<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">
  
  
  <title>守护进程和线程 | YanChen</title>
  <meta name="description" content="守护进程  1.1 守护进程介绍 Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字，如vsftpd Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。  总结守护进程">
<meta name="keywords" content="web安全,网络安全资讯，WEB渗透，数据安全，渗透测试，学习投资，金融理财">
<meta property="og:type" content="article">
<meta property="og:title" content="守护进程和线程">
<meta property="og:url" content="https://xiaowuyoucy.github.io/2022/01/24/linux082守护进程和线程/index.html">
<meta property="og:site_name" content="YanChen">
<meta property="og:description" content="守护进程  1.1 守护进程介绍 Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字，如vsftpd Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。  总结守护进程">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://xiaowuyoucy.github.io/images/javawz/image-20220124220938860.png">
<meta property="og:image" content="https://xiaowuyoucy.github.io/images/javawz/image-20220124231226369.png">
<meta property="og:image" content="https://xiaowuyoucy.github.io/images/javawz/image-20220124231358842.png">
<meta property="og:image" content="https://xiaowuyoucy.github.io/images/javawz/image-20220124232632703.png">
<meta property="og:image" content="https://xiaowuyoucy.github.io/images/javawz/image-20220124232651711.png">
<meta property="og:image" content="https://xiaowuyoucy.github.io/images/javawz/image-20220124232725306.png">
<meta property="og:image" content="https://xiaowuyoucy.github.io/images/javawz/image-20220128210559848.png">
<meta property="og:image" content="https://xiaowuyoucy.github.io/images/javawz/image-20220128210619983.png">
<meta property="og:image" content="https://xiaowuyoucy.github.io/images/javawz/image-20220128210754455.png">
<meta property="og:image" content="https://xiaowuyoucy.github.io/images/javawz/image-20220128210816722.png">
<meta property="og:image" content="https://xiaowuyoucy.github.io/images/javawz/image-20220128211719750.png">
<meta property="og:updated_time" content="2022-01-29T19:12:09.139Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="守护进程和线程">
<meta name="twitter:description" content="守护进程  1.1 守护进程介绍 Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字，如vsftpd Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。  总结守护进程">
<meta name="twitter:image" content="https://xiaowuyoucy.github.io/images/javawz/image-20220124220938860.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://xiaowuyoucy.github.io/2022/01/24/linux082守护进程和线程/index.html">
  
    <link rel="alternate" href="/atom.xml" title="YanChen" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/fonts2/iconfont.css">
  
  
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css">
  
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/xiaowuyoucy" target="_blank">
          <img class="img-circle img-rotate" src="/images/logo.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">YanChen</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> GuangZhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索">
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech>
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-navigation">
          <a href="https://www.xiaochenyan.top/navigation/index.html">
            
            <i class="icon icon-map-marker"></i>
            
            <span class="menu-title">导航</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-movies">
          <a href="/movies">
            
            <i class="icon iconfont icon-video"></i>
            
            <span class="menu-title">电影</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/xiaowuyoucy" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">格言</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
				
				<p id="hitokoto">:D 获取中...</p>
				<p id="from" style="text-align: right"></p>
                <script>
					  var xhr = new XMLHttpRequest();
					  xhr.open('get', 'https://v1.hitokoto.cn');
					  xhr.onreadystatechange = function () {
						if (xhr.readyState === 4) {
						  var data = JSON.parse(xhr.responseText);
						  var hitokoto = document.getElementById('hitokoto');
						  hitokoto.innerText = data.hitokoto;
						  var from = document.getElementById('from');
						  from.innerText = "-- " + data.from;
						}
					  }
					  xhr.send();
				</script>
				
				
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML-CSS/">HTML/CSS</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">195</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/KaliLinux/">KaliLinux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MYSQL/">MYSQL</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenSSL/">OpenSSL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RHCE/">RHCE</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB安全渗透/">WEB安全渗透</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows命令/">Windows命令</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows网络编程/">Windows网络编程</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/apache/">apache</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">106</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp17从入门到精通/">cpp17从入门到精通</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/githubHexo/">githubHexo</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/libevent/">libevent</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">94</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/windows程序设计/">windows程序设计</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/windows程序设计2/">windows程序设计2</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术资讯/">技术资讯</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">38</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/易语言/">易语言</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/汇编逆向/">汇编逆向</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/理财投资/">理财投资</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/简谈计算机/">简谈计算机</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程开发/">编程开发</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程词汇/">编程词汇</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议/">网络协议</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络爬虫/">网络爬虫</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机公共基础/">计算机公共基础</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络TCP-IP传输协议-网络抓包/">计算机网络TCP/IP传输协议/网络抓包</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络原理/">计算机网络原理</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/高中数学/">高中数学</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GET/">$_GET</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/POST，-SERVER/">$_POST，$_SERVER</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/REQUEST/">$_REQUEST</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cookie/">Cookie</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GOTO语句/">GOTO语句</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang函数/">Golang函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang匿名函数/">Golang匿名函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang基础/">Golang基础</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang基础类型占位符/">Golang基础类型占位符</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang常量与变量里表达式/">Golang常量与变量里表达式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang循环结构/">Golang循环结构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang指针/">Golang指针</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang标准输入与输出/">Golang标准输入与输出</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang流程控制/">Golang流程控制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang程序运算/">Golang程序运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang类型转换及移位运算/">Golang类型转换及移位运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang闭包函数/">Golang闭包函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ISO七层模型/">ISO七层模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java总结/">Java总结</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kalinux/">Kalinux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Null和Undefined/">Null和Undefined</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP两种定义常量的形式/">PHP两种定义常量的形式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP常量/">PHP常量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python教程/">Python教程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python笔记/">Python笔记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python运算符/">Python运算符</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEO网站优化/">SEO网站优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XSS/">XSS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DIR/">__DIR__</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FILE/">__FILE__</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LINE/">__LINE__</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache环境变量/">apache环境变量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache配置/">apache配置</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/beef劫持/">beef劫持</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dowhile循环/">dowhile循环</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iota定义常量组/">iota定义常量组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript函数/">javascript函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js-this方法/">js-this方法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js布尔类型隐私转换/">js布尔类型隐私转换</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux目录结构/">linux目录结构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php变量/">php变量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql注入/">sql注入</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/urlib2/">urlib2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web安全渗透/">web安全渗透</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web渗透/">web渗透</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/变量的操作/">变量的操作</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/延时执行defer/">延时执行defer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉格狼日/">拉格狼日</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/时间复杂度测试/">时间复杂度测试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/理财，投资/">理财，投资</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络模型/">网络模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机基础/">计算机基础</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/顺序表/">顺序表</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/GET/" style="font-size: 13px;">$_GET</a> <a href="/tags/POST，-SERVER/" style="font-size: 13px;">$_POST，$_SERVER</a> <a href="/tags/REQUEST/" style="font-size: 13px;">$_REQUEST</a> <a href="/tags/Cookie/" style="font-size: 13px;">Cookie</a> <a href="/tags/GOTO语句/" style="font-size: 13px;">GOTO语句</a> <a href="/tags/Golang/" style="font-size: 13px;">Golang</a> <a href="/tags/Golang函数/" style="font-size: 13px;">Golang函数</a> <a href="/tags/Golang匿名函数/" style="font-size: 13px;">Golang匿名函数</a> <a href="/tags/Golang基础/" style="font-size: 14px;">Golang基础</a> <a href="/tags/Golang基础类型占位符/" style="font-size: 13px;">Golang基础类型占位符</a> <a href="/tags/Golang常量与变量里表达式/" style="font-size: 13px;">Golang常量与变量里表达式</a> <a href="/tags/Golang循环结构/" style="font-size: 13px;">Golang循环结构</a> <a href="/tags/Golang指针/" style="font-size: 13px;">Golang指针</a> <a href="/tags/Golang标准输入与输出/" style="font-size: 13px;">Golang标准输入与输出</a> <a href="/tags/Golang流程控制/" style="font-size: 13px;">Golang流程控制</a> <a href="/tags/Golang程序运算/" style="font-size: 13px;">Golang程序运算</a> <a href="/tags/Golang类型转换及移位运算/" style="font-size: 13px;">Golang类型转换及移位运算</a> <a href="/tags/Golang闭包函数/" style="font-size: 13px;">Golang闭包函数</a> <a href="/tags/ISO七层模型/" style="font-size: 13px;">ISO七层模型</a> <a href="/tags/Java总结/" style="font-size: 13px;">Java总结</a> <a href="/tags/Kalinux/" style="font-size: 13px;">Kalinux</a> <a href="/tags/Null和Undefined/" style="font-size: 13px;">Null和Undefined</a> <a href="/tags/PHP两种定义常量的形式/" style="font-size: 13px;">PHP两种定义常量的形式</a> <a href="/tags/PHP常量/" style="font-size: 13px;">PHP常量</a> <a href="/tags/Python教程/" style="font-size: 13px;">Python教程</a> <a href="/tags/Python笔记/" style="font-size: 13px;">Python笔记</a> <a href="/tags/Python运算符/" style="font-size: 13px;">Python运算符</a> <a href="/tags/SEO网站优化/" style="font-size: 13px;">SEO网站优化</a> <a href="/tags/XSS/" style="font-size: 14px;">XSS</a> <a href="/tags/DIR/" style="font-size: 13px;">__DIR__</a> <a href="/tags/FILE/" style="font-size: 13px;">__FILE__</a> <a href="/tags/LINE/" style="font-size: 13px;">__LINE__</a> <a href="/tags/apache环境变量/" style="font-size: 13px;">apache环境变量</a> <a href="/tags/apache配置/" style="font-size: 13px;">apache配置</a> <a href="/tags/beef劫持/" style="font-size: 13px;">beef劫持</a> <a href="/tags/dowhile循环/" style="font-size: 13px;">dowhile循环</a> <a href="/tags/iota定义常量组/" style="font-size: 13px;">iota定义常量组</a> <a href="/tags/javascript函数/" style="font-size: 13px;">javascript函数</a> <a href="/tags/js-this方法/" style="font-size: 13px;">js-this方法</a> <a href="/tags/js布尔类型隐私转换/" style="font-size: 13px;">js布尔类型隐私转换</a> <a href="/tags/linux目录结构/" style="font-size: 13px;">linux目录结构</a> <a href="/tags/php变量/" style="font-size: 13px;">php变量</a> <a href="/tags/sql注入/" style="font-size: 13px;">sql注入</a> <a href="/tags/urlib2/" style="font-size: 13px;">urlib2</a> <a href="/tags/web安全渗透/" style="font-size: 13px;">web安全渗透</a> <a href="/tags/web渗透/" style="font-size: 13px;">web渗透</a> <a href="/tags/变量的操作/" style="font-size: 13px;">变量的操作</a> <a href="/tags/延时执行defer/" style="font-size: 13px;">延时执行defer</a> <a href="/tags/拉格狼日/" style="font-size: 13px;">拉格狼日</a> <a href="/tags/时间复杂度测试/" style="font-size: 13px;">时间复杂度测试</a> <a href="/tags/理财，投资/" style="font-size: 13px;">理财，投资</a> <a href="/tags/算法/" style="font-size: 13px;">算法</a> <a href="/tags/网络模型/" style="font-size: 13px;">网络模型</a> <a href="/tags/计算机基础/" style="font-size: 13px;">计算机基础</a> <a href="/tags/顺序表/" style="font-size: 13px;">顺序表</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">52</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">87</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">37</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">51</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">125</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">106</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">九月 2014</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/cpp/">cpp</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/23/封装ASN1类-工厂模式和单向散列函数/" class="title">封装ASN1类、工厂模式和单向散列函数</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-22T18:01:12.000Z" itemprop="datePublished">2022-05-23</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/cpp/">cpp</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/21/UML类图-常见的报文编码方式-ASN1报文编解码-vs连接linux服务器/" class="title">UML类图_常见的报文编码方式_ASN1报文编解码_vs连接linux服务器</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-21T03:32:04.000Z" itemprop="datePublished">2022-05-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Git/">Git</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/17/Git教程/" class="title">Git教程</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-17T14:55:09.000Z" itemprop="datePublished">2022-05-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/cpp/">cpp</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/17/项目介绍和部署/" class="title">项目介绍和部署</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-17T14:36:46.000Z" itemprop="datePublished">2022-05-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/OpenSSL/">OpenSSL</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/17/OpenSSL安装和配置/" class="title">OpenSSL安装和配置</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-16T23:12:06.000Z" itemprop="datePublished">2022-05-17</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-linux082守护进程和线程" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      守护进程和线程
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/01/24/linux082守护进程和线程/" class="article-date">
	  <time datetime="2022-01-24T12:30:39.000Z" itemprop="datePublished">2022-01-24</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/01/24/linux082守护进程和线程/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 8.6k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 35(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="守护进程"><a class="markdownIt-Anchor" href="#守护进程"></a> 守护进程</h2>
<h3 id="11-守护进程介绍"><a class="markdownIt-Anchor" href="#11-守护进程介绍"></a> 1.1 守护进程介绍</h3>
<p>Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字，如vsftpd</p>
<p>Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。</p>
<ul>
<li>总结守护进程的特点：
<ul>
<li>Linux后台服务进程</li>
<li>独立于控制终端</li>
<li>周期性的执行某种任务</li>
<li>不受用户登陆和注销的影响</li>
<li>一般采用以d结尾的名字</li>
</ul>
</li>
</ul>
<h3 id="12-进程组和会话"><a class="markdownIt-Anchor" href="#12-进程组和会话"></a> 1.2 进程组和会话</h3>
<ul>
<li>
<p>进程组</p>
<ul>
<li>进程组是一个或者多个进程的集合，每个进程都属于一个进程组，引入进程组是为了简化对进程的管理。当父进程创建子进程的时候，默认子进程与父进程属于同一个进程组。</li>
<li>进程组ID==第一个进程ID（组长进程）。如父进程创建了多个子进程，父进程和多个子进程同属于一个组，而由于父进程是进程组里的第一个进程，所以父进程就是这个组的组长, 组长ID==父进程ID。</li>
<li>可以使用kill -SIGKILL -进程组ID(负的)来将整个进程组内的进程全部杀死。</li>
<li>只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</li>
<li>进程组生存期：从进程组创建到最后一个进程离开</li>
</ul>
</li>
<li>
<p>会话</p>
<ul>
<li>一个会话是一个或多个进程组的集合。</li>
<li>创建会话的进程不能是进程组组长</li>
<li>创建会话的进程成为一个进程组的组长进程，同时也成为会话的会长。</li>
<li>需要有root权限（ubuntu不需要）</li>
<li>新创建的会话丢弃原有的控制终端</li>
<li>建立新会话时，先调用fork, 父进程终止，子进程调用setsid函数</li>
<li>可以使用<code>ps ajx</code>来查看进程组ID和会话ID</li>
<li>可以fork出几个子进程，然后查看进程组ID和会话ID</li>
</ul>
</li>
<li>
<p>进程组和会话的关系图</p>
<p><img src="/images/javawz/image-20220124220938860.png" alt="image-20220124220938860"></p>
</li>
</ul>
<h3 id="13-创建守护进程的模型"><a class="markdownIt-Anchor" href="#13-创建守护进程的模型"></a> 1.3 创建守护进程的模型</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t setsid(void);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功后，将返回调用进程的（新）会话ID。一旦出错，</span><br><span class="line">返回（pid_t）-1，并设置errno以指示错误。</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>第1步：fork子进程，父进程退出</p>
<ul>
<li>子进程继承了父进程的进程组ID, 但具有一个新的进程ID,这样就保证了子进程不是一个进程组的组长ID,这对于下面要做的setsid函数的调用是必要的前提条件</li>
</ul>
</li>
<li>
<p>第2步：子进程调用setsid函数创建新会话</p>
<ul>
<li>调用这个函数以后</li>
<li>该进程成为新会话的首进程，是会话的会长</li>
<li>成为一个新进程组的组长进程，是进程组组长</li>
<li>不受控制终端的影响</li>
</ul>
</li>
<li>
<p>第3步：改变当前工作目录<code>chdir</code></p>
<ul>
<li>如：a.out在U盘上，启动这个程序，这个程序的当前的工作目录就是这个u盘，如果u盘拔掉后进程的当前工作目录将消失，a.out将不能正常工作。</li>
</ul>
</li>
<li>
<p>第4步：重设文件掩码  <code>mode &amp; ~umask</code></p>
<ul>
<li>子进程会继承父进程的掩码</li>
<li>增加子进程程序操作的灵活性</li>
<li><code>umask(0000);</code>最右边的0代表八进制</li>
</ul>
</li>
<li>
<p>第5步：关闭文件描述符</p>
<ul>
<li>守护进程不受控制终端的影响所以可以关闭，以释放资源</li>
<li><code>close(STDIN_FILENO);</code></li>
<li><code>close(STDOUT_FILENO);</code></li>
<li><code>close(STDERR_FILENO);</code></li>
</ul>
</li>
<li>
<p>第6步：执行核心工作</p>
<ul>
<li>守护进程的核心代码逻辑</li>
</ul>
</li>
</ul>
<h3 id="14练习"><a class="markdownIt-Anchor" href="#14练习"></a> 1.4练习</h3>
<p>​	编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。</p>
<p>分析：首先要按照1.3介绍的守护进行的步骤创建一个守护进程</p>
<p>题目要求每隔2S钟，所以需要一个定时器，2S钟触发一次，需要调用<code>setitimer</code>函数创建一个定时器，并且要捕获SIGALRM信号，然后在SIGALRM信号处理函数里面完成获取系统时间，然后将时间写入文件。</p>
<ul>
<li>用到的主要知识点：
<ul>
<li>创建守护进程的模型</li>
<li>setitimer函数的使用</li>
<li>sigaction函数</li>
<li>文件I/O操作</li>
<li>获取系统时间函数time，将<code>time_t</code>类型转换为字符串ctime函数</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建守护进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//打开文件</span></span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">"mydemon.log"</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0755</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取当前的系统时间</span></span><br><span class="line">	<span class="keyword">time_t</span> t;</span><br><span class="line">	time(&amp;t);</span><br><span class="line">    <span class="comment">//将时间转换为字符串形式</span></span><br><span class="line">	<span class="keyword">char</span> *p = ctime(&amp;t);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将时间写入文件</span></span><br><span class="line">	write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//父进程fork子进程, 然后父进程退出</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&lt;<span class="number">0</span> || pid&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//子进程调用setsid函数创建会话</span></span><br><span class="line">	setsid();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//改变当前的工作目录</span></span><br><span class="line">	chdir(<span class="string">"/home/itcast/log"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//改变文件掩码</span></span><br><span class="line">	umask(<span class="number">0000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭标准输入,输出和错误输出文件描述符</span></span><br><span class="line">	close(STDIN_FILENO);</span><br><span class="line">	close(STDOUT_FILENO);</span><br><span class="line">	close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//核心操作</span></span><br><span class="line">	<span class="comment">//注册信号处理函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">	act.sa_handler = myfunc;</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);	</span><br><span class="line">	sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置时钟</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tm</span>;</span></span><br><span class="line">	tm.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">	tm.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	tm.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">	tm.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	setitimer(ITIMER_REAL, &amp;tm, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化:<br>
 1 不再频繁的打开和关闭文件<br>
 	2 如何控制log文件大小  test.log</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写守护进程: 每隔2秒获取一次系统时间,并将时间写入文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获取当前系统时间</span></span><br><span class="line">	<span class="keyword">time_t</span> tm;</span><br><span class="line">	time(&amp;tm);</span><br><span class="line">	<span class="keyword">char</span> *p = ctime(&amp;tm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//新建文件</span></span><br><span class="line">		fd = open(<span class="string">"./mydaemon.log"</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0777</span>);</span><br><span class="line">		<span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"open error"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写文件</span></span><br><span class="line">	write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//fork子进程，父进程退出</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&lt;<span class="number">0</span> || pid&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子进程调用setsid函数创建新会话</span></span><br><span class="line">	setsid();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//改变当前工作目录chdir</span></span><br><span class="line">	chdir(<span class="string">"/home/itcast"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重设文件掩码</span></span><br><span class="line">	umask(<span class="number">0000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭标准输入,标准输出, 标准错误输出这三个文件描述符</span></span><br><span class="line">	close(STDIN_FILENO);</span><br><span class="line">	close(STDOUT_FILENO);</span><br><span class="line">	close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//核心工作</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">	act.sa_handler = sighandler;</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用setitimer函数设置时钟</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tm</span>;</span></span><br><span class="line">	tm.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">	tm.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	tm.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">	tm.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	setitimer(ITIMER_REAL, &amp;tm, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取文件大小</span></span><br><span class="line">		<span class="keyword">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">		<span class="keyword">if</span>(size&gt;<span class="number">100</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			close(fd);</span><br><span class="line">            <span class="comment">//文件重命名</span></span><br><span class="line">			rename(<span class="string">"./mydaemon.log"</span>, <span class="string">"./mydaemon.log.bak"</span>);</span><br><span class="line">			flag =<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
守护进程的特点:
	&emsp;1 一个linux后台服务进程
	&emsp;2 不依赖于控制终端
	&emsp;3 周期性执行某些任务
&emsp;	4 不受用户登录和注销的影响
&emsp;	5 一般以d结尾
<p>进程组和会话:<br>
 进程组: 一个进程包含多个进程<br>
 会话: 多个组组成一个会话.<br>
 创建会话的进程不能是组长进程;<br>
 	一般创建会话是父进程先fork子进程, 然后父进程退出, 让子进程调用setsid函数<br>
 	创建一个会话, 这个子进程既是会长也是组长;<br>
 	只要是创建了会话, 这个进程就脱离了控制终端的影响.</p>
<p>创建守护进程模型:<br>
1 父进程fork子进程, 然后父进程退出.<br>
目的是: 子进程肯定不是组长进程, 为后续调用setsid函数提供了条件.<br>
2 子进程调用setsid函数创建一个新的会话.<br>
  1 该子进程成了该会话的会长<br>
  2 该子进程成了该组的组长进程.<br>
  	3 不再受控制终端的影响了<br>
3 改变当前的工作目录, chdir  -----不是必须的<br>
4 重设文件掩码, umask(0000)  -----不是必须的<br>
5 关闭<code>STDIN_FILENO STDOUT_FILENO STDERR_FILENO</code>  —不是必须的<br>
6 核心操作</p>
<h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2>
<ul>
<li>
<h3 id="21-什么是线程"><a class="markdownIt-Anchor" href="#21-什么是线程"></a> 2.1 什么是线程</h3>
<ul>
<li>轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。</li>
<li>进程：拥有独立的地址空间，拥有PCB，相当于独居。</li>
<li>线程：有PCB，但没有独立的地址空间，多个线程共享进程空间，相当于合租。</li>
</ul>
</li>
</ul>
<p><img src="/images/javawz/image-20220124231226369.png" alt="image-20220124231226369"></p>
<ul>
<li>
<p>在Linux操作系统下：</p>
<ul>
<li>线程：最小的执行单位</li>
<li>进程：最小分配资源单位，可看成是只有一个线程的进程。</li>
</ul>
</li>
<li>
<p>线程的特点</p>
<ul>
<li>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</li>
<li>线程是轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</li>
<li>从内核里看进程和线程是一样的，都有各自不同的PCB.</li>
<li>进程可以蜕变成线程</li>
<li>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</li>
</ul>
</li>
</ul>
<p><img src="/images/javawz/image-20220124231358842.png" alt="image-20220124231358842"></p>
<ul>
<li>查看指定线程的LWP号：<code>ps –Lf pid</code></li>
<li>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数 clone。</li>
<li>如果复制对方的地址空间，那么就产出一个“进程”；</li>
<li>如果共享对方的地址空间，就产生一个“线程”。</li>
</ul>
<p>so：<strong>Linux内核是不区分进程和线程的, 只在用户层面上进行区分</strong>。</p>
<p>所以，线程所有操作函数<code>pthread_*</code> 是库函数，而非系统调用。</p>
<h3 id="22-线程共享资源"><a class="markdownIt-Anchor" href="#22-线程共享资源"></a> 2.2 线程共享资源</h3>
<ul>
<li>文件描述符表</li>
<li>每种信号的处理方式</li>
<li>当前工作目录</li>
<li>用户ID和组ID</li>
<li>内存地址空间 (<code>.text/.data/.bss/heap/共享库</code>)</li>
</ul>
<h3 id="23-线程非共享资源"><a class="markdownIt-Anchor" href="#23-线程非共享资源"></a> 2.3 线程非共享资源</h3>
<ul>
<li>线程id</li>
<li>处理器现场和栈指针(内核栈)</li>
<li>独立的栈空间(用户空间栈)</li>
<li>errno变量</li>
<li>信号屏蔽字</li>
<li>调度优先级</li>
</ul>
<h3 id="24-线程优-缺点"><a class="markdownIt-Anchor" href="#24-线程优-缺点"></a> 2.4  线程优、缺点</h3>
<ul>
<li>优点：
<ul>
<li>提高程序并发性</li>
<li>开销小</li>
<li>数据通信、共享数据方便</li>
</ul>
</li>
<li>缺点：
<ul>
<li>库函数，不稳定</li>
<li>gdb调试、编写困难</li>
<li>对信号支持不好</li>
</ul>
</li>
</ul>
<p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p>
<h3 id="25-pthread_create函数"><a class="markdownIt-Anchor" href="#25-pthread_create函数"></a> 2.5  pthread_create函数</h3>
<ul>
<li>头文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数作用：</li>
<li>创建一个新线程</li>
<li>函数原型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread, </span><br><span class="line"></span><br><span class="line">				const pthread_attr_t *attr,</span><br><span class="line"></span><br><span class="line">	      		void *(*start_routine) (void *),</span><br><span class="line"></span><br><span class="line">				 void *arg</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>返回值</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回错误号</li>
</ul>
</li>
<li>
<p>函数参数：</p>
<ul>
<li><code>pthread_t</code>：传出参数，保存系统为我们分配好的线程ID</li>
<li>当前Linux中可理解为：<code>typedef unsigned long int pthread_t</code>。</li>
<li>attr：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。</li>
<li><code>start_routine</code>：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。</li>
<li>arg：线程主函数执行期间所使用的参数。</li>
</ul>
</li>
<li>
<p>注意点</p>
<ul>
<li>由于<code>pthread_create</code>的错误码不保存在errno中，因此不能直接用<code>perror()</code>打印错误信息，可以先用<code>strerror()</code>把错误码转换成错误信息再打印。<code>strerror要包含头文件#include&lt;string.h&gt;</code></li>
<li>如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。</li>
</ul>
</li>
<li>
<p>练习题：</p>
</li>
</ul>
<p>1 编写程序创建一个线程。</p>
<br>
<br>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_t pthread_self(void);</span><br><span class="line"></span><br><span class="line">函数作用：获得线程自身的ID。pthread_t的类型为unsigned long int，所以在打印的时候要使用%lu方式，否则显示结果出问题。</span><br><span class="line"></span><br><span class="line">pthread_self() 	//获取当前线程id</span><br></pre></td></tr></table></figure>
<br>
<h4 id="多线程编译是要指定库"><a class="markdownIt-Anchor" href="#多线程编译是要指定库"></a> 多线程编译是要指定库</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc xxx.c -l pthread -o xxx</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line">	<span class="comment">//创建子线程</span></span><br><span class="line">	<span class="keyword">pthread_t</span> thread;</span><br><span class="line">	<span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p>2 编写程序创建一个线程，并给线程传递一个<code>int</code>参数</p>
<p>3 编写程序创建一个线程，并给线程传递一个结构体参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程: 传递参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int n = *(int *)arg;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Test</span> *<span class="title">p</span> = (<span class="title">struct</span> <span class="title">Test</span> *)<span class="title">arg</span>;</span></span><br><span class="line">	<span class="comment">//struct Test *p = arg;</span></span><br><span class="line">	<span class="comment">//printf("n==[%d]\n", n);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[%d][%s]\n"</span>, p-&gt;data, p-&gt;name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">99</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;t, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(struct Test));</span><br><span class="line">	t.data = <span class="number">88</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(t.name, <span class="string">"xiaowen"</span>);	</span><br><span class="line">	<span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line">	<span class="comment">//创建子线程</span></span><br><span class="line">	<span class="keyword">pthread_t</span> thread;</span><br><span class="line">	<span class="comment">//int ret = pthread_create(&amp;thread, NULL, mythread, &amp;n);</span></span><br><span class="line">	<span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, &amp;t);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 编写程序，主线程循环创建5个子线程，并让子线程判断自己是第几个子线程。</p>
<p>练习4分析：最后每个子线程打印出来的值并不是想象中的值，比如都是5，分析其原因：</p>
<p>在创建子线程的时候使用循环因子作为参数传递给子线程，这样主线程和多个子线程就会共享变量i（变量i在main函数中定义，在整个进程都一直有效）所以在子线程看来变量i是合法的栈内存空间。</p>
<p>那么为什么最后每个子线程打印出来的值都是5呢?</p>
<p>是由于主线程可能会在一个cpu时间片内连续创建了5个子线程，此时变量i的值变成了5，当主线程失去cpu的时间片后，子线程得到cpu的时间片，子线程访问的是变量i的内存空间的值，所以打印出来值为5.</p>
<p><img src="/images/javawz/image-20220124232632703.png" alt="image-20220124232632703"></p>
<p>主线程和子线程共享同一块内存空间</p>
<p><img src="/images/javawz/image-20220124232651711.png" alt="image-20220124232651711"></p>
<p>主线程和子线程分时使用cpu资源</p>
<p>解决办法：不能使多个子线程都共享同一块内存空间，应该使每个子线程访问不同的内存空间，可以在主线程定义一个数组：<code>int arr[5];</code>，然后创建线程的时候分别传递不同的数组元素，这样每个子线程访问的就是互不相同的内存空间，这样就可以打印正确的值。</p>
<p>如下图：</p>
<p><img src="/images/javawz/image-20220124232725306.png" alt="image-20220124232725306"></p>
<p>多个子线程各自访问不同的内存空间</p>
<ul>
<li>根据测试程序还可以得出结论：
<ul>
<li>如果主线程早于子线程退出，则子线程可能得不到执行，因为主线程退出，整个进程空间都会被回收，子线程没有了生存空间，所以也就得不到执行。</li>
<li>线程之间（包含主线程和子线程）可以共享同一变量，包含全局变量或者非全局变量（但是非全局变量必须在其有效的生存期内）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环创建子线程,并且打印是第几个子线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = *(<span class="keyword">int</span> *)arg;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[%d]:child thread, pid==[%d], id==[%ld]\n"</span>, i, getpid(), pthread_self());</span><br><span class="line">	sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">	<span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line">	<span class="comment">//创建子线程</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">pthread_t</span> thread[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i;</span><br><span class="line">		ret = pthread_create(&amp;thread[i], <span class="literal">NULL</span>, mythread, &amp;arr[i]);</span><br><span class="line">		<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">	sleep(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26pthread_exit函数"><a class="markdownIt-Anchor" href="#26pthread_exit函数"></a> 2.6pthread_exit函数</h3>
<p>在线程中禁止调用exit函数，否则会导致整个进程退出，取而代之的是调用<code>pthread_exit</code>函数，这个函数是使一个线程退出，如果主线程调用<code>pthread_exit</code>函数也不会使整个进程退出，不影响其他线程的执行。</p>
<ul>
<li>
<p>函数描述</p>
<ul>
<li>将单个线程退出</li>
</ul>
</li>
<li>
<p>函数原型</p>
<ul>
<li><code>void pthread_exit(void *retval);</code></li>
</ul>
</li>
<li>
<p>函数参数</p>
<ul>
<li>retval表示线程退出状态，通常传NULL</li>
</ul>
</li>
</ul>
<p>另注意，<code>pthread_exit</code>或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了，栈空间就会被回收。</p>
<p>练习：编写程序测试<code>pthread_exit</code>函数使一个线程退出。</p>
<p>通过程序测试得知，<code>pthread_exit</code>函数只是使一个线程退出，假如子线程里面调用了exit函数，会使整个进程终止；如果主线程调用了<code>pthread_exit</code>函数，并不影响子线程，只是使主线程自己退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程退出函数测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> g_var = <span class="number">9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">	<span class="comment">//printf("[%p]\n", &amp;g_var);</span></span><br><span class="line">	<span class="comment">//pthread_exit(&amp;g_var);</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;t, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line">	t.data = <span class="number">99</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(t.name, <span class="string">"xiaowen"</span>);</span><br><span class="line">	pthread_exit(&amp;t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line">	<span class="comment">//创建子线程</span></span><br><span class="line">	<span class="keyword">pthread_t</span> thread;</span><br><span class="line">	<span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回收子线程</span></span><br><span class="line">	<span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	pthread_join(thread, &amp;p);	</span><br><span class="line">	<span class="comment">//int n = *(int *)p;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Test</span> *<span class="title">pt</span> = (<span class="title">struct</span> <span class="title">Test</span> *)<span class="title">p</span>;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child exit status:[%d],[%s],[%p]\n"</span>,  pt-&gt;data, pt-&gt;name, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="27-pthread_join函数"><a class="markdownIt-Anchor" href="#27-pthread_join函数"></a> 2.7 pthread_join函数</h3>
<ul>
<li>
<p>函数描述：阻塞等待线程退出，获取线程退出状态。其作用，对应进程中的waitpid() 函数。</p>
</li>
<li>
<p>函数原型：<code>int pthread_join(pthread_t thread, void **retval);</code></p>
</li>
<li>
<p>函数返回值：</p>
<ul>
<li>成功：0；</li>
<li>失败：错误号</li>
</ul>
</li>
<li>
<p>函数参数：</p>
<ul>
<li>thread：线程ID</li>
<li>retval：存储线程结束状态，整个指针和<code>pthread_exit</code>的参数是同一块内存地址。</li>
</ul>
</li>
</ul>
<p>练习：编写程序，使主线程获取子线程的退出状态。</p>
<p>一般先定义<code>void *ptr; 然后pthread_join(threadid, &amp;ptr);</code></p>
<h3 id="28-pthread_detach函数"><a class="markdownIt-Anchor" href="#28-pthread_detach函数"></a> 2.8 pthread_detach函数</h3>
<p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p>
<p>进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</p>
<p>也可使用 pthread_create函数参2(线程属性)来设置线程分离。<code>pthread_detach</code>函数是在创建线程之后调用的。</p>
<ul>
<li>函数描述
<ul>
<li>实现线程分离</li>
</ul>
</li>
<li>函数原型
<ul>
<li><code>int pthread_detach(pthread_t thread);</code></li>
</ul>
</li>
<li>函数返回值
<ul>
<li>成功：0；</li>
<li>失败：错误号</li>
</ul>
</li>
</ul>
<p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用<code>pthread_ join</code>获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。不能对一个已经处于detach状态的线程调用<code>pthread_ join</code>，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了<code>pthread_detach</code>就不能再调用<code>pthread_ join</code>了。</p>
<p>练习：编写程序，在创建线程之后设置线程的分离状态。</p>
<p>说明：如果线程已经设置了分离状态，则再调用<code>pthread_ join</code>就会失败，可用这个方法验证是否已成功设置分离状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置子线程为分离属性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">	sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line">	<span class="comment">//创建子线程</span></span><br><span class="line">	<span class="keyword">pthread_t</span> thread;</span><br><span class="line">	<span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置线程为分离属性</span></span><br><span class="line">	pthread_detach(thread);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子线程设置分离属性,则pthread_join不再阻塞,立刻返回</span></span><br><span class="line">	ret = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_join error:[%s]\n"</span>, strerror(ret));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="29-pthread_cancel函数"><a class="markdownIt-Anchor" href="#29-pthread_cancel函数"></a> 2.9 pthread_cancel函数</h3>
<ul>
<li>
<p>函数描述</p>
</li>
<li>
<p>杀死(取消)线程。其作用，对应进程中 kill() 函数。</p>
</li>
<li>
<p>函数原型</p>
</li>
<li>
<p><code>int pthread_cancel(pthread_t thread);</code></p>
</li>
<li>
<p>函数返回值</p>
</li>
<li>
<p>成功：0；</p>
</li>
<li>
<p>失败：错误号</p>
</li>
<li>
<p>【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。</p>
</li>
<li>
<p>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</p>
</li>
<li>
<p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write… 执行命令<code>man 7 pthreads</code>可以查看具备这些取消点的系统调用列表。可粗略认为一个系统调用(进入内核)即为一个取消点。还以通过调用<code>pthread_testcancel</code>函数设置一个取消点。</p>
<ul>
<li>函数原型：<code>void pthread_testcancel(void);</code></li>
</ul>
</li>
</ul>
<p>练习：编写程序，让主线程取消子线程的执行。</p>
<p>先测试一下没有取消点看看能否使线程取消；然后调用<code>pthread_testcancel</code>设置一个取消点，看看能够使线程取消。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置取消点</span></span><br><span class="line">		<span class="comment">//pthread_testcancel();</span></span><br><span class="line">		<span class="comment">//printf也有取消点</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-----\n"</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line">	<span class="comment">//创建子线程</span></span><br><span class="line">	<span class="keyword">pthread_t</span> thread;</span><br><span class="line">	<span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取消子线程</span></span><br><span class="line">	pthread_cancel(thread);</span><br><span class="line"></span><br><span class="line">	pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="210-pthread_equal函数"><a class="markdownIt-Anchor" href="#210-pthread_equal函数"></a> 2.10 pthread_equal函数</h3>
<ul>
<li>函数描述：</li>
<li>比较两个线程ID是否相等。</li>
<li>函数原型</li>
<li><code>int pthread_equal(pthread_t t1, pthread_t t2);</code></li>
</ul>
<p>注意：这个函数是为了以能够扩展使用的， 有可能Linux在未来线程ID <code>pthread_t</code>类型被修改为结构体实现。</p>
<h3 id="211-进程函数和线程函数比较"><a class="markdownIt-Anchor" href="#211-进程函数和线程函数比较"></a> 2.11 进程函数和线程函数比较</h3>
<table>
<thead>
<tr>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>fork</strong></td>
<td><strong>pthread_create</strong></td>
</tr>
<tr>
<td><strong>exit</strong></td>
<td><strong>pthread_exit</strong></td>
</tr>
<tr>
<td><strong>wait/waitpid</strong></td>
<td><strong>pthread_join</strong></td>
</tr>
<tr>
<td><strong>kill</strong></td>
<td><strong>pthread_cancel</strong></td>
</tr>
<tr>
<td><strong>getpid</strong></td>
<td><strong>pthread_self</strong></td>
</tr>
</tbody>
</table>
<p><br><br></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较线程ID是否相等</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line">	<span class="comment">//创建子线程</span></span><br><span class="line">	<span class="keyword">pthread_t</span> thread;</span><br><span class="line">	<span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//比较线程ID</span></span><br><span class="line">	<span class="comment">//if(pthread_equal(thread, pthread_self())!=0)</span></span><br><span class="line">	<span class="keyword">if</span>(pthread_equal(pthread_self(), pthread_self())!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"two thread id is same\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"two thread id is not same\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-线程属性"><a class="markdownIt-Anchor" href="#3-线程属性"></a> 3 线程属性</h3>
<p>linux下线程的属性是可以根据实际项目需要，进行设置，之前讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题，如果对程序的性能提出更高的要求，则需要设置线程属性，本节以设置线程的分离属性为例讲解设置线程属性。</p>
<ul>
<li>
<p>线程的分离状态决定一个线程以什么样的方式来终止自己，有两种状态：</p>
<ul>
<li>非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</li>
<li>分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</li>
</ul>
</li>
<li>
<p>设置线程属性分为以下步骤</p>
</li>
<li>
<p>第1步：定义线程属性类型类型的变量</p>
<ul>
<li><code>pthread_attr_t attr;</code></li>
</ul>
</li>
<li>
<p>第2步：对线程属性变量进行初始化</p>
<ul>
<li><code>int pthread_attr_init (pthread_attr_t* attr);</code></li>
</ul>
</li>
<li>
<p>第3步：设置线程为分离属性</p>
</li>
<li>
<p><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code></p>
<ul>
<li>参数:
<ul>
<li>attr: 线程属性</li>
<li>detachstate:
<ul>
<li><code>PTHREAD_CREATE_DETACHED</code>(分离)</li>
<li><code>PTHREAD_CREATE_JOINABLE</code>（非分离)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意：这一步完成之后调用<code>pthread_create</code>函数创建线程，</p>
<p>则创建出来的线程就是分离线程；其实上述三步就是</p>
<p><code>pthread_create</code>的第二个参数做准备工作。</p>
<ul>
<li>第4步：释放线程属性资源
<ul>
<li><code>int pthread_attr_destroy(pthread_attr_t *attr);</code></li>
<li>参数：线程属性</li>
</ul>
</li>
</ul>
<p>练习：编写程序，创建一个分离属性的线程。</p>
<p>验证：设置为分离属性的线程是不能够被<code>pthread_join</code>函数回收的，</p>
<p>可以通过调用<code>pthread_join</code>函数测试该线程是否已经是分离属性的线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在创建子线程的时候设置分离属性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//定义pthread_attr_t类型的变量</span></span><br><span class="line">	<span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化attr变量</span></span><br><span class="line">	pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置attr为分离属性</span></span><br><span class="line">	pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建子线程</span></span><br><span class="line">	<span class="keyword">pthread_t</span> thread;</span><br><span class="line">	<span class="keyword">int</span> ret = pthread_create(&amp;thread, &amp;attr, mythread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放线程属性</span></span><br><span class="line">	pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//验证子线程是否为分离属性</span></span><br><span class="line">	ret = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_join error:[%s]\n"</span>, strerror(ret));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-线程同步"><a class="markdownIt-Anchor" href="#4-线程同步"></a> 4 线程同步</h3>
<h4 id="41-线程同步的概念"><a class="markdownIt-Anchor" href="#41-线程同步的概念"></a> 4.1 线程同步的概念</h4>
<p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p>
<h4 id="42-线程同步的例子"><a class="markdownIt-Anchor" href="#42-线程同步的例子"></a> 4.2 线程同步的例子</h4>
<p>创建两个线程，让两个线程共享一个全局变量<code>int number</code>， 然后让每个线程数5000次数，看最后打印出这个number值是多少？</p>
<p>线程A代码片段：</p>
<p><img src="/images/javawz/image-20220128210559848.png" alt="image-20220128210559848"></p>
<p>线程B代码片段：</p>
<p><img src="/images/javawz/image-20220128210619983.png" alt="image-20220128210619983"></p>
<ul>
<li>
<p>代码片段说明</p>
<ul>
<li>代码中使用调用usleep是为了让两个子线程能够轮流使用CPU，避免一个子线程在一个时间片内完成5000次数数。</li>
<li>对number执行++操作，使用了中间变量cur是为了尽可能的模拟cpu时间片用完而让出cpu的情况。</li>
</ul>
</li>
<li>
<p>测试结果</p>
<ul>
<li>经过多次测试最后的结果显示，有可能会出现number值少于5000*2=10000的情况。</li>
</ul>
</li>
<li>
<p>分析原因</p>
<ul>
<li>假如子线程A执行完了cur++操作，还没有将cur的值赋值给number失去了cpu的执行权，子线程B得到了cpu执行权，而子线程B最后执行完了number=cur，而后失去了cpu的执行权；此时子线程A又重新得到cpu的执行权，并执行number=cur操作，这样会把线程B刚刚写回number的值被覆盖了，造成number值不符合预期的值。</li>
</ul>
<p><img src="/images/javawz/image-20220128210754455.png" alt="image-20220128210754455"></p>
</li>
<li>
<p>数据混乱的原因</p>
<ul>
<li>资源共享（独享资源则不会）</li>
<li>调度随机（线程操作共享资源的先后顺序不确定）</li>
<li>线程间缺乏必要的同步机制。</li>
</ul>
</li>
</ul>
<p>以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p>
<ul>
<li>
<p>如何解决问题</p>
<ul>
<li>原子操作的概念</li>
</ul>
<p>原子操作指的是该操作要么不做，要么就完成。</p>
<ul>
<li>使用互斥锁解决同步问题</li>
</ul>
<p>使用互斥锁其实是模拟原子操作，互斥锁示意图：</p>
</li>
</ul>
<p>Linux中提供一把互斥锁mutex（也称之为互斥量）。每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p>
<p>资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</p>
<p><img src="/images/javawz/image-20220128210816722.png" alt="image-20220128210816722"></p>
<p>线程1访问共享资源的时候要先判断锁是否锁着，如果锁着就阻塞等待；若锁是解开的就将这把锁加锁，此时可以访问共享资源，访问完成后释放锁，这样其他线程就有机会获得锁。</p>
<p>应该注意：图中同一时刻，只能有一个线程持有该锁，只要该线程未完成操作就不释放锁。</p>
<p>​	使用互斥锁之后，两个线程由并行操作变成了串行操作，效率降低了，但是数据不一致的问题得到解决了。</p>
<h4 id="43互斥锁主要相关函数"><a class="markdownIt-Anchor" href="#43互斥锁主要相关函数"></a> 4.3互斥锁主要相关函数</h4>
<ul>
<li>
<p><code>pthread_mutex_t</code>类型</p>
<ul>
<li>其本质是一个结构体，为简化理解，应用时可忽略其实现细节，简单当成整数看待。</li>
<li><code>pthread_mutex_t mutex;</code>变量mutex只有两种取值1、0。</li>
</ul>
</li>
<li>
<p><code>pthread_mutex_init</code>函数</p>
<ul>
<li>函数描述：
<ul>
<li>初始化一个互斥锁(互斥量) —&gt; 初值可看作1</li>
</ul>
</li>
<li>函数原型：
<ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></li>
</ul>
</li>
<li>函数参数
<ul>
<li>mutex：传出参数，调用时应传<code>&amp;mutex</code></li>
<li>attr：互斥锁属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>restrict关键字</strong>：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改互斥量mutex的两种初始化方式：</p>
<ul>
<li><strong>静态初始化</strong>：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。</li>
<li><code>pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</code></li>
<li><strong>动态初始化</strong>：局部变量应采用动态初始化。</li>
</ul>
</li>
</ul>
<p><code>pthread_mutex_init(&amp;mutex, NULL);</code></p>
<ul>
<li>
<p><code>pthread_mutex_destroy</code>函数</p>
</li>
<li>
<p>函数描述</p>
<ul>
<li>销毁一个互斥锁</li>
</ul>
</li>
<li>
<p>函数原型</p>
<ul>
<li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></li>
</ul>
</li>
<li>
<p>函数参数</p>
<ul>
<li>mutex—互斥锁变量</li>
</ul>
</li>
<li>
<p><code>pthread_mutex_lock</code>函数</p>
<ul>
<li>函数描述
<ul>
<li>对互斥所加锁，可理解为将<code>mutex--</code></li>
</ul>
</li>
<li>函数原型
<ul>
<li><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></li>
</ul>
</li>
<li>函数参数
<ul>
<li>mutex—互斥锁变量</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>pthread_mutex_unlock</code>函数</p>
<ul>
<li>函数描述</li>
<li>对互斥所解锁，可理解为将mutex ++</li>
<li>函数原型</li>
<li><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li>
</ul>
</li>
<li>
<p><code>pthread_mutex_trylock</code>函数</p>
<ul>
<li>函数描述
<ul>
<li>尝试加锁</li>
</ul>
</li>
<li>函数原型
<ul>
<li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></li>
</ul>
</li>
<li>函数参数
<ul>
<li>mutex—互斥锁变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="44-加锁和解锁"><a class="markdownIt-Anchor" href="#44-加锁和解锁"></a> 4.4 加锁和解锁</h4>
<ul>
<li>lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</li>
<li>unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</li>
</ul>
<p>练习：使用互斥锁解决两个线程数数不一致的问题。</p>
<p>代码片段：在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好。</p>
<p><img src="/images/javawz/image-20220128211719750.png" alt="image-20220128211719750"></p>
<p>总结：使用互斥锁之后，两个线程由并行变为了串行，效率降低了，但是可以使两个线程同步操作共享资源，从而解决了数据不一致的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 50000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mythread1</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NUM;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		n = number;</span><br><span class="line">		n++;</span><br><span class="line">		number = n;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"A: [%d]\n"</span>,number);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mythread2</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NUM;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		n = number;</span><br><span class="line">		n++;</span><br><span class="line">		number = n;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"B: [%d]\n"</span>,number);</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> thread1;</span><br><span class="line">	<span class="keyword">pthread_t</span> thread2;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ret1 = pthread_create(&amp;thread1,<span class="literal">NULL</span>,mythread1,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ret1 != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error: [%s]\n"</span>,strerror(ret1));</span><br><span class="line">		<span class="keyword">return</span> ret1;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">int</span> ret2 = pthread_create(&amp;thread2,<span class="literal">NULL</span>,mythread2,<span class="literal">NULL</span>);	</span><br><span class="line">	<span class="keyword">if</span>(ret2 != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error: [%s]\n"</span>,strerror(ret2));</span><br><span class="line">		<span class="keyword">return</span> ret2;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">void</span> *retval1;</span><br><span class="line">	<span class="keyword">void</span> *retval2;</span><br><span class="line">	<span class="keyword">int</span> join_ret = pthread_join(thread1,&amp;retval1);</span><br><span class="line">	<span class="keyword">if</span>(join_ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_join error [%s]\n"</span>,strerror(join_ret));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> join_ret2 = pthread_join(thread2,&amp;retval2);</span><br><span class="line">	<span class="keyword">if</span>(join_ret2 != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_join error [%s]\n"</span>,strerror(join_ret2));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"number [%d]"</span>,number);</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">	pthread_mutex_destroy(&amp;mutex);	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>互斥锁: 线程A和线程B共同访问共享资源, 当线程A想访问共享资源的时候,<br>
要先获得锁, 如果锁被占用, 则加锁不成功需要阻塞等待对方释放锁;<br>
若锁没有被占用, 则获得锁成功–加锁, 然后操作共享资源, 操作完之后,<br>
必须解锁, 同理B也是和A一样.<br>
也就是说, 同时不能有两个线程访问共享资源, 属于互斥操作.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://xiaowuyoucy.github.io/2022/01/24/linux082守护进程和线程/" title="守护进程和线程" target="_blank" rel="external">https://xiaowuyoucy.github.io/2022/01/24/linux082守护进程和线程/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/xiaowuyoucy" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/logo.jpg" class="img-rounded w-full" alt>
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/xiaowuyoucy" target="_blank"><span class="text-dark">YanChen</span><small class="ml-1x"></small></a></h3>
        <div>Personal profile</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
		  

    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/01/30/linux083线程同步/" title="线程同步"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/01/23/linux081使用信号完成两个进程交替数数/" title="使用信号完成两个进程交替数数"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/zfb.png" alt="扫码支持" title="扫一扫">
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wx.png" alt="扫码支持" title="扫一扫">
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class>
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/xiaowuyoucy" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
	<span>More contact information</span>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>


    <script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:xiaowuyoucy.github.io ' + keyword;
        return false;
    });
})(jQuery);
</script>




   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '032928647cd59bc9f443',
    clientSecret: '82a11fd93e4d0779655af6dc4b73942a03e95276',
    repo: 'Xiaowuyoucy.github.io',
    owner: 'Xiaowuyoucy',
    admin: ['Xiaowuyoucy'],
    id: md5(location.pathname),
    distractionFreeMode: true
  })
  gitalk.render('comments')
  </script>

  







</body>
</html>