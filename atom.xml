<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanChen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowuyoucy.github.io/"/>
  <updated>2021-07-13T16:07:40.876Z</updated>
  <id>https://xiaowuyoucy.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OD调试器(断点),汇编指令MOV</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/12/hbnx001-OD%E8%B0%83%E8%AF%95%E5%99%A8-%E6%96%AD%E7%82%B9-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4MOV/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/12/hbnx001-OD调试器-断点-汇编指令MOV/</id>
    <published>2021-07-12T15:22:37.000Z</published>
    <updated>2021-07-13T16:07:40.876Z</updated>
    
    <content type="html"><![CDATA[<p>OD 按下F2断点/关闭断点</p><h3 id="跳到被调用的地方的下一条语句"><a class="markdownIt-Anchor" href="#跳到被调用的地方的下一条语句"></a> 跳到被调用的地方的下一条语句</h3><p><img src="/images/javawz/1626103662895.png" alt="1626103662895"></p><p>按下回车会鼠标右键选择反汇编窗口中跟随</p><h3 id="定位到指定api函数的地方"><a class="markdownIt-Anchor" href="#定位到指定api函数的地方"></a> 定位到指定API函数的地方</h3><p><img src="/images/javawz/1626103810500.png" alt="1626103810500"></p><p><img src="/images/javawz/1626103833021.png" alt="1626103833021"></p><p>按下Ctrl + G 或 鼠标右键选择转到-&gt;表达式</p><p>或者输入命令 <code>bp api函数名</code></p><p><img src="/images/javawz/1626103933703.png" alt="1626103933703"></p><h3 id="查看所有断点"><a class="markdownIt-Anchor" href="#查看所有断点"></a> 查看所有断点</h3><p><img src="/images/javawz/1626103996834.png" alt="1626103996834"></p><p><img src="/images/javawz/1626104011540.png" alt="1626104011540"></p><p>按下 ALT + B 或 鼠标点击菜单栏 查看-&gt;断点</p><h3 id="将od添加到鼠标右键菜单栏1626104111657"><a class="markdownIt-Anchor" href="#将od添加到鼠标右键菜单栏1626104111657"></a> 将OD添加到鼠标右键菜单栏<img src="/images/javawz/1626104111657.png" alt="1626104111657"></h3><p><img src="/images/javawz/1626104133252.png" alt="1626104133252"></p><h3 id="od断点历史记录文件夹"><a class="markdownIt-Anchor" href="#od断点历史记录文件夹"></a> OD断点历史记录文件夹</h3><p><img src="/images/javawz/1626104363289.png" alt="1626104363289"></p><h3 id="c或c内联汇编"><a class="markdownIt-Anchor" href="#c或c内联汇编"></a> c或c++内联汇编</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 001_MOV.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> aaa = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, TCHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MessageBoxW(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, MB_OK);</span><br><span class="line">aaa = <span class="number">0x889977</span>;<span class="comment">//MOV DWORD PTR DS:[0x403018],0x889977</span></span><br><span class="line">__asm &#123;</span><br><span class="line">mov aaa, <span class="number">0x889977</span></span><br><span class="line">&#125;</span><br><span class="line">__asm mov aaa, <span class="number">0x889977</span>;</span><br><span class="line">MessageBoxW(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mov指令"><a class="markdownIt-Anchor" href="#mov指令"></a> MOV指令</h3><p>aaa=0x889977;</p><p>MOV DWORD PTR DS:[0x403018],0x889977</p><p>dword 双字 就是四个字节 ptr pointer缩写 即指针 []里的数据是一个地址值</p><h3 id="dd指令"><a class="markdownIt-Anchor" href="#dd指令"></a> dd指令</h3><p>查看数据的指令</p><p><code>dd 地址</code></p><p>dd 0x403018 == dd 403018</p><hr><hr><h3 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 知识点：</h3><p>l  函数与CALL</p><p>l  关闭C/C++优化</p><p>l  单步步过</p><p>l  单步步入</p><p><strong>一、函数与CALL</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int add(int a,int b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> return a+b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">00401030 |. 8105 18304000&gt;ADD DWORD PTR DS:[403018],88       ; add 加法指令</span><br><span class="line"></span><br><span class="line">未被优化</span><br><span class="line"></span><br><span class="line">00401040 |. 68 88000000  PUSH 88</span><br><span class="line"></span><br><span class="line">00401045 |. A1 18304000  MOV EAX,DWORD PTR DS:[403018]</span><br><span class="line"></span><br><span class="line">0040104A |. 50      PUSH EAX</span><br><span class="line"></span><br><span class="line">0040104B |. E8 B0FFFFFF  CALL 001_MOV.00401000          ; add函数</span><br><span class="line"></span><br><span class="line">00401050 |. 83C4 08    ADD ESP,8</span><br><span class="line"></span><br><span class="line">00401053 |. A3 18304000  MOV DWORD PTR DS:[403018],EAX</span><br></pre></td></tr></table></figure><p><strong>二、关闭C/C++优化</strong></p><p>项目配置属性—&gt; C/C++ —&gt;优化—&gt;禁用/Od</p><p><strong>三、单步步入：(进CALL)</strong></p><p>F9(运行): 如果断下后，要继续让程序运行起来，可以用快捷键</p><p><em><strong>F7(单步步入):按下后执行下一条指令。如果有CALL则进入。</strong></em></p><p><strong>四、单步步过：(不进CALL)</strong></p><p>F8(单步步过):按下后执行下一条指令。不会进入子函数CALL里边，子函数CALL也被当成一条指令。</p><p>这两个单步执行操作的主要区别在于：如果当前的命令是一个子函数，按，将会进入子函数，并停在子函数的第一条命令上；而按，将会一次运行完这个子函数。如果您单步步过的子函数中含有断点或其他调试事件，执行将会被暂停</p><hr><hr><h3 id="知识点-2"><a class="markdownIt-Anchor" href="#知识点-2"></a> 知识点：</h3><p>l 立即寻址</p><p>l 寄存器寻址</p><p>l 寄存器间接寻址</p><p>l 直接寻址方式</p><p>l 直接寻址方式</p><p>l 寄存器相对寻址</p><h4 id="一-了解指令常用寻址方式"><a class="markdownIt-Anchor" href="#一-了解指令常用寻址方式"></a> 一、了解指令常用寻址方式</h4><p>寻址方式就是寻找操作数或操作数地址的方式。</p><p>寄存器是中央处理器内的组成部分。寄存器是一组容量有限的高速存贮部件，它们可用来暂存指令、数据和位址。（DWORD）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MOV   EAX，0x1234     //立即寻址         </span><br><span class="line"></span><br><span class="line">MOV   EAX，EBX     //寄存器寻址  数据寄存器,一般称之为通用寄存器组 通用寄存器有4个 EAX,EBX,ECX,EDX       </span><br><span class="line"></span><br><span class="line">MOV   EAX，[EBX]     //寄存器间接寻址         </span><br><span class="line"></span><br><span class="line">MOV   EAX，v       //v是一个变量名  </span><br><span class="line"></span><br><span class="line">MOV   EAX，[1234]     //直接寻址方式         </span><br><span class="line"></span><br><span class="line">MOV   EAX，[EBX+1234]   //寄存器相对寻址</span><br></pre></td></tr></table></figure><h4 id="二-理解寻址"><a class="markdownIt-Anchor" href="#二-理解寻址"></a> 二、理解寻址</h4><p>上边的名字看起来很多，总结起来也就2种方式：</p><p>带[]与不带[]</p><p><code>1、不带括号的 有立即数与寄存器</code></p><p><code>2、带括号的就是指针，从地址里边取值出来。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MOV   EAX，0x1234     //立即寻址     eax=0x1234;      </span><br><span class="line"></span><br><span class="line">MOV   EAX，EBX     //寄存器寻址    eax=ebx        </span><br><span class="line"></span><br><span class="line">MOV   EAX，[EBX]     //寄存器间接寻址  eax=*(int*)ebx;        </span><br><span class="line"></span><br><span class="line">MOV   EAX，v       //v是一个变量名   eax=v; //被编译后 一般会呈后边两种形式</span><br><span class="line"></span><br><span class="line">MOV   EAX，[1234]     //直接寻址方式   eax=*(int*)(0x1234)</span><br><span class="line"></span><br><span class="line">MOV   EAX，[EBX+1234]   // 寄存器相对寻址  eax=*(int*)((int)ebx+1234); //这里的1234称为偏移，EBX是基址</span><br></pre></td></tr></table></figure><h4 id="三-对调位置"><a class="markdownIt-Anchor" href="#三-对调位置"></a> 三、对调位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MOV   EAX，0x1234     //立即数不能出现在MOV指令左边。如：   MOV 0x1234,EAX 这是错的写法   </span><br><span class="line"></span><br><span class="line">后边的都可以对换位置    </span><br><span class="line"></span><br><span class="line">MOV   EAX，EBX     //寄存器寻址    eax=ebx         mov ebx,eax     </span><br><span class="line"></span><br><span class="line">MOV   EAX，[EBX]     //寄存器间接寻址  eax=*(int*)ebx;       mov [ebx],eax    </span><br><span class="line"></span><br><span class="line">MOV   EAX，v       //v是一个变量名   eax=v;          mov v,eax</span><br><span class="line"></span><br><span class="line">MOV   EAX，[1234]     //直接寻址方式   eax=*(int*)(0x1234)     mov [1234],eax</span><br><span class="line"></span><br><span class="line">MOV   EAX，[EBX+1234]   // 寄存器相对寻址  eax=*(int*)((int)ebx+1234)  mov [ebx+1234],eax</span><br></pre></td></tr></table></figure><h4 id="四-代码测试"><a class="markdownIt-Anchor" href="#四-代码测试"></a> 四、代码测试</h4><p><code>int *da=a;//int a[0x10]={0,1,2,3,4,5,6,7,8,9,0xA,0xB,0xC,0xd,0xe};</code></p><p>//提示 在命令栏中用 dd 地址表达式 可以以DWORD 4字节格式显示指定地址的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">mov eax,0x1111</span><br><span class="line"></span><br><span class="line">   mov ebx,eax</span><br><span class="line"></span><br><span class="line">mov ebx,bbb //全局变量bbb</span><br><span class="line"></span><br><span class="line">mov ebx,da //取数组基址</span><br><span class="line"></span><br><span class="line"> mov eax,[da+4]</span><br><span class="line"></span><br><span class="line"> mov eax,[ebx+4]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//下边指令，前边是寄存器相对寻址，后边是立即寻址</span><br><span class="line"></span><br><span class="line">0040105A |. C745 FC 20304&gt;MOV DWORD PTR SS:[EBP-4],001_MOV.00403020   ; int *da=a //a是数组的地址 </span><br><span class="line"></span><br><span class="line">00401061 |. B8 11110000  MOV EAX,1111                 ; eax=0x1111 立即寻址</span><br><span class="line"></span><br><span class="line">00401066 |. 8BD8     MOV EBX,EAX                  ; mov ebx,0x1111--&gt;ebx=0x1111 //寄存器寻址</span><br><span class="line"></span><br><span class="line">00401068 |. 8B1D 18304000 MOV EBX,DWORD PTR DS:[403018]         ; mov ebx,008899FF--&gt;ebx=009988FF 直接寻址</span><br><span class="line"></span><br><span class="line">0040106E |. 8B5D FC    MOV EBX,DWORD PTR SS:[EBP-4]         ; mov ebx,da 寄存器 相对寻址</span><br><span class="line"></span><br><span class="line">00401071 |. 8B45 00    MOV EAX,DWORD PTR SS:[EBP]            //寄存器间接寻址</span><br><span class="line"></span><br><span class="line">00401074 |. 8B43 04    MOV EAX,DWORD PTR DS:[EBX+4]         ; eax=da[1]=1 寄存器 相对寻址</span><br></pre></td></tr></table></figure><h3 id="dd命令"><a class="markdownIt-Anchor" href="#dd命令"></a> dd命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dd eax + 2 * 8</span><br><span class="line"></span><br><span class="line">dd eax</span><br><span class="line"></span><br><span class="line">dd 0x11111</span><br></pre></td></tr></table></figure><h3 id="定位到指定地址"><a class="markdownIt-Anchor" href="#定位到指定地址"></a> 定位到指定地址</h3><p><img src="/images/javawz/1626164450409.png" alt></p><p><img src="/images/javawz/1626164503122.png" alt="1626164503122"></p><hr><hr><h3 id="知识点-3"><a class="markdownIt-Anchor" href="#知识点-3"></a> 知识点：</h3><p>加法汇编指令ADD</p><p><strong>一、加法指令 ADD(Addition)</strong> <strong>格式</strong></p><p>格式: ADD A,B  //A=A+B;</p><p>功能: 两数相加</p><ol><li>OPRD1为任一通用寄存器或存储器操作数,可以是任意一个通用寄存器,而且还可以是任意一个存储器操作数.</li></ol><p>OPRD2为立即数,也可以是任意一个通用寄存器操作数.立即数只能用于源操作数B.</p><ol start="2"><li>A和B均为寄存器是允许的,一个为寄存器而另一个为存储器也是允许的, 但不允许两个都是存储器操作数.</li></ol><p>//也就是说A与B不能同时是指针 如: <code>add [eax],[ebx] 这类情况是错的</code></p><p>例子：</p><p>第三课中的add函数里 有如下2句代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401003 |. 8B45 08    MOV EAX,DWORD PTR SS:[EBP+8]       ; a</span><br><span class="line"></span><br><span class="line">00401006 |. 0345 0C    ADD EAX,DWORD PTR SS:[EBP+C]       ; b //eax=a+b</span><br></pre></td></tr></table></figure><p><strong>二、ADD指令测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     int i=0;</span><br><span class="line"></span><br><span class="line">     printf(&quot;&quot;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  i=i+0x100;</span><br><span class="line"></span><br><span class="line">    i=i+0x111;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     int *p=&amp;i;</span><br><span class="line"></span><br><span class="line">     __asm </span><br><span class="line"></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">          mov eax,0x222</span><br><span class="line"></span><br><span class="line">          mov ebx,0x100</span><br><span class="line"></span><br><span class="line">          add ebx,eax //ebx322</span><br><span class="line"></span><br><span class="line">          //</span><br><span class="line"></span><br><span class="line">          mov ebx,p</span><br><span class="line"></span><br><span class="line">          add [ebx],0x111</span><br><span class="line">//00401048 |. 8003 11    ADD BYTE PTR DS:[EBX],11         ; i=i+11</span><br><span class="line"></span><br><span class="line">          add i,0x111   //DWORD WORD</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line"></span><br><span class="line">     0040101C |. 8B45 F8    MOV EAX,DWORD PTR SS:[EBP-8]       ; eax=i=0</span><br><span class="line"></span><br><span class="line">     0040101F |. 05 00010000  ADD EAX,100               ; eax=eax+100=0+100=100</span><br><span class="line"></span><br><span class="line">     00401024 |. 8945 F8    MOV DWORD PTR SS:[EBP-8],EAX       ; i=eax=100</span><br><span class="line"></span><br><span class="line">     00401027 |. 8B4D F8    MOV ECX,DWORD PTR SS:[EBP-8]       ; ecx=i=100</span><br><span class="line"></span><br><span class="line">     0040102A |. 81C1 11010000 ADD ECX,111               ; ecx=ecx+111=100+111=0x211</span><br><span class="line"></span><br><span class="line">     00401030 |. 894D F8    MOV DWORD PTR SS:[EBP-8],ECX       ; i=ecx=0x211</span><br><span class="line"></span><br><span class="line">     00401033 |. 8D55 F8    LEA EDX,DWORD PTR SS:[EBP-8]       ; edx=&amp;i=ebp-8;</span><br><span class="line"></span><br><span class="line">     00401036 |. 8955 FC    MOV DWORD PTR SS:[EBP-4],EDX       ; p=&amp;i</span><br><span class="line"></span><br><span class="line">     00401039 |. B8 22020000  MOV EAX,222</span><br><span class="line"></span><br><span class="line">     0040103E |. BB 00010000  MOV EBX,100</span><br><span class="line"></span><br><span class="line">     00401043 |. 03D8     ADD EBX,EAX               ; ebx=ebx+eax=100+222=322</span><br><span class="line"></span><br><span class="line">     00401045 |. 8B5D FC    MOV EBX,DWORD PTR SS:[EBP-4]       ; ebx=i=edx=ebp-8</span><br><span class="line"></span><br><span class="line">     00401048 |. 8003 11    ADD BYTE PTR DS:[EBX],11         ; i=i+11</span><br><span class="line"></span><br><span class="line">     0040104B |. 8145 F8 11010&gt;ADD DWORD PTR SS:[EBP-8],111       ; i=i+111</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     */ </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     printf(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OD按下<code>-</code>号可以返回上一步</p><hr><hr><h3 id="知识点-4"><a class="markdownIt-Anchor" href="#知识点-4"></a> 知识点：</h3><p><strong>十六进制</strong></p><p><strong>字节，字，双字</strong></p><p><strong>汇编中的内存单元长度修饰</strong></p><p><strong>add [ebx],0x111 //00401048 |.  8003 11  ADD BYTE PTR DS:[EBX],11   ; i=i+11</strong></p><p><strong>一、十六进制</strong></p><p><strong>十六进制</strong>同我们日常中的十进制表示法不一样。它由0-9,A-F,组成。与10进制的对应关系是：0-9对应0-9;A-F对应10-15;</p><p>十进制元素(0,1,2,3,4,5,6,7,8,9)</p><p>十六进制元素(0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F)</p><p>9+1=10; //十进制 A</p><p>F+1=10; //十六进制</p><p>99+1=100;//十进制 0x64</p><p>FF+1=100;//十六进制 1<em>16</em>16=256 //0xBDA=11<em>16</em>16+13*16+10</p><p>十六进制一般会加上前缀0x 汇编中也可以加上h后缀</p><p>//想一想 十六进制中</p><p>0x0F+2=0x11  0xF9+1=0xFA  0x10+1=0x11  0x18+8=0x20 8+9=0x11</p><p><strong>二、字节，字，双字</strong></p><p>字节 (1字节):BYTE类型 ( unsigned char)  0-255    表示成16进制0–0xFF</p><p>字  (2字节):WORD类型 (unsigned short)  0-65535，  表示成16进制0–0xFFFF</p><p>双字 (4字节):DWORD类型(unsigned long)  0-4294967295 表示成16进制0–0xFFFFFFFF</p><p>四字(8字节) QWORD 类型 (unsigned long long )  64 位整数，Q 代表四（字）</p><p><strong>三、汇编中的内存单元长度修饰</strong></p><p><strong>1、自动加上修饰前缀规律</strong></p><p>后面是寄存器会自动加上前缀修饰符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> int pb=3;</span><br><span class="line"></span><br><span class="line"> mov [eax],ebx</span><br><span class="line"></span><br><span class="line"> mov edx,[ecx]</span><br><span class="line"></span><br><span class="line"> mov ebx,pb</span><br><span class="line"></span><br><span class="line">BYTE c=3;</span><br><span class="line"></span><br><span class="line">WORD w=4;</span><br><span class="line"></span><br><span class="line">DWORD dw=5;</span><br><span class="line"></span><br><span class="line">mov c,0x87654321</span><br><span class="line"></span><br><span class="line">mov w,0x87654321</span><br><span class="line"></span><br><span class="line">mov dw,0x87654321</span><br></pre></td></tr></table></figure><p><strong>2、必须手动添加内存单元长度修饰的情况</strong></p><p><strong>前边是存储器，后边是常量的情况，需要手动添加长度修饰</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">add [ebx],0x111 //特殊... 因为编译器不知道具体长度，会默认为 字节长度</span><br><span class="line"></span><br><span class="line">mov byte ptr [ebx],0x87654321</span><br><span class="line"></span><br><span class="line">mov word ptr [ebx],0x87654321</span><br><span class="line"></span><br><span class="line">mov dword ptr [ebx],0x87654321</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   BYTE c=3;</span><br><span class="line"></span><br><span class="line">     WORD w=4;</span><br><span class="line"></span><br><span class="line">     DWORD dw=5;</span><br><span class="line"></span><br><span class="line">     __asm</span><br><span class="line"></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">            add c,0x87654321 // mov [ebp-??],0x21</span><br><span class="line"></span><br><span class="line">              add w,0x87654321</span><br><span class="line"></span><br><span class="line">               add dw,0x87654321</span><br><span class="line"></span><br><span class="line">               /* 自动添加的长度修饰符</span><br><span class="line"></span><br><span class="line">               00401071 |. 8045 EF 21  ADD BYTE PTR SS:[EBP-11],21       ; c=21</span><br><span class="line"></span><br><span class="line">              00401075 |.  66:8145 FC 21&gt;ADD WORD PTR SS:[EBP-4],4321       ; w=4321</span><br><span class="line"></span><br><span class="line">               0040107B |. 8145 F0 21436&gt;ADD DWORD PTR SS:[EBP-10],87654321    ; dw=87654321</span><br><span class="line"></span><br><span class="line">               */</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><hr><h3 id="知识点-5"><a class="markdownIt-Anchor" href="#知识点-5"></a> 知识点：</h3><p>寄存器EAX</p><p>寄存器AX</p><p>寄存器AH</p><p>寄存器AL</p><p>一、EAX与AX,AH,AL关系图</p><p>EAX，EBX，ECX，EDX都有低16位和低8位，高8位寄存器</p><p>ESP，EBP，ESI，EDI只有低16位寄存器例如 SP,BP,SI,DI，而没有低8位和高8位</p><h4 id="数据查看命令"><a class="markdownIt-Anchor" href="#数据查看命令"></a> 数据查看命令</h4><p>dd  查看DWORD内存</p><p>dw 查看WORD内存</p><p>db 查看BYTE内存</p><p><img src="/images/javawz/1626179488871.png" alt="1626179488871"></p><p>一格表示一字节</p><p><img src="/images/javawz/1626178921052.png" alt="1626178921052"></p><p>二、代码测试</p><h5 id="1-od命令栏-号指令-用计显示表达式的值"><a class="markdownIt-Anchor" href="#1-od命令栏-号指令-用计显示表达式的值"></a> 1、OD命令栏 ？号指令 （用计显示表达式的值)</h5><p><code>? ax</code> 查看ax的值</p><p><code>? eax</code> 查看eax的值</p><p><code>? al</code> 查看al的值</p><p><code>? ah</code>查看ah的值</p><p><img src="/images/javawz/1626179249330.png" alt="1626179249330"></p><p><img src="/images/javawz/1626178885198.png" alt="1626178885198"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">printf(&quot;&quot;);</span><br><span class="line">int i_AX,i_AH,i_AL;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax,0x87654321  ;</span><br><span class="line">mov word ptr [i_AX],ax</span><br><span class="line">mov byte ptr [i_AH],ah</span><br><span class="line">mov byte ptr [i_AL],al</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">DWORD iEax;</span><br><span class="line">WORD  iAx;</span><br><span class="line">BYTE  iAh,iAl;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax,0x87654321</span><br><span class="line">mov iEax,eax</span><br><span class="line">mov iAx,ax</span><br><span class="line">mov iAh,ah</span><br><span class="line">mov iAl,al</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;EAX=%x,AX=%x,AH=%x,AL=%x \n&quot;,iEax,iAx,iAh,iAl);</span><br><span class="line">getchar();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h3 id="知识点-6"><a class="markdownIt-Anchor" href="#知识点-6"></a> 知识点：</h3><p>MOVSX符号扩展传送</p><p>MOVZX零扩展传送</p><p>一、MOVSX与MOVZX格式</p><p>MOVSX 操作数A ，操作数B</p><p>MOVZX 操作数A ，操作数B</p><p>相同点：操作数B 空间必须小于 操作数A</p><p>1、格式与MOV基本相同</p><p>2、能完成小存储单元向大存储单元的数据传送 比如 movsx eax,bx movzx ebx,ax   movsx eax,bx</p><p>正确语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOVSX EAX,AX</span><br><span class="line">MOVSX EBX,BL</span><br><span class="line">MOVZX EDX,DX</span><br><span class="line">MOVZX EDX,DL</span><br></pre></td></tr></table></figure><p>错误写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVSX EAX,EAX //第二个操作数内存等于第一个操作数</span><br><span class="line">MOVSX AX,EAX  //第二个操作数内存大于第一个操作数</span><br></pre></td></tr></table></figure><p><strong>MOVSX，MOVZX 与MOV指令区别：</strong></p><p>1、MOVSX，MOVZX的操作数B所占空间必须小于操作数A.</p><p>2、MOV指令是原值传送，不会改动。而MOVSX与MOVZX有可能会改动</p><p><strong>MOVSX与MOVZX的区别：</strong></p><p>1、MOVSX将用操作数B的符号位扩展填充操作数A的余下空间，如果是负数则符号位为1，如果是正数则和MOVZX功能相同</p><p>2、MOVZX将用0来扩展填充操作数A的余下空间。</p><p>操作数A</p><p><img src="/images/javawz/1626181356116.png" alt="1626181356116"></p><p>操作数B</p><p><img src="/images/javawz/1626181370217.png" alt="1626181370217"></p><p>二、代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> int i=0x888;</span><br><span class="line"></span><br><span class="line">     char ci=-100;</span><br><span class="line"></span><br><span class="line">     printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">     i=ci; //111111111111111111111111 11001101</span><br><span class="line"></span><br><span class="line">     i=(unsigned char)ci; //       11001101</span><br><span class="line"></span><br><span class="line">printf(&quot;&quot;);</span><br></pre></td></tr></table></figure><p>判断有符号十六进制是正数还是负数</p><p>char 0-FF //FF/2</p><p>DWORD 0-0xFFF 8F8F</p><p>最高为大于等于8的是负数,1至7是正数</p><h5 id="od按下f4键可以运行到鼠标指定的指令前提是程序必须会经过这条指令"><a class="markdownIt-Anchor" href="#od按下f4键可以运行到鼠标指定的指令前提是程序必须会经过这条指令"></a> <code>OD按下F4键可以运行到鼠标指定的指令,前提是程序必须会经过这条指令</code></h5><hr><hr><h3 id="知识点-7"><a class="markdownIt-Anchor" href="#知识点-7"></a> 知识点：</h3><p><strong>LEA指令</strong></p><p>&amp;与LEA</p><p>OD里修改汇编代码  在指定的指令位置按下空格键或</p><p><strong>一、LEA指令格式</strong></p><p><strong>有效地址传送指令</strong> LEA</p><p>格式: LEA 操作数A, 操作数B</p><p>功能: 将操作数B的有效地址传送到指定的的某个寄存器，操作数A必须是寄存器。(32位系统上就是32位寄存器)</p><p><code>不能两个操作数都是内存操作的</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误写法</span><br><span class="line">LEA DWORD PTR DS:[EBX],DWORD PTR DS:[0X123456]</span><br></pre></td></tr></table></figure><p><strong>二、C++代码测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line"></span><br><span class="line">int *p=&amp;i;</span><br></pre></td></tr></table></figure><p><strong>三、OD里修改汇编代码</strong></p><p>按下空格后 直接输入汇编代码</p><p><img src="/images/javawz/1626186522912.png" alt="1626186522912"></p><p><strong>四、汇编代码测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int i=0:</span><br><span class="line"></span><br><span class="line">char a[4]=&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">__asm</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> lea ebx,i  // ebx=&amp;i</span><br><span class="line"></span><br><span class="line"> mov dword ptr [ebx],0x113388</span><br><span class="line"></span><br><span class="line"> mov i,0x776628</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><hr><hr><p>知识点：</p><p><strong>OD调试</strong></p><p><strong>命令栏指令</strong></p><p><strong>一、OD调试</strong></p><p><strong>重新开始：Ctrl+F2</strong></p><p>转到地址：CTRL+G</p><p><strong>断点切换: F2</strong></p><p>断点窗口: Alt+B</p><p>运行  : F9</p><p>暂停  : F12</p><p>单步步过: F8 //遇到CALL跳过</p><p>单步步入: F7 //遇到CALL进入</p><p>运行到选定位置  :F4  <strong>//这个主菜单上没有，右键菜单-断点-F4</strong></p><p>反汇编窗口中跟随 :回车键enter</p><p>跟随: 回车键enter //进入某个地址</p><p>执行到返回 CTRL + F9</p><h5 id="右键菜单转到"><a class="markdownIt-Anchor" href="#右键菜单转到"></a> 右键菜单–转到</h5><p>+号：转到下一步 //Plus</p><p>-号：转到上一步 //Minus</p><p><code>*号</code>：转到当前指令地址 //EIP</p><p>寄存器窗口:</p><p><strong>二、命令栏指令</strong></p><p>bp 下断点</p><p>bc 清除断点</p><p>dd 以双字方式显示数据</p><p>dw 以字方式显示数据</p><p>db 以字节方式显示数据</p><p>？ 计算表达式的值</p><hr><hr><h3 id="知识点-8"><a class="markdownIt-Anchor" href="#知识点-8"></a> 知识点：</h3><p><strong>汇编减法指令sub</strong></p><p><strong>初识标志位</strong></p><p><strong>标志寄存器PSW</strong></p><p><strong>ZF（零标志）</strong></p><p><strong>一、标志寄存器PSW</strong></p><p>标志寄存器PSW(程序状态字寄存器PSW)</p><p>标志寄存器PSW是一个16为的寄存器。它反映了CPU运算的状态特征并且存放某些控制标志。8086使用了16位中的9位，包括6个状态标志位和3个控制标志位。</p><p><img src="/images/javawz/1626190827047.png" alt="1626190827047"></p><p><strong>CF(进位标志位)</strong>：当执行一个加法（减法）运算时，最高位产生进位（或借位）时，CF为1，否则为0。</p><p><strong>ZF零标志位</strong>：若当前的运算结果为零，则ZF为1，否则为0。</p><p><strong>SF符号标志位</strong>：该标志位与运算结果的最高位相同。即运算结果为负，则SF为1，否则为0。</p><p><strong>OF溢出标志位</strong>：若运算结果超出机器能够表示的范围称为溢出，此时OF为1，否则为0。判断是否溢出的方法是：进行二进制运算时，最高位的进位值与次高位的进位值进行异或运算，若运算结果为1则表示溢出OF=1，否则OF=0</p><p><strong>PF奇偶标志</strong>：当运算结果的最低16位中含1的个数为偶数则PF=1否则PF=0</p><p><strong>AF辅助进位标志</strong>：一个加法（减法）运算结果的低4位向高4位有进位（或借位）时则AF=1否则AF=0</p><p>另外还有三个控制标志位用来控制CPU的操作，可以由程序进行置位和复位。</p><p><strong>TF跟踪标志</strong>：该标志位为方面程序调试而设置。若TF=1，8086/8088CPU处于单步工作方式，即在每条指令执行结束后，产生中断。</p><p><strong>IF中断标志位</strong>：该标志位用来控制CPU是否响应可屏蔽中断。若IF=1则允许中断，否则禁止中断。</p><p><strong>DF方向标志</strong>：该标志位用来控制串处理指令的处理方向。若DF=1则串处理过程中地址自动递减，否则自动递增。</p><p><strong>OD里能查看到除IF标志外的 8个标志位</strong></p><p><img src="/images/javawz/1626190975291.png" alt="1626190975291"></p><p><strong>二、SUB指令</strong></p><p><strong>减法指令SUB (SUBtract)</strong></p><p>格式: SUB A,B //A=A-B;</p><p>功能: 两个操作数的相减,即从A中减去B,其结果放在A中.</p><p>SUB指令会影响标志位</p><p><code>如果SUB EAX,EBX 等于0的话,ZF标志位会置为1,说明两数相等</code></p><hr><hr><p>知识点：</p><p><strong>比较指令CMP</strong></p><p><strong>条件跳转指令JZ</strong></p><p><strong>ZF（零标志）</strong></p><p><strong>CMP</strong> <strong>和JZ</strong> <strong>指令</strong></p><p><strong>比较指令CMP</strong></p><p>格式: <strong>CMP</strong> A,B // A-B;</p><p>功能: 两个操作数的相减,即从A中减去B，其结果会影响标志位， 对标志位的影响与SUB指令相同。本条指令主要是用于配合条件转移指令使用。如JZ ZF=0时，跳转</p><p><strong>条件转移指令 JE/JZ</strong></p><p><code>格式: JE/JZ标号 //等于跳转</code></p><p><code>功能: ZF＝1,转到指定地址执行</code></p><p>说明:</p><ol><li><p>指令JE与JZ等价,它们是根据标志位ZF进行转移的指令</p></li><li><p>JE,JZ均为一条指令的两种助记符表示方法</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   printf(&quot;begin\n&quot;);</span><br><span class="line"></span><br><span class="line">     int a=3;</span><br><span class="line"></span><br><span class="line">    if (a!=3)</span><br><span class="line"></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">          printf(&quot;do code\n&quot;);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;end&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OD 按下F2断点/关闭断点&lt;/p&gt;
&lt;h3 id=&quot;跳到被调用的地方的下一条语句&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#跳到被调用的地方的下一条语句&quot;&gt;&lt;/a&gt; 跳到被调用的地方的下一条语句&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/ima
      
    
    </summary>
    
      <category term="汇编逆向" scheme="https://xiaowuyoucy.github.io/categories/%E6%B1%87%E7%BC%96%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0088-%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0088-算法/</id>
    <published>2021-07-05T10:16:24.000Z</published>
    <updated>2021-07-05T10:31:46.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h1><h3 id="算法基础"><a class="markdownIt-Anchor" href="#算法基础"></a> 算法基础</h3><h4 id="算法概述"><a class="markdownIt-Anchor" href="#算法概述"></a> 算法概述</h4><p>算法部分主要由头文件&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;组成。</p><p>&lt;algorithm&gt;是所有STL头文件中最大的一个，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、反转、排序、合并等等。</p><p>&lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。</p><p>&lt;functional&gt;中则定义了一些模板类，用以声明函数对象。</p><p>STL提供了大量实现算法的模版函数，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能，从而大大地提升效率。</p><p>#include &lt;algorithm&gt;</p><p>#include &lt;numeric&gt;</p><p>#include &lt;functional&gt;</p><h4 id="stl中算法分类"><a class="markdownIt-Anchor" href="#stl中算法分类"></a> STL中算法分类</h4><ul><li><p>操作对象</p></li><li><ul><li>直接改变容器的内容</li><li>将原容器的内容复制一份,修改其副本,然后传回该副本</li></ul></li><li><p>功能:</p></li><li><ul><li><p>非可变序列算法 指不直接修改其所操作的容器内容的算法</p></li><li><ul><li>计数算法     count、count_if</li><li>搜索算法     search、find、find_if、find_first_of、…</li><li>比较算法     equal、mismatch、lexicographical_compare</li></ul></li><li><p>可变序列算法 指可以修改它们所操作的容器内容的算法</p></li><li><ul><li>删除算法     remove、remove_if、remove_copy、…</li><li>修改算法     for_each、transform</li><li>排序算法     sort、stable_sort、partial_sort、</li></ul></li><li><p>排序算法 包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作</p></li><li><p>数值算法 对容器内容进行数值计算</p></li></ul></li></ul><h4 id="常用算法汇总"><a class="markdownIt-Anchor" href="#常用算法汇总"></a> 常用算法汇总</h4><p>常用的查找算法：</p><p>adjacent_find()（ adjacent 是邻近的意思）,binary_search(),count(),</p><p>count_if(),equal_range(),find(),find_if()。</p><p>常用的排序算法：</p><p>merge(),sort(),random_shuffle()（shuffle是洗牌的意思） ,reverse()。</p><p>常用的拷贝和替换算法：</p><p>copy(), replace(),</p><p>replace_if(),swap()</p><p>常用的算术和生成算法：</p><p>accumulate()（ accumulate 是求和的意思）,fill(),。</p><p>常用的集合算法：</p><p>set_union(),set_intersection(),</p><p>set_difference()。</p><p>常用的遍历算法：</p><p>for_each(), transform()（ transform 是变换的意思）</p><h3 id="算法中函数对象和谓词"><a class="markdownIt-Anchor" href="#算法中函数对象和谓词"></a> 算法中函数对象和谓词</h3><h4 id="函数对象和谓词定义"><a class="markdownIt-Anchor" href="#函数对象和谓词定义"></a> 函数对象和谓词定义</h4><p><strong>函数对象：</strong></p><p>重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象。一个类对象，表现出一个函数的特征，就是通过“对象名+(参数列表)”的方式使用一个类对象，如果没有上下文，完全可以把它看作一个函数对待。</p><p>这是通过重载类的operator()来实现的。</p><p>“在标准库中，函数对象被广泛地使用以获得弹性”，标准库中的很多算法都可以使用函数对象或者函数来作为自定的回调行为；</p><p><strong>谓词：</strong></p><p>一元函数对象：函数参数1个；</p><p>二元函数对象：函数参数2个；</p><p>一元谓词 函数参数1个，函数返回值是bool类型，可以作为一个判断式</p><p>​              谓词可以使一个仿函数，也可以是一个回调函数。</p><p>二元谓词 函数参数2个，函数返回值是bool类型</p><p>一元谓词函数举例如下</p><p>1，判断给出的string对象的长度是否小于6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool GT6(const string &amp;s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return s.size() &gt;= 6;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2,判断给出的int是否在3到8之间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool Compare( int i )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return ( i &gt;= 3 &amp;&amp; i &lt;= 8 );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二元谓词举例如下</p><p>1，比较两个string对象，返回一个bool值，指出第一个string是否比第二个短</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool isShorter(const string &amp;s1, const string &amp;s2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return s1.size() &lt; s2.size();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一元函数对象案例"><a class="markdownIt-Anchor" href="#一元函数对象案例"></a> 一元函数对象案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//1普通类 重载 函数调用操作符</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void FuncShowElemt(T &amp;t)  //普通函数 不能像 仿函数那样记录状态</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void showChar(char &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数模板 重载 函数调用操作符</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class ShowElemt</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ShowElemt()</span><br><span class="line">&#123;</span><br><span class="line">n = 0;</span><br><span class="line">&#125;</span><br><span class="line">void operator()(T &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">void printCount()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//1 函数对象 基本使用</span><br><span class="line">void main11()</span><br><span class="line">&#123;</span><br><span class="line">int a = 100;</span><br><span class="line">FuncShowElemt&lt;int&gt;(a); //普通的函数调用</span><br><span class="line"></span><br><span class="line">ShowElemt&lt;int&gt; showElemt; //函数对象 </span><br><span class="line">showElemt(a); //函数对象调用 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一元谓词案例"><a class="markdownIt-Anchor" href="#一元谓词案例"></a> 一元谓词案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//1元谓词 例子</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Isdiv</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Isdiv(const T &amp;divisor) //</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;divisor = divisor;</span><br><span class="line">&#125;</span><br><span class="line">bool operator()(T &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">return (t%divisor == 0);</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">private:</span><br><span class="line">T divisor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main13()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v2;</span><br><span class="line">for (int i=10; i&lt;33; i++)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">int a = 4;</span><br><span class="line">Isdiv&lt;int&gt; mydiv(a);</span><br><span class="line">// _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)   //返回的是迭代器</span><br><span class="line">it = find_if(v2.begin(), v2.end(), Isdiv&lt;int&gt;(4));</span><br><span class="line">if (it != v2.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;第一个被4整除的数是：&quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二元函数对象案例"><a class="markdownIt-Anchor" href="#二元函数对象案例"></a> 二元函数对象案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">struct SumAdd</span><br><span class="line">&#123;</span><br><span class="line">T operator()(T &amp;t1, T &amp;t2)</span><br><span class="line">&#123;</span><br><span class="line">return t1 + t2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void printE(T &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = t.begin(); it!=t.end(); it++ )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt; &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it!=v.end(); it++ )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  main14()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1, v2 ;</span><br><span class="line">vector&lt;int&gt; v3;</span><br><span class="line">v1.push_back(1);</span><br><span class="line">v1.push_back(2);</span><br><span class="line">v1.push_back(3);</span><br><span class="line"></span><br><span class="line">v2.push_back(4);</span><br><span class="line">v2.push_back(5);</span><br><span class="line">v2.push_back(6);</span><br><span class="line"></span><br><span class="line">v3.resize(10);</span><br><span class="line"></span><br><span class="line">//transform(v1.begin(), v1.end(), v2.begin(),v3.begin(), SumAdd&lt;int&gt;());</span><br><span class="line">/*</span><br><span class="line">template&lt;class _InIt1,</span><br><span class="line">class _InIt2,</span><br><span class="line">class _OutIt,</span><br><span class="line">class _Fn2&gt; inline</span><br><span class="line">_OutIt transform(_InIt1 _First1, _InIt1 _Last1,</span><br><span class="line">_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)</span><br><span class="line">*/</span><br><span class="line">vector&lt;int&gt;::iterator it = transform(v1.begin(), v1.end(), v2.begin(),v3.begin(), SumAdd&lt;int&gt;());</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">printE(v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二元谓词案例"><a class="markdownIt-Anchor" href="#二元谓词案例"></a> 二元谓词案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void current(int &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MyCompare(const int &amp;a, const int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">return a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line">void main15()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v(10);</span><br><span class="line"></span><br><span class="line">for (int i=0; i&lt;10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v[i] = rand() % 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), current);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">sort(v.begin(), v.end(), MyCompare );</span><br><span class="line"></span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">for (int i=0; i&lt;10; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, v[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="预定义函数对象和函数适配器"><a class="markdownIt-Anchor" href="#预定义函数对象和函数适配器"></a> 预定义函数对象和函数适配器</h4><p>预定义函数对象基本概念：标准模板库STL提前定义了很多预定义函数对象，#include &lt;functional&gt; 必须包含。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//1使用预定义函数对象：</span><br><span class="line">//类模板plus&lt;&gt; 的实现了： 不同类型的数据进行加法运算</span><br><span class="line">void main41()</span><br><span class="line">&#123;</span><br><span class="line">plus&lt;int&gt; intAdd;</span><br><span class="line">int x = 10;</span><br><span class="line">int y = 20;</span><br><span class="line">int z = intAdd(x, y); //等价于 x + y </span><br><span class="line">cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">plus&lt;string&gt; stringAdd;</span><br><span class="line">string myc = stringAdd(&quot;aaa&quot;, &quot;bbb&quot;);</span><br><span class="line">cout &lt;&lt; myc &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; v1;</span><br><span class="line">v1.push_back(&quot;bbb&quot;);</span><br><span class="line">v1.push_back(&quot;aaa&quot;);</span><br><span class="line">v1.push_back(&quot;ccc&quot;);</span><br><span class="line">v1.push_back(&quot;zzzz&quot;);</span><br><span class="line"></span><br><span class="line">//缺省情况下，sort()用底层元素类型的小于操作符以升序排列容器的元素。</span><br><span class="line">//为了降序，可以传递预定义的类模板greater,它调用底层元素类型的大于操作符：</span><br><span class="line">cout &lt;&lt; &quot;sort()函数排序&quot; &lt;&lt; endl;;</span><br><span class="line">sort(v1.begin(), v1.end(), greater&lt;string&gt;() ); //从大到小</span><br><span class="line">for (vector&lt;string&gt;::iterator it=v1.begin(); it!=v1.end(); it++ )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算术函数对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">预定义的函数对象支持加、减、乘、除、求余和取反。调用的操作符是与type相关联的实例</span><br><span class="line">加法：plus&lt;Types&gt;</span><br><span class="line">plus&lt;string&gt; stringAdd;</span><br><span class="line">sres = stringAdd(sva1,sva2);</span><br><span class="line">减法：minus&lt;Types&gt;</span><br><span class="line">乘法：multiplies&lt;Types&gt;</span><br><span class="line">除法divides&lt;Tpye&gt;</span><br><span class="line">求余：modulus&lt;Tpye&gt;</span><br><span class="line">取反：negate&lt;Type&gt;</span><br><span class="line">negate&lt;int&gt; intNegate;</span><br><span class="line">ires = intNegate(ires);</span><br><span class="line">Ires= UnaryFunc(negate&lt;int&gt;(),Ival1);</span><br></pre></td></tr></table></figure><p><strong>关系函数对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">等于equal_to&lt;Tpye&gt;</span><br><span class="line">equal_to&lt;string&gt; stringEqual;</span><br><span class="line">sres = stringEqual(sval1,sval2);</span><br><span class="line">不等于not_equal_to&lt;Type&gt;</span><br><span class="line">大于 greater&lt;Type&gt;</span><br><span class="line">大于等于greater_equal&lt;Type&gt;</span><br><span class="line">小于 less&lt;Type&gt;</span><br><span class="line">小于等于less_equal&lt;Type&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main42()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;string&gt; v1;</span><br><span class="line">v1.push_back(&quot;bbb&quot;);</span><br><span class="line">v1.push_back(&quot;aaa&quot;);</span><br><span class="line">v1.push_back(&quot;ccc&quot;);</span><br><span class="line">v1.push_back(&quot;zzzz&quot;);</span><br><span class="line">v1.push_back(&quot;ccc&quot;);</span><br><span class="line">string s1 = &quot;ccc&quot;;</span><br><span class="line">//int num = count_if(v1.begin(),v1.end(), equal_to&lt;string&gt;(),s1);</span><br><span class="line">int num = count_if(v1.begin(),v1.end(),bind2nd(equal_to&lt;string&gt;(), s1));</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>逻辑函数对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">逻辑与 logical_and&lt;Type&gt;</span><br><span class="line">logical_and&lt;int&gt; indAnd;</span><br><span class="line">ires = intAnd(ival1,ival2);</span><br><span class="line">dres=BinaryFunc( logical_and&lt;double&gt;(),dval1,dval2);</span><br><span class="line">逻辑或logical_or&lt;Type&gt;</span><br><span class="line">逻辑非logical_not&lt;Type&gt;</span><br><span class="line">logical_not&lt;int&gt; IntNot;</span><br><span class="line">Ires = IntNot(ival1);</span><br><span class="line">Dres=UnaryFunc( logical_not&lt;double&gt;,dval1);</span><br></pre></td></tr></table></figure><h4 id="函数适配器"><a class="markdownIt-Anchor" href="#函数适配器"></a> 函数适配器</h4><p>​        <strong>函数适配器的理论知识</strong></p><p><img src="/images/javawz/1625480849621.png" alt="1625480849621"></p><p><img src="/images/javawz/1625480873142.png" alt="1625480873142"></p><p><img src="/images/javawz/1625480877479.png" alt="1625480877479"></p><p><img src="/images/javawz/1625480882053.png" alt="1625480882053"></p><p><strong>常用函数函数适配器</strong></p><p>标准库提供一组函数适配器，用来特殊化或者扩展一元和二元函数对象。常用适配器是：</p><p>1绑定器（binder）: binder通过把二元函数对象的一个实参绑定到一个特殊的值上，将其转换成一元函数对象。C＋＋标准库提供两种预定义的binder适配器：bind1st和bind2nd，前者把值绑定到二元函数对象的第一个实参上，后者绑定在第二个实参上。</p><p>2取反器(negator) : negator是一个将函数对象的值翻转的函数适配器。标准库提供两个预定义的ngeator适配器：not1翻转一元预定义函数对象的真值,而not2翻转二元谓词函数的真值。</p><p>常用函数适配器列表如下：</p><p>bind1st(op, value)</p><p>bind2nd(op, value)</p><p>not1(op)</p><p>not2(op)</p><p>mem_fun_ref(op)</p><p>mem_fun(op)</p><p>ptr_fun(op)</p><p><strong>3）常用函数适配器案例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class IsGreat</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">IsGreat(int i)</span><br><span class="line">&#123;</span><br><span class="line">m_num = i;</span><br><span class="line">&#125;</span><br><span class="line">bool operator()(int &amp;num)</span><br><span class="line">&#123;</span><br><span class="line">if (num &gt; m_num)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">private:</span><br><span class="line">int m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main43()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;  v1;</span><br><span class="line">for (int i=0; i&lt;5; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator it = v1.begin(); it!=v1.end(); it ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot; ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int num1 = count(v1.begin(), v1.end(), 3);</span><br><span class="line">cout &lt;&lt; &quot;num1:&quot; &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//通过谓词求大于2的个数</span><br><span class="line">int num2 = count_if(v1.begin(), v1.end(), IsGreat(2)); </span><br><span class="line">cout &lt;&lt; &quot;num2:&quot; &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//通过预定义函数对象求大于2的个数   greater&lt;int&gt;() 有2个参数 </span><br><span class="line">//param &gt; 2</span><br><span class="line">int num3 = count_if(v1.begin(), v1.end(), bind2nd(greater&lt;int&gt;(), 2 ) );</span><br><span class="line">cout &lt;&lt; &quot;num3:&quot; &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//取模 能被2整除的数 求奇数</span><br><span class="line">int num4 = count_if(v1.begin(), v1.end(), bind2nd(modulus &lt;int&gt;(), 2 ) ); </span><br><span class="line">cout &lt;&lt; &quot;奇数num4:&quot; &lt;&lt; num4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int num5 = count_if(v1.begin(), v1.end(), not1( bind2nd(modulus &lt;int&gt;(), 2 ) ) ); </span><br><span class="line">cout &lt;&lt; &quot;偶数num5:&quot; &lt;&lt; num5 &lt;&lt; endl;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10328-stl的容器算法迭代器的设计理念"><a class="markdownIt-Anchor" href="#10328-stl的容器算法迭代器的设计理念"></a> 10.3.2.8 STL的容器算法迭代器的设计理念</h4><p><img src="/images/javawz/clip_image002.jpg" alt="img"></p><p>1） STL的容器通过<strong>类模板</strong>技术，实现数据类型和容器模型的分离。</p><p>2） STL的迭代器技术实现了遍历容器的统一方法；也为STL的算法提供了统一性</p><p>3） STL的函数对象实现了自定义数据类型的算法运算。（算法和）</p><p>4） 具体例子：transform算法的输入，通过迭代器first和last指向的元算作为输入；通过result作为输出；通过函数对象来做自定义数据类型的运算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#算法&quot;&gt;&lt;/a&gt; 算法&lt;/h1&gt;
&lt;h3 id=&quot;算法基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#算法基础&quot;&gt;&lt;/a&gt; 算法基础&lt;/h3&gt;
&lt;h4 
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>容器共性机制研究</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0087-%E5%AE%B9%E5%99%A8%E5%85%B1%E6%80%A7%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0087-容器共性机制研究/</id>
    <published>2021-07-05T06:41:46.000Z</published>
    <updated>2021-07-05T06:51:15.814Z</updated>
    
    <content type="html"><![CDATA[<h4 id="容器的共通能力"><a class="markdownIt-Anchor" href="#容器的共通能力"></a> 容器的共通能力</h4><p>C++模板是容器的概念。</p><p><img src="/images/javawz/1625467342426.png" alt="1625467342426"></p><p><b>理论提高：</b>所有容器提供的都是值（value）语意，而非引用（reference）语意。<strong>容器执行插入元素的操作时，内部实施拷贝动作。<strong>所以STL容器内存储的元素必须</strong>能够被拷贝</strong>（必须提供拷贝构造函数）。</p><p>除了queue与stack外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。</p><p>通常STL不会丢出异常。要求使用者确保传入正确的参数。</p><p>每个容器都提供了一个默认构造函数跟一个默认拷贝构造函数。</p><p>如已有容器vecIntA。</p><p>vector&lt;int&gt; vecIntB(vecIntA); //调用拷贝构造函数，复制vecIntA到vecIntB中。</p><p>与大小相关的操作方法(c代表容器)：</p><p>c.size();  //返回容器中元素的个数</p><p>c.empty();  //判断容器是否为空</p><p>比较操作(c1,c2代表容器)：</p><p>c1 == c2   判断c1是否等于c2</p><p>c1 != c2   判断c1是否不等于c2</p><p>c1 = c2    把c2的所有元素指派给c1</p><h4 id="各个容器的使用时机"><a class="markdownIt-Anchor" href="#各个容器的使用时机"></a> 各个容器的使用时机</h4><p><img src="/images/javawz/1625467543529.png" alt="1625467543529"></p><p><b> deque的使用场景：</b>比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</p><h5 id="vector与deque的比较"><a class="markdownIt-Anchor" href="#vector与deque的比较"></a> vector与deque的比较：</h5><p>一：<a href="http://vector.at" target="_blank" rel="noopener">vector.at</a>()<a href="http://xn--deque-gu8k.at" target="_blank" rel="noopener">比deque.at</a>()效率高，<a href="http://xn--vector-hh4kj42j.at" target="_blank" rel="noopener">比如vector.at</a>(0)是固定的，deque的开始位置却是不固定的。</p><p>二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</p><p>三：deque支持头部的快速插入与快速移除，这是deque的优点。</p><p><b> list的使用场景：</b>比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p><p><b>set的使用场景：</b>比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。</p><p><b> map的使用场景：</b>比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;容器的共通能力&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#容器的共通能力&quot;&gt;&lt;/a&gt; 容器的共通能力&lt;/h4&gt;
&lt;p&gt;C++模板是容器的概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/162546734242
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>Map和multimap容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0086-Map%E5%92%8Cmultimap%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0086-Map和multimap容器/</id>
    <published>2021-07-05T06:30:26.000Z</published>
    <updated>2021-07-05T06:41:11.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="map和multimap容器"><a class="markdownIt-Anchor" href="#map和multimap容器"></a> Map和multimap容器</h1><p>map是标准的<strong>关联式</strong>容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。</p><p>map中<strong>key值是唯一的</strong>。集合中的元素按一定的<strong>顺序</strong>排列。元素插入过程是按排序规则插入，所以不能指定插入位置。</p><p>map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入操作和删除操作上比vector快。</p><p>map可以直接存取key所对应的value，支持[]操作符，如map[key]=value。</p><p>multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。</p><p>#include &lt;map&gt;</p><p><img src="/images/javawz/1625466752833.png" alt="1625466752833"></p><h4 id="mapmultimap对象的默认构造"><a class="markdownIt-Anchor" href="#mapmultimap对象的默认构造"></a> map/multimap对象的默认构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map/multimap采用模板类实现，对象的默认构造形式：</span><br><span class="line">map&lt;T1,T2&gt; mapTT; </span><br><span class="line">multimap&lt;T1,T2&gt;  multimapTT;  </span><br><span class="line">如：</span><br><span class="line">map&lt;int, char&gt; mapA;</span><br><span class="line">map&lt;string,float&gt; mapB;</span><br><span class="line">//其中T1,T2还可以用各种指针类型或自定义类型</span><br></pre></td></tr></table></figure><h4 id="map的插入与迭代器"><a class="markdownIt-Anchor" href="#map的插入与迭代器"></a> map的插入与迭代器</h4><p>map.insert(…);  //往容器插入元素，返回pair&lt;iterator,bool&gt;</p><p>在map中插入元素的三种方式：</p><p>假设 map&lt;int, string&gt; mapStu;</p><h5 id="一-通过pair的方式插入对象"><a class="markdownIt-Anchor" href="#一-通过pair的方式插入对象"></a> 一、通过pair的方式插入对象</h5><p>mapStu.insert( pair&lt;int,string&gt;(3,“小张”) );</p><h5 id="二-通过pair的方式插入对象"><a class="markdownIt-Anchor" href="#二-通过pair的方式插入对象"></a> 二、通过pair的方式插入对象</h5><p>mapStu.inset(make_pair(-1, “校长-1”));</p><h5 id="三-通过value_type的方式插入对象"><a class="markdownIt-Anchor" href="#三-通过value_type的方式插入对象"></a> 三、通过value_type的方式插入对象</h5><p>mapStu.insert( map&lt;int,string&gt;::value_type(1,“小李”) );</p><h5 id="四-通过数组的方式插入值"><a class="markdownIt-Anchor" href="#四-通过数组的方式插入值"></a> 四、通过数组的方式插入值</h5><p>mapStu[3] = “小刘&quot;;</p><p>mapStu[5] = “小王&quot;；</p><p>​</p><p>前三种方法，采用的是insert()方法，该方法<strong>返回值为pair</strong></p><p>第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值<strong>修改</strong>成“小刘”。若发现已存在3这个键，则修改这个键对应的value。</p><p>string strName = mapStu[2];  //取操作或插入操作</p><p>只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，键为2，值为初始化值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">假设  map&lt;int, string&gt; mapA;</span><br><span class="line">pair&lt; map&lt;int,string&gt;::iterator, bool &gt; pairResult = mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;));//插入方式一</span><br><span class="line"></span><br><span class="line">int iFirstFirst = (pairResult.first)-&gt;first;//iFirst == 3;</span><br><span class="line">string strFirstSecond = (pairResult.first)-&gt;second;//strFirstSecond为&quot;小张&quot;</span><br><span class="line">bool bSecond = pairResult.second;//bSecond == true;</span><br><span class="line"></span><br><span class="line">mapA.insert(map&lt;int,string&gt;::value_type(1,&quot;小李&quot;));//插入方式二</span><br><span class="line"></span><br><span class="line">mapA[3] = &quot;小刘&quot;;//修改value</span><br><span class="line">mapA[5] = &quot;小王&quot;;//插入方式三</span><br><span class="line"></span><br><span class="line">string str1 = mapA[2];//执行插入 string() 操作，返回的str1的字符串内容为空。</span><br><span class="line">string str2 = mapA[3];//取得value，str2为&quot;小刘&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//迭代器遍历</span><br><span class="line">for (map&lt;int,string&gt;::iterator it=mapA.begin(); it!=mapA.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;int, string&gt; pr = *it;</span><br><span class="line">int iKey = pr.first;</span><br><span class="line">string strValue = pr.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;T1,T2,less&lt;T1&gt; &gt;  mapA;  //该容器是按键的升序方式排列元素。未指定函数对象，默认采用less&lt;T1&gt;函数对象。</span><br><span class="line">map&lt;T1,T2,greater&lt;T1&gt;&gt; mapB;   //该容器是按键的降序方式排列元素。</span><br><span class="line">less&lt;T1&gt;与greater&lt;T1&gt;  可以替换成其它的函数对象functor。</span><br><span class="line">可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。</span><br><span class="line">map.begin();  //返回容器中第一个数据的迭代器。</span><br><span class="line">map.end();  //返回容器中最后一个数据之后的迭代器。</span><br><span class="line">map.rbegin();  //返回容器中倒数第一个元素的迭代器。</span><br><span class="line">map.rend();   //返回容器中倒数最后一个元素的后面的迭代器。</span><br></pre></td></tr></table></figure><h4 id="map对象的拷贝构造与赋值"><a class="markdownIt-Anchor" href="#map对象的拷贝构造与赋值"></a> map对象的拷贝构造与赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map(const map &amp;mp);     //拷贝构造函数</span><br><span class="line">map&amp; operator=(const map &amp;mp);//重载等号操作符</span><br><span class="line">map.swap(mp);//交换两个集合容器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line">map&lt;int, string&gt; mapA;</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;));</span><br><span class="line"></span><br><span class="line">map&lt;int ,string&gt; mapB(mapA);//拷贝构造</span><br><span class="line"></span><br><span class="line">map&lt;int, string&gt; mapC;</span><br><span class="line">mapC = mapA;//赋值</span><br><span class="line"></span><br><span class="line">mapC[3] = &quot;老张&quot;;</span><br><span class="line">mapC.swap(mapA);//交换</span><br></pre></td></tr></table></figure><h4 id="map的大小"><a class="markdownIt-Anchor" href="#map的大小"></a> map的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.size();//返回容器中元素的数目</span><br><span class="line">map.empty();//判断容器是否为空</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int, string&gt; mapA;</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;));</span><br><span class="line"></span><br><span class="line">if (mapA.empty())</span><br><span class="line">&#123;</span><br><span class="line">int iSize = mapA.size();//iSize == 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map的删除"><a class="markdownIt-Anchor" href="#map的删除"></a> map的删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.clear();//删除所有元素</span><br><span class="line">map.erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">map.erase(beg,end);    //删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</span><br><span class="line">map.erase(keyElem);     //删除容器中key为keyElem的对组。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int, string&gt; mapA;</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;));</span><br><span class="line"></span><br><span class="line">//删除区间内的元素</span><br><span class="line">map&lt;int,string&gt;::iterator itBegin=mapA.begin();</span><br><span class="line">++ itBegin;</span><br><span class="line">++ itBegin;</span><br><span class="line">map&lt;int,string&gt;::iterator itEnd=mapA.end();</span><br><span class="line">mapA.erase(itBegin,itEnd);//此时容器mapA包含按顺序的&#123;1,&quot;小杨&quot;&#125;&#123;3,&quot;小张&quot;&#125;两个元素。</span><br><span class="line"></span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;));</span><br><span class="line"></span><br><span class="line">//删除容器中第一个元素</span><br><span class="line">mapA.erase(mapA.begin());//此时容器mapA包含了按顺序的&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;三个元素</span><br><span class="line"></span><br><span class="line">//删除容器中key为5的元素</span><br><span class="line">mapA.erase(5);    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//删除mapA的所有元素</span><br><span class="line">mapA.clear();//容器为空</span><br></pre></td></tr></table></figure><h4 id="map的查找"><a class="markdownIt-Anchor" href="#map的查找"></a> map的查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.find(key);   查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();</span><br><span class="line">map.count(keyElem);   //返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,string&gt;::iterator it=mapStu.find(3);</span><br><span class="line">if(it == mapStu.end())</span><br><span class="line">&#123;</span><br><span class="line">//没找到</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    //找到了</span><br><span class="line">        pair&lt;int, string&gt; pairStu = *it;</span><br><span class="line">  int iID = pairStu.first;//或   int  iID = it-&gt;first;</span><br><span class="line">        string strName = pairStu.second;//或   string strName = it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map.lower_bound(keyElem);  //返回第一个key&gt;=keyElem元素的迭代器。</span><br><span class="line">map.upper_bound(keyElem);   //  返回第一个key&gt;keyElem元素的迭代器。</span><br><span class="line">例如：  mapStu是用map&lt;int,string&gt;声明的容器，已包含&#123;1,&quot;小李&quot;&#125;&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;&#123;9,&quot;小陈&quot;&#125;元素。map&lt;int,string&gt;::iterator it;</span><br><span class="line">it = mapStu.lower_bound(5);  //it-&gt;first==5    it-&gt;second==&quot;小王&quot;</span><br><span class="line">it = mapStu.upper_bound(5);   //it-&gt;first==7   it-&gt;second==&quot;小赵&quot;</span><br><span class="line">it = mapStu.lower_bound(6);  //it-&gt;first==7    it-&gt;second==&quot;小赵&quot;</span><br><span class="line">it = mapStu.upper_bound(6);    //it-&gt;first==7   it-&gt;second==&quot;小赵&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。</span><br><span class="line"> </span><br><span class="line">以上函数返回两个迭代器，而这两个迭代器被封装在pair中。</span><br><span class="line"></span><br><span class="line">例如 map&lt;int,string&gt; mapStu;</span><br><span class="line">...  //往mapStu容器插入元素&#123;1,&quot;小李&quot;&#125;&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;&#123;9,&quot;小陈&quot;&#125;</span><br><span class="line">pair&lt; map&lt;int,string&gt;::iterator , map&lt;int,string&gt;::iterator &gt; pairIt = mapStu.equal_range(5);</span><br><span class="line">map&lt;int, string&gt;::iterator itBeg = pairIt.first;</span><br><span class="line">map&lt;int, string&gt;::iterator itEnd = pairIt.second;</span><br><span class="line">//此时 itBeg-&gt;first==5  ,  itEnd-&gt;first == 7,</span><br><span class="line">itBeg-&gt;second==&quot;小王&quot;, itEnd-&gt;second==&quot;小赵&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;map和multimap容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#map和multimap容器&quot;&gt;&lt;/a&gt; Map和multimap容器&lt;/h1&gt;
&lt;p&gt;map是标准的&lt;strong&gt;关联式&lt;/strong&gt;容器，一个map是
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>Set和multiset容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0085-Set%E5%92%8Cmultiset%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0085-Set和multiset容器/</id>
    <published>2021-07-05T06:17:49.000Z</published>
    <updated>2021-07-05T06:29:05.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="set和multiset容器"><a class="markdownIt-Anchor" href="#set和multiset容器"></a> Set和multiset容器</h1><p>set是一个<strong>集合</strong>容器，其中所包含的元素是<strong>唯一</strong>的，<strong>集合中的元素按一定的顺序排列</strong>。<strong>元素插入过程是按排序规则插入</strong>，所以不能指定插入位置。</p><p>set采用<strong>红黑树</strong>变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。</p><p>set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。</p><p>multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中<strong>同一值可以出现多次</strong>。</p><p>不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。</p><p>#include &lt;set&gt;</p><h4 id="setmultiset对象的默认构造"><a class="markdownIt-Anchor" href="#setmultiset对象的默认构造"></a> set/multiset对象的默认构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; setInt;            //一个存放int的set容器。</span><br><span class="line">set&lt;float&gt; setFloat;     //一个存放float的set容器。</span><br><span class="line">set&lt;string&gt; setString;     //一个存放string的set容器。</span><br><span class="line">multiset&lt;int&gt; mulsetInt;            //一个存放int的multi set容器。</span><br><span class="line">multi set&lt;float&gt; multisetFloat;     //一个存放float的multi set容器。</span><br><span class="line">multi set&lt;string&gt; multisetString;     //一个存放string的multi set容器。</span><br></pre></td></tr></table></figure><h4 id="set的插入与迭代器"><a class="markdownIt-Anchor" href="#set的插入与迭代器"></a> set的插入与迭代器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set.insert(elem);     //在容器中插入元素。</span><br><span class="line">set.begin();  //返回容器中第一个数据的迭代器。</span><br><span class="line">set.end();  //返回容器中最后一个数据之后的迭代器。</span><br><span class="line">set.rbegin();  //返回容器中倒数第一个元素的迭代器。</span><br><span class="line">set.rend();   //返回容器中倒数最后一个元素的后面的迭代器。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; setInt;</span><br><span class="line">setInt.insert(3); setInt.insert(1);setInt.insert(5);setInt.insert(2);</span><br><span class="line">for(set&lt;int&gt;::iterator it=setInt.begin(); it!=setInt.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">      int iItem = *it;</span><br><span class="line">      cout &lt;&lt; iItem;    //或直接使用cout &lt;&lt; *it</span><br><span class="line">&#125;</span><br><span class="line">//这样子便顺序输出  1 2 3 5。</span><br><span class="line"></span><br><span class="line">set.rbegin()与set.rend()</span><br></pre></td></tr></table></figure><h4 id="set集合的元素排序"><a class="markdownIt-Anchor" href="#set集合的元素排序"></a> Set集合的元素排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int,less&lt;int&gt; &gt;  setIntA;  //该容器是按升序方式排列元素。</span><br><span class="line">set&lt;int,greater&lt;int&gt;&gt; setIntB;   //该容器是按降序方式排列元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set&lt;int&gt; 相当于 set&lt;int,less&lt;int&gt;&gt;。</span><br><span class="line">less&lt;int&gt;与greater&lt;int&gt;中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。</span><br><span class="line">//疑问1：less&lt;&gt;与greater&lt;&gt;是什么？</span><br><span class="line"></span><br><span class="line">疑问2：如果set&lt;&gt;不包含int类型，而是包含自定义类型，set容器如何排序？</span><br><span class="line">要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫functor。</span><br><span class="line">下面将讲解什么是functor，functor的用法。</span><br><span class="line">使用stl提供的函数对象</span><br><span class="line">set&lt;int,greater&lt;int&gt;&gt; setIntB;   </span><br><span class="line">setIntB.insert(3);</span><br><span class="line">setIntB.insert(1);</span><br><span class="line">setIntB.insert(5);</span><br><span class="line">setIntB.insert(2);</span><br><span class="line">此时容器setIntB就包含了按顺序的5,3,2,1元素</span><br></pre></td></tr></table></figure><h4 id="函数对象functor的用法"><a class="markdownIt-Anchor" href="#函数对象functor的用法"></a> 函数对象functor的用法</h4><p>尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。</p><p>functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。</p><p>greater&lt;&gt;与less&lt;&gt;就是函数对象。</p><p>下面举出greater&lt;int&gt;的简易实现原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">struct greater</span><br><span class="line">&#123;</span><br><span class="line">bool operator() (const int&amp; iLeft, const int&amp; iRight)</span><br><span class="line">&#123;</span><br><span class="line">       return (iLeft&gt;iRight);    //如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">容器就是调用函数对象的operator()方法去比较两个值的大小。</span><br><span class="line"></span><br><span class="line">题目：学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。</span><br><span class="line"></span><br><span class="line">解：</span><br><span class="line">//学生类</span><br><span class="line">class CStudent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CStudent(int iID, string strName)</span><br><span class="line">&#123;</span><br><span class="line">m_iID = iID;</span><br><span class="line">m_strName = strName;</span><br><span class="line">&#125;</span><br><span class="line">     int m_iID;//学号</span><br><span class="line">     string m_strName; //姓名</span><br><span class="line">&#125;</span><br><span class="line">//为保持主题鲜明，本类不写拷贝构造函数，本类也不需要写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。</span><br><span class="line"></span><br><span class="line">//函数对象</span><br><span class="line">struct StuFunctor</span><br><span class="line">&#123;</span><br><span class="line">bool operator()  (const CStudent &amp;stu1, const CStudent &amp;stu2)</span><br><span class="line">&#123;</span><br><span class="line">return (stu1.m_iID&lt;stu2.m_iID);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//main函数</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;CStudent, StuFunctor&gt; setStu;</span><br><span class="line">setStu.insert(CStudent(3,&quot;小张&quot;));</span><br><span class="line">setStu.insert(CStudent(1,&quot;小李&quot;));</span><br><span class="line">setStu.insert(CStudent(5,&quot;小王&quot;));</span><br><span class="line">setStu.insert(CStudent(2,&quot;小刘&quot;));</span><br><span class="line">//此时容器setStu包含了四个学生对象，分别是按姓名顺序的“小李”，“小刘”，“小张”，“小王” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set对象的拷贝构造与赋值"><a class="markdownIt-Anchor" href="#set对象的拷贝构造与赋值"></a> set对象的拷贝构造与赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(const set &amp;st);     //拷贝构造函数</span><br><span class="line">set&amp; operator=(const set &amp;st);//重载等号操作符</span><br><span class="line">set.swap(st);//交换两个集合容器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; setIntA;</span><br><span class="line">setIntA.insert(3);</span><br><span class="line">setIntA.insert(1);</span><br><span class="line">setIntA.insert(7);</span><br><span class="line">setIntA.insert(5);</span><br><span class="line">setIntA.insert(9);</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; setIntB(setIntA);  //1 3 5 7 9</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; setIntC;</span><br><span class="line">setIntC = setIntA;//1 3 5 7 9</span><br><span class="line"></span><br><span class="line">setIntC.insert(6);</span><br><span class="line">setIntC.swap(setIntA);  //交换</span><br></pre></td></tr></table></figure><h4 id="set的大小"><a class="markdownIt-Anchor" href="#set的大小"></a> set的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set.size();//返回容器中元素的数目</span><br><span class="line">set.empty();//判断容器是否为空</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; setIntA;</span><br><span class="line">setIntA.insert(3);</span><br><span class="line">setIntA.insert(1);</span><br><span class="line">setIntA.insert(7);</span><br><span class="line">setIntA.insert(5);</span><br><span class="line">setIntA.insert(9);</span><br><span class="line"></span><br><span class="line">if (!setIntA.empty())</span><br><span class="line">&#123;</span><br><span class="line">int iSize = setIntA.size();//5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set的删除"><a class="markdownIt-Anchor" href="#set的删除"></a> set的删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set.clear();//清除所有元素</span><br><span class="line">set.erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">set.erase(beg,end);    //删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</span><br><span class="line">set.erase(elem);     //删除容器中值为elem的元素。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">删除区间内的元素</span><br><span class="line">setInt是用set&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9,11元素。</span><br><span class="line">set&lt;int&gt;::iterator itBegin=setInt.begin();</span><br><span class="line">++ itBegin;</span><br><span class="line">set&lt;int&gt;::iterator itEnd=setInt.begin();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">setInt.erase(itBegin,itEnd);</span><br><span class="line">//此时容器setInt包含按顺序的1,6,9,11四个元素。</span><br><span class="line"></span><br><span class="line">删除容器中第一个元素</span><br><span class="line">setInt.erase(setInt.begin());//6,9,11</span><br><span class="line"></span><br><span class="line">删除容器中值为9的元素</span><br><span class="line">set.erase(9);    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除setInt的所有元素</span><br><span class="line">setInt.clear();//容器为空</span><br></pre></td></tr></table></figure><h4 id="set的查找"><a class="markdownIt-Anchor" href="#set的查找"></a> set的查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set.find(elem);   //查找elem元素，返回指向elem元素的迭代器。</span><br><span class="line"></span><br><span class="line">set.count(elem);   //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。</span><br><span class="line"></span><br><span class="line">set.lower_bound(elem);  //返回第一个&gt;=elem元素的迭代器。</span><br><span class="line">set.upper_bound(elem);   //  返回第一个&gt;elem元素的迭代器。</span><br><span class="line">set.equal_range(elem);//返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。</span><br><span class="line"> </span><br><span class="line">以上函数返回两个迭代器，而这两个迭代器被封装在pair中。</span><br><span class="line">以下讲解pair的含义与使用方法。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; setInt;</span><br><span class="line">setInt.insert(3);</span><br><span class="line">setInt.insert(1);</span><br><span class="line">setInt.insert(7);</span><br><span class="line">setInt.insert(5);</span><br><span class="line">setInt.insert(9);</span><br><span class="line"></span><br><span class="line">set&lt;int&gt;::iterator itA = setInt.find(5);</span><br><span class="line">int iA = *itA;//iA == 5</span><br><span class="line">int iCount = setInt.count(5);//iCount == 1</span><br><span class="line"></span><br><span class="line">set&lt;int&gt;::iterator itB = setInt.lower_bound(5);</span><br><span class="line">set&lt;int&gt;::iterator itC = setInt.upper_bound(5);</span><br><span class="line">int iB = *itB;//iB == 5</span><br><span class="line">int iC = *itC; //iC == 7</span><br><span class="line"></span><br><span class="line">pair&lt; set&lt;int&gt;::iterator, set&lt;int&gt;::iterator &gt; pairIt = setInt.equal_range(5);  //pair是什么？</span><br></pre></td></tr></table></figure><h4 id="pair的使用"><a class="markdownIt-Anchor" href="#pair的使用"></a> pair的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair译为对组，可以将两个值视为一个单元。</span><br><span class="line">pair&lt;T1,T2&gt;存放的两个值的类型，可以不一样，如T1为int，T2为float。T1,T2也可以是自定义类型。</span><br><span class="line">pair.first是pair里面的第一个值，是T1类型。</span><br><span class="line">pair.second是pair里面的第二个值，是T2类型。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; setInt;</span><br><span class="line">...  //往setInt容器插入元素1,3,5,7,9</span><br><span class="line">pair&lt; set&lt;int&gt;::iterator , set&lt;int&gt;::iterator &gt; pairIt = setInt.equal_range(5);</span><br><span class="line">set&lt;int&gt;::iterator itBeg = pairIt.first;</span><br><span class="line">set&lt;int&gt;::iterator itEnd = pairIt.second;</span><br><span class="line">//此时 *itBeg==5  而  *itEnd == 7</span><br></pre></td></tr></table></figure><h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4><p>一、容器set/multiset的使用方法；</p><p>​              红黑树的变体，查找效率高，插入不能指定位置，插入时自动排序。</p><p>二、functor的使用方法；</p><p>类似于函数的功能，可用来自定义一些规则，如元素比较规则。</p><p>三、pair的使用方法。</p><p>​     对组，一个整体的单元，存放两个类型(T1,T2，T1可与T2一样)的两个元素。</p><p>案例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int x;</span><br><span class="line">   scanf(&quot;%ld&quot;,&amp;x);</span><br><span class="line">   multiset&lt;int&gt; h;//建立一个multiset类型，变量名是h，h序列里面存的是int类型,初始h为空</span><br><span class="line">   while(x!=0)&#123;</span><br><span class="line">       h.insert(x);//将x插入h中</span><br><span class="line">       scanf(&quot;%ld&quot;,&amp;x);</span><br><span class="line">   &#125;    </span><br><span class="line"></span><br><span class="line">pair&lt; multiset&lt;int&gt;::iterator , multiset&lt;int&gt;::iterator &gt; pairIt = h.equal_range(22);</span><br><span class="line">multiset&lt;int&gt;::iterator itBeg = pairIt.first;</span><br><span class="line">multiset&lt;int&gt;::iterator itEnd = pairIt.second;</span><br><span class="line"></span><br><span class="line">int nBeg = *itBeg;</span><br><span class="line">int nEnd = *itEnd;</span><br><span class="line"></span><br><span class="line">   while(!h.empty())&#123;// 序列非空h.empty()==true时表示h已经空了</span><br><span class="line">multiset&lt;int&gt;::iterator c = h.begin();//c指向h序列中第一个元素的地址，第一个元素是最小的元素</span><br><span class="line">       printf(&quot;%ld &quot;,*c);//将地址c存的数据输出</span><br><span class="line">       h.erase(c);//从h序列中将c指向的元素删除</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;set和multiset容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#set和multiset容器&quot;&gt;&lt;/a&gt; Set和multiset容器&lt;/h1&gt;
&lt;p&gt;set是一个&lt;strong&gt;集合&lt;/strong&gt;容器，其中所包含的元素
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>优先级队列priority_queue</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0084-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97priority-queue/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0084-优先级队列priority-queue/</id>
    <published>2021-07-05T06:02:34.000Z</published>
    <updated>2021-07-05T06:09:00.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先级队列priority_queue"><a class="markdownIt-Anchor" href="#优先级队列priority_queue"></a> 优先级队列priority_queue</h1><p>最大值优先级队列、最小值优先级队列</p><p>优先级队列适配器 STL priority_queue</p><p>用来开发一些特殊的应用,请对stl的类库,多做扩展性学习</p><p>默认是从大到小插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;int, deque&lt;int&gt;&gt; pq;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;&gt; pq;</span><br><span class="line">pq.empty()</span><br><span class="line">pq.size()</span><br><span class="line">pq.top()</span><br><span class="line">pq.pop()</span><br><span class="line">pq.push(item)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;queue&quot; </span><br><span class="line">void main81()</span><br><span class="line">&#123;</span><br><span class="line">priority_queue&lt;int&gt; p1; //默认是 最大值优先级队列 </span><br><span class="line">//priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; p1; //相当于这样写</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; p2; //最小值优先级队列</span><br><span class="line"></span><br><span class="line">p1.push(33);</span><br><span class="line">p1.push(11);</span><br><span class="line">p1.push(55);</span><br><span class="line">p1.push(22);</span><br><span class="line">cout &lt;&lt;&quot;队列大小&quot; &lt;&lt; p1.size() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt;&quot;队头&quot; &lt;&lt; p1.top() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">while (p1.size() &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p1.top() &lt;&lt; &quot; &quot;;</span><br><span class="line">p1.pop();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;测试 最小值优先级队列&quot; &lt;&lt; endl;</span><br><span class="line">p2.push(33);</span><br><span class="line">p2.push(11);</span><br><span class="line">p2.push(55);</span><br><span class="line">p2.push(22);</span><br><span class="line">while (p2.size() &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p2.top() &lt;&lt; &quot; &quot;;</span><br><span class="line">p2.pop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;优先级队列priority_queue&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#优先级队列priority_queue&quot;&gt;&lt;/a&gt; 优先级队列priority_queue&lt;/h1&gt;
&lt;p&gt;最大值优先级队列、最小值优先级队列&lt;/p&gt;
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>List容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0083-List%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0083-List容器/</id>
    <published>2021-07-05T05:52:34.000Z</published>
    <updated>2021-07-05T08:33:47.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="list容器"><a class="markdownIt-Anchor" href="#list容器"></a> List容器</h1><p>list是一个<strong>双向链表容器</strong>，可高效地进行插入删除元素。</p><p>list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok) it+5(err)</p><p>#include&lt;list&gt;</p><h4 id="list对象的默认构造"><a class="markdownIt-Anchor" href="#list对象的默认构造"></a> list对象的默认构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list采用采用模板类实现,对象的默认构造形式：list&lt;T&gt; lstT;  如：</span><br><span class="line">list&lt;int&gt; lstInt;            //定义一个存放int的list容器。</span><br><span class="line">list&lt;float&gt; lstFloat;     //定义一个存放float的list容器。</span><br><span class="line">list&lt;string&gt; lstString;     //定义一个存放string的list容器。</span><br><span class="line">...    </span><br><span class="line">//尖括号内还可以设置指针类型或自定义类型。</span><br></pre></td></tr></table></figure><h4 id="list头尾的添加移除操作"><a class="markdownIt-Anchor" href="#list头尾的添加移除操作"></a> list头尾的添加移除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.push_back(elem);   //在容器尾部加入一个元素</span><br><span class="line">list.pop_back();              //删除容器中最后一个元素</span><br><span class="line">list.push_front(elem);     //在容器开头插入一个元素</span><br><span class="line">list.pop_front();              //从容器开头移除第一个元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstInt;</span><br><span class="line">lstInt.push_back(1);</span><br><span class="line">lstInt.push_back(3);</span><br><span class="line">lstInt.push_back(5);</span><br><span class="line">lstInt.push_back(7);</span><br><span class="line">lstInt.push_back(9);</span><br><span class="line">lstInt.pop_front();</span><br><span class="line">lstInt.pop_front();</span><br><span class="line">lstInt.push_front(11);</span><br><span class="line">lstInt.push_front(13);</span><br><span class="line">lstInt.pop_back();</span><br><span class="line">lstInt.pop_back();</span><br><span class="line">// lstInt    &#123;13,11,5&#125;</span><br></pre></td></tr></table></figure><h4 id="list的数据存取"><a class="markdownIt-Anchor" href="#list的数据存取"></a> list的数据存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.front();   //返回第一个元素。</span><br><span class="line">list.back();  //返回最后一个元素。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstInt;</span><br><span class="line">lstInt.push_back(1);</span><br><span class="line">lstInt.push_back(3);</span><br><span class="line">lstInt.push_back(5);</span><br><span class="line">lstInt.push_back(7);</span><br><span class="line">lstInt.push_back(9);</span><br><span class="line"></span><br><span class="line">int iFront = lstInt.front();//1</span><br><span class="line">int iBack = lstInt.back();//9</span><br><span class="line">lstInt.front() = 11;//11</span><br><span class="line">lstInt.back() = 19;//19</span><br></pre></td></tr></table></figure><h4 id="list与迭代器"><a class="markdownIt-Anchor" href="#list与迭代器"></a> list与迭代器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.begin();                     //返回容器中第一个元素的迭代器。</span><br><span class="line">list.end();                       //返回容器中最后一个元素之后的迭代器。</span><br><span class="line">list.rbegin();         //返回容器中倒数第一个元素的迭代器。</span><br><span class="line">list.rend();         //返回容器中倒数最后一个元素的后面的迭代器。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstInt;</span><br><span class="line">lstInt.push_back(1);</span><br><span class="line">lstInt.push_back(3);</span><br><span class="line">lstInt.push_back(5);</span><br><span class="line">lstInt.push_back(7);</span><br><span class="line">lstInt.push_back(9);</span><br><span class="line"></span><br><span class="line">for (list&lt;int&gt;::iterator it=lstInt.begin(); it!=lstInt.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it;</span><br><span class="line">cout &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (list&lt;int&gt;::reverse_iterator rit=lstInt.rbegin(); rit!=lstInt.rend(); ++rit)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *rit;</span><br><span class="line">cout &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list对象的带参数构造"><a class="markdownIt-Anchor" href="#list对象的带参数构造"></a> list对象的带参数构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list(beg,end);    //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</span><br><span class="line">list(n,elem);   //构造函数将n个elem拷贝给本身。</span><br><span class="line">list(const list &amp;lst);  //拷贝构造函数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstIntA;</span><br><span class="line">lstIntA.push_back(1);</span><br><span class="line">lstIntA.push_back(3);</span><br><span class="line">lstIntA.push_back(5);</span><br><span class="line">lstIntA.push_back(7);</span><br><span class="line">lstIntA.push_back(9);</span><br><span class="line"></span><br><span class="line">list&lt;int&gt; lstIntB(lstIntA.begin(),lstIntA.end());//1 3 5 7 9</span><br><span class="line">list&lt;int&gt; lstIntC(5,8);//8 8 8 8 8 </span><br><span class="line">list&lt;int&gt; lstIntD(lstIntA);//1 3 5 7 9</span><br></pre></td></tr></table></figure><h4 id="list的赋值"><a class="markdownIt-Anchor" href="#list的赋值"></a> list的赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.assign(beg,end);    //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</span><br><span class="line">list.assign(n,elem);  //将n个elem拷贝赋值给本身。</span><br><span class="line">list&amp; operator=(const list &amp;lst);//重载等号操作符</span><br><span class="line">list.swap(lst);  // 将lst与本身的元素互换。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstIntA,lstIntB,lstIntC,lstIntD;</span><br><span class="line">lstIntA.push_back(1);</span><br><span class="line">lstIntA.push_back(3);</span><br><span class="line">lstIntA.push_back(5);</span><br><span class="line">lstIntA.push_back(7);</span><br><span class="line">lstIntA.push_back(9);</span><br><span class="line"></span><br><span class="line">lstIntB.assign(lstIntA.begin(),lstIntA.end());//1 3 5 7 9</span><br><span class="line">lstIntC.assign(5,8);//8 8 8 8 8</span><br><span class="line">lstIntD = lstIntA;//1 3 5 7 9</span><br><span class="line">lstIntC.swap(lstIntD);//互换</span><br></pre></td></tr></table></figure><h4 id="list的大小"><a class="markdownIt-Anchor" href="#list的大小"></a> list的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.size();   //返回容器中元素的个数</span><br><span class="line">list.empty();   //判断容器是否为空</span><br><span class="line">list.resize(num);   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">list.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstIntA;</span><br><span class="line">lstIntA.push_back(1);</span><br><span class="line">lstIntA.push_back(3);</span><br><span class="line">lstIntA.push_back(5);</span><br><span class="line"></span><br><span class="line">if (!lstIntA.empty())</span><br><span class="line">&#123;</span><br><span class="line">int iSize = lstIntA.size();//3</span><br><span class="line">lstIntA.resize(5);//1 3 5 0 0</span><br><span class="line">lstIntA.resize(7,1);//1 3 5 0 0 1 1</span><br><span class="line">lstIntA.resize(2);//1 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list的插入"><a class="markdownIt-Anchor" href="#list的插入"></a> list的插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.insert(pos,elem);   //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br><span class="line">list.insert(pos,n,elem);   //在pos位置插入n个elem数据，无返回值。</span><br><span class="line">list.insert(pos,beg,end);   //在pos位置插入[beg,end)区间的数据，无返回值。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstA;</span><br><span class="line">list&lt;int&gt; lstB;</span><br><span class="line"></span><br><span class="line">lstA.push_back(1);</span><br><span class="line">lstA.push_back(3);</span><br><span class="line">lstA.push_back(5);</span><br><span class="line">lstA.push_back(7);</span><br><span class="line">lstA.push_back(9);</span><br><span class="line"></span><br><span class="line">lstB.push_back(2);</span><br><span class="line">lstB.push_back(4);</span><br><span class="line">lstB.push_back(6);</span><br><span class="line">lstB.push_back(8);</span><br><span class="line"></span><br><span class="line">lstA.insert(lstA.begin(), 11);//&#123;11, 1, 3, 5, 7, 9&#125;</span><br><span class="line">lstA.insert(++lstA.begin(),2,33);//&#123;11,33,33,1,3,5,7,9&#125;</span><br><span class="line">lstA.insert(lstA.begin() , lstB.begin() , lstB.end() );//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span><br></pre></td></tr></table></figure><h4 id="list的删除"><a class="markdownIt-Anchor" href="#list的删除"></a> list的删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.clear();//移除容器的所有数据</span><br><span class="line">list.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">list.erase(pos);    //删除pos位置的数据，返回下一个数据的位置。</span><br><span class="line">list.remove(elem);   //删除容器中所有与elem值匹配的元素。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//删除区间内的元素</span><br><span class="line">lstInt是用list&lt;int&gt; //声明的容器，现已包含按顺序的1,3,5,6,9元素。</span><br><span class="line">list&lt;int&gt;::iterator itBegin=lstInt.begin();</span><br><span class="line">++ itBegin;</span><br><span class="line">list&lt;int&gt;::iterator itEnd=lstInt.begin();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">lstInt.erase(itBegin,itEnd);</span><br><span class="line">//此时容器lstInt包含按顺序的1,6,9三个元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//假设 lstInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素的方法一</span><br><span class="line">for(list&lt;int&gt;::iterator it=lstInt.being(); it!=lstInt.end(); )    //小括号里不需写  ++it</span><br><span class="line">&#123;</span><br><span class="line">   if(*it == 3)</span><br><span class="line">   &#123;</span><br><span class="line">        it  =  lstInt.erase(it);       //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span><br><span class="line">         //此时，不执行  ++it；  </span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">       ++it;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除容器中等于3的元素的方法二</span><br><span class="line">lstInt.remove(3);</span><br><span class="line"></span><br><span class="line">//删除lstInt的所有元素</span><br><span class="line">lstInt.clear();//容器为空</span><br></pre></td></tr></table></figure><h4 id="list的反序排列"><a class="markdownIt-Anchor" href="#list的反序排列"></a> list的反序排列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.reverse();     //反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstA;</span><br><span class="line"></span><br><span class="line">lstA.push_back(1);</span><br><span class="line">lstA.push_back(3);</span><br><span class="line">lstA.push_back(5);</span><br><span class="line">lstA.push_back(7);</span><br><span class="line">lstA.push_back(9);</span><br><span class="line"></span><br><span class="line">lstA.reverse();//9 7 5 3 1</span><br></pre></td></tr></table></figure><h4 id="list排序"><a class="markdownIt-Anchor" href="#list排序"></a> list排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list.sort();//默认从小到大</span><br><span class="line">改变规则需要提供回调函数</span><br><span class="line">例如比较两个int类型的回调函数</span><br><span class="line"></span><br><span class="line">bool Compare(const int&amp; x,const int&amp; y) &#123;</span><br><span class="line">return x &gt; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool Compare(const int&amp; x,const int&amp; y) &#123;</span><br><span class="line">return x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line">list&lt;int&gt; li;</span><br><span class="line">li.push_back(10);</span><br><span class="line">li.push_back(20);</span><br><span class="line">li.push_back(40);</span><br><span class="line">li.push_back(1);</span><br><span class="line">li.push_back(2);</span><br><span class="line"></span><br><span class="line">li.sort(Compare);</span><br><span class="line"></span><br><span class="line">for (list&lt;int&gt;::iterator it = li.begin(); it != li.end();it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一、容器deque的使用方法</p><p>​     适合     在头尾添加移除元素。使用方法与vector类似。</p><p>二、容器queue,stack的使用方法</p><p>​     适合队列，堆栈的操作方式。</p><p>三、容器list的使用方法</p><p>​     适合在任意位置快速插入移除元素</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;list容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#list容器&quot;&gt;&lt;/a&gt; List容器&lt;/h1&gt;
&lt;p&gt;list是一个&lt;strong&gt;双向链表容器&lt;/strong&gt;，可高效地进行插入删除元素。&lt;/p&gt;
&lt;p&gt;list不可以随
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>Queue容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0082-Queue%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0082-Queue容器/</id>
    <published>2021-07-05T05:48:08.000Z</published>
    <updated>2021-07-05T05:52:08.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="queue容器"><a class="markdownIt-Anchor" href="#queue容器"></a> Queue容器</h1><p>queue是队列容器，是一种“先进先出”的容器。</p><p>queue是简单地装饰deque容器而成为另外的一种容器。</p><p>#include &lt;queue&gt;</p><h4 id="queue对象的默认构造"><a class="markdownIt-Anchor" href="#queue对象的默认构造"></a> queue对象的默认构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue采用模板类实现，queue对象的默认构造形式：queue&lt;T&gt; queT;  如：</span><br><span class="line">queue&lt;int&gt; queInt;            //一个存放int的queue容器。</span><br><span class="line">queue&lt;float&gt; queFloat;     //一个存放float的queue容器。</span><br><span class="line">queue&lt;string&gt; queString;     //一个存放string的queue容器。</span><br><span class="line">...    </span><br><span class="line">//尖括号内还可以设置指针类型或自定义类型。</span><br></pre></td></tr></table></figure><h4 id="queue的push与pop方法"><a class="markdownIt-Anchor" href="#queue的push与pop方法"></a> queue的push()与pop()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.push(elem);   //往队尾添加元素</span><br><span class="line">queue.pop();   //从队头移除第一个元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;int&gt; queInt;</span><br><span class="line">queInt.push(1);queInt.push(3);</span><br><span class="line">queInt.push(5);queInt.push(7);</span><br><span class="line">queInt.push(9);queInt.pop();</span><br><span class="line">queInt.pop();</span><br><span class="line">此时queInt存放的元素是5,7,9</span><br></pre></td></tr></table></figure><h4 id="queue对象的拷贝构造与赋值"><a class="markdownIt-Anchor" href="#queue对象的拷贝构造与赋值"></a> queue对象的拷贝构造与赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue(const queue &amp;que);     //拷贝构造函数</span><br><span class="line">queue&amp; operator=(const queue &amp;que);//重载等号操作符</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;int&gt; queIntA;</span><br><span class="line">queIntA.push(1);</span><br><span class="line">queIntA.push(3);</span><br><span class="line">queIntA.push(5);</span><br><span class="line">queIntA.push(7);</span><br><span class="line">queIntA.push(9);</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; queIntB(queIntA);//拷贝构造</span><br><span class="line">queue&lt;int&gt; queIntC;</span><br><span class="line">queIntC = queIntA;//赋值</span><br></pre></td></tr></table></figure><h4 id="queue的数据存取"><a class="markdownIt-Anchor" href="#queue的数据存取"></a> queue的数据存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.back();   //返回最后一个元素</span><br><span class="line">queue.front();   //返回第一个元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;int&gt; queIntA;</span><br><span class="line">queIntA.push(1);</span><br><span class="line">queIntA.push(3);</span><br><span class="line">queIntA.push(5);</span><br><span class="line">queIntA.push(7);</span><br><span class="line">queIntA.push(9);</span><br><span class="line"></span><br><span class="line">int iFront = queIntA.front();//1</span><br><span class="line">int iBack = queIntA.back();//9</span><br><span class="line"></span><br><span class="line">queIntA.front() = 11;//11</span><br><span class="line">queIntA.back() = 19;//19</span><br></pre></td></tr></table></figure><h4 id="queue的大小"><a class="markdownIt-Anchor" href="#queue的大小"></a> queue的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.empty();   //判断队列是否为空</span><br><span class="line">queue.size();      //返回队列的大小</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;int&gt; queIntA; </span><br><span class="line">queIntA.push(1);   </span><br><span class="line">queIntA.push(3);  </span><br><span class="line">queIntA.push(5);</span><br><span class="line">queIntA.push(7);</span><br><span class="line">queIntA.push(9);</span><br><span class="line"></span><br><span class="line">if (!queIntA.empty())</span><br><span class="line">&#123;</span><br><span class="line">int iSize = queIntA.size();//5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;queue容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#queue容器&quot;&gt;&lt;/a&gt; Queue容器&lt;/h1&gt;
&lt;p&gt;queue是队列容器，是一种“先进先出”的容器。&lt;/p&gt;
&lt;p&gt;queue是简单地装饰deque容器而成为另外的一
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>stack容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0081-stack%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0081-stack容器/</id>
    <published>2021-07-05T05:40:14.000Z</published>
    <updated>2021-07-05T05:47:36.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stack容器"><a class="markdownIt-Anchor" href="#stack容器"></a> stack容器</h1><p>Stack简介</p><p>stack是堆栈容器，是一种“先进后出”的容器。</p><p>stack是简单地装饰deque容器而成为另外的一种容器。</p><p><code>#include &lt;stack&gt;</code></p><h4 id="stack对象的默认构造"><a class="markdownIt-Anchor" href="#stack对象的默认构造"></a> stack对象的默认构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack采用模板类实现， stack对象的默认构造形式： stack &lt;T&gt; stkT;  </span><br><span class="line">stack &lt;int&gt; stkInt;            //一个存放int的stack容器。</span><br><span class="line">stack &lt;float&gt; stkFloat;     //一个存放float的stack容器。</span><br><span class="line">stack &lt;string&gt; stkString;     //一个存放string的stack容器。</span><br><span class="line">...    </span><br><span class="line">//尖括号内还可以设置指针类型或自定义类型。</span><br></pre></td></tr></table></figure><h3 id="stack的push与pop方法"><a class="markdownIt-Anchor" href="#stack的push与pop方法"></a> stack的push()与pop()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack.push(elem);   //往栈头添加元素</span><br><span class="line">stack.pop();   //从栈头移除第一个元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; stkInt;  </span><br><span class="line">stkInt.push(1);stkInt.push(3);stkInt.pop();   </span><br><span class="line">stkInt.push(5);stkInt.push(7);  </span><br><span class="line">stkInt.push(9);stkInt.pop();   </span><br><span class="line">stkInt.pop();  </span><br><span class="line">此时stkInt存放的元素是1,5</span><br></pre></td></tr></table></figure><h4 id="stack对象的拷贝构造与赋值"><a class="markdownIt-Anchor" href="#stack对象的拷贝构造与赋值"></a> stack对象的拷贝构造与赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack(const stack &amp;stk);     //拷贝构造函数</span><br><span class="line">stack&amp; operator=(const stack &amp;stk);//重载等号操作符</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; stkIntA;</span><br><span class="line">stkIntA.push(1);</span><br><span class="line">stkIntA.push(3);</span><br><span class="line">stkIntA.push(5);</span><br><span class="line">stkIntA.push(7);</span><br><span class="line">stkIntA.push(9);</span><br><span class="line"></span><br><span class="line">stack&lt;int&gt; stkIntB(stkIntA);//拷贝构造</span><br><span class="line">stack&lt;int&gt; stkIntC;</span><br><span class="line">stkIntC = stkIntA;//赋值</span><br></pre></td></tr></table></figure><h3 id="stack的数据存取"><a class="markdownIt-Anchor" href="#stack的数据存取"></a> stack的数据存取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.top();  //返回最后一个压入栈元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">stack&lt;int&gt; stkIntA;</span><br><span class="line">stkIntA.push(1);</span><br><span class="line">stkIntA.push(3);</span><br><span class="line">stkIntA.push(5);</span><br><span class="line">stkIntA.push(7);</span><br><span class="line">stkIntA.push(9);</span><br><span class="line"></span><br><span class="line">int iTop = stkIntA.top();//9</span><br><span class="line">stkIntA.top() = 19;//19</span><br></pre></td></tr></table></figure><h3 id="stack的大小"><a class="markdownIt-Anchor" href="#stack的大小"></a> stack的大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack.empty();   //判断堆栈是否为空</span><br><span class="line">stack.size();      //返回堆栈的大小</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; stkIntA;</span><br><span class="line">stkIntA.push(1);</span><br><span class="line">stkIntA.push(3);</span><br><span class="line">stkIntA.push(5);</span><br><span class="line">stkIntA.push(7);</span><br><span class="line">stkIntA.push(9);</span><br><span class="line"></span><br><span class="line">if (!stkIntA.empty())</span><br><span class="line">&#123;</span><br><span class="line">int iSize = stkIntA.size();//5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stack容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stack容器&quot;&gt;&lt;/a&gt; stack容器&lt;/h1&gt;
&lt;p&gt;Stack简介&lt;/p&gt;
&lt;p&gt;stack是堆栈容器，是一种“先进后出”的容器。&lt;/p&gt;
&lt;p&gt;stack是简单地装
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>deque容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/01/cpp0080-STL%E7%9A%84Deque%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/01/cpp0080-STL的Deque容器/</id>
    <published>2021-07-01T05:05:02.000Z</published>
    <updated>2021-07-01T11:26:35.242Z</updated>
    
    <content type="html"><![CDATA[<h4 id="deque简介"><a class="markdownIt-Anchor" href="#deque简介"></a> Deque简介</h4><p>deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数组，而vector是单端的。</p><p>deque在接口上和vector非常相似，在许多操作的地方可以直接替换。</p><p>deque可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。</p><p>deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。</p><p>#include &lt;deque&gt;</p><h4 id="deque对象的默认构造"><a class="markdownIt-Anchor" href="#deque对象的默认构造"></a> deque对象的默认构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deque采用模板类实现，deque对象的默认构造形式：deque&lt;T&gt; deqT;  </span><br><span class="line"></span><br><span class="line">deque &lt;int&gt; deqInt;            //一个存放int的deque容器。</span><br><span class="line">deque &lt;float&gt; deq Float;     //一个存放float的deque容器。</span><br><span class="line">deque &lt;string&gt; deq String;     //一个存放string的deque容器。</span><br><span class="line">...   </span><br><span class="line"> //尖括号内还可以设置指针类型或自定义类型。</span><br></pre></td></tr></table></figure><h4 id="deque末尾的添加移除操作"><a class="markdownIt-Anchor" href="#deque末尾的添加移除操作"></a> deque末尾的添加移除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.push_back(elem);//在容器尾部添加一个数据</span><br><span class="line">deque.push_front(elem);//在容器头部插入一个数据</span><br><span class="line">deque.pop_back();    //删除容器最后一个数据</span><br><span class="line">deque.pop_front();//删除容器第一个数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqInt;</span><br><span class="line">deqInt.push_back(1);</span><br><span class="line">deqInt.push_back(3);</span><br><span class="line">deqInt.push_back(5);</span><br><span class="line">deqInt.push_back(7);</span><br><span class="line">deqInt.push_back(9);</span><br><span class="line">deqInt.pop_front();</span><br><span class="line">deqInt.pop_front();</span><br><span class="line">deqInt.push_front(11);</span><br><span class="line">deqInt.push_front(13);</span><br><span class="line">deqInt.pop_back();</span><br><span class="line">deqInt.pop_back();</span><br><span class="line">//deqInt  &#123; 13,11,5&#125;</span><br></pre></td></tr></table></figure><h4 id="deque的数据存取"><a class="markdownIt-Anchor" href="#deque的数据存取"></a> deque的数据存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.at(idx);  //返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span><br><span class="line">deque[idx];  //返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span><br><span class="line">deque.front();   //返回第一个数据。</span><br><span class="line">deque.back();  //返回最后一个数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqInt;</span><br><span class="line">deqInt.push_back(1);</span><br><span class="line">deqInt.push_back(3);</span><br><span class="line">deqInt.push_back(5);</span><br><span class="line">deqInt.push_back(7);</span><br><span class="line">deqInt.push_back(9);</span><br><span class="line"></span><br><span class="line">int iA = deqInt.at(0);//1</span><br><span class="line">int iB = deqInt[1];//3</span><br><span class="line">deqInt.at(0) = 99;//99</span><br><span class="line">deqInt[1] = 88;//88</span><br><span class="line"></span><br><span class="line">int iFront = deqInt.front();//99</span><br><span class="line">int iBack = deqInt.back();//9</span><br><span class="line">deqInt.front() = 77;//77</span><br><span class="line">deqInt.back() = 66;//66</span><br></pre></td></tr></table></figure><h4 id="deque与迭代器"><a class="markdownIt-Anchor" href="#deque与迭代器"></a> deque与迭代器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.begin();  //返回容器中第一个元素的迭代器。</span><br><span class="line">deque.end();  //返回容器中最后一个元素之后的迭代器。</span><br><span class="line">deque.rbegin();  //返回容器中倒数第一个元素的迭代器。</span><br><span class="line">deque.rend();   //返回容器中倒数最后一个元素之后的迭代器。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqInt;</span><br><span class="line">deqInt.push_back(1);</span><br><span class="line">deqInt.push_back(3);</span><br><span class="line">deqInt.push_back(5);</span><br><span class="line">deqInt.push_back(7);</span><br><span class="line">deqInt.push_back(9);</span><br><span class="line"></span><br><span class="line">for (deque&lt;int&gt;::iterator it=deqInt.begin(); it!=deqInt.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it;</span><br><span class="line">cout &lt;&lt; &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">// 1 3 5 7 9</span><br><span class="line"></span><br><span class="line">for (deque&lt;int&gt;::reverse_iterator rit=deqInt.rbegin(); rit!=deqInt.rend(); ++rit)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *rit;</span><br><span class="line">cout &lt;&lt; &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//9 7 5 3 1</span><br></pre></td></tr></table></figure><h4 id="deque对象的带参数构造"><a class="markdownIt-Anchor" href="#deque对象的带参数构造"></a> deque对象的带参数构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deque(beg,end);    //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</span><br><span class="line">deque(n,elem);   //构造函数将n个elem拷贝给本身。</span><br><span class="line">deque(const deque  &amp;deq);  //拷贝构造函数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqIntA;</span><br><span class="line">deqIntA.push_back(1);</span><br><span class="line">deqIntA.push_back(3);</span><br><span class="line">deqIntA.push_back(5);</span><br><span class="line">deqIntA.push_back(7);</span><br><span class="line">deqIntA.push_back(9);</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt; deqIntB(deqIntA.begin(),deqIntA.end());//1 3 5 7 9</span><br><span class="line">deque&lt;int&gt; deqIntC(5,8);//8 8 8 8 8</span><br><span class="line">deque&lt;int&gt; deqIntD(deqIntA);//1 3 5 7 9</span><br></pre></td></tr></table></figure><h4 id="deque的赋值"><a class="markdownIt-Anchor" href="#deque的赋值"></a> deque的赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.assign(beg,end);    //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</span><br><span class="line">deque.assign(n,elem);  //将n个elem拷贝赋值给本身。</span><br><span class="line">deque&amp; operator=(const deque &amp;deq);//重载等号操作符 </span><br><span class="line">deque.swap(deq);  // 将vec与本身的元素互换</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqIntA,deqIntB,deqIntC,deqIntD;</span><br><span class="line">deqIntA.push_back(1);</span><br><span class="line">deqIntA.push_back(3);</span><br><span class="line">deqIntA.push_back(5);</span><br><span class="line">deqIntA.push_back(7);</span><br><span class="line">deqIntA.push_back(9);</span><br><span class="line"></span><br><span class="line">deqIntB.assign(deqIntA.begin(),deqIntA.end());// 1 3 5 7 9</span><br><span class="line"></span><br><span class="line">deqIntC.assign(5,8);//8 8 8 8 8</span><br><span class="line"></span><br><span class="line">deqIntD = deqIntA;//1 3 5 7 9</span><br><span class="line"></span><br><span class="line">deqIntC.swap(deqIntD);//互换</span><br></pre></td></tr></table></figure><h4 id="deque的大小"><a class="markdownIt-Anchor" href="#deque的大小"></a> deque的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.size();   //返回容器中元素的个数</span><br><span class="line">deque.empty();   //判断容器是否为空</span><br><span class="line">deque.resize(num);   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">deque.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqIntA;</span><br><span class="line">deqIntA.push_back(1);</span><br><span class="line">deqIntA.push_back(3);</span><br><span class="line">deqIntA.push_back(5);</span><br><span class="line"></span><br><span class="line">int iSize = deqIntA.size();  //3</span><br><span class="line"></span><br><span class="line">if (!deqIntA.empty())</span><br><span class="line">&#123;</span><br><span class="line">deqIntA.resize(5);//1 3 5 0 0</span><br><span class="line">deqIntA.resize(7,1);//1 3 5 0 0 1 1</span><br><span class="line">deqIntA.resize(2);//1 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque的插入"><a class="markdownIt-Anchor" href="#deque的插入"></a> deque的插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deque.insert(pos,elem);   //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br><span class="line">deque.insert(pos,n,elem);   //在pos位置插入n个elem数据，无返回值。</span><br><span class="line">deque.insert(pos,beg,end);   //在pos位置插入[beg,end)区间的数据，无返回值。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqA;</span><br><span class="line">deque&lt;int&gt; deqB;</span><br><span class="line"></span><br><span class="line">deqA.push_back(1);</span><br><span class="line">deqA.push_back(3);</span><br><span class="line">deqA.push_back(5);</span><br><span class="line">deqA.push_back(7);</span><br><span class="line">deqA.push_back(9);</span><br><span class="line"></span><br><span class="line">deqB.push_back(2);</span><br><span class="line">deqB.push_back(4);</span><br><span class="line">deqB.push_back(6);</span><br><span class="line">deqB.push_back(8);</span><br><span class="line"></span><br><span class="line">deqA.insert(deqA.begin(), 11);//&#123;11, 1, 3, 5, 7, 9&#125;</span><br><span class="line">deqA.insert(deqA.begin()+1,2,33);//&#123;11,33,33,1,3,5,7,9&#125;</span><br><span class="line">deqA.insert(deqA.begin() , deqB.begin() , deqB.end() );//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span><br></pre></td></tr></table></figure><h4 id="deque的删除"><a class="markdownIt-Anchor" href="#deque的删除"></a> deque的删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deque.clear();//移除容器的所有数据</span><br><span class="line">deque.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">deque.erase(pos);    //删除pos位置的数据，返回下一个数据的位置。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">删除区间内的元素</span><br><span class="line">deqInt是用deque&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。</span><br><span class="line">deque&lt;int&gt;::iterator itBegin=deqInt.begin()+1;</span><br><span class="line">deque&lt;int&gt;::iterator itEnd=deqInt.begin()+3;</span><br><span class="line">deqInt.erase(itBegin,itEnd);</span><br><span class="line">//此时容器deqInt包含按顺序的1,6,9三个元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假设 deqInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素</span><br><span class="line">for(deque&lt;int&gt;::iterator it=deqInt.being(); it!=deqInt.end(); )    //小括号里不需写  ++it</span><br><span class="line">&#123;</span><br><span class="line">   if(*it == 3)</span><br><span class="line">   &#123;</span><br><span class="line">        it  =  deqInt.erase(it);       //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span><br><span class="line">         //此时，不执行  ++it；  </span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">       ++it;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除deqInt的所有元素</span><br><span class="line">deqInt.clear();//容器为空</span><br></pre></td></tr></table></figure><h3 id="基本操作代码"><a class="markdownIt-Anchor" href="#基本操作代码"></a> 基本操作代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//deque容器初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d2(<span class="number">10</span>,<span class="number">5</span>); <span class="comment">//带参数构造函数</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d3(d2.begin(),d2.end());</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d4(d3); <span class="comment">//拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deque赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="comment">//d.assign(10,5);  赋值</span></span><br><span class="line"><span class="comment">//d.assign(d1.begin(),d1.end());</span></span><br><span class="line"></span><br><span class="line">d = d1;  <span class="comment">//重载= 赋值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (d1.empty())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"不空!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//d1.resize(5);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; d1.size() &lt;&lt; endl;</span></span><br><span class="line">d1.resize(<span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deque插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"></span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">30</span>);</span><br><span class="line">d.push_front(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size();i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = d.begin(); it != d.end(); it++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">while (d.size() &gt; 0)&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; d.back() &lt;&lt; "被删除!" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">d.pop_back();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "大小:" &lt;&lt; d.size() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//头删除</span></span><br><span class="line"><span class="keyword">while</span> (!d.empty())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d.front() &lt;&lt; <span class="string">"被删除!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">d.pop_front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deque容器插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.insert(d.begin(),<span class="number">100</span>); <span class="comment">//头插法</span></span><br><span class="line">d.insert(d.end(), <span class="number">200</span>); <span class="comment">//尾差法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = d.begin(); it != d.end(); it++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//test03();</span></span><br><span class="line"><span class="comment">//test04();</span></span><br><span class="line">test06();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例代码"><a class="markdownIt-Anchor" href="#案例代码"></a> 案例代码</h3><p>sort排序第三个参数是判断规则函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool mycompare(int v1,int v2)&#123;</span><br><span class="line"></span><br><span class="line">return v1 &gt; v2; // 排序从大大小</span><br><span class="line">//return v1 &lt; v2; //从小到大</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Player(<span class="built_in">string</span> name, <span class="keyword">int</span> score) :name(name), score(score)&#123;&#125;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> score; <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建选手</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_Player</span><span class="params">(<span class="built_in">vector</span>&lt;Player&gt;&amp; v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> nameseed = <span class="string">"ABCDE"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"选手"</span>;</span><br><span class="line">name += nameseed[i];</span><br><span class="line"><span class="function">Player <span class="title">p</span><span class="params">(name,<span class="number">0</span>)</span></span>;  <span class="comment">//创建选手</span></span><br><span class="line">v.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycompare</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v1 &gt; v2)&#123;  <span class="comment">//从大到小</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Set_Player_Score</span><span class="params">(<span class="built_in">vector</span>&lt;Player&gt;&amp; plist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Player&gt;::iterator it = plist.begin(); it != plist.end();it++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dscore;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> score = <span class="number">50</span> + rand() % <span class="number">50</span>; <span class="comment">//打分</span></span><br><span class="line">dscore.push_back(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序 sort</span></span><br><span class="line">sort(dscore.begin(), dscore.end(), mycompare);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (deque&lt;int&gt;::iterator it = dscore.begin(); it != dscore.end();it ++)&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; *it &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">dscore.pop_front(); <span class="comment">//去除最高分</span></span><br><span class="line">dscore.pop_back(); <span class="comment">//去除最低分</span></span><br><span class="line"><span class="comment">//分数总结</span></span><br><span class="line"><span class="keyword">int</span> totalscore = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator dit = dscore.begin(); dit != dscore.end(); dit++)&#123;</span><br><span class="line">totalscore += *dit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> scoreavg = totalscore / dscore.size();</span><br><span class="line">(*it).score = scoreavg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示5名选手得分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show_Player_Score</span><span class="params">(<span class="built_in">vector</span>&lt;Player&gt;&amp; plist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Player&gt;::iterator it = plist.begin(); it != plist.end(); it++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名:"</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">" 分数:"</span> &lt;&lt; it-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Player&gt;  vPlayer;  <span class="comment">//存放我们的选手信息</span></span><br><span class="line">Create_Player(vPlayer); <span class="comment">//创建选手</span></span><br><span class="line">Set_Player_Score(vPlayer);</span><br><span class="line">Show_Player_Score(vPlayer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//评委打分案例(sort 算法排序)</span></span><br><span class="line"><span class="comment">//创建 5 个选手(姓名，得分)，10 个评委对 5 个选手进行打分</span></span><br><span class="line"><span class="comment">//得分规则：去除最高分，去除最低分，取出平均分</span></span><br><span class="line"><span class="comment">//按得分对 5 名选手进行排名</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;deque简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#deque简介&quot;&gt;&lt;/a&gt; Deque简介&lt;/h4&gt;
&lt;p&gt;deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>STL的vector容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/29/cpp0079-STL%E7%9A%84vector%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/29/cpp0079-STL的vector容器/</id>
    <published>2021-06-29T05:23:08.000Z</published>
    <updated>2021-06-29T06:11:06.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stl的vector容器"><a class="markdownIt-Anchor" href="#stl的vector容器"></a> STL的vector容器</h1><h4 id="1vector容器简介"><a class="markdownIt-Anchor" href="#1vector容器简介"></a> 1Vector容器简介</h4><p>vector是将元素置于一个动态数组中加以管理的容器。</p><p>vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。</p><p>vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时</p><h4 id="2vector对象的默认构造"><a class="markdownIt-Anchor" href="#2vector对象的默认构造"></a> 2vector对象的默认构造</h4><p>vector采用模板类实现，vector对象的默认构造形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; vecT; </span><br><span class="line">vector&lt;int&gt; vecInt;        //一个存放int的vector容器。</span><br><span class="line">vector&lt;float&gt; vecFloat;     //一个存放float的vector容器。</span><br><span class="line">vector&lt;string&gt; vecString;   //一个存放string的vector容器。</span><br><span class="line">...    //尖括号内还可以设置指针类型或自定义类型。</span><br><span class="line">Class CA&#123;&#125;;</span><br><span class="line">vector&lt;CA*&gt; vecpCA;  //用于存放CA对象的指针的vector容器。</span><br><span class="line">vector&lt;CA&gt; vecCA;     //用于存放CA对象的vector容器。由于容器元素的存放是按值复制的方式进行的，所以此时CA必须提供CA的拷贝构造函数，以保证CA对象间拷贝正常。</span><br></pre></td></tr></table></figure><h4 id="3vector对象的带参数构造"><a class="markdownIt-Anchor" href="#3vector对象的带参数构造"></a> 3vector对象的带参数构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector(beg,end);    //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</span><br><span class="line">vector(n,elem);   //构造函数将n个elem拷贝给本身。</span><br><span class="line">vector(const vector &amp;vec);  //拷贝构造函数</span><br><span class="line"></span><br><span class="line">int  iArray[] = &#123;0,1,2,3,4&#125;;</span><br><span class="line">vector&lt;int&gt;  vecIntA( iArray,  iArray+5 );</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vecIntB (  vecIntA.begin() , vecIntA.end()  );   //用构造函数初始化容器vecIntB </span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vecIntB (  vecIntA.begin() , vecIntA.begin()+3  );  </span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vecIntC(3,9); //此代码运行后，容器vecIntB就存放3个元素，每个元素的值是9。</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vecIntD(vecIntA);</span><br></pre></td></tr></table></figure><h4 id="4vector的赋值"><a class="markdownIt-Anchor" href="#4vector的赋值"></a> 4vector的赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">理论知识</span><br><span class="line">vector.assign(beg,end);    //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</span><br><span class="line">vector.assign(n,elem);  //将n个elem拷贝赋值给本身。</span><br><span class="line">vector&amp; operator=(const vector  &amp;vec);//重载等号操作符</span><br><span class="line">vector.swap(vec);  // 将vec与本身的元素互换。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;int&gt; vecIntA, vecIntB, vecIntC, vecIntD;</span><br><span class="line">int  iArray[] = &#123;0,1,2,3,4&#125;;</span><br><span class="line">vecIntA.assign(iArray,iArray+5);</span><br><span class="line"></span><br><span class="line">vecIntB.assign( vecIntA.begin(),  vecIntA.end() );    //用其它容器的迭代器作参数。</span><br><span class="line"></span><br><span class="line">vecIntC.assign(3,9);</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vecIntD;</span><br><span class="line">vecIntD = vecIntA;</span><br><span class="line"></span><br><span class="line">vecIntA.swap(vecIntD);</span><br></pre></td></tr></table></figure><h4 id="5vector的大小"><a class="markdownIt-Anchor" href="#5vector的大小"></a> 5vector的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">理论知识</span><br><span class="line">vector.size();   //返回容器中元素的个数</span><br><span class="line"></span><br><span class="line">vector.empty();   //判断容器是否为空</span><br><span class="line"></span><br><span class="line">vector.resize(num);   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line"></span><br><span class="line">vector.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line"></span><br><span class="line">vi.reserve(num);//设置容量</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如   vecInt是vector&lt;int&gt;  声明的容器，现已包含1,2,3元素。</span><br><span class="line">int iSize = vecInt.size();//iSize == 3;</span><br><span class="line">bool bEmpty = vecInt.empty();// bEmpty == false;</span><br><span class="line">执行vecInt.resize(5);  //此时里面包含1,2,3,0,0元素。</span><br><span class="line">再执行vecInt.resize(8,3);  //此时里面包含1,2,3,0,0,3,3,3元素。</span><br><span class="line">再执行vecInt.resize(2);  //此时里面包含1,2元素。</span><br></pre></td></tr></table></figure><h4 id="6vector末尾的添加移除操作"><a class="markdownIt-Anchor" href="#6vector末尾的添加移除操作"></a> 6vector末尾的添加移除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vecInt;</span><br><span class="line">vecInt.push_back(1);  //在容器尾部加入一个元素</span><br><span class="line">vecInt.push_back(3);  </span><br><span class="line">vecInt.push_back(5);  </span><br><span class="line">vecInt.push_back(7); </span><br><span class="line">vecInt.push_back(9); </span><br><span class="line">vecInt.pop_back();    //移除容器中最后一个元素</span><br><span class="line">vecInt.pop_back();</span><br><span class="line">//&#123;5 ,7 ,9&#125;</span><br></pre></td></tr></table></figure><h4 id="7vector的数据存取"><a class="markdownIt-Anchor" href="#7vector的数据存取"></a> 7vector的数据存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">理论知识</span><br><span class="line">vec.at(idx);  //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span><br><span class="line">vec[idx];  //返回索引idx所指的数据，越界时，运行直接报错</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vecInt;    //假设包含1 ,3 ,5 ,7 ,9</span><br><span class="line">vecInt.at(2) == vecInt[2];//5</span><br><span class="line">vecInt.at(2) = 8;  或  vecInt[2] = 8;</span><br><span class="line">vecInt 就包含 1, 3, 8, 7, 9值</span><br><span class="line"></span><br><span class="line">int iF = vector.front();//iF==1</span><br><span class="line">int iB = vector.back();//iB==9</span><br><span class="line">vector.front() = 11;//vecInt包含&#123;11,3,8,7,9&#125;</span><br><span class="line">vector.back() = 19;//vecInt包含&#123;11,3,8,7,19&#125;</span><br></pre></td></tr></table></figure><h4 id="8迭代器基本原理"><a class="markdownIt-Anchor" href="#8迭代器基本原理"></a> 8迭代器基本原理</h4><p>迭代器是一个“可遍历STL容器内全部或部分元素”的对象。</p><p>迭代器指出容器中的一个特定位置。</p><p>迭代器就如同一个指针。</p><p>迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围。</p><p>这里大概介绍一下迭代器的类别。<br><code>输入迭代器</code>：也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</p><p><code>输出迭代器</code>：也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</p><p><code>正向迭代器</code>：组合输入迭代器和输出迭代器的功能，还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。</p><p><code>双向迭代器</code>：组合正向迭代器的功能，还可以通过–操作符向后移动位置。<br>随机访问迭代器：组合双向迭代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</p><p>目前本系列教程所用到的容器，都支持双向迭代器或随机访问迭代器，下面将会详细介绍这两个类别的迭代器。</p><h4 id="9双向迭代器与随机访问迭代器"><a class="markdownIt-Anchor" href="#9双向迭代器与随机访问迭代器"></a> 9双向迭代器与随机访问迭代器</h4><p>双向迭代器支持的操作：</p><p>it++, ++it,  it–,  --it，*it， itA = itB，</p><p>itA == itB，itA != itB</p><p>​     其中list,set,multiset,map,multimap支持双向迭代器。</p><p>随机访问迭代器支持的操作：</p><p>在双向迭代器的操作基础上添加</p><p>it+=i， it-=i， it+i(或it=it+i)，it[i],</p><p>itA&lt;itB,  itA&lt;=itB, itA&gt;itB, itA&gt;=itB 的功能。</p><p>​     其中vector，deque支持随机访问迭代器。</p><h4 id="10vector与迭代器的配合使用"><a class="markdownIt-Anchor" href="#10vector与迭代器的配合使用"></a> 10vector与迭代器的配合使用</h4><p><img src="/images/javawz/1624945151928.png" alt="1624945151928"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;  vecInt; //假设包含1,3,5,7,9元素</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it;//声明容器vector&lt;int&gt;的迭代器。</span><br><span class="line"></span><br><span class="line">it = vecInt.begin();    // *it == 1</span><br><span class="line"></span><br><span class="line">++it;//或者it++;  *it == 3  ，前++的效率比后++的效率高，前++返回引用，后++返回值。</span><br><span class="line"></span><br><span class="line">it += 2;//*it == 7</span><br><span class="line"></span><br><span class="line">it = it+1;//*it == 9</span><br><span class="line"></span><br><span class="line">++it;// it == vecInt.end();  此时不能再执行*it,会出错!</span><br></pre></td></tr></table></figure><p>正向遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(vector&lt;int&gt;::iterator it=vecInt.begin(); it!=vecInt.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">      int iItem = *it; </span><br><span class="line">      cout &lt;&lt; iItem;    //或直接使用  cout &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(vector&lt;int&gt;::reverse_iterator rit=vecInt.rbegin(); rit!=vecInt.rend(); ++rit)    //注意，小括号内仍是++rit</span><br><span class="line">&#123;</span><br><span class="line">int iItem  = *rit;</span><br><span class="line">      cout &lt;&lt; iItem;//或直接使用cout &lt;&lt; *rit;</span><br><span class="line">&#125;</span><br><span class="line">此时将打印出9,7,5,3,1</span><br><span class="line">注意，这里迭代器的声明采用vector&lt;int&gt;::reverse_iterator，而非vector&lt;int&gt;::iterator。</span><br></pre></td></tr></table></figure><p>迭代器还有其它两种声明方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::const_iterator 与 vector&lt;int&gt;::const_reverse_iterator</span><br></pre></td></tr></table></figure><p>以上两种分别是vector&lt;int&gt;::iterator 与vector&lt;int&gt;::reverse_iterator 的只读形式，使用这两种迭代器时，不会修改到容器中的值。</p><p>备注：不过容器中的insert和erase方法仅接受这四种类型中的iterator，其它三种不支持。《Effective STL》建议我们尽量使用iterator取代const_iterator、reverse_iterator和const_reverse_iterator。</p><h4 id="11vector的插入"><a class="markdownIt-Anchor" href="#11vector的插入"></a> 11vector的插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector.insert(pos,elem);   //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br><span class="line">vector.insert(pos,n,elem);   //在pos位置插入n个elem数据，无返回值。</span><br><span class="line">vector.insert(pos,beg,end);   //在pos位置插入[beg,end)区间的数据，无返回值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">简单案例</span><br><span class="line">vector&lt;int&gt; vecA;</span><br><span class="line">vector&lt;int&gt; vecB;</span><br><span class="line"></span><br><span class="line">vecA.push_back(1);</span><br><span class="line">vecA.push_back(3);</span><br><span class="line">vecA.push_back(5);</span><br><span class="line">vecA.push_back(7);</span><br><span class="line">vecA.push_back(9);</span><br><span class="line"></span><br><span class="line">vecB.push_back(2);</span><br><span class="line">vecB.push_back(4);</span><br><span class="line">vecB.push_back(6);</span><br><span class="line">vecB.push_back(8);</span><br><span class="line"></span><br><span class="line">vecA.insert(vecA.begin(), 11);//&#123;11, 1, 3, 5, 7, 9&#125;</span><br><span class="line">vecA.insert(vecA.begin()+1,2,33);//&#123;11,33,33,1,3,5,7,9&#125;</span><br><span class="line">vecA.insert(vecA.begin() , vecB.begin() , vecB.end() );//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span><br></pre></td></tr></table></figure><h4 id="12vector的删除"><a class="markdownIt-Anchor" href="#12vector的删除"></a> 12vector的删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">理论知识</span><br><span class="line">vector.clear();//移除容器的所有数据</span><br><span class="line">vec.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">vec.erase(pos);    //删除pos位置的数据，返回下一个数据的位置。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">简单案例:</span><br><span class="line">删除区间内的元素</span><br><span class="line">vecInt是用vector&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。</span><br><span class="line">vector&lt;int&gt;::iterator itBegin=vecInt.begin()+1;</span><br><span class="line">vector&lt;int&gt;::iterator itEnd=vecInt.begin()+2;</span><br><span class="line">vecInt.erase(itBegin,itEnd);</span><br><span class="line">//此时容器vecInt包含按顺序的1,6,9三个元素。</span><br><span class="line"></span><br><span class="line">假设 vecInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素</span><br><span class="line">for(vector&lt;int&gt;::iterator it=vecInt.being(); it!=vecInt.end(); )    //小括号里不需写  ++it</span><br><span class="line">&#123;</span><br><span class="line">   if(*it == 3)</span><br><span class="line">   &#123;</span><br><span class="line">        it  =  vecInt.erase(it);       //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span><br><span class="line">         //此时，不执行  ++it；  </span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">       ++it;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除vecInt的所有元素</span><br><span class="line">vecInt.clear();//容器为空</span><br></pre></td></tr></table></figure><h3 id="巧用swap收缩vector空间容量"><a class="markdownIt-Anchor" href="#巧用swap收缩vector空间容量"></a> 巧用swap收缩vector空间容量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"></span><br><span class="line">vi.resize(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">vi.reserve(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vi.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cap: "</span> &lt;&lt; vi.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"================================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vi).swap(vi); <span class="comment">//先创建一个匿名对象,用vi的元素个数初始化,然后交换vi的ptr指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vi.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cap: "</span> &lt;&lt; vi.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reserve预留空间提高程序效率"><a class="markdownIt-Anchor" href="#reserve预留空间提高程序效率"></a> reserve预留空间提高程序效率</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">int</span> * pAddress = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">vi.reserve(<span class="number">100000</span>);<span class="comment">//如果提前知道了数据的个数,可以提前设置好容量的大小,避免频繁改动内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vi.push_back(i);</span><br><span class="line"><span class="keyword">if</span> (pAddress != &amp;vi[<span class="number">0</span>]) &#123;</span><br><span class="line">pAddress = &amp;vi[<span class="number">0</span>];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::left);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"vi的内存变动了"</span> &lt;&lt; num &lt;&lt; <span class="string">"次"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stl的vector容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stl的vector容器&quot;&gt;&lt;/a&gt; STL的vector容器&lt;/h1&gt;
&lt;h4 id=&quot;1vector容器简介&quot;&gt;&lt;a class=&quot;markdownIt-Anc
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>STL的string容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/29/cpp0078-STL%E7%9A%84string%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/29/cpp0078-STL的string容器/</id>
    <published>2021-06-29T04:18:51.000Z</published>
    <updated>2021-07-05T03:38:07.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stl的string容器"><a class="markdownIt-Anchor" href="#stl的string容器"></a> STL的string容器</h1><h3 id="1string概念"><a class="markdownIt-Anchor" href="#1string概念"></a> 1String概念</h3><p>string是STL的字符串类型，通常用来表示字符串。而在使用string之前，字符串通常是用char<em>表示的。string与char</em>都可以用来表示字符串，那么二者有什么区别呢。</p><p>string和char*的比较</p><p>string是一个类, char*是一个指向字符的指针。</p><p>string封装了char*，管理这个字符串，是一个char*型的容器。</p><p>string不用考虑内存释放和越界。</p><p>string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</p><p>string提供了一系列的字符串操作函数（这个等下会详讲）</p><p>查找find，拷贝copy，删除erase，替换replace，插入insert</p><h3 id="2string的构造函数"><a class="markdownIt-Anchor" href="#2string的构造函数"></a> 2string的构造函数</h3><p>默认构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string();    //构造一个空的字符串string s1。</span><br></pre></td></tr></table></figure><p>拷贝构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(const string &amp;str); //构造一个与str一样的string。如string s1(s2)。</span><br></pre></td></tr></table></figure><p>带参数的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string(const char *s);  //用字符串s初始化</span><br><span class="line"></span><br><span class="line">string(int n,char c);  //用n个字符c初始化</span><br></pre></td></tr></table></figure><h4 id="3string的存取字符操作"><a class="markdownIt-Anchor" href="#3string的存取字符操作"></a> 3string的存取字符操作</h4><p>string类的字符操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const char &amp;operator[] (int n) const;</span><br><span class="line"></span><br><span class="line">const char &amp;at(int n) const;</span><br><span class="line"></span><br><span class="line">char &amp;operator[] (int n);</span><br><span class="line"></span><br><span class="line">char &amp;at(int n);</span><br></pre></td></tr></table></figure><p>operator[]和at()均返回当前字符串中第n个字符，但二者是有区别的。</p><p>​    主要区别在于at()在越界时会抛出异常，[]在刚好越界时会返回(char)0，再继续越界时，编译器直接出错。如果你的程序希望可以通过try,catch捕获异常，建议采用at()。</p><h3 id="4从string取得const-char的操作"><a class="markdownIt-Anchor" href="#4从string取得const-char的操作"></a> 4从string取得const char*的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *c_str() const;   //返回一个以&apos;\0&apos;结尾的字符串的首地址</span><br></pre></td></tr></table></figure><h3 id="5把string拷贝到char指向的内存空间的操作"><a class="markdownIt-Anchor" href="#5把string拷贝到char指向的内存空间的操作"></a> 5把string拷贝到char*指向的内存空间的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int copy(char *s, int n, int pos=0) const;</span><br></pre></td></tr></table></figure><p>把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目。注意要保证s所指向的空间足够大以容纳当前字符串，不然会越界。</p><h3 id="6string的长度"><a class="markdownIt-Anchor" href="#6string的长度"></a> 6string的长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int length() const;   //返回当前字符串的长度。长度不包括字符串结尾的&apos;\0&apos;。</span><br><span class="line">bool empty() const;     //当前字符串是否为空</span><br></pre></td></tr></table></figure><h3 id="7string的赋值"><a class="markdownIt-Anchor" href="#7string的赋值"></a> 7string的赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string &amp;operator=(const string &amp;s);//把字符串s赋给当前的字符串</span><br><span class="line"></span><br><span class="line">string &amp;assign(const char *s); //把字符串s赋给当前的字符串</span><br><span class="line"></span><br><span class="line">string &amp;assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串</span><br><span class="line"></span><br><span class="line">string &amp;assign(const string &amp;s);  //把字符串s赋给当前字符串</span><br><span class="line"></span><br><span class="line">string &amp;assign(int n,char c);  //用n个字符c赋给当前字符串</span><br><span class="line"></span><br><span class="line">string &amp;assign(const string &amp;s,int start, int n);  //把字符串s中从start开始的n个字符赋给当前字符串</span><br></pre></td></tr></table></figure><h3 id="8string字符串连接"><a class="markdownIt-Anchor" href="#8string字符串连接"></a> 8string字符串连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string &amp;operator+=(const string &amp;s);  //把字符串s连接到当前字符串结尾</span><br><span class="line"></span><br><span class="line">string &amp;operator+=(const char *s);//把字符串s连接到当前字符串结尾</span><br><span class="line"></span><br><span class="line">string &amp;append(const char *s);    //把字符串s连接到当前字符串结尾</span><br><span class="line"></span><br><span class="line">string &amp;append(const char *s,int n);  //把字符串s的前n个字符连接到当前字符串结尾</span><br><span class="line"></span><br><span class="line">string &amp;append(const string &amp;s);   //同operator+=()</span><br><span class="line"></span><br><span class="line">string &amp;append(const string &amp;s,int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span><br><span class="line"></span><br><span class="line">string &amp;append(int n, char c);   //在当前字符串结尾添加n个字符c</span><br></pre></td></tr></table></figure><h4 id="9string的比较"><a class="markdownIt-Anchor" href="#9string的比较"></a> 9string的比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int compare(const string &amp;s) const;  //与字符串s比较</span><br><span class="line">int compare(const char *s) const;   //与字符串s比较</span><br></pre></td></tr></table></figure><p>compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的A比小写的a小。</p><h3 id="10string的子串"><a class="markdownIt-Anchor" href="#10string的子串"></a> 10string的子串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string substr(int pos=0, int n=npos) const;    //返回由pos开始的n个字符组成的子字符串</span><br></pre></td></tr></table></figure><h3 id="11string的查找-和-替换"><a class="markdownIt-Anchor" href="#11string的查找-和-替换"></a> 11string的查找 和 替换</h3><h4 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int find(char c,int pos=0) const;  //从pos开始查找字符c在当前字符串的位置 </span><br><span class="line"></span><br><span class="line">int find(const char *s, int pos=0) const;  //从pos开始查找字符串s在当前字符串的位置</span><br><span class="line"></span><br><span class="line">int find(const string &amp;s, int pos=0) const;  //从pos开始查找字符串s在当前字符串中的位置</span><br><span class="line"></span><br><span class="line">find函数如果查找不到，就返回-1</span><br><span class="line"></span><br><span class="line">int rfind(char c, int pos=npos) const;   //从pos开始从后向前查找字符c在当前字符串中的位置 </span><br><span class="line"></span><br><span class="line">int rfind(const char *s, int pos=npos) const;</span><br><span class="line"></span><br><span class="line">int rfind(const string &amp;s, int pos=npos) const;</span><br><span class="line">//rfind是反向查找的意思，如果查找不到， 返回-1</span><br></pre></td></tr></table></figure><h4 id="替换"><a class="markdownIt-Anchor" href="#替换"></a> 替换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string &amp;replace(int pos, int n, const char *s);//删除从pos开始的n个字符，然后在pos处插入串s</span><br><span class="line"></span><br><span class="line">string &amp;replace(int pos, int n, const string &amp;s);  //删除从pos开始的n个字符，然后在pos处插入串s</span><br><span class="line"></span><br><span class="line">void swap(string &amp;s2);    //交换当前字符串与s2的值</span><br></pre></td></tr></table></figure><h3 id="12string的区间删除和插入"><a class="markdownIt-Anchor" href="#12string的区间删除和插入"></a> 12String的区间删除和插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string &amp;insert(int pos, const char *s);</span><br><span class="line">string &amp;insert(int pos, const string &amp;s);</span><br><span class="line">//前两个函数在pos位置插入字符串s</span><br><span class="line">string &amp;insert(int pos, int n, char c);  //在pos位置 插入n个字符c</span><br><span class="line"></span><br><span class="line">string &amp;erase(int pos=0, int n=npos);  //删除pos开始的n个字符，返回修改后的字符串</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//char* 和 string转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string类型转换为char*字符串</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = s.c_str();</span><br><span class="line"></span><br><span class="line"><span class="comment">//char*类型字符串转换为string类型字符串</span></span><br><span class="line"><span class="keyword">char</span>* str2 = <span class="string">"acbd"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(str2)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s; <span class="comment">//默认构造</span></span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"acbd"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string容器字符串赋值和存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//string容器赋值</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s = <span class="string">"abcd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s2;</span><br><span class="line">s2.assign(<span class="string">"pppp"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//string容器存取</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s3.size();i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s3.size();i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//【】访问方式访问越界时候，不会抛异常，直接挂掉</span></span><br><span class="line"><span class="comment">//at会抛出异常</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s3[100] &lt;&lt; endl;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3.at(<span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (...)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"访问越界!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string容器拼接操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"aaa"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"bbb"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string s3 = s1 + s2;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; s3 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s1 += s2;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; s1 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法方式 append</span></span><br><span class="line">s1.append(s2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string查找和替换 比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">" acbdefg"</span>;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">string</span> target = <span class="string">"bd"</span>;</span><br><span class="line"><span class="keyword">int</span> pos = s.find(target);</span><br><span class="line"><span class="keyword">char</span>* target2 = <span class="string">"ef"</span>;</span><br><span class="line"><span class="keyword">int</span> pos2 = s.find(target2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pos:"</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pos2:"</span> &lt;&lt; pos2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos3 = s.rfind(target);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pos3:"</span> &lt;&lt; pos3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串替换</span></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"acbd"</span>;</span><br><span class="line">s.replace(<span class="number">0</span>, <span class="number">2</span>, s1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string 比较 子串 插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较</span></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"abd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = s1.compare(s2);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s1 &gt; s2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s1 &lt; s2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s1 == s2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="built_in">string</span> s4 = s3.substr(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s4"</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">"abcd"</span>;</span><br><span class="line">s5.insert(<span class="number">0</span>, <span class="string">"pppp"</span>);</span><br><span class="line"><span class="built_in">string</span> s6 = <span class="string">"qqqq"</span>;</span><br><span class="line">s5.insert(s5.size(), s6);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">s5.erase(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="comment">//test03();</span></span><br><span class="line"><span class="comment">//test04();</span></span><br><span class="line"><span class="comment">//test05();</span></span><br><span class="line">test06();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stl的string容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stl的string容器&quot;&gt;&lt;/a&gt; STL的string容器&lt;/h1&gt;
&lt;h3 id=&quot;1string概念&quot;&gt;&lt;a class=&quot;markdownIt-Ancho
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>STL基础理论</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/29/cpp0077-STL%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/29/cpp0077-STL基础理论/</id>
    <published>2021-06-29T03:39:14.000Z</published>
    <updated>2021-06-29T03:56:38.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stl实用技术专题"><a class="markdownIt-Anchor" href="#stl实用技术专题"></a> STL实用技术专题</h1><h2 id="stl标准模板库理论基础"><a class="markdownIt-Anchor" href="#stl标准模板库理论基础"></a> STL(标准模板库)理论基础</h2><h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3><p>STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现在C<ins>中，但在被引入C</ins>之前该技术就已经存在了很长的一段时间。</p><p>STL的从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文 件：&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt; 和&lt;utility&gt;。</p><p>​                                  <img src="/images/javawz/1624938401945.png" alt="1624938401945"></p><p>STL详细的说六大组件</p><p>–  容器（Container）</p><p>–  算法（Algorithm）</p><p>–  迭代器（Iterator）</p><p>–  仿函数（Function object）</p><p>–  适配器（Adaptor）</p><p>–  空间配制器（allocator）</p><h3 id="使用stl的好处"><a class="markdownIt-Anchor" href="#使用stl的好处"></a> 使用STL的好处</h3><p>1）STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p><p>2）STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。</p><p>例如，在STL的vector容器中，可以放入元素、基础数据类型变量、元素的地址；</p><p>STL的sort()函数可以用来操作vector,list等容器。</p><p>1）  程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p><p>2） STL具有高可重用性，高性能，高移植性，跨平台的优点。</p><p>高可重用性：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p><p>高性能：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种)</p><p>高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。</p><p>​         跨平台：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。</p><p>3） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p><p>4） 了解到STL的这些好处，我们知道STL无疑是最值得C<ins>程序员骄傲的一部分。每一个C＋＋程序员都应该好好学习STL。只有能够熟练使用STL的程序员，才是好的C</ins>程序员。</p><p>5）  总之：招聘工作中，经常遇到C<ins>程序员对STL不是非常了解。大多是有一个大致的映像，而对于在什么情况下应该使用哪个容器和算法都感到比较茫然。STL是C</ins>程序员的一项不可或缺的基本技能，掌握它对提升C++编程大有裨益。</p><h3 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h3><p>在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。</p><p>经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在 细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用已有的实现构造自己的特定类型下的数据结构，通过设置一些模板，STL容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。</p><p>容器部分主要由头文 件&lt;vector&gt;,&lt;list&gt;,&lt;deque&gt;,&lt;set&gt;,&lt;map&gt;,&lt;stack&gt; 和&lt;queue&gt;组成。对于常用的一些容器和容器适配器（可以看作由其它容器实现的容器），可以通过下表总结一下它们和相应头文件的对应关系。</p><h4 id="容器的概念"><a class="markdownIt-Anchor" href="#容器的概念"></a> 容器的概念</h4><p>用来管理一组元素</p><p><img src="/images/javawz/1624938571486.png" alt="1624938571486"></p><h3 id="容器的分类"><a class="markdownIt-Anchor" href="#容器的分类"></a> 容器的分类</h3><p>序列式容器（Sequence containers）</p><p>每个元素都有固定位置－－取决于插入时机和地点，和元素值无关。</p><p>vector、deque、list</p><p>关联式容器（Associated containers）</p><p>元素位置取决于特定的排序准则，和插入顺序无关</p><p>set、multiset、map、multimap</p><p><img src="/images/javawz/1624938647706.png" alt="1624938647706"></p><h3 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h3><p>迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化， 这种简化在STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通 过迭代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。</p><p>迭代器部分主要由头文件&lt;utility&gt;,&lt;iterator&gt;和&lt;memory&gt;组 成。&lt;utility&gt;是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，&lt;iterator&gt;中提供了迭代器 使用的许多方法，而对于&lt;memory&gt;的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生 的临时对象提供机制,&lt;memory&gt;中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器。</p><h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3><p>函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使 用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提 供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种 类中的其他类型。</p><p>STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以 你所指定的规则对序列进行稳定性排序等等。这样一来，只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要 的功能并大大地提升效率。</p><p>算法部分主要由头文件&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;组 成。&lt;algorithm&gt;是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上 都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。&lt;numeric&gt;体积很 小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。&lt;functional&gt;中则定义了一些模板类， 用以声明函数对象。</p><h3 id="c标准库"><a class="markdownIt-Anchor" href="#c标准库"></a> C++标准库</h3><p>C<ins>强大的功能来源于其丰富的类库及库函数资源。C</ins>标准库的内容总共在50个标准头文件中定义。在C++开发中，要尽可能地利用标准库完 成。这样做的直接好处包括：（1）成本：已经作为标准提供，何苦再花费时间、人力重新开发呢；（2）质量：标准库的都是经过严格测试的，正确性有保证； （3）效率：关于人的效率已经体现在成本中了，关于代码的执行效率要相信实现标准库的大牛们的水平；（4）良好的编程风格：采用行业中普遍的做法进行开发。</p><p>在C++程序设计课程中，尤其是作为第一门程序设计课程，我们注重了语法、语言的机制等方面的内容。程序设计能力的培养有个过程，跨过基本的原 理性知识直接进入到工程</p><p>中的普遍做法，由于跨度决定了其难度。再者，在掌握了基本原理的基础上，在认识标准库的问题上完全可以凭借实践，逐步地掌握。标准 库的学习不需要认认真真地读书，需要的是在了解概貌的情况下，在实践中深入。</p><p>这个任务就是要知道C++程序设计课程中不讲的，但对程序设计又很重要的这部分内容。至少我们要能先回答出“有什么”的问题。</p><p>C++标准库的内容分为10类，分别是（建议在阅读中，将你已经用过或听说过的头文件划出来）：</p><p>C1. 标准库中与语言支持功能相关的头文件</p><p><img src="/images/javawz/1624938841622.png" alt="1624938841622"></p><p>C2. 支持流输入/输出的头文件</p><p><img src="/images/javawz/1624938863804.png" alt="1624938863804"></p><p><img src="/images/javawz/1624938872087.png" alt="1624938872087"></p><p><img src="/images/javawz/1624938893530.png" alt="1624938893530"></p><p><img src="/images/javawz/1624938910448.png" alt="1624938910448"></p><p><img src="/images/javawz/1624938922112.png" alt="1624938922112"></p><p>C<ins>标准库的所有头文件都没有扩展名。C</ins>标准库以&lt;cname&gt;形式的标准头文件提供。在 &lt;cname&gt;形式标准的头文件中，与宏相关的名称在全局作用域中定义，其他名称在std命名空间中声明。在C++中还可以使用name.h 形式的标准C库头文件名</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stl实用技术专题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stl实用技术专题&quot;&gt;&lt;/a&gt; STL实用技术专题&lt;/h1&gt;
&lt;h2 id=&quot;stl标准模板库理论基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hre
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>文件操作</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/29/cpp0076-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/29/cpp0076-文件操作/</id>
    <published>2021-06-29T01:27:59.000Z</published>
    <updated>2021-06-29T02:56:37.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文本文件操作"><a class="markdownIt-Anchor" href="#文本文件操作"></a> 文本文件操作</h1><p><img src="/images/javawz/1624931175526.png" alt="1624931175526"></p><p>ifstream类，它是从istream类派生的，用来支持从磁盘文件的输入。<br>ofstream类，它是从ostream类派生的，用来支持向磁盘文件的输出。<br>fstream类，它是从iostream类派生的，用来支持对磁盘文件的输入输出。</p><h3 id="文件的打开与关闭"><a class="markdownIt-Anchor" href="#文件的打开与关闭"></a> 文件的打开与关闭</h3><h4 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h4><p>所谓打开(open)文件是一种形象的说法，如同打开房门就可以进入房间活<br>动一样。<br>打开文件是指在文件读写之前做必要的准备工作，包括：</p><p>1）为文件流对象和指定的磁盘文件建立关联，以便使文件流流向指定的磁盘<br>文件。</p><p>2）指定文件的工作方式，如，该文件是作为输入文件还是输出文件，是ASCII<br>文件还是二进制文件等。<br>以上工作可以通过两种不同的方法实现。</p><ol><li></li></ol><p>调用文件流的成员函数open。如<br>ofstream outfile; //定义ofstream类(输出文件流类)对象outfile<br>outfile.open(“f1.dat”,ios::out); <a href="//xn--f1-1v2cr9attq17hwkl.xn--dat-wu9dv7iw01ampkoo5book">//使文件流与f1.dat文件建立关联</a><br>第2行是调用输出文件流的成员函数open打开磁盘文件f1.dat，并指定它为输出<br>文件，<br>文件流对象ouFile将向磁盘文件f1.dat输出数据。ios::out是I/O模式的一<br>种，表示以输出方式打开一个文件。或者简单地说，此时f1.dat是一个输出文<br>件，接收从内存输出的数据。<br>调用成员函数open的一般形式为：<br>文件流对象.open(磁盘文件名, 输入输出方式);<br>磁盘文件名可以包括路径，如&quot;c:\new\f1.dat&quot;，如缺省路径，则默认为当<br>前目录下的文件。</p><ol start="2"><li></li></ol><p>在定义文件流对象时指定参数<br>在声明文件流类时定义了带参数的构造函数，其中包含了打开磁盘文件<br>的功能。因此，可以在定义文件流对象时指定参数，调用文件流类的构造函数</p><p><img src="/images/javawz/1624930197915.png" alt="1624930197915"></p><p>几点说明：</p><ol><li><p>新版本的I/O类库中不提供ios::nocreate和ios::noreplace。</p></li><li><p>每一个打开的文件都有一个文件指针，该指针的初始位置由I/O方式指定，<br>每次读写都从文件指针的当前位置开始。每读入一个字节，指针就后移一个字<br>节。当文 件指针移到最后，就会遇到文件结束EOF（文件结束符也占一个字节，<br>其值为-1)，此时流对象的成员函数eof的值为非0值(一般设为1)，表示文件结<br>束 了。</p></li><li><p>可以用“位或”运算符“|”对输入输出方式进行组合，如表13.6中最后3行<br>所示那样。还可以举出下面一些例子：<br>ios::in | ios:: noreplace //打开一个输入文件，若文件不存在则返回打开失<br>败的信息<br>ios::app | ios::nocreate //打开一个输出文件，在文件尾接着写数据，若文件不存在，则返回打开失败的信息<br>ios::out l ios::noreplace //打开一个新文件作为输出文件，如果文件已存<br>在则返回打开失败的信息<br>ios::in l ios::out I ios::binary //打开一个二进制文件，可读可写<br>但不能组合互相排斥的方式，如 ios::nocreate l ios::noreplace。</p></li><li><p>如果打开操作失败，open函数的返回值为0(假)，如果是用调用构造函数的<br>方式打开文件的，则流对象的值为0。可以据此测试打开是否成功。如<br>if(outfile.open(“f1.bat”, ios::app) ==0)<br>cout &lt;&lt;“open error”;<br>或<br>if( !outfile.open(“f1.bat”, ios::app) )<br>cout &lt;&lt;“open error”;</p></li></ol><h4 id="关闭文件"><a class="markdownIt-Anchor" href="#关闭文件"></a> 关闭文件</h4><p>在对已打开的磁盘文件的读写操作完成后，应关闭该文件。关闭文件用<br>成员函数close。如<br>ouFile.close();<br>//将输出文件流所关联的磁盘文件关闭<br>所谓关闭，实际上是解除该磁盘文件与文件流的关联，原来设置的工作方式也<br>失效，这样，就不能再通过文件流对该文件进行输入或输出。此时可以将文件<br>流与其他磁盘文件建立关联，通过文件流对新的文件进行输入或输出。如<br>ouFile.open(“f2.dat”,ios::app|ios::nocreate);<br>此时文件流ouFile与f2.dat建立关联，并指定了f2.dat的工作方式。</p><h3 id="c对ascii文件的读写操作"><a class="markdownIt-Anchor" href="#c对ascii文件的读写操作"></a> C++对ASCII文件的读写操作</h3><p>如果文件的每一个字节中均以ASCII代码形式存放数据,即一个字节存放一<br>个字符,这个文件就是ASCII文件(或称字符文件)。程序可以从ASCII文件中读入若<br>干个字符,也可以向它输出一些字符。</p><ol><li></li></ol><p>用流插入运算符<code>&lt;&lt;</code>和流提取运算符<code>&gt;&gt;</code>输入输出标准类型的数据。<code>&lt;&lt;</code><br>和<code>&gt;&gt;</code>都已在iostream中被重载为能用于ostream和istream类对象的标准类型的<br>输入输出。由于ifstream和<br>ofstream分别是ostream和istream类的派生类；因此<br>它们从ostream和istream类继承了公用的重载函数，所以在对磁盘文件的操作<br>中，可以通过文件流对象和流插入运算符<code>&lt;&lt;</code>及<br>流提取运算符<code>&gt;&gt;</code>实现对磁盘<br>文件的读写，如同用cin、cout和&lt;&lt;、&gt;&gt;对标准设备进行读写一样。</p><ol start="2"><li></li></ol><p>用文件流的put、get、geiline等成员函数进行字符的输入输出，：用C++<br>流成员函数put输出单个字符、C++<br>get()函数读入一个字符和C++<br>getline()函数读<br>入一行字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> sourceFileName[] = <span class="string">"source.txt"</span>;</span><br><span class="line"><span class="keyword">char</span> destFileName[] = <span class="string">"dest.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="comment">//用构造函数打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ifstream fin(sourceFileName,ios::in); //打开输入文件</span></span><br><span class="line"><span class="comment">//ofstream fout(destFileName,ios::out); //打开输出文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">ifstream fin;</span><br><span class="line">ofstream fout;</span><br><span class="line"></span><br><span class="line">fin.open(sourceFileName,ios::in);</span><br><span class="line"><span class="comment">//以写追加模式打开文件</span></span><br><span class="line">fout.open(destFileName,ios::out | ios::app);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断文件是否打开成功</span></span><br><span class="line"><span class="comment">//这里</span></span><br><span class="line"><span class="keyword">if</span> (!fin || !fout)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> (fin.get(ch))</span><br><span class="line">&#123;</span><br><span class="line">fout &lt;&lt; ch;</span><br><span class="line"><span class="comment">//fout.put(ch); //输出一个字符到文件里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">fin.close();</span><br><span class="line">fout.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c对二进制文件的读写操作"><a class="markdownIt-Anchor" href="#c对二进制文件的读写操作"></a> C++对二进制文件的读写操作</h1><h3 id="文本模式"><a class="markdownIt-Anchor" href="#文本模式"></a> 文本模式</h3><p>在linux系统平台下是以<code>\n</code>作为换行符的</p><p>在windows系统平台下是以<code>\r\n</code>作为换行符</p><p>文本模式和二进制模式在Linux下是不区分的,但在windows模式下是区分的,因为windows模式下的换行符<code>\r\n</code>要进行转换</p><h3 id="二进制模式"><a class="markdownIt-Anchor" href="#二进制模式"></a> 二进制模式</h3><p>不进行编码转换,将内存中的内容原封不动的输出到文件或将内容原封不动的输入到内存中</p><p>1.用ios::binary模式打开文件</p><p>2.以二进制方式写到文件</p><p>​对象名.write(地址,要写入的字节大小)</p><p>3.以二进制方式读到内存</p><p>​对象名.read(地址,要读入的字节大小)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person() &#123;</span><br><span class="line">m_Age = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(m_Name,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">const</span> <span class="keyword">char</span> * name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">m_Age = age;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(m_Name, name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m_Name &lt;&lt; <span class="string">"  "</span> &lt;&lt; m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line"><span class="keyword">char</span> m_Name[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"小花"</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> fileName[] = <span class="string">"binary.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以二进制方式打开文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(fileName, ios::out | ios::binary)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(fileName, ios::in | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fin || !fout) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"文件打开失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写二进制文件,首位参数需要转换类型为char *</span></span><br><span class="line">fout.write((<span class="keyword">char</span> *) &amp;p1,<span class="keyword">sizeof</span>(p1));</span><br><span class="line">fout.write((<span class="keyword">char</span> *) &amp;p2,<span class="keyword">sizeof</span>(p2));</span><br><span class="line">fout.close();</span><br><span class="line"></span><br><span class="line">Person tP1, tP2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读二进制文件,首位参数需要转换类型为char *</span></span><br><span class="line">fin.read((<span class="keyword">char</span> *)&amp;tP1,<span class="keyword">sizeof</span>(tP1));</span><br><span class="line">fin.read((<span class="keyword">char</span> *)&amp;tP2,<span class="keyword">sizeof</span>(tP2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示输出</span></span><br><span class="line">tP1.show();</span><br><span class="line">tP2.show();</span><br><span class="line"></span><br><span class="line">fin.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文本文件操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#文本文件操作&quot;&gt;&lt;/a&gt; 文本文件操作&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1624931175526.png&quot; alt=&quot;16249311755
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>标准输入输出</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/28/cpp0075-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/28/cpp0075-标准输入输出/</id>
    <published>2021-06-28T04:14:14.000Z</published>
    <updated>2021-06-29T03:45:06.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准输入输出"><a class="markdownIt-Anchor" href="#标准输入输出"></a> 标准输入输出</h1><p><img src="/images/javawz/1624853954352.png" alt="1624853954352"></p><p><img src="/images/javawz/1624853711081.png" alt="1624853711081"></p><h3 id="缓冲区"><a class="markdownIt-Anchor" href="#缓冲区"></a> 缓冲区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有缓冲区的输入输出对象</span><br><span class="line">cout//标准输出</span><br><span class="line">cin//标准输入</span><br><span class="line">clog//打印日志</span><br><span class="line"></span><br><span class="line">没有缓冲区的输出对象</span><br><span class="line">cerr  //标准出错</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/1624853775895.png" alt="1624853775895"></p><h3 id="标准输入流-常用的cin成员方法"><a class="markdownIt-Anchor" href="#标准输入流-常用的cin成员方法"></a> 标准输入流 常用的cin成员方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ch 代表字符变量</span><br><span class="line">buff 代表字符数组</span><br><span class="line">size代表字符数组长度</span><br><span class="line"></span><br><span class="line">cin.get() //一次只能读取一个字符</span><br><span class="line">cin.get(ch) //读一个字符</span><br><span class="line">cin.get(buff,size) //可以读字符串</span><br><span class="line">cin.getline(buff,size)//输入一行</span><br><span class="line"></span><br><span class="line">cin.ignore() //从缓冲区取走一个字符并丢弃</span><br><span class="line">cin.ignore(2) //从缓冲区取走2个字符并丢弃</span><br><span class="line">cin.ignore(2,&apos;\n&apos;) //从缓冲区取走2个字符并丢弃,遇到\n提前结束</span><br><span class="line"></span><br><span class="line">cin.peek();//偷窥缓冲区内容,返回缓冲区第一个字符,不取走字符</span><br><span class="line"></span><br><span class="line">cin.putback(ch) //把ch放回缓冲区</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cin的operator&gt;&gt;操作符 //根据回车来刷新缓冲区  根据空格来隔离每个变量的内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> myInt;</span><br><span class="line"><span class="keyword">long</span> myLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; myInt;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; myLong;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; buf;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"myInt: "</span> &lt;&lt; myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"myLong: "</span> &lt;&lt; myLong &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"buf: "</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.get()方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.get()如果读到的不是EOF标识符，那么会永远的阻塞等待</span></span><br><span class="line"><span class="comment">//从键盘来讲ctrl+z 代表EOF标识符</span></span><br><span class="line"><span class="keyword">while</span> ((ch = <span class="built_in">cin</span>.get() )!= EOF) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"从输入缓冲区去读取数据，如果缓冲区中没有数据，就阻塞"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//cin.get(a); //从输入缓冲区去读取数据，如果有就给a</span></span><br><span class="line"><span class="comment">//cin.get(b);</span></span><br><span class="line"><span class="comment">//cin.get(c);</span></span><br><span class="line"><span class="comment">//cin.get(a).get(b).get(c);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; "a  =" &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "b  =" &lt;&lt; b&lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "c  =" &lt;&lt; c&lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.get(buf, <span class="number">10</span>, <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.getline()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入一个字符串 aa bb cc dd"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(buf, <span class="number">128</span>); <span class="comment">//从输入缓冲区中读数据到buf中，最多读128 ，知道遇到\n为止</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"buf:"</span> &lt;&lt;buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.ignore()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf1[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">char</span> buf2[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入一个字符串 aa  bb cc dd"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; buf1; <span class="comment">//aa</span></span><br><span class="line"><span class="built_in">cin</span>.ignore(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cin</span>.getline(buf2, <span class="number">128</span>);<span class="comment">// bb cc dd</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"buf1:"</span> &lt;&lt; buf1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"buf2:"</span> &lt;&lt; buf2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.putback()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入一个数字或者字符串"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ch = <span class="built_in">cin</span>.get(); <span class="comment">//从输入缓冲区去读一个字符</span></span><br><span class="line"><span class="keyword">if</span> ((ch &gt;= <span class="string">'0'</span>) &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的是一个数字"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="comment">//此时数字第一个字符已经读出来了。 需要将ch放回到输入缓冲区</span></span><br><span class="line"><span class="built_in">cin</span>.putback(ch); <span class="comment">//将ch仍会缓冲区， 位置就缓冲区的头部。</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"num ="</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的是一个字符串"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//cin.putback(ch);</span></span><br><span class="line"><span class="built_in">cin</span>.getline(buf, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"buf:"</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//test1();</span></span><br><span class="line"><span class="comment">//test2();</span></span><br><span class="line"><span class="comment">//test3();</span></span><br><span class="line"><span class="comment">//test4();</span></span><br><span class="line"><span class="comment">//test5();</span></span><br><span class="line">test6();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准输出流-cout常用的方法"><a class="markdownIt-Anchor" href="#标准输出流-cout常用的方法"></a> 标准输出流 cout常用的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cout.flush() //刷新缓冲区</span><br><span class="line"></span><br><span class="line">cout.put(ch)//输出一个字符</span><br><span class="line"></span><br><span class="line">cout.write(str,strLen) //输出一个字符串</span><br><span class="line"></span><br><span class="line">cout.width(10) //设置10个位宽</span><br><span class="line">cout.fill(&apos;*&apos;) //位宽空余的地方用*代替</span><br><span class="line"></span><br><span class="line">cout.setf(ios::oct) //设置八进制输出</span><br><span class="line">cout.unsetf(ios::dex) //卸载当前默认的十进制输出方式</span><br><span class="line">cout.setf(ios::showbase);//把八进制的0和十六进制的0x显示出来</span><br><span class="line">cout.setf(ios::left);//设置左对齐</span><br></pre></td></tr></table></figure><h3 id="cout常用控制符"><a class="markdownIt-Anchor" href="#cout常用控制符"></a> cout常用控制符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flush</span><br><span class="line">endl</span><br><span class="line">oct</span><br><span class="line">dec</span><br><span class="line">hex</span><br><span class="line">setbase</span><br><span class="line">setw</span><br><span class="line">setfill</span><br><span class="line">setprecision</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/1624857186021.png" alt="1624857186021"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cout.put()</span></span><br><span class="line"><span class="comment">cout.write() //向输出缓冲区中写数据</span></span><br><span class="line"><span class="comment">cout.width()</span></span><br><span class="line"><span class="comment">cout.fill()</span></span><br><span class="line"><span class="comment">cout.setf(标记)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">操作符、控制符</span></span><br><span class="line"><span class="comment">flush</span></span><br><span class="line"><span class="comment">endl</span></span><br><span class="line"><span class="comment">oct</span></span><br><span class="line"><span class="comment">dec</span></span><br><span class="line"><span class="comment">hex</span></span><br><span class="line"><span class="comment">setbase</span></span><br><span class="line"><span class="comment">setw</span></span><br><span class="line"><span class="comment">setfill</span></span><br><span class="line"><span class="comment">setprecision</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hello "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>.put(<span class="string">'h'</span>).put(<span class="string">'e'</span>).put(<span class="string">'l'</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"hello wolrd"</span>;</span><br><span class="line"><span class="built_in">cout</span>.write(str, <span class="built_in">strlen</span>(str));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>.write(str, <span class="built_in">strlen</span>(str) - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//使⽤类成员函数</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "&lt;start&gt;";</span></span><br><span class="line"><span class="comment">cout.width(30); //设置接下来要输出的长度，是30</span></span><br><span class="line"><span class="comment">cout.fill('*'); //将没有填充的多余的空间，填充成*</span></span><br><span class="line"><span class="comment">cout.setf(ios::showbase);//#include&lt;iomanip&gt;</span></span><br><span class="line"><span class="comment">cout.setf(ios::internal);//设置</span></span><br><span class="line"><span class="comment">cout &lt;&lt; hex &lt;&lt; 123 &lt;&lt; "&lt;End&gt;\n";</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使⽤ 操作符、控制符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;Start&gt;"</span></span><br><span class="line">&lt;&lt; setw(<span class="number">30</span>)</span><br><span class="line">&lt;&lt; setfill(<span class="string">'*'</span>)</span><br><span class="line">&lt;&lt; setiosflags(ios::showbase)<span class="comment">//基数</span></span><br><span class="line">&lt;&lt; setiosflags(ios::internal)</span><br><span class="line">&lt;&lt; hex</span><br><span class="line">&lt;&lt; <span class="number">123</span></span><br><span class="line">&lt;&lt; <span class="string">"&lt;End&gt;\n"</span></span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">int</span>a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"inputa:"</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"dec:"</span> &lt;&lt; dec &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//以⼗进制形式输出整数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hex:"</span> &lt;&lt; hex &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//以⼗六进制形式输出整数a</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"oct:"</span> &lt;&lt; setbase(<span class="number">8</span>) &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//以⼋进制形式输出整数a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*pt = <span class="string">"China"</span>;<span class="comment">//pt指向字符串"China"</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; pt &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指定域宽为,输出字符串</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'*'</span>) &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; pt &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指定域宽,输出字符串,空⽩处以'*'填&gt;充</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>pi = <span class="number">22.0</span> / <span class="number">7.0</span>;<span class="comment">//计算pi值</span></span><br><span class="line"><span class="comment">//按指数形式输出,8位⼩数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setiosflags(ios::scientific) &lt;&lt; setprecision(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pi="</span> &lt;&lt; pi &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出pi值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pi="</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; pi &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//改为⼩数形式输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; "pi=" &lt;&lt; setprecision(4) &lt;&lt; pi &lt;&lt; endl;//改为位⼩数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> a = <span class="number">123.456</span>, b = <span class="number">3.14159</span>, c = <span class="number">-3214.67</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setiosflags(ios::right) &lt;&lt; setprecision(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//       123.45</span></span><br><span class="line"><span class="comment">//          3.14</span></span><br><span class="line"><span class="comment">//    -3214.67</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test1();</span></span><br><span class="line"><span class="comment">//test2();</span></span><br><span class="line"><span class="comment">//test3(); </span></span><br><span class="line">test4();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标准输入输出&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#标准输入输出&quot;&gt;&lt;/a&gt; 标准输入输出&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1624853954352.png&quot; alt=&quot;16248539543
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>事件选择模型</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/25/WS004%E4%BA%8B%E4%BB%B6%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/25/WS004事件选择模型/</id>
    <published>2021-06-24T23:51:59.000Z</published>
    <updated>2021-06-25T17:34:03.736Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/javawz/事件选择模型.png" height="100%" width="200%"><hr><img src="/images/javawz/事件模型对比select模型流程图1.png" height="100%" width="100%"><h1 id="事件选择模型"><a class="markdownIt-Anchor" href="#事件选择模型"></a> 事件选择模型</h1><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><h3 id="windows处理用户行为的两种方式"><a class="markdownIt-Anchor" href="#windows处理用户行为的两种方式"></a> windows处理用户行为的两种方式</h3><ul><li><p>消息机制</p><ul><li><p>核心：消息队列</p><ul><li><p>处理过程</p><ul><li>所有的用户操作，比如点鼠标，摁键盘，点软件上的按钮…等等，所有操作均依次按顺序被记录，装进一个队列</li></ul></li><li><p>特点</p><ul><li>消息队列由操作系统维护，咱们做的操作，然后把消息取出来，分类处理</li><li>有先后顺序</li></ul></li><li><p>其他</p><ul><li>我们之后教大家win32,MFC课程，这部分都是基于这个消息队列，会给大家详细介绍，大家暂时从宏观理解</li><li>我们下个模型，异步选择就是基于这个消息的</li></ul></li></ul></li></ul></li><li><p>事件机制</p><ul><li><p>核心：事件集合</p><ul><li><p>处理过程</p><ul><li>根据需求，我们为用户的特定操作绑定一个事件，事件由我们自己调用API创建，需要多少创建多少</li><li>将事件投递给系统，系统就帮咱们监视着，所以不能无限创建，太多系统运行就卡了</li><li>如果操作发生了，比如用户按鼠标了，那么对应的事件就会被置成有信号，也就是类似1变2了，用个数标记aaa</li><li>我们直接获取到有信号的事件，然后处理</li></ul></li><li><p>特点</p><ul><li>所有事件都是咱们自己定义的，系统只是帮咱们置有无信号，所以我们自己掌管定义…</li><li>无序的</li></ul></li><li><p>其他</p><ul><li>咱们这个事件选择，就是应用这个</li></ul></li></ul></li></ul></li></ul><h2 id="事件选择的逻辑"><a class="markdownIt-Anchor" href="#事件选择的逻辑"></a> 事件选择的逻辑</h2><h3 id="整体逻辑跟select差不多你看这个叫wsaeventselect-名字上一看就是select的进化版"><a class="markdownIt-Anchor" href="#整体逻辑跟select差不多你看这个叫wsaeventselect-名字上一看就是select的进化版"></a> 整体逻辑跟select差不多，你看这个叫WSAEventSelect 名字上一看，就是select的进化版</h3><h3 id="第一步"><a class="markdownIt-Anchor" href="#第一步"></a> 第一步</h3><ul><li><p>创建一个事件对象（变量）</p><ul><li>WSACreateEvent</li></ul></li></ul><h3 id="第二步"><a class="markdownIt-Anchor" href="#第二步"></a> 第二步</h3><ul><li><p>为每一个事件对象绑定个socket以及操作accept,read,close…并投递给系统</p><ul><li><p>投递给系统，咱们就完全不用管了，系统自己监管</p><ul><li>咱们就去做别的事儿去了</li></ul></li><li><p>WSAEventSelect</p></li></ul></li></ul><h3 id="第三步"><a class="markdownIt-Anchor" href="#第三步"></a> 第三步</h3><ul><li><p>查看事件是否有信号</p><ul><li>WSAWaitForMultipleEvents</li></ul></li></ul><h3 id="第四步"><a class="markdownIt-Anchor" href="#第四步"></a> 第四步</h3><ul><li><p>有信号的话就分类处理</p><ul><li>WSAEnumNetworkEvents</li></ul></li></ul><h2 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h2><h3 id="网络头文件-网络库"><a class="markdownIt-Anchor" href="#网络头文件-网络库"></a> 网络头文件 网络库</h3><ul><li><p>最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。</p></li><li><p>#include &lt;WinSock2.h&gt;<br>#pragma comment(lib,“ws2_32.lib”)</p><ul><li><p>函数库</p><ul><li><p>winsock2.h</p><ul><li><p>windows socket 第2版</p><ul><li>第一版是 winsock.h</li><li>查看具体区别</li></ul></li><li><p>目前网络库有哪些版本？</p><ul><li><p>1.0<br>1.1<br>2.0<br>2.1<br>2.2</p><ul><li><p>演示MSDN</p><ul><li><p>查这个函数的详细信息</p><ul><li>WSAStartup</li></ul></li></ul></li></ul></li></ul></li><li><p>我们的开发环境支持哪个版本？</p><ul><li>打开头文件，看咱们当前编译器环境支持的最高版本</li></ul></li></ul></li><li><p>ws2_32.lib</p><ul><li><p>windows socket 第2版  32位</p><ul><li>不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll</li></ul></li></ul></li><li><p>wsock32.lib</p><ul><li>winsock.h 第一版网络库 对应的库文件</li></ul></li><li><p>这里不区分大小写</p></li></ul></li></ul></li></ul><h3 id="打开网络库"><a class="markdownIt-Anchor" href="#打开网络库"></a> 打开网络库</h3><ul><li><p>int WSAStartup(<br>WORD      wVersionRequired,<br>LPWSADATA lpWSAData<br>);</p><ul><li><p>功能</p><ul><li><p>打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用</p></li><li><p>w windows<br>s  socket<br>a Asynchronous  异步<br>startup   启动</p><ul><li><p>同步与异步</p><ul><li><p>同步</p><ul><li>阻塞/卡死状态</li></ul></li><li><p>异步</p><ul><li>多个工作同时进行</li></ul></li></ul></li></ul></li></ul></li><li><p>参数1</p><ul><li><p>我们要使用的库的版本</p></li><li><p>类型是 WORD</p><ul><li>转定义：unsigned  short</li></ul></li><li><p>WORD wVersionRequired = MAKEWORD(2,2);</p><ul><li><p>MAKEWORD(主版本,副版本)， 1.0 2.2</p></li><li><p>wVersionRequired</p><ul><li>数据高位/高地址是副版本</li><li>数据低位/低地址是主版本</li><li>用调试+计算器演示数据原理</li></ul></li></ul></li><li><p>位运算，内存操作，小端存储</p></li></ul></li><li><p>参数2</p><ul><li><p>LPWSADATA lpWSAData</p><ul><li><p>系统通过这个参数给我们一些配置信息</p><ul><li><p>注意</p><ul><li>当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则</li></ul></li></ul></li><li><p>看下有哪些信息</p><ul><li><p>struct WSAData {<br>WORD           wVersion;<br>WORD           wHighVersion;<br>unsigned short iMaxSockets;<br>unsigned short iMaxUdpDg;<br>char           *lpVendorInfo;<br>char           szDescription[WSADESCRIPTION_LEN + 1];<br>char           szSystemStatus[WSASYS_STATUS_LEN + 1];<br>}</p><ul><li><p>wVersion</p><ul><li>我们要使用的版本</li></ul></li><li><p>wHighVersion</p><ul><li>系统能提供给我们最高的版本</li></ul></li><li><p>iMaxSockets</p><ul><li>返回可用的socket的数量，2版本之后就没用了</li></ul></li><li><p>iMaxUdpDg</p><ul><li>UDP数据报信息的大小，2版本之后就没用了</li></ul></li><li><p>lpVendorInfo</p><ul><li>供应商特定的信息，2版本之后就没用了</li></ul></li><li><p>szDescription<br>szSystemStatus</p><ul><li>当前库的描述信息，2.0是第二版的意思</li></ul></li></ul></li></ul></li><li><p>当输入的版本不存在</p><ul><li><p>输入1.3， 2.3</p><ul><li><p>有主版本，没有副版本</p><ul><li>得到该主版本的最大副版本 1.1 2.2并使用</li></ul></li></ul></li><li><p>输入3.1  3.3</p><ul><li><p>超过最大版本号</p><ul><li>使用系统能提供的最大的版本 2.2</li></ul></li></ul></li><li><p>输入 0.0 0.1 0.3</p><ul><li><p>主版本是0</p><ul><li>网络库打开失败，不支持请求的套接字版本</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>返回0为执行正确</p></li><li><p>失败</p><ul><li>这些宏的本质</li><li>WSASYSNOTREADY   10091       底层网络子系统尚未准备好进行网络通信。                                                  系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下<br>WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。      要使用的版本不支持<br>WSAEPROCLIM        10067         已达到对Windows套接字实现支持的任务数量的限制。                                 Windows Sockets实现可能限制同时使用它的应用程序的数量<br>WSAEINPROGRESS 10036          正在阻止Windows Sockets 1.1操作。                                                          当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止<br>WSAEFAULT            10014          lpWSAData参数不是有效指针。                                                                 参数写错了</li></ul></li></ul></li></ul></li></ul><h3 id="校验版本"><a class="markdownIt-Anchor" href="#校验版本"></a> 校验版本</h3><ul><li><p>2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion)</p><ul><li><p>HIBYTE是高位 副版本</p></li><li><p>LOBYTE是地位 主版本</p></li><li><p>逻辑</p><ul><li>只要有一个不是2，说明系统不支持我们要的2.2版本</li></ul></li></ul></li><li><p>关闭库<br>并结束函数，可以给出相应提示</p><ul><li>WSACleanup();</li><li>return 0；</li></ul></li></ul><h3 id="创建socket"><a class="markdownIt-Anchor" href="#创建socket"></a> 创建SOCKET</h3><ul><li><p>SOCKET  socket(<br>int af,<br>int type,<br>int protocol<br>);</p><ul><li><p>作用</p><ul><li>创建一个SOCKET</li></ul></li><li><p>SOCKET介绍</p><ul><li><p>什么是socket</p><ul><li>将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了，</li><li>也就是说，SOCKET是我们调用协议进行通信的 操作接口</li></ul></li><li><p>意义</p><ul><li><p>将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。</p><ul><li>网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些</li></ul></li></ul></li><li><p>本质</p><ul><li><p>就是一种数据类型，转定义看下类型</p><ul><li><p>就是一个整数</p><ul><li>uint</li></ul></li><li><p>但是这个数是唯一的</p><ul><li>标识着我当前的应用程序，协议特点等信息</li><li>ID，门牌号</li></ul></li></ul></li></ul></li><li><p>应用</p><ul><li><p>我们网络通信的函数，全部都要使用SOCKET</p><ul><li>演示</li></ul></li><li><p>逻辑</p><ul><li>每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET</li></ul></li></ul></li><li><p>所以</p><ul><li>网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程</li></ul></li></ul></li><li><p>参数1</p><ul><li><p>地址的类型</p><ul><li><p>比如大家联系我</p><ul><li><p>手机</p><ul><li>15512345678</li></ul></li><li><p>固定电话</p><ul><li>7881234</li></ul></li><li><p>ＱＱ</p><ul><li>40916626</li></ul></li><li><p>微信</p><ul><li>c3_xin666</li></ul></li><li><p>找上门</p><ul><li>内蒙古 xxxxxxx</li></ul></li><li><p>…</p></li></ul></li><li><p>AF_INET  2</p><ul><li><p>ipv4</p><ul><li><p>Internet协议版本4（IPv4）地址系列。</p><ul><li><p>192.168.1.103</p><ul><li>0.0.0.0  ~  255.255.255.255</li><li>点分十进制表示法</li></ul></li></ul></li><li><p>4字节 32位的地址</p><ul><li><p>个数快不够</p><ul><li>就是无符号int类型的范围  0 ~ 4294967295</li></ul></li></ul></li></ul></li></ul></li><li><p>AF_INET6  23</p><ul><li><p>ipv6</p><ul><li><p>Internet协议版本6（IPv6）地址系列。</p><ul><li>2001:0:3238:DFE1:63::FEFB</li></ul></li><li><p>16字节  128位的地址</p><ul><li>这个地球每寸一个IP</li></ul></li></ul></li></ul></li><li><p>AF_BTH  32</p><ul><li><p>蓝牙地址系列。<br>如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。</p><ul><li>6B:2D:BC:A9:8C:12</li></ul></li></ul></li><li><p>AF_IRDA  26</p><ul><li>红外数据协会（IrDA）地址系列。<br>仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。</li></ul></li><li><p>通信地址不仅仅只有IP地址</p></li></ul></li></ul></li><li><p>参数2</p><ul><li><p>套接字类型</p><ul><li><p>SOCK_STREAM    1</p><ul><li>一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。</li></ul></li><li><p>SOCK_DGRAM    2</p><ul><li>一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。</li></ul></li><li><p>SOCK_RAW   3</p><ul><li>一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。</li></ul></li><li><p>SOCK_RDM   4</p><ul><li>一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。<br>仅在安装了可靠多播协议时才支持此类型值。</li></ul></li><li><p>SOCK_SEQPACKET   5</p><ul><li>一种套接字类型，提供基于数据报的伪流数据包。</li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>协议的类型</p><ul><li><p>IPPROTO_TCP</p><ul><li>传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_UDP</p><ul><li>用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_ICMP</p><ul><li>Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_IGMP</p><ul><li>Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_RM</p><ul><li>用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。<br>仅在安装了可靠多播协议时才支持此协议值。</li></ul></li><li><p>整理下</p><ul><li>通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。</li><li>想要使用一个协议，咱们设备得支持才行，比如红外</li><li>参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型</li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功返回可用的socket</p><ul><li><p>不用了就一定要销毁套接字</p><ul><li>closesocket(socketListen);</li></ul></li></ul></li><li><p>失败返回INVALID_SOCKET</p><ul><li><p>关闭网络库</p><ul><li>WSACleanup();</li></ul></li><li><p>可用WSAGetLasterror()返回错误码</p></li></ul></li></ul></li></ul></li></ul><h3 id="绑定地址与端口"><a class="markdownIt-Anchor" href="#绑定地址与端口"></a> 绑定地址与端口</h3><ul><li><p>int bind(<br>SOCKET              s,<br>const sockaddr *addr,<br>int                 namelen<br>);</p><ul><li><p>作用</p><ul><li><p>给我们的socket绑定端口号与具体地址</p><ul><li><p>地址</p><ul><li><p>找到咱们的电脑</p><ul><li>只有一个</li></ul></li></ul></li><li><p>端口号</p><ul><li><p>找到我们机器上对应的软件，比如QQ，浏览器等等，都对应着自己的端口号</p><ul><li>多个</li></ul></li><li><p>每一种通信的端口号是唯一的</p></li><li><p>同一个软件可能占用多个端口号</p></li></ul></li></ul></li></ul></li><li><p>参数1</p><ul><li>上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号</li></ul></li><li><p>参数2</p><ul><li><p>结构体</p><ul><li>地址类型</li><li>装IP地址</li><li>端口号</li></ul></li><li><p>结构体类型</p><ul><li><p>sockaddr</p></li><li><p>该参数使用方法</p><ul><li><p>SOCKADDR_IN sockAddress;<br>sockAddress.sin_family = AF_INET;<br>sockAddress.sin_addr.s_addr = inet_addr(“127.0.0.1”);<br>sockAddress.sin_port = 12345;<br>(sockaddr*)&amp;sockAddress强转添加到参数2上</p><ul><li><p>成员1</p><ul><li>跟socket函数参数1是一样的</li></ul></li><li><p>成员2</p><ul><li><p>IP地址</p><ul><li><p><a href="http://192.168.xxx.xxx" target="_blank" rel="noopener">192.168.xxx.xxx</a></p><ul><li>可以在控制台输入指令  ipconfig 就能看到了</li><li>或者在网络设置中，能找到这个地址</li><li>我就不演示了，我不想让你们发现我</li></ul></li><li><p>127.0.0.1</p><ul><li>回送地址  本地回环地址  本地网络测试</li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>端口号</p><ul><li><p>本质</p><ul><li><p>就是一个整数</p><ul><li>0~65535</li></ul></li><li><p>IP是我们机器的地址，端口就是我们具体的软件的通信口，一个软件可能会占用多个接口，比如一个软件可以聊天，可以下载，可以看视频…那么这些不同的通信内容，往往会有各自的协议，各自的端口。</p><ul><li>IP是公司地址，端口就是各个部门的地址了</li></ul></li></ul></li><li><p>填写哪个值呢？</p><ul><li><p>理论上只要这个范围0~65535都可以</p><ul><li><p>实际</p><ul><li><p>介于0～1023，为系统保留占用端口号</p><ul><li>21端口分配给FTP(文件传输协议)服务<br>25端口分配给SMTP（简单邮件传输协议）服务<br>80端口分配给HTTP服务</li></ul></li></ul></li><li><p>所以</p><ul><li><p>我们不能写这个范围的</p><ul><li><p>我们的范围就是1024~65535</p><ul><li>稍微大点儿，1万多</li></ul></li><li><p>但是注意一点，端口号是唯一的，比如1234已经被别的软件占用了，那么你再使用1234这个端口号，那么就会绑定失败，因为已经呗占用了</p><ul><li>给大家演示下</li></ul></li><li><p>那大家如何查看自己要用的端口号有没有被占用呢？</p><ul><li><p>打开运行cmd输入netstat -ano</p><ul><li>查看被使用的所有端口</li></ul></li><li><p>netstat -aon|findstr “12345”</p><ul><li>检查我们要使用的端口号是否被使用了</li><li>使用了就会显示使用的程序，未被使用就啥都不显示</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>参数2的类型大小</p><ul><li>sizeof(参数2)</li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功返回0</p></li><li><p>失败返回SOCKET_ERROR</p><ul><li>具体错误码通过int WSAGetLastError(void);获得</li><li>closesocket(socketListen);<br>WSACleanup();</li></ul></li></ul></li></ul></li></ul><h3 id="开始监听"><a class="markdownIt-Anchor" href="#开始监听"></a> 开始监听</h3><ul><li><p>int WSAAPI listen(<br>SOCKET s,<br>int    backlog<br>);</p><ul><li><p>作用</p><ul><li>将套接字置于正在侦听传入连接的状态。</li></ul></li><li><p>参数1</p><ul><li>服务器端的socket，也就是socket函数创建的</li></ul></li><li><p>参数2</p><ul><li><p>挂起连接队列的最大长度。</p><ul><li><p>就是说，比如有100个用户链接请求，但是系统一次只能处理20个，那么剩下的80个不能不理人家，所以系统就创建个队列记录这些暂时不能处理，一会儿处理的链接请求，依先后顺序处理，那这个队列到底多大？就是这个参数设置，比如2，那么就允许两个新链接排队的。这个肯定不能无限大，那内存不够了。</p></li><li><p>我们可以手动设置这个参数，但是别大了。可能2<sub>10多，</sub>20多。</p></li><li><p>我们一般填写这个参数</p><ul><li><p>SOMAXCONN</p><ul><li>作用是让系统自动选择最合适的个数</li><li>不同的系统环境不一样，所以这个合适的数也都不一样</li></ul></li></ul></li></ul></li></ul></li><li><p>WSAAPI</p><ul><li><p>调用约定</p><ul><li><p>这个我们可以忽略，这是给系统看的，跟咱们没关</p></li><li><p>决定三</p><ul><li>函数名字的编译方式</li><li>参数的入栈顺序</li><li>函数的调用时间</li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功</p><ul><li>返回0</li></ul></li><li><p>失败</p><ul><li><p>SOCKET_ERROR</p></li><li><p>具体错误码</p><ul><li><p>WSAGetLastError()</p></li><li><p>释放</p><ul><li>closesocket(socketListen);</li><li>WSACleanup();</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="事件选择"><a class="markdownIt-Anchor" href="#事件选择"></a> 事件选择</h3><ul><li><p>创建一个事件对象</p><ul><li><p>WSAEVENT WSAAPI WSACreateEvent();</p><ul><li><p>成功</p><ul><li>返回一个事件</li></ul></li><li><p>失败</p><ul><li><p>返回WSA_INVALID_EVENT</p></li><li><p>WSAGetLastError获取错误码</p></li><li><p>关闭</p><ul><li>::closesocket(socketServer);<br>::WSACleanup();</li></ul></li></ul></li><li><p>转定义</p><ul><li><p>HANDLE</p><ul><li><p>句柄</p><ul><li><p>ID</p></li><li><p>内核对象</p><ul><li><p>由系统在内核申请</p></li><li><p>由操作系统访问</p></li><li><p>我们不能定位其内容，也不能修改</p><ul><li><p>void*</p><ul><li>通用类型指针</li></ul></li><li><p>对内核的保护，对规则的保护，从而使操作系统有序的平稳的，有效的运行，而不会随便出问题</p></li></ul></li><li><p>调用函数创建，调用函数释放</p><ul><li>如果我们没有调用释放，那么他可能就一直存在于内核，造成内核内存泄漏， 这种只能重启电脑</li></ul></li><li><p>内核对象有哪些</p><ul><li>socket</li><li>Kernel Objects</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>几个函数</p><ul><li><p>BOOL WSAAPI WSACloseEvent<br>(<br>WSAEVENT hEvent<br>);</p><ul><li><p>关闭/释放事件句柄</p><ul><li>不用就要释放</li></ul></li></ul></li><li><p>BOOL WSAAPI WSAResetEvent<br>(<br>WSAEVENT hEvent<br>);</p><ul><li>重置WSAEventSelect函数使用的事件对象状态的正确方法是将事件对象的句柄传递给hEventObject参数中的WSAEnumNetworkEvents函数。 这将重置事件对象并以原子方式调整套接字上活动FD事件的状态。</li></ul></li><li><p>BOOL WSAAPI WSASetEvent<br>(<br>WSAEVENT hEvent<br>);</p><ul><li>将指定事件主动置成有信号</li></ul></li></ul></li></ul></li><li><p>绑定并投递</p><ul><li><p>int WSAAPI WSAEventSelect<br>(<br>SOCKET   s,<br>WSAEVENT hEventObject,<br>long     lNetworkEvents<br>);</p><ul><li><p>功能</p><ul><li>给事件绑上socket与操作码，并投递给操作系统</li></ul></li><li><p>参数1</p><ul><li><p>被绑定的socket</p><ul><li>最终，每个socket都会被绑定一个事件</li></ul></li></ul></li><li><p>参数2</p><ul><li><p>事件对象</p><ul><li>逻辑，就是讲参数1与参数2绑定在一起</li></ul></li></ul></li><li><p>参数3</p><ul><li><p>具体事件</p><ul><li><p>FD_ACCEPT</p><ul><li><p>有客户端链接</p><ul><li>与服务器socket绑定</li></ul></li></ul></li><li><p>FD_READ</p><ul><li><p>有客户端发来消息</p><ul><li>与客户端socket绑定</li><li>可多个属性并列 用 |</li></ul></li></ul></li><li><p>FD_CLOSE</p><ul><li><p>客户端下线了</p><ul><li>与客户端socket绑定</li><li>包含强制下线，正常下线</li></ul></li></ul></li><li><p>FD_WRITE</p><ul><li><p>可以给客户端发信</p><ul><li>与客户端socket绑定</li><li>会在accept后立即主动产生该信号</li><li>可以说明，客户端连接成功，即可随时send</li></ul></li><li><p>有特点</p><ul><li>代码写完给大家测试</li></ul></li></ul></li><li><p>FD_CONNECT</p><ul><li>客户端一方，给服务器绑定这个</li></ul></li><li><p>0</p><ul><li><p>取消事件监视</p><ul><li>WSAEventSelect（FD_ACCEPT | FD_READ）；</li><li>WSAEventSelect（0）；</li></ul></li></ul></li><li><p>FD_OOB</p><ul><li><p>带外数据</p><ul><li>不多说了，一般不使用</li></ul></li></ul></li><li><p>FD_QOS</p><ul><li><p>套接字服务质量状态发生变化消息通知</p><ul><li>比如：当网络发生拥堵时：用户下载，看电影，聊天，听歌…好多用网事件一起在做，那么计算机网速是有限的，每秒可以处理多少数据，这时候，计算机就会把要紧事优先，比如可以降低下载的速度，以保证看电影流畅，这时候，下载的服务质量就发生了变化。如果投放了这个事件，就会接收到信号了</li><li>通过这些小问题的介绍，大家就要注意到实际应用中的问题了，稍微记一下</li></ul></li><li><p>WSAIoctl</p><ul><li>得到服务质量信息</li><li>char strOut[2048] = { 0 };<br>DWORD nLen = 2048;<br>WSAIoctl(socketServer, SIO_QOS, 0, 0, strOut, nLen, &amp;nLen, NULL, NULL);</li></ul></li></ul></li><li><p>FD_GROUP_QOS</p><ul><li><p>保留</p><ul><li>还没有对其赋值具体意义，还没用呢</li></ul></li><li><p>想要接收套接字组QoS更改的通知。</p></li></ul></li><li><p>重叠I/O模型中</p><ul><li><p>FD_ROUTING_ INTERFACE_CHANGE</p><ul><li><p>想要接收指定目标的路由接口更改通知。</p></li><li><p>数据到达对方的所经过的线路改变了，由于是动态优化选择</p></li><li><p>要通过此函数WSAIoctl注册之后，才可以</p><ul><li>SIO_ROUTING_ INTERFACE_CHANGE</li></ul></li></ul></li><li><p>FD_ADDRESS_ LIST_CHANGE</p><ul><li><p>想要接收套接字地址族的本地地址列表更改通知。</p><ul><li>咱们服务器，链接了很多客户端，那服务器就记录着所有的客户端的地址信息，也就是相当于一个列表，当多一个或者少一个，就是变化了， 咱们就能得到相关的信号了</li></ul></li><li><p>要通过此函数WSAIoctl注册之后，才可以有效</p><ul><li>SIO_ADDRESS_ LIST_CHANGE</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功</p><ul><li>返回0</li></ul></li><li><p>失败</p><ul><li><p>失败SOCKET_ERROR</p><ul><li>WSACloseEvent(wsaEvent);<br>closesocket(socketServer);<br>WSACleanup();</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>询问事件</p><ul><li><p>DWORD WSAAPI WSAWaitForMultipleEvents(<br>DWORD          cEvents,<br>const WSAEVENT *lphEvents,<br>BOOL           fWaitAll,<br>DWORD          dwTimeout,<br>BOOL           fAlertable<br>);</p><ul><li><p>作用</p><ul><li>获取发生信号的事件</li></ul></li><li><p>参数1</p><ul><li><p>事件个数</p><ul><li><p>定义事件列表（数组）个数是</p><ul><li><p>WSA_MAXIMUM_WAIT_EVENTS</p><ul><li>64个</li><li>该函数参数1最大64</li></ul></li><li><p>可以变大</p><ul><li>方法我们在逻辑讲完了再讲，有一点儿复杂</li><li>不像select模型，直接就能变大，因为select本身就是个数组，然后遍历就行了，比较直接，事件选择是异步投放，由系统管理，咱们就不能随便修改了，要按照规则来</li></ul></li></ul></li></ul></li></ul></li><li><p>参数2</p><ul><li>事件列表</li></ul></li><li><p>参数3</p><ul><li><p>事件等待方式</p><ul><li><p>TRUE</p><ul><li>所有的事件都产生信号，才返回</li></ul></li><li><p>FALSE</p><ul><li>任何一个事件产生信号，立即返回</li><li>返回值减去WSA_WAIT_EVENT_0表示事件对象的索引，其状态导致函数返回。</li><li>如果在调用期间发出多个事件对象的信号，则这是信号事件对象的数组索引，其中所有信号事件对象的索引值最小。</li></ul></li></ul></li></ul></li><li><p>参数4</p><ul><li><p>超时间隔，以毫秒为单位。 跟select参数5一样的意义</p></li><li><p>123</p><ul><li><p>等待123毫秒</p><ul><li>超时返回WSA_WAIT_TIMEOUT</li></ul></li></ul></li><li><p>0</p><ul><li>检查事件对象的状态并立即返回。不管有没有信号</li></ul></li><li><p>WSA_INFINITE</p><ul><li>等待直到事件发生</li></ul></li></ul></li><li><p>参数5</p><ul><li><p>TRUE</p><ul><li>重叠IO模型使用</li></ul></li><li><p>FALSE</p><ul><li>咱们这个事件选择模型填写FALSE</li></ul></li></ul></li><li><p>返回值</p><ul><li><p>数组下标的运算值</p><ul><li><p>参数3为true</p><ul><li>所有的事件均有信号</li></ul></li><li><p>参数3为false</p><ul><li>返回值减去WSA_WAIT_EVENT_0==数组中事件的下标</li></ul></li></ul></li><li><p>WSA_WAIT_IO_COMPLETION</p><ul><li>参数5为TRUE，才会返回这个值</li></ul></li><li><p>WSA_WAIT_TIMEOUT</p><ul><li>超时了，continue即可</li></ul></li><li><p>WSA_WAIT_FAILED</p><ul><li>出错了</li></ul></li></ul></li></ul></li></ul></li><li><p>列举事件</p><ul><li><p>int WSAAPI WSAEnumNetworkEvents(<br>SOCKET             s,<br>WSAEVENT           hEventObject,<br>LPWSANETWORKEVENTS lpNetworkEvents<br>);</p><ul><li><p>获取事件类型，并将事件上的信号重置</p><ul><li>accept recv close等等</li></ul></li><li><p>参数1</p><ul><li>对应的socket</li></ul></li><li><p>参数2</p><ul><li>对应的事件</li></ul></li><li><p>参数3</p><ul><li><p>触发的事件类型在这里装着</p></li><li><p>是一个结构体指针</p><ul><li><p>struct _WSANETWORKEVENTS<br>{<br>long lNetworkEvents;<br>int  iErrorCode[FD_MAX_EVENTS];<br>}</p><ul><li><p>成员1：具体操作</p><ul><li>一个信号可能包含两个消息，以按位或的形式存在</li></ul></li><li><p>参数2：错误码数组</p><ul><li>FD_ACCEPT事件错误码在FD_ACCEPT_BIT下标里</li><li>没有错误，对应的就是0</li></ul></li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功</p><ul><li>0</li></ul></li><li><p>失败</p><ul><li>SOCKET_ERROR</li><li>WSAGetLastError()得到错误码</li></ul></li></ul></li></ul></li></ul></li><li><p>事件分类处理逻辑</p><ul><li><p>if (lpNetworkEvents-&gt;lNetworkEvents &amp; FD_ACCEPT)<br>{<br>if (lpNetworkEvents-&gt;iErrorCode[FD_ACCEPT_BIT] == 0)<br>{<br>//接受链接<br>//创建事件<br>//投放事件<br>//元素增加<br>}<br>}</p></li><li><p>用switch可以嘛？</p><ul><li>不行，有大bug</li></ul></li><li><p>else if可以嘛？</p><ul><li>不太行，有小bug</li></ul></li></ul></li></ul><h3 id="有序处理"><a class="markdownIt-Anchor" href="#有序处理"></a> 有序处理</h3><ul><li><p>for (i = Index; i &lt; EventTotal; i++)<br>{<br>Index = WSAWaitForMultipleEvents(1, &amp;EventArray[i], TRUE, 1000, FALSE);<br>if ((Index != WSA_WAIT_FAILED) &amp;&amp; (Index != WSA_WAIT_TIMEOUT))<br>{<br>WSAEnumNetworkEvents(SocketArray[i], EventArray[i], &amp;NetworkEvents);<br>//分类处理<br>}<br>}</p></li><li><p>最开始就一个一个检测</p><ul><li><p>不绝对的公平，只是相对公平，相对有序</p><ul><li>让大家在一轮循环下都能得到处理</li><li>但是并不能完全解决顺序问题，只是达到相对公平</li><li>所以，事件选择模型不能用于大用户，多访问</li></ul></li></ul></li></ul><h3 id="增加事件数量"><a class="markdownIt-Anchor" href="#增加事件数量"></a> 增加事件数量</h3><ul><li><p>一个一个来，一个大数组就行了啊</p><ul><li>结合线程池</li></ul></li><li><p>一组一组来</p><ul><li><p>单线程，一组一组顺序处理就好了</p></li><li><p>创建多个线程，每个线程处理一个事件表，最大64</p><ul><li>提醒</li></ul></li></ul></li></ul><h3 id="释放"><a class="markdownIt-Anchor" href="#释放"></a> 释放</h3><h3 id="对比select的结构吐"><a class="markdownIt-Anchor" href="#对比select的结构吐"></a> 对比select的结构吐</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/javawz/事件选择模型.png&quot; height=&quot;100%&quot; width=&quot;200%&quot;&gt;
&lt;hr&gt;
&lt;img src=&quot;/images/javawz/事件模型对比select模型流程图1.png&quot; height=&quot;100%&quot; width=&quot;
      
    
    </summary>
    
      <category term="Windows网络编程" scheme="https://xiaowuyoucy.github.io/categories/Windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>IP地址的划分和子网掩码计算方法</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/23/jiw005-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%92%E5%88%86%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/23/jiw005-IP地址的划分和子网掩码计算方法/</id>
    <published>2021-06-22T21:50:56.000Z</published>
    <updated>2021-06-22T22:45:38.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ip地址的划分"><a class="markdownIt-Anchor" href="#ip地址的划分"></a> IP地址的划分</h1><p>ip地址转二进制</p><p>192.168.1.110</p><p>11000000  10101000  00000001  01101110</p><h3 id="地址分类"><a class="markdownIt-Anchor" href="#地址分类"></a> 地址分类</h3><p>A类:</p><p>1.0.0.1~126.255.255.254</p><p>0 &lt; A类 &lt; 127</p><p>本地回环地址:</p><p>127.0.0.1~127.255.255.255</p><p>B类:</p><p>128.0.0.1~191.255.255.254</p><p>128 &lt;= B类 &lt; 192</p><p>C类:</p><p>192.0.0.1~223.255.255.254</p><p>D类:</p><p>组播用的</p><p>E类:</p><p>科研用的</p><hr><p>私有ip地址范围:</p><p>局域网地址:</p><p>A类:</p><p>10.0.0.0 ~ 10.255.255.255</p><p>ip个数 = 65536 *255</p><p>B类:</p><p>172.16.0.0 ~ 172.31.255.255</p><p>ip个数 = 16 * 65536</p><p>C类:</p><p>192.168.0.0 ~ 192.168.255.255</p><p>ip个数 =  65536</p><h1 id="子网掩码计算方法"><a class="markdownIt-Anchor" href="#子网掩码计算方法"></a> 子网掩码计算方法</h1><p>子网掩码的作用规定了一个子网的ip地址范围大小：</p><p>不同网段访问要通过路由器或三层交换机</p><p>192.168.11.0/24 === 192.168.11.0 netmask 255.255.255.0</p><p>24 代表子网掩码是24个1</p><p>192.168.11.0    网络号</p><p>192.168.11.1   起始地址</p><p>192.168.11.254   结束地址</p><p>192.168.11.255   广播地址</p><p>例如有一个ip是192.168.1.110</p><p>子网掩码是255.255.255.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">11000000101010000000000101101110</span><br><span class="line"></span><br><span class="line">11111111111111111111111100000000</span><br><span class="line"></span><br><span class="line">11111111对应的部分是不能修改的</span><br><span class="line">也就是</span><br><span class="line">110000001010100000000001   这部分是不能修改的</span><br><span class="line">能修改的是01101110这部分</span><br></pre></td></tr></table></figure><p>一般的可以修改部分全是0是网络号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.0</span><br><span class="line"></span><br><span class="line">子网掩码  </span><br><span class="line">11111111        11111111        11111111        00000000</span><br><span class="line">IP地址</span><br><span class="line">11000000        10101000        00000001        01101110</span><br><span class="line">网络号    </span><br><span class="line">11000000        10101000        00000001        00000000</span><br></pre></td></tr></table></figure><p>起始ip:是网络号+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">子网掩码  </span><br><span class="line">11111111        11111111        11111111        00000000</span><br><span class="line">网络号    </span><br><span class="line">11000000        10101000        00000001        00000000</span><br><span class="line">起始ip</span><br><span class="line">11000000        10101000        00000001        00000001</span><br><span class="line">192.168.1.1</span><br></pre></td></tr></table></figure><p>结束ip:是广播ip-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">子网掩码  </span><br><span class="line">11111111        11111111        11111111        00000000</span><br><span class="line">255.255.255.0</span><br><span class="line">网络号    </span><br><span class="line">11000000        10101000        00000001        00000000</span><br><span class="line">192.168.1.0</span><br><span class="line">起始ip</span><br><span class="line">11000000        10101000        00000001        00000001</span><br><span class="line">192.168.1.1</span><br><span class="line">结束ip</span><br><span class="line">11000000        10101000        00000001        11111110</span><br><span class="line">192.168.1.254</span><br><span class="line">广播ip</span><br><span class="line">11000000        10101000        00000001        11111111</span><br></pre></td></tr></table></figure><p>广播ip:是可修改部分全是1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">子网掩码  </span><br><span class="line">11111111        11111111        11111111        00000000</span><br><span class="line">网络号    </span><br><span class="line">11000000        10101000        00000001        00000000</span><br><span class="line">广播ip</span><br><span class="line">11000000        10101000        00000001        11111111</span><br><span class="line">192.168.1.255</span><br></pre></td></tr></table></figure><h3 id="子网掩码只能用以下的数字"><a class="markdownIt-Anchor" href="#子网掩码只能用以下的数字"></a> 子网掩码只能用以下的数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">000000000</span><br><span class="line">12810000000</span><br><span class="line">19211000000</span><br><span class="line">22411100000</span><br><span class="line">24011110000</span><br><span class="line">24811111000</span><br><span class="line">25211111100</span><br><span class="line">25411111110</span><br><span class="line">25511111111</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ip地址的划分&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ip地址的划分&quot;&gt;&lt;/a&gt; IP地址的划分&lt;/h1&gt;
&lt;p&gt;ip地址转二进制&lt;/p&gt;
&lt;p&gt;192.168.1.110&lt;/p&gt;
&lt;p&gt;11000000  10101000	 
      
    
    </summary>
    
      <category term="计算机网络TCP/IP传输协议/网络抓包" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CTCP-IP%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP的三次握手和四次挥手</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/23/jiw004-TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/23/jiw004-TCP的三次握手和四次挥手/</id>
    <published>2021-06-22T21:03:51.000Z</published>
    <updated>2021-06-22T21:52:10.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp三次握手"><a class="markdownIt-Anchor" href="#tcp三次握手"></a> TCP三次握手</h1><p><img src="/images/javawz/1624396879962.png" alt="1624396879962"></p><p>ack的值永远等于上一个数据包seq的值加1</p><p>ack也叫期望值</p><p><img src="/images/javawz/1624397329411.png" alt="1624397329411"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三次握手：</span><br><span class="line">“喂，你听得到吗？”</span><br><span class="line">“我听得到呀，你听得到我吗？”</span><br><span class="line">“我能听到你，今天 balabala……”</span><br></pre></td></tr></table></figure><h1 id="tcp的四次挥手"><a class="markdownIt-Anchor" href="#tcp的四次挥手"></a> TCP的四次挥手</h1><p><img src="/images/javawz/1624398035519.png" alt="1624398035519"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端:我们分手吧</span><br><span class="line">服务端:好的,我知道了</span><br><span class="line">服务端:我们分手吧</span><br><span class="line">客户端:好的再见</span><br></pre></td></tr></table></figure><h3 id="tcp的数据传输过程"><a class="markdownIt-Anchor" href="#tcp的数据传输过程"></a> tcp的数据传输过程：</h3><h5 id="syn表示建立连接"><a class="markdownIt-Anchor" href="#syn表示建立连接"></a> SYN表示建立连接，</h5><h5 id="fin表示关闭连接"><a class="markdownIt-Anchor" href="#fin表示关闭连接"></a> FIN表示关闭连接，</h5><h5 id="ack表示响应"><a class="markdownIt-Anchor" href="#ack表示响应"></a> ACK表示响应，</h5><h5 id="psh表示有data数据传输"><a class="markdownIt-Anchor" href="#psh表示有data数据传输"></a> PSH表示有DATA数据传输，</h5><h5 id="urg表示紧急指针"><a class="markdownIt-Anchor" href="#urg表示紧急指针"></a> URG表示紧急指针</h5><h5 id="rst表示连接重置"><a class="markdownIt-Anchor" href="#rst表示连接重置"></a> RST表示连接重置。</h5><h1 id="tcp的11种状态"><a class="markdownIt-Anchor" href="#tcp的11种状态"></a> TCP的11种状态</h1><h2 id="tcp三次握手建立连接"><a class="markdownIt-Anchor" href="#tcp三次握手建立连接"></a> TCP三次握手建立连接</h2><p><strong>Tcp头部</strong></p><p><img src="/images/javawz/823435-20170323092941611-1541980584.png" alt="img"></p><p>六个标志位中，我们要用到三个：</p><p><strong>SYN</strong>：SYN=  1 表示这是一个连接请求或连接接受报文。在建立连接时用来进行同步序号（个人理解是，在建立连接的时候，提醒对方记录本方的起始序号）。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若是同意建立连接，则应响应的报文段中使SYN=1、ACK=1。因此SYN=1表示该报文是一个连接请求报文或者是一个连接请求接收报文。</p><p><strong>ACK</strong>：确认号只有在该位设置为1的时候才生效，当该位为0是表示确认号无效。TCP规定，在TCP连接建立后所有传送的数据报文段ACK都必须设置为1。</p><p><strong>FIN</strong>：当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</p><p>此外我们还需要用到序号和确认号：</p><p><strong>序号</strong>：占4个字节，它的范围在0-2^32-1，序号随着通信的进行不断的递增，当达到最大值的时候重新回到0在开始递增。TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按照顺序编号。整个要传送的字节流的起始号必须在连接建立时设置。首部中的序列号字段指的是本报文段所发送的数据的第一个字节的序号。例如，一个报文序号是301，而携带的数据共有100字节。则表示本次报文中的序号是301，下一个报文的序号是401.重复一下，每一个报文的序号是该报文包含的字节中第一个字节的编号。</p><p><strong>确认号</strong>：占4个字节，确认号，是对下一个想要接受的字节的期望，这里隐式确认了对上一个数据包的成功接收。如上例，在成功接收了序号为301的数据包，想要接收下一个数据包因为上个数据包包含100字节，所以此时的确认号应该是401，表示希望接收下一个序号是401的数据包。</p><p>三次握手过程：</p><p><img src="/images/javawz/823435-20170323092953893-1865298744.png" alt="img"></p><p><strong>过程描述：</strong></p><p>首先由Client发出请求连接即 SYN=1 ACK=0 (请看头字段的介绍)，TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x。</p><p>然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y，ack=x+1。</p><p>再然后 Client 再进行一次确认，但不用SYN 了，这时即为 ACK=1, seq=x+1，ack=y+1。</p><p><strong>为什么要进行三次握手（两次确认）：</strong></p><p>为什么A还要发送一侧确认呢？这主要是为了防止已失效的连接请求报文突然又传送到了B，因而产生错误。</p><p>所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况。A发出连接请求，但因连接请求丢失而未收到确认。于是A再次重传一次连接请求。后来收到了确认建立了连接。数据传输完毕后，就释放了连接。A供发送了两个连接请求的报文段，其中第一个丢失，第二个到达了B。没有“已失效的连接请求报文段”。</p><p>现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段。但是B收到此失效的连接请求报文段后，就误认为是A有发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。</p><p>由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样拜拜浪费了。</p><p>采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。</p><p><strong>另一种解释：</strong></p><p>这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题,  无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求,  而是为了满足&quot;在不可靠信道上可靠地传输信息&quot;这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了,  那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息,  对方一定能收到, 或者你不关心是否要保证对方收到你的消息,  那就能像UDP那样直接发送消息就可以了”。这可视为对“三次握手”目的的另一种解答思路。</p><h2 id="四次挥手关闭连接"><a class="markdownIt-Anchor" href="#四次挥手关闭连接"></a> 四次挥手关闭连接</h2><p><img src="/images/javawz/823435-20170323093037486-665986934.png" alt="img"></p><p>当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1,  服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。  A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack =  u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。</p><p><strong>l 为什么要等待呢？</strong></p><p>l 为了防止这种情况：A接到B的释放连接请求后会发送一个确认信息，但是如果这个确认信息丢了，也就是B没有收到确认释放连接，那么B就会重发一个释放连接请求，这时候A还处于TIME_WAIT状态，所以会再次发送一个确认信息。</p><p><strong>l Q2为什么TIME_WAIT 状态还需要等2*MSL秒之后才能返回到CLOSED 状态呢？</strong></p><p>l A2因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED 状态（就好比从SYN_SENT  状态到ESTABLISH  状态那样），但是我们必须假想网络是不可靠的，你无法保证你最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK  状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT 状态的作用就是用来重发可能丢失的ACK报文。</p><h2 id="11种状态"><a class="markdownIt-Anchor" href="#11种状态"></a> 11种状态</h2><p><img src="/images/javawz/823435-20170323093050424-1255848578.png" alt="img"></p><p>简单解释：</p><p><strong>l CLOSED</strong>：初始状态，表示TCP连接是“关闭着的”或“未打开的”。</p><p><strong>l LISTEN</strong> ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。</p><p><strong>l SYN_RCVD</strong> ：表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。</p><p><strong>l SYN_SENT</strong> ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。</p><p><strong>l ESTABLISHED</strong> ：表示TCP连接已经成功建立。</p><p><strong>l FIN_WAIT_1</strong> ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2  两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2  状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1  状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。</p><p><strong>l FIN_WAIT_2</strong> ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2  状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。</p><p><strong>l TIME_WAIT</strong> ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment  Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC  1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED  可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况）</p><p>l <strong>CLOSING</strong> ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING  状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。</p><p><strong>l CLOSE_WAIT</strong> ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。</p><p><strong>l LAST_ACK</strong> ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。</p><p><strong>CLOSING状态：</strong></p><p><img src="/images/javawz/823435-20170323093109565-59098561.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcp三次握手&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tcp三次握手&quot;&gt;&lt;/a&gt; TCP三次握手&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1624396879962.png&quot; alt=&quot;16243968
      
    
    </summary>
    
      <category term="计算机网络TCP/IP传输协议/网络抓包" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CTCP-IP%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP/IP协议模型</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/23/jiw003-TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/23/jiw003-TCP-IP协议/</id>
    <published>2021-06-22T20:51:49.000Z</published>
    <updated>2021-06-22T21:52:06.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcpip协议模型"><a class="markdownIt-Anchor" href="#tcpip协议模型"></a> TCP/IP协议模型</h1><p>tcp/ip协议5层</p><p>物理层</p><p>数据链接层</p><p>网络层</p><p>传输层</p><p>应用层</p><p><img src="/images/javawz/1624395408699.png" alt="1624395408699"></p><h3 id="数据封装和解封装过程"><a class="markdownIt-Anchor" href="#数据封装和解封装过程"></a> 数据封装和解封装过程</h3><p><img src="/images/javawz/20210303141707592.png" alt="数据封装过程"></p><p><img src="/images/javawz/20210303142309447.png" alt="数据解封装过程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcpip协议模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tcpip协议模型&quot;&gt;&lt;/a&gt; TCP/IP协议模型&lt;/h1&gt;
&lt;p&gt;tcp/ip协议5层&lt;/p&gt;
&lt;p&gt;物理层&lt;/p&gt;
&lt;p&gt;数据链接层&lt;/p&gt;
&lt;p&gt;网络层&lt;/p&gt;

      
    
    </summary>
    
      <category term="计算机网络TCP/IP传输协议/网络抓包" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CTCP-IP%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>jiw002-OSI的七层模型</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/23/jiw002-OSI%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/23/jiw002-OSI的七层模型/</id>
    <published>2021-06-22T20:41:52.000Z</published>
    <updated>2021-06-22T20:50:39.089Z</updated>
    
    <content type="html"><![CDATA[<p>网络工程师：</p><h3 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h3><p>1层，通信介质的信号到数字信号（二进制0101）</p><p>负责从电信号/光信号/电磁波信号转换到数字信号</p><p>或</p><p>从数字信号转换到电信号/光信号/电磁波信号</p><h3 id="数据链接层"><a class="markdownIt-Anchor" href="#数据链接层"></a> 数据链接层</h3><p>2层 局域网之间计算机通信  通过mac地址通信   arp协议</p><h3 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h3><p>3层 IP地址，路由（通过网络访问全世界）<br>公网的ip地址相当于门牌号（全世界网络互连） ：<br>私网的ip地址相当于房间号（局域网内部网络互连）</p><h3 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h3><p>4层 tcp/udp</p><p>tcp（可靠，速度慢）</p><p>udp （不可靠，速度快）</p><p>端口（让不同的应用程序，同时使用网络）</p><p>开发：</p><h3 id="会话层"><a class="markdownIt-Anchor" href="#会话层"></a> 会话层</h3><p>5层 控制发包的数据  会话层控制传输层，建立三次握手</p><h3 id="表示层"><a class="markdownIt-Anchor" href="#表示层"></a> 表示层</h3><p>6层 文件格式</p><h3 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h3><p>7层应用程序使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络工程师：&lt;/p&gt;
&lt;h3 id=&quot;物理层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#物理层&quot;&gt;&lt;/a&gt; 物理层&lt;/h3&gt;
&lt;p&gt;1层，通信介质的信号到数字信号（二进制0101）&lt;/p&gt;
&lt;p&gt;负责从电信号/光信号/电磁波信号转换到数字信号
      
    
    </summary>
    
      <category term="计算机网络TCP/IP传输协议/网络抓包" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CTCP-IP%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
</feed>
