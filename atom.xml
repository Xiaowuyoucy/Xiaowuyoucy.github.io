<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanChen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowuyoucy.github.io/"/>
  <updated>2021-06-11T13:33:42.761Z</updated>
  <id>https://xiaowuyoucy.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS模型的TCP/IP协议</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/08/WS002CS%E6%A8%A1%E5%9E%8B%E7%9A%84TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/08/WS002CS模型的TCP-IP协议/</id>
    <published>2021-06-08T14:48:18.000Z</published>
    <updated>2021-06-11T13:33:42.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs模型的tcpip协议"><a class="markdownIt-Anchor" href="#cs模型的tcpip协议"></a> CS模型的TCP/IP协议</h1><h3 id="创建服务端步骤"><a class="markdownIt-Anchor" href="#创建服务端步骤"></a> 创建服务端步骤</h3><ol><li>打开网络头文件</li><li>启动网络库</li><li>校验版本</li><li>创建SOCKET</li><li>绑定地址与端口</li><li>开始监听</li><li>接受连接</li><li>与客户端收发消息</li></ol><h3 id="网络头文件-网络库"><a class="markdownIt-Anchor" href="#网络头文件-网络库"></a> 网络头文件 网络库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;WinSock2.h&gt; </span><br><span class="line">#pragma comment(lib,“ws2_32.lib”)</span><br></pre></td></tr></table></figure><p>目前网络库有哪些版本:</p><p>1.0<br>1.1<br>2.0<br>2.1<br>2.2</p><h3 id="wsadata结构"><a class="markdownIt-Anchor" href="#wsadata结构"></a> WSADATA结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct WSAData &#123;</span><br><span class="line">        WORD                    wVersion;</span><br><span class="line">        WORD                    wHighVersion;</span><br><span class="line">#ifdef _WIN64</span><br><span class="line">        unsigned short          iMaxSockets;</span><br><span class="line">        unsigned short          iMaxUdpDg;</span><br><span class="line">        char FAR *              lpVendorInfo;</span><br><span class="line">        char                    szDescription[WSADESCRIPTION_LEN+1];</span><br><span class="line">        char                    szSystemStatus[WSASYS_STATUS_LEN+1];</span><br><span class="line">#else</span><br><span class="line">        char                    szDescription[WSADESCRIPTION_LEN+1];</span><br><span class="line">        char                    szSystemStatus[WSASYS_STATUS_LEN+1];</span><br><span class="line">        unsigned short          iMaxSockets;</span><br><span class="line">        unsigned short          iMaxUdpDg;</span><br><span class="line">        char FAR *              lpVendorInfo;</span><br><span class="line">#endif</span><br><span class="line">&#125; WSADATA;</span><br></pre></td></tr></table></figure><p><strong>wVersion</strong></p><p>Windows Sockets DLL期望调用者使用的Windows Sockets规范的版本。 高位<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82" target="_blank" rel="noopener">字节</a>存储副版本号, 低位字节存储主版本号，可以用WORD MAKEWORD(BYTE,BYTE ) 返回这个值,例如:MAKEWORD(1,1)</p><p><strong>wHighVersion</strong></p><p>这个DLL能够支持的Windows Sockets规范的最高版本。通常它与wVersion相同。</p><p><strong>szDescription</strong></p><p>以null结尾的ASCII字符串，Windows Sockets DLL将对Windows Sockets实现的描述拷贝到这个字符串中，包括制造商标识。文本（最多可以有256个字符）可以包含任何字符，但是要注意不能包含<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6" target="_blank" rel="noopener">控制字符</a>和<a href="https://baike.baidu.com/item/%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6" target="_blank" rel="noopener">格式字符</a>，应用程序对其最可能的使用方式是把它（可能被截断）显示在在状态信息中。</p><p><strong>szSystemStatus</strong></p><p>以null结尾的ASCII字符串，Windows Sockets DLL把有关的状态或配置信息拷贝到该字符串中。Windows Sockets DLL应当仅在这些信息对用户或支持人员有用时才使用它们，它不应被作为szDescription域的扩展。</p><p><strong>iMaxSockets</strong></p><p>单个进程能够打开的socket的最大数目。Windows  Sockets的实现能提供一个全局的socket池，可以为任何进程分配；或者它也可以为socket分配属于进程的资源。这个数字能够很好地反映Windows Sockets DLL或网络软件的配置方式。应用程序的编写者可以通过这个数字来粗略地指明Windows  Sockets的实现方式对应用程序是否有用。例如，X  Windows服务器在第一次启动的时候可能会检查iMaxSockets的值：如果这个值小于8，应用程序将显示一条错误信息，指示用户重新配置网络软件（这是一种可能要使用szSystemStatus文本的场合）。显然无法保证某个应用程序能够真正分配iMaxSockets个socket，因为可能有其它WindowsSockets应用程序正在使用。</p><p><strong>iMaxUdpDg</strong></p><p>Windows Sockets应用程序能够发送或接收的最大的用户数据包协议（UDP）的数据包大小，以<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82" target="_blank" rel="noopener">字节</a>为单位。如果实现方式没有限制，那么iMaxUdpDg为零。在Berkeley sockets的许多实现中，对于UDP数据包有个固有的限制（在必要时被分解），大小为8192字节。Windows  Sockets的实现可以对碎片重组缓冲区的分配作出限制。对于适合的WindowsSockets  实现，iMaxUdpDg的最小值为512。注意不管iMaxUdpDg的值是什么，都不推荐你发回一个比网络的最大传送单元（MTU）还大的<a href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E6%95%B0%E6%8D%AE%E5%8C%85" target="_blank" rel="noopener">广播数据包</a>。（Windows Sockets API 没有提供发现MTU的机制，但是它不会小于512个字节)。WinSock2.0版中已被废弃。</p><p><strong>lpVendorInfo</strong></p><p>指向销售商的数据结构的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">指针</a>。这个结构的定义（如果有）超出了<a href="https://baike.baidu.com/item/WindowsSockets%E8%A7%84%E8%8C%83" target="_blank" rel="noopener">WindowsSockets规范</a>的范围。WinSock2.0版中已被废弃。</p><h3 id="wsastartup打开网络库"><a class="markdownIt-Anchor" href="#wsastartup打开网络库"></a> WSAStartup打开网络库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int WSAStartup(</span><br><span class="line">WORD      wVersionRequired,</span><br><span class="line">LPWSADATA lpWSAData</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>⑴ wVersionRequested：一个WORD（双字节）型数值，在最高版本的Windows Sockets支持调用者使用，高阶字节指定小版本(修订本)号,低位字节指定主<a href="https://baike.baidu.com/item/%E7%89%88%E6%9C%AC/505574" target="_blank" rel="noopener">版本</a>号。</p><p>⑵lpWSAData 指向WSADATA数据结构的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">指针</a>，用来接收Windows Sockets [1] 实现的<a href="https://baike.baidu.com/item/%E7%BB%86%E8%8A%82/82732" target="_blank" rel="noopener">细节</a>。</p><p>WindowsSockets API提供的调用方可使用的最高版本号。高位<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82" target="_blank" rel="noopener">字节</a>指出副版本(修正)号，低位字节指明主版本号。</p><p>返回值:</p><p>0 成功。</p><p>否则返回下列的错误代码之一。注意通常依靠应用程序调用WSAGetLastError()机制获得的<a href="https://baike.baidu.com/item/%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">错误代码</a>是不能使用的，因为Windows Sockets DLL可能没有建立“上一错误”信息储存的客户数据区域。</p><p>错误代码:</p><p>WSASYSNOTREADY 代码数值为10091，指出网络通信依赖的网络子系统还没有准备好。</p><p>WSAVERNOTSUPPORTED 代码数值为10092，表示所需的Windows Sockets API的版本未由特定的Windows Sockets实现提供。</p><p>WSAEINVAL 代码数值为10022，说明应用程序指出的Windows Sockets版本不被该DLL支持。</p><p>WSAEINPROGRESS 代码数值为10036，说明一个阻塞的Winsock调用正在进行中。</p><p>WSAEPROCLIM 代码数值为10067，说明已经达到了Windows Sockets实现所支持的任务数量的极限。</p><p>WSAEFAULT 代码数值为10014，说明lpWSADATA参数是一个无效的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//MAKEWORD(主版本,副版本)   负责将2,2分配到wdVerSion低8位和高8位</span><br><span class="line">//wdVerSion低8位存储主版本,高8位存储副版本</span><br><span class="line">WORD wdVerSion = MAKEWORD(2, 2);</span><br><span class="line">WSADATA wdSockMsg;</span><br><span class="line"></span><br><span class="line">int nRes = WSAStartup(wdVerSion, &amp;wdSockMsg);</span><br><span class="line"></span><br><span class="line">if (0 != nRes)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;WSAStartup Error %d\n&quot;,nRes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="校验版本"><a class="markdownIt-Anchor" href="#校验版本"></a> 校验版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//校验网络库版本</span><br><span class="line">//HIBYTE取高8位,LOBYTE取高8位</span><br><span class="line">if (HIBYTE(wdSockMsg.wVersion) != 2 || LOBYTE(wdSockMsg.wVersion) != 2)</span><br><span class="line">&#123;</span><br><span class="line">//关闭网络库</span><br><span class="line">WSACleanup();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建socket套接字"><a class="markdownIt-Anchor" href="#创建socket套接字"></a> 创建SOCKET套接字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOCKET PASCAL FAR socket( int af, int type, int protocol);</span><br></pre></td></tr></table></figure><p>参数1</p><p>地址的类型</p><ul><li><p>比如大家联系我</p><ul><li>手机 15512345678</li><li>固定电话 7881234</li><li>ＱＱ 40916626xx</li><li>微信 c3_xin666</li><li>找上门  内蒙古 xxxxxxx</li><li>…</li></ul></li><li><p>AF_INET  2</p><ul><li>ipv4<ul><li>Internet协议版本4（IPv4）地址系列。<ul><li>192.168.1.103<ul><li>0.0.0.0  ~  255.255.255.255</li><li>点分十进制表示法</li></ul></li></ul></li><li>4字节 32位的地址<ul><li>个数快不够<ul><li>就是无符号int类型的范围  0 ~ 4294967295</li></ul></li></ul></li></ul></li></ul></li><li><p>AF_INET6  23</p><ul><li>ipv6<ul><li>Internet协议版本6（IPv6）地址系列。<ul><li>2001:0:3238:DFE1:63::FEFB</li></ul></li><li>16字节  128位的地址<ul><li>这个地球每寸一个IP</li></ul></li></ul></li></ul></li><li><p>AF_BTH  32</p><ul><li>蓝牙地址系列。<br>如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。<ul><li>6B:2D:BC:A9:8C:12</li></ul></li></ul></li><li><p>AF_IRDA  26</p><ul><li>红外数据协会（IrDA）地址系列。<br>仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。</li></ul></li><li><p>通信地址不仅仅只有IP地址</p><br></li></ul><p>参数2</p><ul><li><p>套接字类型</p><ul><li><p>SOCK_STREAM    1</p><ul><li>一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。</li></ul></li><li><p>SOCK_DGRAM    2</p><ul><li>一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。</li></ul></li><li><p>SOCK_RAW   3</p><ul><li>一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。</li></ul></li><li><p>SOCK_RDM   4</p><ul><li>一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。<br>仅在安装了可靠多播协议时才支持此类型值。</li></ul></li><li><p>SOCK_SEQPACKET   5</p><ul><li>一种套接字类型，提供基于数据报的伪流数据包。</li></ul><br></li></ul></li></ul><p>参数3</p><ul><li>协议的类型<ul><li>IPPROTO_TCP<ul><li>传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。</li></ul></li><li>IPPROTO_UDP<ul><li>用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。</li></ul></li><li>IPPROTO_ICMP<ul><li>Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。</li></ul></li><li>IPPROTO_IGMP<ul><li>Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。</li></ul></li><li>IPPROTO_RM<ul><li>用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。<br>仅在安装了可靠多播协议时才支持此协议值。</li></ul></li><li>整理下<ul><li>通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。</li><li>想要使用一个协议，咱们设备得支持才行，比如红外</li><li>参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型</li></ul></li></ul></li></ul><p>返回值</p><ul><li><p>成功返回可用的socket</p><ul><li><p>不用了就一定要销毁套接字</p><ul><li>closesocket(socketListen);</li></ul></li></ul></li><li><p>失败返回INVALID_SOCKET</p><ul><li><p>关闭网络库</p><ul><li>WSACleanup();</li></ul></li><li><p>可用WSAGetLasterror()返回错误码</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SOCKET sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line"><span class="comment">//如果创建套接字失败</span></span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sock)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"socket Error: %d\n"</span>,WSAGetLastError());</span><br><span class="line"><span class="comment">//关闭网络库</span></span><br><span class="line">WSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="绑定地址与端口"><a class="markdownIt-Anchor" href="#绑定地址与端口"></a> 绑定地址与端口</h3><p>给我们的socket绑定端口号与具体地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int PASCAL FAR bind( SOCKET sockaddr, const struct sockaddr FAR* my_addr,int addrlen);</span><br></pre></td></tr></table></figure><p>参数1<br>上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号</p><p>参数2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in sockAddress;</span><br><span class="line">sockAddress.sin_family = AF_INET; //地址类型</span><br><span class="line">sockAddress.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); //服务器ip地址</span><br><span class="line">sockAddress.sin_port = 12345;//服务器端口号</span><br><span class="line">(sockaddr*)&amp;sockAddress强转添加到参数2上</span><br></pre></td></tr></table></figure><p>参数3</p><p>参数2的类型大小</p><p>sizeof(sockAddress)</p><p>返回值<br>成功返回0<br>失败返回SOCKET_ERROR<br>具体错误码通过int WSAGetLastError(void);获得<br>closesocket(socketListen);<br>WSACleanup();</p><h5 id="htons"><a class="markdownIt-Anchor" href="#htons"></a> htons</h5><p>htons的功能：将一个无符号短整型的主机数值转换为网络<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F" target="_blank" rel="noopener">字节顺序</a>，即大尾顺序(big-endian)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u_short htons(u_short hostshort);</span><br></pre></td></tr></table></figure><p>而我们常用的 x86 CPU (intel, AMD) 电脑是 little-endian,也就是整数的低位<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82" target="_blank" rel="noopener">字节</a>放在内存的低字节处。举个例子吧。假定你的数据是0x1234,</p><p>在网络字节顺序里 这个数据放到内存中就应该显示成</p><p>addr addr+1</p><p>0x12 0x34</p><p>而在x86电脑上，数据0x1234放到内存中实际是：</p><p>addr addr+1</p><p>0x34 0x12</p><p>htons 的用处就是把实际主机内存中的整数存放方式调整成网络字节顺序。</p><h5 id="inet_addr"><a class="markdownIt-Anchor" href="#inet_addr"></a> inet_addr</h5><p>inet_addr是一个<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%87%BD%E6%95%B0/3504881" target="_blank" rel="noopener">计算机函数</a>，功能是将一个点分<a href="https://baike.baidu.com/item/%E5%8D%81%E8%BF%9B%E5%88%B6/6521392" target="_blank" rel="noopener">十进制</a>的IP转换成一个长整数型数（u_long类型）等同于inet_addr()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in_addr_t inet_addr(const char* strptr);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daddr.s_addr=inet_addr(&quot;192.168.1.60&quot;);</span><br></pre></td></tr></table></figure><h5 id="inet_ntoa"><a class="markdownIt-Anchor" href="#inet_ntoa"></a> inet_ntoa</h5><p>功能是将网络地址转换成“.”点隔的字符串格式。</p><p>网络字节序IP转化点分十进制IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *inet_ntoa (struct in_addr);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in si;</span><br><span class="line">//地址类型</span><br><span class="line">si.sin_family = AF_INET;</span><br><span class="line">//端口</span><br><span class="line">si.sin_port = htons(12345);</span><br><span class="line">//地址</span><br><span class="line">si.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line"></span><br><span class="line">if (SOCKET_ERROR == bind(sock, (const struct sockaddr *)&amp;si, sizeof(si)))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;bind Error: %d\n&quot;, WSAGetLastError());</span><br><span class="line">//关闭套接字</span><br><span class="line">closesocket(sock);</span><br><span class="line">//关闭网络库</span><br><span class="line">WSACleanup();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开始监听"><a class="markdownIt-Anchor" href="#开始监听"></a> 开始监听</h3><p>将套接字置于正在侦听传入连接的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int WSAAPI listen(</span><br><span class="line">  SOCKET s,</span><br><span class="line">  int    backlog</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="参数1"><a class="markdownIt-Anchor" href="#参数1"></a> 参数1</h5><p>​服务器端的socket，也就是socket函数创建的</p><h5 id="参数2"><a class="markdownIt-Anchor" href="#参数2"></a> 参数2</h5><p>​挂起连接队列的最大长度。<br>​我们一般填写这个参数<br>​SOMAXCONN<br>​作用是让系统自动选择最合适的个数<br>​不同的系统环境不一样，所以这个合适的数也都不一样</p><h5 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h5><h6 id="成功"><a class="markdownIt-Anchor" href="#成功"></a> 成功</h6><p>​返回0</p><h6 id="失败"><a class="markdownIt-Anchor" href="#失败"></a> 失败</h6><p>​SOCKET_ERROR<br>​具体错误码<br>​ WSAGetLastError()<br>​释放<br>​closesocket(socketListen);<br>​WSACleanup();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//开始监听</span><br><span class="line">if (SOCKET_ERROR == listen(sock, SOMAXCONN)) &#123;</span><br><span class="line">printf(&quot;listen Error: %d\n&quot;, WSAGetLastError());</span><br><span class="line">//关闭套接字</span><br><span class="line">closesocket(sock);</span><br><span class="line">//关闭网络库</span><br><span class="line">WSACleanup();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建客户端socket接受连接"><a class="markdownIt-Anchor" href="#创建客户端socket接受连接"></a> 创建客户端socket/接受连接</h3><p>作用<br>accept函数允许在套接字上进行传入连接尝试。<br>listen监听客户端来的链接，accept讲客户端的信息绑定到一个socket上，也就是给客户端创建一个socket,通过返回值返回给我们客户端的socket<br>一次只能创建一个，有几个客户端链接，就要调用几次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SOCKET WSAAPI accept(</span><br><span class="line">  SOCKET   s,//服务端socket</span><br><span class="line">  sockaddr *addr,//用来接收客户端地址和端口</span><br><span class="line">  int      *addrlen //参数2的长度</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个函数是阻塞的</p><p>参数2,参数3可以设置为NULL,不得到客户端信息,可以调用getpeername函数得到客户端信息</p><h5 id="返回值-2"><a class="markdownIt-Anchor" href="#返回值-2"></a> 返回值</h5><h6 id="成功-2"><a class="markdownIt-Anchor" href="#成功-2"></a> 成功</h6><p>​返回值就是给客户端包好的socket,与客户端通信就靠这个</p><h6 id="失败-2"><a class="markdownIt-Anchor" href="#失败-2"></a> 失败</h6><p>​返回INVALID_SOCKET ,用WSAGetLastError()得到错误码<br>​释放空间<br>​closesocket(socketListen);<br>​WSACleanup();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in sockClientAddr;</span><br><span class="line">int len = sizeof(sockClientAddr);</span><br><span class="line">printf(&quot;等待连接...\n&quot;);</span><br><span class="line">SOCKET sockClient = accept(sock, (struct sockaddr *)&amp;sockClientAddr,&amp;len);</span><br><span class="line"></span><br><span class="line">if (sockClient == INVALID_SOCKET) &#123;</span><br><span class="line">printf(&quot;accept Error: %d\n&quot;, WSAGetLastError());</span><br><span class="line">//关闭套接字</span><br><span class="line">closesocket(sock);</span><br><span class="line">//关闭网络库</span><br><span class="line">WSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过getpeername函数得到客户端信息"><a class="markdownIt-Anchor" href="#通过getpeername函数得到客户端信息"></a> 通过getpeername函数得到客户端信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getpeername(newSocket, (struct sockaddr*)&amp;sockClient, &amp;nLen);</span><br></pre></td></tr></table></figure><h4 id="getsockname函数得到本地服务器信息"><a class="markdownIt-Anchor" href="#getsockname函数得到本地服务器信息"></a> getsockname函数得到本地服务器信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getsockname(sSocket, (sockaddr*)&amp;addr, &amp;nLen);</span><br></pre></td></tr></table></figure><h3 id="与客户端收发消息"><a class="markdownIt-Anchor" href="#与客户端收发消息"></a> 与客户端收发消息</h3><h4 id="recv收消息"><a class="markdownIt-Anchor" href="#recv收消息"></a> recv收消息</h4><p>数据的接收都是由协议本身做的，也就是socket的底层做的，系统会有一段缓冲区，存储着接收到的数据。</p><p>咱们外边调用recv的作用，就是通过socket找到这个缓冲区，并把数据复制进咱们的参数2，复制参数3个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int recv(</span><br><span class="line">  SOCKET s, //客户端socket</span><br><span class="line">  char   *buf, //缓冲区</span><br><span class="line">  int    len, //缓冲区大小</span><br><span class="line">  int    flags  //正常写0,表示读完就删除</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="参数1-2"><a class="markdownIt-Anchor" href="#参数1-2"></a> 参数1</h5><p>​客户端的socket，每个客户端对应唯一的socket</p><h5 id="参数2-2"><a class="markdownIt-Anchor" href="#参数2-2"></a> 参数2</h5><p>​客户端消息的存储空间，也就是个字符数组<br>​这个一般1500字节<br>​网络传输得最大单元，1500字节，也就是客户端发过来得数据，一次最大就是1500字节，这是协议规定，这个数值也是根据很多情况，总结出来得最优值<br>​所以客户端最多一组来1500字节，咱们这头1500读一次，够够的了。</p><h5 id="参数3"><a class="markdownIt-Anchor" href="#参数3"></a> 参数3</h5><p>​想要读取得字节个数<br>​一般是参数2得字节数-1，把\0字符串结尾留出来</p><h5 id="参数4"><a class="markdownIt-Anchor" href="#参数4"></a> 参数4</h5><p>一般填0,表示读完就删</p><h6 id="msg_peek"><a class="markdownIt-Anchor" href="#msg_peek"></a> MSG_PEEK</h6><p>​窥视传入的数据。 数据将复制到缓冲区中，但不会从输入队列中删除。<br>​读出来的不删除<br>​这个东西是不建议被使用的<br>​第一、读数据不行<br>​第二、那就无法计数了</p><h6 id="msg_oob"><a class="markdownIt-Anchor" href="#msg_oob"></a> MSG_OOB</h6><p>​带外数据<br>​意义<br>​就是传输一段数据，在外带一个额外的特殊数据<br>​相当于小声BB<br>​实际<br>​就不建议被使用了<br>​1、TCP协议规范（RFC 793）中OOB的原始描述被“主机要求”规范取代（ RFC 1122），但仍有许多机器具有RFC 793 OOB实现。<br>​2、既然两种数据，那咱们就send两次，另一方recv两次就行了，何必搞得那么神神秘秘，浪费计算机精力</p><h6 id="msg_waitall"><a class="markdownIt-Anchor" href="#msg_waitall"></a> MSG_WAITALL</h6><p>​直到系统缓冲区字节数满足参数3所请求得字节数，才开始读取</p><h5 id="返回值-3"><a class="markdownIt-Anchor" href="#返回值-3"></a> 返回值</h5><h5 id="成功-3"><a class="markdownIt-Anchor" href="#成功-3"></a> 成功</h5><p>​返回0</p><h5 id="失败-3"><a class="markdownIt-Anchor" href="#失败-3"></a> 失败</h5><p>​SOCKET_ERROR<br>​具体错误码<br>​ WSAGetLastError()<br>​释放<br>​closesocket(socketListen);<br>​WSACleanup();</p><h3 id="send发送消息"><a class="markdownIt-Anchor" href="#send发送消息"></a> send发送消息</h3><p>向目标发送数据</p><p>本质<br>send函数将我们的数据复制黏贴进系统的协议发送缓冲区，计算机伺机发出去<br>最大传输单元是1500字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int WSAAPI send(</span><br><span class="line">  SOCKET     s,//客户端socket</span><br><span class="line">  const char *buf,//发送缓冲区</span><br><span class="line">  int        len,//发送长度</span><br><span class="line">  int        flags//一般写0</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="参数1-3"><a class="markdownIt-Anchor" href="#参数1-3"></a> 参数1</h5><p>​目标的socket，每个客户端对应唯一的socket</p><h5 id="参数2-3"><a class="markdownIt-Anchor" href="#参数2-3"></a> 参数2</h5><p>​给对方发送的字节串<br>​这个不要超过1500字节<br>​发送时候，协议要进行包装，加上协议信息，也叫协议头，或者叫包头，咱们在理论部分，会非常详细的介绍协议头，以及功能<br>​这个大小不同的协议不一样，链路层14字节，ip头20字节，tcp头20字节，数据结尾还要有状态确认，加起来也几十个字节，所以实际咱们的数据位，不能写1500个，要留出来，那就1024吧，或者最多1400，就差不多了<br>​懂这个大体原理就好<br>​<br>​当然大家这个不一定每次都是正好那么多字节，比如聊天，一句话就十个八个的汉字，别多于1400是最好的<br>​超过1500系统咋办？<br>​系统会分片处理<br>​比如2000个字节<br>​系统分成两个包<br>​1400 + 包头 == 1500<br>假设包头100字节<br>600 + 包头 == 700</p><p>​分两次发送出去<br>​结果<br>​1、系统要给咱们分包再打包，再发送， 客户端接收到了还得拆包，组合数据。从而增加了系统的工作，降低效率<br>​2、有的协议，就把分片后的二包直接丢了</p><h5 id="参数3-2"><a class="markdownIt-Anchor" href="#参数3-2"></a> 参数3</h5><p>​字节个数<br>​1400</p><h5 id="参数4-2"><a class="markdownIt-Anchor" href="#参数4-2"></a> 参数4</h5><p>​写0就行了<br>​其他<br>​MSG_OOB<br>​意义同recv<br>​就不用使用了<br>​带外数据<br>​意义<br>​就是传输一段数据，在外带一个额外的特殊数据<br>​相当于小声BB<br>​实际<br>​就不建议被使用了<br>​1、TCP协议规范（RFC 793）中OOB的原始描述被“主机要求”规范取代（ RFC 1122），但仍有许多机器具有RFC 793 OOB实现。<br>​2、既然两种数据，那咱们就send两次，另一方recv两次就行了，何必搞得那么神神秘秘，浪费计算机精力<br>​MSG_DONTROUTE<br>​指定数据不应受路由限制。 Windows套接字服务提供程序可以选择忽略此标志。</p><h5 id="返回值-4"><a class="markdownIt-Anchor" href="#返回值-4"></a> 返回值</h5><h6 id="成功-4"><a class="markdownIt-Anchor" href="#成功-4"></a> 成功</h6><p>返回写入的字节数</p><h6 id="执行失败"><a class="markdownIt-Anchor" href="#执行失败"></a> 执行失败</h6><p>返回SOCKET_ERROR<br>WSAGetLastError()得到错误码<br>根据错误码信息做相应处理<br>重启<br>等待<br>不用理会</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标记</span></span><br><span class="line">BOOL g_nFlag = TRUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//打开网络库</span></span><br><span class="line">WORD wdVersion = MAKEWORD(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = WSAStartup(wdVersion, &amp;wsaData);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//printf("外%d\n", WSAStartup(wdVersion, &amp;wsaData));</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> != WSAStartup(wdVersion,&amp;wsaData)) <span class="comment">// API </span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span> (<span class="string">"WSAStartup fail!"</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验版本</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> != HIBYTE(wsaData.wVersion) || <span class="number">1</span> != LOBYTE(wsaData.wVersion))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Version fail!"</span> );</span><br><span class="line"><span class="comment">//关闭库</span></span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个SOCKET 监听</span></span><br><span class="line">SOCKET socketListen = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == socketListen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"socket fail!"</span>);</span><br><span class="line"><span class="comment">//关闭库</span></span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定地址</span></span><br><span class="line">SOCKADDR_IN sockAddress;</span><br><span class="line">sockAddress.sin_family = AF_INET;</span><br><span class="line">sockAddress.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">sockAddress.sin_port = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == bind(socketListen,(struct sockaddr*)&amp;sockAddress,<span class="keyword">sizeof</span>(sockAddress)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"bind fail!"</span>);</span><br><span class="line"><span class="comment">//int nError = ::WSAGetLastError();</span></span><br><span class="line"><span class="comment">//关闭库</span></span><br><span class="line">closesocket(socketListen);</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始监听</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == listen(socketListen,<span class="number">2</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"listen fail!"</span>);</span><br><span class="line"><span class="comment">//关闭库</span></span><br><span class="line">closesocket(socketListen);</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受链接</span></span><br><span class="line">SOCKADDR_IN sockClient;</span><br><span class="line"><span class="keyword">int</span> nLen = <span class="keyword">sizeof</span>(sockClient);</span><br><span class="line"></span><br><span class="line">SOCKET newSocket;</span><br><span class="line">newSocket = accept(socketListen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//getsockname(socketListen, (struct sockaddr*)&amp;sockClient, &amp;nLen);</span></span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == newSocket)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"listen fail!"</span> );</span><br><span class="line"><span class="comment">//关闭库</span></span><br><span class="line">closesocket(socketListen);</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(g_nFlag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断客户端连接的集合中是否有需要接收的数据</span></span><br><span class="line"><span class="keyword">char</span> szRecvBuffer[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> szSendBuffer[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//遍历setClient集合，如果发现setClient中的某个</span></span><br><span class="line"><span class="keyword">int</span> nReturnValue = recv(newSocket, szRecvBuffer, <span class="keyword">sizeof</span>(szRecvBuffer)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nRes = WSAGetLastError();</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == nReturnValue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//客户端正常关闭   服务端释放Socket</span></span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (SOCKET_ERROR == nReturnValue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//网络中断  </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"客户端中断连接"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//接收到客户端消息 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Client Data : %s \n"</span>,szRecvBuffer);</span><br><span class="line"><span class="comment">//给客户回信</span></span><br><span class="line"><span class="comment">//scanf_s ("%s", szSendBuffer, 1024);</span></span><br><span class="line"><span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//send(newSocket, "repeat over", strlen(szSendBuffer)+1, 0);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭socket</span></span><br><span class="line">closesocket(socketListen);</span><br><span class="line">closesocket(newSocket);</span><br><span class="line"><span class="comment">//关闭网络库</span></span><br><span class="line">WSACleanup();</span><br><span class="line"></span><br><span class="line"><span class="comment">//system("pause");</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建客户端步骤"><a class="markdownIt-Anchor" href="#创建客户端步骤"></a> 创建客户端步骤</h3><ol><li>打开网络头文件</li><li>启动网络库</li><li>校验版本</li><li>创建SOCKET</li><li>链接到服务器</li><li>与服务端收发消息</li></ol><h3 id="链接到服务器"><a class="markdownIt-Anchor" href="#链接到服务器"></a> 链接到服务器</h3><p>链接服务器并把服务器信息与服务器socket绑定到一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int WSAAPI connect</span><br><span class="line">(</span><br><span class="line">  SOCKET         s,  //服务器socket</span><br><span class="line">  const sockaddr *name, //服务器Ip地址端口号结构体</span><br><span class="line">  int            namelen //参数2结构体大小</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="返回值-5"><a class="markdownIt-Anchor" href="#返回值-5"></a> 返回值</h5><h6 id="成功-5"><a class="markdownIt-Anchor" href="#成功-5"></a> 成功</h6><p>​返回0</p><h6 id="失败-4"><a class="markdownIt-Anchor" href="#失败-4"></a> 失败</h6><p>​返回 SOCKET_ERROR<br>​WSAGetLastError()得到错误码<br>​释放空间<br>​closesocket(socketListen);<br>​WSACleanup();</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WORD wdVersion = MAKEWORD(<span class="number">2</span>, <span class="number">2</span>); </span><br><span class="line">WSADATA wdScokMsg;</span><br><span class="line"><span class="keyword">int</span> nRes = WSAStartup(wdVersion, &amp;wdScokMsg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != nRes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (nRes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WSASYSNOTREADY:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"重启下电脑试试，或者检查网络库"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WSAVERNOTSUPPORTED:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请更新网络库"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WSAEINPROGRESS:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请重新启动"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WSAEPROCLIM:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请尝试关掉不必要的软件，以为当前网络运行提供充足资源"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验版本</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> != HIBYTE(wdScokMsg.wVersion) || <span class="number">2</span> != LOBYTE(wdScokMsg.wVersion))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明版本不对</span></span><br><span class="line"><span class="comment">//清理网络库</span></span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器socket</span></span><br><span class="line">SOCKET socketServer = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == socketServer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a = WSAGetLastError();</span><br><span class="line"><span class="comment">//清理网络库</span></span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接服务器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverMsg</span>;</span></span><br><span class="line">serverMsg.sin_family = AF_INET;</span><br><span class="line">serverMsg.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">serverMsg.sin_addr.S_un.S_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == connect(socketServer, (struct sockaddr*)&amp;serverMsg, <span class="keyword">sizeof</span>(serverMsg)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a = WSAGetLastError();</span><br><span class="line">closesocket(socketServer);</span><br><span class="line"><span class="comment">//清理网络库</span></span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1500</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//int res = recv(socketServer, buf, 50, 0);</span></span><br><span class="line"><span class="comment">//if (0 == res)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//printf("链接中断、客户端下线\n");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else if (SOCKET_ERROR == res)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">////出错了</span></span><br><span class="line"><span class="comment">//int a = WSAGetLastError();</span></span><br><span class="line"><span class="comment">////根据实际情况处理</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//printf("%d   %s\n", res, buf);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">'0'</span> == buf[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == send(socketServer, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//出错了</span></span><br><span class="line"><span class="keyword">int</span> a = WSAGetLastError();</span><br><span class="line"><span class="comment">//根据实际情况处理</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理网络库</span></span><br><span class="line">closesocket(socketServer);</span><br><span class="line">WSACleanup();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cs模型的tcpip协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs模型的tcpip协议&quot;&gt;&lt;/a&gt; CS模型的TCP/IP协议&lt;/h1&gt;
&lt;h3 id=&quot;创建服务端步骤&quot;&gt;&lt;a class=&quot;markdownIt-Anchor
      
    
    </summary>
    
      <category term="Windows网络编程" scheme="https://xiaowuyoucy.github.io/categories/Windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>画笔</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/08/pwcp015-%E7%94%BB%E7%AC%94/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/08/pwcp015-画笔/</id>
    <published>2021-06-08T04:52:49.000Z</published>
    <updated>2021-06-08T08:07:32.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="画笔"><a class="markdownIt-Anchor" href="#画笔"></a> 画笔</h1><h3 id="hpen创建画笔句柄变量"><a class="markdownIt-Anchor" href="#hpen创建画笔句柄变量"></a> HPEN创建画笔句柄变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HPEN hPen1;</span><br></pre></td></tr></table></figure><h3 id="createpen创建画笔"><a class="markdownIt-Anchor" href="#createpen创建画笔"></a> CreatePen创建画笔</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HPEN CreatePen(int nPenStyle, int nWidth, COLORREF crColor);</span><br></pre></td></tr></table></figure><p>nPenStyle ------ Long，指定画笔样式，可以是下述常数之一</p><p>PS_SOLID</p><p>画笔画出的是实线</p><p>PS_DASH</p><p>画笔画出的是虚线（nWidth必须不大于1）</p><p>PS_DOT</p><p>画笔画出的是点线（nWidth必须不大于1）</p><p>PS_DASHDOT</p><p>画笔画出的是点划线（nWidth必须不大于1）</p><p>PS_DASHDOTDOT</p><p>画笔画出的是点-点-划线（nWidth必须不大于1）</p><p>PS_NULL</p><p>画笔不能画图</p><p>PS_INSIDEFRAME</p><p>由椭圆、矩形、圆角矩形、饼图以及弦等生成的封闭对象框时，画线宽度向内扩展。如指定的准确RGB颜色不存在，就进行抖动处理</p><p>nWidth --------- Long，以逻辑单位表示的画笔的宽度</p><p>crColor -------- Long，画笔的RGB颜色</p><p>[返回值]</p><p>Long，如函数执行成功，就返回指向新画笔的一个句柄；否则返回零</p><p>[其它]</p><p>一旦不再需要画笔，记得用DeleteObject函数将其删除</p><h3 id="selectobject"><a class="markdownIt-Anchor" href="#selectobject"></a> SelectObject</h3><p>该函数选择一对象到指定的<a href="https://baike.baidu.com/item/%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%B8%8B%E6%96%87/6768144" target="_blank" rel="noopener">设备上下文</a>环境中，该新对象替换先前的相同类型的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGDIOBJ SelectObject(HDC hdc, HGDIOBJ hgdiobj)</span><br></pre></td></tr></table></figure><p>参数：</p><p>hdc：设备上下文环境的句柄。</p><p>hgdiobj：被选择的对象的句柄，该指定对象必须由如下的函数创建。</p><p><a href="https://baike.baidu.com/item/%E4%BD%8D%E5%9B%BE" target="_blank" rel="noopener">位图</a>：CreateBitmap, CreateBitmapIndirect, CreateCompatible Bitmap, <a href="https://baike.baidu.com/item/CreateDIBitmap" target="_blank" rel="noopener">CreateDIBitmap</a>, CreateDIBsection（只有内存<a href="https://baike.baidu.com/item/%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%B8%8B%E6%96%87" target="_blank" rel="noopener">设备上下文</a>环境可选择位图，并且在同一时刻只能一个设备上下文环境选择位图）。</p><p>画刷：<a href="https://baike.baidu.com/item/CreateBrushIndirect" target="_blank" rel="noopener">CreateBrushIndirect</a>, <a href="https://baike.baidu.com/item/CreateDIBPatternBrush" target="_blank" rel="noopener">CreateDIBPatternBrush</a>, <a href="https://baike.baidu.com/item/CreateDIBPatternBrushPt" target="_blank" rel="noopener">CreateDIBPatternBrushPt</a>, CreateHatchBrush, CreatePatternBrush, CreateSolidBrush。</p><p>字体：CreateFont, CreateFontIndirect。</p><p>笔：CreatePen, CreatePenIndirect。</p><p>区域：<a href="https://baike.baidu.com/item/CombineRgn" target="_blank" rel="noopener">CombineRgn</a>, <a href="https://baike.baidu.com/item/CreateEllipticRgn" target="_blank" rel="noopener">CreateEllipticRgn</a>, <a href="https://baike.baidu.com/item/CreateEllipticRgnIndirect" target="_blank" rel="noopener">CreateEllipticRgnIndirect</a>, <a href="https://baike.baidu.com/item/CreatePolygonRgn" target="_blank" rel="noopener">CreatePolygonRgn</a>, CreateRectRgn, <a href="https://baike.baidu.com/item/CreateRectRgnIndirect" target="_blank" rel="noopener">CreateRectRgnIndirect</a>。</p><p>返回值：如果选择对象不是区域并且函数执行成功，那么返回值是被取代的对象的句柄；如果选择对象是区域并且函数执行成功，返回如下一值:</p><p>SIMPLEREGION：区域由单个矩形组成；</p><p>COMPLEXREGION：区域由多个矩形组成;</p><p>NULLREGION：区域为空。</p><p>如果发生错误并且选择对象不是一个区域，那么返回值为NULL，否则返回HGDI_ERROR。</p><p>注释：该函数返回先前指定类型的选择对象，一个应用程序在它使用新对象进行绘制完成之后，应该用原始的缺省的对象替换新对象。</p><p>应用程序不能同时选择一个位图到多个<a href="https://baike.baidu.com/item/%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%B8%8B%E6%96%87" target="_blank" rel="noopener">设备上下文</a>环境中。</p><p>ICM：如果被选择的对象是画笔或笔，那么就执行颜色管理。</p><h3 id="getstockobject"><a class="markdownIt-Anchor" href="#getstockobject"></a> GetStockObject</h3><p>该函数检索预定义的备用笔、刷子、字体或者<a href="https://baike.baidu.com/item/%E8%B0%83%E8%89%B2%E6%9D%BF" target="_blank" rel="noopener">调色板</a>的句柄。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGDIOBJ GetStockObject(int fnObject)；</span><br></pre></td></tr></table></figure><p>fnObject：指定对象的类型，该参数可取如下值之一；</p><p>BLACK_BRUSH：黑色画刷；DKGRAY_BRUSH：暗灰色画刷；</p><p>DC_BRUSH：在<a href="https://baike.baidu.com/item/Windows98/5246326" target="_blank" rel="noopener">Windows98</a>,Windows NT 5.0和以后版本中为纯颜色画刷，缺省色为白色，可以用<a href="https://baike.baidu.com/item/SetDCBrushColor" target="_blank" rel="noopener">SetDCBrushColor</a>函数改变颜色，更多的信息参见以下的注释部分。</p><p>GRAY_BRUSH：灰色画刷笔；</p><p>HOLLOW_BRUSH：空画刷（相当于NULL_BRUSH）；</p><p>NULL_BRUSH：空画刷（相当于HOLLOW_BRUSH）；</p><p>LTGRAY_BRUSH：亮灰色画刷；</p><p>WHITE_BRUSH：白色画刷；</p><p>BLACK_PEN：黑色钢笔；</p><p>DC_PEN：在<a href="https://baike.baidu.com/item/Windows98/5246326" target="_blank" rel="noopener">Windows98</a>、Windows NT 5.0和以后版本中为纯色钢笔，缺省色为白色，使用<a href="https://baike.baidu.com/item/SetDCPenColor" target="_blank" rel="noopener">SetDCPenColor</a>函数可以改变色彩，更多的信息，参见下面的注释部分。</p><p>WHITE_PEN：白色钢笔；</p><p>ANSI_FIXED_FONT：在Windows中为固定间距（等宽）系统字体；</p><p>ANSI_VAR_FONT：在Windows中为变间距（比例间距）系统字体；</p><p>DEVICE_DEFAUCT_FONT：在WindowsNT中为设备相关字体；</p><p>DEFAULT_GUI_FONT：用户界面对象缺省字体，如菜单和对话框；</p><p>OEM_FIXED_FONT：<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%A7%8B%E8%AE%BE%E5%A4%87%E5%88%B6%E9%80%A0%E5%95%86" target="_blank" rel="noopener">原始设备制造商</a>（OEM）相关固定间距（等宽）字体；</p><p>SYSTEM_FONT：系统字体，在缺省情况下，系统使用系统字体绘制菜单，对话框控制和文本；</p><p>SYSTEM_FIXED_FONT：固定间距（等宽）系统字体，该对象仅提供给兼容16位Windows版本；</p><p>DEFAULT_PALETTE：缺省<a href="https://baike.baidu.com/item/%E8%B0%83%E8%89%B2%E6%9D%BF" target="_blank" rel="noopener">调色板</a>，该调色板由系统调色板中的静态色彩组成。</p><h5 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h5><p>如果成功，返回值标识申请的逻辑对象，如果失败，返回值为NULL。</p><h5 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h5><p>仅在CS_HREDRAW和CS_VREDRAW风格的窗口中使用DKGRAY_BRUSH、GRAY_BRUSH和LTGRAY_BRUSH对象。</p><p>如果在其他风格的窗口中使灰色画笔，可能导致在窗口移动或改变大小之后出现画笔模式错位现象，原始储存画笔不能被调整。</p><p>HOLLOW_BRUSH和NULL_BRUSH储存对象相等。</p><p>由DEFAULT_GUI_FONT储存对象使用的字体将改变。当想使用菜单、对话框和其他用户界面对象使用的字体时请使用此储存对象。</p><p>不必要通过调用<a href="https://baike.baidu.com/item/DeleteObject/6379900" target="_blank" rel="noopener">DeleteObject</a>函数来删除储存对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetStockObject(BLACK_PEN);</span><br></pre></td></tr></table></figure><h3 id="deleteobject删除对象句柄"><a class="markdownIt-Anchor" href="#deleteobject删除对象句柄"></a> DeleteObject删除对象句柄</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL DeleteObject(HGDIOBJ hObject)；</span><br></pre></td></tr></table></figure><p>hObject：逻辑笔、画笔、字体、<a href="https://baike.baidu.com/item/%E4%BD%8D%E5%9B%BE" target="_blank" rel="noopener">位图</a>、区域或者调色板的句柄。</p><p>返回值：成功，返回非零值；如果指定的句柄无效或者它已被选入<a href="https://baike.baidu.com/item/%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%B8%8B%E6%96%87" target="_blank" rel="noopener">设备上下文</a>环境，则返回值为零。</p><p>注释：当一个绘画对象（如笔或画笔）当前被选入一个设备上下文环境时不要删除该对象。当一个调色板画笔被删除时，与该画笔相关的位图并不被删除，该图必须单独地删除。</p><p>系统备用的画笔不可以DeleteObject</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画笔.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"画笔.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量: </span></span><br><span class="line">HINSTANCE hInst;                                <span class="comment">// 当前实例</span></span><br><span class="line">WCHAR szTitle[MAX_LOADSTRING];                  <span class="comment">// 标题栏文本</span></span><br><span class="line">WCHAR szWindowClass[MAX_LOADSTRING];            <span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明: </span></span><br><span class="line"><span class="function">ATOM                <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL                <span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK    <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK    <span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此放置代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局字符串</span></span><br><span class="line">    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">    LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">    MyRegisterClass(hInstance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行应用程序初始化: </span></span><br><span class="line">    <span class="keyword">if</span> (!InitInstance (hInstance, nCmdShow))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY));</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主消息循环: </span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">        &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的: 注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEXW wcex;</span><br><span class="line"></span><br><span class="line">    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">    wcex.style          = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wcex.lpfnWndProc    = WndProc;</span><br><span class="line">    wcex.cbClsExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.cbWndExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.hInstance      = hInstance;</span><br><span class="line">    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY));</span><br><span class="line">    wcex.hCursor        = LoadCursor(<span class="literal">nullptr</span>, IDC_ARROW);</span><br><span class="line">    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);</span><br><span class="line">    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_MY);</span><br><span class="line">    wcex.lpszClassName  = szWindowClass;</span><br><span class="line">    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RegisterClassExW(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数: InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目的: 保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line"></span><br><span class="line">   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,</span><br><span class="line">      CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ShowWindow(hWnd, nCmdShow);</span><br><span class="line">   UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:    处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND  - 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT    - 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY  - 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建画笔句柄变量</span></span><br><span class="line"><span class="keyword">static</span> HPEN hPen1, hPen2, hPen3,hOldPen;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cxClient, cyClient;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cyLine;</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">cxClient = LOWORD(lParam);</span><br><span class="line">cyClient = HIWORD(lParam);</span><br><span class="line">cyLine   = cyClient / <span class="number">8</span>;</span><br><span class="line"><span class="comment">//创建画笔句柄,除了PS_SOLID可以设置宽度,其他的都不可以设置宽度 CreatePen(, 宽度 ,)</span></span><br><span class="line">hPen1 = CreatePen(PS_SOLID,<span class="number">1</span>,RGB(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">hPen2 = CreatePen(PS_DASH, <span class="number">1</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">hPen3 = CreatePen(PS_DOT, <span class="number">1</span>, RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wmId = LOWORD(wParam);</span><br><span class="line">            <span class="comment">// 分析菜单选择: </span></span><br><span class="line">            <span class="keyword">switch</span> (wmId)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">                DestroyWindow(hWnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在此处添加使用 hdc 的任何绘图代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SelectObject 设置画笔</span></span><br><span class="line">hOldPen = (HPEN)SelectObject(hdc, hPen1);</span><br><span class="line"><span class="comment">//设置起点位置</span></span><br><span class="line">MoveToEx(hdc,<span class="number">0</span>,cyLine * <span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//从起点画到终点</span></span><br><span class="line">LineTo(hdc,cxClient, cyLine * <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">SelectObject(hdc, hPen2);</span><br><span class="line">MoveToEx(hdc, <span class="number">0</span>, cyLine * <span class="number">2</span>, <span class="literal">NULL</span>);</span><br><span class="line">LineTo(hdc, cxClient, cyLine * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">SelectObject(hdc, hPen3);</span><br><span class="line">MoveToEx(hdc, <span class="number">0</span>, cyLine * <span class="number">3</span>, <span class="literal">NULL</span>);</span><br><span class="line">LineTo(hdc, cxClient, cyLine * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">SelectObject(hdc, CreatePen(PS_DASHDOT,<span class="number">1</span>,RGB(<span class="number">20</span>,<span class="number">25</span>,<span class="number">255</span>)));</span><br><span class="line">MoveToEx(hdc, <span class="number">0</span>, cyLine * <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">LineTo(hdc, cxClient, cyLine * <span class="number">4</span>);</span><br><span class="line"><span class="comment">//DeleteObject删除旧画笔句柄</span></span><br><span class="line">DeleteObject(SelectObject(hdc, CreatePen(PS_DASHDOTDOT, <span class="number">1</span>, RGB(<span class="number">20</span>, <span class="number">25</span>, <span class="number">255</span>))));</span><br><span class="line">MoveToEx(hdc, <span class="number">0</span>, cyLine * <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line">LineTo(hdc, cxClient, cyLine * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//系统备用的画笔不可以DeleteObject</span></span><br><span class="line"><span class="comment">//GetStockObject获取系统备用对象,获取备用画笔句柄</span></span><br><span class="line">DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN) ));</span><br><span class="line">MoveToEx(hdc, <span class="number">0</span>, cyLine * <span class="number">6</span>, <span class="literal">NULL</span>);</span><br><span class="line">LineTo(hdc, cxClient, cyLine * <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">SelectObject(hdc,hOldPen);</span><br><span class="line">DeleteObject(hPen1);</span><br><span class="line">DeleteObject(hPen2);</span><br><span class="line">DeleteObject(hPen3);</span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">        &#123;</span><br><span class="line">            EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">            <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;画笔&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#画笔&quot;&gt;&lt;/a&gt; 画笔&lt;/h1&gt;
&lt;h3 id=&quot;hpen创建画笔句柄变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hpen创建画笔句柄变量&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>贝塞尔曲线</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/07/pwcp014-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/07/pwcp014-贝塞尔曲线/</id>
    <published>2021-06-07T13:26:23.000Z</published>
    <updated>2021-06-08T05:11:21.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贝塞尔曲线"><a class="markdownIt-Anchor" href="#贝塞尔曲线"></a> 贝塞尔曲线</h1><h3 id="polybezier"><a class="markdownIt-Anchor" href="#polybezier"></a> PolyBezier</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL PolyBezier(HDC hdc, CONST POINT *lppt, DWORD cPoints);</span><br></pre></td></tr></table></figure><p>● 参数</p><p>hdc：指定的设备环境句柄。</p><p>lppt：POINT结构<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">数组</a>的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">指针</a>，包括了<code>样条端点和控制点的坐标，其顺序是起点的坐标、起点的控制点的坐标、终点的控制点的坐标和终点的坐标</code>。</p><p>cPoints：指明<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">数组</a>中的点的个数。</p><p>● 返回值</p><p>若<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">函数调用</a>成功，则返回非零，否则返回零。</p><h3 id="polybezierto"><a class="markdownIt-Anchor" href="#polybezierto"></a> PolyBezierTo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL PolyBezierTo(</span><br><span class="line">HDChdc,</span><br><span class="line">CONST POINT*lppt,</span><br><span class="line">DWORD cCount</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hdc ------------ Long，要在其中绘图的设备场景</p><p>lppt ----------- POINTAPI，指定一个POINTAPI结构<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">数组</a>。其中的第一个结构指定了起点。剩下的点三个一组——包括两个控件点和一个终点.</p><p>cCount---------- lppt<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">数组</a>的总点数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//按下鼠标右键消息</span><br><span class="line">WM_RBUTTONDOWN:</span><br><span class="line">//按下鼠标左键消息</span><br><span class="line">WM_LBUTTONDOWN:</span><br><span class="line">//移动鼠标消息</span><br><span class="line">WM_MOUSEMOVE:</span><br><span class="line"></span><br><span class="line">wParam参数是按下了哪个键</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贝塞尔曲线.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"贝塞尔曲线.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量: </span></span><br><span class="line">HINSTANCE hInst;                                <span class="comment">// 当前实例</span></span><br><span class="line">WCHAR szTitle[MAX_LOADSTRING];                  <span class="comment">// 标题栏文本</span></span><br><span class="line">WCHAR szWindowClass[MAX_LOADSTRING];            <span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明: </span></span><br><span class="line"><span class="function">ATOM                <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL                <span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK    <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK    <span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此放置代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局字符串</span></span><br><span class="line">    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">    LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">    MyRegisterClass(hInstance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行应用程序初始化: </span></span><br><span class="line">    <span class="keyword">if</span> (!InitInstance (hInstance, nCmdShow))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY));</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主消息循环: </span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">        &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的: 注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEXW wcex;</span><br><span class="line"></span><br><span class="line">    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">    wcex.style          = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wcex.lpfnWndProc    = WndProc;</span><br><span class="line">    wcex.cbClsExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.cbWndExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.hInstance      = hInstance;</span><br><span class="line">    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY));</span><br><span class="line">    wcex.hCursor        = LoadCursor(<span class="literal">nullptr</span>, IDC_ARROW);</span><br><span class="line">    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);</span><br><span class="line">    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_MY);</span><br><span class="line">    wcex.lpszClassName  = szWindowClass;</span><br><span class="line">    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RegisterClassExW(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数: InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目的: 保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line"></span><br><span class="line">   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,</span><br><span class="line">      CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ShowWindow(hWnd, nCmdShow);</span><br><span class="line">   UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:    处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND  - 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT    - 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY  - 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawBezier</span><span class="params">(HDC hdc,POINT apt[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PolyBezier(hdc,apt,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">MoveToEx(hdc,apt[<span class="number">0</span>].x, apt[<span class="number">0</span>].y,<span class="literal">NULL</span>);</span><br><span class="line">LineTo(hdc, apt[<span class="number">1</span>].x, apt[<span class="number">1</span>].y);</span><br><span class="line"></span><br><span class="line">MoveToEx(hdc, apt[<span class="number">3</span>].x, apt[<span class="number">3</span>].y, <span class="literal">NULL</span>);</span><br><span class="line">LineTo(hdc, apt[<span class="number">2</span>].x, apt[<span class="number">2</span>].y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawBezier2</span><span class="params">(HDC hdc, POINT apt[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MoveToEx(hdc, apt[<span class="number">0</span>].x, apt[<span class="number">0</span>].y, <span class="literal">NULL</span>);</span><br><span class="line">PolyBezierTo(hdc, apt + <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">MoveToEx(hdc, apt[<span class="number">0</span>].x, apt[<span class="number">0</span>].y, <span class="literal">NULL</span>);</span><br><span class="line">LineTo(hdc, apt[<span class="number">1</span>].x, apt[<span class="number">1</span>].y);</span><br><span class="line"></span><br><span class="line">MoveToEx(hdc, apt[<span class="number">3</span>].x, apt[<span class="number">3</span>].y, <span class="literal">NULL</span>);</span><br><span class="line">LineTo(hdc, apt[<span class="number">2</span>].x, apt[<span class="number">2</span>].y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> POINT apt[<span class="number">4</span>];</span><br><span class="line">HDC hdc;</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line"><span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line"><span class="keyword">if</span> (wParam &amp; MK_RBUTTON || wParam &amp; MK_LBUTTON )</span><br><span class="line">&#123;</span><br><span class="line">hdc = GetDC(hWnd);</span><br><span class="line">            <span class="comment">//用白色画笔还原</span></span><br><span class="line">SelectObject(hdc,GetStockObject(WHITE_PEN));</span><br><span class="line">DrawBezier(hdc, apt);</span><br><span class="line"><span class="comment">//如果按下鼠标左键</span></span><br><span class="line"><span class="keyword">if</span> (wParam &amp; MK_LBUTTON) &#123;</span><br><span class="line">apt[<span class="number">1</span>].x = LOWORD(lParam);</span><br><span class="line">apt[<span class="number">1</span>].y = HIWORD(lParam);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//如果按下鼠标右键</span></span><br><span class="line"><span class="keyword">if</span> (wParam &amp; MK_RBUTTON) &#123;</span><br><span class="line">apt[<span class="number">2</span>].x = LOWORD(lParam);</span><br><span class="line">apt[<span class="number">2</span>].y = HIWORD(lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用黑色画笔画</span></span><br><span class="line">SelectObject(hdc, GetStockObject(BLACK_PEN));</span><br><span class="line">DrawBezier(hdc, apt);</span><br><span class="line"><span class="comment">//DrawBezier2(hdc, apt);</span></span><br><span class="line">ReleaseDC(hWnd,hdc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">            <span class="comment">//设置起点,起点控点,终点控点,终点</span></span><br><span class="line">apt[<span class="number">0</span>].x = LOWORD(lParam) / <span class="number">5</span>;</span><br><span class="line">apt[<span class="number">0</span>].y = HIWORD(lParam)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">apt[<span class="number">1</span>].x = <span class="number">0</span>;</span><br><span class="line">apt[<span class="number">1</span>].y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">apt[<span class="number">2</span>].x = LOWORD(lParam) * <span class="number">4</span> / <span class="number">5</span>;</span><br><span class="line">apt[<span class="number">2</span>].y = HIWORD(lParam)/<span class="number">2</span> - <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">apt[<span class="number">3</span>].x = LOWORD(lParam) * <span class="number">4</span>/ <span class="number">5</span>;</span><br><span class="line">apt[<span class="number">3</span>].y = HIWORD(lParam)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wmId = LOWORD(wParam);</span><br><span class="line">            <span class="comment">// 分析菜单选择: </span></span><br><span class="line">            <span class="keyword">switch</span> (wmId)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">                DestroyWindow(hWnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在此处添加使用 hdc 的任何绘图代码...</span></span><br><span class="line">DrawBezier(hdc,apt);</span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">        &#123;</span><br><span class="line">            EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">            <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../themes/pure/source/images/javawz/1623079557682.png" alt="1623079557682"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;贝塞尔曲线&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#贝塞尔曲线&quot;&gt;&lt;/a&gt; 贝塞尔曲线&lt;/h1&gt;
&lt;h3 id=&quot;polybezier&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#polybezier
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>边框绘制函数</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/07/pwcp013-%E8%BE%B9%E6%A1%86%E7%BB%98%E5%88%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/07/pwcp013-边框绘制函数/</id>
    <published>2021-06-07T12:08:10.000Z</published>
    <updated>2021-06-07T13:06:27.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="边框绘制函数"><a class="markdownIt-Anchor" href="#边框绘制函数"></a> 边框绘制函数</h1><h3 id="rectangle矩形"><a class="markdownIt-Anchor" href="#rectangle矩形"></a> Rectangle矩形</h3><p>使用该函数画一个矩形，可以用当前的画笔画矩形轮廓，用当前画刷进行填充。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL Rectangle(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect)；</span><br></pre></td></tr></table></figure><p>hdc：设备环境句柄。</p><p>nLeftRect：指定矩形左上角的逻辑X坐标。</p><p>nTopRect：指定矩形左上角的逻辑Y坐标。</p><p>nRightRect：指定矩形右下角的逻辑X坐标。</p><p>nBottomRect：指定矩形右下角的逻辑Y坐标。</p><p>返回值：如果<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">函数调用</a>成功，返回值非零，否则返回值为0。</p><p>Windows NT：若想获得更多错误信息，请调用GetLastError函数。</p><p>备注：此函数不使用和改变当前位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rectangle(hdc,200,50,600,400);</span><br></pre></td></tr></table></figure><h3 id="ellipse画圆或椭圆"><a class="markdownIt-Anchor" href="#ellipse画圆或椭圆"></a> Ellipse画圆或椭圆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL Ellipse(HDC hdc,</span><br><span class="line">int nLeftRect,</span><br><span class="line">int nTopRect,</span><br><span class="line">int nRightRect,</span><br><span class="line">int nBottomRect</span><br><span class="line">)；</span><br></pre></td></tr></table></figure><p>hdc：设备环境句柄。</p><p>nLeftRect：指定限定矩形左上角的X坐标。</p><p>nTopRect：指定限定矩形左上角的Y坐标。</p><p>nRightRect：指定限定矩形右下角的X坐标。</p><p>nBottomRect：指定限定矩形右下角的Y坐标。</p><p>如果<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">函数调用</a>成功，返回值非零；如果函数调用失败，返回值是0。</p><p>Windows NT：若想获得更多<a href="https://baike.baidu.com/item/%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF" target="_blank" rel="noopener">错误信息</a>，请调用GetLastError函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ellipse(hdc, 200, 50, 600, 400);</span><br></pre></td></tr></table></figure><h3 id="roundrect带圆角的矩形"><a class="markdownIt-Anchor" href="#roundrect带圆角的矩形"></a> RoundRect带圆角的矩形</h3><p>该函数画一个带圆角的矩形，此矩形由当前画笔画轮廓，由当前画刷填充。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL RoundRect(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nWidth, int nHeight)；</span><br></pre></td></tr></table></figure><p>参数：</p><p>hdc：设备环境句柄。</p><p>nLeftRect：指定矩形左上角的X坐标。</p><p>nTopRect：指定矩形左上角的Y坐标。</p><p>nRightRect：指定矩形右下角的X坐标。</p><p>nbottomRect：指定矩形右下角的Y坐标。</p><p>nWidth：指定用来画圆角的椭圆的宽。</p><p>nHeight：指定用来画圆角的椭圆的高。</p><p>返回值：如果<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">函数调用</a>成功，则返回值非空，否则返回值是0。</p><p>Windows NT：若想获得更多的错误信息，请调用GetLastError函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RoundRect(hdc, 700, 50, 1100, 400,100,100);</span><br></pre></td></tr></table></figure><h3 id="arc画圆弧"><a class="markdownIt-Anchor" href="#arc画圆弧"></a> ARC画圆弧</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BOOL Arc(</span><br><span class="line">HDC hdc,</span><br><span class="line">int xLeft,</span><br><span class="line">int yTop,</span><br><span class="line">int xRight,</span><br><span class="line">int yBottom,</span><br><span class="line">int XStart,</span><br><span class="line">int YStart,</span><br><span class="line">int XEnd,</span><br><span class="line">int YEnd);</span><br></pre></td></tr></table></figure><p><em>hdc</em> 绘画的窗口句柄</p><p>xLeft和nyTopt指定外接矩形左上角坐标</p><p>xRight和yBottom指定外接矩形右下角坐标</p><p>xStart和yStart指定圆弧开始坐标</p><p>xEnd和nyEnd指定圆弧结束坐标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arc(hdc, 850, 500, 1000, 650, 20, 600, 1200, 400);</span><br></pre></td></tr></table></figure><h3 id="chord画弦"><a class="markdownIt-Anchor" href="#chord画弦"></a> Chord画弦</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL Chord(</span><br><span class="line">  DC: HDC;                                &#123;设备环境句柄&#125;</span><br><span class="line">  int X1, Y1, X2, Y2, X3, Y3, X4, Y4 ; &#123;四个坐标点&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参数表</p><p>X1,Y1 ---------- Long，指定围绕椭圆的一个矩形的左上角位置</p><p>X2,Y2 ---------- Long，指定围绕椭圆的一个矩形的右下角位置</p><p>X3,Y3 ---------- Long，指定与椭圆相交的一条线的一个点</p><p>X4,Y4 ---------- Long，指定与椭圆相交的一条线的另一个点</p><p>返回值</p><p>Long，非零表示成功，零表示失败。会设置<a href="https://baike.baidu.com/item/GetLastError/4278820" target="_blank" rel="noopener">GetLastError</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chord(hdc, 450,500,800,850, 20, 600, 1200, 400);</span><br></pre></td></tr></table></figure><h3 id="pie画圆饼"><a class="markdownIt-Anchor" href="#pie画圆饼"></a> Pie画圆饼</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL Pie(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nXRadial1, int nYRadial1, int nXRadial2, int nYRadial2)；</span><br></pre></td></tr></table></figure><p>hdc：设备环境句柄。</p><p>nLeftRect：指定限定矩形左上角的X坐标。</p><p>nTopRect：指定限定矩形左上角的Y坐标。</p><p>nRigthRect：指定限定矩形右下角的X坐标。</p><p>nBottomRect：指定限定矩形右下角的Y坐标。</p><p>nXRadial1：指定第一条半径的端点的X坐标。</p><p>nYRadial1：指定第一条半径的端点的Y坐标。</p><p>nXRadial2：指定第二条半径的端点的X坐标。</p><p>nYRadial2：指定第二条半径的端点的Y坐标。</p><p>返回值：如果<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">函数调用</a>成功，返回值非零；如果函数调用失败，返回值是0。</p><p>Windows：要得到更多的错误信息，调用GetLastError。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pie(hdc,50,500,400,850,500,0,50,650);</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边框绘制函数.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"边框绘制函数.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量: </span></span><br><span class="line">HINSTANCE hInst;                                <span class="comment">// 当前实例</span></span><br><span class="line">WCHAR szTitle[MAX_LOADSTRING];                  <span class="comment">// 标题栏文本</span></span><br><span class="line">WCHAR szWindowClass[MAX_LOADSTRING];            <span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明: </span></span><br><span class="line"><span class="function">ATOM                <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL                <span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK    <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK    <span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此放置代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局字符串</span></span><br><span class="line">    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">    LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">    MyRegisterClass(hInstance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行应用程序初始化: </span></span><br><span class="line">    <span class="keyword">if</span> (!InitInstance (hInstance, nCmdShow))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY));</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主消息循环: </span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">        &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的: 注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEXW wcex;</span><br><span class="line"></span><br><span class="line">    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">    wcex.style          = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wcex.lpfnWndProc    = WndProc;</span><br><span class="line">    wcex.cbClsExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.cbWndExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.hInstance      = hInstance;</span><br><span class="line">    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY));</span><br><span class="line">    wcex.hCursor        = LoadCursor(<span class="literal">nullptr</span>, IDC_ARROW);</span><br><span class="line">    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);</span><br><span class="line">    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_MY);</span><br><span class="line">    wcex.lpszClassName  = szWindowClass;</span><br><span class="line">    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RegisterClassExW(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数: InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目的: 保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line"></span><br><span class="line">   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW ,</span><br><span class="line">     <span class="number">0</span>, <span class="number">0</span>, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ShowWindow(hWnd, nCmdShow);</span><br><span class="line">   UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:    处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND  - 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT    - 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY  - 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wmId = LOWORD(wParam);</span><br><span class="line">            <span class="comment">// 分析菜单选择: </span></span><br><span class="line">            <span class="keyword">switch</span> (wmId)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">                DestroyWindow(hWnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在此处添加使用 hdc 的任何绘图代码...</span></span><br><span class="line"><span class="comment">//画矩形</span></span><br><span class="line">Rectangle(hdc,<span class="number">200</span>,<span class="number">50</span>,<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line"><span class="comment">//画椭圆或正圆</span></span><br><span class="line">Ellipse(hdc, <span class="number">200</span>, <span class="number">50</span>, <span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"><span class="comment">//画带圆角的矩形</span></span><br><span class="line">RoundRect(hdc, <span class="number">700</span>, <span class="number">50</span>, <span class="number">1100</span>, <span class="number">400</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//画弦</span></span><br><span class="line">Chord(hdc, <span class="number">450</span>,<span class="number">500</span>,<span class="number">800</span>,<span class="number">850</span>, <span class="number">20</span>, <span class="number">600</span>, <span class="number">1200</span>, <span class="number">400</span>);</span><br><span class="line"><span class="comment">//画弧</span></span><br><span class="line">Arc(hdc, <span class="number">850</span>, <span class="number">500</span>, <span class="number">1000</span>, <span class="number">650</span>, <span class="number">20</span>, <span class="number">600</span>, <span class="number">1200</span>, <span class="number">400</span>);</span><br><span class="line"><span class="comment">//画圆饼</span></span><br><span class="line">Pie(hdc,<span class="number">50</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">850</span>,<span class="number">500</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">650</span>);</span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">        &#123;</span><br><span class="line">            EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">            <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;边框绘制函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#边框绘制函数&quot;&gt;&lt;/a&gt; 边框绘制函数&lt;/h1&gt;
&lt;h3 id=&quot;rectangle矩形&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rectan
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>正弦波</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/07/pwcp012-%E6%AD%A3%E5%BC%A6%E6%B3%A2/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/07/pwcp012-正弦波/</id>
    <published>2021-06-07T10:49:41.000Z</published>
    <updated>2021-06-07T11:12:28.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正弦波"><a class="markdownIt-Anchor" href="#正弦波"></a> 正弦波</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正弦波.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"正弦波.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"><span class="comment">//点的数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 1000</span></span><br><span class="line"><span class="comment">//波的数量10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWOPI (10 * 3.14159265)</span></span><br><span class="line"><span class="comment">// 全局变量: </span></span><br><span class="line">HINSTANCE hInst;                                <span class="comment">// 当前实例</span></span><br><span class="line">WCHAR szTitle[MAX_LOADSTRING];                  <span class="comment">// 标题栏文本</span></span><br><span class="line">WCHAR szWindowClass[MAX_LOADSTRING];            <span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明: </span></span><br><span class="line"><span class="function">ATOM                <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL                <span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK    <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK    <span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此放置代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局字符串</span></span><br><span class="line">    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">    LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">    MyRegisterClass(hInstance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行应用程序初始化: </span></span><br><span class="line">    <span class="keyword">if</span> (!InitInstance (hInstance, nCmdShow))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY));</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主消息循环: </span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">        &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的: 注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEXW wcex;</span><br><span class="line"></span><br><span class="line">    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">    wcex.style          = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wcex.lpfnWndProc    = WndProc;</span><br><span class="line">    wcex.cbClsExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.cbWndExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.hInstance      = hInstance;</span><br><span class="line">    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY));</span><br><span class="line">    wcex.hCursor        = LoadCursor(<span class="literal">nullptr</span>, IDC_ARROW);</span><br><span class="line">    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);</span><br><span class="line">wcex.lpszMenuName= <span class="literal">NULL</span>;<span class="comment">// MAKEINTRESOURCEW(IDC_MY);</span></span><br><span class="line">    wcex.lpszClassName  = szWindowClass;</span><br><span class="line">    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RegisterClassExW(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数: InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目的: 保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line"></span><br><span class="line">   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,</span><br><span class="line">      CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ShowWindow(hWnd, nCmdShow);</span><br><span class="line">   UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:    处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND  - 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT    - 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY  - 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cxClient, cyClient;</span><br><span class="line">POINT apt[NUM];</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line">cxClient = LOWORD(lParam);</span><br><span class="line">cyClient = HIWORD(lParam);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wmId = LOWORD(wParam);</span><br><span class="line">            <span class="comment">// 分析菜单选择: </span></span><br><span class="line">            <span class="keyword">switch</span> (wmId)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">                DestroyWindow(hWnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">MoveToEx(hdc,<span class="number">0</span>,cyClient / <span class="number">2</span>,<span class="literal">NULL</span>);</span><br><span class="line">LineTo(hdc,cxClient,cyClient / <span class="number">2</span>);</span><br><span class="line"><span class="comment">//将正弦波点分成NUM份</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">apt[i].x = i * cxClient / NUM;</span><br><span class="line">apt[i].y = (<span class="keyword">int</span>) cyClient/<span class="number">2</span> *(<span class="number">1</span> - <span class="built_in">sin</span>(i * TWOPI/NUM));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//连接点</span></span><br><span class="line">Polyline(hdc,apt,NUM);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在此处添加使用 hdc 的任何绘图代码...</span></span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">        &#123;</span><br><span class="line">            EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">            <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正弦波&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#正弦波&quot;&gt;&lt;/a&gt; 正弦波&lt;/h1&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>画直线</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/07/pwcp011-%E7%94%BB%E7%9B%B4%E7%BA%BF/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/07/pwcp011-画直线/</id>
    <published>2021-06-07T09:32:12.000Z</published>
    <updated>2021-06-07T09:51:03.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="画直线"><a class="markdownIt-Anchor" href="#画直线"></a> 画直线</h1><h3 id="point坐标结构类型"><a class="markdownIt-Anchor" href="#point坐标结构类型"></a> POINT坐标结构类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagPOINT</span><br><span class="line">&#123;</span><br><span class="line">LONG  x;</span><br><span class="line">LONG  y;</span><br><span class="line">&#125; POINT, *PPOINT, NEAR *NPPOINT, FAR *LPPOINT;</span><br></pre></td></tr></table></figure><h3 id="movetoex设置当前画笔位置"><a class="markdownIt-Anchor" href="#movetoex设置当前画笔位置"></a> MoveToEx设置当前画笔位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WINGDIAPI BOOL WINAPI MoveToEx(</span><br><span class="line">HDC hdc,</span><br><span class="line">int X,</span><br><span class="line">int Y,</span><br><span class="line">LPPOINT lpPoint</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>HDC hdc：传入参数，<a href="https://baike.baidu.com/item/%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%B8%8B%E6%96%87" target="_blank" rel="noopener">设备上下文</a>句柄。</p><p>int X：传入参数：新位置的X坐标。</p><p>int Y：传入参数：新位置的Y坐标。</p><p>LPPOINT lpPoint：传出参数：一个指向POINT结构的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">指针</a>，用来存放上一个点的位置，若此参数为NULL，则不保存上一个点的位置</p><p>返回值：</p><p>返回TRUE代表移动成功，FALSE代表失败，用GetLastError获得更具体的错误信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoveToEx(hdc, 20, 20, NULL);</span><br></pre></td></tr></table></figure><h3 id="lineto从画笔当前位置画到终点位置"><a class="markdownIt-Anchor" href="#lineto从画笔当前位置画到终点位置"></a> LineTo从画笔当前位置画到终点位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINGDIAPI BOOL WINAPI LineTo(HDChdc,intX,intY,);</span><br></pre></td></tr></table></figure><p>hdc:设备场景句柄</p><p>X:线段终点X坐标位置，采用逻辑坐标表示。这个点不会实际画出来；它不属于线段的一部份</p><p>Y:线段终点Y坐标位置，采用逻辑坐标表示。这个点不会实际画出来；它不属于线段的一部份</p><p>返回值：</p><p>返回TRUE代表移动成功，FALSE代表失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//从起点画到200, 20,并改变当前画笔位置</span><br><span class="line">LineTo(hdc, 200, 20);</span><br></pre></td></tr></table></figure><h3 id="polyline"><a class="markdownIt-Anchor" href="#polyline"></a> Polyline</h3><p>从apt数组中获取坐标点,画一个矩形,不改变当前画笔位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL Polyline( HDChdc, CONST POINT*lppt, intcPoints)</span><br></pre></td></tr></table></figure><p>hdc ------------ Long，要在其中绘图的设备场景</p><p>lpPoint -------- POINTAPI，nCount POINTAPI结构<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">数组</a>中的第一个POINTAPI结构</p><p>nCount --------- Long，lpPoint数组中的点数。会从第一个点到第二个点画一条线，以次类推</p><p>返回值: bool，非零表示成功，零表示失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POINT apt[5] = &#123;</span><br><span class="line">&#123;600,30&#125;,</span><br><span class="line">&#123;800,30&#125;,</span><br><span class="line">&#123;800,500&#125;,</span><br><span class="line">&#123;600,500&#125;,</span><br><span class="line">&#123;600,30&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//从apt数组中获取坐标点,画一个矩形,不改变当前画笔位置</span><br><span class="line">Polyline(hdc,apt,5);</span><br></pre></td></tr></table></figure><h3 id="polylineto"><a class="markdownIt-Anchor" href="#polylineto"></a> PolylineTo</h3><p>从apt2数组中获取坐标点,画一个矩形,并改变当前画笔位置</p><p>使用目前位置作为开始点，并将目前位置设定为最后一根线的终点,根据apt的点依次画直线。设置目前位置可调用MoveToEx函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL PolyLineTo(HDC hdc, CONST POINT * apt, DWORD cpt);</span><br></pre></td></tr></table></figure><p>参数：</p><p>hdc:设备场景句柄</p><p>apt:nCount POINTAPI结构<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">数组</a>中的第一个POINTAPI结构</p><p>cpt:Point数组中的点数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POINT apt2[5] = &#123;</span><br><span class="line">&#123; 900,30 &#125;,</span><br><span class="line">&#123; 1200,30 &#125;,</span><br><span class="line">&#123; 1200,500 &#125;,</span><br><span class="line">&#123; 900,500 &#125;,</span><br><span class="line">&#123; 900,30 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//设置当前画笔位置</span><br><span class="line">MoveToEx(hdc, apt2[0].x, apt2[0].y, NULL);</span><br><span class="line">//从apt2数组中获取坐标点,画一个矩形,改变当前画笔位置</span><br><span class="line">PolylineTo(hdc, apt2 + 1, 4);</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直线.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"直线.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量: </span></span><br><span class="line">HINSTANCE hInst;                                <span class="comment">// 当前实例</span></span><br><span class="line">WCHAR szTitle[MAX_LOADSTRING];                  <span class="comment">// 标题栏文本</span></span><br><span class="line">WCHAR szWindowClass[MAX_LOADSTRING];            <span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明: </span></span><br><span class="line"><span class="function">ATOM                <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL                <span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK    <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK    <span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此放置代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局字符串</span></span><br><span class="line">    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">    LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">    MyRegisterClass(hInstance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行应用程序初始化: </span></span><br><span class="line">    <span class="keyword">if</span> (!InitInstance (hInstance, nCmdShow))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY));</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主消息循环: </span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">        &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的: 注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEXW wcex;</span><br><span class="line"></span><br><span class="line">    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">    wcex.style          = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wcex.lpfnWndProc    = WndProc;</span><br><span class="line">    wcex.cbClsExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.cbWndExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.hInstance      = hInstance;</span><br><span class="line">    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY));</span><br><span class="line">    wcex.hCursor        = LoadCursor(<span class="literal">nullptr</span>, IDC_ARROW);</span><br><span class="line">    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);</span><br><span class="line">    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_MY);</span><br><span class="line">    wcex.lpszClassName  = szWindowClass;</span><br><span class="line">    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RegisterClassExW(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数: InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目的: 保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line"></span><br><span class="line">   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,</span><br><span class="line">      CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ShowWindow(hWnd, nCmdShow);</span><br><span class="line">   UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:    处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND  - 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT    - 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY  - 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//POINT 坐标结构类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct tagPOINT</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">LONG  x;</span></span><br><span class="line"><span class="comment">LONG  y;</span></span><br><span class="line"><span class="comment">&#125; POINT, *PPOINT, NEAR *NPPOINT, FAR *LPPOINT;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个矩形</span></span><br><span class="line">POINT apt[<span class="number">5</span>] = &#123;</span><br><span class="line">&#123;<span class="number">600</span>,<span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="number">800</span>,<span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="number">800</span>,<span class="number">500</span>&#125;,</span><br><span class="line">&#123;<span class="number">600</span>,<span class="number">500</span>&#125;,</span><br><span class="line">&#123;<span class="number">600</span>,<span class="number">30</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第三个矩形</span></span><br><span class="line">POINT apt2[<span class="number">5</span>] = &#123;</span><br><span class="line">&#123; <span class="number">900</span>,<span class="number">30</span> &#125;,</span><br><span class="line">&#123; <span class="number">1200</span>,<span class="number">30</span> &#125;,</span><br><span class="line">&#123; <span class="number">1200</span>,<span class="number">500</span> &#125;,</span><br><span class="line">&#123; <span class="number">900</span>,<span class="number">500</span> &#125;,</span><br><span class="line">&#123; <span class="number">900</span>,<span class="number">30</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wmId = LOWORD(wParam);</span><br><span class="line">            <span class="comment">// 分析菜单选择: </span></span><br><span class="line">            <span class="keyword">switch</span> (wmId)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">                DestroyWindow(hWnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在此处添加使用 hdc 的任何绘图代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置起点位置</span></span><br><span class="line">MoveToEx(hdc, <span class="number">20</span>, <span class="number">20</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//从起点画到200, 20,并改变当前画笔位置</span></span><br><span class="line">LineTo(hdc, <span class="number">200</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//从当前画笔位置,画到200, 500</span></span><br><span class="line">LineTo(hdc, <span class="number">200</span>, <span class="number">500</span>);</span><br><span class="line">LineTo(hdc, <span class="number">20</span>, <span class="number">500</span>);</span><br><span class="line">LineTo(hdc, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从apt数组中获取坐标点,画一个矩形,不改变当前画笔位置</span></span><br><span class="line">Polyline(hdc,apt,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置当前画笔位置</span></span><br><span class="line">MoveToEx(hdc, apt2[<span class="number">0</span>].x, apt2[<span class="number">0</span>].y, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//从apt2数组中获取坐标点,画一个矩形,改变当前画笔位置</span></span><br><span class="line">PolylineTo(hdc, apt2 + <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">        &#123;</span><br><span class="line">            EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">            <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;画直线&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#画直线&quot;&gt;&lt;/a&gt; 画直线&lt;/h1&gt;
&lt;h3 id=&quot;point坐标结构类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#point坐标结构类型&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>设定像素点</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/05/pwcp010-%E8%AE%BE%E5%AE%9A%E5%83%8F%E7%B4%A0%E7%82%B9/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/05/pwcp010-设定像素点/</id>
    <published>2021-06-05T05:59:49.000Z</published>
    <updated>2021-06-05T06:11:47.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="colorref"><a class="markdownIt-Anchor" href="#colorref"></a> COLORREF</h3><p>颜色类型</p><p>实际上是 unsigned long</p><p><img src="/images/javawz/1622873470897.png" alt="1622873470897"></p><h3 id="rgb宏"><a class="markdownIt-Anchor" href="#rgb宏"></a> RGB宏</h3><p>RGB(红,绿,蓝);</p><h3 id="setpixel"><a class="markdownIt-Anchor" href="#setpixel"></a> SetPixel</h3><p>指定坐标处的像素设为指定的颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COLORREF SetPixel(HDC hdc, int X, int Y, COLORREF crColor)；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetPixel(hdc,i,j,color);</span><br></pre></td></tr></table></figure><h3 id="getpixel"><a class="markdownIt-Anchor" href="#getpixel"></a> GetPixel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COLORREF GetPixel(HDC hdc, int nXPos, int nYPos)</span><br></pre></td></tr></table></figure><p>hdc：设备环境句柄。</p><p>nXPos：指定要检查的像素点的逻辑X轴坐标。</p><p>nYPos：指定要检查的像素点的逻辑Y轴坐标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color = GetPixel(hdc,200,200);</span><br></pre></td></tr></table></figure><h3 id="getrvalue宏"><a class="markdownIt-Anchor" href="#getrvalue宏"></a> GetRValue宏</h3><p>获取红色值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">red = GetRValue(color);</span><br></pre></td></tr></table></figure><h3 id="getgvalue宏"><a class="markdownIt-Anchor" href="#getgvalue宏"></a> GetGValue宏</h3><p>获取绿色值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">green = GetGValue(color);</span><br></pre></td></tr></table></figure><h3 id="getbvalue宏"><a class="markdownIt-Anchor" href="#getbvalue宏"></a> GetBValue宏</h3><p>获取蓝色值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blue = GetBValue(color);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;colorref&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#colorref&quot;&gt;&lt;/a&gt; COLORREF&lt;/h3&gt;
&lt;p&gt;颜色类型&lt;/p&gt;
&lt;p&gt;实际上是 unsigned long&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>新滚动条</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/02/pwcp009-%E6%96%B0%E6%BB%9A%E5%8A%A8%E6%9D%A1/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/02/pwcp009-新滚动条/</id>
    <published>2021-06-02T08:05:19.000Z</published>
    <updated>2021-06-05T06:11:44.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新滚动条"><a class="markdownIt-Anchor" href="#新滚动条"></a> 新滚动条</h1><h3 id="scrollinfo"><a class="markdownIt-Anchor" href="#scrollinfo"></a> SCROLLINFO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagSCROLLINFO</span><br><span class="line">&#123;</span><br><span class="line">UINT cbSize ; // set to sizeof (SCROLLINFO)</span><br><span class="line">UINT fMask ; // values to set or get</span><br><span class="line">int nMin; // 滚动条最小值</span><br><span class="line">int nMax; // 滚动条最大值</span><br><span class="line">UINT nPage ; // 一页大小</span><br><span class="line">int nPos ; </span><br><span class="line">int nTrackPos ; // 当前滑块位置</span><br><span class="line">&#125;SCROLLINFO,*LPSCROLLINFO;</span><br></pre></td></tr></table></figure><h3 id="setscrollinfo"><a class="markdownIt-Anchor" href="#setscrollinfo"></a> SetScrollInfo</h3><p>设置滚动条参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setscrollinfo(hwnd hwnd,int fnbar,lpscrollinfo lpsi,bool fredraw);</span><br></pre></td></tr></table></figure><p>参数：</p><p>hWnd：滚动条控件或带标准滚动条的<a href="https://baike.baidu.com/item/%E7%AA%97%E4%BD%93" target="_blank" rel="noopener">窗体</a>句柄，由fnBar参数决定。</p><p>fnBar：指定被设定参数的滚动条的类型。这个参数可以是下面值，含义如下：</p><p>SB_CTL：设置滚动条控件。而参数hwnd必须是滚动条控件的句柄。</p><p>SB_HORZ：设置所给定的<a href="https://baike.baidu.com/item/%E7%AA%97%E4%BD%93" target="_blank" rel="noopener">窗体</a>上标准水平滚动条参数。</p><p>SB_VERT：设置所给定的<a href="https://baike.baidu.com/item/%E7%AA%97%E4%BD%93" target="_blank" rel="noopener">窗体</a>上标准垂直滚动条参数。</p><p>lpsi：指向SCROLLINFO结构。在调用SetScrollInfo之前，设置<a href="https://baike.baidu.com/item/SCROLLINFO" target="_blank" rel="noopener">SCROLLINFO</a>结构中cbSize成员以标识结构大小，设置成员fMask以说明待设置的滚动条参数，并且在适当的成员中制定新的参数值。成员fMask可以为下面所列复合值，含义如下：</p><p>SIF_DISABLENOSCROLL：如果滚动条的新参数使其为没必要，则使滚动条无效而不再移动它。</p><p>SIF_PAGE：设置滚动页码值到由Ipsi指向的SCROLLINFO结构的nPage成员中。</p><p>SIF_POS：设置滚动位置值到由lpsi指向的SCROLLINFO结构的nPos成员中。</p><p>SIF_RANGE：设置滚动范围值到由lpsl指向的SCROLLINFO结构的nMin和nMax成员中。</p><p>fRedraw：指定滚动条是否重画以反映滚动条的变化。如果这个参数为TRUE，滚动条将被重画，否则不被重画。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置SIF_POS</span></span><br><span class="line">si.fMask = SIF_POS;</span><br><span class="line"><span class="comment">//设置滑块位置</span></span><br><span class="line">SetScrollInfo(hWnd,SB_VERT,&amp;si,TRUE);</span><br></pre></td></tr></table></figure><h3 id="getscrollinfo"><a class="markdownIt-Anchor" href="#getscrollinfo"></a> GetScrollInfo</h3><p>获取滚动条的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL GetScrollInfo( HWND hWnd, int fnBar, LPSCROLLINFO lpsi );</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><p>hWnd：滚动条控制或有标准滚动条的<a href="https://baike.baidu.com/item/%E7%AA%97%E4%BD%93" target="_blank" rel="noopener">窗体</a>句柄，由fnBar参数确定。</p><p>fnBar：指定待找回滚动条参数的类型，此参数可以为如下值，其值含义：</p><p>SB_CTL：找回滚动条控制参数。其中参数hwnd一定是处理滚动条控制的句柄。</p><p>SB_HORZ：找回所指定<a href="https://baike.baidu.com/item/%E7%AA%97%E4%BD%93" target="_blank" rel="noopener">窗体</a>的标准水平滚动条参数。</p><p>SB_VERT：找回所指定<a href="https://baike.baidu.com/item/%E7%AA%97%E4%BD%93" target="_blank" rel="noopener">窗体</a>的标准垂直滚动条参数。</p><p>lpsi：指向SCROLLINFO结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetScrollInfo(hWnd, SB_VERT, &amp;si);</span><br></pre></td></tr></table></figure><h3 id="scrollwindow"><a class="markdownIt-Anchor" href="#scrollwindow"></a> ScrollWindow</h3><p>函数滚动所指定的窗口客户区域内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL ScrollWindow(HWND hWnd, int XAmount, int YAmount, CONST RECT *IpRect, CONST RECT *lpClipRect);</span><br></pre></td></tr></table></figure><p>hWnd</p><p>[in]客户区域将被滚动的窗口的<a href="https://baike.baidu.com/item/%E5%8F%A5%E6%9F%84" target="_blank" rel="noopener">句柄</a>。</p><p>XAmount</p><p>[in]指定水平滚动的距离，以设备单位计。如果<a href="https://baike.baidu.com/item/%E7%AA%97%E5%8F%A3%E7%B1%BB" target="_blank" rel="noopener">窗口类</a>风格为CS_OWNDC或CS_CLASSDC，则此参数则使用逻辑单位而非设备单位。当向左滚动<a href="https://baike.baidu.com/item/%E7%AA%97%E4%BD%93" target="_blank" rel="noopener">窗体</a>内容时，参数值必须为负。</p><p>YAmount</p><p>[in]指定垂直滚动的距离，以设备单位计。如果窗口类风格为CS_OWNDC或CS_CLASSDC，则此参数则使用逻辑单位而非设备单位。当向上滚动<a href="https://baike.baidu.com/item/%E7%AA%97%E4%BD%93" target="_blank" rel="noopener">窗体</a>内容时，参数值必须为负。</p><p>lpRect</p><p>[in]指向<a href="https://baike.baidu.com/item/RECT" target="_blank" rel="noopener">RECT</a>结构的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">指针</a>，该结构指定了将要滚动的客户区范围。若此参数为NULL，则整个客户区域将被滚动。</p><p>lpClipRect</p><p>[in]指向<a href="https://baike.baidu.com/item/RECT" target="_blank" rel="noopener">RECT</a>结构的指针，该结构指定了要滚动的<a href="https://baike.baidu.com/item/%E8%A3%81%E5%89%AA%E5%8C%BA%E5%9F%9F" target="_blank" rel="noopener">裁剪区域</a>。只有这个矩形中的位才会被滚动。在矩形之外的位不会被影响，即使它们是在lpRect矩形之内。(见代码&quot;测试一&quot;)假如lpClipRect为NULL，则不会在滚动矩形上进行裁剪。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScrollWindow(hWnd, <span class="number">0</span>, cyChar * (iVertPos - si.nPos),<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/1622623528697.png" alt="1622623528697"></p><p><img src="/images/javawz/1622623600959.png" alt="1622623600959"></p><br><br><br><br><br><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动条2.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"滚动条2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 1024</span></span><br><span class="line"><span class="comment">// 全局变量: </span></span><br><span class="line">HINSTANCE hInst;                                <span class="comment">// 当前实例</span></span><br><span class="line">WCHAR szTitle[MAX_LOADSTRING];                  <span class="comment">// 标题栏文本</span></span><br><span class="line">WCHAR szWindowClass[MAX_LOADSTRING];            <span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明: </span></span><br><span class="line"><span class="function">ATOM                <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL                <span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK    <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK    <span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此放置代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局字符串</span></span><br><span class="line">    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">    LoadStringW(hInstance, IDC_MY2, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">    MyRegisterClass(hInstance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行应用程序初始化: </span></span><br><span class="line">    <span class="keyword">if</span> (!InitInstance (hInstance, nCmdShow))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY2));</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主消息循环: </span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">        &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的: 注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEXW wcex;</span><br><span class="line"></span><br><span class="line">    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">    wcex.style          = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wcex.lpfnWndProc    = WndProc;</span><br><span class="line">    wcex.cbClsExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.cbWndExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.hInstance      = hInstance;</span><br><span class="line">    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY2));</span><br><span class="line">    wcex.hCursor        = LoadCursor(<span class="literal">nullptr</span>, IDC_ARROW);</span><br><span class="line">    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);</span><br><span class="line">wcex.lpszMenuName= <span class="literal">NULL</span>;<span class="comment">// MAKEINTRESOURCEW(IDC_MY2);</span></span><br><span class="line">    wcex.lpszClassName  = szWindowClass;</span><br><span class="line">    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RegisterClassExW(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数: InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目的: 保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line"></span><br><span class="line">   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW | WS_VSCROLL,</span><br><span class="line">      CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ShowWindow(hWnd, nCmdShow);</span><br><span class="line">   UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:    处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND  - 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT    - 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY  - 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SCROLLINFO si;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> TEXTMETRIC tm;<span class="comment">//获取字体信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cxChar;<span class="comment">//字体宽度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cyChar;<span class="comment">//字体高度</span></span><br><span class="line">HDC hdc;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> iVscrollPos;<span class="comment">//当前滑块位置</span></span><br><span class="line"><span class="keyword">static</span> TCHAR szBuffer[<span class="number">1024</span>][<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cyClient;<span class="comment">//当前客户区高度大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cxClient;<span class="comment">//当前客户区宽度大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> iVertPos;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> iPaintBeg;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> iPaintEnd;</span><br><span class="line"><span class="keyword">switch</span> (message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line"><span class="comment">//获取客户区的高度</span></span><br><span class="line">cyClient = HIWORD(lParam);</span><br><span class="line"><span class="comment">//获取客户区的宽度</span></span><br><span class="line">cxClient = LOWORD(lParam);</span><br><span class="line"><span class="comment">//初始化si结构大小</span></span><br><span class="line">si.cbSize = <span class="keyword">sizeof</span>(si);</span><br><span class="line"><span class="comment">//设置可用标志</span></span><br><span class="line"><span class="comment">//SIF_RANGE:使用nMin和nMax成员</span></span><br><span class="line"><span class="comment">//SIF_PAGE:使用nPage成员</span></span><br><span class="line">si.fMask = SIF_RANGE | SIF_PAGE;</span><br><span class="line"><span class="comment">//设置一页大小</span></span><br><span class="line">si.nPage = cyClient / cyChar;</span><br><span class="line"><span class="comment">//设置滚动条最小值</span></span><br><span class="line">si.nMin = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//设置滚动条最大值</span></span><br><span class="line">si.nMax = MAX_LINE - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//设置滚动条参数</span></span><br><span class="line">SetScrollInfo(hWnd,SB_VERT,&amp;si,TRUE);</span><br><span class="line"><span class="comment">//窗口设置为失效</span></span><br><span class="line">InvalidateRect(hWnd, <span class="literal">NULL</span>, TRUE);</span><br><span class="line"><span class="comment">//更新窗口</span></span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_VSCROLL:</span><br><span class="line"></span><br><span class="line">si.cbSize = <span class="keyword">sizeof</span>(si);</span><br><span class="line"><span class="comment">//SIF_ALL:所有成员可用</span></span><br><span class="line">si.fMask = SIF_ALL;</span><br><span class="line"><span class="comment">//获取滚动条信息</span></span><br><span class="line">GetScrollInfo(hWnd,SB_VERT,&amp;si);</span><br><span class="line">iVertPos = si.nPos;</span><br><span class="line"><span class="comment">//获取滚动条操作的消息</span></span><br><span class="line"><span class="keyword">switch</span> (LOWORD(wParam))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//向上滚动一行</span></span><br><span class="line"><span class="keyword">case</span> SB_LINEUP:</span><br><span class="line">si.nPos -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//向下滚动一行</span></span><br><span class="line"><span class="keyword">case</span> SB_LINEDOWN:</span><br><span class="line">si.nPos += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//向下滚动一页</span></span><br><span class="line"><span class="keyword">case</span> SB_PAGEDOWN:</span><br><span class="line">si.nPos += si.nPage;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//向上滚动一页</span></span><br><span class="line"><span class="keyword">case</span> SB_PAGEUP:</span><br><span class="line">si.nPos -= si.nPage;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//拖动滑块时</span></span><br><span class="line"><span class="keyword">case</span> SB_THUMBTRACK:</span><br><span class="line"></span><br><span class="line">si.nPos = si.nTrackPos;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置SIF_POS</span></span><br><span class="line">si.fMask = SIF_POS;</span><br><span class="line"><span class="comment">//设置滑块位置</span></span><br><span class="line">SetScrollInfo(hWnd,SB_VERT,&amp;si,TRUE);</span><br><span class="line"><span class="comment">//获取滚动条信息</span></span><br><span class="line">GetScrollInfo(hWnd, SB_VERT, &amp;si);</span><br><span class="line"><span class="comment">//如果滑块位置不等于当前滑块位置</span></span><br><span class="line"><span class="keyword">if</span> (si.nPos != iVertPos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//滚动所指定的窗口客户区域内容</span></span><br><span class="line">ScrollWindow(hWnd, <span class="number">0</span>, cyChar * (iVertPos - si.nPos),<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">hdc = GetDC(hWnd);</span><br><span class="line">GetTextMetrics(hdc, &amp;tm);</span><br><span class="line">cxChar = tm.tmAveCharWidth;</span><br><span class="line">cyChar = tm.tmHeight + tm.tmExternalLeading;</span><br><span class="line">ReleaseDC(hWnd, hdc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_LINE; i++)</span><br><span class="line">&#123;</span><br><span class="line">_sntprintf(szBuffer[i], <span class="number">1024</span>, TEXT(<span class="string">"Hello %d "</span>), i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> wmId = LOWORD(wParam);</span><br><span class="line"><span class="comment">// 分析菜单选择: </span></span><br><span class="line"><span class="keyword">switch</span> (wmId)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">DestroyWindow(hWnd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">&#123;</span><br><span class="line">PAINTSTRUCT ps;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">si.cbSize = <span class="keyword">sizeof</span> si;</span><br><span class="line">si.fMask = SIF_ALL;</span><br><span class="line">GetScrollInfo(hWnd,SB_VERT,&amp;si);</span><br><span class="line">iVertPos = si.nPos;</span><br><span class="line"><span class="comment">//获取滚动条开始打印的位置</span></span><br><span class="line"><span class="comment">//ps.rcPaint.top 无效矩形的顶位置</span></span><br><span class="line">iPaintBeg = max(<span class="number">0</span>, iVertPos + ps.rcPaint.top / cyChar);</span><br><span class="line"><span class="comment">//获取滚动条结束打印的位置</span></span><br><span class="line"><span class="comment">//ps.rcPaint.bottom无效矩形的底位置</span></span><br><span class="line">iPaintEnd = min(MAX_LINE - <span class="number">1</span>, iVertPos + ps.rcPaint.bottom / cyChar);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处添加使用 hdc 的任何绘图代码...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = iPaintBeg, temp; i &lt; iPaintEnd; i++)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = (i - iVertPos) * cyChar;</span><br><span class="line"><span class="comment">//SetScrollPos(hWnd, SB_VERT, y, TRUE);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TextOut(hdc, x, y, szBuffer[i], lstrlen(szBuffer[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EndPaint(hWnd, &amp;ps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">        &#123;</span><br><span class="line">            EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">            <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;新滚动条&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#新滚动条&quot;&gt;&lt;/a&gt; 新滚动条&lt;/h1&gt;
&lt;h3 id=&quot;scrollinfo&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#scrollinfo&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>滚动条</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/01/pwcp008-%E6%BB%9A%E5%8A%A8%E6%9D%A1/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/01/pwcp008-滚动条/</id>
    <published>2021-06-01T04:05:13.000Z</published>
    <updated>2021-06-01T11:55:39.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="滚动条"><a class="markdownIt-Anchor" href="#滚动条"></a> 滚动条</h1><ol><li>在CreateWindow中加入WS_VSCROLL</li><li>添加WM_VSCROLL消息</li><li>设置滑块大小</li><li>设置滑块位置</li><li>更新客户区</li></ol><h3 id="ws_vscroll垂直滚动条"><a class="markdownIt-Anchor" href="#ws_vscroll垂直滚动条"></a> WS_VSCROLL垂直滚动条</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW | WS_VSCROLL,</span><br><span class="line">   CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h3 id="ws_hscroll水平滚动条"><a class="markdownIt-Anchor" href="#ws_hscroll水平滚动条"></a> WS_HSCROLL水平滚动条</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW | WS_HSCROLL,</span><br><span class="line">   CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h3 id="wm_vscroll消息"><a class="markdownIt-Anchor" href="#wm_vscroll消息"></a> WM_VSCROLL消息</h3><p>SB_PAGEDOWN 向下滚动一页</p><p>SB_LINEDOWN 向下滚动一行</p><p>SB_PAGEUP 向上滚动一页</p><p>SB_LINEUP 向上滚动一行</p><p>SB_TOP 滚动到顶端</p><p>SB_BOTTOM 滚动到底部</p><p>SB_THUMBPOSITION 用户有拖动滚动框 （滑块），并释放鼠标按钮。HIWORD 指示在拖动操作结束时滚动框的位置。</p><p>SB_THUMBTRACK 用户正在拖动滚动框。直到用户释放鼠标按钮，反复发送此邮件。HIWORD 指示滚动框已被拖动到的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_VSCROLL:</span><br><span class="line"><span class="keyword">switch</span> (LOWORD(wParam)) <span class="comment">//取wParam低位</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> SB_LINEUP:<span class="comment">//向上滚动一行</span></span><br><span class="line">iVscrollPos -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SB_LINEDOWN: <span class="comment">//向下滚动一行</span></span><br><span class="line">iVscrollPos += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SB_PAGEDOWN:<span class="comment">//向下滚动一页</span></span><br><span class="line">iVscrollPos += cyClient / cyChar;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SB_PAGEUP:<span class="comment">//向上滚动一页</span></span><br><span class="line">iVscrollPos -= cyClient / cyChar;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SB_THUMBTRACK:<span class="comment">//按下鼠标拖动滑块</span></span><br><span class="line">iVscrollPos = HIWORD(wParam);<span class="comment">//获取高位,滑块的位置</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">iVscrollPos = max(<span class="number">0</span>, min(iVscrollPos, MAX_LINE - <span class="number">1</span>));</span><br><span class="line"><span class="comment">//如果不等于当前滑块位置</span></span><br><span class="line"><span class="keyword">if</span>(iVscrollPos != GetScrollPos(hWnd,SB_VERT))</span><br><span class="line">SetScrollPos(hWnd, SB_VERT, iVscrollPos, TRUE);</span><br><span class="line">InvalidateRect(hWnd,<span class="literal">NULL</span>,TRUE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="setscrollrange"><a class="markdownIt-Anchor" href="#setscrollrange"></a> SetScrollRange</h3><p>函数设置所指定滚动条范围的最小值和最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL SetScrollRange(</span><br><span class="line">HWND hWnd, // 窗口句柄</span><br><span class="line">int nBar, // 滚动条类型</span><br><span class="line">int nMinPos, // 滚动条的最小位置</span><br><span class="line">int nMaxPos, // 滚动条的最大位置</span><br><span class="line">BOOL bRedraw // 重绘标志</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetScrollRange(hWnd,SB_VERT,0, MAX_LINE - 1,FALSE);</span><br></pre></td></tr></table></figure><h3 id="getscrollpos"><a class="markdownIt-Anchor" href="#getscrollpos"></a> GetScrollPos</h3><p>获取指定滚动条中滚动按钮的当前位置</p><p>hWnd：根据参数nBar值，处理滚动条控制或带有标准滚动条<a href="https://baike.baidu.com/item/%E7%AA%97%E4%BD%93" target="_blank" rel="noopener">窗体</a>。</p><p>nBar：指定滚动条将被检查。</p><p>SB_HORZ：水平滚动条</p><p>SB_VERT：垂直滚动条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetScrollPos(hWnd,SB_VERT);</span><br></pre></td></tr></table></figure><h3 id="setscrollpos"><a class="markdownIt-Anchor" href="#setscrollpos"></a> SetScrollPos</h3><p>用于设置所指定滚动条中的滚动按钮的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int SetScrollPos(</span><br><span class="line">HWNDhWnd, //窗体句柄</span><br><span class="line">intnBar, //滚动条</span><br><span class="line">intnPos, //滚动条的新位置</span><br><span class="line">BOOLbRedraw // 重绘标志</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>SB_HORZ：水平滚动条</p><p>SB_VERT：垂直滚动条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetScrollPos(hWnd, SB_VERT, iVscrollPos, TRUE);</span><br></pre></td></tr></table></figure><h3 id="invalidaterect"><a class="markdownIt-Anchor" href="#invalidaterect"></a> InvalidateRect</h3><p>使整个窗口无效</p><p>一般用来重画窗口,触发WM_PAINT消息</p><p>向指定的<a href="https://baike.baidu.com/item/%E7%AA%97%E4%BD%93/4163553" target="_blank" rel="noopener">窗体</a>更新区域添加一个矩形，然后窗体跟新区域的这一部分将被重新绘制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL InvalidateRect(</span><br><span class="line">HWND hWnd, // 窗口句柄</span><br><span class="line">CONST RECT *lpRect, // 矩形指针变量</span><br><span class="line">BOOL bErase //是否重画</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lpRect：如果为NULL，全部的窗口客户区域将被增加到更新区域中。</p><h3 id="updatewindow"><a class="markdownIt-Anchor" href="#updatewindow"></a> UpdateWindow</h3><p>更新指定窗口的客户区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL UpdateWindow(</span><br><span class="line">HWND hWnd // 窗口的句柄</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="wm_size"><a class="markdownIt-Anchor" href="#wm_size"></a> WM_SIZE</h3><p>当窗口大小发生改变时触发消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line"><span class="comment">//获取客户区的高度</span></span><br><span class="line">cyClient = HIWORD(lParam);</span><br><span class="line"><span class="comment">//获取客户区的宽度</span></span><br><span class="line">cxClient = LOWORD(lParam);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动条.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"滚动条.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 100</span></span><br><span class="line"><span class="comment">// 全局变量: </span></span><br><span class="line">HINSTANCE hInst;                                <span class="comment">// 当前实例</span></span><br><span class="line">WCHAR szTitle[MAX_LOADSTRING];                  <span class="comment">// 标题栏文本</span></span><br><span class="line">WCHAR szWindowClass[MAX_LOADSTRING];            <span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明: </span></span><br><span class="line"><span class="function">ATOM                <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL                <span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK    <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK    <span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此放置代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局字符串</span></span><br><span class="line">    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">    LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">    MyRegisterClass(hInstance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行应用程序初始化: </span></span><br><span class="line">    <span class="keyword">if</span> (!InitInstance (hInstance, nCmdShow))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY));</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主消息循环: </span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">        &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的: 注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEXW wcex;</span><br><span class="line"></span><br><span class="line">    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">    wcex.style          = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wcex.lpfnWndProc    = WndProc;</span><br><span class="line">    wcex.cbClsExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.cbWndExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.hInstance      = hInstance;</span><br><span class="line">    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY));</span><br><span class="line">    wcex.hCursor        = LoadCursor(<span class="literal">nullptr</span>, IDC_ARROW);</span><br><span class="line">    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);</span><br><span class="line">wcex.lpszMenuName= <span class="literal">NULL</span>;<span class="comment">// MAKEINTRESOURCEW(IDC_MY);</span></span><br><span class="line">    wcex.lpszClassName  = szWindowClass;</span><br><span class="line">    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RegisterClassExW(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数: InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目的: 保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line">   <span class="comment">//WS_VSCROLL 创建垂直滚动条</span></span><br><span class="line">   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW | WS_VSCROLL,</span><br><span class="line">      CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ShowWindow(hWnd, nCmdShow);</span><br><span class="line">   UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:    处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND  - 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT    - 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY  - 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> TEXTMETRIC tm;<span class="comment">//获取字体信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cxChar;<span class="comment">//字体宽度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cyChar;<span class="comment">//字体高度</span></span><br><span class="line">HDC hdc;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> iVscrollPos;<span class="comment">//当前滑块位置</span></span><br><span class="line">TCHAR szBuffer[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cyClient;<span class="comment">//当前客户区高度大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cxClient;<span class="comment">//当前客户区宽度大小</span></span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">case</span> WM_SIZE:</span><br><span class="line"><span class="comment">//获取客户区的高度</span></span><br><span class="line">cyClient = HIWORD(lParam);</span><br><span class="line"><span class="comment">//获取客户区的宽度</span></span><br><span class="line">cxClient = LOWORD(lParam);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_VSCROLL:</span><br><span class="line"><span class="comment">//获取滚动条操作的消息</span></span><br><span class="line"><span class="keyword">switch</span> (LOWORD(wParam))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//向上滚动一行</span></span><br><span class="line"><span class="keyword">case</span> SB_LINEUP:</span><br><span class="line">iVscrollPos -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//向下滚动一行</span></span><br><span class="line"><span class="keyword">case</span> SB_LINEDOWN:</span><br><span class="line">iVscrollPos += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//向下滚动一页</span></span><br><span class="line"><span class="keyword">case</span> SB_PAGEDOWN:</span><br><span class="line">iVscrollPos += cyClient / cyChar;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//向上滚动一页</span></span><br><span class="line"><span class="keyword">case</span> SB_PAGEUP:</span><br><span class="line">iVscrollPos -= cyClient / cyChar;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//拖动滑块时</span></span><br><span class="line"><span class="keyword">case</span> SB_THUMBTRACK:</span><br><span class="line"><span class="comment">//拖动滑块时,获取滑块位置,在wParam的高位</span></span><br><span class="line">iVscrollPos = HIWORD(wParam);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最小是0,最大是MAX_LINE - 1</span></span><br><span class="line">iVscrollPos = max(<span class="number">0</span>, min(iVscrollPos, MAX_LINE - <span class="number">1</span>));</span><br><span class="line"><span class="comment">//如果当前滑块位置不等于iVscrollPos</span></span><br><span class="line"><span class="keyword">if</span>(iVscrollPos != GetScrollPos(hWnd,SB_VERT))</span><br><span class="line">SetScrollPos(hWnd, SB_VERT, iVscrollPos, TRUE);</span><br><span class="line">InvalidateRect(hWnd,<span class="literal">NULL</span>,TRUE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">hdc = GetDC(hWnd);</span><br><span class="line">GetTextMetrics(hdc, &amp;tm);</span><br><span class="line">cxChar = tm.tmAveCharWidth;</span><br><span class="line">cyChar = tm.tmHeight + tm.tmExternalLeading;</span><br><span class="line">ReleaseDC(hWnd,hdc);</span><br><span class="line"><span class="comment">//当前滑块默认为0</span></span><br><span class="line">iVscrollPos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//设置滚动条大小</span></span><br><span class="line">SetScrollRange(hWnd,SB_VERT,<span class="number">0</span>, MAX_LINE - <span class="number">1</span>,FALSE);</span><br><span class="line"><span class="comment">//设置滑块位置</span></span><br><span class="line">SetScrollPos(hWnd,SB_VERT,iVscrollPos,TRUE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wmId = LOWORD(wParam);</span><br><span class="line">            <span class="comment">// 分析菜单选择: </span></span><br><span class="line">            <span class="keyword">switch</span> (wmId)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">                DestroyWindow(hWnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">            HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在此处添加使用 hdc 的任何绘图代码...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, temp; i &lt; MAX_LINE; i++)</span><br><span class="line">&#123;</span><br><span class="line"> x = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (iVscrollPos &gt;= MAX_LINE - cyClient/cyChar)</span><br><span class="line"> &#123;</span><br><span class="line"> y = (i - (MAX_LINE - cyClient / cyChar)) * cyChar;</span><br><span class="line"> <span class="comment">//SetScrollPos(hWnd, SB_VERT, y, TRUE);</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> y = (i - iVscrollPos) * cyChar;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_sntprintf(szBuffer,<span class="number">1024</span>,TEXT(<span class="string">"Hello %d "</span>),i + <span class="number">1</span>);</span><br><span class="line">TextOut(hdc, x, y,szBuffer,lstrlen(szBuffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">        &#123;</span><br><span class="line">            EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">            <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;滚动条&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#滚动条&quot;&gt;&lt;/a&gt; 滚动条&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;在CreateWindow中加入WS_VSCROLL&lt;/li&gt;
&lt;li&gt;添加WM_VSCROLL消息&lt;/li&gt;
&lt;li&gt;设置滑
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>系统字体</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/31/pwcp007-%E7%B3%BB%E7%BB%9F%E5%AD%97%E4%BD%93/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/31/pwcp007-系统字体/</id>
    <published>2021-05-31T11:26:57.000Z</published>
    <updated>2021-06-08T05:12:26.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统字体"><a class="markdownIt-Anchor" href="#系统字体"></a> 系统字体</h1><p><img src="/images/javawz/1622460534446.png" alt="1622460534446"></p><h3 id="textmetric字体信息结构"><a class="markdownIt-Anchor" href="#textmetric字体信息结构"></a> TEXTMETRIC字体信息结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTEXTMETRIC</span> &#123;</span> </span><br><span class="line">LONG tmHeight; <span class="comment">//字符高度</span></span><br><span class="line">LONG tmAscent; <span class="comment">//字符上部高度(基线以上)</span></span><br><span class="line">LONG tmDescent; <span class="comment">//字符下部高度(基线以下)</span></span><br><span class="line">LONG tmInternalLeading, <span class="comment">//由tmHeight定义的字符高度的顶部空间数目</span></span><br><span class="line">LONG tmExternalLeading, <span class="comment">//夹在两行之间的空间数目</span></span><br><span class="line">LONG tmAveCharWidth, <span class="comment">//平均字符宽度</span></span><br><span class="line">LONG tmMaxCharWidth, <span class="comment">//最宽字符的宽度</span></span><br><span class="line">LONG tmWeight; <span class="comment">//字体的粗细轻重程度</span></span><br><span class="line">LONG tmOverhang, <span class="comment">//加入某些拼接字体上的附加高度</span></span><br><span class="line">LONG tmDigitizedAspectX, <span class="comment">//字体设计所针对的设备水平方向</span></span><br><span class="line">LONG tmDigitizedAspectY, <span class="comment">//字体设计所针对的设备垂直方向</span></span><br><span class="line">BCHAR tmFirstChar; <span class="comment">//为字体定义的第一个字符</span></span><br><span class="line">BCHAR tmLastChar; <span class="comment">//为字体定义的最后一个字符</span></span><br><span class="line">BCHAR tmDefaultChar; <span class="comment">//字体中所没有字符的替代字符</span></span><br><span class="line">BCHAR tmBreakChar; <span class="comment">//用于拆字的字符</span></span><br><span class="line">BYTE tmItalic, <span class="comment">//字体为斜体时非零</span></span><br><span class="line">BYTE tmUnderlined, <span class="comment">//字体为下划线时非零</span></span><br><span class="line">BYTE tmStruckOut, <span class="comment">//字体被删去时非零</span></span><br><span class="line">BYTE tmPitchAndFamily, <span class="comment">//字体间距(低4位)和族(高4位)</span></span><br><span class="line">BYTE tmCharSet; <span class="comment">//字体的字符集</span></span><br><span class="line">&#125; TEXTMETRIC;</span><br></pre></td></tr></table></figure><h3 id="gettextmetrics"><a class="markdownIt-Anchor" href="#gettextmetrics"></a> GetTextMetrics</h3><p>把程序当前的字体信息，存放到<a href="https://baike.baidu.com/item/TEXTMETRIC/10316529" target="_blank" rel="noopener">TEXTMETRIC</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL GetTextMetrics(HDC hdc, LPTEXTMETRIC lptm)；</span><br></pre></td></tr></table></figure><p>hdc：设备环境句柄。</p><p>lptm：指向结构TEXTMETRIC的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">指针</a>，该结构用于获得字体信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetTextMetrics(hdc, &amp;tm);</span><br></pre></td></tr></table></figure><h3 id><a class="markdownIt-Anchor" href="#"></a> </h3><h3 id="getsystemmetrics"><a class="markdownIt-Anchor" href="#getsystemmetrics"></a> GetSystemMetrics</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int WINAPI GetSystemMetrics( __in intnIndex);</span><br></pre></td></tr></table></figure><p>只有一个参数，称之为「索引」，这个索引有75个<a href="https://baike.baidu.com/item/%E6%A0%87%E8%AF%86%E7%AC%A6/7105638" target="_blank" rel="noopener">标识符</a>，通过设置不同的标识符就可以获取系统分辨率、<a href="https://baike.baidu.com/item/%E7%AA%97%E4%BD%93/4163553" target="_blank" rel="noopener">窗体</a>显示区域的宽度和高度、滚动条的宽度和高度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取屏幕宽度</span></span><br><span class="line">cxScreen = GetSystemMetrics(SM_CXSCREEN);</span><br><span class="line"><span class="comment">//获取屏幕高度</span></span><br><span class="line">cyScreen = GetSystemMetrics(SM_CYSCREEN);</span><br></pre></td></tr></table></figure><h3 id="settextalign"><a class="markdownIt-Anchor" href="#settextalign"></a> SetTextAlign</h3><p>为指定设备环境设置文字对齐标志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UINT SetTextAlign(</span><br><span class="line">HDC hdc, // 设备环境句柄</span><br><span class="line">UINT fMode // 文本对齐选项</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>设置对齐方式为左对齐</p><pre><code>SetTextAlign(hdc, TA_LEFT | TA_TOP);</code></pre><p>设置对齐方式为右对齐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetTextAlign(hdc, TA_RIGHT | TA_TOP);</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统字体.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"系统字体.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量: </span></span><br><span class="line">HINSTANCE hInst;                                <span class="comment">// 当前实例</span></span><br><span class="line">WCHAR szTitle[MAX_LOADSTRING];                  <span class="comment">// 标题栏文本</span></span><br><span class="line">WCHAR szWindowClass[MAX_LOADSTRING];            <span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明: </span></span><br><span class="line"><span class="function">ATOM                <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL                <span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK    <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK    <span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此放置代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局字符串</span></span><br><span class="line">    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">    LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">    MyRegisterClass(hInstance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行应用程序初始化: </span></span><br><span class="line">    <span class="keyword">if</span> (!InitInstance (hInstance, nCmdShow))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY));</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主消息循环: </span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">        &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的: 注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEXW wcex;</span><br><span class="line"></span><br><span class="line">    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">    wcex.style          = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wcex.lpfnWndProc    = WndProc;</span><br><span class="line">    wcex.cbClsExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.cbWndExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.hInstance      = hInstance;</span><br><span class="line">    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY));</span><br><span class="line">    wcex.hCursor        = LoadCursor(<span class="literal">nullptr</span>, IDC_ARROW);</span><br><span class="line">    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);</span><br><span class="line">wcex.lpszMenuName= <span class="literal">NULL</span>;<span class="comment">//MAKEINTRESOURCEW(IDC_MY);</span></span><br><span class="line">    wcex.lpszClassName  = szWindowClass;</span><br><span class="line">    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RegisterClassExW(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数: InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目的: 保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line"></span><br><span class="line">   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,</span><br><span class="line">      CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ShowWindow(hWnd, nCmdShow);</span><br><span class="line">   UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:    处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND  - 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT    - 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY  - 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> TEXTMETRIC tm;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cxChar;<span class="comment">//字符宽度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cyChar;<span class="comment">//字符高度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cxCap;<span class="comment">//一个字符的宽度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cxScreen, cyScreen;<span class="comment">//屏幕宽度和高度</span></span><br><span class="line">TCHAR szBuffer[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">//字符串长度</span></span><br><span class="line">HDC hdc;</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">hdc = GetDC(hWnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把程序当前的字体信息，存放到tm</span></span><br><span class="line">GetTextMetrics(hdc, &amp;tm);</span><br><span class="line"><span class="comment">//获取字符平均值</span></span><br><span class="line">cxChar = tm.tmAveCharWidth;</span><br><span class="line"><span class="comment">//获取字符高度</span></span><br><span class="line">cyChar = tm.tmHeight + tm.tmExternalLeading + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//获取一个字符的宽度</span></span><br><span class="line">cxCap = (tm.tmPitchAndFamily &amp; <span class="number">1</span> ? <span class="number">3</span> : <span class="number">2</span>) * cxChar / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//获取屏幕宽度</span></span><br><span class="line">cxScreen = GetSystemMetrics(SM_CXSCREEN);</span><br><span class="line"><span class="comment">//获取屏幕高度</span></span><br><span class="line">cyScreen = GetSystemMetrics(SM_CYSCREEN);</span><br><span class="line">ReleaseDC(hWnd,hdc);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wmId = LOWORD(wParam);</span><br><span class="line">            <span class="comment">// 分析菜单选择: </span></span><br><span class="line">            <span class="keyword">switch</span> (wmId)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">                DestroyWindow(hWnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在此处添加使用 hdc 的任何绘图代码...</span></span><br><span class="line">TextOut(hdc,<span class="number">0</span>,<span class="number">0</span>,TEXT(<span class="string">"SM_CXSCREEN"</span>),lstrlen(TEXT(<span class="string">"SM_CXSCREEN"</span>)));</span><br><span class="line"></span><br><span class="line">TextOut(hdc, cxCap * <span class="number">30</span>, <span class="number">0</span>, TEXT(<span class="string">"屏幕宽度"</span>), lstrlen(TEXT(<span class="string">"屏幕宽度"</span>)));</span><br><span class="line"><span class="comment">//设置对齐方式为右对齐</span></span><br><span class="line">SetTextAlign(hdc,TA_RIGHT|TA_TOP);</span><br><span class="line">len = _sntprintf(szBuffer,<span class="number">1024</span>,TEXT(<span class="string">"%d"</span>),cxScreen);</span><br><span class="line">TextOut(hdc, cxCap * <span class="number">60</span>, <span class="number">0</span>, szBuffer,len);</span><br><span class="line"><span class="comment">//设置对齐方式为左对齐</span></span><br><span class="line">SetTextAlign(hdc,TA_LEFT | TA_TOP);</span><br><span class="line">TextOut(hdc, <span class="number">0</span>, cyChar, TEXT(<span class="string">"SM_CYSCREEN"</span>), lstrlen(TEXT(<span class="string">"SM_CYSCREEN"</span>)));</span><br><span class="line"></span><br><span class="line">TextOut(hdc, cxCap * <span class="number">30</span>, cyChar, TEXT(<span class="string">"屏幕高度"</span>), lstrlen(TEXT(<span class="string">"屏幕高度"</span>)));</span><br><span class="line"><span class="comment">//设置对齐方式为右对齐</span></span><br><span class="line">SetTextAlign(hdc, TA_RIGHT | TA_TOP);</span><br><span class="line"></span><br><span class="line">len = _sntprintf(szBuffer, <span class="number">1024</span>, TEXT(<span class="string">"%d"</span>), cyScreen);</span><br><span class="line">TextOut(hdc, cxCap * <span class="number">60</span>, cyChar, szBuffer, len);</span><br><span class="line"><span class="comment">//设置对齐方式为左对齐</span></span><br><span class="line">SetTextAlign(hdc, TA_LEFT | TA_TOP);</span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">        &#123;</span><br><span class="line">            EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">            <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统字体&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#系统字体&quot;&gt;&lt;/a&gt; 系统字体&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1622460534446.png&quot; alt=&quot;1622460534446&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>文本输出</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/31/pwcp006-%E6%96%87%E6%9C%AC%E8%BE%93%E5%87%BA/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/31/pwcp006-文本输出/</id>
    <published>2021-05-31T10:15:56.000Z</published>
    <updated>2021-05-31T10:33:18.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文本输出"><a class="markdownIt-Anchor" href="#文本输出"></a> 文本输出</h1><h3 id="设备环境句柄"><a class="markdownIt-Anchor" href="#设备环境句柄"></a> 设备环境句柄</h3><h4 id="beginpaint和endpaint用于wm_paint"><a class="markdownIt-Anchor" href="#beginpaint和endpaint用于wm_paint"></a> BeginPaint和EndPaint用于WM_PAINT</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">case WM_PAINT:</span><br><span class="line">        HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">        ...</span><br><span class="line">        EndPaint(hWnd, &amp;ps);</span><br></pre></td></tr></table></figure><h3 id="getdc和releasedc可以用在任何位置"><a class="markdownIt-Anchor" href="#getdc和releasedc可以用在任何位置"></a> GetDC和releaseDC可以用在任何位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hdc = GetDC(hwnd);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">releaseDC(hwnd,hdc);</span><br></pre></td></tr></table></figure><h3 id="textout"><a class="markdownIt-Anchor" href="#textout"></a> TextOut</h3><p>用当前选择的字体、背景颜色和正文颜色将一个字符串写到指定位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL TextOut(</span><br><span class="line">HDC hdc, // 设备描述表句柄</span><br><span class="line">int nXStart, // 字符串的开始位置 x坐标</span><br><span class="line">int nYStart, // 字符串的开始位置 y坐标</span><br><span class="line">LPCTSTR lpString, // 字符串</span><br><span class="line">int cbString // 字符串中字符的个数</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通盘考虑.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"通盘考虑.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量: </span></span><br><span class="line">HINSTANCE hInst;                                <span class="comment">// 当前实例</span></span><br><span class="line">WCHAR szTitle[MAX_LOADSTRING];                  <span class="comment">// 标题栏文本</span></span><br><span class="line">WCHAR szWindowClass[MAX_LOADSTRING];            <span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明: </span></span><br><span class="line"><span class="function">ATOM                <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL                <span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK    <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK    <span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此放置代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局字符串</span></span><br><span class="line">    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">    LoadStringW(hInstance, IDC_MY, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">    MyRegisterClass(hInstance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行应用程序初始化: </span></span><br><span class="line">    <span class="keyword">if</span> (!InitInstance (hInstance, nCmdShow))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MY));</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主消息循环: </span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">        &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的: 注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEXW wcex;</span><br><span class="line"></span><br><span class="line">    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">    wcex.style          = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wcex.lpfnWndProc    = WndProc;</span><br><span class="line">    wcex.cbClsExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.cbWndExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.hInstance      = hInstance;</span><br><span class="line">    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MY));</span><br><span class="line">    wcex.hCursor        = LoadCursor(<span class="literal">nullptr</span>, IDC_ARROW);</span><br><span class="line">wcex.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<span class="comment">//(HBRUSH)(COLOR_WINDOW+1);</span></span><br><span class="line">wcex.lpszMenuName = <span class="literal">NULL</span>;<span class="comment">//MAKEINTRESOURCEW(IDC_MY);</span></span><br><span class="line">    wcex.lpszClassName  = szWindowClass;</span><br><span class="line">    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RegisterClassExW(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数: InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目的: 保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line"></span><br><span class="line">   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,</span><br><span class="line">      CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ShowWindow(hWnd, nCmdShow);</span><br><span class="line">   UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:    处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND  - 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT    - 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY  - 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> iCharWidth = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wmId = LOWORD(wParam);</span><br><span class="line">            <span class="comment">// 分析菜单选择: </span></span><br><span class="line">            <span class="keyword">switch</span> (wmId)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">                DestroyWindow(hWnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">TCHAR szBuffer[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在此处添加使用 hdc 的任何绘图代码...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">_sntprintf(szBuffer,<span class="number">1024</span>, TEXT(<span class="string">"我爱你 %d"</span>),i + <span class="number">1</span>);</span><br><span class="line">TextOut(hdc, <span class="number">0</span>, iCharWidth * i,szBuffer , lstrlen(szBuffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">        &#123;</span><br><span class="line">            EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">            <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文本输出&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#文本输出&quot;&gt;&lt;/a&gt; 文本输出&lt;/h1&gt;
&lt;h3 id=&quot;设备环境句柄&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#设备环境句柄&quot;&gt;&lt;/a&gt; 设备环境
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>通盘考虑</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/31/pwcp005-%E9%80%9A%E7%9B%98%E8%80%83%E8%99%91/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/31/pwcp005-通盘考虑/</id>
    <published>2021-05-31T09:45:08.000Z</published>
    <updated>2021-05-31T10:16:31.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通盘考虑"><a class="markdownIt-Anchor" href="#通盘考虑"></a> 通盘考虑</h1><p>Loadicon 加载图标，以供程序使用。</p><p>LoadCursor加载鼠标光标，以供程序使用。</p><p>GetStockObject 获取一个图形对象。在本例中是一个用来对窗口的背景进行重绘<br>的画刷。</p><p>RegisterClass 为应用程序的窗口注册一个窗口类。</p><p>MessageBox 显示消息框。</p><p>Create Window 基于窗口类创建一个窗口。</p><p>ShowWindow 在屏幕中显示窗口。</p><p>UpdateWindow 指示窗口对其自身进行重绘。</p><p>GetMessage 从消息队列获取消息。</p><p>TranslateMessage 翻译一些键盘消息。</p><p>DispatchMessage 将消息发送给窗口过程。</p><p>PlaySound 播放声音文件。</p><p>BeginPaint 标明窗口绘制开始。</p><p>GetClientRect 获取窗口客户区的尺寸。</p><p>DrawText 显示一个文本字符串。</p><p>EndPaint结束窗口绘制。</p><p>PostQuitMessage 将“退出”消息插入消息队列。</p><p>DefWindowProc 执行默认的消息处理。</p><h3 id="大写标识符"><a class="markdownIt-Anchor" href="#大写标识符"></a> 大写标识符</h3><p><img src="/images/javawz/1622454625727.png" alt="1622454625727"></p><h3 id="匈牙利标记法"><a class="markdownIt-Anchor" href="#匈牙利标记法"></a> 匈牙利标记法</h3><p><img src="/images/javawz/1622454896616.png" alt="1622454896616"></p><h3 id="getstockobject"><a class="markdownIt-Anchor" href="#getstockobject"></a> GetStockobject</h3><p>获取预定义的备用笔、刷子、字体或者调色板的句柄。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGDIOBJ GetStockObject(int fnObject)；</span><br></pre></td></tr></table></figure><p>fnObject：指定对象的类型，该参数可取如下值之一；</p><p>BLACK_BRUSH：黑色画刷；DKGRAY_BRUSH：暗灰色画刷；</p><p>DC_BRUSH：在<a href="https://baike.baidu.com/item/Windows98/5246326" target="_blank" rel="noopener">Windows98</a>,Windows NT 5.0和以后版本中为纯颜色画刷，缺省色为白色，可以用<a href="https://baike.baidu.com/item/SetDCBrushColor" target="_blank" rel="noopener">SetDCBrushColor</a>函数改变颜色，更多的信息参见以下的注释部分。</p><p>GRAY_BRUSH：灰色画刷笔；</p><p>HOLLOW_BRUSH：空画刷（相当于NULL_BRUSH）；</p><p>NULL_BRUSH：空画刷（相当于HOLLOW_BRUSH）；</p><p>LTGRAY_BRUSH：亮灰色画刷；</p><p>WHITE_BRUSH：白色画刷；</p><p>BLACK_PEN：黑色钢笔；</p><p>DC_PEN：在<a href="https://baike.baidu.com/item/Windows98/5246326" target="_blank" rel="noopener">Windows98</a>、Windows NT 5.0和以后版本中为纯色钢笔，缺省色为白色，使用<a href="https://baike.baidu.com/item/SetDCPenColor" target="_blank" rel="noopener">SetDCPenColor</a>函数可以改变色彩，更多的信息，参见下面的注释部分。</p><p>WHITE_PEN：白色钢笔；</p><p>ANSI_FIXED_FONT：在Windows中为固定间距（等宽）系统字体；</p><p>ANSI_VAR_FONT：在Windows中为变间距（比例间距）系统字体；</p><p>DEVICE_DEFAUCT_FONT：在WindowsNT中为设备相关字体；</p><p>DEFAULT_GUI_FONT：用户界面对象缺省字体，如菜单和对话框；</p><p>OEM_FIXED_FONT：<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%A7%8B%E8%AE%BE%E5%A4%87%E5%88%B6%E9%80%A0%E5%95%86" target="_blank" rel="noopener">原始设备制造商</a>（OEM）相关固定间距（等宽）字体；</p><p>SYSTEM_FONT：系统字体，在缺省情况下，系统使用系统字体绘制菜单，对话框控制和文本；</p><p>SYSTEM_FIXED_FONT：固定间距（等宽）系统字体，该对象仅提供给兼容16位Windows版本；</p><p>DEFAULT_PALETTE：缺省<a href="https://baike.baidu.com/item/%E8%B0%83%E8%89%B2%E6%9D%BF" target="_blank" rel="noopener">调色板</a>，该调色板由系统调色板中的静态色彩组成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通盘考虑&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#通盘考虑&quot;&gt;&lt;/a&gt; 通盘考虑&lt;/h1&gt;
&lt;p&gt;Loadicon 加载图标，以供程序使用。&lt;/p&gt;
&lt;p&gt;LoadCursor加载鼠标光标，以供程序使用。&lt;/p&gt;
&lt;p&gt;GetSt
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>windows向导及句柄</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/31/pwcp004-windows%E5%90%91%E5%AF%BC%E5%8F%8A%E5%8F%A5%E6%9F%84/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/31/pwcp004-windows向导及句柄/</id>
    <published>2021-05-31T02:11:55.000Z</published>
    <updated>2021-05-31T04:21:53.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="windows向导及句柄"><a class="markdownIt-Anchor" href="#windows向导及句柄"></a> windows向导及句柄</h1><ul><li><p><a href="#1">最好把<code>stdafx.h</code>中的#define WIN32_LEAN_AND_MEAN 注释掉,不然很多功能会使用不了 </a></p></li><li><p><a href="#2">当水平或垂直方向发生变化时就重画 </a></p></li><li><p><a href="#3">窗口在创建过程中触发的第一个消息 </a></p></li><li><p><a href="#4">PlaySound 用于播放音乐的API函数 </a></p></li><li><p><a href="#5">RECT矩形类 </a></p></li><li><p><a href="#6">HDC设备上下文句柄 </a></p></li><li><p><a href="#7">PAINTSTRUCT 包含了某应用程序用来绘制它所拥有的窗口客户区所需要的信息的结构体 </a></p></li><li><p><a href="#8">BeginPaint 指定窗口进行绘图工作的准备，并用将和绘图有关的信息填充到一个PAINTSTRUCT结构中 </a></p></li><li><p><a href="#9">EndPaint释放设备上下文句柄 </a></p></li><li><p><a href="#10">GetClientRect获取窗口客户区大小 </a></p></li><li><p><a href="#11">Ellipse在窗口客户区画一个椭圆 </a></p></li><li><p><a href="#12">DrawText在窗口打印文字 </a></p></li><li><p><a href="#13">句柄 </a></p></li></ul><h3 id="windows向导"><a class="markdownIt-Anchor" href="#windows向导"></a> windows向导</h3><br><p><img src="/images/javawz/1622427535392.png" alt="1622427535392"></p><p><img src="/images/javawz/1622427560513.png" alt="1622427560513"></p><p><span id="1"></span></p><h3 id="最好把stdafxh中的define-win32_lean_and_mean-注释掉不然很多功能会使用不了"><a class="markdownIt-Anchor" href="#最好把stdafxh中的define-win32_lean_and_mean-注释掉不然很多功能会使用不了"></a> 最好把<code>stdafx.h</code>中的#define WIN32_LEAN_AND_MEAN 注释掉,不然很多功能会使用不了</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define WIN32_LEAN_AND_MEAN             // 从 Windows 头中排除极少使用的资料</span></span><br></pre></td></tr></table></figure><p><span id="2"></span></p><h3 id="当水平或垂直方向发生变化时就重画"><a class="markdownIt-Anchor" href="#当水平或垂直方向发生变化时就重画"></a> 当水平或垂直方向发生变化时就重画</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wcex.style = CS_HREDRAW | CS_VREDRAW;<span class="comment">//当水平或垂直方向发生变化时就重画</span></span><br></pre></td></tr></table></figure><p><span id="3"></span></p><h3 id="窗口在创建过程中触发的第一个消息"><a class="markdownIt-Anchor" href="#窗口在创建过程中触发的第一个消息"></a> 窗口在创建过程中触发的第一个消息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">case WM_CREATE:</span><br></pre></td></tr></table></figure><p><span id="4"></span></p><h3 id="playsound-用于播放音乐的api函数"><a class="markdownIt-Anchor" href="#playsound-用于播放音乐的api函数"></a> PlaySound 用于播放音乐的API函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PlaySound</span><span class="params">(LPCSTR pszSound, HMODULE hmod,DWORD fdwSound)</span></span>;</span><br></pre></td></tr></table></figure><p>在vs2010以上版本需要加入#pragma comment(lib, “winmm.lib”)才能使用PlaySound 或在项目属性-&gt;链接器-&gt;输入-&gt;附加依赖项中添加winmm.lib</p><p>SND_ASYNC 异步播放</p><p>SND_FILENAME 文件名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlaySound(TEXT(<span class="string">"2.wav"</span>),<span class="literal">NULL</span>,SND_FILENAME | SND_ASYNC);</span><br></pre></td></tr></table></figure><p><span id="5"></span></p><h3 id="rect矩形类"><a class="markdownIt-Anchor" href="#rect矩形类"></a> RECT矩形类</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RECT</span> &#123;</span></span><br><span class="line">LONG left;</span><br><span class="line">LONG top;</span><br><span class="line">LONG right;</span><br><span class="line">LONG bottom;</span><br><span class="line">&#125; RECT, *PRECT;</span><br></pre></td></tr></table></figure><p><span id="6"></span></p><h3 id="hdc设备上下文句柄"><a class="markdownIt-Anchor" href="#hdc设备上下文句柄"></a> HDC设备上下文句柄</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDC hdc; <span class="comment">//设备上下文句柄</span></span><br></pre></td></tr></table></figure><p><span id="7"></span></p><h3 id="paintstruct-包含了某应用程序用来绘制它所拥有的窗口客户区所需要的信息的结构体"><a class="markdownIt-Anchor" href="#paintstruct-包含了某应用程序用来绘制它所拥有的窗口客户区所需要的信息的结构体"></a> PAINTSTRUCT 包含了某应用程序用来绘制它所拥有的窗口客户区所需要的信息的结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPAINTSTRUCT</span> &#123;</span></span><br><span class="line">HDC hdc;</span><br><span class="line">BOOL fErase;</span><br><span class="line">RECT rcPaint;</span><br><span class="line">BOOL fRestore;</span><br><span class="line">BOOL fIncUpdate;</span><br><span class="line">BYTE rgbReserved[<span class="number">32</span>];</span><br><span class="line">&#125; PAINTSTRUCT, *PPAINTSTRUCT;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT ps; <span class="comment">//绘制结构</span></span><br></pre></td></tr></table></figure><p><span id="8"></span></p><h3 id="beginpaint-指定窗口进行绘图工作的准备并用将和绘图有关的信息填充到一个paintstruct结构中"><a class="markdownIt-Anchor" href="#beginpaint-指定窗口进行绘图工作的准备并用将和绘图有关的信息填充到一个paintstruct结构中"></a> BeginPaint 指定窗口进行绘图工作的准备，并用将和绘图有关的信息填充到一个PAINTSTRUCT结构中</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HDC <span class="title">BeginPaint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HWND hwnd, <span class="comment">// 窗口的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPPAINTSTRUCT lpPaint <span class="comment">// 绘制信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdc = BeginPaint(hwnd,&amp;ps); <span class="comment">//获取设备上下文句柄</span></span><br></pre></td></tr></table></figure><p><span id="9"></span></p><h3 id="endpaint释放设备上下文句柄"><a class="markdownIt-Anchor" href="#endpaint释放设备上下文句柄"></a> EndPaint释放设备上下文句柄</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EndPaint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HWND hWnd, <span class="comment">// 窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">CONST PAINTSTRUCT *lpPaint <span class="comment">// 绘制窗口的数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EndPaint(hwnd,&amp;ps);//释放设备上下文句柄</span><br></pre></td></tr></table></figure><p><span id="10"></span>&gt;</p><h3 id="getclientrect获取窗口客户区大小"><a class="markdownIt-Anchor" href="#getclientrect获取窗口客户区大小"></a> GetClientRect获取窗口客户区大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetClientRect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HWND hWnd, <span class="comment">// 窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPRECT lpRect <span class="comment">// 客户区坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetClientRect(hwnd, &amp;rect);<span class="comment">//获取窗口客户区大小</span></span><br></pre></td></tr></table></figure><p><span id="11"></span></p><h3 id="ellipse在窗口客户区画一个椭圆"><a class="markdownIt-Anchor" href="#ellipse在窗口客户区画一个椭圆"></a> Ellipse在窗口客户区画一个椭圆</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Ellipse</span><span class="params">(HDC hdc,<span class="comment">//设备环境句柄。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> nLeftRect, <span class="comment">//指定限定矩形左上角的X坐标。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> nTopRect, <span class="comment">//指定限定矩形左上角的Y坐标。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> nRightRect, <span class="comment">//指定限定矩形右下角的X坐标。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> nBottomRect <span class="comment">//指定限定矩形右下角的Y坐标。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ellipse(hdc, 0, 0, 200, 100); //在窗口客户区画一个椭圆</span><br></pre></td></tr></table></figure><p><span id="12"></span></p><h3 id="drawtext在窗口打印文字"><a class="markdownIt-Anchor" href="#drawtext在窗口打印文字"></a> DrawText在窗口打印文字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawText</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HDC hDC, <span class="comment">// 设备描述表句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPCTSTR lpString, <span class="comment">// 将要绘制的字符串</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> nCount, <span class="comment">// 字符串的长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPRECT lpRect, <span class="comment">// 指向矩形结构RECT的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">UINT uFormat <span class="comment">// 正文的绘制选项</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DrawText(hdc, TEXT(<span class="string">"Hello Windows SDK"</span>), <span class="number">-1</span>, &amp;rect,</span><br><span class="line">DT_SINGLELINE | DT_CENTER | DT_VCENTER</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>DT_SINGLELINE   单行显示文本，回车和换行符都不断行。</p><p>DT_CENTER   指定文本水平居中显示。</p><p>DT_VCENTER   指定文本垂直居中显示。该标记只在单行文本输出时有效，所以它必须与DT_SINGLELINE结合使用。</p><br><p><span id="13"></span></p><h3 id="句柄"><a class="markdownIt-Anchor" href="#句柄"></a> 句柄</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">HINSTANCE</td><td style="text-align:center">实例化句柄</td></tr><tr><td style="text-align:center">HWND</td><td style="text-align:center">窗口句柄</td></tr><tr><td style="text-align:center">HDC</td><td style="text-align:center">设备上下文句柄</td></tr><tr><td style="text-align:center">HICON</td><td style="text-align:center">图标句柄</td></tr><tr><td style="text-align:center">HCURSOR</td><td style="text-align:center">鼠标句柄</td></tr><tr><td style="text-align:center">HBRUSH</td><td style="text-align:center">画刷句柄</td></tr></tbody></table><p><br><br><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// windows向导.cpp : 定义应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows向导.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LOADSTRING 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量: </span></span><br><span class="line">HINSTANCE hInst;                                <span class="comment">// 当前实例</span></span><br><span class="line">WCHAR szTitle[MAX_LOADSTRING];                  <span class="comment">// 标题栏文本</span></span><br><span class="line">WCHAR szWindowClass[MAX_LOADSTRING];            <span class="comment">// 主窗口类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此代码模块中包含的函数的前向声明: </span></span><br><span class="line"><span class="function">ATOM                <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span>;</span><br><span class="line"><span class="function">BOOL                <span class="title">InitInstance</span><span class="params">(HINSTANCE, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK    <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"><span class="function">INT_PTR CALLBACK    <span class="title">About</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此放置代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局字符串</span></span><br><span class="line">    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);</span><br><span class="line">    LoadStringW(hInstance, IDC_WINDOWS, szWindowClass, MAX_LOADSTRING);</span><br><span class="line">    MyRegisterClass(hInstance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行应用程序初始化: </span></span><br><span class="line">    <span class="keyword">if</span> (!InitInstance (hInstance, nCmdShow))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWS));</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主消息循环: </span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">        &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: MyRegisterClass()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的: 注册窗口类。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">ATOM <span class="title">MyRegisterClass</span><span class="params">(HINSTANCE hInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEXW wcex;</span><br><span class="line"></span><br><span class="line">    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line"></span><br><span class="line">    wcex.style          = CS_HREDRAW | CS_VREDRAW;<span class="comment">//当水平或垂直方向发生变化时就重画</span></span><br><span class="line">    wcex.lpfnWndProc    = WndProc;</span><br><span class="line">    wcex.cbClsExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.cbWndExtra     = <span class="number">0</span>;</span><br><span class="line">    wcex.hInstance      = hInstance;</span><br><span class="line">    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWS));</span><br><span class="line">    wcex.hCursor        = LoadCursor(<span class="literal">nullptr</span>, IDC_ARROW);</span><br><span class="line">    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_WINDOWS);</span></span><br><span class="line">wcex.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">    wcex.lpszClassName  = szWindowClass;</span><br><span class="line">    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RegisterClassExW(&amp;wcex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   函数: InitInstance(HINSTANCE, int)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   目的: 保存实例句柄并创建主窗口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   注释: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        在此函数中，我们在全局变量中保存实例句柄并</span></span><br><span class="line"><span class="comment">//        创建和显示主程序窗口。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitInstance</span><span class="params">(HINSTANCE hInstance, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   hInst = hInstance; <span class="comment">// 将实例句柄存储在全局变量中</span></span><br><span class="line"></span><br><span class="line">   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,</span><br><span class="line">      CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInstance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hWnd)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ShowWindow(hWnd, nCmdShow);</span><br><span class="line">   UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目的:    处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND  - 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT    - 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY  - 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RECT rect;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//case WM_COMMAND:</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        int wmId = LOWORD(wParam);</span></span><br><span class="line">    <span class="comment">//        // 分析菜单选择: </span></span><br><span class="line">    <span class="comment">//        switch (wmId)</span></span><br><span class="line">    <span class="comment">//        &#123;</span></span><br><span class="line">    <span class="comment">//        case IDM_ABOUT:</span></span><br><span class="line">    <span class="comment">//            DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);</span></span><br><span class="line">    <span class="comment">//            break;</span></span><br><span class="line">    <span class="comment">//        case IDM_EXIT:</span></span><br><span class="line">    <span class="comment">//            DestroyWindow(hWnd);</span></span><br><span class="line">    <span class="comment">//            break;</span></span><br><span class="line">    <span class="comment">//        default:</span></span><br><span class="line">    <span class="comment">//            return DefWindowProc(hWnd, message, wParam, lParam);</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    break;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_CREATE: <span class="comment">//窗口在创建过程中触发的第一个消息</span></span><br><span class="line"><span class="comment">//SND_ASYNC 异步播放 </span></span><br><span class="line"><span class="comment">//SND_FILENAME 文件名</span></span><br><span class="line"><span class="comment">//需要在项目属性-&gt;链接器-&gt;输入-&gt;附加依赖项中添加winmm.lib</span></span><br><span class="line"><span class="comment">//PlaySound(TEXT("2.wav"),NULL,SND_FILENAME | SND_ASYNC); </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">&#123;</span><br><span class="line">PAINTSTRUCT ps;</span><br><span class="line">HDC hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处添加使用 hdc 的任何绘图代码...</span></span><br><span class="line">GetClientRect(hWnd, &amp;rect);</span><br><span class="line">Ellipse(hdc,<span class="number">0</span>,<span class="number">0</span>,rect.right,rect.bottom);</span><br><span class="line">DrawText(hdc, TEXT(<span class="string">"我爱你"</span>), <span class="number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “关于”框的消息处理程序。</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">About</span><span class="params">(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(lParam);</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)</span><br><span class="line">        &#123;</span><br><span class="line">            EndDialog(hDlg, LOWORD(wParam));</span><br><span class="line">            <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;windows向导及句柄&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#windows向导及句柄&quot;&gt;&lt;/a&gt; windows向导及句柄&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;最好把&lt;code&gt;stdafx.h&lt;/
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows模型</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/30/pwcp003-Windows%E6%A8%A1%E5%9E%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/30/pwcp003-Windows模型/</id>
    <published>2021-05-30T12:06:53.000Z</published>
    <updated>2021-05-31T01:01:51.246Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javawz/1622376428133.png" alt="1622376428133"></p><p>HWND H代表句柄,WND代表窗口</p><p>HINSTANCE  实例句柄,只要是一个已经存在的程序或窗口等,都称为实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口回调函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">PSTR szCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> iCmdShow</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HWND hwnd;<span class="comment">//实例句柄</span></span><br><span class="line">MSG msg;<span class="comment">//消息</span></span><br><span class="line">WNDCLASS wc;<span class="comment">//窗口类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.设计一个窗口类</span></span><br><span class="line">wc.style = <span class="number">0</span>;<span class="comment">//窗口样式</span></span><br><span class="line">wc.lpfnWndProc = (WNDPROC)WndProc;<span class="comment">//窗口回调函数</span></span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;<span class="comment">//额外窗口类的内存</span></span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;<span class="comment">//额外窗口内存</span></span><br><span class="line">wc.hInstance = hInstance;<span class="comment">//窗口的实例句柄</span></span><br><span class="line">wc.hIcon = LoadIcon(<span class="literal">NULL</span>,IDI_WINLOGO);<span class="comment">//窗口图标</span></span><br><span class="line">wc.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);<span class="comment">//箭头鼠标</span></span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);<span class="comment">//窗口颜色</span></span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;<span class="comment">//窗口菜单</span></span><br><span class="line">wc.lpszClassName = TEXT(<span class="string">"MyWndClass"</span>);<span class="comment">//窗口类名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.注册窗口类</span></span><br><span class="line">RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建窗口</span></span><br><span class="line">hwnd = CreateWindow(</span><br><span class="line">TEXT(<span class="string">"MyWndClass"</span>),<span class="comment">//窗口类名</span></span><br><span class="line">TEXT(<span class="string">"窗口标题"</span>),<span class="comment">//窗口标题</span></span><br><span class="line">WS_OVERLAPPEDWINDOW,<span class="comment">//窗口风格</span></span><br><span class="line">CW_USEDEFAULT,<span class="comment">//窗口X坐标位置  默认</span></span><br><span class="line">CW_USEDEFAULT,<span class="comment">//窗口Y坐标位置  默认</span></span><br><span class="line">CW_USEDEFAULT,<span class="comment">//宽度  默认</span></span><br><span class="line">CW_USEDEFAULT,<span class="comment">//高度  默认</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//父窗口句柄</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//菜单句柄</span></span><br><span class="line">hInstance,<span class="comment">//窗口实例句柄</span></span><br><span class="line"><span class="literal">NULL</span><span class="comment">//用户数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.显示和更新窗口</span></span><br><span class="line">ShowWindow(hwnd, iCmdShow);</span><br><span class="line">UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.消息循环</span></span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把键盘输入翻译成为可传递的消息</span></span><br><span class="line">TranslateMessage(&amp;msg);</span><br><span class="line"><span class="comment">//转发消息到窗口过程函数</span></span><br><span class="line">DispatchMessage(&amp;msg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回消息参数</span></span><br><span class="line"><span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HWND hwnd,</span></span></span><br><span class="line"><span class="function"><span class="params">UINT message,</span></span></span><br><span class="line"><span class="function"><span class="params">WPARAM wParam,</span></span></span><br><span class="line"><span class="function"><span class="params">LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//是一种包含了某应用程序用来绘制它所拥有的窗口客户区所需要的信息的结构体</span></span><br><span class="line">PAINTSTRUCT ps; <span class="comment">//绘制结构</span></span><br><span class="line"></span><br><span class="line">HDC hdc; <span class="comment">//设备上下文句柄</span></span><br><span class="line"></span><br><span class="line">RECT rect;<span class="comment">//矩形框</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (message)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_SIZE:<span class="comment">//窗口的大小发生改变时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line"><span class="comment">/*MessageBox(hwnd, TEXT("Hello Windows SDK"), TEXT("Windows"), MB_OK);*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> WM_PAINT:<span class="comment">//打印消息</span></span><br><span class="line">hdc = BeginPaint(hwnd,&amp;ps); <span class="comment">//获取设备上下文句柄</span></span><br><span class="line"></span><br><span class="line">GetClientRect(hwnd, &amp;rect);<span class="comment">//获取窗口客户区大小</span></span><br><span class="line">Ellipse(hdc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">100</span>); <span class="comment">//在窗口客户区画一个椭圆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定的矩形里写入格式化的正文，根据指定的方法对正文格式化</span></span><br><span class="line"><span class="comment">//DrawText(hdc, 将要绘制的字符串,字符串的长度,指向矩形结构RECT的指针, 正文的绘制选项)</span></span><br><span class="line">            <span class="comment">//-1代表全部输出</span></span><br><span class="line">DrawText(hdc, TEXT(<span class="string">"Hello Windows SDK"</span>), <span class="number">-1</span>, &amp;rect,</span><br><span class="line">DT_SINGLELINE | DT_CENTER | DT_VCENTER</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">EndPaint(hwnd,&amp;ps);<span class="comment">//释放设备上下文句柄</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:<span class="comment">//销毁窗口消息(关闭)</span></span><br><span class="line">PostQuitMessage(<span class="number">0</span>);<span class="comment">//将0放入消息队列中,让GetMessage获取,然后退出消息循环</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把不需要处理的消息交给操作系统处理</span></span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hwnd,message,wParam,lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javawz/1622376428133.png&quot; alt=&quot;1622376428133&quot;&gt;&lt;/p&gt;
&lt;p&gt;HWND H代表句柄,WND代表窗口&lt;/p&gt;
&lt;p&gt;HINSTANCE  实例句柄,只要是一个已经存在的程序或窗口等,都称为实例&lt;
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>Unicode简介</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/30/pwcp002-Unicode%E7%AE%80%E4%BB%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/30/pwcp002-Unicode简介/</id>
    <published>2021-05-30T06:38:31.000Z</published>
    <updated>2021-05-30T13:26:11.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="unicode简介"><a class="markdownIt-Anchor" href="#unicode简介"></a> Unicode简介</h1><table><thead><tr><th style="text-align:center">两种字符集</th><th style="text-align:center">ASCII</th><th style="text-align:center">Unicode(宽字符)</th></tr></thead><tbody><tr><td style="text-align:center">两种字符类型</td><td style="text-align:center">char</td><td style="text-align:center">wchar_t</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">CHAR</td><td style="text-align:center">WCHAR</td></tr><tr><td style="text-align:center">函数的两种版本</td><td style="text-align:center">printf</td><td style="text-align:center">wprintf</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">strlen</td><td style="text-align:center">wcslen</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">MessageBoxA</td><td style="text-align:center">MessageBoxW</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">PCHAR</td><td style="text-align:center">PWCHAR</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">通用版本</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">_tcslen</td><td style="text-align:center">MessageBox</td><td style="text-align:center">TCHAR</td></tr><tr><td style="text-align:center">PTCHAR</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">通用宏</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">TEXT</td><td style="text-align:center">_<em>TEXT</em></td><td style="text-align:center">__T</td></tr><tr><td style="text-align:center">_T</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ASCII 版本  多字节字符集   双字节字符集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"我爱你"</span>;</span><br><span class="line">CHAR a2 = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">strlen</span>(str));</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, str, <span class="literal">NULL</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Unicode 版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">setlocale(LC_ALL, <span class="string">"chs"</span>);</span><br><span class="line"><span class="keyword">wchar_t</span> a = L'A';</span><br><span class="line"><span class="keyword">wchar_t</span> str[] = <span class="string">L"我爱你"</span>;</span><br><span class="line">WCHAR a2 = L'A';</span><br><span class="line"></span><br><span class="line">wprintf(<span class="string">L"%lc\n"</span>, a);</span><br><span class="line">wprintf(<span class="string">L"%ls\n"</span>, str);</span><br><span class="line">wprintf(<span class="string">L"%d\n"</span>, wcslen(str));  <span class="comment">//这里显示3个字符,是因为把两个字节当一个字符处理</span></span><br><span class="line">MessageBoxW(<span class="literal">NULL</span>, str, <span class="literal">NULL</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通用版本,一般使用这个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setlocale(LC_ALL, <span class="string">"chs"</span>);</span><br><span class="line">TCHAR a = TEXT(<span class="string">'A'</span>);</span><br><span class="line">TCHAR str[] = TEXT(<span class="string">"我爱你"</span>);</span><br><span class="line">TCHAR a2 = TEXT(<span class="string">'A'</span>);</span><br><span class="line"></span><br><span class="line">MessageBox(<span class="literal">NULL</span>, str, <span class="literal">NULL</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test1();</span><br><span class="line">test2();</span><br><span class="line">test3();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Windows中使用sprintf</th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>ASCII版本</td><td>宽字符版本</td><td>通用版本</td></tr><tr><td>可变数目的参数</td><td></td><td></td><td></td></tr><tr><td>标准版</td><td>sprintf</td><td>swprintf</td><td><code>_stprintf</code></td></tr><tr><td>最大长度版</td><td>_snprintf</td><td>_snwprintf</td><td><code>_sntprintf</code></td></tr><tr><td>windows版</td><td>wsprintfA</td><td>wsprintfW</td><td>wsprintf</td></tr><tr><td>-----------------------</td><td>---------</td><td>---------</td><td>---------</td></tr><tr><td>参数数组的指针</td><td></td><td></td><td></td></tr><tr><td>标准版</td><td>vsprintf</td><td>vswprintf</td><td>vstprintf</td></tr><tr><td>最大长度版</td><td>_vsnprintf</td><td>_vsnwprintf</td><td><code>_vsntprintf</code></td></tr><tr><td>windows版</td><td>wvsprintfA</td><td>wvsprintfW</td><td>wvsprintf</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>_CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义ASCII格式化MessageBox函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> CDECL <span class="title">MessageBoxPrintfA</span><span class="params">(<span class="keyword">char</span> *szCaption, <span class="keyword">char</span> *szFormat, ...)</span></span>;</span><br><span class="line"><span class="comment">//自定义Unicode格式化MessageBox函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> CDECL <span class="title">MessageBoxPrintfW</span><span class="params">(<span class="keyword">wchar_t</span> *szCaption, <span class="keyword">wchar_t</span> *szFormat, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义通用格式化MessageBox函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> CDECL <span class="title">MessageBoxPrintf</span><span class="params">(TCHAR *szCaption, TCHAR *szFormat, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ASCII 版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">char</span> szBuffer[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不安全版本</span></span><br><span class="line"><span class="built_in">sprintf</span>(szBuffer, <span class="string">"我爱你%d"</span>, a);</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>,szBuffer,<span class="string">"ASCII 不安全版本"</span>,MB_OK);</span><br><span class="line"></span><br><span class="line"><span class="comment">//安全版本</span></span><br><span class="line">_snprintf(szBuffer, <span class="number">100</span>,<span class="string">"我爱你%d"</span>, a);</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, szBuffer, <span class="string">"ASCII 安全版本"</span>, MB_OK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Unicode 版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> szBuffer[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">swprintf(szBuffer,<span class="number">100</span>, <span class="string">L"我爱你%d"</span>, a);</span><br><span class="line"></span><br><span class="line">MessageBoxW(<span class="literal">NULL</span>, szBuffer, <span class="string">L"Unicode 版本"</span>, MB_OK);</span><br><span class="line"></span><br><span class="line"><span class="comment">//安全版本</span></span><br><span class="line">_snwprintf(szBuffer,<span class="number">100</span>,<span class="string">L"我爱你%d"</span>, a);</span><br><span class="line"></span><br><span class="line">MessageBoxW(<span class="literal">NULL</span>, szBuffer, <span class="string">L"Unicode 版本"</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通用版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line">TCHAR szBuffer[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//通用不安全版本</span></span><br><span class="line">_stprintf(szBuffer, TEXT(<span class="string">"我爱你%d"</span>), a);</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, szBuffer, TEXT(<span class="string">"通用不安全版本"</span>), MB_OK);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用安全版本</span></span><br><span class="line">_sntprintf(szBuffer, <span class="number">100</span>, TEXT(<span class="string">"我爱你%d"</span>), a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MessageBox(<span class="literal">NULL</span>, szBuffer, TEXT(<span class="string">"通用安全版本"</span>), MB_OK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MessageBoxPrintf(TEXT(<span class="string">"MessageBoxPrintf 标题"</span>), TEXT(<span class="string">"我爱你%d%d"</span>), <span class="number">13</span>, <span class="number">14</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MessageBoxPrintfA(<span class="string">"MessageBoxPrintf 标题"</span>, <span class="string">"我爱你%d%d"</span>, <span class="number">13</span>, <span class="number">14</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MessageBoxPrintfW(<span class="string">L"MessageBoxPrintf 标题"</span>, <span class="string">L"我爱你%d%d"</span>, <span class="number">13</span>, <span class="number">14</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">PSTR szCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> iCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test1();//ASCII</span></span><br><span class="line"><span class="comment">//test2();//Unicode</span></span><br><span class="line"><span class="comment">//test3();//通用版本</span></span><br><span class="line"><span class="comment">//test4();//通用版本格式化MessageBox</span></span><br><span class="line">test5();<span class="comment">//ASCII本格式化MessageBox</span></span><br><span class="line">test6();<span class="comment">//Unicode本格式化MessageBox</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义通用格式化MessageBox函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> CDECL <span class="title">MessageBoxPrintf</span><span class="params">(TCHAR *szCaption, TCHAR *szFormat, ...)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">va_list pArgs;<span class="comment">//用来接收...参数</span></span><br><span class="line">TCHAR szBuffer[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//获取...第一个参数的地址</span></span><br><span class="line">va_start(pArgs, szFormat);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用版本_vsntprintf根据平台来决定是ASCII还是Unicode</span></span><br><span class="line"><span class="comment">//_vsntprintf(通用缓冲区,缓冲区大小,格式字符串,可变参数变量)</span></span><br><span class="line"><span class="comment">//将szFormat,pArgs的内容放到szBuffer中,并将szFormat中的%xxx,对应替换成pArgs</span></span><br><span class="line">_vsntprintf(szBuffer, <span class="keyword">sizeof</span>(szBuffer) / <span class="keyword">sizeof</span>(TCHAR), szFormat, pArgs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束对pArgs变量的使用</span></span><br><span class="line">va_end(pArgs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MessageBox(<span class="literal">NULL</span>, szBuffer, szCaption, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义ASCII格式化MessageBox函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> CDECL <span class="title">MessageBoxPrintfA</span><span class="params">(<span class="keyword">char</span> *szCaption, <span class="keyword">char</span> *szFormat, ...)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">va_list pArgs;<span class="comment">//用来接收...参数</span></span><br><span class="line"><span class="keyword">char</span> szBuffer[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//获取...第一个参数的地址</span></span><br><span class="line">va_start(pArgs, szFormat);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ASCII版本_vsnprintf</span></span><br><span class="line"><span class="comment">//_vsntprintf(ASCII缓冲区,缓冲区大小,格式字符串,可变参数变量)</span></span><br><span class="line"><span class="comment">//将szFormat,pArgs的内容放到szBuffer中,并将szFormat中的%xxx,对应替换成pArgs</span></span><br><span class="line">_vsnprintf(szBuffer, <span class="keyword">sizeof</span>(szBuffer) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>), szFormat, pArgs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束对pArgs变量的使用</span></span><br><span class="line">va_end(pArgs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MessageBoxA(<span class="literal">NULL</span>, szBuffer, szCaption, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义Unicode格式化MessageBox函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> CDECL <span class="title">MessageBoxPrintfW</span><span class="params">(<span class="keyword">wchar_t</span> *szCaption, <span class="keyword">wchar_t</span> *szFormat, ...)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">va_list pArgs;<span class="comment">//用来接收...参数</span></span><br><span class="line"><span class="keyword">wchar_t</span> szBuffer[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//获取...第一个参数的地址</span></span><br><span class="line">va_start(pArgs, szFormat);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unicode版本_vsnwprintf</span></span><br><span class="line"><span class="comment">//_vsntprintf(Unicode缓冲区,缓冲区大小,格式字符串,可变参数变量)</span></span><br><span class="line"><span class="comment">//将szFormat,pArgs的内容放到szBuffer中,并将szFormat中的%xxx,对应替换成pArgs</span></span><br><span class="line">_vsnwprintf(szBuffer, <span class="keyword">sizeof</span>(szBuffer) / <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>), szFormat, pArgs);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//结束对pArgs变量的使用</span></span><br><span class="line">va_end(pArgs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MessageBoxW(<span class="literal">NULL</span>, szBuffer, szCaption, MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/1622369585719.png" alt="1622369585719"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;unicode简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#unicode简介&quot;&gt;&lt;/a&gt; Unicode简介&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;两种字
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>第一个Windows程序</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/30/pwcp001-%E7%AC%AC%E4%B8%80%E4%B8%AAWindows%E7%A8%8B%E5%BA%8F/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/30/pwcp001-第一个Windows程序/</id>
    <published>2021-05-30T06:34:55.000Z</published>
    <updated>2021-05-30T06:37:38.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个windows程序"><a class="markdownIt-Anchor" href="#第一个windows程序"></a> 第一个Windows程序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,PSTR szCmdLine,int iCmdShow)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">WINAPI 是____stdcall</span></span><br><span class="line"><span class="comment">WinMain 是入口函数</span></span><br><span class="line"><span class="comment">HINSTANCE实例句柄类型</span></span><br><span class="line"><span class="comment">HINSTANCE hInstance本模块的实例句柄</span></span><br><span class="line"><span class="comment">HINSTANCE hPrevInstance 是旧时代的,Win16留下来的,</span></span><br><span class="line"><span class="comment">PSTR szCmdLine 命令行参数</span></span><br><span class="line"><span class="comment">int iCmdShow 主窗口初始化时显示方式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance,HINSTANCE hPrevInstance,PSTR szCmdLine,<span class="keyword">int</span> iCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">MessageBox(<span class="literal">NULL</span>,TEXT(<span class="string">"我爱你,小麦老婆"</span>),TEXT(<span class="string">"这是标题"</span>),MB_OK);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MessageBox(NULL,TEXT("我爱你,小麦老婆"),TEXT("这是标题"),MB_OK);</span></span><br><span class="line"><span class="comment">MessageBox 对话框函数</span></span><br><span class="line"><span class="comment">参数1: 窗口句柄</span></span><br><span class="line"><span class="comment">参数2:对话框内容</span></span><br><span class="line"><span class="comment">参数3:标题</span></span><br><span class="line"><span class="comment">参数4:标志显示消息框中的按钮以及图标。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>WINAPI 是__stdcall</p><p>WinMain 是入口函数</p><p>HINSTANCE实例句柄类型</p><p>HINSTANCE hInstance本模块的实例句柄</p><p>HINSTANCE hPrevInstance 是旧时代的,Win16留下来的,</p><p>PSTR szCmdLine 命令行参数</p><p>int iCmdShow 主窗口初始化时显示方式</p><p>MessageBox(NULL,TEXT(“我爱你,小麦老婆”),TEXT(“这是标题”),MB_OK);</p><p>MessageBox 对话框函数</p><p>参数1: 窗口句柄</p><p>参数2:对话框内容</p><p>参数3:标题</p><p>参数4:标志显示消息框中的按钮以及图标。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一个windows程序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一个windows程序&quot;&gt;&lt;/a&gt; 第一个Windows程序&lt;/h1&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
      <category term="windows程序设计2" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"/>
    
    
  </entry>
  
  <entry>
    <title>设计自己的线程局部存储</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/28/win0004-%E8%AE%BE%E8%AE%A1%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/28/win0004-设计自己的线程局部存储/</id>
    <published>2021-05-28T01:31:12.000Z</published>
    <updated>2021-06-08T14:34:41.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计自己的线程局部存储"><a class="markdownIt-Anchor" href="#设计自己的线程局部存储"></a> 设计自己的线程局部存储</h1><p>（1）自动管理它所保存的指针所指向的内存单元的分配和释放。这样做，一方面大大方<br>便了用户使用，另一方面，在一个线程不使用线程局部变量的情况下，管理系统可以决定不为<br>这个线程分配内存，从而节省内存空间。</p><p>（2）允许用户申请使用任意多个TLS索引。Microsoft确保每个进程的位数组中至少有TLS_MINIMUM_AVAILABLE个位标志是可用的。在WinNTh文件中这个值被定义为64，Windows 2000又做了扩展，使至少1000个标志可用。</p><h3 id="新的tls主要由4个类组成"><a class="markdownIt-Anchor" href="#新的tls主要由4个类组成"></a> 新的TLS主要由4个类组成</h3><p>CSimpleList类负责实现简单的链表功能，把各线程私有数据连在一起，以便能够释放它们占用的内存；</p><p>CNoTrackObject类重载了new和delete操作符，负责为线程私有数据分配内存空间；</p><p>CThreadSlotData类是整个系统的核心，它负责分配索引和存取线程私有数据；</p><p>CThreadLocal是最终提供给用户使用的类模板，它负责为用户提供友好的接口函数。</p><p><img src="/images/javawz/1622167447633.png" alt="1622167447633"></p><p>线程的私有数据是自己自定义的结构或类,需要继承CNoTrackObject类</p><p>一个存放线程私有数据的数据结构CThreadData</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// _AFXTLS_.H文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __AFXTLS_H__  <span class="comment">// _AFXTLS_.H 文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __AFXTLS_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNoTrackObject</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// CSimpleList</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSimpleList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">CSimpleList(<span class="keyword">int</span> nNextOffset = <span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置数据结构中pNext成员的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Construct</span><span class="params">(<span class="keyword">int</span> nNextOffset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供给用户的接口函数（Operations），用于添加、删除和遍历节点</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//判断是否为空链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;<span class="comment">//添加节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveAll</span><span class="params">()</span></span>;<span class="comment">//删除所有结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">GetHead</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//获取头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">GetNext</span><span class="params">(<span class="keyword">void</span>* p)</span> <span class="keyword">const</span></span>;<span class="comment">//获取下一个结点</span></span><br><span class="line"><span class="function">BOOL <span class="title">Remove</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;<span class="comment">//删除结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为实现接口函数所需的成员（Implementation）</span></span><br><span class="line"><span class="keyword">void</span>* m_pHead;<span class="comment">// 链表中第一个元素的地址</span></span><br><span class="line"><span class="keyword">size_t</span> m_nNextOffset;<span class="comment">// 数据结构中pNext成员的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>** <span class="title">GetNextPtr</span><span class="params">(<span class="keyword">void</span>* p)</span> <span class="keyword">const</span></span>;<span class="comment">//获取pNext的偏移地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的内联函数</span></span><br><span class="line"><span class="keyword">inline</span> CSimpleList::CSimpleList(<span class="keyword">int</span> nNextOffset)</span><br><span class="line">&#123; m_pHead = <span class="literal">NULL</span>; m_nNextOffset = nNextOffset; &#125;</span><br><span class="line"><span class="comment">//设置数据结构中pNext成员的偏移量</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> CSimpleList::Construct(<span class="keyword">int</span> nNextOffset)</span><br><span class="line">&#123; m_nNextOffset = nNextOffset; &#125;</span><br><span class="line"><span class="comment">//判断链表为空,返回NULL</span></span><br><span class="line"><span class="keyword">inline</span> BOOL CSimpleList::IsEmpty() <span class="keyword">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> m_pHead == <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="comment">//移除所有结点</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> CSimpleList::RemoveAll()</span><br><span class="line">&#123; m_pHead = <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="comment">//获取头节点</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* CSimpleList::GetHead() <span class="keyword">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> m_pHead; &#125;</span><br><span class="line"><span class="comment">//获取下一个结点的地址</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* CSimpleList::GetNext(<span class="keyword">void</span>* preElement) <span class="keyword">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> *GetNextPtr(preElement); &#125;</span><br><span class="line"><span class="comment">//获取数据结构中pNext成员的偏移量</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>** CSimpleList::GetNextPtr(<span class="keyword">void</span>* p) <span class="keyword">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> (<span class="keyword">void</span>**)((BYTE*)p + m_nNextOffset); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">TYPE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CTypedSimpleList</span> :</span> <span class="keyword">public</span> CSimpleList</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CTypedSimpleList(<span class="keyword">int</span> nNextOffset = <span class="number">0</span>) </span><br><span class="line">: CSimpleList(nNextOffset) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddHead</span><span class="params">(TYPE p)</span> </span></span><br><span class="line"><span class="function"></span>&#123; CSimpleList::AddHead((<span class="keyword">void</span>*)p); &#125;</span><br><span class="line"><span class="function">TYPE <span class="title">GetHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (TYPE)CSimpleList::GetHead(); &#125;</span><br><span class="line"><span class="function">TYPE <span class="title">GetNext</span><span class="params">(TYPE p)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (TYPE)CSimpleList::GetNext(p); &#125;</span><br><span class="line"><span class="function">BOOL <span class="title">Remove</span><span class="params">(TYPE p)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> CSimpleList::Remove(p); &#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">TYPE</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (TYPE)CSimpleList::GetHead(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// CNoTrackObject</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNoTrackObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> nSize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="keyword">virtual</span> ~CNoTrackObject() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// CThreadSlotData - 管理我们自己的线程局部存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// warning C4291: no matching operator delete found</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4291) </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CSlotData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CThreadData</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThreadSlotData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CThreadSlotData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供给用户的接口函数（Operations）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AllocSlot</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeSlot</span><span class="params">(<span class="keyword">int</span> nSlot)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">GetThreadValue</span><span class="params">(<span class="keyword">int</span> nSlot)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">int</span> nSlot, <span class="keyword">void</span>* pValue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteValues</span><span class="params">(HINSTANCE hInst, BOOL bAll = FALSE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的实现代码（Implementations）</span></span><br><span class="line">DWORD m_tlsIndex;<span class="comment">// 用来访问系统提供的线程局部存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_nAlloc;<span class="comment">//  m_pSlotData所指向数组的大小</span></span><br><span class="line"><span class="keyword">int</span> m_nRover;<span class="comment">// 为了快速找到一个空闲的槽而设定的值</span></span><br><span class="line"><span class="keyword">int</span> m_nMax;<span class="comment">// CThreadData结构中pData指向的数组的大小</span></span><br><span class="line">CSlotData* m_pSlotData;<span class="comment">// 标识每个槽状态的全局数组的首地址</span></span><br><span class="line">CTypedSimpleList&lt;CThreadData*&gt; m_list;<span class="comment">// CThreadData结构的列表</span></span><br><span class="line">CRITICAL_SECTION m_cs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteValues</span><span class="params">(CThreadData* pData, HINSTANCE hInst)</span></span>;</span><br><span class="line">~CThreadSlotData();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThreadLocalObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 属性成员(Attributes)，用于取得保存在线程局部的变量中的指针</span></span><br><span class="line"><span class="function">CNoTrackObject* <span class="title">GetData</span><span class="params">(CNoTrackObject* (*pfnCreateObject)())</span></span>;</span><br><span class="line"><span class="function">CNoTrackObject* <span class="title">GetDataNA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现(Implementation)</span></span><br><span class="line">DWORD m_nSlot;</span><br><span class="line">~CThreadLocalObject();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">TYPE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CThreadLocal</span> :</span> <span class="keyword">public</span> CThreadLocalObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 属性成员（Attributes）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">TYPE* <span class="title">GetData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TYPE* pData = (TYPE*)CThreadLocalObject::GetData(&amp;CreateObject);</span><br><span class="line"><span class="keyword">return</span> pData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TYPE* <span class="title">GetDataNA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TYPE* pData = (TYPE*)CThreadLocalObject::GetDataNA();</span><br><span class="line"><span class="keyword">return</span> pData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> TYPE*()</span><br><span class="line">&#123; <span class="keyword">return</span> GetData(); &#125;</span><br><span class="line">TYPE* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123; <span class="keyword">return</span> GetData(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现（Implementation）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> CNoTrackObject* <span class="title">CreateObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> TYPE; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_LOCAL(cla.ss_name, ident_name) \</span></span><br><span class="line">CThreadLocal&lt;class_name&gt; ident_name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTERN_THREAD_LOCAL(class_name, ident_name) \</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">THREAD_LOCAL</span><span class="params">(class_name, ident_name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __AFXTLS_H__</span></span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">2.2.4 </span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">#ifndef __AFXTLS_H__  // _AFXTLS_.H 文件</span></span></span><br><span class="line"><span class="function"><span class="comment">#define __AFXTLS_H__</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">#include &lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">class CThreadLocalObject</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">public:</span></span></span><br><span class="line"><span class="function"><span class="comment">CThreadLocalObject();</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">// 属性成员(Attributes)，用于取得保存在线程局部的变量中的指针</span></span></span><br><span class="line"><span class="function"><span class="comment">LPVOID GetData(LPVOID (*pfnCreateObject)());</span></span></span><br><span class="line"><span class="function"><span class="comment">LPVOID GetDataNA();</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">// 执行体(Implementation)，实现类接口所需的成员</span></span></span><br><span class="line"><span class="function"><span class="comment">DWORD m_tlsIndex;</span></span></span><br><span class="line"><span class="function"><span class="comment">~CThreadLocalObject();</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">#endif // __AFXTLS_H__</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// AFXTLS.CPP文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"_AFXTLS_.H"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------CSimpleList类---------------------------</span></span><br><span class="line"><span class="comment">//添加节点</span></span><br><span class="line"><span class="keyword">void</span> CSimpleList::AddHead(<span class="keyword">void</span>* p)</span><br><span class="line">&#123;</span><br><span class="line">*GetNextPtr(p) = m_pHead;</span><br><span class="line">m_pHead = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line">BOOL CSimpleList::Remove(<span class="keyword">void</span>* p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>)<span class="comment">// 检查参数</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">BOOL bResult = FALSE; <span class="comment">// 假设移除失败</span></span><br><span class="line"><span class="keyword">if</span>(p == m_pHead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 要移除头元素</span></span><br><span class="line">m_pHead = *GetNextPtr(p);</span><br><span class="line">bResult = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 试图在表中查找要移除的元素</span></span><br><span class="line"><span class="keyword">void</span>* pTest = m_pHead;</span><br><span class="line"><span class="keyword">while</span>(pTest != <span class="literal">NULL</span> &amp;&amp; *GetNextPtr(pTest) != p)</span><br><span class="line">pTest = *GetNextPtr(pTest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果找到，就将元素移除</span></span><br><span class="line"><span class="keyword">if</span>(pTest != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">*GetNextPtr(pTest) = *GetNextPtr(p);</span><br><span class="line">bResult = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------CThreadSlotData类----------------------//</span></span><br><span class="line">BYTE __afxThreadData[<span class="keyword">sizeof</span>(CThreadSlotData)];<span class="comment">// 为下面的_afxThreadData变量提供内存</span></span><br><span class="line">CThreadSlotData* _afxThreadData; <span class="comment">// 定义全局变量_afxThreadData来为全局变量分配空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//槽状态结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CSlotData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD dwFlags;<span class="comment">// 槽的使用标志（被分配/未被分配）</span></span><br><span class="line">HINSTANCE hInst;<span class="comment">// 占用此槽的模块句柄</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//链表节点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CThreadData</span> :</span> <span class="keyword">public</span> CNoTrackObject</span><br><span class="line">&#123;</span><br><span class="line">CThreadData* pNext; <span class="comment">// CSimpleList类要使用此成员</span></span><br><span class="line"><span class="keyword">int</span> nCount;    <span class="comment">// 数组元素的个数</span></span><br><span class="line">LPVOID* pData;      <span class="comment">// 数组的首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLOT_USED 0x01<span class="comment">// CSlotData结构中dwFlags成员的值为0x01时表示该槽已被使用</span></span></span><br><span class="line"><span class="comment">//构造函数,前期的初始化</span></span><br><span class="line">CThreadSlotData::CThreadSlotData()</span><br><span class="line">&#123;</span><br><span class="line">m_list.Construct(offsetof(CThreadData, pNext)); <span class="comment">// 初始化CTypedSimpleList对象</span></span><br><span class="line"></span><br><span class="line">m_nMax = <span class="number">0</span>;</span><br><span class="line">m_nAlloc = <span class="number">0</span>;</span><br><span class="line">m_nRover = <span class="number">1</span>;<span class="comment">// 我们假定Slot1还未被分配（第一个槽（Slot0）总是保留下来不被使用）</span></span><br><span class="line">m_pSlotData = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">m_tlsIndex = ::TlsAlloc();<span class="comment">// 使用系统的TLS申请一个索引</span></span><br><span class="line">::InitializeCriticalSection(&amp;m_cs);<span class="comment">// 初始化关键段变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在位数组上获取可用的槽号</span></span><br><span class="line"><span class="keyword">int</span> CThreadSlotData::AllocSlot()</span><br><span class="line">&#123;</span><br><span class="line">::EnterCriticalSection(&amp;m_cs);<span class="comment">// 进入临界区（也叫关键段）</span></span><br><span class="line"><span class="keyword">int</span> nAlloc = m_nAlloc;</span><br><span class="line"><span class="keyword">int</span> nSlot = m_nRover;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前要使用的槽号大于位数组个数,或当前槽号已经被使用</span></span><br><span class="line"><span class="keyword">if</span>(nSlot &gt;= nAlloc || m_pSlotData[nSlot].dwFlags &amp; SLOT_USED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 搜索m_pSlotData，查找空槽（SLOT）</span></span><br><span class="line"><span class="keyword">for</span>(nSlot = <span class="number">1</span>; nSlot &lt; nAlloc &amp;&amp; m_pSlotData[nSlot].dwFlags &amp; SLOT_USED; nSlot ++) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不存在空槽，申请更多的空间</span></span><br><span class="line"><span class="keyword">if</span>(nSlot &gt;= nAlloc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 增加全局数组的大小，分配或再分配内存以创建新槽</span></span><br><span class="line"><span class="keyword">int</span> nNewAlloc = nAlloc + <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">HGLOBAL hSlotData;</span><br><span class="line"><span class="keyword">if</span>(m_pSlotData == <span class="literal">NULL</span>)<span class="comment">// 第一次使用</span></span><br><span class="line">&#123;</span><br><span class="line">hSlotData = ::GlobalAlloc(GMEM_MOVEABLE, nNewAlloc*<span class="keyword">sizeof</span>(CSlotData));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">//获取当前位数组的句柄</span></span><br><span class="line">hSlotData = ::GlobalHandle(m_pSlotData);</span><br><span class="line">                <span class="comment">//位数组从物理内存中解除</span></span><br><span class="line">::GlobalUnlock(hSlotData);</span><br><span class="line">                <span class="comment">//重新设置位数组的大小</span></span><br><span class="line">hSlotData = ::GlobalReAlloc(hSlotData, </span><br><span class="line">nNewAlloc*<span class="keyword">sizeof</span>(CSlotData), GMEM_MOVEABLE);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//将位数组绑定到物理内存中</span></span><br><span class="line">CSlotData* pSlotData = (CSlotData*)::GlobalLock(hSlotData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新申请的空间初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(pSlotData + m_nAlloc, <span class="number">0</span>, (nNewAlloc - nAlloc)*<span class="keyword">sizeof</span>(CSlotData));</span><br><span class="line">m_nAlloc = nNewAlloc;</span><br><span class="line">m_pSlotData = pSlotData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整m_nMax的值，以便为各线程的私有数据分配内存</span></span><br><span class="line"><span class="keyword">if</span>(nSlot &gt;= m_nMax)</span><br><span class="line">m_nMax = nSlot + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">m_pSlotData[nSlot].dwFlags |= SLOT_USED;</span><br><span class="line"><span class="comment">// 更新m_nRover的值(我们假设下一个槽未被使用)</span></span><br><span class="line">m_nRover = nSlot + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">::LeaveCriticalSection(&amp;m_cs);</span><br><span class="line"><span class="keyword">return</span> nSlot; <span class="comment">// 返回的槽号可以被FreeSlot, GetThreadValue, SetValue函数使用了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadSlotData::FreeSlot(<span class="keyword">int</span> nSlot)</span><br><span class="line">&#123;</span><br><span class="line">::EnterCriticalSection(&amp;m_cs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有线程中的数据</span></span><br><span class="line">CThreadData* pData = m_list;</span><br><span class="line"><span class="keyword">while</span>(pData != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(nSlot &lt; pData-&gt;nCount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> (CNoTrackObject*)pData-&gt;pData[nSlot];</span><br><span class="line">pData-&gt;pData[nSlot] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">pData = pData-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将此槽号标识为未被使用</span></span><br><span class="line">m_pSlotData[nSlot].dwFlags &amp;= ~SLOT_USED;</span><br><span class="line">::LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* CThreadSlotData::GetThreadValue(<span class="keyword">int</span> nSlot)</span><br><span class="line">&#123;</span><br><span class="line">CThreadData* pData = (CThreadData*)::TlsGetValue(m_tlsIndex);</span><br><span class="line"><span class="keyword">if</span>(pData == <span class="literal">NULL</span> || nSlot &gt;= pData-&gt;nCount)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> pData-&gt;pData[nSlot];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadSlotData::SetValue(<span class="keyword">int</span> nSlot, <span class="keyword">void</span>* pValue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 通过TLS索引得到我们为线程安排的私有存储空间</span></span><br><span class="line">CThreadData* pData = (CThreadData*)::TlsGetValue(m_tlsIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为线程私有数据申请内存空间</span></span><br><span class="line"><span class="keyword">if</span>((pData == <span class="literal">NULL</span> || nSlot &gt;= pData-&gt;nCount) &amp;&amp; pValue != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// pData的值为空，表示该线程第一次访问线程私有数据</span></span><br><span class="line"><span class="keyword">if</span>(pData == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pData = <span class="keyword">new</span> CThreadData;</span><br><span class="line">pData-&gt;nCount = <span class="number">0</span>;</span><br><span class="line">pData-&gt;pData = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新申请的内存的地址添加到全局列表中</span></span><br><span class="line">::EnterCriticalSection(&amp;m_cs);</span><br><span class="line">m_list.AddHead(pData);</span><br><span class="line">::LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pData-&gt;pData指向真正的线程私有数据，下面的代码将私有数据占用的空间增长到m_nMax指定的大小</span></span><br><span class="line"><span class="keyword">if</span>(pData-&gt;pData == <span class="literal">NULL</span>)</span><br><span class="line">pData-&gt;pData = (<span class="keyword">void</span>**)::GlobalAlloc(LMEM_FIXED, m_nMax*<span class="keyword">sizeof</span>(LPVOID));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pData-&gt;pData = (<span class="keyword">void</span>**)::GlobalReAlloc(pData-&gt;pData, m_nMax*<span class="keyword">sizeof</span>(LPVOID), LMEM_MOVEABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新申请的内存初始话为0</span></span><br><span class="line"><span class="built_in">memset</span>(pData-&gt;pData + pData-&gt;nCount, <span class="number">0</span>, </span><br><span class="line">(m_nMax - pData-&gt;nCount) * <span class="keyword">sizeof</span>(LPVOID));</span><br><span class="line">pData-&gt;nCount = m_nMax;</span><br><span class="line">::TlsSetValue(m_tlsIndex, pData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程私有数据的值</span></span><br><span class="line">pData-&gt;pData[nSlot] = pValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadSlotData::DeleteValues(HINSTANCE hInst, BOOL bAll)</span><br><span class="line">&#123;</span><br><span class="line">::EnterCriticalSection(&amp;m_cs);</span><br><span class="line"><span class="keyword">if</span>(!bAll)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 仅仅删除当前线程的线程局部存储占用的空间</span></span><br><span class="line">CThreadData* pData = (CThreadData*)::TlsGetValue(m_tlsIndex);</span><br><span class="line"><span class="keyword">if</span>(pData != <span class="literal">NULL</span>)</span><br><span class="line">DeleteValues(pData, hInst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 删除所有线程的线程局部存储占用的空间</span></span><br><span class="line">CThreadData* pData = m_list.GetHead();</span><br><span class="line"><span class="keyword">while</span>(pData != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">CThreadData* pNextData = pData-&gt;pNext;</span><br><span class="line">DeleteValues(pData, hInst);</span><br><span class="line">pData = pNextData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">::LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadSlotData::DeleteValues(CThreadData* pData, HINSTANCE hInst)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 释放表中的每一个元素</span></span><br><span class="line">BOOL bDelete = TRUE;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;pData-&gt;nCount; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hInst == <span class="literal">NULL</span> || m_pSlotData[i].hInst == hInst)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// hInst匹配，删除数据</span></span><br><span class="line"><span class="keyword">delete</span> (CNoTrackObject*)pData-&gt;pData[i];</span><br><span class="line">pData-&gt;pData[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 还有其它模块在使用，不要删除数据</span></span><br><span class="line"><span class="keyword">if</span>(pData-&gt;pData[i] != <span class="literal">NULL</span>)</span><br><span class="line">bDelete = FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bDelete)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 从列表中移除</span></span><br><span class="line">::EnterCriticalSection(&amp;m_cs);</span><br><span class="line">m_list.Remove(pData);</span><br><span class="line">::LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">::LocalFree(pData-&gt;pData);</span><br><span class="line"><span class="keyword">delete</span> pData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除TLS索引，防止重用</span></span><br><span class="line">::TlsSetValue(m_tlsIndex, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CThreadSlotData::~CThreadSlotData()</span><br><span class="line">&#123;</span><br><span class="line">CThreadData *pData = m_list;</span><br><span class="line"><span class="keyword">while</span>(pData != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">CThreadData* pDataNext = pData-&gt;pNext;</span><br><span class="line">DeleteValues(pData, <span class="literal">NULL</span>);</span><br><span class="line">pData = pData-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(m_tlsIndex != (DWORD)<span class="number">-1</span>)</span><br><span class="line">::TlsFree(m_tlsIndex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(m_pSlotData != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">HGLOBAL hSlotData = ::GlobalHandle(m_pSlotData);</span><br><span class="line">::GlobalUnlock(hSlotData);</span><br><span class="line">::GlobalFree(m_pSlotData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::DeleteCriticalSection(&amp;m_cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------CNoTrackObject类---------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* CNoTrackObject::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> nSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 申请一块带有GMEM_FIXED和GMEM_ZEROINIT标志的内存</span></span><br><span class="line"><span class="keyword">void</span>* p = ::GlobalAlloc(GPTR, nSize);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CNoTrackObject::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">::GlobalFree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------CThreadLocalObject 类--------------------------------//</span></span><br><span class="line"></span><br><span class="line">CNoTrackObject* CThreadLocalObject::GetData(CNoTrackObject* (*pfnCreateObject)())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m_nSlot == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(_afxThreadData == <span class="literal">NULL</span>)</span><br><span class="line">_afxThreadData = <span class="keyword">new</span>(__afxThreadData) CThreadSlotData;</span><br><span class="line">m_nSlot = _afxThreadData-&gt;AllocSlot();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CNoTrackObject* pValue = (CNoTrackObject*)_afxThreadData-&gt;GetThreadValue(m_nSlot);</span><br><span class="line"><span class="keyword">if</span>(pValue == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建一个数据项</span></span><br><span class="line">pValue = (*pfnCreateObject)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用线程私有数据保存新创建的对象</span></span><br><span class="line">_afxThreadData-&gt;SetValue(m_nSlot, pValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CNoTrackObject* CThreadLocalObject::GetDataNA()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m_nSlot == <span class="number">0</span> || _afxThreadData == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> (CNoTrackObject*)_afxThreadData-&gt;GetThreadValue(m_nSlot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CThreadLocalObject::~CThreadLocalObject()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m_nSlot != <span class="number">0</span> &amp;&amp; _afxThreadData != <span class="literal">NULL</span>)</span><br><span class="line">_afxThreadData-&gt;FreeSlot(m_nSlot);</span><br><span class="line">m_nSlot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计自己的线程局部存储&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#设计自己的线程局部存储&quot;&gt;&lt;/a&gt; 设计自己的线程局部存储&lt;/h1&gt;
&lt;p&gt;（1）自动管理它所保存的指针所指向的内存单元的分配和释放。这样做，一方面大大方&lt;br&gt;
便
      
    
    </summary>
    
      <category term="windows程序设计" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/28/WS001CS%E6%A8%A1%E5%9E%8B%E7%9A%84TCP_IP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/28/WS001CS模型的TCP_IP协议/</id>
    <published>2021-05-28T01:31:12.000Z</published>
    <updated>2021-06-08T14:49:38.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcpip协议"><a class="markdownIt-Anchor" href="#tcpip协议"></a> TCP/IP协议</h1><h2 id="基于tcpip协议的cs模型"><a class="markdownIt-Anchor" href="#基于tcpip协议的cs模型"></a> 基于tcp/ip协议的c/s模型</h2><h3 id="tcpip协议-2"><a class="markdownIt-Anchor" href="#tcpip协议-2"></a> tcp/ip协议</h3><ul><li><p>Transmission Control Protocol / Internet Protocol</p></li><li><p>重要性</p><ul><li>TCP/IP是今天的互联网的基石，没有这个就上不了网了</li></ul></li><li><p>概念</p><ul><li>tcp/ip协议族(簇，组，体系），并不是tcp协议和ip协议的总称，tcp/ip指的是整个网络传输体系。而tcp协议和ip协议就是单单的两个协议。</li></ul></li><li><p>tcp/ip协议的特点</p><ul><li><p>面向连接的，可靠的，基于字节流的传输层协议。</p></li><li><p>udp/ip</p><ul><li>面向非连接的，不可靠的，基于数据报的传输层协议。</li></ul></li></ul></li></ul><h3 id="clientserver-客户端服务器模型"><a class="markdownIt-Anchor" href="#clientserver-客户端服务器模型"></a> client/server ----- 客户端/服务器模型</h3><ul><li><p>比如QQ，DNF，LOL等这些我们下载客户端的，都属于c/s模型的一个应用</p></li><li><p>c/s模型其实是概念层面的，实现层面可以是基于任何的网络协议。</p></li><li><p>常见的还有b/s模型</p><ul><li>浏览器/服务器模型   基于http/https协议的</li></ul></li></ul><h3 id="套接字编程与socket编程"><a class="markdownIt-Anchor" href="#套接字编程与socket编程"></a> 套接字编程与socket编程</h3><ul><li>socket中文-&gt;套接字，也统称叫网络编程</li></ul><h3 id="演示我们要实现的效果"><a class="markdownIt-Anchor" href="#演示我们要实现的效果"></a> 演示我们要实现的效果</h3><ul><li><p>局域网</p></li><li><p>如果在广域网使用啊</p><ul><li><p>内网穿透，内网转发</p><ul><li>花生壳</li><li>Sunny-Ngrok</li><li>…</li></ul></li></ul></li></ul><h2 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h2><h3 id="网络头文件-网络库"><a class="markdownIt-Anchor" href="#网络头文件-网络库"></a> 网络头文件 网络库</h3><ul><li>最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。</li><li>#include &lt;WinSock2.h&gt;<br>#pragma comment(lib,“ws2_32.lib”)<ul><li><p>函数库</p><ul><li><p>winsock2.h</p><ul><li><p>windows socket 第2版</p><ul><li>第一版是 winsock.h</li><li>查看具体区别</li></ul></li><li><p>目前网络库有哪些版本？</p><ul><li><p>1.0<br>1.1<br>2.0<br>2.1<br>2.2</p><ul><li><p>演示MSDN</p><ul><li><p>查这个函数的详细信息</p><ul><li>WSAStartup</li></ul></li></ul></li></ul></li></ul></li><li><p>我们的开发环境支持哪个版本？</p><ul><li>打开头文件，看咱们当前编译器环境支持的最高版本</li></ul></li></ul></li><li><p>ws2_32.lib</p><ul><li><p>windows socket 第2版  32位</p><ul><li>不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll</li></ul></li></ul></li><li><p>wsock32.lib</p><ul><li>winsock.h 第一版网络库 对应的库文件</li></ul></li><li><p>这里不区分大小写</p></li></ul></li></ul></li></ul><h3 id="打开网络库"><a class="markdownIt-Anchor" href="#打开网络库"></a> 打开网络库</h3><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int WSAStartup(</span><br><span class="line">WORD      wVersionRequired,</span><br><span class="line">LPWSADATA lpWSAData</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li><p>打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用</p></li><li><p>w windows<br>s  socket<br>a Asynchronous  异步<br>startup   启动</p><ul><li><p>同步与异步</p><ul><li><p>同步</p><ul><li>阻塞/卡死状态</li></ul></li><li><p>异步</p><ul><li>多个工作同时进行</li></ul></li></ul></li></ul></li></ul></li><li><p>参数1</p><ul><li><p>我们要使用的库的版本</p></li><li><p>类型是 WORD</p><ul><li>转定义：unsigned  short</li></ul></li><li><p>WORD wVersionRequired = MAKEWORD(2,2);</p><ul><li><p>MAKEWORD(主版本,副版本)， 1.0 2.2</p></li><li><p>wVersionRequired</p><ul><li>数据高位/高地址是副版本</li><li>数据低位/低地址是主版本</li><li>用调试+计算器演示数据原理</li></ul></li></ul></li><li><p>位运算，内存操作，小端存储</p></li></ul></li><li><p>参数2</p><ul><li><p>LPWSADATA lpWSAData</p><ul><li><p>系统通过这个参数给我们一些配置信息</p><ul><li><p>注意</p><ul><li>当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则</li></ul></li></ul></li><li><p>看下有哪些信息</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct WSAData &#123;</span><br><span class="line">WORD           wVersion;</span><br><span class="line">WORD           wHighVersion;</span><br><span class="line">unsigned short iMaxSockets;</span><br><span class="line">unsigned short iMaxUdpDg;</span><br><span class="line">char           *lpVendorInfo;</span><br><span class="line">char           szDescription[WSADESCRIPTION_LEN + 1];</span><br><span class="line">char           szSystemStatus[WSASYS_STATUS_LEN + 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>wVersion</p><ul><li>我们要使用的版本</li></ul></li><li><p>wHighVersion</p><ul><li>系统能提供给我们最高的版本</li></ul></li><li><p>iMaxSockets</p><ul><li>返回可用的socket的数量，2版本之后就没用了</li></ul></li><li><p>iMaxUdpDg</p><ul><li>UDP数据报信息的大小，2版本之后就没用了</li></ul></li><li><p>lpVendorInfo</p><ul><li>供应商特定的信息，2版本之后就没用了</li></ul></li><li><p>szDescription<br>szSystemStatus</p><ul><li>当前库的描述信息，2.0是第二版的意思</li></ul></li></ul></li></ul></li><li><p>当输入的版本不存在</p><ul><li><p>输入1.3， 2.3</p><ul><li><p>有主版本，没有副版本</p><ul><li>得到该主版本的最大副版本 1.1 2.2并使用</li></ul></li></ul></li><li><p>输入3.1  3.3</p><ul><li><p>超过最大版本号</p><ul><li>使用系统能提供的最大的版本 2.2</li></ul></li></ul></li><li><p>输入 0.0 0.1 0.3</p><ul><li><p>主版本是0</p><ul><li>网络库打开失败，不支持请求的套接字版本</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>返回0为执行正确</p></li><li><p>失败</p><ul><li>这些宏的本质</li><li>WSASYSNOTREADY   10091       底层网络子系统尚未准备好进行网络通信。                                                  系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下<br>WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。      要使用的版本不支持<br>WSAEPROCLIM        10067         已达到对Windows套接字实现支持的任务数量的限制。                                 Windows Sockets实现可能限制同时使用它的应用程序的数量<br>WSAEINPROGRESS 10036          正在阻止Windows Sockets 1.1操作。                                                          当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止<br>WSAEFAULT            10014          lpWSAData参数不是有效指针。                                                                 参数写错了</li></ul></li></ul></li></ul></li></ul><h3 id="校验版本"><a class="markdownIt-Anchor" href="#校验版本"></a> 校验版本</h3><ul><li><p>2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion)</p><ul><li><p>HIBYTE是高位 副版本</p></li><li><p>LOBYTE是地位 主版本</p></li><li><p>逻辑</p><ul><li>只要有一个不是2，说明系统不支持我们要的2.2版本</li></ul></li></ul></li><li><p>关闭库<br>并结束函数，可以给出相应提示</p><ul><li>WSACleanup();</li><li>return 0；</li></ul></li></ul><h3 id="创建socket"><a class="markdownIt-Anchor" href="#创建socket"></a> 创建SOCKET</h3><ul><li><p>SOCKET  socket(<br>int af,<br>int type,<br>int protocol<br>);</p><ul><li><p>作用</p><ul><li>创建一个SOCKET</li></ul></li><li><p>SOCKET介绍</p><ul><li><p>什么是socket</p><ul><li>将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了，</li><li>也就是说，SOCKET是我们调用协议进行通信的 操作接口</li></ul></li><li><p>意义</p><ul><li><p>将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。</p><ul><li>网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些</li></ul></li></ul></li><li><p>本质</p><ul><li><p>就是一种数据类型，转定义看下类型</p><ul><li><p>就是一个整数</p><ul><li>uint</li></ul></li><li><p>但是这个数是唯一的</p><ul><li>标识着我当前的应用程序，协议特点等信息</li><li>ID，门牌号</li></ul></li></ul></li></ul></li><li><p>应用</p><ul><li><p>我们网络通信的函数，全部都要使用SOCKET</p><ul><li>演示</li></ul></li><li><p>逻辑</p><ul><li>每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET</li></ul></li></ul></li><li><p>所以</p><ul><li>网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程</li></ul></li></ul></li><li><p>参数1</p><ul><li><p>地址的类型</p><ul><li><p>比如大家联系我</p><ul><li><p>手机</p><ul><li>15512345678</li></ul></li><li><p>固定电话</p><ul><li>7881234</li></ul></li><li><p>ＱＱ</p><ul><li>40916626</li></ul></li><li><p>微信</p><ul><li>c3_xin666</li></ul></li><li><p>找上门</p><ul><li>内蒙古 xxxxxxx</li></ul></li><li><p>…</p></li></ul></li><li><p>AF_INET  2</p><ul><li><p>ipv4</p><ul><li><p>Internet协议版本4（IPv4）地址系列。</p><ul><li><p>192.168.1.103</p><ul><li>0.0.0.0  ~  255.255.255.255</li><li>点分十进制表示法</li></ul></li></ul></li><li><p>4字节 32位的地址</p><ul><li><p>个数快不够</p><ul><li>就是无符号int类型的范围  0 ~ 4294967295</li></ul></li></ul></li></ul></li></ul></li><li><p>AF_INET6  23</p><ul><li><p>ipv6</p><ul><li><p>Internet协议版本6（IPv6）地址系列。</p><ul><li>2001:0:3238:DFE1:63::FEFB</li></ul></li><li><p>16字节  128位的地址</p><ul><li>这个地球每寸一个IP</li></ul></li></ul></li></ul></li><li><p>AF_BTH  32</p><ul><li><p>蓝牙地址系列。<br>如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。</p><ul><li>6B:2D:BC:A9:8C:12</li></ul></li></ul></li><li><p>AF_IRDA  26</p><ul><li>红外数据协会（IrDA）地址系列。<br>仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。</li></ul></li><li><p>通信地址不仅仅只有IP地址</p></li></ul></li></ul></li><li><p>参数2</p><ul><li><p>套接字类型</p><ul><li><p>SOCK_STREAM    1</p><ul><li>一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。</li></ul></li><li><p>SOCK_DGRAM    2</p><ul><li>一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。</li></ul></li><li><p>SOCK_RAW   3</p><ul><li>一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。</li></ul></li><li><p>SOCK_RDM   4</p><ul><li>一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。<br>仅在安装了可靠多播协议时才支持此类型值。</li></ul></li><li><p>SOCK_SEQPACKET   5</p><ul><li>一种套接字类型，提供基于数据报的伪流数据包。</li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>协议的类型</p><ul><li><p>IPPROTO_TCP</p><ul><li>传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_UDP</p><ul><li>用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_ICMP</p><ul><li>Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_IGMP</p><ul><li>Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_RM</p><ul><li>用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。<br>仅在安装了可靠多播协议时才支持此协议值。</li></ul></li><li><p>整理下</p><ul><li>通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。</li><li>想要使用一个协议，咱们设备得支持才行，比如红外</li><li>参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型</li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功返回可用的socket</p><ul><li><p>不用了就一定要销毁套接字</p><ul><li>closesocket(socketListen);</li></ul></li></ul></li><li><p>失败返回INVALID_SOCKET</p><ul><li><p>关闭网络库</p><ul><li>WSACleanup();</li></ul></li><li><p>可用WSAGetLasterror()返回错误码</p></li></ul></li></ul></li></ul></li></ul><h3 id="绑定地址与端口"><a class="markdownIt-Anchor" href="#绑定地址与端口"></a> 绑定地址与端口</h3><ul><li><p>int bind(<br>SOCKET              s,<br>const sockaddr *addr,<br>int                 namelen<br>);</p><ul><li><p>作用</p><ul><li><p>给我们的socket绑定端口号与具体地址</p><ul><li><p>地址</p><ul><li><p>找到咱们的电脑</p><ul><li>只有一个</li></ul></li></ul></li><li><p>端口号</p><ul><li><p>找到我们机器上对应的软件，比如QQ，浏览器等等，都对应着自己的端口号</p><ul><li>多个</li></ul></li><li><p>每一种通信的端口号是唯一的</p></li><li><p>同一个软件可能占用多个端口号</p></li></ul></li></ul></li></ul></li><li><p>参数1</p><ul><li>上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号</li></ul></li><li><p>参数2</p><ul><li><p>结构体</p><ul><li>地址类型</li><li>装IP地址</li><li>端口号</li></ul></li><li><p>结构体类型</p><ul><li><p>sockaddr</p></li><li><p>该参数使用方法</p><ul><li><p>SOCKADDR_IN sockAddress;<br>sockAddress.sin_family = AF_INET;<br>sockAddress.sin_addr.s_addr = inet_addr(“127.0.0.1”);<br>sockAddress.sin_port = 12345;<br>(sockaddr*)&amp;sockAddress强转添加到参数2上</p><ul><li><p>成员1</p><ul><li>跟socket函数参数1是一样的</li></ul></li><li><p>成员2</p><ul><li><p>IP地址</p><ul><li><p><a href="http://192.168.xxx.xxx" target="_blank" rel="noopener">192.168.xxx.xxx</a></p><ul><li>可以在控制台输入指令  ipconfig 就能看到了</li><li>或者在网络设置中，能找到这个地址</li><li>我就不演示了，我不想让你们发现我</li></ul></li><li><p>127.0.0.1</p><ul><li>回送地址  本地回环地址  本地网络测试</li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>端口号</p><ul><li><p>本质</p><ul><li><p>就是一个整数</p><ul><li>0~65535</li></ul></li><li><p>IP是我们机器的地址，端口就是我们具体的软件的通信口，一个软件可能会占用多个接口，比如一个软件可以聊天，可以下载，可以看视频…那么这些不同的通信内容，往往会有各自的协议，各自的端口。</p><ul><li>IP是公司地址，端口就是各个部门的地址了</li></ul></li></ul></li><li><p>填写哪个值呢？</p><ul><li><p>理论上只要这个范围0~65535都可以</p><ul><li><p>实际</p><ul><li><p>介于0～1023，为系统保留占用端口号</p><ul><li>21端口分配给FTP(文件传输协议)服务<br>25端口分配给SMTP（简单邮件传输协议）服务<br>80端口分配给HTTP服务</li></ul></li></ul></li><li><p>所以</p><ul><li><p>我们不能写这个范围的</p><ul><li><p>我们的范围就是1024~65535</p><ul><li>稍微大点儿，1万多</li></ul></li><li><p>但是注意一点，端口号是唯一的，比如1234已经被别的软件占用了，那么你再使用1234这个端口号，那么就会绑定失败，因为已经呗占用了</p><ul><li>给大家演示下</li></ul></li><li><p>那大家如何查看自己要用的端口号有没有被占用呢？</p><ul><li><p>打开运行cmd输入netstat -ano</p><ul><li>查看被使用的所有端口</li></ul></li><li><p>netstat -aon|findstr “12345”</p><ul><li>检查我们要使用的端口号是否被使用了</li><li>使用了就会显示使用的程序，未被使用就啥都不显示</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>参数2的类型大小</p><ul><li>sizeof(参数2)</li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功返回0</p></li><li><p>失败返回SOCKET_ERROR</p><ul><li>具体错误码通过int WSAGetLastError(void);获得</li><li>closesocket(socketListen);<br>WSACleanup();</li></ul></li></ul></li></ul></li></ul><h3 id="开始监听"><a class="markdownIt-Anchor" href="#开始监听"></a> 开始监听</h3><ul><li><p>int WSAAPI listen(<br>SOCKET s,<br>int    backlog<br>);</p><ul><li><p>作用</p><ul><li>将套接字置于正在侦听传入连接的状态。</li></ul></li><li><p>参数1</p><ul><li>服务器端的socket，也就是socket函数创建的</li></ul></li><li><p>参数2</p><ul><li><p>挂起连接队列的最大长度。</p><ul><li><p>就是说，比如有100个用户链接请求，但是系统一次只能处理20个，那么剩下的80个不能不理人家，所以系统就创建个队列记录这些暂时不能处理，一会儿处理的链接请求，依先后顺序处理，那这个队列到底多大？就是这个参数设置，比如2，那么就允许两个新链接排队的。这个肯定不能无限大，那内存不够了。</p></li><li><p>我们可以手动设置这个参数，但是别大了。可能2<sub>10多，</sub>20多。</p></li><li><p>我们一般填写这个参数</p><ul><li><p>SOMAXCONN</p><ul><li>作用是让系统自动选择最合适的个数</li><li>不同的系统环境不一样，所以这个合适的数也都不一样</li></ul></li></ul></li></ul></li></ul></li><li><p>WSAAPI</p><ul><li><p>调用约定</p><ul><li><p>这个我们可以忽略，这是给系统看的，跟咱们没关</p></li><li><p>决定三</p><ul><li>函数名字的编译方式</li><li>参数的入栈顺序</li><li>函数的调用时间</li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功</p><ul><li>返回0</li></ul></li><li><p>失败</p><ul><li><p>SOCKET_ERROR</p></li><li><p>具体错误码</p><ul><li><p>WSAGetLastError()</p></li><li><p>释放</p><ul><li>closesocket(socketListen);</li><li>WSACleanup();</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="创建客户端socket接受连接"><a class="markdownIt-Anchor" href="#创建客户端socket接受连接"></a> 创建客户端socket/接受连接</h3><ul><li><p>SOCKET WSAAPI accept(<br>SOCKET   s,<br>sockaddr *addr,<br>int      *addrlen<br>);</p><ul><li><p>作用</p><ul><li>accept函数允许在套接字上进行传入连接尝试。</li><li>listen监听客户端来的链接，accept讲客户端的信息绑定到一个socket上，也就是给客户端创建一个socket,通过返回值返回给我们客户端的socket</li><li>一次只能创建一个，有几个客户端链接，就要调用几次</li></ul></li><li><p>参数1</p><ul><li><p>我们上面创建的自己的socket</p><ul><li>socket先处于监听状态，然后来的链接都在由这个管理，我们取客户端的信息，就是通过这个我们自己的socket</li></ul></li></ul></li><li><p>参数2</p><ul><li><p>客户端的地址端口信息结构体</p><ul><li><p>跟bind的第二个参数一样</p><ul><li>意义：系统帮我们监视着客户端的动态，肯定会记录客户端的信息，也就是IP地址，和端口号，并通过这个结构体记录</li></ul></li><li><p>SOCKADDR_IN sockClient</p><ul><li>这个我们不用填写，系统帮我们填写，也即传址调用</li></ul></li><li><p>参数2 3也能都设置成NULL，那就是不直接得到客户端的地址，端口号咯</p><ul><li><p>此时可以通过函数得到客户端信息</p><ul><li>getpeername(newSocket, (struct sockaddr*)&amp;sockClient, &amp;nLen);</li></ul></li><li><p>得到本地服务器信息</p><ul><li>getsockname(sSocket, (sockaddr*)&amp;addr, &amp;nLen);</li></ul></li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>参数2的大小</p><ul><li>sizeof</li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功</p><ul><li><p>返回值就是给客户端包好的socket</p><ul><li>与客户端通信就靠这个</li></ul></li></ul></li><li><p>失败</p><ul><li><p>返回INVALID_SOCKET</p><ul><li><p>WSAGetLastError()得到错误码</p></li><li><p>释放空间</p><ul><li>closesocket(socketListen);</li><li>WSACleanup();</li></ul></li></ul></li></ul></li></ul></li><li><p>accept调试</p><ul><li><p>1、阻塞，同步</p><ul><li>这个函数是阻塞的，没有客户端链接，那就一直卡在这儿，等着。</li></ul></li><li><p>2、多个链接</p><ul><li>一次只能一个，5个就要5次循环</li></ul></li><li><p>理解缺点</p></li></ul></li></ul></li></ul><h3 id="与客户端收发消息"><a class="markdownIt-Anchor" href="#与客户端收发消息"></a> 与客户端收发消息</h3><ul><li><p>收</p><ul><li><p>int recv(<br>SOCKET s,<br>char   *buf,<br>int    len,<br>int    flags<br>);</p><ul><li><p>作用</p><ul><li>得到指定客户端（参数1）发来的消息</li></ul></li><li><p>原理</p><ul><li><p>本质：复制</p><ul><li>数据的接收都是由协议本身做的，也就是socket的底层做的，系统会有一段缓冲区，存储着接收到的数据。</li><li>咱们外边调用recv的作用，就是通过socket找到这个缓冲区，并把数据复制进咱们的参数2，复制参数3个</li></ul></li></ul></li><li><p>参数1</p><ul><li>客户端的socket，每个客户端对应唯一的socket</li></ul></li><li><p>参数2</p><ul><li><p>客户端消息的存储空间，也就是个字符数组</p><ul><li><p>这个一般1500字节</p><ul><li>网络传输得最大单元，1500字节，也就是客户端发过来得数据，一次最大就是1500字节，这是协议规定，这个数值也是根据很多情况，总结出来得最优值</li><li>所以客户端最多一组来1500字节，咱们这头1500读一次，够够的了。</li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>想要读取得字节个数</p><ul><li>一般是参数2得字节数-1，把\0字符串结尾留出来</li></ul></li></ul></li><li><p>参数4</p><ul><li><p>数据的读取方式</p><ul><li><p>0</p></li><li><p>正常逻辑来说</p><ul><li><p>我们从系统缓冲区把数据读到我们的buf,读到我们buf中后，系统缓冲区的被读的就应该被删除掉了，不然也是浪费空间，毕竟，通信时间长的话，那就爆炸了</p></li><li><p>我们将缓冲区的数据读到我们自己的buf，根据需要处理相应的数据，这是我们可控的，完全玩儿弄于咱么你自己的鼓掌，系统缓冲区的数据，咱们无可奈何，操作不了</p></li><li><p>读出来的就删除的话，有很多的好处</p><ul><li><p>1、系统缓冲区读到的数据，比我们的buf多，那么我们读出来的，系统删掉，从而我们就可以依次的把所有数据读完了</p><ul><li><p>比如</p><ul><li>系统缓冲区收到abcdefghijk，咱们的recvbuf一次读4个字节，那么我们放循环里，就会依次读出abcd,efgh,ijk</li></ul></li><li><p>如果不删，那每次都是从头读</p><ul><li>在循环里就是每次都是abcd…只读到这四个</li></ul></li></ul></li><li><p>2、可以计数收到了多少字节</p><ul><li>返回值就是本次读出来的数据</li></ul></li></ul></li><li><p>正常这种逻辑</p><ul><li><p>填0</p><ul><li>哈哈</li><li>读出来的就删除</li></ul></li></ul></li></ul></li><li><p>MSG_PEEK</p><ul><li><p>窥视传入的数据。 数据将复制到缓冲区中，但不会从输入队列中删除。</p><ul><li>读出来的不删除</li></ul></li><li><p>这个东西是不建议被使用的</p><ul><li>第一、读数据不行</li><li>第二、那就无法计数了</li></ul></li></ul></li><li><p>MSG_OOB</p><ul><li><p>带外数据</p><ul><li><p>意义</p><ul><li><p>就是传输一段数据，在外带一个额外的特殊数据</p><ul><li>相当于小声BB</li></ul></li></ul></li><li><p>实际</p><ul><li><p>就不建议被使用了</p><ul><li>1、TCP协议规范（RFC 793）中OOB的原始描述被“主机要求”规范取代（ RFC 1122），但仍有许多机器具有RFC 793 OOB实现。</li><li>2、既然两种数据，那咱们就send两次，另一方recv两次就行了，何必搞得那么神神秘秘，浪费计算机精力</li></ul></li></ul></li></ul></li></ul></li><li><p>MSG_WAITALL</p><ul><li>直到系统缓冲区字节数满足参数3所请求得字节数，才开始读取</li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>读出来字节数大小</p><ul><li><p>读没了咋办？</p><ul><li><p>在recv函数卡着，等着客户端发来数据</p><ul><li>即阻塞，同步</li></ul></li><li><p>阻塞的</p></li></ul></li></ul></li><li><p>客户端下线，这端返回0</p><ul><li>释放客户端socket</li></ul></li><li><p>执行失败，返回SOCKET_ERROR</p><ul><li><p>WSAGetLastError()得到错误码</p></li><li><p>根据错误码信息做相应处理</p><ul><li>重启</li><li>等待</li><li>不用理会</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>发</p><ul><li><p>int WSAAPI send(<br>SOCKET     s,<br>const char *buf,<br>int        len,<br>int        flags<br>);</p><ul><li><p>作用</p><ul><li><p>向目标发送数据</p></li><li><p>本质</p><ul><li>send函数将我们的数据复制黏贴进系统的协议发送缓冲区，计算机伺机发出去</li><li>最大传输单元是1500字节</li></ul></li></ul></li><li><p>参数1</p><ul><li>目标的socket，每个客户端对应唯一的socket</li></ul></li><li><p>参数2</p><ul><li><p>给对方发送的字节串</p><ul><li><p>这个不要超过1500字节</p><ul><li><p>发送时候，协议要进行包装，加上协议信息，也叫协议头，或者叫包头，咱们在理论部分，会非常详细的介绍协议头，以及功能</p></li><li><p>这个大小不同的协议不一样，链路层14字节，ip头20字节，tcp头20字节，数据结尾还要有状态确认，加起来也几十个字节，所以实际咱们的数据位，不能写1500个，要留出来，那就1024吧，或者最多1400，就差不多了</p><ul><li>懂这个大体原理就好</li><li>详细的包的封装原理，我们在后面纯理论部分介绍</li></ul></li><li><p>当然大家这个不一定每次都是正好那么多字节，比如聊天，一句话就十个八个的汉字，别多于1400是最好的</p></li></ul></li><li><p>超过1500系统咋办？</p><ul><li><p>系统会分片处理</p><ul><li><p>比如2000个字节</p></li><li><p>系统分成两个包</p><ul><li><p>1400+包头==1500</p><ul><li>假设包头100字节</li></ul></li><li><p>600+包头==700</p></li><li><p>分两次发送出去</p></li></ul></li><li><p>结果</p><ul><li>1、系统要给咱们分包再打包，再发送， 客户端接收到了还得拆包，组合数据。从而增加了系统的工作，降低效率</li><li>2、有的协议，就把分片后的二包直接丢了</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>字节个数</p><ul><li>1400</li></ul></li></ul></li><li><p>参数4</p><ul><li><p>写0就行了</p></li><li><p>其他</p><ul><li><p>MSG_OOB</p><ul><li><p>意义同recv</p><ul><li>就不用使用了</li></ul></li><li><p>带外数据</p><ul><li><p>意义</p><ul><li><p>就是传输一段数据，在外带一个额外的特殊数据</p><ul><li>相当于小声BB</li></ul></li></ul></li><li><p>实际</p><ul><li><p>就不建议被使用了</p><ul><li>1、TCP协议规范（RFC 793）中OOB的原始描述被“主机要求”规范取代（ RFC 1122），但仍有许多机器具有RFC 793 OOB实现。</li><li>2、既然两种数据，那咱们就send两次，另一方recv两次就行了，何必搞得那么神神秘秘，浪费计算机精力</li></ul></li></ul></li></ul></li></ul></li><li><p>MSG_DONTROUTE</p><ul><li>指定数据不应受路由限制。 Windows套接字服务提供程序可以选择忽略此标志。</li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功返回写入的字节数</p></li><li><p>执行失败，返回SOCKET_ERROR</p><ul><li><p>WSAGetLastError()得到错误码</p></li><li><p>根据错误码信息做相应处理</p><ul><li>重启</li><li>等待</li><li>不用理会</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h2><h3 id="网络头文件-网络库-2"><a class="markdownIt-Anchor" href="#网络头文件-网络库-2"></a> 网络头文件 网络库</h3><ul><li><p>最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。</p></li><li><p>#include &lt;WinSock2.h&gt;<br>#pragma comment(lib,“ws2_32.lib”)</p><ul><li><p>函数库</p><ul><li><p>winsock2.h</p><ul><li><p>windows socket 第2版</p><ul><li>第一版是 winsock.h</li><li>查看具体区别</li></ul></li><li><p>目前网络库有哪些版本？</p><ul><li><p>1.0<br>1.1<br>2.0<br>2.1<br>2.2</p><ul><li><p>演示MSDN</p><ul><li><p>查这个函数的详细信息</p><ul><li>WSAStartup</li></ul></li></ul></li></ul></li></ul></li><li><p>我们的开发环境支持哪个版本？</p><ul><li>打开头文件，看咱们当前编译器环境支持的最高版本</li></ul></li></ul></li><li><p>ws2_32.lib</p><ul><li><p>windows socket 第2版  32位</p><ul><li>不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll</li></ul></li></ul></li><li><p>wsock32.lib</p><ul><li>winsock.h 第一版网络库 对应的库文件</li></ul></li><li><p>这里不区分大小写</p></li></ul></li></ul></li></ul><h3 id="打开网络库-2"><a class="markdownIt-Anchor" href="#打开网络库-2"></a> 打开网络库</h3><ul><li><p>int WSAStartup(<br>WORD      wVersionRequired,<br>LPWSADATA lpWSAData<br>);</p><ul><li><p>功能</p><ul><li><p>打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用</p></li><li><p>w windows<br>s  socket<br>a Asynchronous  异步<br>startup   启动</p><ul><li><p>同步与异步</p><ul><li><p>同步</p><ul><li>阻塞/卡死状态</li></ul></li><li><p>异步</p><ul><li>多个工作同时进行</li></ul></li></ul></li></ul></li></ul></li><li><p>参数1</p><ul><li><p>我们要使用的库的版本</p></li><li><p>类型是 WORD</p><ul><li>转定义：unsigned  short</li></ul></li><li><p>WORD wVersionRequired = MAKEWORD(2,2);</p><ul><li><p>MAKEWORD(主版本,副版本)， 1.0 2.2</p></li><li><p>wVersionRequired</p><ul><li>数据高位/高地址是副版本</li><li>数据低位/低地址是主版本</li><li>用调试+计算器演示数据原理</li></ul></li></ul></li><li><p>位运算，内存操作，小端存储</p></li></ul></li><li><p>参数2</p><ul><li><p>LPWSADATA lpWSAData</p><ul><li><p>系统通过这个参数给我们一些配置信息</p><ul><li><p>注意</p><ul><li>当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则</li></ul></li></ul></li><li><p>看下有哪些信息</p><ul><li><p>struct WSAData {<br>WORD           wVersion;<br>WORD           wHighVersion;<br>unsigned short iMaxSockets;<br>unsigned short iMaxUdpDg;<br>char           *lpVendorInfo;<br>char           szDescription[WSADESCRIPTION_LEN + 1];<br>char           szSystemStatus[WSASYS_STATUS_LEN + 1];<br>}</p><ul><li><p>wVersion</p><ul><li>我们要使用的版本</li></ul></li><li><p>wHighVersion</p><ul><li>系统能提供给我们最高的版本</li></ul></li><li><p>iMaxSockets</p><ul><li>返回可用的socket的数量，2版本之后就没用了</li></ul></li><li><p>iMaxUdpDg</p><ul><li>UDP数据报信息的大小，2版本之后就没用了</li></ul></li><li><p>lpVendorInfo</p><ul><li>供应商特定的信息，2版本之后就没用了</li></ul></li><li><p>szDescription<br>szSystemStatus</p><ul><li>当前库的描述信息，2.0是第二版的意思</li></ul></li></ul></li></ul></li><li><p>当输入的版本不存在</p><ul><li><p>输入1.3， 2.3</p><ul><li><p>有主版本，没有副版本</p><ul><li>得到该主版本的最大副版本 1.1 2.2并使用</li></ul></li></ul></li><li><p>输入3.1  3.3</p><ul><li><p>超过最大版本号</p><ul><li>使用系统能提供的最大的版本 2.2</li></ul></li></ul></li><li><p>输入 0.0 0.1 0.3</p><ul><li><p>主版本是0</p><ul><li>网络库打开失败，不支持请求的套接字版本</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>返回0为执行正确</p></li><li><p>失败</p><ul><li>这些宏的本质</li><li>WSASYSNOTREADY   10091       底层网络子系统尚未准备好进行网络通信。                                                  系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下<br>WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。      要使用的版本不支持<br>WSAEPROCLIM        10067         已达到对Windows套接字实现支持的任务数量的限制。                                 Windows Sockets实现可能限制同时使用它的应用程序的数量<br>WSAEINPROGRESS 10036          正在阻止Windows Sockets 1.1操作。                                                          当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止<br>WSAEFAULT            10014          lpWSAData参数不是有效指针。                                                                 参数写错了</li></ul></li></ul></li></ul></li></ul><h3 id="校验版本-2"><a class="markdownIt-Anchor" href="#校验版本-2"></a> 校验版本</h3><ul><li><p>2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion)</p><ul><li><p>HIBYTE是高位 副版本</p></li><li><p>LOBYTE是地位 主版本</p></li><li><p>逻辑</p><ul><li>只要有一个不是2，说明系统不支持我们要的2.2版本</li></ul></li></ul></li><li><p>关闭库<br>并结束函数，可以给出相应提示</p><ul><li>WSACleanup();</li><li>return 0；</li></ul></li></ul><h3 id="创建socket-2"><a class="markdownIt-Anchor" href="#创建socket-2"></a> 创建SOCKET</h3><ul><li><p>SOCKET  socket(<br>int af,<br>int type,<br>int protocol<br>);</p><ul><li><p>作用</p><ul><li>创建一个SOCKET</li></ul></li><li><p>SOCKET介绍</p><ul><li><p>什么是socket</p><ul><li>将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了，</li><li>也就是说，SOCKET是我们调用协议进行通信的 操作接口</li></ul></li><li><p>意义</p><ul><li><p>将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。</p><ul><li>网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些</li></ul></li></ul></li><li><p>本质</p><ul><li><p>就是一种数据类型，转定义看下类型</p><ul><li><p>就是一个整数</p><ul><li>uint</li></ul></li><li><p>但是这个数是唯一的</p><ul><li>标识着我当前的应用程序，协议特点等信息</li><li>ID，门牌号</li></ul></li></ul></li></ul></li><li><p>应用</p><ul><li><p>我们网络通信的函数，全部都要使用SOCKET</p><ul><li>演示</li></ul></li><li><p>逻辑</p><ul><li>每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET</li></ul></li></ul></li><li><p>所以</p><ul><li>网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程</li></ul></li></ul></li><li><p>参数1</p><ul><li><p>地址的类型</p><ul><li><p>比如大家联系我</p><ul><li><p>手机</p><ul><li>15512345678</li></ul></li><li><p>固定电话</p><ul><li>7881234</li></ul></li><li><p>ＱＱ</p><ul><li>40916626</li></ul></li><li><p>微信</p><ul><li>c3_xin666</li></ul></li><li><p>找上门</p><ul><li>内蒙古 xxxxxxx</li></ul></li><li><p>…</p></li></ul></li><li><p>AF_INET  2</p><ul><li><p>ipv4</p><ul><li><p>Internet协议版本4（IPv4）地址系列。</p><ul><li><p>192.168.1.103</p><ul><li>0.0.0.0  ~  255.255.255.255</li><li>点分十进制表示法</li></ul></li></ul></li><li><p>4字节 32位的地址</p><ul><li><p>个数快不够</p><ul><li>就是无符号int类型的范围  0 ~ 4294967295</li></ul></li></ul></li></ul></li></ul></li><li><p>AF_INET6  23</p><ul><li><p>ipv6</p><ul><li><p>Internet协议版本6（IPv6）地址系列。</p><ul><li>2001:0:3238:DFE1:63::FEFB</li></ul></li><li><p>16字节  128位的地址</p><ul><li>这个地球每寸一个IP</li></ul></li></ul></li></ul></li><li><p>AF_BTH  32</p><ul><li><p>蓝牙地址系列。<br>如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。</p><ul><li>6B:2D:BC:A9:8C:12</li></ul></li></ul></li><li><p>AF_IRDA  26</p><ul><li>红外数据协会（IrDA）地址系列。<br>仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。</li></ul></li><li><p>通信地址不仅仅只有IP地址</p></li></ul></li></ul></li><li><p>参数2</p><ul><li><p>套接字类型</p><ul><li><p>SOCK_STREAM    1</p><ul><li>一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。</li></ul></li><li><p>SOCK_DGRAM    2</p><ul><li>一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。</li></ul></li><li><p>SOCK_RAW   3</p><ul><li>一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。</li></ul></li><li><p>SOCK_RDM   4</p><ul><li>一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。<br>仅在安装了可靠多播协议时才支持此类型值。</li></ul></li><li><p>SOCK_SEQPACKET   5</p><ul><li>一种套接字类型，提供基于数据报的伪流数据包。</li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>协议的类型</p><ul><li><p>IPPROTO_TCP</p><ul><li>传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_UDP</p><ul><li>用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_ICMP</p><ul><li>Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_IGMP</p><ul><li>Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_RM</p><ul><li>用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。<br>仅在安装了可靠多播协议时才支持此协议值。</li></ul></li><li><p>整理下</p><ul><li>通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。</li><li>想要使用一个协议，咱们设备得支持才行，比如红外</li><li>参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型</li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功返回可用的socket</p><ul><li><p>不用了就一定要销毁套接字</p><ul><li>closesocket(socketListen);</li></ul></li></ul></li><li><p>失败返回INVALID_SOCKET</p><ul><li><p>关闭网络库</p><ul><li>WSACleanup();</li></ul></li><li><p>可用WSAGetLasterror()返回错误码</p></li></ul></li></ul></li></ul></li></ul><h3 id="链接到服务器"><a class="markdownIt-Anchor" href="#链接到服务器"></a> 链接到服务器</h3><ul><li><p>int WSAAPI connect<br>(<br>SOCKET         s,<br>const sockaddr *name,<br>int            namelen<br>);</p><ul><li><p>作用</p><ul><li>链接服务器并把服务器信息与服务器socket绑定到一起</li></ul></li><li><p>参数1</p><ul><li>服务器socket</li></ul></li><li><p>参数2</p><ul><li>服务器Ip地址端口号结构体</li></ul></li><li><p>参数3</p><ul><li>参数2结构体大小</li></ul></li><li><p>返回值</p><ul><li><p>成功</p><ul><li>返回0</li></ul></li><li><p>失败</p><ul><li><p>返回 SOCKET_ERROR</p><ul><li><p>WSAGetLastError()得到错误码</p></li><li><p>释放空间</p><ul><li>closesocket(socketListen);</li><li>WSACleanup();</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="与服务器收发消息"><a class="markdownIt-Anchor" href="#与服务器收发消息"></a> 与服务器收发消息</h3><ul><li><p>收</p><ul><li><p>recv(newSocket, szRecvBuffer, sizeof(szRecvBuffer), 0);</p><ul><li>参数1</li><li>参数2</li><li>参数3</li><li>参数4</li><li>返回值</li></ul></li></ul></li><li><p>发</p><ul><li><p>send(newSocket, szSendBuffer, strlen(szSendBuffer)+1, 0);</p><ul><li>参数1</li><li>参数2</li><li>参数3</li><li>参数4</li><li>返回值</li></ul></li></ul></li></ul><h2 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h2><h3 id="加个循环稍微完善下逻辑"><a class="markdownIt-Anchor" href="#加个循环稍微完善下逻辑"></a> 加个循环，稍微完善下逻辑</h3><h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3><ul><li><p>由于accept  recv是阻塞的，做其中一件事，另外一件事就做不了，所以假设有多个客户端的情况下，</p></li><li><p>我们当前的模型，我先等，我不管及将来的是什么请求，我先等</p><ul><li>结果：咱们在这等收消息recv，结果来了个链接请求，那就无法处理，链接只能accept</li><li>另外，我们等的socket可能没有发请求，那我们完了，等到睡着。</li><li>从而，我这个服务器，就是废了</li></ul></li></ul><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><ul><li><p>我们直接主动跟系统要，要什么？要有请求的socket，哪个有请求了，就给我哪个</p><ul><li>结果：<br>得到链接请求，我们就直接accept<br>得到是发来了消息，我们就recv</li><li>从而就不会发生无谓的傻等情况</li></ul></li></ul><h3 id="得到"><a class="markdownIt-Anchor" href="#得到"></a> 得到</h3><ul><li><p>select模型</p><ul><li><p>select就是挑选的意思，它把请求的套接字给我们选出来，我们直接就去处理这些套接字</p></li><li><p>即：select就是处理accept与recv阻塞问题的</p><ul><li>send本身也是阻塞的，不是长阻塞，是短阻塞</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcpip协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tcpip协议&quot;&gt;&lt;/a&gt; TCP/IP协议&lt;/h1&gt;
&lt;h2 id=&quot;基于tcpip协议的cs模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;
      
    
    </summary>
    
      <category term="Windows网络编程" scheme="https://xiaowuyoucy.github.io/categories/Windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Win32程序的执行单元</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/20/win0003-Win32%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/20/win0003-Win32程序的执行单元/</id>
    <published>2021-05-19T16:32:15.000Z</published>
    <updated>2021-05-30T13:21:49.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="win32程序的执行单元"><a class="markdownIt-Anchor" href="#win32程序的执行单元"></a> Win32程序的执行单元</h1><h3 id="线程的创建"><a class="markdownIt-Anchor" href="#线程的创建"></a> 线程的创建</h3><h4 id="线程函数的定义"><a class="markdownIt-Anchor" href="#线程函数的定义"></a> 线程函数的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI ThreadProc(LPVOID lpParam) //线程函数名ThreadProc可以随意的</span><br></pre></td></tr></table></figure><p>WINAPI 是一个宏名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define WINAPI __stdcall;</span><br></pre></td></tr></table></figure><p><code>__stdcall</code>是新标准C/C++函数的调用方法</p><p><code>__stdcall</code>采用自动清栈的方式</p><p><code>__cdecl</code>采用的是手工清栈方式</p><p><code>ThreadProc</code>是一个回调函数</p><p>如果没有显式说明的话，函数的调用方法是<code>__cdecl</code></p><p>lpParam参数由CreateTHread函数的第四个参数指定</p><h4 id="创建新线程的函数是createthread"><a class="markdownIt-Anchor" href="#创建新线程的函数是createthread"></a> 创建新线程的函数是CreateThread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateThread（</span><br><span class="line">LPSECURITY_ATTRIBUTES lpThreadAttributes，//线程的安全属性</span><br><span class="line">DWORD dwStackSize，//指定线程堆栈的大小</span><br><span class="line">LPTHREAD_START_ROUTINE lpStartAddress，//线程函数的起始地址</span><br><span class="line">LPVOID IpParameter，//传递给线程函数的参数</span><br><span class="line">DWORD dwCreationFlags，//指定创线程建后是否立即启动</span><br><span class="line">DWORD* pThreadld//用于取得内核给新生成的线程分配的线程ID号</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>成功：返回新建线程的句柄</p><p>IpThreadAttributes参数:</p><p>如果指定为NULL表示默认安全属性,且不可继承</p><p>如果希望此线程对象句柄可以被继承,则必须设定一个SECURITY_ATTRIBUTES结构,将它的bInheritHandle成员初始化为TRUE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SECURITY ATTRIBUTES sa</span><br><span class="line">sa.nLength =sizeof(sa)；</span><br><span class="line">sa.lpSecurityDescriptor = NULL;</span><br><span class="line">sa.binheritHandle=TRUE;</span><br><span class="line">//使CreateThread返回的句柄可以被继承</span><br><span class="line">//句柄h可以被子进程继承</span><br><span class="line">HANDLE h=：CreateThread(&amp;sa，....);</span><br></pre></td></tr></table></figure><p>dwCreationFlags—创建标志:</p><p>如果是0，表示线程被创建后立即开始运行；如果指定为CREATE_SUSPENDED标志，表示线程被创建以后处于挂起（暂停）状态，直到使用ResumeThread函数</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" I am from a thread, count = %d \n"</span>, i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD dwThreadId;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个线程</span></span><br><span class="line">hThread = ::CreateThread (</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认安全属性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认堆栈大小</span></span><br><span class="line">ThreadProc,<span class="comment">// 线程入口地址（执行线程的函数）</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 传给函数的参数</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">// 指定线程立即运行</span></span><br><span class="line">&amp;dwThreadId);<span class="comment">// 返回线程的ID号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Now another thread has been created. ID = %d \n"</span>, dwThreadId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待新线程运行结束</span></span><br><span class="line">::WaitForSingleObject (hThread, INFINITE);</span><br><span class="line">::CloseHandle (hThread);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>INFINITE表示无限时间等待</p><h4 id="waitforsingleobject函数等待新线程运行结束"><a class="markdownIt-Anchor" href="#waitforsingleobject函数等待新线程运行结束"></a> WaitForSingleObject函数等待新线程运行结束</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//等待新线程运行结束</span><br><span class="line">::WaitForSingleObject（</span><br><span class="line">hThread，//hHandle 要等待的对象的句柄</span><br><span class="line">INFINITE);//dwMilliseconds要等待的时间（以毫秒为单位）</span><br></pre></td></tr></table></figure><p>WaitForSingleObject函数用于等待指定的对象（hHandle）变成受信状态。参数dwMilliseconds给出了以毫秒为单位的要等待的时间，其值指定为INFINITE表示要等待无限长的时间。</p><p>当有下列一种情况发生时函数就会返回：<br>（1）要等待的对象变成受信（signaled）状态。<br>（2）参数dwMilliseconds指定的时间已过去。</p><p>一个可执行对象有两种状态，未受信（nonsignaled）和受信（signaled）状态。</p><p><code>线程对象只有当线程运行结束时才达到受信状态</code>，此时&quot;WaitForSingleObject（hThread，INFINITE）&quot;语句才会返回。</p><hr>### 内核句柄对象<p>线程内核对象就是一个包含了线程状态信息的数据结构。每一次对Create Thread函数的成<br>功调用，系统都会在内部为新的线程分配一个内核对象。系统提供的管理线程的函数其实就是<br>依靠访问线程内核对象来实现管理的。</p><p>线程内核对象（Thread Kernel Object）</p><p><img src="/images/javawz/1621938794206.png" alt="1621938794206"></p><h4 id="1线程上下文context"><a class="markdownIt-Anchor" href="#1线程上下文context"></a> 1，线程上下文CONTEXT</h4><p>每个线程都有它自己的一组CPU寄存器，称为<code>线程的上下文</code>。这组寄存器的值保存在一<br>个CONTEXT结构里，反映了该线程上次运行时CPU寄存器的状态。</p><h4 id="2使用计数usage-count"><a class="markdownIt-Anchor" href="#2使用计数usage-count"></a> 2，使用计数Usage Count</h4><p>Usage Count成员记录了线程内核对象的使用计数，这个计数说明了此内核对象被打开的<br>次数。</p><p>当这个值是0的时候，系统就认为已经没有任何进程在引用此内核对象了，于是线程内核对象就要从内存中撤销。<br>只要线程没有结束运行， Usage Count的值就至少为1。</p><p>在创建一个新的线程时，CreateThread函数返回线程内核对象的句柄，相当于打开一次新创建的内核对象，这也会促使Usage Count的值加1，所以创建一个新的线程后，初始状态下Usage Count的值是2。之后，只要有进程打开此内核对象，就会使Usage Count的值加1。比如当有一个进程调用OpenThread<br>函数打开这个线程内核对象后， Usage Count的值会再次加1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenThread(</span><br><span class="line">DWORD dwDesiredAccess， //想要的访问权限，可以为THREAD ALL ACCESS等</span><br><span class="line">BOOL bInheritHandle，//指定此函数返回的句柄是否可以被子进程继承</span><br><span class="line">DWORD dwThreadld//目标线程ID号</span><br><span class="line">);//注意， OpenThread函数是Windows 2000及其以上产品的新特性， Windows 98并不支持它。</span><br></pre></td></tr></table></figure><p>由于对这个函数的调用会使Usage Count的值加1，所以在使用完它们返回的句柄后一定要调用CloseHandle函数进行关闭。关闭内核对象句柄的操作就会使Usage Count的值减1.</p><p>还有一些函数仅仅返回内核对象的<code>伪句柄</code>，并不会创建新的句柄，当然也就不会影响Usage Count的值。如果对这些伪句柄调用CloseHandle函数，那么CloseHandle就会忽略对自己的调用并返回FALSE，对进程和线程来说，这些函数有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HANDLE GetCurrentProcess 0； //返回当前进程句柄</span><br><span class="line">HANDLE GetCurrentThread 0； //返回当前线程句柄</span><br></pre></td></tr></table></figure><p>如果线程结束后Usage Count不为0,会造成内存泄露   当然，线程所在的进程结束后，该进程占用的所有资源都要释放</p><h4 id="暂停次数suspend-count"><a class="markdownIt-Anchor" href="#暂停次数suspend-count"></a> 暂停次数Suspend Count</h4><p>线程内核对象中的Suspend Count用于指明线程的暂停计数。</p><p>当调用CreateProcess （创建进程的主线程）或CreateThread函数时，线程的内核对象就被创建了，它暂停计数被初始化为1 （即处于暂停状态），这可以阻止新创建的线程被调度到CPU中。</p><p>因为线程的初始化需要时间，当线程完全初始化好了之后， CreateProcess或CreateThread检查是否传递了<code>CREATE_SUSPENDED</code>标志。如果传递了这个标志，那么这些函数就返回，同时新线程处于暂停状态。</p><p>如果尚未传递该标志，那么线程的暂停计数将被递减为0。当线程的暂停计数是0的时候，该线程就处于可调度状态。</p><p>暂停次数为1:暂停状态</p><p>暂停次数为0:可调度状态</p><h4 id="resunethread唤醒一个线程"><a class="markdownIt-Anchor" href="#resunethread唤醒一个线程"></a> ResuneThread唤醒一个线程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD ResuneThread (HANDLE hThread);      //唤醒一个挂起的线程</span><br></pre></td></tr></table></figure><p>该函数减少线程的暂停计数，当计数值减到0的时候，线程被恢复运行。如果调用成功ResumeThread函数返回线程的前一个暂停计数，否则返回OxFFFFFFFF （-1）。<br>单个线程可以被暂停若干次。如果一个线程被暂停了3次，它必须被唤醒3次才可以分配给一个CPU</p><h4 id="suspendthread函数挂起一个线程"><a class="markdownIt-Anchor" href="#suspendthread函数挂起一个线程"></a> SuspendThread函数挂起一个线程。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI SuspendThread(</span><br><span class="line">　　_In_HANDLE hThread</span><br><span class="line">　　);</span><br></pre></td></tr></table></figure><p><code>可调度的（没有处于暂停状态）</code></p><p>大约每经20ms， Windows查看一次当前存在的所有线程内核对象。在这些对象中，只有<br>一少部分是可调度的（没有处于暂停状态）， Windows选择其中的一个内核对象，将它的<br>CONTEXT （上下文）装入CPU的寄存器，这一过程称为<code>上下文转换</code>。</p><h3 id="退出代码exit-code"><a class="markdownIt-Anchor" href="#退出代码exit-code"></a> 退出代码Exit Code</h3><p>成员Exit Code指定了线程的退出代码，也可以说是线程函数的返回值。在线程运行期间，线程函数还没有返回， Exit Code的值是STILL_ACTIVE。线程运行结束后，系统自动将Exit Code设为线程函数的返回值。可以用GetExitCodeThread函数得到线程的退出代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwExitCode；</span><br><span class="line">if(GetExitCodeThread(hThread， &amp;dwExitCode))</span><br><span class="line">&#123;</span><br><span class="line">if(dwExitCode == STILL ACTIVE)</span><br><span class="line">&#123;&#125;//目标线程还在运行</span><br><span class="line">else</span><br><span class="line">&#123;&#125;//目标线程已经中止，退出代码为dwExitCode</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">........</span><br></pre></td></tr></table></figure><h4 id="getexitcodethread得到线程的退出代码"><a class="markdownIt-Anchor" href="#getexitcodethread得到线程的退出代码"></a> GetExitCodeThread得到线程的退出代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL GetExitCodeThread( HANDLE hThread, LPDWORD lpExitCode);</span><br></pre></td></tr></table></figure><h3 id="是否受信signaled"><a class="markdownIt-Anchor" href="#是否受信signaled"></a> 是否受信Signaled</h3><p>成员Signaled指示了线程对象是否为“受信”状态。</p><p>线程在运行期间， Signaled的值永远是FALSE，即“<code>未受信</code>”，只有当线程结束以后，系统才把Signaled的值置为TRUE，此时，针对此对象的等待函数就会返回，如上一小节中的WaitForSingleObject函数。</p><p>线程结束后,会变成受信状态</p><h3 id="线程的终止"><a class="markdownIt-Anchor" href="#线程的终止"></a> 线程的终止</h3><p>一当线程正常终止时，会发生下列事件：<br>在线程函数中创建的所有C++对象将通过它们各自的析构函数被正确地销毁。<br>该线程使用的堆栈将被释放。<br>系统将线程内核对象中Exit Code （退出代码）的值由STILL_ ACTIVE设置为线程函数的返回值。<br>系统将递减线程内核对象中Usage Code （使用计数）的值。</p><h4 id="终止线程的执行有4种方法"><a class="markdownIt-Anchor" href="#终止线程的执行有4种方法"></a> 终止线程的执行有4种方法:</h4><p>（1）线程函数自然退出。当函数执行到return语句返回时， Windows将终止线程的执行。<br>建议使用这种方法终止线程的执行。<br>（2）使用ExitThread函数来终止线程，原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void ExitThread（ DWORD dwExiCode ）//线程的退出代码</span><br></pre></td></tr></table></figure><p>ExitThread函数会中止当前线程的运行，促使系统释放掉所有此线程使用的资源。但是，<br>CCt资源却不能得到正确地清除。</p><p>（3）使用TerminateThread函数在一个线程中强制终止另一个线程的执行，原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL TerminateThread(</span><br><span class="line">HANDLE hThread， //目标线程句柄</span><br><span class="line">DWORD dwExitCode //目标线程的退出代码</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>（4）使用ExitProcess函数结束进程，这时系统会自动结束进程中所有线程的运行。用这<br>种方法相当于对每个线程使用TerminateThread函数，所以也应当避免这种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLSPEC_NORETURN VOID ExitProcess(UINT uExitCode);//进程退出代码</span><br></pre></td></tr></table></figure><h4 id="线程的优先级"><a class="markdownIt-Anchor" href="#线程的优先级"></a> 线程的优先级</h4><p>每个线程都要被赋予一个优先级号，取值为0（最低）到31 （最高）。</p><p>调用WaitForSingleObject函数就会导致主线程处于不可调度状态，还有在第4章要讨论的GetMessage函数，也会使线程暂停运行。</p><p>Windows支持6个优先级类： idle， below normal， normal， above normal，high和real-time.</p><p>线程刚被创建时，他的相对优先级总是被设置为normal，若要改变线程的优先级，必须<br>使用下面这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL SetThreadPriority(HANDLE hThread,int nPriority );</span><br></pre></td></tr></table></figure><p>hThread参数是目标线程的句柄, nPriority参数定义了线程的优先级,取值如下所示:</p><p>THREAD_PRIORITY_TIME_CRITICALTime-critical (实时)</p><p>THREAD_PRIORITY_HIGHEST_Highest (最高)</p><p>THREAD_PRIORITY_ABOVE_NORMAL   Above normal (高于正常, Windows 98不支持)</p><p>THREAD_PRIORITY_NORMAL Nornal (正常)</p><p>THREAD_PRIORITY_BELOW_NORMAL   Below normal （低于正常， Windows 98不支持）</p><p>THREAD_PRIORITY_LOWEST   Lowest （最低）</p><p>THREAD_PRIORITY_IDLE   Idle （空闲）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadIdle</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i++&lt;<span class="number">10</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Idle Thread is running \n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadNormal</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i++&lt;<span class="number">10</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Normal Thread is running \n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwThreadID;</span><br><span class="line">HANDLE h[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个优先级为Idle的线程</span></span><br><span class="line">h[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadIdle, <span class="literal">NULL</span>,</span><br><span class="line">CREATE_SUSPENDED, &amp;dwThreadID);</span><br><span class="line">::SetThreadPriority(h[<span class="number">0</span>], THREAD_PRIORITY_IDLE);</span><br><span class="line">::ResumeThread(h[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个优先级为Normal的线程</span></span><br><span class="line">h[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadNormal, <span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两个线程内核对象都变成受信状态</span></span><br><span class="line">::WaitForMultipleObjects(</span><br><span class="line"><span class="number">2</span>,    <span class="comment">// DWORD nCount  要等待的内核对象的数量</span></span><br><span class="line">h,    <span class="comment">// CONST HANDLE *lpHandles 句柄数组</span></span><br><span class="line">TRUE,    <span class="comment">// BOOL bWaitAll指定是否等待所有内核对象变成受信状态</span></span><br><span class="line">INFINITE);  <span class="comment">// DWORD dwMilliseconds 要等待的时间</span></span><br><span class="line">   </span><br><span class="line">::CloseHandle(h[<span class="number">0</span>]);</span><br><span class="line">::CloseHandle(h[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>创建线程时可以给参数指定CREATE_SUSPENDED，让线程挂起</p><p>ResumeThread函数恢复线程运行。</p><h4 id="waitformultipleobjects函数"><a class="markdownIt-Anchor" href="#waitformultipleobjects函数"></a> <code>WaitForMultipleObjects</code>函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForMultipleObjects(</span><br><span class="line">DWORD nCount,//数组个数</span><br><span class="line">const HANDLE* lpHandles,//句柄数组</span><br><span class="line">BOOL bWaitAll,//指定是否等待所有内核对象变成受信状态</span><br><span class="line">DWORD dwMilliseconds//要等待的时间</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>用于等待多个内核对象，前两个参数分别为要等待的内核对象的个数和句柄数组指针。</p><p>如果将第三个参数bWaitAll的值设为TRUE，等待的内核对象全部变成受信状态以后此函数才返回。否则， bWaitAll为0的话，只要等待的内核对象中有一个变成了受信状态， WaitForMultipleObjects就返回，返回值指明了是哪一个内核对象变成了受信状态。</p><p>参数bWaitAll为FALSE的时候， WaitForMultpleObjects函数从索引0开始扫描整个句柄<br>数组，第一个受信的内核对象将终止函数的等待，使函数返回。</p><p>下面的代码说明了函数返回值的作用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h[<span class="number">2</span>];</span><br><span class="line">h[<span class="number">0</span>] = hThread1;</span><br><span class="line">h[<span class="number">1</span>] = hThread2;</span><br><span class="line">DWORD dw = ::WaitForMultipleObjects(<span class="number">2</span>, h, FALSE, <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">switch</span>(dw)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WAIT_FAILED:</span><br><span class="line"><span class="comment">// 调用WaitForMultipleObjects函数失败(句柄无效？)</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_TIMEOUT:</span><br><span class="line"><span class="comment">// 在5秒内没有一个内核对象受信</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0 + <span class="number">0</span>:</span><br><span class="line"><span class="comment">// 句柄h[0]对应的内核对象受信</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0 + <span class="number">1</span>:</span><br><span class="line"><span class="comment">// 句柄h[1]对应的内核对象受信</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cc运行期库"><a class="markdownIt-Anchor" href="#cc运行期库"></a> C/C++运行期库</h4><p><code>#include &lt;process.h&gt;</code></p><p>在实际的开发过程中，一般不直接使用windows系统提供的CreateThread函数创建线程，<br>而是使用C/C++运行期函数_beginthreadex。</p><p>_beginthreadex的参数与CreateThread函数是对应的，只是参数名和类型不完全相同，使用的<br>时候需要强制转化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned long _beginthreadex(</span><br><span class="line">void *security,</span><br><span class="line">unsigned stack_size,</span><br><span class="line">unsigned (__stdcall *start_address) ( void *),</span><br><span class="line">void *arglist,</span><br><span class="line">unsigned initflag,</span><br><span class="line">unsigned *thrdaddr</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>相应地， C/C++运行期库也提供了另一个版本的结束当前线程运行的函数，用于取代<br>ExitThread函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void  _endthreadex（unsigned retval ）； //指定退出代码</span><br></pre></td></tr></table></figure><p>这个函数会释放_beginthreadex为保持线程同步而申请的内存空间，然后再调用ExitThread<br>函数来终止线程。</p><p>使用_beginthreadex来创建一个线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">my</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">132</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">132</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">132</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD threadId;</span><br><span class="line">HANDLE h = (HANDLE) _beginthreadex(<span class="literal">NULL</span>,<span class="literal">NULL</span>,(_beginthreadex_proc_type)my,<span class="literal">NULL</span>,<span class="number">0</span>, (<span class="keyword">unsigned</span>*)&amp;threadId);</span><br><span class="line">WaitForSingleObject(h, INFINITE);</span><br><span class="line">    CloseHandle(h);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h2><h3 id="临界区对象"><a class="markdownIt-Anchor" href="#临界区对象"></a> 临界区对象</h3><p>当多个线程在同一个进程中执行时，可能有不止一个线程同时执行同一段代码，访问同一段内存中的数据。多个线程同时读共享数据没有问题，但如果同时读和写，情况就不同了。</p><h4 id="使用临界区对象"><a class="markdownIt-Anchor" href="#使用临界区对象"></a> 使用临界区对象</h4><p>临界区对象是定义在数据段中的一个CRITICAL_SECTION结构， Windows内部使用这个结构记录一些信息，确保在同一时间只有一个线程访问该数据段中的数据。</p><p>编程的时候，要把临界区对象定义在想保护的数据段中，然后在任何线程使用此临界区对象之前对它进行初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void InitializeCriticalSection（LPCRITICAL_SECTION IpCriticalSection）；</span><br><span class="line">//指向数据段中定义的CRITICAL_SECTION结构</span><br></pre></td></tr></table></figure><p>线程访问临界区中数据的时候，必须首先调用EnterCriticalSection函数，申请进入临界区（文叫关键代码段），在同一时间内， Windows只允许一个线程进入临界区。</p><p>所以在申请的时候，如果有另一个线程在临界区的话， EnterCriticalSection函数会一直等待下去，直到其他线程离开临界区才返回。EnterCriticalSection函数用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void EnterCriticalSection（ LPCRITICAL_SECTION IpCriticalSection）；</span><br></pre></td></tr></table></figure><p>当操作完成的时候，还要将临界区交还给Windows，以便其他线程可以申请使用。这个工作由LeaveCriticalSection函数来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void LeaveCriticalSection（ LPCRITICAL_SECTION IpCriticalSection）;</span><br></pre></td></tr></table></figure><p>当程序不再使用临界区对象的时候，必须使用DeleteCriticalSection函数将它删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void DeleteCriticalSection（ LPCRITICAL_SECTION IpCriticalSection）;</span><br></pre></td></tr></table></figure><p>现在使用临界区对象来改写上面有同步问题的计数程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;process.h&gt;</span><br><span class="line"></span><br><span class="line">BOOL g_bContinue = TRUE;</span><br><span class="line">int g_nCount1 = 0;</span><br><span class="line">int g_nCount2 = 0;</span><br><span class="line">CRITICAL_SECTION g_cs; // 对存在同步问题的代码段使用临界区对象</span><br><span class="line"></span><br><span class="line">UINT __stdcall ThreadFunc(LPVOID);</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">UINT uId;</span><br><span class="line">HANDLE h[2];</span><br><span class="line"></span><br><span class="line">// 初始化临界区对象</span><br><span class="line">::InitializeCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">h[0] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId);</span><br><span class="line">h[1] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId);</span><br><span class="line"></span><br><span class="line">// 等待1秒后通知两个计数线程结束，关闭句柄</span><br><span class="line">Sleep(1000);</span><br><span class="line">g_bContinue = FALSE;</span><br><span class="line">::WaitForMultipleObjects(2, h, TRUE, INFINITE);</span><br><span class="line">::CloseHandle(h[0]);</span><br><span class="line">::CloseHandle(h[1]);</span><br><span class="line"></span><br><span class="line">// 删除临界区对象</span><br><span class="line">::DeleteCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">printf(&quot;g_nCount1 = %d \n&quot;, g_nCount1);</span><br><span class="line">printf(&quot;g_nCount2 = %d \n&quot;, g_nCount2);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT __stdcall ThreadFunc(LPVOID)</span><br><span class="line">&#123;</span><br><span class="line">while(g_bContinue)</span><br><span class="line">&#123;</span><br><span class="line">::EnterCriticalSection(&amp;g_cs);</span><br><span class="line">g_nCount1++;</span><br><span class="line">g_nCount2++;</span><br><span class="line">::LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="互锁函数"><a class="markdownIt-Anchor" href="#互锁函数"></a> 互锁函数</h4><p>互锁函数为同步访问多线程共享变量提供了一个简单的机制。如果变量在共享内存，不同<br>进程的线程也可以使用此机制。</p><p>用于互锁的函数有InterlockedIncrement. InterlockedDecrement.<br>InterlockedExchangeAdd， InterlockedExchangePointer等.</p><p>InterlockedIncrement函数递增（加1）指定的32位变量。这个函数可以阻止其他线程同<br>时使用此变量，函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LONG InterlockedIncrement（ LONG volatile* Addend）;</span><br><span class="line">//指向要递增的变量</span><br></pre></td></tr></table></figure><p>InterlockedDecrement函数同步递减（减1）指定的32位变量，原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LONG InterlockedDecrement( LONG volatile* Addend);</span><br><span class="line">//指向要递减的变量</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// InterlockDemo.cpp文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_nCount1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> g_nCount2 = <span class="number">0</span>;</span><br><span class="line">BOOL g_bContinue = TRUE;</span><br><span class="line"></span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UINT uId;</span><br><span class="line">HANDLE h[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">h[<span class="number">0</span>] = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId);</span><br><span class="line">h[<span class="number">1</span>] = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待1秒后通知两个计数线程结束，关闭句柄</span></span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">g_bContinue = FALSE;</span><br><span class="line">::WaitForMultipleObjects(<span class="number">2</span>, h, TRUE, INFINITE);</span><br><span class="line">::CloseHandle(h[<span class="number">0</span>]);</span><br><span class="line">::CloseHandle(h[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"g_nCount1 = %d \n"</span>, g_nCount1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"g_nCount2 = %d \n"</span>, g_nCount2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(g_bContinue)</span><br><span class="line">&#123;</span><br><span class="line">::InterlockedIncrement((<span class="keyword">long</span>*)&amp;g_nCount1);</span><br><span class="line">::InterlockedIncrement((<span class="keyword">long</span>*)&amp;g_nCount2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件内核对象"><a class="markdownIt-Anchor" href="#事件内核对象"></a> 事件内核对象</h4><p>多线程程序设计大多会涉及线程间相互通信。</p><p>事件对象（event）是一种抽象的对象，它也有未受信（nonsignaled）和受信（signaled）两种状态，编程人员也可以使用WaitForSingleObject函数等待其变成受信状态。</p><p>事件对象包含3个成员： nUsageCount （使用计数）、bManualReset （是否人工重置）和<br>bSignaled （是否受信）。</p><p>成员nUsagecount记录当前的使用计数，当使用计数为0的时候，Windows就会销毁此内核对象占用的资源；</p><p>成员bManualReset指定在一个事件内核对象上等待的函数返回之后， Windows是否重置这个对象为未受信状态；</p><p>成员bsignaled指定当前事件内核对象是否受信。</p><p>如果想使用事件对象，需要首先用<code>CreateEvent</code>函数去创建它，初始状态下， nUsageCount<br>的值为1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateEvent（</span><br><span class="line">LPSECURITY_ATTRIBUTES IpEventAttributes，//用来定义事件对象的安全属性</span><br><span class="line">BOOL bManualReset,//指定是否需要手动重置事件对象为未受信状态。</span><br><span class="line">BOOL bInitialState，//指定事件对象创建时的初始状态</span><br><span class="line">LPCWSTR IpName）;//事件对象的名称</span><br></pre></td></tr></table></figure><p>参数bManualReset对应着内核对象中的bManualReset成员。</p><p>自动重置（auto-reset）和人工重置（manual-reset）是事件内核对象两种不同的类型。</p><p>当一个人工重置的事件对象受信以后，所有等待在这个事件上的线程都会变为可调度状态(暂停次数为0)；</p><p>可是当一个自动重置的事件对象受信以后， Windows仅允许一个等待在该事件上的线程变成可调度状态，然后就自动重置此事件对象为未受信状态。</p><p>blnitialState参数对应着bSignaled成员。</p><p>将它设为TRUE，则表示事件对象创建时的初始化状态为受信(结束)（bSignaled =TRUE）；设为FALSE时，状态为未受信(未结束)（bSignaled =FALSE）。</p><p>IpName参数用来指定事件对象的名称。为事件对象命名是为了在其他地方（比如，其他<br>进程的线程中）使用OpenEvent或CreateEvent函数获取此内核对象的句柄。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenEvent (</span><br><span class="line">DWORD dwDesiredAccess, //指定想要的访问权限</span><br><span class="line">BOOL blnheritHandle, //指定返回句柄是否可被继承</span><br><span class="line">LPCWSTR IpName); //要打开的事件对象的名称</span><br></pre></td></tr></table></figure><p>系统创建或打开一个事件内核对象后，会返回事件的句柄。当编程人员不使用此内核对象的时候，应该调用CloseHandle函数释放它占用的资源。</p><p>事件对象被建立后，程序可以通过SetEvent和ResetEvent函数来设置它的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BOOL SetEvent(HANDLE hEvent ); //将事件状态设为&quot;受信(sigaled) &quot;;</span><br><span class="line">BOOL ResetEvent(HANDLE hEvent); //将事件状态设为&quot;未受信(nonsigaled) &quot;;</span><br></pre></td></tr></table></figure><p>通常情况下，为一个自动重置类型的事件对象调用ResetEvent函数是不必要的，因为Windows会自动重置此事件对象。</p><p>下面例子中，主线程通过将事件状态设为“受信”来通知子线程开始工作。这是事件内核对<br>象一个很重要的用途，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE g_hEvent;</span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ChildFunc</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hChildThread;</span><br><span class="line">UINT uId;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个自动重置的（auto-reset events），未受信的（nonsignaled）事件内核对象</span></span><br><span class="line">g_hEvent = ::CreateEvent(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">hChildThread = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ChildFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知子线程开始工作</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please input a char to tell the Child Thread to work: \n"</span>);</span><br><span class="line">getchar();</span><br><span class="line">::SetEvent(g_hEvent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待子线程完成工作，释放资源</span></span><br><span class="line">::WaitForSingleObject(hChildThread, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"All the work has been finished. \n"</span>);</span><br><span class="line">::CloseHandle(hChildThread);</span><br><span class="line">::CloseHandle(g_hEvent);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ChildFunc</span><span class="params">(LPVOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">::WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Child thread is working...... \n"</span>);</span><br><span class="line">::Sleep(<span class="number">5</span>*<span class="number">1000</span>); <span class="comment">// 暂停5秒，模拟真正的工作</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量内核对象"><a class="markdownIt-Anchor" href="#信号量内核对象"></a> 信号量内核对象</h3><p>信号量（Semaphore）内核对象对线程的同步方式与前面几种方法不同，它允许多个线程<br>在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</p><p>在用CreateSemaphore函数创建信号量时，即要同时指出允许的最大资源计数和当前可用资源计数。</p><p>一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可<br>用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。</p><p>但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能再允许<br>其他线程的进入，此时的信号量信号将无法发出。</p><p>线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore函数将当前可用资源计数加1，在任何时候当前可用资源计数决不可能大于最大资源计数。</p><p><img src="/images/javawz/1622071965844.png" alt="1622071965844"></p><p>以箭头和白色箭头表示共享资源所允许的最大资源计数和当前可用资源计数。</p><p>黑色箭头表示已经访问的资源个数。当可用资源为0时，其他线程不能进入，直到可用资源大于0时，其他线程才可访问</p><p>信号量也被称作Dikstrait数器。</p><p>使用信号量内核对象进行线程同步主要会用到CreateSemaphore，OpenSemaphore、ReleaseSemaphore、 WaitForSingleObject和WaitForMultipleObjects等函数。</p><h4 id="其中createsemaphore用来创建一个信号量内核对象其函数原型为"><a class="markdownIt-Anchor" href="#其中createsemaphore用来创建一个信号量内核对象其函数原型为"></a> 其中CreateSemaphore用来创建一个信号量内核对象，其函数原型为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateSemaphore(</span><br><span class="line">LPSECURITY_ATTRIBUTES IpSemaphoreAttributes,//安全属性指针</span><br><span class="line">LONG IInitialCount,//初始计数</span><br><span class="line">LONG IMaximumCount,//最大计数</span><br><span class="line">LPCTSTR IpName//对象名指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参数IMaximumCount是一个有符号32位值，定义了允许的最大资源计数，最大取值不能<br>超过4294967295， IpName参数可以为创建的信号量定义一个名字，由于其创建的是一个内核<br>对象，因此在其他进程中可以通过该名字而得到此信号量。</p><h4 id="opensemaphore-函数即可用来根据信号量名打开在其他进程中创建的信号量函数原型如下"><a class="markdownIt-Anchor" href="#opensemaphore-函数即可用来根据信号量名打开在其他进程中创建的信号量函数原型如下"></a> OpenSemaphore （）函数即可用来根据信号量名打开在其他进程中创建的信号量，函数原型如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenSemaphore(</span><br><span class="line">DWORD dwDesiredAccess,//访问标志</span><br><span class="line">BOOL bInheritHandle,//继承标志</span><br><span class="line">LPCTSTR IpName//信号量名</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在线程离开对共享资源的处理时，必须通过ReleaseSemaphore来增加当前可用资源计数。否则，将会出现当前正在处理共享资源的实际线程数并没有达到要限制的数值，而其他线程却因为当前可用资源计数为0而仍无法进入的情况。</p><h4 id="releasesemaphore的函数原型为"><a class="markdownIt-Anchor" href="#releasesemaphore的函数原型为"></a> ReleaseSemaphore的函数原型为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL ReleaseSemaphore(</span><br><span class="line">HANDLE hSemaphore,//信号量句柄</span><br><span class="line">LONG IReleaseCount,//计数递增数量</span><br><span class="line">LPLONG IpPreviousCount//先前计数</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该函数将IReleaseCount中的值添加给信号量的当前资源计数，一般将IReleaseCount设置<br>为1，如果需要也可以设置其他的值。</p><p>WaitForSingleObject和WaitForMultipleObjects主要用在试图进入共享资源的线程函数入口处，主要用来判断信号量的当前可用资源计数是否允许本线程的进入。</p><p>只有在当前可用资源计数值大于0时，被监视的信号量内核对象才会得到通知。</p><p>信号量的使用特点使甚更适用于对Socket （套接字）程序中线程的同步。</p><p>例如，网络上的HTTP服务器要对同一时间内访问同一页面的用户数加以限制，这时可以为没一个用户对服务<br>器的页面请求设置一个线程，而页面则是待保护的共享资源，通过使用信号量对线程的同步作用可以确保在任一时刻无论有多少用户对某一页面进行访问，只有不大于设定的最大用户数目的线程能够进行访问，而其他的访问企图则被挂起，只有在有用户退出对此页面的访问后才有可能进入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;process.h&gt;//使用_beginthreadex创建线程需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量对象句柄</span></span><br><span class="line">HANDLE hSemaphore;</span><br><span class="line"></span><br><span class="line"><span class="function">UINT WINAPI <span class="title">myThread</span><span class="params">(LPVOID pParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//试图进入信号量关口</span></span><br><span class="line">WaitForSingleObject(hSemaphore, INFINITE);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放信号量计数</span></span><br><span class="line">ReleaseSemaphore(hSemaphore,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建信号量对象</span></span><br><span class="line">hSemaphore = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">HANDLE h1 = (HANDLE) _beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE h2 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE h3 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE h4 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(h1, INFINITE);</span><br><span class="line">WaitForSingleObject(h2, INFINITE);</span><br><span class="line">WaitForSingleObject(h3, INFINITE);</span><br><span class="line">WaitForSingleObject(h4, INFINITE);</span><br><span class="line">   </span><br><span class="line">    CloseHandle(h1);</span><br><span class="line">    CloseHandle(h2);</span><br><span class="line">    CloseHandle(h3);</span><br><span class="line">    CloseHandle(h4);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥内核对象"><a class="markdownIt-Anchor" href="#互斥内核对象"></a> 互斥内核对象</h3><p>互斥（Mutex）是一种用途非常广泛的内核对象。</p><p>能够保证多个线程对同一共享资源的互斥访问。</p><p>同临界区有些类似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。</p><p>当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。</p><p>与其他几种内核对象不同，互斥对象在操作系统中拥有特殊代码，并由操作系统来管理，操作系统<br>甚至还允许其进行一些其他内核对象所不能进行的非常规操作。</p><p><img src="/javawz/1622074362650.png" alt="1622074362650"></p><p>黑点表示令牌，只有拿到令牌的线程才能进入访问资源，访问结束后要交出令牌，不然其他线程会一直无法访问该资源。</p><p>以互斥内核对象来保持线程同步可能用到的函数主要有CreateMutex、OpenMutex.<br>ReleaseMutex、 WaitForSingleObject和WaitForMultipleObjects等。</p><p>在使用互斥对象前，首先要通过CreateMutex或OpenMutex创建或打开一个互斥对象。</p><h4 id="createmutex函数原型如下"><a class="markdownIt-Anchor" href="#createmutex函数原型如下"></a> CreateMutex函数原型如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateMutex(</span><br><span class="line">LPSECURITY_ATTRIBUTES IpMutexAttributes， //安全属性指针</span><br><span class="line">BOOL bInitialOwner，//初始拥有者</span><br><span class="line">LPCTSTR IpName//互斥对象名</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数blnitialowner主要用来控制互斥对象的初始状态。一般多将其设置为FALSE，以表<br>明互斥对象在创建时并没有为任何线程所占有。</p><p>如果在创建互斥对象时指定了对象名，那么可以在本进程其他地方或是在其他进程通过OpenMutex函数得到此互斥对象的句柄。</p><h4 id="openmutex函数原型为"><a class="markdownIt-Anchor" href="#openmutex函数原型为"></a> OpenMutex函数原型为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenMutex(</span><br><span class="line">DWORD dwDesiredAccess，//访问标志</span><br><span class="line">BOOL bInheritHandle， //继承标志</span><br><span class="line">LPCTSTR IpName//互斥对象名</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当目前对资源具有访问权的线程不再需要访问此资源而要离开时，必须通过ReleaseMutex函数来释放其拥有的互斥对。</p><h4 id="releasemutex函数原型为"><a class="markdownIt-Anchor" href="#releasemutex函数原型为"></a> ReleaseMutex函数原型为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL ReleaseMutex(HANDLE hMutex);</span><br></pre></td></tr></table></figure><p>其惟一的参数hMutex为待释放的互斥对象句柄。</p><p>至于WaitForSingleObject和WaitForMultipleObjects等待函数在互斥对象保持线程同步中所起的作用与在其他内核对象中的作用是基本一致的，也是等待互斥内核对象的通知。</p><p>但是这里需要特别指出的是：在互斥对象通知引起调用等待函数返回时，等待函数的返回值不再是通常的<code>WAIT_OBJECT_0</code> （对于WaitForSingleObject函数）或是在<code>WAIT_OBJECT_0</code>到<code>WAIT_OBJECT_0+nCount-1</code>之间的一个值（对于WaitForMultipleObiects函数）</p><p>而是将返回一个<code>WAIT_ABANDONED_0</code> （对于WaitForSingleObject函数）或是在<code>WAIT_ABANDONED_0</code>到<code>WAIT_ABANDONED_0+nCount-1</code>之间的一个值（对于WaitForMultipleObjects函数） ，以此来表明线程正在等待的互斥对象由另外一个线程所拥有，而此线程却在使用完共享资源前就已经终止。</p><p>除此之外，使用互斥对象的方法在等待线程的可调度性上同使用其他几种内核对象的方法也有所不同，其他内核对象在没有得到通知时，受调用等待函数的作用，线程将会挂起，同时失去可调度性，<code>而使用互斥的方法却可以在等待的同时仍具有可调度性，这也正是互斥对象所能完成的非常规操作之一</code></p><h4 id="关于wait_abandoned或wait_abandoned_0返回值"><a class="markdownIt-Anchor" href="#关于wait_abandoned或wait_abandoned_0返回值"></a> 关于WAIT_ABANDONED或WAIT_ABANDONED_0返回值</h4><p>假设有A、B两个线程和一个互斥量hMutex。如果A线程调用WaitForSingleObject获取到互斥量后，并没有调用ReleaseMutex来释放互斥量就终止了（如调用了ExitThread,TerminateThread）。然后线程B调用WaitForSingleObject就会返回WAIT_ABANDONED，并且线程B获取到互斥量，线程B使用完成后应该调用ReleasMutex释放互斥量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量对象句柄</span></span><br><span class="line">HANDLE hMutex;</span><br><span class="line">HANDLE h1;</span><br><span class="line">HANDLE h2;</span><br><span class="line">HANDLE h3;</span><br><span class="line">HANDLE h4; </span><br><span class="line"></span><br><span class="line"><span class="function">UINT WINAPI <span class="title">myThread</span><span class="params">(LPVOID pParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了"</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ReleaseMutex(hMutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//试图进入信号量关口</span></span><br><span class="line">DWORD dw =  WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line"><span class="keyword">switch</span> (dw)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WAIT_FAILED:</span><br><span class="line"><span class="comment">// 调用WaitForMultipleObjects函数失败(句柄无效？)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="string">"调用WaitForMultipleObjects函数失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_TIMEOUT:</span><br><span class="line"><span class="comment">// 在10毫秒后没有一个内核对象受信</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="string">"等待10ms后Mutex内核对象未受信,所以结束本线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0:</span><br><span class="line"><span class="comment">// hMutex句柄对应的内核对象受信</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="string">" hMutex句柄对应的内核对象受信,本线程会正常工作"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_ABANDONED_0:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"上一个线程在使用完之后,没有使用ReleaseMutex释放"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">":  "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ReleaseMutex(hMutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">":  "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//释放信号量计数</span></span><br><span class="line"><span class="comment">//ReleaseMutex(hMutex);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建信号量对象</span></span><br><span class="line">hMutex = CreateMutex(<span class="literal">NULL</span>,FALSE,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">h1 = (HANDLE) _beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"a"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">h2 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"b"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">h3 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"c"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">h4 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"d"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(h1, INFINITE);</span><br><span class="line">WaitForSingleObject(h2, INFINITE);</span><br><span class="line">WaitForSingleObject(h3, INFINITE);</span><br><span class="line">WaitForSingleObject(h4, INFINITE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写程序时，互斥对象多用在对那些为多个线程所访问的内存块的保护上，可以确保任<br>何线程在处理此内存块时都对其拥有可靠的独占访问权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量对象句柄</span></span><br><span class="line">HANDLE hMutex;</span><br><span class="line">HANDLE h1;</span><br><span class="line">HANDLE h2;</span><br><span class="line">HANDLE h3;</span><br><span class="line">HANDLE h4; </span><br><span class="line"></span><br><span class="line"><span class="function">UINT WINAPI <span class="title">myThread</span><span class="params">(LPVOID pParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了"</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//试图进入信号量关口</span></span><br><span class="line">DWORD dw =  WaitForSingleObject(hMutex, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">switch</span> (dw)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WAIT_FAILED:</span><br><span class="line"><span class="comment">// 调用WaitForMultipleObjects函数失败(句柄无效？)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="string">"调用WaitForMultipleObjects函数失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_TIMEOUT:</span><br><span class="line"><span class="comment">// 在10毫秒后没有一个内核对象受信</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="string">"等待10ms后Mutex内核对象未受信,所以结束本线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0:</span><br><span class="line"><span class="comment">// hMutex句柄对应的内核对象受信</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="string">" hMutex句柄对应的内核对象受信,本线程会正常工作"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sleep(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">":  "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//释放信号量计数</span></span><br><span class="line">ReleaseMutex(hMutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建信号量对象</span></span><br><span class="line">hMutex = CreateMutex(<span class="literal">NULL</span>,FALSE,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">h1 = (HANDLE) _beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"a"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">h2 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"b"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">h3 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"c"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">h4 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"d"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(h1, INFINITE);</span><br><span class="line">WaitForSingleObject(h2, INFINITE);</span><br><span class="line">WaitForSingleObject(h3, INFINITE);</span><br><span class="line">WaitForSingleObject(h4, INFINITE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程局部存储"><a class="markdownIt-Anchor" href="#线程局部存储"></a> 线程局部存储</h3><p>线程局部存储（thread-local storage， TLS）是一个使用很方便的存储线程局部数据的系统。<br>利用TLS机制可以为进程中所有的线程关联若干个数据，各个线程通过由TLS分配的全局索引来访问与自己关联的数据。</p><p>这样，每个线程都可以有线程局部的静态存储数据。<br>用于管理TLS的数据结构是很简单的， Windows仅为系统中的每一个进程维护一个位数组，再为该进程中的每一个线程申请一个同样长度的数组空间。</p><p><img src="/javawz/1622081496611.png" alt="1622081496611"></p><p>运行在系统中的每一个进程都有一个位数组。</p><p>位数组的成员是一个标志，每个标志的值被设为FREE或INUSE，指示了此标志对应的数组索引是否在使用中。</p><p>Windodws保证至少有TLS_MINIMUM_AVAILABLE（定义在WinNTh文件中）个标志位可用。</p><h4 id="1主线程调用tisalloc函数为线程局部存储分配索引函数原型为"><a class="markdownIt-Anchor" href="#1主线程调用tisalloc函数为线程局部存储分配索引函数原型为"></a> （1）主线程调用TIsAlloc函数为线程局部存储分配索引，函数原型为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD TIsAlloc(void);//返回一个TLS索引</span><br></pre></td></tr></table></figure><p>系统为每一个进程都维护着一个长度为TLS_MINIMUM_AVAILABLE的位数组， TIsAlloc的返回值就是数组的一个下标（索引）。</p><p>这个位数组的惟一用途就是记忆哪一个下标在使用中。</p><p>初始状态下，此位数组成员的值都是FREE，表示未被使用。</p><p>当调用TIsAlloc的时候，系统会挨个检查这个数组中成员的值，直到找到一个值为FREE的成员。把找到的成<br>员的值由FREE改为INUSE后， TIsAlloc函数返回该成员的索引。</p><p>如果不能找到一个值为FREE的成员， TIsAlloc函数就返回TLS_OUT_OF_INDEXES （在WinBase.h文件中定义为-1），意味着失败。</p><h5 id="当一个线程被创建时-windows就会在进程地址空间中为该线程分配一个长度为tls_minimum_available的数组数组成员的值都被初始化为0"><a class="markdownIt-Anchor" href="#当一个线程被创建时-windows就会在进程地址空间中为该线程分配一个长度为tls_minimum_available的数组数组成员的值都被初始化为0"></a> 当一个线程被创建时， Windows就会在进程地址空间中为该线程分配一个长度为TLS_MINIMUM_AVAILABLE的数组，数组成员的值都被初始化为0。</h5><h5 id="在内部系统将此数组与该线程关联起来保证只能在该线程中访问此数组中的数据"><a class="markdownIt-Anchor" href="#在内部系统将此数组与该线程关联起来保证只能在该线程中访问此数组中的数据"></a> 在内部，系统将此数组与该线程关联起来，保证只能在该线程中访问此数组中的数据。</h5><h5 id="每个线程都有它自己的数组数组成员可以存储任何数据"><a class="markdownIt-Anchor" href="#每个线程都有它自己的数组数组成员可以存储任何数据"></a> 每个线程都有它自己的数组，数组成员可以存储任何数据。</h5><h4 id="2每个线程调用tissetvalue和tisgetvalue设置或读取线程数组中的值tissetvalue函数原型为"><a class="markdownIt-Anchor" href="#2每个线程调用tissetvalue和tisgetvalue设置或读取线程数组中的值tissetvalue函数原型为"></a> （2）每个线程调用TIsSetValue和TIsGetValue设置或读取线程数组中的值，TIsSetValue函数原型为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL TIsSetValue(</span><br><span class="line">DWORD dwTisindex,//TLS索引</span><br><span class="line">LPVOID IpTIsValue//要设置的值</span><br><span class="line">);</span><br><span class="line">LPVOID TIsGetValue(DWORD dwTIslIndex);//TLS索引</span><br></pre></td></tr></table></figure><p>TlsSetValue函数将参数IpTIsValue指定的值放入索引为dwTIsIndex的线程数组成员中。</p><p>这样，IpTisValue的值就与调用TIisSetValue函数的线程关联了起来。</p><p>此函数调用成功，会返回TRUE</p><p>调用TIsSetValue函数，一个线程只能改变自己线程数组中成员的值，而没有办法为另<br>个线程设置TLS值。</p><p>到现在为止，将数据从一个线程传到另一个线程的惟一方法是在创建线<br>程时使用线程函数的参数。</p><p>TIsGetValue函数的作用是取得线程数组中索引为dwTIsIndex的成员的值。</p><p>TlsSetValue和TIsGetValue分别用于设置和取得线程数组中的特定成员的值，而它们使用<br>的索引就是TIsAlloc函数的返回值。</p><p>这就充分说明了进程中惟一的位数组和各线程数组的关系。</p><p>例如， TIsAlloc返回3，那就说明索引3被此进程中的每一个正在运行的和以后要被创建的线程保存起来，用以访问各自线程数组中对应的成员的值。</p><p>（3）主线程调用TIsFree释放局部存储索引。函数的惟一参数是TIsAlloc返回的索引。<br>利用TLS可以给特定的线程关联一个数据。比如下面的例子将每个线程的创建时间与该<br>线程关联了起来，这样，在线程终止的时候就可以得到线程的生命周期。整个跟踪线程运行时<br>间的例子的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 02UseTLS.cpp.cpp文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用TLS记录线程的运行时间</span></span><br><span class="line"></span><br><span class="line">DWORD g_tlsUsedTime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStartTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">GetUsedTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化开始时间</span></span><br><span class="line">InitStartTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟长时间工作</span></span><br><span class="line">i = <span class="number">10000</span>*<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>(i--) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出本线程运行的时间</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" This thread is coming to end. Thread ID: %-5d, Used Time: %d \n"</span>, </span><br><span class="line">::GetCurrentThreadId(), GetUsedTime());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UINT uId;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">HANDLE h[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过在进程位数组中申请一个索引，初始化线程运行时间记录系统</span></span><br><span class="line">g_tlsUsedTime = ::TlsAlloc(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 令十个线程同时运行，并等待它们各自的输出结果</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">h[i] = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">::WaitForSingleObject(h[i], INFINITE);</span><br><span class="line">::CloseHandle(h[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过释放线程局部存储索引，释放时间记录系统占用的资源</span></span><br><span class="line">::TlsFree(g_tlsUsedTime);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化线程的开始时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStartTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获得当前时间，将线程的创建时间与线程对象相关联</span></span><br><span class="line">DWORD dwStart = ::GetTickCount();</span><br><span class="line">::TlsSetValue(g_tlsUsedTime, (LPVOID)dwStart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得一个线程已经运行的时间</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetUsedTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获得当前时间，返回当前时间和线程创建时间的差值</span></span><br><span class="line">DWORD dwElapsed = ::GetTickCount();</span><br><span class="line">dwElapsed = dwElapsed - (DWORD)::TlsGetValue(g_tlsUsedTime);</span><br><span class="line"><span class="keyword">return</span> dwElapsed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetTickCount</code>函数可以取得Windows从启动开始经过的时间，其返回值是以毫秒为单位<br>的已启动的时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;win32程序的执行单元&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#win32程序的执行单元&quot;&gt;&lt;/a&gt; Win32程序的执行单元&lt;/h1&gt;
&lt;h3 id=&quot;线程的创建&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h
      
    
    </summary>
    
      <category term="windows程序设计" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Win32程序运行原理</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/19/win0002-Win32%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/19/win0002-Win32程序运行原理/</id>
    <published>2021-05-18T18:02:51.000Z</published>
    <updated>2021-05-19T16:27:45.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="win32程序运行原理"><a class="markdownIt-Anchor" href="#win32程序运行原理"></a> Win32程序运行原理</h1><h3 id="cpu的保护模式和windows系统"><a class="markdownIt-Anchor" href="#cpu的保护模式和windows系统"></a> CPU的保护模式和Windows系统</h3><p>80386处理器有三种工作模式：实模式、保护模式和虚拟86模式</p><p>实模式和虚拟模式是为了和8086处理器兼容而设置的</p><p>Windows操作系统运行在保护模式中</p><h4 id="windows的多任务实现"><a class="markdownIt-Anchor" href="#windows的多任务实现"></a> Windows的多任务实现</h4><p>多任务隔离技术：可以使每个任务都有独立的地址空间，就像每个任务独享一个CPU一样</p><p>在Windows中任务被进程取代</p><p>进程就是正在运行的应用程序的实例（执行它的是线程，进程实则就是一块应用程序的空间）</p><p>Windows是多任务操作系统 每个进程内的线程只能访问自己 线程的内存，不能访问其他进程的内存</p><p>例如 有进程A，B</p><p>A进程中的线程只能访问自己进程的内存，不能访问B进程中的地址</p><h3 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h3><p>Windows为每个进程分配4GB的地址空间主要依靠CPU支持</p><p>CPU在保护模式下支持虚拟存储</p><p>虚拟内存：将磁盘空间当做内存空间来使用</p><p>页文件：包含了对所有进程都有效的虚拟内存</p><p>4GB虚拟地址的前半部分留给系统，后半部分留给用户</p><p><img src="/images/javawz/1621362607000.png" alt="1621362607000"></p><p>系统空间：内核代码、设备驱动代码等等。部分空间是共享的</p><h3 id="内核模式和用户模式"><a class="markdownIt-Anchor" href="#内核模式和用户模式"></a> 内核模式和用户模式：</h3><p>80386处理器共定义了4中（0~3）特权级别 称为<code>环</code></p><p><img src="/images/javawz/1621363114545.png" alt="1621363114545"></p><p>0是特权级(最高级)</p><p>3是用户级</p><p>Windows有两种模式:</p><p>内核模式是0级：系统程序（驱动等等）</p><p>用户模式是3级</p><p>当应用程序调用系统函数时，会从用户模式切换到内核模式去执行</p><h3 id="内核对象"><a class="markdownIt-Anchor" href="#内核对象"></a> 内核对象</h3><p>内核对象：系统提供用户模式下代码与内核模式下代码进行交互的基本接口。</p><p><img src="/images/javawz/1621364048617.png" alt="1621364048617"></p><p>对象句柄：</p><p>调用函数创建一个内核对象时会返回一个此对象的句柄</p><p>很多API函数都需要使用此句柄来辨别处理哪个内核对象，该句柄仅对创建该内核对象的进程有效</p><p>也可以多个进程共享一个内核对象，调用<code>DuplicateHandle</code>复制一个进程句柄传给其他进程</p><h3 id="使用计数"><a class="markdownIt-Anchor" href="#使用计数"></a> 使用计数</h3><p>系统为进程分配内核对象资源时,会将内核对象使用计数属性初始化为1</p><p>以后每次打开这个内核对象,系统就会将使用计数加1,关闭则减1</p><p>使用计数为0时,说明这个内核对象所有引用都已经关闭,系统会释放该内核对象资源</p><h3 id="进程的创建"><a class="markdownIt-Anchor" href="#进程的创建"></a> 进程的创建</h3><h4 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程:</h4><p>进程:</p><p>磁盘将可执行文件载入内存之后就变成了进程</p><p>进程是一个正在运行的程序</p><p>拥有自己的虚拟空间地址、代码、数据、其他系统资源</p><p>有一个或多个线程</p><p>一个进程要完成任何事情，必须拥有一个在它地址空间中运行的线程，此线程负责执行该进程地址空间的代码</p><p>线程:</p><p>进程内执行代码的独立实体</p><p>系统创建一个进程后，会创建一个线程来执行进程内的代码，这个线程称为主线程</p><p>主线程运行过程中可以创建其他线程，一般主线程创建的线程称为辅助线程或子线程</p><p>组成Win32进程的两个部分</p><p>1.进程内核对象：操作系统使用此内核对象进行管理该进程</p><p>2.私有的虚拟地址空间：包含了所有可执行的或是DLL模块的代码和数据、程序动态申请内存的地方</p><h3 id="应用程序的启动过程"><a class="markdownIt-Anchor" href="#应用程序的启动过程"></a> 应用程序的启动过程</h3><h5 id="控制台应用程序的启动过程"><a class="markdownIt-Anchor" href="#控制台应用程序的启动过程"></a> 控制台应用程序的启动过程</h5><p>1.操作系统会调用C/C<ins>运行期启动函数（会初始化C/C</ins>运行期库）</p><p>2.C/C++运行期启动函数调用入口main函数</p><h5 id="win32应用程序的启动过程"><a class="markdownIt-Anchor" href="#win32应用程序的启动过程"></a> Win32应用程序的启动过程</h5><p>1.操作系统会调用CreateProcess函数来创建一个新的进程</p><p>当一个线程调用CreateProcess函数的时候,系统会创建一个进程内核对象,初始化使用计数为1</p><p>该进程内核对象是一个系统用来管理这个进程的数据结构</p><p>2.为新的进程创建一个虚拟空间,加载应用程序运行时所需要的代码和数据</p><p>3.为新的进程创建一个主线程</p><p>4.主线程会执行C/C++运行期启动代码</p><p>5.C/C++运行期启动代码会调用main函数</p><p>如果系统成功创建一个进程和一个主线程,CreateProcess会返回TRUE,否者返回FALSE</p><p>创建进程称为父进程,被创建进程称为子进程</p><p>系统在创建新进程的时候会传递一个STARTUPINFO类型的变量,这个结构体包含了父进程传递给子进程的一些信息</p><h4 id="startupinfo结构体定义如下"><a class="markdownIt-Anchor" href="#startupinfo结构体定义如下"></a> STARTUPINFO结构体定义如下</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFO</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">DWORD cb;  <span class="comment">//包含STARTUPINFO结构中的字节数.如果Microsoft将来扩展该结构,它可用作版本控制手段.应用程序必须将cb初始化为sizeof(STARTUPINFO) </span></span><br><span class="line">    PSTR lpReserved; <span class="comment">//保留。必须初始化为NULL</span></span><br><span class="line">    PSTR lpDesktop; <span class="comment">//用于标识启动应用程序所在的桌面的名字。如果该桌面存在，新进程便与指定的桌面相关联。如果桌面不存在，便创建一个带有默认属性的桌面，并使用为新进程指定的名字。如果lpDesktop是NULL（这是最常见的情况 ),那么该进程将与当前桌面相关联 </span></span><br><span class="line">    PSTR lpTitle; <span class="comment">//用于设定控制台窗口的名称。如果lpTitle是NULL，则可执行文件的名字将用作窗口名.This parameter must be NULL for GUI or console processes that do not create a new console window.</span></span><br><span class="line">    DWORD dwX; <span class="comment">//用于设定应用程序窗口相对屏幕左上角位置的x 坐标（以像素为单位）。 </span></span><br><span class="line">    DWORD dwY; <span class="comment">//对于GUI processes用CW_USEDEFAULT作为CreateWindow的x、y参数，创建它的第一个重叠窗口。若是创建控制台窗口的应用程序，这些成员用于指明相对控制台窗口的左上角的位置</span></span><br><span class="line">    DWORD dwXSize; <span class="comment">//用于设定应用程序窗口的宽度（以像素为单位）</span></span><br><span class="line">    DWORD dwYSize; <span class="comment">//子进程将CW_USEDEFAULT 用作CreateWindow 的nWidth、nHeight参数来创建它的第一个重叠窗口。若是创建控制台窗口的应用程序，这些成员将用于指明控制台窗口的宽度 </span></span><br><span class="line">    DWORD dwXCountChars; <span class="comment">//用于设定子应用程序的控制台窗口的宽度（屏幕显示的字节列）和高度（字节行）（以字符为单位） </span></span><br><span class="line">    DWORD dwYCountChars; </span><br><span class="line">    DWORD dwFillAttribute;   <span class="comment">//用于设定子应用程序的控制台窗口使用的文本和背景颜色 </span></span><br><span class="line">    DWORD dwFlags;           <span class="comment">//请参见下一段和表4-7 的说明 </span></span><br><span class="line">    WORD wShowWindow;        <span class="comment">//用于设定如果子应用程序初次调用的ShowWindow 将SW_*作为nCmdShow 参数传递时，该应用程序的第一个重叠窗口应该如何出现。本成员可以是通常用于ShowWindow 函数的任何一个SW_*标识符，除了SW_SHOWDEFAULT. </span></span><br><span class="line">    WORD cbReserved2;        <span class="comment">//保留。必须被初始化为0 </span></span><br><span class="line">    PBYTE lpReserved2;       <span class="comment">//保留。必须被初始化为NULL</span></span><br><span class="line">    HANDLE hStdInput;        <span class="comment">//用于设定供控制台输入和输出用的缓存的句柄。按照默认设置，hStdInput 用于标识键盘缓存，hStdOutput 和hStdError用于标识控制台窗口的缓存 </span></span><br><span class="line">    HANDLE hStdOutput; </span><br><span class="line">    HANDLE hStdError; </span><br><span class="line">&#125; STARTUPINFO, *LPSTARTUPINFO;</span><br></pre></td></tr></table></figure><h4 id="dwflags-使用标志及含义"><a class="markdownIt-Anchor" href="#dwflags-使用标志及含义"></a> dwFlags 使用标志及含义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STARTF_USESIZE <span class="comment">// 使用dwXSize和dwYSize成员</span></span><br><span class="line">STARTF_USESHOWWINDOW <span class="comment">//使用wShowWindow成员</span></span><br><span class="line">STARTF_USEPOSITION <span class="comment">//使用dwX和dwY成员</span></span><br><span class="line">STARTF_USECOUNTCHARS <span class="comment">//使用dwXCountChars和dwYCountChars成员</span></span><br><span class="line">STARTF_USEFILLATTRIBUTE <span class="comment">//使用dwFillAttribute成员</span></span><br><span class="line">STARTF_USESTDHANDLES <span class="comment">//使用hStdInput、hStdOutput和hStdError成员</span></span><br><span class="line">STARTF_RUN_FULLSCREEN <span class="comment">//强制在x 8 6 计算机上运行的控制台应用程序以全屏幕方式启动运行</span></span><br></pre></td></tr></table></figure><h4 id="getstartupinfo函数"><a class="markdownIt-Anchor" href="#getstartupinfo函数"></a> GetStartupInfo函数</h4><p>获取父进程创建自己时使用的STARTUPINFO结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">GetStartupInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">LPSTARTUPINFO lpStartupInfo <span class="comment">// STARTUPINFO指针</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>定义一个STARTUPINFO结构体变量后要初始化cb成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFO si = &#123;<span class="keyword">sizeof</span>(STARTUPINFO)&#125;;</span><br><span class="line">GetStartupInfo(&amp;si);</span><br></pre></td></tr></table></figure><h4 id="createprocess函数"><a class="markdownIt-Anchor" href="#createprocess函数"></a> CreateProcess函数</h4><p>用来创建一个新的进程和它的主线程，这个新进程运行指定的可执行文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">BOOL <span class="title">CreateProcess</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">　LPCTSTR lpApplicationName, <span class="comment">// 应用程序名称  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPTSTR lpCommandLine, <span class="comment">// 命令行字符串  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="comment">// 进程的安全属性  NULL默认安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPSECURITY_ATTRIBUTES lpThreadAttributes, <span class="comment">// 线程的安全属性  NULL默认安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">　BOOL bInheritHandles, <span class="comment">// 是否继承父进程的属性  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　DWORD dwCreationFlags, <span class="comment">// 创建标志  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPVOID lpEnvironment, <span class="comment">// 指向新的环境块的指针  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPCTSTR lpCurrentDirectory, <span class="comment">// 指向当前目录名的指针  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPSTARTUPINFO lpStartupInfo, <span class="comment">// 传递给新进程的信息  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPPROCESS_INFORMATION lpProcessInformation <span class="comment">// 新进程返回的信息  </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>lp开头代表是说明变量类型为指针变量</p><p>LPCSTR 是 const char *</p><p>WINDEF.h头文件包含了变量类型对应的宏名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>       DWORD;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span>                 BOOL;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>       BYTE;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>      WORD;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">float</span>               FLOAT;</span><br><span class="line"> <span class="keyword">typedef</span> FLOAT               *PFLOAT;</span><br><span class="line"> <span class="keyword">typedef</span> BOOL near           *PBOOL;</span><br><span class="line"> <span class="keyword">typedef</span> BOOL far            *LPBOOL;</span><br><span class="line"> <span class="keyword">typedef</span> BYTE near           *PBYTE;</span><br><span class="line"> <span class="keyword">typedef</span> BYTE far            *LPBYTE;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> near            *PINT;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> far             *LPINT;</span><br><span class="line"> <span class="keyword">typedef</span> WORD near           *PWORD;</span><br><span class="line"> <span class="keyword">typedef</span> WORD far            *LPWORD;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">long</span> far            *LPLONG;</span><br><span class="line"> <span class="keyword">typedef</span> DWORD near          *PDWORD;</span><br><span class="line"> <span class="keyword">typedef</span> DWORD far           *LPDWORD;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">void</span> far            *LPVOID;</span><br><span class="line"> <span class="keyword">typedef</span> CONST <span class="keyword">void</span> far      *LPCVOID;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span>                 INT;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>        UINT;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>        *PUINT;</span><br></pre></td></tr></table></figure><h4 id="创建一个新的进程打开记事本"><a class="markdownIt-Anchor" href="#创建一个新的进程打开记事本"></a> 创建一个新的进程打开记事本</h4><p><img src="/images/javawz/1621369626292.png" alt="1621369626292"></p><h4 id="process_information结构体"><a class="markdownIt-Anchor" href="#process_information结构体"></a> PROCESS_INFORMATION结构体</h4><p><img src="/images/javawz/1621369983635.png" alt="1621369983635"></p><p>创建了一个进程之后,如果不使用hProcess或hThread时就应该释放它</p><p>父进程必须要有一个CloseHandle函数来关闭CreateProcess函数返回的两个内核对象句柄，否者基本子进程已经终止了,该进程的内核对象和主线程的内核对象仍然没有释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 02CreateProcess.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> szCommandLine[] = <span class="string">"cmd"</span>;</span><br><span class="line">STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">si.dwFlags = STARTF_USESHOWWINDOW;<span class="comment">// 指定wShowWindow成员有效</span></span><br><span class="line">si.wShowWindow = TRUE;<span class="comment">// 此成员设为TRUE的话则显示新建进程的主窗口，</span></span><br><span class="line"><span class="comment">// 为FALSE的话则不显示</span></span><br><span class="line">BOOL bRet = ::CreateProcess (</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 不在此指定可执行文件的文件名</span></span><br><span class="line">szCommandLine,<span class="comment">// 命令行参数</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认进程安全性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认线程安全性</span></span><br><span class="line">FALSE,<span class="comment">// 指定当前进程内的句柄不可以被子进程继承</span></span><br><span class="line">CREATE_NEW_CONSOLE,<span class="comment">// 为新进程创建一个新的控制台窗口</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 使用本进程的环境变量</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 使用本进程的驱动器和目录</span></span><br><span class="line">&amp;si,</span><br><span class="line">&amp;pi);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 既然我们不使用两个句柄，最好是立刻将它们关闭</span></span><br><span class="line">::CloseHandle (pi.hThread);</span><br><span class="line">::CloseHandle (pi.hProcess);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 新进程的进程ID号：%d \n"</span>, pi.dwProcessId);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 新进程的主线程ID号：%d \n"</span>, pi.dwThreadId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>windows是通过dwFlags来查看STARTUPINFO变量中的哪一个成员有效，再去取那个成员的值</p><p>使用wShowWindow成员用STARTF_USESHOWWINDOW</p><p>使用dwXSize和dwXSize用STARTF_USESIZE</p><p>使用dwX，dwY成员用STARTF_USEPOSITION</p><p><code>dwFlags = STARTF_USESHOWWINDOW | STARTF_USESIZE | STARTF_USEPOSITION</code></p><p>则wShowWindow,dwXSize,dwXSize,dwX，dwY成员都有效</p><p>CREATE_NEW_CONSOLE 表示创建一个新的控制台</p><h4 id="closehandle函数"><a class="markdownIt-Anchor" href="#closehandle函数"></a> CloseHandle函数</h4><p>关闭一个内核对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL CloseHandle(</span><br><span class="line"></span><br><span class="line">HANDLE hObject//代表一个已打开对象handle。</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>TRUE：执行成功；</p><p>FALSE：执行失败，可以调用GetLastError()获知失败原因。</p><h3 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h3><h4 id="获取系统进程"><a class="markdownIt-Anchor" href="#获取系统进程"></a> 获取系统进程</h4><hr><h4 id="processentry32-结构"><a class="markdownIt-Anchor" href="#processentry32-结构"></a> PROCESSENTRY32 结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span>  &#123;</span>    </span><br><span class="line">  DWORD   dwSize;   <span class="comment">//   结构大小；    </span></span><br><span class="line">  DWORD   cntUsage;   <span class="comment">//   此进程的引用计数；    </span></span><br><span class="line">  DWORD   th32ProcessID;   <span class="comment">//   进程ID;    </span></span><br><span class="line">  DWORD   th32DefaultHeapID;   <span class="comment">//   进程默认堆ID；    </span></span><br><span class="line">  DWORD   th32ModuleID;   <span class="comment">//   进程模块ID；    </span></span><br><span class="line">  DWORD   cntThreads;   <span class="comment">//   此进程开启的线程计数；    </span></span><br><span class="line">  DWORD   th32ParentProcessID;<span class="comment">//   父进程ID；    </span></span><br><span class="line">  LONG   pcPriClassBase;   <span class="comment">//   线程优先权；    </span></span><br><span class="line">  DWORD   dwFlags;   <span class="comment">//   保留；    </span></span><br><span class="line">  <span class="keyword">char</span>   szExeFile[MAX_PATH];   <span class="comment">//   进程全名；    </span></span><br><span class="line">  &#125;   PROCESSENTRY32;</span><br></pre></td></tr></table></figure><hr><h4 id="createtoolhelp32snapshot"><a class="markdownIt-Anchor" href="#createtoolhelp32snapshot"></a> CreateToolhelp32Snapshot</h4><p>可以通过获取进程信息为指定的进程、进程使用的堆[HEAP]、模块[MODULE]、线程建立一个快照。</p><p>头文件：<code>tlhelp32.h</code></p><p>返回值： 调用成功，返回快照的句柄，调用失败，返回INVALID_HANDLE_VALUE**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**<span class="function">HANDLE WINAPI <span class="title">CreateToolhelp32Snapshot</span><span class="params">(**</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">*DWORD dwFlags,* <span class="comment">//用来指定“快照”中需要返回的对象，可以是TH32CS_SNAPPROCESS等</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">*DWORD th32ProcessID* <span class="comment">//一个进程ID号，用来指定要获取哪一个进程的快照，当获取系统进程列表   //获取 当前进程快照时可以设为0</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>指定快照中包含的系统内容，dwFlags这个参数能够使用下列数值（常量）中的一个或多个。<br><code>TH32CS_INHERIT</code>       声明快照句柄是可继承的。<br><code>TH32CS_SNAPALL</code>        在快照中包含系统中所有的进程和线程。<br><code>TH32CS_SNAPHEAPLIST</code>    在快照中包含在th32ProcessID中指定的进程的所有的堆。<br><code>TH32CS_SNAPMODULE</code>    在快照中包含在th32ProcessID中指定的进程的所有的模块。<br><code>TH32CS_SNAPPROCESS</code>    在快照中包含系统中所有的进程。<br><code>TH32CS_SNAPTHREAD</code>     在快照中包含系统中所有的线程。<br>H32CS_SNAPALL = (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE)</p><hr><h4 id="process32first"><a class="markdownIt-Anchor" href="#process32first"></a> process32First</h4><p>是一个进程获取函数，当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后，我们可以利用process32First函数来获得第一个进程的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">Process32First</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   HANDLE hSnapshot, <span class="comment">//快照句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">   LPPROCESSENTRY32 lppe <span class="comment">//PROCESSENTRY32指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="process32next"><a class="markdownIt-Anchor" href="#process32next"></a> Process32Next</h4><p>是一个进程获取函数，当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后,我们可以利用Process32Next函数来获得下一个进程的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">Process32Next</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   HANDLE hSnapshot, <span class="comment">//快照句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">   LPPROCESSENTRY32 lppe <span class="comment">//PROCESSENTRY32指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><br><hr><h4 id="获取系统进程的例子"><a class="markdownIt-Anchor" href="#获取系统进程的例子"></a> 获取系统进程的例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 02ProcessList.cpp文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt; // 声明快照函数的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PROCESSENTRY32 pe32;</span><br><span class="line"><span class="comment">// 在使用这个结构之前，先设置它的大小</span></span><br><span class="line">pe32.dwSize = <span class="keyword">sizeof</span>(pe32); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 给系统内的所有进程拍一个快照</span></span><br><span class="line">HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" CreateToolhelp32Snapshot调用失败！ \n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历进程快照，轮流显示每个进程的信息</span></span><br><span class="line">BOOL bMore = ::Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line"><span class="keyword">while</span>(bMore)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 进程名称：%s \n"</span>, pe32.szExeFile);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 进程ID号：%u \n\n"</span>, pe32.th32ProcessID);</span><br><span class="line"></span><br><span class="line">bMore = ::Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要忘记清除掉snapshot对象</span></span><br><span class="line">::CloseHandle(hProcessSnap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><hr><h4 id="终止当前进程"><a class="markdownIt-Anchor" href="#终止当前进程"></a> 终止当前进程</h4><p>终止进程也就是结束程序的执行，让它从内存中卸载。进程终止的原因可能有4种:</p><p>(1)主线程的入口函数返回。</p><p>(2)进程中一个线程调用了ExitProcess 函数。</p><p>(3)此进程中的所有线程都结束了。</p><p>(4)其他进程中的一一个线程调 用了TerminateProcess 函数。</p><h4 id="exitprocess结束当前进程函数"><a class="markdownIt-Anchor" href="#exitprocess结束当前进程函数"></a> Exitprocess结束当前进程函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Exitprocess(UINT uExitCode);//uExitCode为退出代码</span><br></pre></td></tr></table></figure><hr><h4 id="terminateprocess终止其他进程函数"><a class="markdownIt-Anchor" href="#terminateprocess终止其他进程函数"></a> TerminateProcess终止其他进程函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL TerminateProcess(</span><br><span class="line">HANDLE hprocess,//要结束的进程句柄</span><br><span class="line">UINT uExitCode//指定目标进程的退出代码</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="openprocess-函数用来打开一个已存在的进程对象并返回进程的句柄"><a class="markdownIt-Anchor" href="#openprocess-函数用来打开一个已存在的进程对象并返回进程的句柄"></a> OpenProcess 函数用来打开一个已存在的进程对象，并返回进程的句柄。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenProcess(</span><br><span class="line">DWORD dwDesiredAccess, //渴望得到的访问权限（标志）</span><br><span class="line">BOOL bInheritHandle, // 是否继承句柄</span><br><span class="line">DWORD dwProcessId// 进程id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>**dwDesiredAccess ：**获取的权限，可分为以下几种</p><p>PROCESS_ALL_ACCESS：获取所有权限</p><p>PROCESS_CREATE_PROCESS：创建进程</p><p>PROCESS_CREATE_THREAD：创建线程</p><p>PROCESS_DUP_HANDLE：使用DuplicateHandle()函数复制一个新句柄</p><p>PROCESS_QUERY_INFORMATION：获取进程的令牌、退出码和优先级等信息</p><p>PROCESS_QUERY_LIMITED_INFORMATION：获取进程特定的某个信息</p><p>PROCESS_SET_INFORMATION：设置进程的某种信息</p><p>PROCESS_SET_QUOTA：使用SetProcessWorkingSetSize函数设置内存限制</p><p>PROCESS_SUSPEND_RESUME：暂停或者恢复一个进程</p><p>PROCESS_TERMINATE：使用Terminate函数终止进程</p><p>PROCESS_VM_OPERATION：在进程的地址空间执行操作</p><p>PROCESS_VM_READ：使用ReadProcessMemory函数在进程中读取内存</p><p>PROCESS_VM_WRITE：使用WriteProcessMemory函数在进程中写入内存</p><p>SYNCHRONIZE：使用wait函数等待进程终止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 02TerminateProcess.cpp文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">TerminateProcessFromId</span><span class="params">(DWORD dwId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line"><span class="comment">// 打开目标进程，取得进程句柄</span></span><br><span class="line">HANDLE hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwId);</span><br><span class="line"><span class="keyword">if</span>(hProcess != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 终止进程</span></span><br><span class="line">bRet = ::TerminateProcess(hProcess, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwId;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 请输入您要终止的进程的ID号： \n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%u"</span>, &amp;dwId);</span><br><span class="line"><span class="keyword">if</span>(TerminateProcessFromId(dwId))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 终止进程成功！ \n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 终止进程失败！ \n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getlasterror获取调用线程的最后出错代码"><a class="markdownIt-Anchor" href="#getlasterror获取调用线程的最后出错代码"></a> GetLastError获取调用线程的最后出错代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD GetLastError(VOID);</span><br></pre></td></tr></table></figure><h4 id="getexitcodeprocess-获取一个已中断进程的退出代码"><a class="markdownIt-Anchor" href="#getexitcodeprocess-获取一个已中断进程的退出代码"></a> GetExitCodeProcess 获取一个已中断进程的退出代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL GetExitCodeProcess(</span><br><span class="line">HANDLE hProcess,//想获取退出代码的一个进程的句柄</span><br><span class="line">LPDWORD lpExitCode//用于装载进程退出代码的一个长整数变量。如进程尚未中止，则设为常数STILL_ACTIVE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一旦进程终止， 就会有下列事件发生:</p><p>(1)所有被这个进程创建或打开的对象句柄就会关闭。</p><p>(2)此进程内的所有线程将终止执行。</p><p>(3)进程内核对象变成受信状态，所有等待在此对象上的线程开始运行，即WaitForSingleObject函数返回。</p><p>(4)系统将进程对象中退出代码的值由STILL_ ACTIVE改为指定的退出码。</p><hr><h4 id="readprocessmemory是一个内存操作函数-其作用为根据进程句柄读入该进程的某个内存空间"><a class="markdownIt-Anchor" href="#readprocessmemory是一个内存操作函数-其作用为根据进程句柄读入该进程的某个内存空间"></a> ReadProcessMemory是一个内存操作函数， 其作用为根据进程句柄读入该进程的某个内存空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL ReadProcessMemory(</span><br><span class="line">HANDLE hProcess,//待读进程的句柄</span><br><span class="line">PVOID pvAddressRemote,//目标进程中待读内容的起始位置</span><br><span class="line">PVOID pvBufferLocal, //用来接受读取数据的缓冲区</span><br><span class="line">DWORD dwSize, //要读取的字节数</span><br><span class="line">PDWORD pdwNumBytesRead//用来供函数返回实际读取的字节数</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="writeprocessmemory是计算机语言中的一种函数-此函数能写入某一进程的内存区域直接写入会出access-violation错误故需此函数入口区必须可以访问否则操作将失败"><a class="markdownIt-Anchor" href="#writeprocessmemory是计算机语言中的一种函数-此函数能写入某一进程的内存区域直接写入会出access-violation错误故需此函数入口区必须可以访问否则操作将失败"></a> WriteProcessMemory是计算机语言中的一种函数。此函数能写入某一进程的内存区域（直接写入会出Access Violation错误），故需此函数入口区必须可以访问，否则操作将失败。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL WriteProcessMemory(</span><br><span class="line">HANDLE hProcess,//由OpenProcess返回的进程句柄。</span><br><span class="line">LPVOID lpBaseAddress,//要写的内存首地址</span><br><span class="line">LPVOID lpBuffer,//指向要写的数据的指针。</span><br><span class="line">DWORD nSize,//要写入的字节数。</span><br><span class="line">LPDWORD lpNumberOfBytesWritten//用来供函数返回实际写入的字节数</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>应该在目标进程的整个用户地址空间进行搜索。在进程的整个4GB地址中，Windows 98系列的操作系统为应用程序预留的是4MB到2GB部分，Windows2000系列的操作系统预留的是64KB到2GB部分，所以在搜索前还要先判断操作系统的类型，以决定搜索的范围。</p><h4 id="osversioninfo-操作系统的信息版本结构"><a class="markdownIt-Anchor" href="#osversioninfo-操作系统的信息版本结构"></a> OSVERSIONINFO 操作系统的信息版本结构</h4><p><img src="/images/javawz/1621378080153.png" alt="1621378080153"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _OSVERSIONINFO &#123;</span><br><span class="line"></span><br><span class="line">DWORD dwOSVersionInfoSize; // 本结构的大小，必须在调用之前设置</span><br><span class="line"></span><br><span class="line">DWORD dwMajorVersion;//操作系统的主版本号</span><br><span class="line"></span><br><span class="line">DWORD dwMinorVersion;//操作系统的次版本号</span><br><span class="line"></span><br><span class="line">DWORD dwBuildNumber;//操作系统的编译版本号</span><br><span class="line"></span><br><span class="line">DWORD dwPlatformld;//操作系统平台。可以是VER_PLATFORM_WIN32_NT (2000系列)等</span><br><span class="line"></span><br><span class="line">TCHAR szCSDVersion[128];//指定安装在系统上的最新服务包，例如“Service Pack3&quot;等</span><br><span class="line"></span><br><span class="line">&#125; OSVERSIONINFO;</span><br></pre></td></tr></table></figure><h4 id="getversionex返回当前操作系统的版本号在64位系统上是32位字节长度"><a class="markdownIt-Anchor" href="#getversionex返回当前操作系统的版本号在64位系统上是32位字节长度"></a> GetVersionEX返回当前操作系统的版本号（在64位系统上是32位字节长度）。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL GetVersionEx(</span><br><span class="line">LPOSVERSIONINFO lpVersionInformation // 指向版本信息结构体的指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h4 id="游戏修改器例子"><a class="markdownIt-Anchor" href="#游戏修改器例子"></a> 游戏修改器例子</h4><p>Windows采用了分页机制来管理内存，每页的大小是4KB (在x86处理器上)。也就是说Windows是以4KB为单位来为应用程序分配内存的。所以可以按页来搜索目标内存，以提高搜索效率。下面的CompareAPage函数的功能就是比较目标进程内存中1页大小的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 02MemRepair.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">FindFirst</span><span class="params">(DWORD dwValue)</span></span>;<span class="comment">// 在目标进程空间进行第一次查找</span></span><br><span class="line"><span class="function">BOOL <span class="title">FindNext</span><span class="params">(DWORD dwValue)</span></span>;<span class="comment">// 在目标进程地址空间进行第2、3、4……次查找</span></span><br><span class="line"></span><br><span class="line">DWORD g_arList[<span class="number">1024</span>];<span class="comment">// 地址列表</span></span><br><span class="line"><span class="keyword">int</span> g_nListCnt;<span class="comment">// 有效地址的个数</span></span><br><span class="line">HANDLE g_hProcess;<span class="comment">// 目标进程句柄</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">WriteMemory</span><span class="params">(DWORD dwAddr, DWORD dwValue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 启动02testor进程</span></span><br><span class="line"><span class="keyword">char</span> szFileName[] = <span class="string">"ConsoleApplication1.exe"</span>;</span><br><span class="line">STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line">::CreateProcess(<span class="literal">NULL</span>, szFileName, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, </span><br><span class="line">CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"><span class="comment">// 关闭线程句柄，既然我们不使用它</span></span><br><span class="line">::CloseHandle(pi.hThread);</span><br><span class="line">g_hProcess = pi.hProcess;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入要修改的值</span></span><br><span class="line"><span class="keyword">int</span>iVal;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Input val = "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行第一次查找</span></span><br><span class="line">FindFirst(iVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出搜索的结果</span></span><br><span class="line">ShowList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(g_nListCnt &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Input val = "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行下次搜索</span></span><br><span class="line">FindNext(iVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示搜索结果</span></span><br><span class="line">ShowList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得新值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" New value = "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iVal);     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入新值</span></span><br><span class="line"><span class="keyword">if</span>(WriteMemory(g_arList[<span class="number">0</span>], iVal))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Write data success \n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">::CloseHandle(g_hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CompareAPage</span><span class="params">(DWORD dwBaseAddr, DWORD dwValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 读取1页内存</span></span><br><span class="line">BYTE arBytes[<span class="number">4096</span>];</span><br><span class="line"><span class="keyword">if</span>(!::ReadProcessMemory(g_hProcess, (LPVOID)dwBaseAddr, arBytes, <span class="number">4096</span>, <span class="literal">NULL</span>))</span><br><span class="line"><span class="keyword">return</span> FALSE;<span class="comment">// 此页不可读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这1页内存中查找</span></span><br><span class="line">DWORD* pdw;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(<span class="keyword">int</span>)<span class="number">4</span>*<span class="number">1024</span><span class="number">-3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pdw = (DWORD*)&amp;arBytes[i];</span><br><span class="line"><span class="keyword">if</span>(pdw[<span class="number">0</span>] == dwValue)<span class="comment">// 等于要查找的值？</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(g_nListCnt &gt;= <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">// 添加到全局变量中</span></span><br><span class="line">g_arList[g_nListCnt++] = dwBaseAddr + i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">FindFirst</span><span class="params">(DWORD dwValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> DWORD dwOneGB = <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">// 1GB</span></span><br><span class="line"><span class="keyword">const</span> DWORD dwOnePage = <span class="number">4</span>*<span class="number">1024</span>;<span class="comment">// 4KB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g_hProcess == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看操作系统类型，以决定开始地址</span></span><br><span class="line">DWORD dwBase;</span><br><span class="line">OSVERSIONINFO vi = &#123; <span class="keyword">sizeof</span>(vi) &#125;;</span><br><span class="line">::GetVersionEx(&amp;vi);</span><br><span class="line"><span class="keyword">if</span> (vi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)</span><br><span class="line">dwBase = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">// Windows 98系列，4MB</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dwBase = <span class="number">64</span>*<span class="number">1024</span>;<span class="comment">// Windows NT系列，64KB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在开始地址到2GB的地址空间进行查找</span></span><br><span class="line"><span class="keyword">for</span>(; dwBase &lt;<span class="number">2</span>*dwOneGB; dwBase += dwOnePage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 比较1页大小的内存</span></span><br><span class="line">CompareAPage(dwBase, dwValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">FindNext</span><span class="params">(DWORD dwValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 保存m_arList数组中有效地址的个数，初始化新的m_nListCnt值</span></span><br><span class="line"><span class="keyword">int</span> nOrgCnt = g_nListCnt;</span><br><span class="line">g_nListCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在m_arList数组记录的地址处查找</span></span><br><span class="line">BOOL bRet = FALSE;<span class="comment">// 假设失败</span></span><br><span class="line">DWORD dwReadValue;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nOrgCnt; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(::ReadProcessMemory(g_hProcess, (LPVOID)g_arList[i], &amp;dwReadValue, <span class="keyword">sizeof</span>(DWORD), <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dwReadValue == dwValue)</span><br><span class="line">&#123;</span><br><span class="line">g_arList[g_nListCnt++] = g_arList[i];</span><br><span class="line">bRet = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出搜索到的地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; g_nListCnt; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%08lX \n"</span>, g_arList[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">WriteMemory</span><span class="params">(DWORD dwAddr, DWORD dwValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ::WriteProcessMemory(g_hProcess, (LPVOID)dwAddr, &amp;dwValue, <span class="keyword">sizeof</span>(DWORD), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 02Testor.cpp文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量测试</span></span><br><span class="line"><span class="keyword">int</span> g_nNum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">198</span>;<span class="comment">// 局部变量测试</span></span><br><span class="line">g_nNum = <span class="number">1003</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 输出个变量的值和地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" i = %d, addr = %08lX;   g_nNum = %d, addr = %08lX \n"</span>,</span><br><span class="line">++i, &amp;i, --g_nNum, &amp;g_nNum);</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;win32程序运行原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#win32程序运行原理&quot;&gt;&lt;/a&gt; Win32程序运行原理&lt;/h1&gt;
&lt;h3 id=&quot;cpu的保护模式和windows系统&quot;&gt;&lt;a class=&quot;markdownIt
      
    
    </summary>
    
      <category term="windows程序设计" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
</feed>
