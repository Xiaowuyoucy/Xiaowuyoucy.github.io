<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanChen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowuyoucy.github.io/"/>
  <updated>2022-01-29T19:00:15.150Z</updated>
  <id>https://xiaowuyoucy.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程同步</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/30/linux083%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/30/linux083线程同步/</id>
    <published>2022-01-29T17:35:19.000Z</published>
    <updated>2022-01-29T19:00:15.150Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-互斥锁"><a class="markdownIt-Anchor" href="#1-互斥锁"></a> 1 互斥锁</h3><h4 id="11互斥锁的使用步骤"><a class="markdownIt-Anchor" href="#11互斥锁的使用步骤"></a> 1.1互斥锁的使用步骤</h4><ul><li><p>第1步：创建一把互斥锁</p><ul><li><code>pthread_mutex_t mutex;</code></li></ul></li><li><p>初始化互斥锁</p><ul><li><code>pthread_mutex_init(&amp;mutex);</code>—相当于mutex=1</li></ul></li><li><p>在代码中寻找共享资源（也称为临界区）</p><ul><li><code>pthread_mutex_lock(&amp;mutex); -- mutex = 0</code></li></ul></li><li><p>临界区代码</p><ul><li><code>pthread_mutex_unlock(&amp;mutex); -- mutex = 1</code></li></ul></li><li><p>释放互斥锁资源</p><ul><li><code>pthread_mutex_destroy(&amp;mutex);</code></li></ul></li></ul><p>注意：必须在所有操作共享资源的线程上都加上锁否则不能起到同步的效果</p><h4 id="12-练习"><a class="markdownIt-Anchor" href="#12-练习"></a> 1.2 练习</h4><ul><li>编写思路：</li></ul><p>1 定义一把互斥锁，应该为一全局变量</p><p><code>pthread_mutex_t mutex;</code></p><p>2 在main函数中对mutex进行初始化</p><p><code>pthread_mutex_init(&amp;mutex, NULL);</code></p><p>3 创建两个线程，在两个线程中加锁和解锁</p><p>4 主线程释放互斥锁资源</p><p><code>pthread_mutex_destroy(&amp;mutex);</code></p><p><img src="/images/javawz/image-20220130014052263.png" alt="image-20220130014052263"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread1</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"world\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread2</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"HELLO "</span>);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WORLD\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1;</span><br><span class="line"><span class="keyword">pthread_t</span> thread2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机数种子</span></span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//互斥锁初始化</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">ret = pthread_create(&amp;thread1, <span class="literal">NULL</span>, mythread1, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = pthread_create(&amp;thread2, <span class="literal">NULL</span>, mythread2, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束</span></span><br><span class="line">pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放互斥锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-死锁"><a class="markdownIt-Anchor" href="#13-死锁"></a> 1.3 死锁</h3><p>死锁并不是linux提供给用户的一种使用方法，而是由于用户使用互斥锁不当引起的一种现象。</p><ul><li>常见的死锁有两种：<ul><li>第一种：自己锁自己，如下图代码片段</li><li>第二种 线程A拥有A锁，请求获得B锁；线程B拥有B锁，请求获得A锁，这样造成线程A和线程B都不释放自己的锁，而且还想得到对方的锁，从而产生死锁，如下图所示：</li></ul></li></ul><p><img src="/images/javawz/image-20220130014154167.png" alt="image-20220130014154167"></p><ul><li>如何解决死锁：<ul><li>让线程按照一定的顺序去访问共享资源</li><li>在访问其他锁的时候，需要先将自己的锁解开</li><li>调用<code>pthread_mutex_trylock</code>，如果加锁不成功会立刻返回</li></ul></li></ul><p>​自己锁自己.<br>​注意点: 线程在异常退出的时候也需要解锁.<br>A线程占用着A锁, 又想去获得B锁; B线程占用着B锁, 又想去获得A锁,<br>​  两个线程都不释放自己的锁, 又想去获得对方的锁, 从而造成了死锁.<br>​  解决方法:<br>​  1 需要先释放自己的锁再去获得其他锁<br>​  2 避免使用嵌套的锁, 让线程按照一定的顺序加锁<br>​  3 可以调用<code>pthread_mutex_trylock</code>函数加锁, 该函数不阻塞, 所以不会产生死锁.</p><h3 id="2-读写锁"><a class="markdownIt-Anchor" href="#2-读写锁"></a> 2 读写锁</h3><ul><li>什么是读写锁<ul><li>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。<strong>写独占、读共享。</strong></li></ul></li><li>读写锁使用场合<ul><li>读写锁非常适合于对数据结构读的次数远大于写的情况。</li></ul></li><li>读写锁特性<ul><li>读写锁是“写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞。</li><li>读写锁是“读模式加锁”时，如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</li><li>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高</li></ul></li><li>读写锁场景练习:<ul><li>线程A加写锁成功, 线程B请求读锁<ul><li>线程B阻塞</li></ul></li><li>线程A持有读锁, 线程B请求写锁<ul><li>线程B阻塞</li></ul></li><li>线程A拥有读锁, 线程B请求读锁<ul><li>线程B加锁成功</li></ul></li><li>线程A持有读锁, 然后线程B请求写锁, 然后线程C请求读锁<ul><li>B阻塞，c阻塞 - 写的优先级高</li><li>A解锁，B线程加写锁成功，C继续阻塞</li><li>B解锁，C加读锁成功</li></ul></li><li>线程A持有写锁, 然后线程B请求读锁, 然后线程C请求写锁<ul><li>BC阻塞</li><li>A解锁，C加写锁成功，B继续阻塞</li><li>C解锁，B加读锁成功</li></ul></li></ul></li><li>读写锁总结</li></ul><p>读并行，写独占，当读写同时等待锁的时候写的优先级高</p><ul><li><p>读写锁主要操作函数</p><ul><li>定义一把读写锁<ul><li><code>pthread_rwlock_t rwlock;</code></li></ul></li><li>初始化读写锁<ul><li><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></li><li>函数参数</li><li>rwlock-读写锁</li><li>attr-读写锁属性，传NULL为默认属性</li></ul></li><li>销毁读写锁<ul><li><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></li></ul></li><li>加读锁<ul><li><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></li></ul></li><li>尝试加读锁<ul><li><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></li></ul></li><li>加写锁<ul><li><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></li></ul></li><li>尝试加写锁<ul><li><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></li></ul></li><li>解锁<ul><li><code>int pthread_rwlock_unlock(&amp;pthread_rwlock_t *rwlock);</code></li></ul></li></ul></li><li><p>练习：3个线程不定时写同一全局资源，5个线程不定时读同一全局资源。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读写锁测试程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把读写锁</span></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写线程回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_write</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加写锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">cur = number;</span><br><span class="line">cur++;</span><br><span class="line">number = cur;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]-W:[%d]\n"</span>, i, cur);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读线程回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_read</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加读锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">cur = number;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]-R:[%d]\n"</span>, i, cur);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">pthread_t</span> thread[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//读写锁初始化</span></span><br><span class="line">pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建3个写子线程</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">pthread_create(&amp;thread[i], <span class="literal">NULL</span>, thread_write, &amp;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建5个读子线程</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">pthread_create(&amp;thread[i], <span class="literal">NULL</span>, thread_read, &amp;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回收子线程</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n; j++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_join(thread[j], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-条件变量"><a class="markdownIt-Anchor" href="#3-条件变量"></a> 3 条件变量</h3><ul><li>条件本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。<ul><li>使用互斥量保护共享数据;</li><li>使用条件变量可以使线程阻塞, 等待某个条件的发生, 当条件满足的时候解除阻塞.</li></ul></li><li>条件变量的两个动作:<ul><li>条件不满足, 阻塞线程</li><li>条件满足, 通知阻塞的线程解除阻塞, 开始工作.</li></ul></li><li>条件变量相关函数<ul><li><code>pthread_cond_t cond;</code><ul><li>定义一个条件变量</li></ul></li></ul></li><li><code>int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);</code><ul><li>函数描述:初始化条件变量</li><li>函数参数:<ul><li>cond: 条件变量</li><li>attr: 条件变量属性, 通常传NULL</li></ul></li><li>函数返回值:成功返回0, 失败返回错误号</li></ul></li><li><code>int pthread_cond_destroy(pthread_cond_t *cond);</code><ul><li>函数描述: 销毁条件变量</li><li>函数参数: 条件变量</li><li>返回值: 成功返回0, 失败返回错误号</li></ul></li><li><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code><ul><li>函数描述: 条件不满足, 引起线程阻塞并解锁;<ul><li>​     条件满足, 解除线程阻塞, 并加锁</li></ul></li><li>函数参数:<ul><li>cond: 条件变量</li><li>mutex: 互斥锁变量</li></ul></li><li>函数返回值: 成功返回0, 失败返回错误号</li></ul></li><li><code>int pthread_cond_signal(pthread_cond_t *cond);</code><ul><li>函数描述: 唤醒至少一个阻塞在该条件变量上的线程</li><li>函数参数: 条件变量</li><li>函数返回值: 成功返回0, 失败返回错误号</li></ul></li></ul><p>4 使用条件变量的代码片段</p><p><img src="/images/javawz/image-20220130015559506.png" alt="image-20220130015559506"></p><p>上述代码中，生产者线程调用<code>pthread_cond_signal</code>函数会使消费者线程在<code>pthread_cond_wait</code>处解除阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用条件变量实现生产者和消费者模型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line">NODE *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生产一个节点</span></span><br><span class="line">pNode = (NODE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span>(pNode==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"malloc error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pNode-&gt;data = rand()%<span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"P:[%d]\n"</span>, pNode-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">pNode-&gt;next = head;</span><br><span class="line">head = pNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知消费者线程解除阻塞</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//若条件不满足,需要阻塞等待</span></span><br><span class="line"><span class="comment">//若条件不满足,则阻塞等待并解锁;</span></span><br><span class="line"><span class="comment">//若条件满足(被生成者线程调用pthread_cond_signal函数通知),解除阻塞并加锁 </span></span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C:[%d]\n"</span>, head-&gt;data);</span><br><span class="line">pNode = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pNode);</span><br><span class="line">pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1;</span><br><span class="line"><span class="keyword">pthread_t</span> thread2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化互斥锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量初始化</span></span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建生产者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建消费者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束</span></span><br><span class="line">pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放互斥锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放条件变量</span></span><br><span class="line">pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用条件变量实现生产者和消费者模型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line">NODE *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生产一个节点</span></span><br><span class="line">pNode = (NODE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span>(pNode==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"malloc error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pNode-&gt;data = rand()%<span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"P[%d]:[%d]\n"</span>, n, pNode-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">pNode-&gt;next = head;</span><br><span class="line">head = pNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知消费者线程解除阻塞</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//若条件不满足,需要阻塞等待</span></span><br><span class="line"><span class="comment">//若条件不满足,则阻塞等待并解锁;</span></span><br><span class="line"><span class="comment">//若条件满足(被生成者线程调用pthread_cond_signal函数通知),解除阻塞并加锁 </span></span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C[%d]:[%d]\n"</span>, n, head-&gt;data);</span><br><span class="line">pNode = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pNode);</span><br><span class="line">pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">pthread_t</span> thread2[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化互斥锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量初始化</span></span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i]= i;</span><br><span class="line"><span class="comment">//创建生产者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread1[i], <span class="literal">NULL</span>, producer, &amp;arr[i]);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建消费者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread2[i], <span class="literal">NULL</span>, consumer, &amp;arr[i]);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_join(thread1[i], <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(thread2[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放互斥锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放条件变量</span></span><br><span class="line">pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h3><p>1 信号量介绍</p><p>​信号量相当于多把锁, 可以理解为是加强版的互斥锁</p><p>2 相关函数</p><p>定义信号量 <code>sem_t sem</code>;</p><ul><li><p><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></p><ul><li>函数描述: 初始化信号量</li><li>函数参数:<ul><li>sem: 信号量变量</li><li>pshared: 0表示线程同步, 1表示进程同步</li><li>value: 最多有几个线程操作共享数据</li></ul></li><li>函数返回值:成功返回0, 失败返回-1, 并设置errno值</li></ul></li><li><p><code>int sem_wait(sem_t *sem);</code></p><ul><li>函数描述: 调用该函数一次, 相当于<code>sem--</code>, 当sem为0的时候, 引起阻塞</li><li>函数参数: 信号量变量</li><li>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</li></ul></li><li><p><code>int sem_post(sem_t *sem);</code></p><ul><li>函数描述: 调用一次, 相当于<code>sem++</code></li><li>` 函数参数: 信号量变量</li><li>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</li></ul></li><li><p><code>int sem_trywait(sem_t *sem);</code></p><ul><li>函数描述: 尝试加锁, 若失败直接返回, 不阻塞</li><li>函数参数: 信号量变量</li><li>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</li></ul></li><li><p><code>int sem_destroy(sem_t *sem);</code></p><ul><li>函数描述: 销毁信号量</li><li>函数参数: 信号量变量</li><li>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</li></ul></li></ul><p>3 信号量代码片段:</p><p><img src="/images/javawz/image-20220130020118740.png" alt="image-20220130020118740"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用信号量实现生产者和消费者模型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line">NODE *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> sem_producer;</span><br><span class="line"><span class="keyword">sem_t</span> sem_consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生产一个节点</span></span><br><span class="line">pNode = (NODE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span>(pNode==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"malloc error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pNode-&gt;data = rand()%<span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"P:[%d]\n"</span>, pNode-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">sem_wait(&amp;sem_producer); <span class="comment">//--</span></span><br><span class="line"></span><br><span class="line">pNode-&gt;next = head;</span><br><span class="line">head = pNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">sem_post(&amp;sem_consumer);  <span class="comment">//相当于++</span></span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">sem_wait(&amp;sem_consumer); <span class="comment">//相当于--</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C:[%d]\n"</span>, head-&gt;data);</span><br><span class="line">pNode = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">sem_post(&amp;sem_producer); <span class="comment">//相当于++</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pNode);</span><br><span class="line">pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1;</span><br><span class="line"><span class="keyword">pthread_t</span> thread2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化信号量</span></span><br><span class="line">sem_init(&amp;sem_producer, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">sem_init(&amp;sem_consumer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建生产者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建消费者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束</span></span><br><span class="line">pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放信号量资源</span></span><br><span class="line">sem_destroy(&amp;sem_producer);</span><br><span class="line">sem_destroy(&amp;sem_consumer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-互斥锁&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-互斥锁&quot;&gt;&lt;/a&gt; 1 互斥锁&lt;/h3&gt;
&lt;h4 id=&quot;11互斥锁的使用步骤&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11互斥锁的使用步骤
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>守护进程和线程</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/24/linux082%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/24/linux082守护进程和线程/</id>
    <published>2022-01-24T12:30:39.000Z</published>
    <updated>2022-01-28T15:40:00.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="守护进程"><a class="markdownIt-Anchor" href="#守护进程"></a> 守护进程</h2><h3 id="11-守护进程介绍"><a class="markdownIt-Anchor" href="#11-守护进程介绍"></a> 1.1 守护进程介绍</h3><p>Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字，如vsftpd</p><p>Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。</p><ul><li>总结守护进程的特点：<ul><li>Linux后台服务进程</li><li>独立于控制终端</li><li>周期性的执行某种任务</li><li>不受用户登陆和注销的影响</li><li>一般采用以d结尾的名字</li></ul></li></ul><h3 id="12-进程组和会话"><a class="markdownIt-Anchor" href="#12-进程组和会话"></a> 1.2 进程组和会话</h3><ul><li><p>进程组</p><ul><li>进程组是一个或者多个进程的集合，每个进程都属于一个进程组，引入进程组是为了简化对进程的管理。当父进程创建子进程的时候，默认子进程与父进程属于同一个进程组。</li><li>进程组ID==第一个进程ID（组长进程）。如父进程创建了多个子进程，父进程和多个子进程同属于一个组，而由于父进程是进程组里的第一个进程，所以父进程就是这个组的组长, 组长ID==父进程ID。</li><li>可以使用kill -SIGKILL -进程组ID(负的)来将整个进程组内的进程全部杀死。</li><li>只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</li><li>进程组生存期：从进程组创建到最后一个进程离开</li></ul></li><li><p>会话</p><ul><li>一个会话是一个或多个进程组的集合。</li><li>创建会话的进程不能是进程组组长</li><li>创建会话的进程成为一个进程组的组长进程，同时也成为会话的会长。</li><li>需要有root权限（ubuntu不需要）</li><li>新创建的会话丢弃原有的控制终端</li><li>建立新会话时，先调用fork, 父进程终止，子进程调用setsid函数</li><li>可以使用<code>ps ajx</code>来查看进程组ID和会话ID</li><li>可以fork出几个子进程，然后查看进程组ID和会话ID</li></ul></li><li><p>进程组和会话的关系图</p><p><img src="/images/javawz/image-20220124220938860.png" alt="image-20220124220938860"></p></li></ul><h3 id="13-创建守护进程的模型"><a class="markdownIt-Anchor" href="#13-创建守护进程的模型"></a> 1.3 创建守护进程的模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t setsid(void);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功后，将返回调用进程的（新）会话ID。一旦出错，</span><br><span class="line">返回（pid_t）-1，并设置errno以指示错误。</span><br></pre></td></tr></table></figure><ul><li><p>第1步：fork子进程，父进程退出</p><ul><li>子进程继承了父进程的进程组ID, 但具有一个新的进程ID,这样就保证了子进程不是一个进程组的组长ID,这对于下面要做的setsid函数的调用是必要的前提条件</li></ul></li><li><p>第2步：子进程调用setsid函数创建新会话</p><ul><li>调用这个函数以后</li><li>该进程成为新会话的首进程，是会话的会长</li><li>成为一个新进程组的组长进程，是进程组组长</li><li>不受控制终端的影响</li></ul></li><li><p>第3步：改变当前工作目录<code>chdir</code></p><ul><li>如：a.out在U盘上，启动这个程序，这个程序的当前的工作目录就是这个u盘，如果u盘拔掉后进程的当前工作目录将消失，a.out将不能正常工作。</li></ul></li><li><p>第4步：重设文件掩码  <code>mode &amp; ~umask</code></p><ul><li>子进程会继承父进程的掩码</li><li>增加子进程程序操作的灵活性</li><li><code>umask(0000);</code>最右边的0代表八进制</li></ul></li><li><p>第5步：关闭文件描述符</p><ul><li>守护进程不受控制终端的影响所以可以关闭，以释放资源</li><li><code>close(STDIN_FILENO);</code></li><li><code>close(STDOUT_FILENO);</code></li><li><code>close(STDERR_FILENO);</code></li></ul></li><li><p>第6步：执行核心工作</p><ul><li>守护进程的核心代码逻辑</li></ul></li></ul><h3 id="14练习"><a class="markdownIt-Anchor" href="#14练习"></a> 1.4练习</h3><p>​编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。</p><p>分析：首先要按照1.3介绍的守护进行的步骤创建一个守护进程</p><p>题目要求每隔2S钟，所以需要一个定时器，2S钟触发一次，需要调用<code>setitimer</code>函数创建一个定时器，并且要捕获SIGALRM信号，然后在SIGALRM信号处理函数里面完成获取系统时间，然后将时间写入文件。</p><ul><li>用到的主要知识点：<ul><li>创建守护进程的模型</li><li>setitimer函数的使用</li><li>sigaction函数</li><li>文件I/O操作</li><li>获取系统时间函数time，将<code>time_t</code>类型转换为字符串ctime函数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建守护进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"mydemon.log"</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0755</span>);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前的系统时间</span></span><br><span class="line"><span class="keyword">time_t</span> t;</span><br><span class="line">time(&amp;t);</span><br><span class="line">    <span class="comment">//将时间转换为字符串形式</span></span><br><span class="line"><span class="keyword">char</span> *p = ctime(&amp;t);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将时间写入文件</span></span><br><span class="line">write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//父进程fork子进程, 然后父进程退出</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span> || pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子进程调用setsid函数创建会话</span></span><br><span class="line">setsid();</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变当前的工作目录</span></span><br><span class="line">chdir(<span class="string">"/home/itcast/log"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变文件掩码</span></span><br><span class="line">umask(<span class="number">0000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭标准输入,输出和错误输出文件描述符</span></span><br><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心操作</span></span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = myfunc;</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置时钟</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tm</span>;</span></span><br><span class="line">tm.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">tm.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">tm.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">tm.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">setitimer(ITIMER_REAL, &amp;tm, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化:<br> 1 不再频繁的打开和关闭文件<br> 2 如何控制log文件大小  test.log</p><hr>守护进程的特点:&emsp;1 一个linux后台服务进程&emsp;2 不依赖于控制终端&emsp;3 周期性执行某些任务&emsp;4 不受用户登录和注销的影响&emsp;5 一般以d结尾<p>进程组和会话:<br> 进程组: 一个进程包含多个进程<br> 会话: 多个组组成一个会话.<br> 创建会话的进程不能是组长进程;<br> 一般创建会话是父进程先fork子进程, 然后父进程退出, 让子进程调用setsid函数<br> 创建一个会话, 这个子进程既是会长也是组长;<br> 只要是创建了会话, 这个进程就脱离了控制终端的影响.</p><p>创建守护进程模型:<br>1 父进程fork子进程, 然后父进程退出.<br>目的是: 子进程肯定不是组长进程, 为后续调用setsid函数提供了条件.<br>2 子进程调用setsid函数创建一个新的会话.<br>  1 该子进程成了该会话的会长<br>  2 该子进程成了该组的组长进程.<br>  3 不再受控制终端的影响了<br>3 改变当前的工作目录, chdir  -----不是必须的<br>4 重设文件掩码, umask(0000)  -----不是必须的<br>5 关闭STDIN_FILENO  STDOUT_FILENO STDERR_FILENO   —不是必须的<br>6 核心操作</p><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><ul><li><h3 id="21-什么是线程"><a class="markdownIt-Anchor" href="#21-什么是线程"></a> 2.1 什么是线程</h3><ul><li>轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。</li><li>进程：拥有独立的地址空间，拥有PCB，相当于独居。</li><li>线程：有PCB，但没有独立的地址空间，多个线程共享进程空间，相当于合租。</li></ul></li></ul><p><img src="/images/javawz/image-20220124231226369.png" alt="image-20220124231226369"></p><ul><li><p>在Linux操作系统下：</p><ul><li>线程：最小的执行单位</li><li>进程：最小分配资源单位，可看成是只有一个线程的进程。</li></ul></li><li><p>线程的特点</p><ul><li>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</li><li>线程是轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</li><li>从内核里看进程和线程是一样的，都有各自不同的PCB.</li><li>进程可以蜕变成线程</li><li>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</li></ul></li></ul><p><img src="/images/javawz/image-20220124231358842.png" alt="image-20220124231358842"></p><ul><li>查看指定线程的LWP号：<code>ps –Lf pid</code></li><li>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数 clone。</li><li>如果复制对方的地址空间，那么就产出一个“进程”；</li><li>如果共享对方的地址空间，就产生一个“线程”。</li></ul><p>so：<strong>Linux内核是不区分进程和线程的, 只在用户层面上进行区分</strong>。</p><p>所以，线程所有操作函数<code>pthread_*</code> 是库函数，而非系统调用。</p><h3 id="22-线程共享资源"><a class="markdownIt-Anchor" href="#22-线程共享资源"></a> 2.2 线程共享资源</h3><ul><li>文件描述符表</li><li>每种信号的处理方式</li><li>当前工作目录</li><li>用户ID和组ID</li><li>内存地址空间 (<code>.text/.data/.bss/heap/共享库</code>)</li></ul><h3 id="23-线程非共享资源"><a class="markdownIt-Anchor" href="#23-线程非共享资源"></a> 2.3 线程非共享资源</h3><ul><li>线程id</li><li>处理器现场和栈指针(内核栈)</li><li>独立的栈空间(用户空间栈)</li><li>errno变量</li><li>信号屏蔽字</li><li>调度优先级</li></ul><h3 id="24-线程优-缺点"><a class="markdownIt-Anchor" href="#24-线程优-缺点"></a> 2.4  线程优、缺点</h3><ul><li>优点：<ul><li>提高程序并发性</li><li>开销小</li><li>数据通信、共享数据方便</li></ul></li><li>缺点：<ul><li>库函数，不稳定</li><li>gdb调试、编写困难</li><li>对信号支持不好</li></ul></li></ul><p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p><h3 id="25-pthread_create函数"><a class="markdownIt-Anchor" href="#25-pthread_create函数"></a> 2.5  pthread_create函数</h3><ul><li>头文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br></pre></td></tr></table></figure><ul><li>函数作用：</li><li>创建一个新线程</li><li>函数原型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread, </span><br><span class="line"></span><br><span class="line">const pthread_attr_t *attr,</span><br><span class="line"></span><br><span class="line">      void *(*start_routine) (void *),</span><br><span class="line"></span><br><span class="line"> void *arg</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>返回值</p><ul><li>成功，返回0</li><li>失败，返回错误号</li></ul></li><li><p>函数参数：</p><ul><li><code>pthread_t</code>：传出参数，保存系统为我们分配好的线程ID</li><li>当前Linux中可理解为：<code>typedef unsigned long int pthread_t</code>。</li><li>attr：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。</li><li><code>start_routine</code>：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。</li><li>arg：线程主函数执行期间所使用的参数。</li></ul></li><li><p>注意点</p><ul><li>由于<code>pthread_create</code>的错误码不保存在errno中，因此不能直接用<code>perror()</code>打印错误信息，可以先用<code>strerror()</code>把错误码转换成错误信息再打印。<code>strerror要包含头文件#include&lt;string.h&gt;</code></li><li>如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。</li></ul></li><li><p>练习题：</p></li></ul><p>1 编写程序创建一个线程。</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_t pthread_self(void);</span><br><span class="line"></span><br><span class="line">函数作用：获得线程自身的ID。pthread_t的类型为unsigned long int，所以在打印的时候要使用%lu方式，否则显示结果出问题。</span><br><span class="line"></span><br><span class="line">pthread_self() //获取当前线程id</span><br></pre></td></tr></table></figure><br><h4 id="多线程编译是要指定库"><a class="markdownIt-Anchor" href="#多线程编译是要指定库"></a> 多线程编译是要指定库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc xxx.c -l pthread -o xxx</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>2 编写程序创建一个线程，并给线程传递一个<code>int</code>参数</p><p>3 编写程序创建一个线程，并给线程传递一个结构体参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程: 传递参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int n = *(int *)arg;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> *<span class="title">p</span> = (<span class="title">struct</span> <span class="title">Test</span> *)<span class="title">arg</span>;</span></span><br><span class="line"><span class="comment">//struct Test *p = arg;</span></span><br><span class="line"><span class="comment">//printf("n==[%d]\n", n);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d][%s]\n"</span>, p-&gt;data, p-&gt;name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">99</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;t, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(struct Test));</span><br><span class="line">t.data = <span class="number">88</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(t.name, <span class="string">"xiaowen"</span>);</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="comment">//int ret = pthread_create(&amp;thread, NULL, mythread, &amp;n);</span></span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, &amp;t);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 编写程序，主线程循环创建5个子线程，并让子线程判断自己是第几个子线程。</p><p>练习4分析：最后每个子线程打印出来的值并不是想象中的值，比如都是5，分析其原因：</p><p>在创建子线程的时候使用循环因子作为参数传递给子线程，这样主线程和多个子线程就会共享变量i（变量i在main函数中定义，在整个进程都一直有效）所以在子线程看来变量i是合法的栈内存空间。</p><p>那么为什么最后每个子线程打印出来的值都是5呢?</p><p>是由于主线程可能会在一个cpu时间片内连续创建了5个子线程，此时变量i的值变成了5，当主线程失去cpu的时间片后，子线程得到cpu的时间片，子线程访问的是变量i的内存空间的值，所以打印出来值为5.</p><p><img src="/images/javawz/image-20220124232632703.png" alt="image-20220124232632703"></p><p>主线程和子线程共享同一块内存空间</p><p><img src="/images/javawz/image-20220124232651711.png" alt="image-20220124232651711"></p><p>主线程和子线程分时使用cpu资源</p><p>解决办法：不能使多个子线程都共享同一块内存空间，应该使每个子线程访问不同的内存空间，可以在主线程定义一个数组：<code>int arr[5];</code>，然后创建线程的时候分别传递不同的数组元素，这样每个子线程访问的就是互不相同的内存空间，这样就可以打印正确的值。</p><p>如下图：</p><p><img src="/images/javawz/image-20220124232725306.png" alt="image-20220124232725306"></p><p>多个子线程各自访问不同的内存空间</p><ul><li>根据测试程序还可以得出结论：<ul><li>如果主线程早于子线程退出，则子线程可能得不到执行，因为主线程退出，整个进程空间都会被回收，子线程没有了生存空间，所以也就得不到执行。</li><li>线程之间（包含主线程和子线程）可以共享同一变量，包含全局变量或者非全局变量（但是非全局变量必须在其有效的生存期内）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环创建子线程,并且打印是第几个子线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:child thread, pid==[%d], id==[%ld]\n"</span>, i, getpid(), pthread_self());</span><br><span class="line">sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">pthread_t</span> thread[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">ret = pthread_create(&amp;thread[i], <span class="literal">NULL</span>, mythread, &amp;arr[i]);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26pthread_exit函数"><a class="markdownIt-Anchor" href="#26pthread_exit函数"></a> 2.6pthread_exit函数</h3><p>在线程中禁止调用exit函数，否则会导致整个进程退出，取而代之的是调用<code>pthread_exit</code>函数，这个函数是使一个线程退出，如果主线程调用<code>pthread_exit</code>函数也不会使整个进程退出，不影响其他线程的执行。</p><ul><li><p>函数描述</p><ul><li>将单个线程退出</li></ul></li><li><p>函数原型</p><ul><li><code>void pthread_exit(void *retval);</code></li></ul></li><li><p>函数参数</p><ul><li>retval表示线程退出状态，通常传NULL</li></ul></li></ul><p>另注意，<code>pthread_exit</code>或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了，栈空间就会被回收。</p><p>练习：编写程序测试<code>pthread_exit</code>函数使一个线程退出。</p><p>通过程序测试得知，<code>pthread_exit</code>函数只是使一个线程退出，假如子线程里面调用了exit函数，会使整个进程终止；如果主线程调用了<code>pthread_exit</code>函数，并不影响子线程，只是使主线程自己退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程退出函数测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> g_var = <span class="number">9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"><span class="comment">//printf("[%p]\n", &amp;g_var);</span></span><br><span class="line"><span class="comment">//pthread_exit(&amp;g_var);</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;t, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line">t.data = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(t.name, <span class="string">"xiaowen"</span>);</span><br><span class="line">pthread_exit(&amp;t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//回收子线程</span></span><br><span class="line"><span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">pthread_join(thread, &amp;p);</span><br><span class="line"><span class="comment">//int n = *(int *)p;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> *<span class="title">pt</span> = (<span class="title">struct</span> <span class="title">Test</span> *)<span class="title">p</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child exit status:[%d],[%s],[%p]\n"</span>,  pt-&gt;data, pt-&gt;name, p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="27-pthread_join函数"><a class="markdownIt-Anchor" href="#27-pthread_join函数"></a> 2.7 pthread_join函数</h3><ul><li><p>函数描述：阻塞等待线程退出，获取线程退出状态。其作用，对应进程中的waitpid() 函数。</p></li><li><p>函数原型：<code>int pthread_join(pthread_t thread, void **retval);</code></p></li><li><p>函数返回值：</p><ul><li>成功：0；</li><li>失败：错误号</li></ul></li><li><p>函数参数：</p><ul><li>thread：线程ID</li><li>retval：存储线程结束状态，整个指针和<code>pthread_exit</code>的参数是同一块内存地址。</li></ul></li></ul><p>练习：编写程序，使主线程获取子线程的退出状态。</p><p>一般先定义<code>void *ptr; 然后pthread_join(threadid, &amp;ptr);</code></p><h3 id="28-pthread_detach函数"><a class="markdownIt-Anchor" href="#28-pthread_detach函数"></a> 2.8 pthread_detach函数</h3><p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p><p>进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</p><p>也可使用 pthread_create函数参2(线程属性)来设置线程分离。<code>pthread_detach</code>函数是在创建线程之后调用的。</p><ul><li>函数描述<ul><li>实现线程分离</li></ul></li><li>函数原型<ul><li><code>int pthread_detach(pthread_t thread);</code></li></ul></li><li>函数返回值<ul><li>成功：0；</li><li>失败：错误号</li></ul></li></ul><p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用<code>pthread_ join</code>获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。不能对一个已经处于detach状态的线程调用<code>pthread_ join</code>，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了<code>pthread_detach</code>就不能再调用<code>pthread_ join</code>了。</p><p>练习：编写程序，在创建线程之后设置线程的分离状态。</p><p>说明：如果线程已经设置了分离状态，则再调用<code>pthread_ join</code>就会失败，可用这个方法验证是否已成功设置分离状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置子线程为分离属性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置线程为分离属性</span></span><br><span class="line">pthread_detach(thread);</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程设置分离属性,则pthread_join不再阻塞,立刻返回</span></span><br><span class="line">ret = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_join error:[%s]\n"</span>, strerror(ret));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="29-pthread_cancel函数"><a class="markdownIt-Anchor" href="#29-pthread_cancel函数"></a> 2.9 pthread_cancel函数</h3><ul><li><p>函数描述</p></li><li><p>杀死(取消)线程。其作用，对应进程中 kill() 函数。</p></li><li><p>函数原型</p></li><li><p><code>int pthread_cancel(pthread_t thread);</code></p></li><li><p>函数返回值</p></li><li><p>成功：0；</p></li><li><p>失败：错误号</p></li><li><p>【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。</p></li><li><p>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</p></li><li><p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write… 执行命令<code>man 7 pthreads</code>可以查看具备这些取消点的系统调用列表。可粗略认为一个系统调用(进入内核)即为一个取消点。还以通过调用<code>pthread_testcancel</code>函数设置一个取消点。</p><ul><li>函数原型：<code>void pthread_testcancel(void);</code></li></ul></li></ul><p>练习：编写程序，让主线程取消子线程的执行。</p><p>先测试一下没有取消点看看能否使线程取消；然后调用<code>pthread_testcancel</code>设置一个取消点，看看能够使线程取消。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置取消点</span></span><br><span class="line"><span class="comment">//pthread_testcancel();</span></span><br><span class="line"><span class="comment">//printf也有取消点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消子线程</span></span><br><span class="line">pthread_cancel(thread);</span><br><span class="line"></span><br><span class="line">pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="210-pthread_equal函数"><a class="markdownIt-Anchor" href="#210-pthread_equal函数"></a> 2.10 pthread_equal函数</h3><ul><li>函数描述：</li><li>比较两个线程ID是否相等。</li><li>函数原型</li><li><code>int pthread_equal(pthread_t t1, pthread_t t2);</code></li></ul><p>注意：这个函数是为了以能够扩展使用的， 有可能Linux在未来线程ID <code>pthread_t</code>类型被修改为结构体实现。</p><h3 id="211-进程函数和线程函数比较"><a class="markdownIt-Anchor" href="#211-进程函数和线程函数比较"></a> 2.11 进程函数和线程函数比较</h3><table><thead><tr><th>进程</th><th>线程</th></tr></thead><tbody><tr><td><strong>fork</strong></td><td><strong>pthread_create</strong></td></tr><tr><td><strong>exit</strong></td><td><strong>pthread_exit</strong></td></tr><tr><td><strong>wait/waitpid</strong></td><td><strong>pthread_join</strong></td></tr><tr><td><strong>kill</strong></td><td><strong>pthread_cancel</strong></td></tr><tr><td><strong>getpid</strong></td><td><strong>pthread_self</strong></td></tr></tbody></table><p><br><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较线程ID是否相等</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较线程ID</span></span><br><span class="line"><span class="comment">//if(pthread_equal(thread, pthread_self())!=0)</span></span><br><span class="line"><span class="keyword">if</span>(pthread_equal(pthread_self(), pthread_self())!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"two thread id is same\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"two thread id is not same\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-线程属性"><a class="markdownIt-Anchor" href="#3-线程属性"></a> 3 线程属性</h3><p>linux下线程的属性是可以根据实际项目需要，进行设置，之前讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题，如果对程序的性能提出更高的要求，则需要设置线程属性，本节以设置线程的分离属性为例讲解设置线程属性。</p><ul><li><p>线程的分离状态决定一个线程以什么样的方式来终止自己，有两种状态：</p><ul><li>非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</li><li>分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</li></ul></li><li><p>设置线程属性分为以下步骤</p></li><li><p>第1步：定义线程属性类型类型的变量</p><ul><li><code>pthread_attr_t attr;</code></li></ul></li><li><p>第2步：对线程属性变量进行初始化</p><ul><li><code>int pthread_attr_init (pthread_attr_t* attr);</code></li></ul></li><li><p>第3步：设置线程为分离属性</p></li><li><p><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code></p><ul><li>参数:<ul><li>attr: 线程属性</li><li>detachstate:<ul><li><code>PTHREAD_CREATE_DETACHED</code>(分离)</li><li><code>PTHREAD_CREATE_JOINABLE</code>（非分离)</li></ul></li></ul></li></ul></li></ul><p>注意：这一步完成之后调用<code>pthread_create</code>函数创建线程，</p><p>则创建出来的线程就是分离线程；其实上述三步就是</p><p><code>pthread_create</code>的第二个参数做准备工作。</p><ul><li>第4步：释放线程属性资源<ul><li><code>int pthread_attr_destroy(pthread_attr_t *attr);</code></li><li>参数：线程属性</li></ul></li></ul><p>练习：编写程序，创建一个分离属性的线程。</p><p>验证：设置为分离属性的线程是不能够被<code>pthread_join</code>函数回收的，</p><p>可以通过调用<code>pthread_join</code>函数测试该线程是否已经是分离属性的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在创建子线程的时候设置分离属性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义pthread_attr_t类型的变量</span></span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化attr变量</span></span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置attr为分离属性</span></span><br><span class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, &amp;attr, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放线程属性</span></span><br><span class="line">pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证子线程是否为分离属性</span></span><br><span class="line">ret = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_join error:[%s]\n"</span>, strerror(ret));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-线程同步"><a class="markdownIt-Anchor" href="#4-线程同步"></a> 4 线程同步</h3><h4 id="41-线程同步的概念"><a class="markdownIt-Anchor" href="#41-线程同步的概念"></a> 4.1 线程同步的概念</h4><p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p><h4 id="42-线程同步的例子"><a class="markdownIt-Anchor" href="#42-线程同步的例子"></a> 4.2 线程同步的例子</h4><p>创建两个线程，让两个线程共享一个全局变量<code>int number</code>， 然后让每个线程数5000次数，看最后打印出这个number值是多少？</p><p>线程A代码片段：</p><p><img src="/images/javawz/image-20220128210559848.png" alt="image-20220128210559848"></p><p>线程B代码片段：</p><p><img src="/images/javawz/image-20220128210619983.png" alt="image-20220128210619983"></p><ul><li><p>代码片段说明</p><ul><li>代码中使用调用usleep是为了让两个子线程能够轮流使用CPU，避免一个子线程在一个时间片内完成5000次数数。</li><li>对number执行++操作，使用了中间变量cur是为了尽可能的模拟cpu时间片用完而让出cpu的情况。</li></ul></li><li><p>测试结果</p><ul><li>经过多次测试最后的结果显示，有可能会出现number值少于5000*2=10000的情况。</li></ul></li><li><p>分析原因</p><ul><li>假如子线程A执行完了cur++操作，还没有将cur的值赋值给number失去了cpu的执行权，子线程B得到了cpu执行权，而子线程B最后执行完了number=cur，而后失去了cpu的执行权；此时子线程A又重新得到cpu的执行权，并执行number=cur操作，这样会把线程B刚刚写回number的值被覆盖了，造成number值不符合预期的值。</li></ul><p><img src="/images/javawz/image-20220128210754455.png" alt="image-20220128210754455"></p></li><li><p>数据混乱的原因</p><ul><li>资源共享（独享资源则不会）</li><li>调度随机（线程操作共享资源的先后顺序不确定）</li><li>线程间缺乏必要的同步机制。</li></ul></li></ul><p>以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p><ul><li><p>如何解决问题</p><ul><li>原子操作的概念</li></ul><p>原子操作指的是该操作要么不做，要么就完成。</p><ul><li>使用互斥锁解决同步问题</li></ul><p>使用互斥锁其实是模拟原子操作，互斥锁示意图：</p></li></ul><p>Linux中提供一把互斥锁mutex（也称之为互斥量）。每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p><p>资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</p><p><img src="/images/javawz/image-20220128210816722.png" alt="image-20220128210816722"></p><p>线程1访问共享资源的时候要先判断锁是否锁着，如果锁着就阻塞等待；若锁是解开的就将这把锁加锁，此时可以访问共享资源，访问完成后释放锁，这样其他线程就有机会获得锁。</p><p>应该注意：图中同一时刻，只能有一个线程持有该锁，只要该线程未完成操作就不释放锁。</p><p>​使用互斥锁之后，两个线程由并行操作变成了串行操作，效率降低了，但是数据不一致的问题得到解决了。</p><h4 id="43互斥锁主要相关函数"><a class="markdownIt-Anchor" href="#43互斥锁主要相关函数"></a> 4.3互斥锁主要相关函数</h4><ul><li><p><code>pthread_mutex_t</code>类型</p><ul><li>其本质是一个结构体，为简化理解，应用时可忽略其实现细节，简单当成整数看待。</li><li><code>pthread_mutex_t mutex;</code>变量mutex只有两种取值1、0。</li></ul></li><li><p><code>pthread_mutex_init</code>函数</p><ul><li>函数描述：<ul><li>初始化一个互斥锁(互斥量) —&gt; 初值可看作1</li></ul></li><li>函数原型：<ul><li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></li></ul></li><li>函数参数<ul><li>mutex：传出参数，调用时应传<code>&amp;mutex</code></li><li>attr：互斥锁属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。</li></ul></li></ul></li><li><p><strong>restrict关键字</strong>：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改互斥量mutex的两种初始化方式：</p><ul><li><strong>静态初始化</strong>：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。</li><li><code>pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</code></li><li><strong>动态初始化</strong>：局部变量应采用动态初始化。</li></ul></li></ul><p><code>pthread_mutex_init(&amp;mutex, NULL);</code></p><ul><li><p><code>pthread_mutex_destroy</code>函数</p></li><li><p>函数描述</p><ul><li>销毁一个互斥锁</li></ul></li><li><p>函数原型</p><ul><li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></li></ul></li><li><p>函数参数</p><ul><li>mutex—互斥锁变量</li></ul></li><li><p><code>pthread_mutex_lock</code>函数</p><ul><li>函数描述<ul><li>对互斥所加锁，可理解为将<code>mutex--</code></li></ul></li><li>函数原型<ul><li><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></li></ul></li><li>函数参数<ul><li>mutex—互斥锁变量</li></ul></li></ul></li><li><p><code>pthread_mutex_unlock</code>函数</p><ul><li>函数描述</li><li>对互斥所解锁，可理解为将mutex ++</li><li>函数原型</li><li><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li></ul></li><li><p><code>pthread_mutex_trylock</code>函数</p><ul><li>函数描述<ul><li>尝试加锁</li></ul></li><li>函数原型<ul><li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></li></ul></li><li>函数参数<ul><li>mutex—互斥锁变量</li></ul></li></ul></li></ul><h4 id="44-加锁和解锁"><a class="markdownIt-Anchor" href="#44-加锁和解锁"></a> 4.4 加锁和解锁</h4><ul><li>lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</li><li>unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</li></ul><p>练习：使用互斥锁解决两个线程数数不一致的问题。</p><p>代码片段：在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好。</p><p><img src="/images/javawz/image-20220128211719750.png" alt="image-20220128211719750"></p><p>总结：使用互斥锁之后，两个线程由并行变为了串行，效率降低了，但是可以使两个线程同步操作共享资源，从而解决了数据不一致的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 50000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mythread1</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">n = number;</span><br><span class="line">n++;</span><br><span class="line">number = n;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"A: [%d]\n"</span>,number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mythread2</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">n = number;</span><br><span class="line">n++;</span><br><span class="line">number = n;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"B: [%d]\n"</span>,number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1;</span><br><span class="line"><span class="keyword">pthread_t</span> thread2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret1 = pthread_create(&amp;thread1,<span class="literal">NULL</span>,mythread1,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret1 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error: [%s]\n"</span>,strerror(ret1));</span><br><span class="line"><span class="keyword">return</span> ret1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ret2 = pthread_create(&amp;thread2,<span class="literal">NULL</span>,mythread2,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret2 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error: [%s]\n"</span>,strerror(ret2));</span><br><span class="line"><span class="keyword">return</span> ret2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> *retval1;</span><br><span class="line"><span class="keyword">void</span> *retval2;</span><br><span class="line"><span class="keyword">int</span> join_ret = pthread_join(thread1,&amp;retval1);</span><br><span class="line"><span class="keyword">if</span>(join_ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_join error [%s]\n"</span>,strerror(join_ret));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> join_ret2 = pthread_join(thread2,&amp;retval2);</span><br><span class="line"><span class="keyword">if</span>(join_ret2 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_join error [%s]\n"</span>,strerror(join_ret2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"number [%d]"</span>,number);</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥锁: 线程A和线程B共同访问共享资源, 当线程A想访问共享资源的时候,<br>要先获得锁, 如果锁被占用, 则加锁不成功需要阻塞等待对方释放锁;<br>若锁没有被占用, 则获得锁成功–加锁, 然后操作共享资源, 操作完之后,<br>必须解锁, 同理B也是和A一样.<br>也就是说, 同时不能有两个线程访问共享资源, 属于互斥操作.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;守护进程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#守护进程&quot;&gt;&lt;/a&gt; 守护进程&lt;/h2&gt;
&lt;h3 id=&quot;11-守护进程介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-守护进程介绍&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>使用信号完成两个进程交替数数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/23/linux081%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%88%90%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%95%B0%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/23/linux081使用信号完成两个进程交替数数/</id>
    <published>2022-01-23T12:30:23.000Z</published>
    <updated>2022-01-23T12:33:05.975Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用SIGUSR1和SIGUSR2在父子进程间交替数数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"F:[%d]\n"</span>, num);</span><br><span class="line">num += <span class="number">2</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C:[%d]\n"</span>, num);</span><br><span class="line">num += <span class="number">2</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num=<span class="number">0</span>;</span><br><span class="line">flag  = <span class="number">1</span>;</span><br><span class="line">signal(SIGUSR1, func1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">kill(pid, SIGUSR2);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num=<span class="number">1</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">signal(SIGUSR2, func2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">kill(getppid(), SIGUSR1);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>SIGCHLD</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/23/linux080SIGCHLD/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/23/linux080SIGCHLD/</id>
    <published>2022-01-23T11:15:47.000Z</published>
    <updated>2022-01-23T12:29:57.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="产生sigchld信号的条件"><a class="markdownIt-Anchor" href="#产生sigchld信号的条件"></a> 产生SIGCHLD信号的条件</h3><ul><li><p>子进程结束的时候</p></li><li><p>子进程收到SIGSTOP信号</p></li><li><p>当子进程停止时，收到SIGCONT信号</p></li></ul><h3 id="sigchld信号的作用"><a class="markdownIt-Anchor" href="#sigchld信号的作用"></a> SIGCHLD信号的作用</h3><p>​子进程退出后，内核会给它的父进程发送SIGCHLD信号，父进程收到这个信号后可以对子进程进行回收。</p><p>​使用SIGCHLD信号完成对子进程的回收可以避免父进程阻塞等待而不能执行其他操作，只有当父进程收到SIGCHLD信号之后才去调用信号捕捉函数完成对子进程的回收，未收到SIGCHLD信号之前可以处理其他操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对SIGCHLD信号测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child [%d]\n"</span>,pid);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">signal(SIGCHLD,sighandler);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fater [%d]\n"</span>,pid);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -19 子进程id号 //对子进程发送SIGSTOP信号,然后产生SIGCHLD信号</span><br><span class="line">kill -18 子进程id号 //对子进程发送SIGCONT信号,然后产生SIGCHLD信号</span><br></pre></td></tr></table></figure><h3 id="使用sigchld信号完成对子进程的回收"><a class="markdownIt-Anchor" href="#使用sigchld信号完成对子进程的回收"></a> 使用SIGCHLD信号完成对子进程的回收</h3><ul><li><p>练习：父进程创建三个子进程，然后让父进程捕获SIGCHLD信号完成对子进程的回收。</p></li><li><p>注意点：</p></li><li><p>有可能还未完成信号处理函数的注册三个子进程都退出了。</p></li><li><p>解决办法：可以在fork之前先将SIGCHLD信号阻塞，当完成信号处理函数的注册后在解除阻塞。</p></li><li><p>当SIGCHLD信号函数处理期间, SIGCHLD信号若再次产生是被阻塞的,而且若产生了多次, 则该信号只会被处理一次, 这样可能会产生僵尸进程。</p></li><li><p>解决办法: 可以在信号处理函数里面使用while(1)循环回收, 这样就有可能出现捕获一次SIGCHLD信号但是回收了多个子进程的情况，从而可以避免产生僵尸进程。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父进程使用SICCHLD信号完成对子进程的回收</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitchild</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> wpid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回收子进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line"><span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child is quit, wpid==[%d]\n"</span>, wpid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child is living, wpid==[%d]\n"</span>, wpid);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"no child is living, wpid==[%d]\n"</span>, wpid);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将SIGCHLD信号阻塞</span></span><br><span class="line"><span class="keyword">sigset_t</span> mask;</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line">sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//fork子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) <span class="comment">//fork失败的情况</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>) <span class="comment">//父进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: fpid==[%d], cpid==[%d]\n"</span>, getpid(), pid);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: fpid==[%d], cpid==[%d]\n"</span>, getppid(), getpid());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:father: fpid==[%d]\n"</span>, i, getpid());</span><br><span class="line"><span class="comment">//signal(SIGCHLD, waitchild);</span></span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = waitchild;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除对SIGCHLD信号的阻塞</span></span><br><span class="line">sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第1个子进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:child: cpid==[%d]\n"</span>, i, getpid());</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第2个子进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:child: cpid==[%d]\n"</span>, i, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第3个子进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:child: cpid==[%d]\n"</span>, i, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;产生sigchld信号的条件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#产生sigchld信号的条件&quot;&gt;&lt;/a&gt; 产生SIGCHLD信号的条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;子进程结束的时候&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>sigaction函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/22/linux079sigaction/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/22/linux079sigaction/</id>
    <published>2022-01-22T13:10:27.000Z</published>
    <updated>2022-01-23T08:35:04.927Z</updated>
    
    <content type="html"><![CDATA[<ul><li>sigaction函数</li><li>函数说明：注册一个信号处理函数</li><li>函数原型：</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</span><br></pre></td></tr></table></figure><ul><li>函数参数：</li><li>signum：捕捉的信号</li><li>act：  传入参数，新的处理方式。</li><li>oldact： 传出参数，旧的处理方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction &#123;</span><br><span class="line"></span><br><span class="line">void  (*sa_handler)(int);// 信号处理函数</span><br><span class="line"></span><br><span class="line">void  (*sa_sigaction)(int, siginfo_t *, void *); //信号处理函数</span><br><span class="line"></span><br><span class="line">sigset_t  sa_mask; //信号处理函数执行期间需要阻塞的信号</span><br><span class="line"></span><br><span class="line">int    sa_flags; //通常为0，表示使用默认标识</span><br><span class="line"></span><br><span class="line">void   (*sa_restorer)(void);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>总结：</p><ul><li>sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作</li><li>sa_mask: 用来指定在信号处理函数执行期间需要被屏蔽的信号，特别是当某个信号被处理时，它自身会被自动放入进程的信号掩码，因此在信号处理函数执行期间这个信号不会再度发生。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</li><li>sa_flags：通常设置为0，使用默认属性。</li><li>sa_restorer：已不再使用</li></ul></li><li><p>练习：编写程序，使用sigaction函数注册信号捕捉函数，并使用这个程序验证信号是否支持排队。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sigaction函数测试---注册信号处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">sleep(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = sighandler;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);  <span class="comment">//在信号处理函数执行期间, 不阻塞任何信号</span></span><br><span class="line">sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signal(SIGQUIT, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>知识点: 信号处理不支持排队:</p></li><li><p>在XXX信号处理函数执行期间, XXX信号是被阻塞的, 如果该信号产生了多次, 在XXX信号处理函数结束之后,  该XXX信号只被处理一次.</p></li><li><p>在XXX信号处理函数执行期间,如果阻塞了YYY信号, 若YYY信号产生了多次, 当XXX信号处理函数结束后, YYY信号只会被处理一次.</p></li><li><p>内核实现信号捕捉的过程</p></li></ul><p>如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这称为捕捉信号。由于信号处理函数的代码是在用户空间的，处理过程比较复杂，举例如下：</p><p>用户程序注册了SIGQUIT信号的处理函数sighandler。</p><p>当前正在执行main函数，这时发生中断或异常切换到内核态。</p><p>在中断处理完毕后要返回用户态的main函数之前检查到有信号SIGQUIT递达。</p><p>内核决定返回用户态后不是恢复main函数的上下文继续执行，而是执行sighandler函数，sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系，是两个独立的控制流程。</p><p>sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态。</p><p>如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行了。</p><p><img src="/images/javawz/wps7CFB.tmp.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;sigaction函数&lt;/li&gt;
&lt;li&gt;函数说明：注册一个信号处理函数&lt;/li&gt;
&lt;li&gt;函数原型：&lt;/li&gt;
&lt;/ul&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>信号集相关函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/22/linux078%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/22/linux078信号集相关函数/</id>
    <published>2022-01-22T06:35:35.000Z</published>
    <updated>2022-01-22T13:07:07.163Z</updated>
    
    <content type="html"><![CDATA[<p>由于信号集属于内核的一块区域，用户不能直接操作内核空间，为此，内核提供了一些信号集相关的接口函数，使用这些函数用户就可以完成对信号集的相关操作。</p><p>信号集是一个能表示多个信号的数据类型，<code>sigset_t set</code>，set即一个信号集。既然是一个集合，就需要对集进行添加、删除等操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sigset_t类型的定义在signal.h文件中的第49行处:</span><br><span class="line">typedef __sigset_t sigset_t;</span><br><span class="line">__sigset_t的定义在sigset.h文件中的26，27行处: </span><br><span class="line"># define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span><br><span class="line"></span><br><span class="line">  typedef struct</span><br><span class="line">  &#123;</span><br><span class="line">    unsigned long int __val[_SIGSET_NWORDS];</span><br><span class="line">  &#125; __sigset_t;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">上述变量类型的定义的查找有个小窍门： 可以执行gcc的预处理命令：</span><br><span class="line">gcc -E test.c -o test.i 这样头文件就会展开，可以直接到test.i文件中看到相关变量类型的定义。</span><br></pre></td></tr></table></figure><p>信号集相关函数</p><ul><li><code>int sigemptyset(sigset_t *set);</code></li></ul><p>函数说明：将某个信号集清0</p><p>函数返回值：成功：0；失败：-1，设置errno</p><ul><li><code>int sigfillset(sigset_t *set);</code></li></ul><p>函数说明：将某个信号集置1</p><p>函数返回值：成功：0；失败：-1，设置errno</p><ul><li><code>int sigaddset(sigset_t *set, int signum);</code></li></ul><p>函数说明：将某个信号加入信号集合中</p><p>函数返回值：成功：0；失败：-1，设置errno</p><ul><li><code>int sigdelset(sigset_t *set, int signum);</code></li></ul><p>函数说明：将某信号从信号清出信号集</p><p>函数返回值：成功：0；失败：-1，设置errno</p><ul><li><code>int sigismember(const sigset_t *set, int signum);</code></li></ul><p>函数说明：判断某个信号是否在信号集中</p><p>函数返回值：在：1；不在：0；出错：-1，设置errno</p><ul><li>sigprocmask函数</li></ul><p>函数说明：用来屏蔽信号、解除屏蔽也使用该函数。其本质，读</p><p>取或修改进程控制块中的信号屏蔽字（阻塞信号集）。</p><p>特别注意，屏蔽信号只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢弃处理。</p><p>函数原型：<code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code></p><p>函数返回值：成功：0；失败：-1，设置errno</p><p>函数参数：</p><p>how参数取值：假设当前的信号屏蔽字为mask</p><p><code>SIG_BLOCK</code>: 当how设置为此值，set表示需要屏蔽的信号。<strong>相当于</strong> mask = mask | set</p><p><code>SIG_UNBLOCK</code>: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~set</p><p><code>SIG_SETMASK</code>: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于mask = set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</p><p>set：传入参数，是一个自定义信号集合。由参数how来指示如何修改当前信号屏蔽字。</p><p>oldset：传出参数，保存旧的信号屏蔽字。</p><ul><li>sigpending函数</li></ul><p>函数原型：<code>int sigpending(sigset_t *set);</code></p><p>函数说明：读取当前进程的未决信号集</p><p>函数参数：set传出参数</p><p>函数返回值：成功：0；失败：-1，设置errno</p><p>练习：编写程序，设置阻塞信号集并把所有常规信号的未决状态打印至屏幕。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号集相关函数测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册SIGINT和SIGQUIT的信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line">signal(SIGQUIT, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义sigset_t类型的变量</span></span><br><span class="line"><span class="keyword">sigset_t</span> pending, mask, oldmask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">sigemptyset(&amp;pending);</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line">sigemptyset(&amp;oldmask);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将SIGINT和SIGQUIT加入到阻塞信号集中</span></span><br><span class="line">sigaddset(&amp;mask, SIGINT);</span><br><span class="line">sigaddset(&amp;mask, SIGQUIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将mask中的SIGINT和SIGQUIT信号加入到阻塞信号集中</span></span><br><span class="line"><span class="comment">//sigprocmask(SIG_BLOCK, &amp;mask, NULL);</span></span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;oldmask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取未决信号集</span></span><br><span class="line">sigpending(&amp;pending);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">32</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断某个信号是否在集合中</span></span><br><span class="line"><span class="keyword">if</span>(sigismember(&amp;pending, i)==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k++%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从阻塞信号集中解除对SIGINT和SIGQUIT的阻塞</span></span><br><span class="line"><span class="comment">//sigprocmask(SIG_UNBLOCK, &amp;mask, NULL);</span></span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于信号集属于内核的一块区域，用户不能直接操作内核空间，为此，内核提供了一些信号集相关的接口函数，使用这些函数用户就可以完成对信号集的相关操作。&lt;/p&gt;
&lt;p&gt;信号集是一个能表示多个信号的数据类型，&lt;code&gt;sigset_t set&lt;/code&gt;，set即一个信号集。既然
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>未决信号集和阻塞信号集的关系</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/22/linux077%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/22/linux077未决信号集和阻塞信号集的关系/</id>
    <published>2022-01-22T05:56:34.000Z</published>
    <updated>2022-01-22T07:37:44.866Z</updated>
    
    <content type="html"><![CDATA[<p>未决信号集和阻塞信号集的关系</p><p>阻塞信号集是当前进程要阻塞的信号的集合，未决信号集是当前进程中还处于未决状态的信号的集合，这两个集合存储在内核的PCB中。</p><ul><li>下面以SIGINT为例说明信号未决信号集和阻塞信号集的关系：</li><li>编号从1开始</li><li>当进程收到一个SIGINT信号（信号编号为2），首先这个信号会保存在未决信号集合中，此时对应的2号编号的这个位置上置为1，表示处于未决状态；在这个信号需要被处理之前首先要在阻塞信号集中的编号为2的位置上去检查该值是否为1：</li><li>如果为1，表示SIGNIT信号被当前进程阻塞了，这个信号暂时不被处理，所以未决信号集上该位置上的值保持为1，表示该信号处于未决状态；</li><li>如果为0，表示SIGINT信号没有被当前进程阻塞，这个信号需要被处理，内核会对SIGINT信号进行处理（执行默认动作，忽略或者执行用户自定义的信号处理函数），并将未决信号集中编号为2的位置上将1变为0，表示该信号已经处理了，这个时间非常短暂，用户感知不到。</li></ul><p>当SIGINT信号从阻塞信号集中解除阻塞之后，该信号就会被处理。</p><p><img src="/images/javawz/wpsB642.tmp.jpg" alt="img"></p><p>未决信号集和阻塞信号集的数据类型都是<code>sigset_t</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;未决信号集和阻塞信号集的关系&lt;/p&gt;
&lt;p&gt;阻塞信号集是当前进程要阻塞的信号的集合，未决信号集是当前进程中还处于未决状态的信号的集合，这两个集合存储在内核的PCB中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下面以SIGINT为例说明信号未决信号集和阻塞信号集的关系：&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>setitimer函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/22/linux076setitimer%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/22/linux076setitimer函数/</id>
    <published>2022-01-21T16:27:46.000Z</published>
    <updated>2022-01-22T05:19:25.228Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>函数原型</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);</span><br></pre></td></tr></table></figure><ul><li><strong>函数描述</strong></li></ul><p>设置定时器(闹钟)，可代替alarm函数，精度微秒us，可以实现周期定时。</p><ul><li><p><strong>函数返回值</strong></p><ul><li>成功：0；</li><li>失败：-1，设置errno值</li></ul></li><li><p><strong>函数参数：</strong></p></li><li><p>which：指定定时方式</p></li><li><p>自然定时：<code>ITIMER_REAL</code> → <strong>14）SIGALRM</strong>计算自然时间</p></li><li><p>虚拟空间计时(用户空间)：<code>ITIMER_VIRTUAL</code>→ <strong>26）SIGVTALRM</strong> 只计算进程占用cpu的时间</p></li><li><p>运行时计时(用户+内核)：<code>ITIMER_PROF</code> → <strong>27）SIGPROF</strong>计算占用cpu及执行系统调用的时间</p></li><li><p>new_value：<code>struct itimerval</code>, 负责设定timeout时间。</p><ul><li><code>itimerval.it_value</code>: 设定第一次执行function所延迟的秒数</li><li><code>itimerval.it_interval</code>: 设定以后每几秒执行function</li></ul></li><li><p>old_value： 存放旧的timeout值，一般指定为NULL</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct itimerval &#123; </span><br><span class="line"></span><br><span class="line">  struct timerval it_interval; // 闹钟触发周期</span><br><span class="line"></span><br><span class="line">  struct timerval it_value; // 闹钟触发时间</span><br><span class="line"></span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"> struct timeval &#123; </span><br><span class="line"></span><br><span class="line">  long tv_sec; // 秒</span><br><span class="line"></span><br><span class="line">  long tv_usec; // 微秒</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>练习: 使用setitimer实现每隔一秒打印一次hello, world。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo [%d]\n"</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册捕获SIGALRM信号处理函数</span></span><br><span class="line">signal(SIGALRM,sighandler);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tm</span>;</span></span><br><span class="line"><span class="comment">//周期性时间赋值</span></span><br><span class="line">tm.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">tm.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//第一次触发的时间,3秒后每隔1秒发送一次SIGALRM信号</span></span><br><span class="line">tm.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">tm.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setitimer(ITIMER_REAL,&amp;tm,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>alarm函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/21/linux075alarm%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/21/linux075alarm函数/</id>
    <published>2022-01-21T12:20:15.000Z</published>
    <updated>2022-01-21T12:34:18.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="alarm函数"><a class="markdownIt-Anchor" href="#alarm函数"></a> alarm函数</h3><ul><li><p>函数原型：<code>unsigned int alarm(unsigned int seconds);</code></p></li><li><p>函数描述：设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。</p></li><li><p>函数返回值：返回0或剩余的秒数，无失败。例如：</p></li></ul><p><img src="/images/javawz/wps5652.tmp.jpg" alt="img"></p><ul><li>常用操作：取消定时器alarm(0)，返回旧闹钟余下秒数。</li></ul><p>alarm使用的是自然定时法，与进程状态无关，就绪、运行、挂起(阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm都计时。</p><br><p>=============================================================================</p><br><p>练习题1：编写一个程序测试alarm函数</p><p>练习题2：编写程序，测试你的电脑1秒种能数多个数字。</p><ul><li><p>使用time命令查看程序执行的时间。程序运行的瓶颈在于IO，优化程序，首选优化IO。</p></li><li><p>实际执行时间 = 系统时间 + 用户时间 + 损耗时间</p></li></ul><p>损耗的时间主要来来自文件IO操作，IO操作会有用户区到内核区的切换，切换的次数越多越耗时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal函数测试---注册信号处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line">signal(SIGALRM, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = alarm(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"first: n==[%d]\n"</span>, n);</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">n = alarm(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//n = alarm(0); //取消时钟</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"second: n==[%d]\n"</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试1秒钟可以数多少数字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//一秒钟后发送信号</span></span><br><span class="line">alarm(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]"</span>, i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="time命令"><a class="markdownIt-Anchor" href="#time命令"></a> time命令</h3><p>查看程序使用的时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time 程序名</span><br><span class="line"></span><br><span class="line">real   实际执行时间</span><br><span class="line">user    用户时间</span><br><span class="line">sys     系统时间(内核时间)</span><br></pre></td></tr></table></figure><p>实际执行时间 = 系统时间 + 用户时间 + 损耗时间<br>损耗时间= 实际执行时间-(系统时间 + 用户时间 )<br>每一个数字都直接打印:<code>printf(&quot;[%d]\n&quot;, i++);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">real    0m1.217s</span><br><span class="line">user    0m0.120s</span><br><span class="line">sys     0m0.252s</span><br><span class="line">15734次</span><br></pre></td></tr></table></figure><p><code>损耗时间= 1.217-(0.120+0.252)=0.845</code><br>文件重定向之后:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time ./alarm_uncle  &gt; test.log</span><br><span class="line">real    0m1.003s</span><br><span class="line">user    0m0.520s</span><br><span class="line">sys     0m0.428s</span><br><span class="line">2191879次</span><br></pre></td></tr></table></figure><p><code>损耗时间=1.003-(0.520+0.428)=0.055</code><br>原因是: 调用<code>printf</code>函数打印数字遇到<code>\n</code>才会打印, 打印过程涉及到从<br>用户区到内核区的切换, 切换次数越多消耗的时间越长, 效率越低;<br>而使用文件重定向, 由于文件操作是带缓冲的, 所以涉及到用户区到内核区的<br>切换次数大大减少,从而使损耗降低.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;alarm函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#alarm函数&quot;&gt;&lt;/a&gt; alarm函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数原型：&lt;code&gt;unsigned int alarm(unsigned int seco
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>abort函数和raise函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/20/linux074abort%E5%87%BD%E6%95%B0%E5%92%8Craise%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/20/linux074abort函数和raise函数/</id>
    <published>2022-01-20T12:16:22.000Z</published>
    <updated>2022-01-20T13:51:22.352Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>raise函数</p><ul><li><p>函说描述：给当前进程发送指定信号(自己给自己发)</p></li><li><p>函数原型：</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int raise(int sig);</span><br></pre></td></tr></table></figure><ul><li><p>函数返回值：成功：0，失败非0值</p></li><li><p>函数拓展:</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise(signo) == kill(getpid(), signo);</span><br></pre></td></tr></table></figure><ul><li><p>abort函数</p></li><li><p>函数描述：给自己发送异常终止信号 <strong>6) SIGABRT</strong>，并产生core文件</p></li><li><p>函数原型：<code>void abort(void);</code></p></li><li><p>设置core文件大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited//无限制大小</span><br><span class="line">ulimit -x//x代表的是 下面带-的参数,比如-c</span><br><span class="line">yxc19980620c@yc:~/my/demo05$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 15434</span><br><span class="line">max locked memory       (kbytes, -l) 65536</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 15434</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure></li><li><p>函数拓展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abort() == kill(getpid(), SIGABRT);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//raise和abort函数测-</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给当前进程发送SIGINT信号</span></span><br><span class="line">raise(SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给当前进程发送SIGABRT</span></span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;raise函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函说描述：给当前进程发送指定信号(自己给自己发)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>信号相关函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/20/linux073%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/20/linux073信号相关函数/</id>
    <published>2022-01-20T10:38:02.000Z</published>
    <updated>2022-01-20T10:45:23.684Z</updated>
    
    <content type="html"><![CDATA[<h3 id="signal函数"><a class="markdownIt-Anchor" href="#signal函数"></a> signal函数</h3><ul><li><p>函数作用：注册信号捕捉函数</p></li><li><p>函数原型</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line"></span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br></pre></td></tr></table></figure><ul><li><p>函数参数</p><ul><li>signum：信号编号</li><li>handler：信号处理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal函数测试---注册信号处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//while(1)</span></span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="kill函数命令"><a class="markdownIt-Anchor" href="#kill函数命令"></a> kill函数/命令</h3><ul><li><p>描述：给指定进程发送指定信号</p></li><li><p>kill命令：kill -SIGKILL 进程PID</p></li><li><p>kill函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int kill(pid_t pid, int sig);</span><br></pre></td></tr></table></figure></li><li><p>函数返回值：</p><ul><li>成功：0；</li><li>失败：-1，设置errno</li></ul></li><li><p>函数参数：</p><ul><li>sig信号参数：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</li><li>pid参数：</li><li>pid &gt; 0: 发送信号给指定的进程。</li><li>pid = 0: 发送信号给与调用kill函数进程属于同一进程组的所有进程。</li><li>pid &lt; -1:  取|pid|发给对应进程组。</li><li>pid = -1：发送给进程有权限发送的系统中所有进程。</li></ul></li></ul><p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal函数测试---注册信号处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">kill(getpid(), SIGINT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;signal函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#signal函数&quot;&gt;&lt;/a&gt; signal函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数作用：注册信号捕捉函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数原型&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>信号的基本概念</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/20/linux072%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/20/linux072信号的基本概念/</id>
    <published>2022-01-20T08:51:19.000Z</published>
    <updated>2022-01-22T16:21:43.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号介绍"><a class="markdownIt-Anchor" href="#信号介绍"></a> 信号介绍</h2><ul><li>信号的概念</li></ul><p>信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</p><ul><li><p>信号在我们的生活中随处可见，例如：</p><ul><li><p>古代战争中摔杯为号；</p></li><li><p>现代战争中的信号弹;</p></li><li><p>体育比赛中使用的信号枪…</p></li></ul></li><li><p>信号的特点</p><ul><li>简单</li><li>不能携带大量信息</li><li>满足某个特点条件才会产生</li></ul></li></ul><h2 id="2-信号的机制"><a class="markdownIt-Anchor" href="#2-信号的机制"></a> 2 信号的机制</h2><p>进程A给进程B发送信号，进程B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕后再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</p><p><code>每个进程收到的所有信号，都是由内核负责发送的。</code></p><p>进程A给进程B发送信号示意图：</p><p><img src="/images/javawz/wps6534.tmp.jpg" alt="img"></p><p><img src="/images/javawz/image-20220120172232030.png" alt="image-20220120172232030"></p><h3 id="21信号的状态"><a class="markdownIt-Anchor" href="#21信号的状态"></a> 2.1信号的状态</h3><p>信号有三种状态：产生、未决和递达。</p><ul><li><p>信号的产生</p><ul><li>按键产生，如：Ctrl+c(终止进程SIGINT)、Ctrl+z(挂起进程SIGTSTP)、Ctrl+\(退出进程SIGQUIT)</li><li>系统调用产生，如：kill、raise、abort</li><li>软件条件产生，如：定时器alarm</li><li>硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</li><li>命令产生，如：kill命令</li></ul></li><li><p>未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。</p></li><li><p>递达：递送并且到达进程。</p></li></ul><h3 id="22-信号的处理方式"><a class="markdownIt-Anchor" href="#22-信号的处理方式"></a> 2.2 信号的处理方式</h3><ul><li><p>执行默认动作</p></li><li><p>忽略信号(丢弃不处理)</p></li><li><p>捕捉信号(调用用户的自定义的处理函数)</p></li></ul><h3 id="23-信号的特质"><a class="markdownIt-Anchor" href="#23-信号的特质"></a> 2.3 信号的特质</h3><p>信号的实现手段导致信号<code>有很强的延时性</code>，但对于用户来说，时间非常短，不易察觉。</p><p>Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集</strong>。</p><p>注:表示PCB的task_struct结构体定义在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/src/linux-headers-4.4.0-97/include/linux/sched.h:1390</span><br></pre></td></tr></table></figure><h3 id="24-阻塞信号集和未决信号集"><a class="markdownIt-Anchor" href="#24-阻塞信号集和未决信号集"></a> 2.4 阻塞信号集和未决信号集</h3><p>Linux内核的进程控制块PCB是一个结构体，这个结构体里面包含了信号相关的信息，主要有阻塞信号集和未决信号集。</p><ul><li><p>阻塞信号集中保存的都是被当前进程阻塞的信号。若当前进程收到的是阻塞信号集中的某些信号，这些信号需要暂时被阻塞，不予处理。</p></li><li><p>信号产生后由于某些原因(主要是阻塞)不能抵达，这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态；若是信号从阻塞信号集中解除阻塞，则该信号会被处理，并从未决信号集中去除。</p></li></ul><h3 id="25信号的四要素"><a class="markdownIt-Anchor" href="#25信号的四要素"></a> 2.5信号的四要素</h3><ul><li>通过<code>man 7 signal</code>可以查看信号相关信息</li><li>信号编号</li><li>信号的名字</li><li>信号的默认处理(默认终止进程)</li><li>信号如何产生</li></ul><h4 id="1-信号的编号"><a class="markdownIt-Anchor" href="#1-信号的编号"></a> 1 信号的编号</h4><p>使用kill -l命令可以查看当前系统有哪些信号，不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。</p><h4 id="2-信号的名称"><a class="markdownIt-Anchor" href="#2-信号的名称"></a> 2 信号的名称</h4><h4 id="3-产生信号的事件"><a class="markdownIt-Anchor" href="#3-产生信号的事件"></a> 3 产生信号的事件</h4><h4 id="4信号的默认处理动作"><a class="markdownIt-Anchor" href="#4信号的默认处理动作"></a> 4信号的默认处理动作</h4><p><strong>Term</strong>：终止进程</p><p><strong>Ign</strong>：忽略信号 (默认即时对该种信号忽略操作)</p><p><strong>Core</strong>：终止进程，生成Core文件。(查验死亡原因，用于gdb调试)</p><p><strong>Stop</strong>：停止（暂停）进程</p><p><strong>Cont</strong>：继续运行进程</p><ul><li><p>特别需要注意的是：The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.(无法捕获、阻止或忽略信号SIGKILL和SIGSTOP。)</p></li><li><p>几个常用到的信号</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">SIGINT、SIGQUIT、SIGKILL、SIGSEGV、SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM、SIGTERM、SIGCHLD、SIGSTOP、SIGCONT</span><br><span class="line"></span><br><span class="line">SIGHUP        1       A     在控制终端上是挂起信号, 或者控制进程结束</span><br><span class="line">SIGINT        2       A     从键盘输入的中断</span><br><span class="line">SIGQUIT       3       C     从键盘输入的退出</span><br><span class="line">SIGILL        4       C     无效硬件指令</span><br><span class="line">SIGABRT       6       C     非正常终止, 可能来自 abort(3)</span><br><span class="line">SIGFPE        8       C     浮点运算例外</span><br><span class="line">SIGKILL       9      AEF    杀死进程信号</span><br><span class="line">SIGSEGV      11       C     无效的内存引用</span><br><span class="line">SIGPIPE      13       A     管道中止: 写入已经关闭读取的管道</span><br><span class="line">SIGALRM      14       A     来自 alarm(2) 的超时信号</span><br><span class="line">SIGTERM      15       A     终止信号</span><br><span class="line">SIGUSR1   30,10,16    A     用户定义的信号 1</span><br><span class="line">SIGUSR2   31,12,17    A     用户定义的信号 2</span><br><span class="line">SIGCHLD   20,17,18    B     子进程结束或停止</span><br><span class="line">SIGCONT   19,18,25          继续停止的进程</span><br><span class="line">SIGSTOP   17,19,23   DEF    停止进程</span><br><span class="line">SIGTSTP   18,20,24    D     终端上发出的停止信号</span><br><span class="line">SIGTERM      15       A     终止信号</span><br><span class="line">SIGUSR1   30,10,16    A     用户定义的信号 1</span><br><span class="line">SIGUSR2   31,12,17    A     用户定义的信号 2</span><br><span class="line">SIGCHLD   20,17,18    B     子进程结束或停止</span><br><span class="line">SIGFPE        8       C     浮点运算例外</span><br><span class="line">SIGABRT       6       C     非正常终止, 可能来自 abort(3)</span><br><span class="line">SIGQUIT       3       C     从键盘输入的退出</span><br><span class="line">SIGILL        4       C     无效硬件指令</span><br><span class="line">SIGABRT       6       C     非正常终止, 可能来自 abort(3)</span><br><span class="line">SIGFPE        8       C     浮点运算例外</span><br><span class="line">SIGKILL       9      AEF    杀死进程信号</span><br><span class="line">SIGSEGV      11       C     无效的内存引用</span><br><span class="line">SIGPIPE      13       A     管道中止: 写入无人读取的管道</span><br><span class="line">SIGALRM      14       A     来自 alarm(2) 的超时信号</span><br><span class="line">SIGTERM      15       A     终止信号</span><br><span class="line">SIGUSR1   30,10,16    A     用户定义的信号 1</span><br><span class="line">SIGUSR2   31,12,17    A     用户定义的信号 2</span><br><span class="line">SIGCHLD   20,17,18    B     子进程结束或停止</span><br><span class="line">SIGCONT   19,18,25          继续停止的进程</span><br><span class="line">SIGSTOP   17,19,23   DEF    停止进程</span><br><span class="line">SIGTSTP   18,20,24    D     终端上发出的停止信号</span><br><span class="line">SIGTTIN   21,21,26    D     后台进程试图从控制终端(tty)输入</span><br><span class="line">SIGTTOU   22,22,27    D     后台进程试图在控制终端(tty)输出</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;信号介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#信号介绍&quot;&gt;&lt;/a&gt; 信号介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;信号的概念&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>第二章物理层</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/20/第二章物理层/</id>
    <published>2022-01-19T17:14:47.000Z</published>
    <updated>2022-01-23T18:36:47.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="物理层定义的标准"><a class="markdownIt-Anchor" href="#物理层定义的标准"></a> 物理层定义的标准</h3><p>1.物理层解决如何在连接各种计算机的传输媒体上传输数据比特流 （0101…）。<br>物理层的主要任务：确定传输媒体的接口的一些特性：<br>1）机械特性：接口形状，大小，引线数目。<br>2）电气特性：规定电压范围（-5V到5V）。<br>3）功能特性：例如规定-5V是0，+5V是1.<br>4)过程特性：（规程特性）规定建立连接时各个相关部件的工作步骤(比如一个大可乐瓶和一个小可乐瓶,他们的瓶盖都是通用的,说明接口一样大小)。</p><h3 id="数据通信基础知识"><a class="markdownIt-Anchor" href="#数据通信基础知识"></a> 数据通信基础知识</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;物理层定义的标准&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#物理层定义的标准&quot;&gt;&lt;/a&gt; 物理层定义的标准&lt;/h3&gt;
&lt;p&gt;1.物理层解决如何在连接各种计算机的传输媒体上传输数据比特流 （0101…）。&lt;br&gt;
物理层的主要任务：确
      
    
    </summary>
    
      <category term="计算机网络原理" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>内存映射区</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/19/linux071%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/19/linux071内存映射区/</id>
    <published>2022-01-19T11:37:10.000Z</published>
    <updated>2022-01-19T16:36:41.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="存储映射区介绍"><a class="markdownIt-Anchor" href="#存储映射区介绍"></a> 存储映射区介绍</h3><p>​存储映射<code>I/O (Memory-mapped I/O)</code>使一个磁盘文件与存储空间中的一个缓冲区相映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样，就可在不使用read和write函数的情况下，使用地址（指针）完成I/O操作。</p><p>使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。</p><img src="/images/javawz/image-20220119222706887.png" height="140%" width="35%"><h3 id="mmap函数"><a class="markdownIt-Anchor" href="#mmap函数"></a> mmap函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br></pre></td></tr></table></figure><h4 id="函数作用"><a class="markdownIt-Anchor" href="#函数作用"></a> 函数作用:</h4><p>建立存储映射区</p><h4 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> 函数原型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br></pre></td></tr></table></figure><h4 id="函数返回值"><a class="markdownIt-Anchor" href="#函数返回值"></a> 函数返回值：</h4><p>成功：返回创建的映射区首地址；</p><p>失败：<code>MAP_FAILED</code>宏 并设置errno</p><h4 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数：</h4><p>addr: 指定映射的起始地址, 通常设为NULL, 由系统指定</p><p>length：映射到内存的文件长度</p><p>prot：映射区的保护方式, 最常用的:</p><p>读：<code>PROT_READ</code></p><p>写：<code>PROT_WRITE</code></p><p>读写：<code>PROT_READ | PROT_WRITE</code></p><p>flags：映射区的特性, 可以是</p><p><code>MAP_SHARED</code>: 写入映射区的数据会写回文件, 且允许其他映射该文件的进程共享。</p><p><code>MAP_PRIVATE</code>: 对映射区的写入操作会产生一个映射区的复制(copy-on-write), 对此区域所做的修改不会写回原文件。</p><p>fd：由open返回的文件描述符, 代表要映射的文件。</p><p>offset：以文件开始处的偏移量, <strong>必须是4k的整数倍</strong>, 通常为0, 表示从文件头开始映射。</p><h3 id="munmap函数"><a class="markdownIt-Anchor" href="#munmap函数"></a> munmap函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br></pre></td></tr></table></figure><h4 id="函数作用-2"><a class="markdownIt-Anchor" href="#函数作用-2"></a> 函数作用:</h4><p>释放由mmap函数建立的存储映射区</p><h4 id="函数原型-2"><a class="markdownIt-Anchor" href="#函数原型-2"></a> 函数原型:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int munmap(void *addr, size_t length);</span><br></pre></td></tr></table></figure><h4 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值：</h4><p>成功：返回0</p><p>失败：返回-1，设置errno值</p><h4 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数:</h4><p>addr：调用mmap函数成功返回的映射区首地址</p><p>length：映射区大小（mmap函数的第二个参数）</p><h4 id="mmap注意事项"><a class="markdownIt-Anchor" href="#mmap注意事项"></a> mmap注意事项</h4><p>创建映射区的过程中，隐含着一次对映射文件的读操作，将文件内容读取到映射区</p><p>当MAP_SHARED时，要求：映射区的权限应 &lt;=文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</p><p>映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭。</p><p>特别注意，当映射文件大小为0时，不能创建映射区。所以，用于映射的文件必须要有实际大小；mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。</p><p>munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。</p><p>文件偏移量必须为0或者4K的整数倍</p><p>mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</p><h4 id="有关mmap函数的使用总结"><a class="markdownIt-Anchor" href="#有关mmap函数的使用总结"></a> 有关mmap函数的使用总结</h4><p>第一个参数写成NULL</p><p>第二个参数要映射的文件大小 &gt; 0</p><p>第三个参数：PROT_READ 、PROT_WRITE</p><p>第四个参数：MAP_SHARED 或者 MAP_PRIVATE</p><p>第五个参数：打开的文件对应的文件描述符</p><p>第六个参数：4k的整数倍</p><h4 id="mmap函数相关思考题"><a class="markdownIt-Anchor" href="#mmap函数相关思考题"></a> mmap函数相关思考题</h4><p>可以open的时候O_CREAT一个新文件来创建映射区吗?</p><p>答:不可以,因为刚刚创建出来的文件大小是0</p><p>如果open时O_RDONLY, mmap时PROT参数指定<code>PROT_READ|PROT_WRITE</code>会怎样？</p><p>答:open的权限应该大于等于mmap</p><p>mmap映射完成之后, 文件描述符关闭，对mmap映射有没有影响？</p><p>答:没有影响</p><p>如果文件偏移量为1000会怎样？</p><p>答:必须为4K的整倍数</p><p>对mem越界操作会怎样？</p><p>答:出错</p><p>如果<code>mem++</code>，munmap可否成功？</p><p>答:出错</p><p>mmap什么情况下会调用失败？</p><p>答:指定错误参数或内存不足的时候</p><p>如果不检测mmap的返回值，会怎样？</p><p>答:如果mmap返回的是-1,而又不检测,从而会使用错误的指针</p><h4 id="mmap应用练习"><a class="markdownIt-Anchor" href="#mmap应用练习"></a> mmap应用练习</h4><p>练习1：使用mmap完成对文件的读写操作</p><p>练习:2：使用mmap完成父子进程间通信</p><p>图解说明</p><p><img src="/images/javawz/wps1FD2.tmp.jpg" alt="img"></p><p>思路</p><p>调用mmap函数创建存储映射区，返回映射区首地址ptr</p><p>调用fork函数创建子进程，子进程也拥有了映射区首地址</p><p>父子进程可以通过映射区首地址指针ptr完成通信</p><p>调用munmap函数释放存储映射区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用mmap函数完成父子进程间通信</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line"><span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./test.log"</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//void * addr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);</span></span><br><span class="line"><span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(addr, <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%s]"</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习3：使用mmap完成没有血缘关系的进程间通</p><p>思路：两个进程都打开相同的文件，然后调用mmap函数建立存储映射区，这样两个进程共享同一个存储映射区。</p><h4 id="mmap_read"><a class="markdownIt-Anchor" href="#mmap_read"></a> mmap_read</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用mmap函数完成两个不相干进程间通信</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line"><span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./test.log"</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立共享映射区</span></span><br><span class="line"><span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">memcpy</span>(buf, addr, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf=[%s]\n"</span>, buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mmap_write"><a class="markdownIt-Anchor" href="#mmap_write"></a> mmap_write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用mmap函数完成两个不相干进程间通信</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line"><span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./test.log"</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立共享映射区</span></span><br><span class="line"><span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(addr, <span class="string">"0123456789"</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用mmap函数建立匿名映射"><a class="markdownIt-Anchor" href="#使用mmap函数建立匿名映射"></a> 使用mmap函数建立匿名映射：</h4><p>必须是有血缘关系之间的进程使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br></pre></td></tr></table></figure><p><code>MAP_ANONYMOUS</code>必须和<code>MAP_SHARED</code>一起使用，而且fd指定为-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用mmap匿名映射完成父子进程间通信</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line"><span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"><span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(addr, <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%s]"</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;存储映射区介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#存储映射区介绍&quot;&gt;&lt;/a&gt; 存储映射区介绍&lt;/h3&gt;
&lt;p&gt;​	存储映射&lt;code&gt;I/O (Memory-mapped I/O)&lt;/code&gt;使一个磁盘文件与存储空间中的一
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>fifo函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/17/linux070fifo%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/17/linux070fifo函数/</id>
    <published>2022-01-17T10:59:33.000Z</published>
    <updated>2022-01-17T17:01:09.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fifo介绍"><a class="markdownIt-Anchor" href="#fifo介绍"></a> FIFO介绍</h3><p><strong>FIFO常被称为命名管道</strong>，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间通信。<strong>但通过FIFO，不相关的进程也能交换数据。</strong></p><p>​FIFO是Linux基础文件类型中的一种（文件类型为p，可通过ls -l查看文件类型）。但FIFO文件在磁盘上没有数据块，文件大小为0，仅仅用来标识内核中一条通道。进程可以打开这个文件进行read/write，实际上是在读写内核缓冲区，这样就实现了进程间通信。</p><h3 id="创建管道"><a class="markdownIt-Anchor" href="#创建管道"></a> 创建管道</h3><h4 id="方式1-使用命令-mkfifo"><a class="markdownIt-Anchor" href="#方式1-使用命令-mkfifo"></a> 方式1-使用命令 mkfifo</h4><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo 管道名</span><br></pre></td></tr></table></figure><p>例如：mkfifo myfifo</p><h4 id="方式2-使用函数"><a class="markdownIt-Anchor" href="#方式2-使用函数"></a> 方式2-使用函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">参数一是文件名</span><br><span class="line">参数2是文件权限</span><br><span class="line">成功返回0</span><br><span class="line">失败返回-1并设置errno</span><br></pre></td></tr></table></figure><p>参数说明和返回值可以查看man 3 mkfifo</p><p>当创建了一个FIFO，就可以使用open函数打开它，常见的文件I/O函数都可用于FIFO。如：close、read、write、unlink等。</p><p>FIFO严格遵循先进先出（first in first out），对FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。<strong>它们不支持诸如lseek()等文件定位操作。</strong></p><h3 id="access函数"><a class="markdownIt-Anchor" href="#access函数"></a> access函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br></pre></td></tr></table></figure><p>函数声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int access(const char* pathname, int mode);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F_OK 值为0，判断文件是否存在</span><br><span class="line"> </span><br><span class="line">X_OK 值为1，判断对文件是可执行权限</span><br><span class="line"> </span><br><span class="line">W_OK 值为2，判断对文件是否有写权限</span><br><span class="line"> </span><br><span class="line">R_OK 值为4，判断对文件是否有读权限</span><br><span class="line"> </span><br><span class="line">注：后三种可以使用或“|”的方式，一起使用，如W_OK|R_OK</span><br></pre></td></tr></table></figure><p>返回值：成功0，失败-1</p><h3 id="使用fifo完成两个进程通信"><a class="markdownIt-Anchor" href="#使用fifo完成两个进程通信"></a> 使用FIFO完成两个进程通信</h3><p>使用FIFO完成两个进程通信的示意图</p><p><img src="/images/javawz/wps1DAE.tmp.jpg" alt="img"></p><h3 id="fifo_writec"><a class="markdownIt-Anchor" href="#fifo_writec"></a> fifo_write.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = access(<span class="string">"./myfifo"</span>,F_OK);<span class="comment">//判断文件是否存在</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//创建管道文件</span></span><br><span class="line">ret = mkfifo(<span class="string">"myfifo"</span>,<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"mkfifo error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开管道文件</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./myfifo"</span>,O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建缓冲区并且初始化为0</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">"%d hello\n"</span>,++i);</span><br><span class="line">        <span class="comment">//写数据到管道文件</span></span><br><span class="line">write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fifo_readc"><a class="markdownIt-Anchor" href="#fifo_readc"></a> fifo_read.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//打开管道文件</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./myfifo"</span>,O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//读管道文件</span></span><br><span class="line">len = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"len[%d]  %s"</span>,len,buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;fifo介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fifo介绍&quot;&gt;&lt;/a&gt; FIFO介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;FIFO常被称为命名管道&lt;/strong&gt;，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>如何查看管道缓冲区大小</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/17/linux069%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/17/linux069如何查看管道缓冲区大小/</id>
    <published>2022-01-17T10:58:01.000Z</published>
    <updated>2022-01-17T11:03:34.143Z</updated>
    
    <content type="html"><![CDATA[<h3 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long fpathconf(int fd, int name);</span><br><span class="line"></span><br><span class="line">printf(&quot;pipe size==[%ld]\n&quot;, fpathconf(fd[0], _PC_PIPE_BUF));</span><br><span class="line"></span><br><span class="line">printf(&quot;pipe size==[%ld]\n&quot;, fpathconf(fd[1], _PC_PIPE_BUF));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"pipe error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//获取管道缓冲区大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe size [%ld]\n"</span>,fpathconf(fd[<span class="number">0</span>],_PC_PIPE_BUF));</span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">write(fd[<span class="number">1</span>],<span class="string">"hello pipe!"</span>,<span class="keyword">sizeof</span>(<span class="string">"hello pipe!"</span>));</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">read(fd[<span class="number">0</span>],buf,<span class="number">1024</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;命令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#命令&quot;&gt;&lt;/a&gt; 命令&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>设置管道为非阻塞方式</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/17/linux068%E8%AE%BE%E7%BD%AE%E7%AE%A1%E9%81%93%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/17/linux068设置管道为非阻塞方式/</id>
    <published>2022-01-16T18:27:23.000Z</published>
    <updated>2022-01-16T18:29:52.837Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，管道的读写两端都是阻塞的，若要设置读或者写端为非阻塞，则可参</p><p>考下列三个步骤进行：</p><p>第1步：<code>int flags = fcntl(fd[0], F_GETFL, 0);</code></p><p>第2步： <code>flag |= O_NONBLOCK;</code></p><p>第3步： <code>fcntl(fd[0], F_SETFL, flags);</code></p><h3 id="若是读端设置为非阻塞"><a class="markdownIt-Anchor" href="#若是读端设置为非阻塞"></a> 若是读端设置为非阻塞：</h3><ul><li>写端没有关闭，管道中没有数据可读，则read返回-1；</li><li>写端没有关闭，管道中有数据可读，则read返回实际读到的字节数</li><li>写端已经关闭，管道中有数据可读，则read返回实际读到的字节数</li><li>写端已经关闭，管道中没有数据可读，则read返回0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建管道</span></span><br><span class="line"><span class="comment">//int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"pipe error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe size==[%ld]\n"</span>, fpathconf(fd[<span class="number">0</span>], _PC_PIPE_BUF));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe size==[%ld]\n"</span>, fpathconf(fd[<span class="number">1</span>], _PC_PIPE_BUF));</span><br><span class="line"></span><br><span class="line"><span class="comment">//close(fd[0]);</span></span><br><span class="line"><span class="comment">//write(fd[1], "hello world", strlen("hello world"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭写端</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置管道的读端为非阻塞</span></span><br><span class="line"><span class="keyword">int</span> flag = fcntl(fd[<span class="number">0</span>], F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">int</span> n = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read over, n==[%d], buf==[%s]\n"</span>, n, buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;默认情况下，管道的读写两端都是阻塞的，若要设置读或者写端为非阻塞，则可参&lt;/p&gt;
&lt;p&gt;考下列三个步骤进行：&lt;/p&gt;
&lt;p&gt;第1步：&lt;code&gt;int flags = fcntl(fd[0], F_GETFL, 0);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第2步： &lt;code&gt;fl
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>管道的读写行为</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/17/linux067%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E8%A1%8C%E4%B8%BA/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/17/linux067管道的读写行为/</id>
    <published>2022-01-16T17:54:45.000Z</published>
    <updated>2022-01-16T18:26:56.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="读操作"><a class="markdownIt-Anchor" href="#读操作"></a> 读操作</h3><h4 id="有数据"><a class="markdownIt-Anchor" href="#有数据"></a> 有数据</h4><p>read正常读，返回读出的字节数</p><h4 id="无数据"><a class="markdownIt-Anchor" href="#无数据"></a> 无数据</h4><p>1.写端全部关闭</p><p>read解除阻塞，返回0, 相当于读文件读到了尾部</p><p>2.没有全部关闭</p><p>read阻塞</p><h3 id="写操作"><a class="markdownIt-Anchor" href="#写操作"></a> 写操作</h3><h4 id="读端全部关闭"><a class="markdownIt-Anchor" href="#读端全部关闭"></a> 读端全部关闭</h4><p>管道破裂，进程终止, 内核给当前进程发SIGPIPE信号</p><h4 id="读端没全部关闭"><a class="markdownIt-Anchor" href="#读端没全部关闭"></a> 读端没全部关闭</h4><p>1.缓冲区写满了</p><p>write阻塞</p><p>2.缓冲区没有满</p><p>继续write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建管道</span></span><br><span class="line"><span class="comment">//int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"pipe error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe size==[%ld]\n"</span>, fpathconf(fd[<span class="number">0</span>], _PC_PIPE_BUF));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe size==[%ld]\n"</span>, fpathconf(fd[<span class="number">1</span>], _PC_PIPE_BUF));</span><br><span class="line"></span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(fd[<span class="number">1</span>], <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭写端</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">int</span> n = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read over, n==[%d], buf==[%s]\n"</span>, n, buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;读操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#读操作&quot;&gt;&lt;/a&gt; 读操作&lt;/h3&gt;
&lt;h4 id=&quot;有数据&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#有数据&quot;&gt;&lt;/a&gt; 有数据&lt;/h4&gt;
&lt;p&gt;r
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>父子进程执行ps_aux_grep_bash思路分析和实现</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/17/linux066%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8Cps-aux-grep-bash%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/17/linux066父子进程执行ps-aux-grep-bash思路分析和实现/</id>
    <published>2022-01-16T16:35:18.000Z</published>
    <updated>2022-01-16T17:52:12.339Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../themes/pure/source/images/javawz/image-20220117003549233.png" alt="image-20220117003549233"></p><p>输入<code>grep bash</code> 回车之后默认情况下是等待终端输入数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用pipe完成ps aux | grep bash操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建管道</span></span><br><span class="line"><span class="comment">//int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"pipe error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//关闭读端</span></span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将标准输出重定向到管道的写端</span></span><br><span class="line">dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line"></span><br><span class="line">execlp(<span class="string">"ps"</span>, <span class="string">"ps"</span>, <span class="string">"aux"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">perror(<span class="string">"execlp error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//关闭写端</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将标准输入重定向到管道的读端</span></span><br><span class="line">dup2(fd[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line"></span><br><span class="line">execlp(<span class="string">"grep"</span>, <span class="string">"grep"</span>, <span class="string">"--color=auto"</span>, <span class="string">"bash"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">perror(<span class="string">"execlp error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../../themes/pure/source/images/javawz/image-20220117003549233.png&quot; alt=&quot;image-20220117003549233&quot;&gt;&lt;/p&gt;
&lt;p&gt;输入&lt;code&gt;grep bash&lt;/co
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>pipe函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/15/linux065pipe%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/15/linux065pipe函数/</id>
    <published>2022-01-15T05:49:44.000Z</published>
    <updated>2022-01-15T09:47:53.212Z</updated>
    
    <content type="html"><![CDATA[<h3 id="管道的概念"><a class="markdownIt-Anchor" href="#管道的概念"></a> 管道的概念</h3><p>管道是一种最基本的IPC机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用pipe函数即可创建一个管道。</p><p><img src="/images/javawz/wps6AFD.tmp.jpg" alt="img"></p><p>有如下特质：</p><p>管道的本质是一块内核缓冲区</p><p>由两个文件描述符引用，一个表示读端，一个表示写端。</p><p>规定数据从管道的写端流入管道，从读端流出。</p><p>当两个进程都终结的时候，管道也自动消失。</p><p>管道的读端和写端默认都是阻塞的。</p><h3 id="管道的原理"><a class="markdownIt-Anchor" href="#管道的原理"></a> 管道的原理</h3><p>管道的实质是内核缓冲区，内部使用环形队列实现。</p><p>默认缓冲区大小为4K，可以使用ulimit -a命令获取大小。</p><p>实际操作过程中缓冲区会根据数据压力做适当调整。</p><h3 id="管道的局限性"><a class="markdownIt-Anchor" href="#管道的局限性"></a> 管道的局限性</h3><p>数据一旦被读走，便不在管道中存在，不可反复读取。</p><p>数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道</p><p>只能在有血缘关系的进程间使用管道。</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结:</h4><p>1.管道的本质是一块内核缓冲区,内部的实现是环形队列</p><p>2.管道有读写两端,读写两端是两个文件描述符</p><p>3.数据的流向是从管道的写端流到管道的读端(数据的流向是单向的)</p><p>4.数据被读走之后,在管道中就消失</p><p>5.pipe只能用于有血缘关系的进程间通信</p><p>6.管道的读写两端是阻塞的(写满数据阻塞，没读到数据阻塞)</p><p>7.管道的大小默认是4K,但是会根据实际情况做适当调整</p><h3 id="创建管道pipe函数"><a class="markdownIt-Anchor" href="#创建管道pipe函数"></a> 创建管道pipe函数</h3><p>函数作用:</p><p>创建一个管道</p><p>头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure><p>函数原型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int fd[2]);</span><br></pre></td></tr></table></figure><p>函数参数:</p><p>若函数调用成功，fd[0]存放管道的读端，fd[1]存放管道的写端</p><p>返回值:</p><p>成功返回0；</p><p>失败返回-1，并设置errno值。</p><p>​函数调用成功返回读端和写端的文件描述符，其中<strong>fd[0]是读端， fd[1]是写端</strong>，<strong>向管道读写数据是通过使用这两个文件描述符进行的，读写管道的实质是操作内核缓冲区。</strong></p><p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？</p><h3 id="父子进程使用管道通信"><a class="markdownIt-Anchor" href="#父子进程使用管道通信"></a> 父子进程使用管道通信</h3><p>一个进程在由pipe()创建管道后，一般再fork一个子进程，然后通过管道实现父子进程间的通信（因此也不难推出，只要两个进程中存在血缘关系，这里的血缘关系指的是具有共同的祖先，都可以采用管道方式来进行通信）。<strong>父子进程间具有相同的文件描述符，且指向同一个管道pipe</strong>，其他没有关系的进程不能获得pipe（）产生的两个文件描述符，也就不能利用同一个管道进行通信。</p><p><strong>第一步：父进程创建管道</strong></p><p><img src="/images/javawz/wps6AFE.tmp.jpg" alt="img"></p><p><strong>第二步：父进程fork出子进程</strong></p><p><img src="/images/javawz/wps6AFF.tmp.jpg" alt="img"></p><p><strong>第三步：父进程关闭fd[0]，子进程关闭fd[1]</strong></p><p><img src="/images/javawz/wps6B00.tmp.jpg" alt="img"></p><h4 id="创建步骤总结"><a class="markdownIt-Anchor" href="#创建步骤总结"></a> 创建步骤总结：</h4><p>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]和fd[1]，分别指向管道的读端和写端。</p><p>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管。</p><p>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出，这样就实现了父子进程间通信。</p><p>pipe用于父子进程间通信:</p><p>1.父进程创建pipe</p><p>2.父进程调用fork函数创建子进程</p><p>3.父进程关闭一端</p><p>4.子进程关闭一端</p><p>5.父进程和子进程分别执行read或者write操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建管道</span></span><br><span class="line"><span class="comment">//int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret = pipe(fd); </span><br><span class="line">    <span class="comment">/*子进程会复制一份fd,然后内核计数读和写fd各变成2*/</span></span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"pipe error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//关闭读端</span></span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">write(fd[<span class="number">1</span>], <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line"></span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//关闭写端</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">int</span> n = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read over, n==[%d], buf==[%s]\n"</span>, n, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;管道的概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#管道的概念&quot;&gt;&lt;/a&gt; 管道的概念&lt;/h3&gt;
&lt;p&gt;管道是一种最基本的IPC机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用pipe函数即可创建一个管道。&lt;/p
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
</feed>
