<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanChen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowuyoucy.github.io/"/>
  <updated>2022-02-23T17:33:55.172Z</updated>
  <id>https://xiaowuyoucy.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cpp介绍</title>
    <link href="https://xiaowuyoucy.github.io/2022/02/22/cpp%E4%BB%8B%E7%BB%8D/"/>
    <id>https://xiaowuyoucy.github.io/2022/02/22/cpp介绍/</id>
    <published>2022-02-21T16:57:55.000Z</published>
    <updated>2022-02-23T17:33:55.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><p>每个c++程序都从main函数开始执行</p><p>函数的定义格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">(多个语句构成的)函数体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语句"><a class="markdownIt-Anchor" href="#语句"></a> 语句</h3><p>C++程序的最小完整执行指令都是以分号结尾的语句。</p><p>可以将一条语句写在多个行，不管中间有多少空格、回车符、换行符，最后都是以分号作为语句的结束。</p><h3 id="程序注释"><a class="markdownIt-Anchor" href="#程序注释"></a> 程序注释</h3><h4 id="多行注释"><a class="markdownIt-Anchor" href="#多行注释"></a> 多行注释</h4><p>以/*开头，然后以*/结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">多行注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="单行注释"><a class="markdownIt-Anchor" href="#单行注释"></a> 单行注释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 单行注释</span><br></pre></td></tr></table></figure><p>块注释不能嵌套,既不能在块注释中再出现/* 或 */</p><h3 id="hello-world程序"><a class="markdownIt-Anchor" href="#hello-world程序"></a> hello world程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准输入输出库和cout"><a class="markdownIt-Anchor" href="#标准输入输出库和cout"></a> 标准输入输出库和cout</h3><p>要使用标准输入输出库就要包含头文件<code>#include&lt;iostream&gt;</code></p><p>stream是流的意思，io是输入input输出output的缩写。</p><p><code>#include</code>指令称为包含预处理指令,意思是用文件iostream的内容来替换掉这个预处理指令</p><p>cout对象代表的是标准输出流对象(既代表终端窗口)</p><h3 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h3><p>一个c<ins>程序可能会使用其他人写的库,例如有A库和B库,这两个库中的全局变量或函数的名字都有可能相同,为了避免冲突,c</ins>引入了命名空间将这两个库区分开来。</p><p>C++自带的标准库中的所有对象、函数等都属于一个叫std的标准命名空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std; 将整个标准名字空间std的名字都引入到程序中,写上这句话就可以直接调用std命名空间中的变量或函数了</span><br></pre></td></tr></table></figure><h4 id="名字空间限定"><a class="markdownIt-Anchor" href="#名字空间限定"></a> 名字空间限定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命名空间::变量/函数</span><br><span class="line">std::cout</span><br><span class="line">std::cout表示这是名字空间std的cout</span><br><span class="line"></span><br><span class="line">std::endl</span><br><span class="line">表示std命名空间中的endl,代表换行符</span><br></pre></td></tr></table></figure><h4 id="用using引入单个名字"><a class="markdownIt-Anchor" href="#用using引入单个名字"></a> 用using引入单个名字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using std::cout;</span><br><span class="line">cout &lt;&lt; &quot;123&quot; &lt;&lt; 456&quot;;</span><br><span class="line">引入之后,后面就不需要在用名字限定了</span><br><span class="line"></span><br><span class="line">输出运算符&lt;&lt;可以连续使用,这是因为cout &lt;&lt; &quot;123&quot; 返回的还是cout</span><br></pre></td></tr></table></figure><h3 id="字符串和字符"><a class="markdownIt-Anchor" href="#字符串和字符"></a> 字符串和字符</h3><p>单引号括起来的表示一个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;n&apos;  &apos;,&apos;  &apos;a&apos;</span><br></pre></td></tr></table></figure><p>双引号括起来的表示一个字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;abd&quot;   &quot;123&quot;    &quot;asd&quot;</span><br></pre></td></tr></table></figure><p><code>\n</code>和endl的区别</p><p><code>\n</code>和endl都表示换行符，endl会强制程序的缓冲区里面的数据立即输出</p><p><code>\t</code>表示制表符</p><h3 id="宏定义"><a class="markdownIt-Anchor" href="#宏定义"></a> 宏定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define 宏名 值</span><br><span class="line"></span><br><span class="line">#define PI 3.1415</span><br><span class="line">程序预处理阶段是,会将程序中所有的PI都用3.1415来替换</span><br></pre></td></tr></table></figure><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p>变量是命名的内存块。</p><p>在c++中变量也称为对象</p><p>每个变量都有一个数据类型,例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">double r;</span><br><span class="line">double area;</span><br></pre></td></tr></table></figure><h3 id="初始值"><a class="markdownIt-Anchor" href="#初始值"></a> {}初始值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i&#123;2&#125;;</span><br><span class="line">double r&#123;2.5&#125;;</span><br><span class="line">double area = 0;</span><br></pre></td></tr></table></figure><h3 id="标准输入流对象cin"><a class="markdownIt-Anchor" href="#标准输入流对象cin"></a> 标准输入流对象cin</h3><p>cin输入流对象,代表键盘对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double r;</span><br><span class="line">cin &gt;&gt; r;//重键盘输入一个数字到r中</span><br></pre></td></tr></table></figure><h3 id="用户自定义类型"><a class="markdownIt-Anchor" href="#用户自定义类型"></a> 用户自定义类型</h3><p>string类型</p><p>要使用string类型需要包含头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br></pre></td></tr></table></figure><p>string类型有一个size()成员函数,可以返回string对象的字符个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1 = &quot;abc&quot;;</span><br><span class="line">cout &lt;&lt; s1.size() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>substr(s,e)成员函数返回string对象下标s到e(不包含e)之间的字符构成的一个字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1 = &quot;123456&quot;;</span><br><span class="line">cout &lt;&lt; s1.substr(1,4) &lt;&lt; endl;//输出123</span><br></pre></td></tr></table></figure><p>可以用+将两个字符串对象拼接起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = &quot;abc&quot;;</span><br><span class="line">string s2 = &quot;def&quot;;</span><br><span class="line">cout &lt;&lt; s1 + s2 &lt;&lt; endl;//输出abcdef</span><br></pre></td></tr></table></figure><h3 id="数字表示"><a class="markdownIt-Anchor" href="#数字表示"></a> 数字表示</h3><p>用0b开头表示一串二进制表示一个二进制数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0b000010111</span><br></pre></td></tr></table></figure><h4 id="十六进制"><a class="markdownIt-Anchor" href="#十六进制"></a> 十六进制</h4><p>用0x表示16进制数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x12 0xFA0xFF</span><br></pre></td></tr></table></figure><h4 id="八进制"><a class="markdownIt-Anchor" href="#八进制"></a> 八进制</h4><p>用0开头表示8进制数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0120440777</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::dec// 以十进制方式输出</span><br><span class="line">std::hex// 以十六进制方式输出</span><br><span class="line">std::oct// 以八进制方式输出</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220222020913683.png" alt="image-20220222020913683"></p><h3 id="编译c程序"><a class="markdownIt-Anchor" href="#编译c程序"></a> 编译c++程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ 源文件名 -o 目标程序名</span><br><span class="line"></span><br><span class="line">g++ test.cpp -o test</span><br><span class="line">最终生成test程序</span><br></pre></td></tr></table></figure><h2 id="变量和数据类型"><a class="markdownIt-Anchor" href="#变量和数据类型"></a> 变量和数据类型</h2><p>变量的定义格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 变量名&#123;&#125;;</span><br></pre></td></tr></table></figure><p>{}方式的初始化称为列表初始化</p><p>如果{}里面没有值,对于基本类型的变量,初始值默认为0,有的编译器则会发出警告或报错</p><h3 id="信息损失则报错"><a class="markdownIt-Anchor" href="#信息损失则报错"></a> 信息损失则报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a&#123;1.2&#125;;//1.2会截取小数部分,导致信息损失,所以会报错</span><br></pre></td></tr></table></figure><h3 id="auto"><a class="markdownIt-Anchor" href="#auto"></a> auto</h3><p>用auto定义一个有初始值的变量时,不需要明确指定类型,因为编译器能自动从变量的初始值推断出该变量的数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto b = true;// bool</span><br><span class="line">auto ch&#123;&apos;x&apos;&#125;;// char</span><br><span class="line">auto i = 123;// int</span><br><span class="line">auto d&#123;1.2&#125;;// double</span><br><span class="line">auto z = d + i;// 从表达式的d+i的值来推断z的数据类型</span><br></pre></td></tr></table></figure><h3 id="typeid运算符"><a class="markdownIt-Anchor" href="#typeid运算符"></a> typeid运算符</h3><p>可以用typeid运算符查询得到一个数据类型或变量的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; typeid(int) .name() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; typeid(b).name() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="decltype"><a class="markdownIt-Anchor" href="#decltype"></a> decltype</h3><p>用decltype(exp)得到一个表达式的值的类型,并用这个类型来定义一个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(3 + 4.5) c;</span><br></pre></td></tr></table></figure><h3 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型"></a> 基本类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wchar_t 宽字符类型,在windows平台上是16位 2字节类型</span><br><span class="line">char16_t 表示UTF-16类型</span><br><span class="line">char32_t 表示UTF-32字符类型</span><br></pre></td></tr></table></figure><h3 id="整型文字常量"><a class="markdownIt-Anchor" href="#整型文字常量"></a> 整型文字常量</h3><p>字母u或U表示unsigned整型</p><p>字母l或L表示long整型</p><p>字母ll或LL表示 long long整型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">18u// unsigned</span><br><span class="line">18U// unsigned</span><br><span class="line"></span><br><span class="line">022L// long</span><br><span class="line">18l// long </span><br><span class="line"></span><br><span class="line">18LL// long long</span><br><span class="line">0x12uL// unsigned long </span><br><span class="line">18ULL// long long</span><br></pre></td></tr></table></figure><h3 id="浮点型文字常量"><a class="markdownIt-Anchor" href="#浮点型文字常量"></a> 浮点型文字常量</h3><p>默认是double</p><p>用f或F表示float</p><p>用l或L表示long double</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3.14</span><br><span class="line">3.14f</span><br><span class="line">3.14F</span><br><span class="line"></span><br><span class="line">3.14L</span><br><span class="line">3.14l</span><br></pre></td></tr></table></figure><h3 id="字符串文字常量"><a class="markdownIt-Anchor" href="#字符串文字常量"></a> 字符串文字常量</h3><p>L表示 wchar_t</p><p>u表示 char16_t</p><p>U表示 char32_t</p><p>u8前缀表示 UTF-8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L&apos;A&apos;// wchar_t</span><br><span class="line"></span><br><span class="line">u&apos;A&apos;// char16_t</span><br><span class="line"></span><br><span class="line">U&apos;A&apos;// char32_t</span><br><span class="line"></span><br><span class="line">u8&apos;A&apos;// utf-8</span><br><span class="line">u8&quot;abcd&quot;</span><br></pre></td></tr></table></figure><h3 id="原始字符串"><a class="markdownIt-Anchor" href="#原始字符串"></a> 原始字符串</h3><p>不需要处理转义字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R&quot;1234\n&quot;</span><br></pre></td></tr></table></figure><h3 id="格式化输出"><a class="markdownIt-Anchor" href="#格式化输出"></a> 格式化输出</h3><p>流操作符定义在2个头文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iomanip.h</span><br><span class="line">ios.h//ios头文件已经被iostream头文件包含,该头文件中的操纵符不带任何参数</span><br></pre></td></tr></table></figure><h4 id="iosh"><a class="markdownIt-Anchor" href="#iosh"></a> ios.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::dec;// 十进制输出</span><br><span class="line">std::hex;// 十六进制输出</span><br><span class="line">std::oct;// 八进制输出</span><br><span class="line"></span><br><span class="line">std::fixed;// 以固定精度形式输出</span><br><span class="line">std::scientific;// 以科学计数法形式输出</span><br><span class="line">std::hexfloat;// 以十六进制浮点形式输出</span><br><span class="line">std::defaultfloat; // 以默认形式输出</span><br></pre></td></tr></table></figure><h4 id="iomaniph"><a class="markdownIt-Anchor" href="#iomaniph"></a> iomanip.h</h4><p>iomanip的操纵符需要传递一个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::setw(n);//改变输出域的宽度</span><br><span class="line">std::setprecision(n)//改变浮点数的精度</span><br><span class="line"></span><br><span class="line">//改变填空字符,当setw的输出域宽度大于输出值的宽度时,默认的填空字符是空格,可以用setfill(ch)改变这个填空字符</span><br><span class="line">std::setfill(ch)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; setprecision(2) &lt;&lt; 3.1415926 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; setw(10) &lt;&lt; 3.1415926 &lt;&lt; endl</span><br><span class="line">cout &lt;&lt; setw(10) &lt;&lt; setfill(&apos;-&apos;) &lt;&lt; 3.1415926 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">3.1</span><br><span class="line">3.1</span><br><span class="line">----------3.1</span><br></pre></td></tr></table></figure><h3 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换"></a> 强制类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(类型) 值</span><br><span class="line">(int)123;</span><br><span class="line"></span><br><span class="line">static_cast&lt;类型&gt;值</span><br><span class="line">static_cast&lt;int&gt;123;</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a class="markdownIt-Anchor" href="#类型别名"></a> 类型别名</h3><p>可以用关键字using给一个数据类型起另外的名字,称为<strong>类型别名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using 别名 = 类型;</span><br><span class="line"></span><br><span class="line">using  INT = int;</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220223002707798.png" alt="image-20220223002707798"></p><p>上面的意思是 如果定义了 USING_COMPILER_A则执行下面这部分，否则则执行另外这部分。</p><h3 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h3><p>不同的枚举类型的值是不能相互比较或赋值的 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum class Day&#123;Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday&#125;;</span><br><span class="line"></span><br><span class="line">Day d&#123;Day::Tuesday&#125;;//定义一个Day类型的d变量并初始值为Tuesday</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数&quot;&gt;&lt;/a&gt; 函数&lt;/h3&gt;
&lt;p&gt;每个c++程序都从main函数开始执行&lt;/p&gt;
&lt;p&gt;函数的定义格式:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;
      
    
    </summary>
    
      <category term="cpp17从入门到精通" scheme="https://xiaowuyoucy.github.io/categories/cpp17%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>g++使用</title>
    <link href="https://xiaowuyoucy.github.io/2022/02/10/linux000g%E5%8A%A0%E5%8A%A0%E4%BD%BF%E7%94%A8/"/>
    <id>https://xiaowuyoucy.github.io/2022/02/10/linux000g加加使用/</id>
    <published>2022-02-09T17:01:38.000Z</published>
    <updated>2022-02-09T17:17:08.065Z</updated>
    
    <content type="html"><![CDATA[<p>g++是GNU组织推出的C++编译器。它不但可以用来编译传统的C++程序，也可以用来编译现代C++，比如<code>C++11/14</code>等。</p><p>g++的用法和gcc类似，编译C++的时候比gcc更简单，因为它会自动链接到C++标准库，而不像gcc需要手工指定。</p><p>g++编译程序的内部过程和gcc一样，也要经过4个阶段：预处理、编译、汇编和链接。</p><p>g++的基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ [选项] 准备编译的文件 [选项] [目标文件]</span><br></pre></td></tr></table></figure><h3 id="编译单个源文件"><a class="markdownIt-Anchor" href="#编译单个源文件"></a> 编译单个源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -o test</span><br></pre></td></tr></table></figure><p>test.cpp为需要编译的源文件，test为输出的可执行目录</p><h3 id="编译多个源文件"><a class="markdownIt-Anchor" href="#编译多个源文件"></a> 编译多个源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ testspeaker.cpp speaker.cpp -o testspeaker</span><br></pre></td></tr></table></figure><p>testspeaker.cpp speaker.cpp 需要编译的2个源文件</p><h3 id="更多参数详解"><a class="markdownIt-Anchor" href="#更多参数详解"></a> 更多参数详解</h3><p><strong>-E</strong><br>只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E test.cpp &gt; test.txt</span><br></pre></td></tr></table></figure><p><strong>-S</strong><br>只激活预处理和编译，就是指把文件编译成为汇编代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S test.cpp</span><br></pre></td></tr></table></figure><p>他将生成.s的汇编代码，你可以用文本编辑器察看</p><p><strong>-c</strong><br>只激活预处理,编译,和汇编,也就是他只把程序做成obj文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c</span><br></pre></td></tr></table></figure><p>他将生成.o的obj文件</p><h3 id="目录选项"><a class="markdownIt-Anchor" href="#目录选项"></a> 目录选项</h3><p><code>-Wl:rpath</code>,添加运行时库路径<br><code>-Wl:rpath</code>, 后面也是路径，运行的时候用。这条编译指令会在编译时记录到target文件中，所以编译之后的target文件在执行时会按这里给出的路径去找库文件。</p><p>如：<code>-Wl:rpath=/home/hello/lib</code></p><p>表示将<code>/home/hello/lib</code>目录作为程序运行时第一个寻找库文件的目录，程序寻找顺序是：<code>/home/hello/lib–&gt;/usr/lib–&gt;/usr/local/lib。</code></p><p>可以加多个包含路径，程序在运行时的寻找顺序为添加的顺序。</p><p><code>-L</code>,添加链接库路径<br><code>-L</code>后跟路径，告诉链接器从哪找库(.so文件)，只有在链接时会用到。</p><p>如：<code>-L /home/hello/lib</code></p><p>表示将<code>/home/hello/lib</code>目录作为第一个寻找库文件的目录，寻找顺序是：<code>/home/hello/lib–&gt;/usr/lib–&gt;/usr/local/lib</code>。</p><p>可以加多个包含路径，链接器的寻找顺序为添加的顺序。</p><p><code>-l</code>,添加引用链接库<br><code>-l</code> 在链接时用到，它的作用是告诉链接器，要用到哪个库。 如：<code>-l pthread</code></p><p>告诉链接器(linker)，程序需要链接pthread这个库,这里的pthread是库名不是文件名，<a href="http://xn--libpthread-0m4p18as1q4ojs42e4gcqyhhn4r.so" target="_blank" rel="noopener">具体来说文件句是libpthread.so</a></p><p><code>-I</code>,添加包含路径<br><code>-I</code>在编译时用，告诉编译器去哪个路径下找文件</p><p>如：<code>-I /home/hello/include</code></p><p>表示将<code>/home/hello/include</code>目录作为第一个寻找头文件的目录。</p><p>编译器的寻找顺序是：<code>/home/hello/include–&gt;/usr/include–&gt;/usr/local/include</code>。如果在<code>/home/hello/include</code>中有个文件hello.h，则在程序中用#include就能引用到这个文件。</p><p>可以加多个包含路径，编译器的寻找顺序为添加的顺序。</p><h3 id="调试选项"><a class="markdownIt-Anchor" href="#调试选项"></a> 调试选项</h3><p><code>-g</code><br>只是编译器，在编译的时候，产生调试信息。</p><p><code>-gstabs</code><br>此选项以stabs格式声称调试信息,但是不包括gdb调试信息.</p><p><code>-gstabs+</code><br>此选项以stabs格式声称调试信息,并且包含仅供gdb使用的额外调试信息.</p><p><code>-ggdb</code><br>此选项将尽可能的生成gdb的可以使用的调试信息.</p><p><code>-glevel</code><br>请求生成调试信息，同时用level指出需要多少信息，默认的level值是2<br>链接选项</p><p><code>-static</code>此选项将禁止使用动态库。<br>优点：程序运行不依赖于其他库</p><p>缺点：文件比较大</p><p><code>-shared</code> 指定生成动态链接库<br>优点：生成文件比较小</p><p>缺点：运行时需要系统提供动态库</p><p><code>-symbolic</code> 建立共享目标文件的时候,把引用绑定到全局符号上.<br>对所有无法解析的引用作出警告(除非用连接编辑选项 <code>-Xlinker -z -Xlinker defs</code>取代)。</p><p>注：只有部分系统支持该选项.</p><h3 id="错误与警告"><a class="markdownIt-Anchor" href="#错误与警告"></a> 错误与警告</h3><p><code>-Wall</code><br>一般使用该选项，允许发出GCC能够提供的所有有用的警告。也可以用-W{warning}来标记指定的警告。</p><p><code>-pedantic</code><br>允许发出ANSI/ISO C标准所列出的所有警告</p><p><code>-pedantic-errors</code><br>允许发出ANSI/ISO C标准所列出的错误</p><p><code>-werror</code><br>把所有警告转换为错误，以在警告发生时中止编译过程</p><p><code>-w</code><br>关闭所有警告,建议不要使用此项<br>预处理选项</p><p><code>-Dmacro</code><br>相当于C语言中的#define macro</p><p><code>-Dmacro=defn</code><br>相当于C语言中的#define macro=defn</p><p><code>-Umacro</code><br>相当于C语言中的#undef macro</p><p><code>-undef</code><br>取消对任何非标准宏的定义<br>其他选项</p><p><code>-o</code><br>制定目标名称,缺省的时候,g++编译出来的文件是a.out</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-O</span><br><span class="line">-O0</span><br><span class="line">-O1</span><br><span class="line">-O2</span><br><span class="line">-O3</span><br></pre></td></tr></table></figure><p>编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高</p><p><code>-fpic</code><br>编译器就生成位置无关目标码.适用于共享库(shared library).</p><p><code>-fPIC</code><br>编译器就输出位置无关目标码.适用于动态连接(dynamic linking),即使分支需要大范围转移.</p><p><code>-v</code><br>显示详细的编译、汇编、连接命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;g++是GNU组织推出的C++编译器。它不但可以用来编译传统的C++程序，也可以用来编译现代C++，比如&lt;code&gt;C++11/14&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;g++的用法和gcc类似，编译C++的时候比gcc更简单，因为它会自动链接到C++标准库，而不像gcc需要手
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>网络配置2</title>
    <link href="https://xiaowuyoucy.github.io/2022/02/08/linux000%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE2/"/>
    <id>https://xiaowuyoucy.github.io/2022/02/08/linux000网络配置2/</id>
    <published>2022-02-08T10:43:17.000Z</published>
    <updated>2022-02-08T10:47:48.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu1604-命令行配置网络"><a class="markdownIt-Anchor" href="#ubuntu1604-命令行配置网络"></a> Ubuntu16.04 命令行配置网络</h1><h3 id="1-切换root"><a class="markdownIt-Anchor" href="#1-切换root"></a> 1. 切换root</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line"> </span><br><span class="line">sudo passwd root #首次需给root配置密码</span><br></pre></td></tr></table></figure><h3 id="2-查看网卡信息"><a class="markdownIt-Anchor" href="#2-查看网卡信息"></a> 2. 查看网卡信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure><p>看见如eth0或enp5s0或ens33或ens192等就可以，比如我的是enp3s0</p><h3 id="3-配置系统网络"><a class="markdownIt-Anchor" href="#3-配置系统网络"></a> 3. 配置系统网络</h3><p>网络接口配置文件: <code>/etc/network/interfaces</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#无需改动</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line">#添加以下：</span><br><span class="line">auto enp3s0   #开机自动连接网络(enp3s0 为网卡名称,ifconfig -a看自己的)</span><br><span class="line"> </span><br><span class="line">iface enp3s0 inet static  #static表示使用固定ip，dhcp表述使用动态ip</span><br><span class="line"> </span><br><span class="line">address 192.168.1.84      #设置ip地址</span><br><span class="line"> </span><br><span class="line">netmask 255.255.255.0     #设置子网掩码</span><br><span class="line"> </span><br><span class="line">gateway 192.168.1.1       #设置网关</span><br><span class="line"> </span><br><span class="line">dns-nameservers 8.8.8.8   #设置DNS,谷歌dns</span><br><span class="line">#dns-nameservers 202.106.0.20  北京市联通dns</span><br></pre></td></tr></table></figure><h3 id="4-重启网络服务"><a class="markdownIt-Anchor" href="#4-重启网络服务"></a> 4. 重启网络服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service networking restart</span><br></pre></td></tr></table></figure><p>然后ifconfig 查看ip信息</p><p><strong>没效果就 reboot重启电脑</strong></p><p><strong><code>ping www.baidu.com</code> 如下已连通</strong></p><p><img src="/images/javawz/20200515111943424.png" alt="img"></p><p>OK.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu1604-命令行配置网络&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ubuntu1604-命令行配置网络&quot;&gt;&lt;/a&gt; Ubuntu16.04 命令行配置网络&lt;/h1&gt;
&lt;h3 id=&quot;1-切换root&quot;&gt;&lt;a class
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>网络配置</title>
    <link href="https://xiaowuyoucy.github.io/2022/02/08/linux000%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>https://xiaowuyoucy.github.io/2022/02/08/linux000网络配置/</id>
    <published>2022-02-08T10:24:04.000Z</published>
    <updated>2022-02-08T10:41:19.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu1804的网络配置静态ip和动态ip"><a class="markdownIt-Anchor" href="#ubuntu1804的网络配置静态ip和动态ip"></a> Ubuntu18.04的网络配置（静态IP和动态IP）</h1><h3 id="查看ubuntu系统的版本号命令"><a class="markdownIt-Anchor" href="#查看ubuntu系统的版本号命令"></a> 查看Ubuntu系统的版本号命令</h3><p><code>cat /etc/issue</code>或者 <code>lsb_release -a</code></p><h3 id="切换root命令"><a class="markdownIt-Anchor" href="#切换root命令"></a> 切换root命令</h3><p><code>sudo -i</code> 或者 <code>sudo -s</code></p><p><strong>提示：以下操作均在root用户下进行，如在普通用户，请自行加上sudo！</strong></p><h3 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h3><p>Ubuntu从17.10开始，已放弃在<code>/etc/network/interfaces</code>里配置IP地址，即使配置也不会生效，而是改成netplan方式，配置写在<code>/etc/netplan/01-netcfg.yaml</code>或者类似名称的yaml文件里，如下：</p><p>VMware14里安装的Ubuntu18.04.1 Desktop版本下的配置文件名：</p><p><img src="/images/javawz/1404518-20200614223934337-1576886527.png" alt="img"></p><p>VMware14里安装的Ubuntu18.04.4 Server版本下的配置文件名：</p><p><img src="/images/javawz/1404518-20200614224306528-1449186048.png" alt="img"></p><p>阿里云Ubuntu18.04.4 Server版本下的配置文件名：</p><p><img src="/images/javawz/1404518-20200614224537679-1678462440.png" alt="img"></p><h3 id="下面以vmware14里安装的ubuntu-18044-server版本为例vmware网络连接选择的桥接模式"><a class="markdownIt-Anchor" href="#下面以vmware14里安装的ubuntu-18044-server版本为例vmware网络连接选择的桥接模式"></a> 下面以VMware14里安装的Ubuntu 18.04.4 Server版本为例（VMware网络连接选择的桥接模式）</h3><h4 id="一-配置静态ip地址"><a class="markdownIt-Anchor" href="#一-配置静态ip地址"></a> 一、配置静态IP地址</h4><p>打开配置文件：<code>vim /etc/netplan/50-cloud-init.yaml</code>，写入以下配置内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        ens33:                  # 配置的网卡名称</span><br><span class="line">            dhcp4: no           # 关闭dhcp4</span><br><span class="line">            dhcp6: no           # 关闭dhcp6</span><br><span class="line">            addresses: [192.168.0.120/24]       # 设置本机IP地址及掩码</span><br><span class="line">            gateway4: 192.168.0.1               # 设置网关</span><br><span class="line">            nameservers:</span><br><span class="line">                    addresses: [114.114.114.114, 8.8.8.8]       # 设置DNS</span><br><span class="line">    version: 2</span><br></pre></td></tr></table></figure><p>截图</p><p><img src="/images/javawz/1404518-20200614231300863-237073454.png" alt="img"></p><p>配置完成后，保存并退出，执行<code>netplan apply</code>命令可以让配置直接生效</p><p>以前的重启网络服务命令 <code>/etc/init.d/networking restart</code> 或者 <code>service networking restar</code> 都是无法使用的（做测试时发现18.04.1的Desktop版本还是可以使用的，但/etc/netplan/下的yaml配置文件并不会生效）。</p><h4 id="验证是否配置成功"><a class="markdownIt-Anchor" href="#验证是否配置成功"></a> 验证是否配置成功</h4><p><code>ifconfig -a</code></p><p><img src="/images/javawz/1404518-20200614222201955-990276377.png" alt="img"></p><h4 id="验证是否能ping通外网"><a class="markdownIt-Anchor" href="#验证是否能ping通外网"></a> 验证是否能ping通外网</h4><p><code>ping -c 4 baidu.com</code></p><p><img src="/images/javawz/1404518-20200614222251773-819407962.png" alt="img"></p><h4 id="二-配置动态ip地址"><a class="markdownIt-Anchor" href="#二-配置动态ip地址"></a> 二、配置动态IP地址</h4><p>打开配置文件：<code>vim /etc/netplan/50-cloud-init.yaml</code>，写入以下配置内容（其实只需要开启dhcp就可以）：</p><p><img src="/images/javawz/1404518-20200614230042002-1549179355.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">network: </span><br><span class="line">   ethernets: </span><br><span class="line">       ens33: #配置网卡名称</span><br><span class="line">           dhcp4: true#开启dhcp4</span><br><span class="line">           dhcp4: true#开启dhcp4</span><br><span class="line">   version: 2</span><br></pre></td></tr></table></figure><p>保存并退出，执行 <code>netplan apply</code>命令让配置生效，用上述方法验证是否配置成功！</p><p>这里顺便也记录下Ubuntu 18.04.1 Desktop版本的配置，和18.04.4 Server版本略有区别（VMware网络连接选择的也是桥接模式）</p><p><code>vim /etc/netplan/01-network-manager-all.yaml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  # renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">          ens33:</span><br><span class="line">                  dhcp4: no</span><br><span class="line">                  dhcp6: no</span><br><span class="line">                  addresses: [192.168.0.130/24]</span><br><span class="line">                  gateway4: 192.168.0.1</span><br><span class="line">                  nameservers:</span><br><span class="line">                          addresses: [114.114.114.144, 8.8.8.8]</span><br></pre></td></tr></table></figure><p>截图</p><p><img src="/images/javawz/1404518-20200615081736202-1829516241.png" alt="img"></p><h3 id="这里有几点需要注意"><a class="markdownIt-Anchor" href="#这里有几点需要注意"></a> 这里有几点需要注意：</h3><p>1、Ubuntu 18.04.1 Desktop版本配置的时候需要将renderer: NetworkManager一行注释掉，否则netplan命令无法生效；</p><p>2、配置信息要严格按照yaml语言的语法格式，每个配置项使用空格缩进表示层级关系；<strong>缩进不允许使用tab，只允许空格；缩进的空格数不重要，只要相同层级的元素左对齐即可，否则netplan命令会报错；</strong></p><p>3、对应配置项后跟着冒号，之后要接个空格，否则netplan命令也会报错。</p><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><p>重新启停以太网卡命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33 down//关闭</span><br><span class="line"></span><br><span class="line">ifconfig ens33 up//开启</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu1804的网络配置静态ip和动态ip&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ubuntu1804的网络配置静态ip和动态ip&quot;&gt;&lt;/a&gt; Ubuntu18.04的网络配置（静态IP和动态IP）&lt;/h1&gt;
&lt;h3 id
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/31/linux084%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/31/linux084网络基础/</id>
    <published>2022-01-31T08:50:57.000Z</published>
    <updated>2022-02-23T17:34:14.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="协议的概念"><a class="markdownIt-Anchor" href="#协议的概念"></a> 协议的概念</h3><h4 id="什么是协议"><a class="markdownIt-Anchor" href="#什么是协议"></a> 什么是协议</h4><p>从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。</p><p>假设，A、B双方欲传输文件。规定：</p><p>第一次，传输文件名，接收方接收到文件名，应答OK给传输方；</p><p>第二次，发送文件的尺寸，接收方接收到该数据再次应答一个OK；</p><p>第三次，传输文件内容。同样，接收方接收数据完成后应答OK表示文件内容接收成功。</p><p>由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形成了一个最简单的数据传输规则。双方都按此规则发送、接收数据。A、B之间达成的这个相互遵守的规则即为协议。</p><p>这种仅在A、B之间被遵守的协议称之为<strong>原始协议</strong>。当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为一个<strong>标准协议</strong>。最早的ftp协议就是由此衍生而来。</p><p>TCP协议注重数据的传输。http协议着重于数据的解释。</p><h4 id="典型协议"><a class="markdownIt-Anchor" href="#典型协议"></a> 典型协议</h4><p>传输层 常见协议有TCP/UDP协议。</p><p>应用层 常见的协议有HTTP协议，FTP协议。</p><p>网络层 常见协议有IP协议、ICMP协议、IGMP协议。</p><p>网络接口层 常见协议有ARP协议、RARP协议。</p><p>TCP<a href="http://baike.baidu.com/view/544903.htm" target="_blank" rel="noopener">传输控制协议</a>（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的<a href="http://baike.baidu.com/view/239605.htm" target="_blank" rel="noopener">传输层</a>通信协议。</p><p>UDP用户数据报协议（User Datagram Protocol）是<a href="http://baike.baidu.com/view/113948.htm" target="_blank" rel="noopener">OSI</a>参考模型中一种无连接的<a href="http://baike.baidu.com/view/239605.htm" target="_blank" rel="noopener">传输层</a>协议，提供面向事务的简单不可靠信息传送服务。</p><p>HTTP<a href="http://baike.baidu.com/view/468465.htm" target="_blank" rel="noopener">超文本传输协议</a>（Hyper Text Transfer Protocol）是<a href="http://baike.baidu.com/view/6825.htm" target="_blank" rel="noopener">互联网</a>上应用最为广泛的一种<a href="http://baike.baidu.com/view/16603.htm" target="_blank" rel="noopener">网络协议</a>。</p><p>FTP文件传输协议（File Transfer Protocol）</p><p>IP协议是<a href="http://baike.baidu.com/view/1706.htm" target="_blank" rel="noopener">因特网</a>互联协议（Internet Protocol）</p><p>ICMP协议是Internet控制<a href="http://baike.baidu.com/view/175122.htm" target="_blank" rel="noopener">报文</a>协议（Internet Control Message Protocol）它是<a href="http://baike.baidu.com/view/2221037.htm" target="_blank" rel="noopener">TCP/IP协议族</a>的一个子协议，用于在IP<a href="http://baike.baidu.com/view/23880.htm" target="_blank" rel="noopener">主机</a>、<a href="http://baike.baidu.com/view/18655.htm" target="_blank" rel="noopener">路由</a>器之间传递控制消息。</p><p>IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。</p><p><a href="http://baike.baidu.com/view/32698.htm" target="_blank" rel="noopener">ARP</a>协议是正向<a href="http://baike.baidu.com/view/149421.htm" target="_blank" rel="noopener">地址解析协议</a>（Address Resolution Protocol），通过已知的IP，寻找对应主机的<a href="http://baike.baidu.com/view/69334.htm" target="_blank" rel="noopener">MAC地址</a>。</p><p><a href="http://baike.baidu.com/view/32772.htm" target="_blank" rel="noopener">RARP</a>是反向地址转换协议，通过MAC地址确定IP地址。</p><h3 id="网络应用程序设计模式"><a class="markdownIt-Anchor" href="#网络应用程序设计模式"></a> 网络应用程序设计模式</h3><h4 id="cs模式"><a class="markdownIt-Anchor" href="#cs模式"></a> C/S模式</h4><p>​传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p><p>优点:</p><ol><li>协议选用灵活</li><li>可以提前缓存数据。</li></ol><p>缺点:</p><pre><code> 1. 对用户的安全构成威胁   2. 开发工作量较大，调试困难</code></pre><h4 id="bs模式"><a class="markdownIt-Anchor" href="#bs模式"></a> B/S模式</h4><p>浏览器()/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p><p>优点:</p><ol><li>比较安全</li><li>开发工作简洁,只需要开发服务端</li><li>跨平台</li></ol><p>缺点:</p><ol><li>要求使用http协议</li><li>不可以提前缓存数据</li></ol><h3 id="分层模型"><a class="markdownIt-Anchor" href="#分层模型"></a> 分层模型</h3><h4 id="osi七层模型"><a class="markdownIt-Anchor" href="#osi七层模型"></a> OSI七层模型</h4><p><img src="/images/javawz/image-20220131174614011.png" alt="image-20220131174614011"></p><ol><li><p><strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做<strong>比特</strong>。</p></li><li><p><strong>数据链路层</strong>：定义了如何让格式化数据以<strong>帧</strong>为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1</p></li><li><p><strong>网络层</strong>：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。<strong>数据包</strong></p></li><li><p><strong>传输层</strong>：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做<strong>段</strong>。</p></li><li><p><strong>会话层</strong>：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</p></li><li><p><strong>表示层</strong>：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</p></li><li><p><strong>应用层</strong>：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</p></li></ol><h4 id="tcpip四层模型"><a class="markdownIt-Anchor" href="#tcpip四层模型"></a> TCP/IP四层模型</h4><p>TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示：</p><p><img src="/images/javawz/image-20220131174756807.png" alt="image-20220131174756807"></p><p>一般在应用开发过程中，讨论最多的是TCP/IP模型。</p><h3 id="通信过程"><a class="markdownIt-Anchor" href="#通信过程"></a> 通信过程</h3><p>两台计算机通过TCP/IP协议通讯的过程如下所示：</p><p><img src="/images/javawz/image-20220131175741703.png" alt="image-20220131175741703"></p><p>上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示：</p><p><img src="/images/javawz/image-20220131180004435.png" alt="image-20220131180004435"></p><p>链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、<strong>数据差错校验</strong>等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。</p><p>网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter-net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。</p><p>网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。</p><p>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。</p><p>UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</p><p>目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：</p><p><img src="/images/javawz/image-20220131180029314.png" alt="image-20220131180029314"></p><p>以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。</p><p>虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。</p><h3 id="协议格式"><a class="markdownIt-Anchor" href="#协议格式"></a> 协议格式</h3><h4 id="数据包封装"><a class="markdownIt-Anchor" href="#数据包封装"></a> 数据包封装</h4><p>传输层及其以下的机制由内核提供，应用层由用户进程提供（后面将介绍如何使用socket API编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示：</p><p><img src="/images/javawz/image-20220131180149068.png" alt="image-20220131180149068"></p><p>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p><h4 id="以太网帧格式"><a class="markdownIt-Anchor" href="#以太网帧格式"></a> 以太网帧格式</h4><p>以太网的帧格式如下所示：</p><p><img src="/images/javawz/image-20220131180221986-1644317422126.png" alt="image-20220131180221986"></p><p>其中的<strong>源地址和目的地址</strong>是指网卡的<strong>硬件地址</strong>（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，“HWaddr 00:15:F2:14:9E:3F”部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。</p><p>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。<strong>最大值1500称为以太网的最大传输单元（MTU）</strong>，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。</p><h4 id="arp数据报格式"><a class="markdownIt-Anchor" href="#arp数据报格式"></a> ARP数据报格式</h4><p>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。</p><p>每台主机都维护一个ARP缓存表，可以用<code>arp -a</code>命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。想一想，为什么表项要有过期时间而不是一直有效？</p><p>ARP数据报的格式如下所示：</p><p><img src="/images/javawz/image-20220131192510328.png" alt="image-20220131192510328"></p><p>源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为1表示ARP请求，op字段为2表示ARP应答。</p><p><img src="/images/javawz/image-20220131230905439.png" alt="image-20220131230905439"></p><p><img src="/images/javawz/image-20220131231031294.png" alt="image-20220131231031294"></p><p>路由器会把arp数据报发给所有的机器，然后每个机器拿到后会检查接收端的ip是不是自己的ip，如果不是则扔掉</p><p>ARP数据报：获取下一条的mac地址</p><p><img src="/images/javawz/image-20220131232110833.png" alt="image-20220131232110833"></p><p>TTL:表示当前还可以进行多少跳，每次到达自己这里TTL都会减一</p><p>数据包到达路由器后会进行解封装,先解数据帧首尾,然后解网络层，然后再封装自己的ip和自己的mac地址，和目标mac地址，最后发出去，每次结果路由器都会重复上面步骤，直到到达目的pc</p><h4 id="ip段格式"><a class="markdownIt-Anchor" href="#ip段格式"></a> IP段格式</h4><p><img src="/images/javawz/image-20220201173046589.png" alt="image-20220201173046589"></p><p>IP数据报的首部长度和数据长度都是可变长的，<strong>但总是4字节的整数倍</strong>。对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，<strong>最小值为5</strong>，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说<strong>首部长度最大是60字节</strong>。8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大?吐量、最大可靠性、最小成本），还有一个位总是0。总长度是整个数据报（包括IP首部和IP层payload）的字节数。每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。3位标志和13位片偏移用于分片。TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。</p><p>想一想，前面讲了以太网帧中的最小数据长度为46字节，不足46字节的要用填充字节补上，那么如何界定这46字节里前多少个字节是IP、ARP或RARP数据报而后面是填充字节？</p><h3 id="udp数据报格式"><a class="markdownIt-Anchor" href="#udp数据报格式"></a> UDP数据报格式</h3><p><img src="/images/javawz/image-20220201173320717.png" alt="image-20220201173320717"></p><p>端口号表示指定的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">下面分析一帧基于UDP的TFTP协议帧。</span><br><span class="line">以太网首部</span><br><span class="line">0000: 00 05 5d 67 d0 b1 00 05 5d 61 58 a8 08 00</span><br><span class="line">IP首部</span><br><span class="line">0000: 45 00</span><br><span class="line">0010: 00 53 93 25 00 00 80 11 25 ec c0 a8 00 37 c0 a8</span><br><span class="line">0020: 00 01</span><br><span class="line">UDP首部</span><br><span class="line">0020： 05 d4 00 45 00 3f ac 40</span><br><span class="line">TFTP协议</span><br><span class="line">0020: 00 01 &apos;c&apos;&apos;:&apos;&apos;\&apos;&apos;q&apos;</span><br><span class="line">0030: &apos;w&apos;&apos;e&apos;&apos;r&apos;&apos;q&apos;&apos;.&apos;&apos;q&apos;&apos;w&apos;&apos;e&apos;00 &apos;n&apos;&apos;e&apos;&apos;t&apos;&apos;a&apos;&apos;s&apos;&apos;c&apos;&apos;i&apos;</span><br><span class="line">0040: &apos;i&apos;00 &apos;b&apos;&apos;l&apos;&apos;k&apos;&apos;s&apos;&apos;i&apos;&apos;z&apos;&apos;e&apos;00 &apos;5&apos;&apos;1&apos;&apos;2&apos;00 &apos;t&apos;&apos;i&apos;</span><br><span class="line">0050: &apos;m&apos;&apos;e&apos;&apos;o&apos;&apos;u&apos;&apos;t&apos;00 &apos;1&apos;&apos;0&apos;00 &apos;t&apos;&apos;s&apos;&apos;i&apos;&apos;z&apos;&apos;e&apos;00 &apos;0&apos;</span><br><span class="line">0060: 00以太网首部：源MAC地址是00:05:5d:61:58:a8，目的MAC地址是00:05:5d:67:d0:b1，上层协议类型0x0800表示IP。</span><br><span class="line">IP首部：每一个字节0x45包含4位版本号和4位首部长度，版本号为4，即IPv4，首部长度为5，说明IP首部不带有选项字段。服务类型为0，没有使用服务。16位总长度字段（包括IP首部和IP层payload的长度）为0x0053，即83字节，加上以太网首部14字节可知整个帧长度是97字节。IP报标识是0x9325，标志字段和片偏移字段设置为0x0000，就是DF=0允许分片，MF=0此数据报没有更多分片，没有分片偏移。TTL是0x80，也就是128。上层协议0x11表示UDP协议。IP首部校验和为0x25ec，源主机IP是c0 a8 00 37（192.168.0.55），目的主机IP是c0 a8 00 01（192.168.0.1）。</span><br><span class="line">UDP首部：源端口号0x05d4（1492）是客户端的端口号，目的端口号0x0045（69）是TFTP服务的well-known端口号。UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay-load的长度。UDP首部和UDP层payload的校验和为0xac40。</span><br><span class="line">TFTP是基于文本的协议，各字段之间用字节0分隔，开头的00 01表示请求读取一个文件，接下来的各字段是：</span><br><span class="line">c:\qwerq.qwe</span><br><span class="line">netascii</span><br><span class="line">blksize 512</span><br><span class="line">timeout 10</span><br><span class="line">tsize 0</span><br></pre></td></tr></table></figure><p>一般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器，客户端主动发起请求（上面的例子就是客户端发起的请求帧），而服务器被动地等待、接收和应答请求。客户端的IP地址和端口号唯一标识了该主机上的TFTP客户端进程，服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程，由于客户端是主动发起请求的一方，它必须知道服务器的IP地址和TFTP服务进程的端口号，所以，一些常见的网络协议有默认的服务器端口，例如HTTP服务默认TCP协议的80端口，FTP服务默认TCP协议的21端口，TFTP服务默认UDP协议的69端口（如上例所示）。在使用客户端程序时，必须指定服务器的主机名或IP地址，如果不明确指定端口号则采用默认端口，请读者查阅ftp、tftp等程序的man page了解如何指定端口号。/etc/services中列出了所有well-known的服务端口和对应的传输层协议，这是由IANA（Internet Assigned Numbers Authority）规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务。</p><p>很多服务有well-known的端口号，然而客户端程序的端口号却不必是well-known的，往往是每次运行客户端程序时由系统自动分配一个空闲的端口号，用完就释放掉，称为ephemeral的端口号，想想这是为什么？</p><p>前面提过，UDP协议不面向连接，也不保证传输的可靠性，例如：</p><p>发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。</p><p>接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。</p><p>通常接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。</p><p>因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。例如，基于UDP的TFTP协议一般只用于传送小文件（所以才叫trivial的ftp），而基于TCP的FTP协议适用于各种文件的传输。TCP协议又是如何用面向连接的服务来代替应用程序解决传输的可靠性问题呢。</p><h4 id="tcp数据报格式"><a class="markdownIt-Anchor" href="#tcp数据报格式"></a> TCP数据报格式</h4><p><img src="/images/javawz/image-20220201173716334.png" alt="image-20220201173716334"></p><p>与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。32位序号、32位确认序号、窗口大小稍后详细解释。4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。URG、ACK、PSH、RST、SYN、FIN是六个控制位，本节稍后将解释SYN、ACK、FIN、RST四个位，其它位的解释从略。16位检验和将TCP协议头和数据都计算在内。紧急指针和各种选项的解释从略。</p><h3 id="nat映射"><a class="markdownIt-Anchor" href="#nat映射"></a> NAT映射</h3><p><img src="/images/javawz/image-20220201173928063.png" alt="image-20220201173928063"></p><p>A机器发送数据包给服务器,首先数据包经过路由器,然后路由器会一个端口号和自己的ip再和A机器的ip成为映射关系,服务器收到后回A机器数据包,目的ip的地址是写路由器的ip,端口号写路由器创建出来的那个端口号,路由器收到数据包后会在NAT映射表中查找端口号对应的ip,找到后再发给A机器</p><h3 id="打洞机制"><a class="markdownIt-Anchor" href="#打洞机制"></a> 打洞机制</h3><p><img src="/images/javawz/image-20220201180619648.png" alt="image-20220201180619648"></p><p>两台机器在不同的局域网中进行直接通信,需要进行nat映射和打洞机制.</p><h3 id="socket编程"><a class="markdownIt-Anchor" href="#socket编程"></a> Socket编程</h3><h4 id="套接字概念"><a class="markdownIt-Anchor" href="#套接字概念"></a> 套接字概念</h4><p>Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。</p><p>既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p><p>套接字的内核实现较为复杂，不宜在学习初期深入学习。</p><p>在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p><p>套接字通信原理如下图所示：</p><p><img src="/images/javawz/image-20220201193432501.png" alt="image-20220201193432501"></p><p>**在网络通信中，套接字一定是成对出现的。**一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。</p><p>TCP/IP协议最早在BSD UNIX上实现，为TCP/IP协议设计的应用层编程接口称为socket API。本章的主要内容是socket API，主要介绍TCP协议的函数接口，最后介绍UDP协议和UNIX Domain Socket的函数接口。</p><p><img src="/images/javawz/image-20220201193510324.png" alt="image-20220201193510324"></p><p><img src="/images/javawz/image-20220201193808939.png" alt="image-20220201193808939"></p><h3 id="网络字节序"><a class="markdownIt-Anchor" href="#网络字节序"></a> 网络字节序</h3><p><img src="/images/javawz/image-20220201234457225.png" alt="image-20220201234457225"></p><p>我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发 出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。</p><p>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。例如上一节的UDP段格式，地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。</p><p>为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做<strong>网络字节序和主机字节序的转换</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要包含的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);<span class="comment">//ip本地字节序转换到网络字节序</span></span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);<span class="comment">//端口本地字节序转换到网络字节序</span></span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);<span class="comment">//ip网络字节序转换为本地字节序</span></span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);<span class="comment">//端口网络字节序转换为本地字节序</span></span><br></pre></td></tr></table></figure><p>h表示host，n表示network，l表示32位长整数，s表示16位短整数。</p><p>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</p><h4 id="ip地址转换函数"><a class="markdownIt-Anchor" href="#ip地址转换函数"></a> IP地址转换函数</h4><p>早期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int inet_aton(const char *cp, struct in_addr *inp);</span><br><span class="line">in_addr_t inet_addr(const char *cp);</span><br><span class="line">char *inet_ntoa(struct in_addr in);</span><br><span class="line">只能处理IPv4的ip地址</span><br><span class="line">不可重入函数</span><br><span class="line">注意参数是struct in_addr</span><br></pre></td></tr></table></figure><p>现在：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;<span class="comment">//字符串点分十进制ip转换为网络字节序</span></span><br><span class="line">参数<span class="number">1</span>:AF_INET(ipv4)</span><br><span class="line">      AF_INET6 (ipv6)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//网络字节序ip转换成点分十进制ip字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line">参数<span class="number">1</span>:AF_INET(ipv4)</span><br><span class="line">      AF_INET6 (ipv6)</span><br><span class="line">    </span><br><span class="line">    两个函数错误返回<span class="number">-1</span>并设置errno</span><br></pre></td></tr></table></figure><p>支持IPv4和IPv6</p><p>可重入函数</p><p>其中<code>inet_pton</code>和<code>inet_ntop</code>不仅可以转换IPv4的<code>in_addr</code>，还可以转换IPv6的<code>in6_addr</code>。</p><p>因此函数接口是<code>void *addrptr</code>。</p><h4 id="sockaddr数据结构"><a class="markdownIt-Anchor" href="#sockaddr数据结构"></a> sockaddr数据结构</h4><p>strcut sockaddr 很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p><p><img src="/images/javawz/image-20220201225235077.png" alt="image-20220201225235077"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr &#123;</span><br><span class="line">sa_family_t sa_family; /* address family, AF_xxx */</span><br><span class="line">char sa_data[14];/* 14 bytes of protocol address */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 sudo grep -r &quot;struct sockaddr_in &#123;&quot;  /usr 命令可查看到struct sockaddr_in结构体的定义。一般其默认的存储位置：/usr/include/linux/in.h 文件中。</span><br></pre></td></tr></table></figure><br><p>一般使用这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">__kernel_sa_family_t sin_family; /* Address family */  地址结构类型</span><br><span class="line">__be16 sin_port; /* Port number */端口号</span><br><span class="line">struct in_addr sin_addr;/* Internet address */IP地址</span><br><span class="line">/* Pad to size of `struct sockaddr&apos;. */</span><br><span class="line">unsigned char __pad[__SOCK_SIZE__ - sizeof(short int) -</span><br><span class="line">sizeof(unsigned short int) - sizeof(struct in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct in_addr &#123;/* Internet address. */</span><br><span class="line">__be32 s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in6 &#123;</span><br><span class="line">unsigned short int sin6_family; /* AF_INET6 */</span><br><span class="line">__be16 sin6_port; /* Transport layer port # */</span><br><span class="line">__be32 sin6_flowinfo; /* IPv6 flow information */</span><br><span class="line">struct in6_addr sin6_addr;/* IPv6 address */</span><br><span class="line">__u32 sin6_scope_id; /* scope id (new in RFC2553) */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct in6_addr &#123;</span><br><span class="line">union &#123;</span><br><span class="line">__u8 u6_addr8[16];</span><br><span class="line">__be16 u6_addr16[8];</span><br><span class="line">__be32 u6_addr32[4];</span><br><span class="line">&#125; in6_u;</span><br><span class="line">#define s6_addr in6_u.u6_addr8</span><br><span class="line">#define s6_addr16 in6_u.u6_addr16</span><br><span class="line">#define s6_addr32 in6_u.u6_addr32</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define UNIX_PATH_MAX 108</span><br><span class="line">struct sockaddr_un &#123;</span><br><span class="line">__kernel_sa_family_t sun_family; /* AF_UNIX */</span><br><span class="line">char sun_path[UNIX_PATH_MAX]; /* pathname */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Pv4和IPv6的地址格式定义在<code>netinet/in.h</code>中，IPv4地址用<code>sockaddr_in</code>结构体表示，包括16位端口号和32位IP地址，IPv6地址用<code>sockaddr_in6</code>结构体表示，包括16位端口号、128位IP地址和一些控制字段。UNIX Domain Socket的地址格式定义在<code>sys/un.h</code>中，用<code>sock-addr_un</code>结构体表示。各种socket地址结构体的开头都是相同的，前16位表示整个结构体的长度（并不是所有UNIX的实现都有长度字段，如Linux就没有），后16位表示地址类型。IPv4、IPv6和Unix Domain Socket的地址类型分别定义为常数<code>AF_INET、AF_INET6、AF_UNIX</code>。这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如bind、accept、connect等函数，这些函数的参数应该设计成<code>void *</code>类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有<code>void *</code>类型，因此这些函数的参数都用<code>struct sockaddr *</code>类型表示，在传递参数之前要强制类型转换一下，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">bind(listen_fd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));/* initialize servaddr */</span><br></pre></td></tr></table></figure><h3 id="网络套接字函数"><a class="markdownIt-Anchor" href="#网络套接字函数"></a> 网络套接字函数</h3><h4 id="socket模型创建流程图"><a class="markdownIt-Anchor" href="#socket模型创建流程图"></a> socket模型创建流程图</h4><p><img src="/images/javawz/image-20220201225715684.png" alt="image-20220201225715684"></p><h4 id="socket函数"><a class="markdownIt-Anchor" href="#socket函数"></a> socket函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">domain:</span><br><span class="line">AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址</span><br><span class="line">AF_INET6 与上面类似，不过是来用IPv6的地址</span><br><span class="line">AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</span><br><span class="line">type:</span><br><span class="line">SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</span><br><span class="line">SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</span><br><span class="line">SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</span><br><span class="line">SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</span><br><span class="line">SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</span><br><span class="line">protocol:</span><br><span class="line">传0 表示使用默认协议。</span><br><span class="line">返回值：</span><br><span class="line">成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</span><br></pre></td></tr></table></figure><p><code>socket()</code>打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回<code>-1</code>。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为<code>SOCK_STREAM</code>，表示面向流的传输协议。如果是UDP协议，则type参数指定为<code>SOCK_DGRAM</code>，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。</p><h4 id="bind函数"><a class="markdownIt-Anchor" href="#bind函数"></a> bind函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">sockfd：</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">构造出IP地址加端口号</span><br><span class="line">addrlen:</span><br><span class="line">sizeof(addr)长度</span><br><span class="line">返回值：</span><br><span class="line">成功返回0，失败返回-1, 设置errno</span><br></pre></td></tr></table></figure><p>服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。</p><p>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(6666);</span><br></pre></td></tr></table></figure><p>首先将整个结构体清零，然后设置地址类型为AF_INET，<strong>网络地址为INADDR_ANY，这个宏表示本地的任意IP地址</strong>，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为6666。</p><h4 id="listen函数"><a class="markdownIt-Anchor" href="#listen函数"></a> listen函数</h4><p>表示最多同时能有多少客户端连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">sockfd:</span><br><span class="line">socket文件描述符</span><br><span class="line">backlog:</span><br><span class="line">排队建立3次握手队列和刚刚建立3次握手队列的链接数和</span><br></pre></td></tr></table></figure><p>查看系统默认backlog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br></pre></td></tr></table></figure><p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</p><h4 id="accept函数"><a class="markdownIt-Anchor" href="#accept函数"></a> accept函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">sockdf:</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">传出参数，返回链接客户端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小</span><br><span class="line">返回值：</span><br><span class="line">成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno</span><br></pre></td></tr></table></figure><p>三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。</p><p>我们的服务器程序结构是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line">cliaddr_len = sizeof(cliaddr);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">n = read(connfd, buf, MAXLINE);</span><br><span class="line">......</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭<code>listenfd</code>，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1。</p><h3 id="connect函数"><a class="markdownIt-Anchor" href="#connect函数"></a> connect函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">sockdf:</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">传入参数，指定服务器端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">传入参数,传入sizeof(addr)大小</span><br><span class="line">返回值：</span><br><span class="line">成功返回0，失败返回-1，设置errno</span><br></pre></td></tr></table></figure><h4 id="cs模型-tcp"><a class="markdownIt-Anchor" href="#cs模型-tcp"></a> C/S模型-TCP</h4><p>下图是基于TCP协议的客户端/服务器程序的一般流程：</p><p><img src="/images/javawz/image-20220201230423889.png" alt="image-20220201230423889"></p><p>服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口的状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞等待服务器应答，服务器应答一个SYN-ACK段，客户端收到后从connect()返回，同时应答一个ACK段，服务器收到后从accept()返回。</p><p>数据传输的过程：</p><p>建立连接后，TCP协议提供全双工的通信服务，但是一般的客户端/服务器程序的流程是由客户端主动发起请求，服务器被动处理请求，一问一答的方式。因此，服务器从accept()返回后立刻调用read()，读socket就像读管道一样，如果没有数据到达就阻塞等待，这时客户端调用write()发送请求给服务器，服务器收到后从read()返回，对客户端的请求进行处理，在此期间客户端调用read()阻塞等待服务器的应答，服务器调用write()将处理结果发回给客户端，再次调用read()阻塞等待下一条请求，客户端收到后从read()返回，发送下一条请求，如此循环下去。</p><p>如果客户端没有更多的请求了，就调用close()关闭连接，就像写端关闭的管道一样，服务器的read()返回0，这样服务器就知道客户端关闭了连接，也调用close()关闭连接。注意，任何一方调用close()后，连接的两个传输方向都关闭，不能再发送数据了。如果一方调用shutdown()则连接处于半关闭状态，仍可接收对方发来的数据。</p><p>在学习socket API时要注意应用程序和TCP协议层是如何交互的： 应用程序调用某个socket函数时TCP协议层完成什么动作，比如调用connect()会发出SYN段 应用程序如何知道TCP协议层的状态变化，比如从某个阻塞的socket函数返回就表明TCP协议收到了某些段，再比如read()返回0就表明收到了FIN段</p><h3 id="nc命令"><a class="markdownIt-Anchor" href="#nc命令"></a> nc命令</h3><p>简单的客户端程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc ip地址 端口号</span><br><span class="line">nc 127.0.0.1 6666</span><br><span class="line">nc 127.1 6666</span><br></pre></td></tr></table></figure><h4 id="bzero函数"><a class="markdownIt-Anchor" href="#bzero函数"></a> bzero函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//要包含的头文件</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 作用: 把缓冲区逐字节清零</span><br><span class="line">void bzero(void *s, size_t n);</span><br><span class="line">void *s//指定缓冲区</span><br><span class="line">size_t n//指定缓冲取大小</span><br></pre></td></tr></table></figure><h4 id="server实现"><a class="markdownIt-Anchor" href="#server实现"></a> server实现</h4><p>作用是从客户端读字符，然后将每个字符转换为大写并回送给客户端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ],CLIE_IP[BUFZIZ];</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT); </span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">    cfd = accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client IP: %s  port:%d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), </span><br><span class="line">            ntohs(clie_addr.sin_port));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        write(cfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(cfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client客户端实现"><a class="markdownIt-Anchor" href="#client客户端实现"></a> client客户端实现</h3><p>作用:客户端输入英文小写字符串,并发送给服务端,然后服务端回一串对应的大写英文字符串,最后输出到终端</p><p>如果客户端不绑定端口和ip，操作系统会隐式的帮客户端绑定地址和端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man 7 ip //查看struct sockaddr_in 结构体</span><br><span class="line"></span><br><span class="line">gets函数最好不要使用,因为已经过时了,使用fgets来代替gets</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建一个socket 指定IPv4 TCP*/</span></span><br><span class="line">    sfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化一个地址结构:*/</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));                       <span class="comment">//清零</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;                             <span class="comment">//IPv4协议族</span></span><br><span class="line">    inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr);    <span class="comment">//指定IP 字符串类型转换为网络字节序 参3:传出参数</span></span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);                      <span class="comment">//指定端口 本地转网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*根据地址结构链接指定服务器进程*/</span></span><br><span class="line">    connect(sfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*从标准输入获取数据*/</span></span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">/*将数据写给服务器*/</span></span><br><span class="line">        write(sfd, buf, <span class="built_in">strlen</span>(buf));       <span class="comment">//写个服务器</span></span><br><span class="line">        <span class="comment">/*从服务器读回转换后数据*/</span></span><br><span class="line">        len = read(sfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">/*写至标准输出*/</span></span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*关闭链接*/</span></span><br><span class="line">    close(sfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h3 id="客户端服务器程序分析"><a class="markdownIt-Anchor" href="#客户端服务器程序分析"></a> 客户端服务器程序分析</h3><br><p><img src="/images/javawz/image-20220210013817470.png" alt="image-20220210013817470"></p><p>客户端和服务器端的cfd文件描述符各自指向两个缓冲区一个是读缓冲区另一个是写缓冲区</p><p>他们是通过IP地址+端口号进行建立连接的</p><p>一个文件描述符读的同时也可以写,所以是双向全双工的</p><p>客户端输入hello然后通过cfd写入发送缓冲区里，然后发送给服务器端的cfd接收缓冲区，服务器端收到hello后将其转换为HELLO后，将其写入发送缓冲区，然后发送给客户端的接收缓冲区，客户端收到后显示到终端</p><p>如果cfd只有一个缓冲区，就只能接收或发送，如果缓冲区是负责接收的，那么就不能发送，相反同上。所以cfd一定是两个缓冲区进行工作的。</p><p>服务器端或客户端的read如果没有接收到消息，一定是阻塞的，直到缓冲区收到内容才进行工作。</p><h3 id="查看网络程序端口"><a class="markdownIt-Anchor" href="#查看网络程序端口"></a> 查看网络程序端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -apn | grep 端口号</span><br></pre></td></tr></table></figure><h3 id="错误处理函数"><a class="markdownIt-Anchor" href="#错误处理函数"></a> 错误处理函数</h3><p>帮助文档查看函数名的时候是不区分大小写的</p><h4 id="wraph"><a class="markdownIt-Anchor" href="#wraph"></a> wrap.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WRAP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> Read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> Write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="keyword">ssize_t</span> Writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="keyword">ssize_t</span> my_read(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr);</span><br><span class="line"><span class="keyword">ssize_t</span> Readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="wrapc"><a class="markdownIt-Anchor" href="#wrapc"></a> wrap.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(s);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ((n = accept(fd, sa, salenptr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">perr_exit(<span class="string">"accept error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((n = bind(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"bind error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n = connect(fd, sa, salen);</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perr_exit(<span class="string">"connect error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((n = listen(fd, backlog)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"listen error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((n = socket(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"socket error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ( (n = read(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ((n = write(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> ((n = close(fd)) == <span class="number">-1</span>)</span><br><span class="line">perr_exit(<span class="string">"close error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*参三: 应该读取的字节数*/</span>                          <span class="comment">//socket 4096  readn(cfd, buf, 4096)   nleft = 4096-1500</span></span><br><span class="line"><span class="comment">//读n个字节</span></span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span>  nleft;              <span class="comment">//usigned int 剩余未读取的字节数</span></span><br><span class="line"><span class="keyword">ssize_t</span> nread;              <span class="comment">//int 实际读到的字节数</span></span><br><span class="line"><span class="keyword">char</span>   *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;                  <span class="comment">//n 未读取字节数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">nread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">nleft -= nread;   <span class="comment">//nleft = nleft - nread </span></span><br><span class="line">ptr += nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写n个字节</span></span><br><span class="line"><span class="keyword">ssize_t</span> Writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nwritten;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"><span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ( (nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">nwritten = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">nleft -= nwritten;</span><br><span class="line">ptr += nwritten;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次读100个字节</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> read_cnt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *read_ptr;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> read_buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ( (read_cnt = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;   <span class="comment">//"hello\n"</span></span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">read_ptr = read_buf;</span><br><span class="line">&#125;</span><br><span class="line">read_cnt--;</span><br><span class="line">*ptr = *read_ptr++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*readline --- fgets*/</span>    </span><br><span class="line"><span class="comment">//传出参数 vptr</span></span><br><span class="line"><span class="comment">// 作用：读一行</span></span><br><span class="line"><span class="keyword">ssize_t</span> Readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n, rc;</span><br><span class="line"><span class="keyword">char</span>    c, *ptr;</span><br><span class="line">ptr = vptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((rc = my_read(fd, &amp;c)) == <span class="number">1</span>) &#123;   <span class="comment">//ptr[] = hello\n</span></span><br><span class="line">*ptr++ = c;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">*ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">*ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read函数返回值"><a class="markdownIt-Anchor" href="#read函数返回值"></a> read函数返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char buf[1024];</span><br><span class="line"></span><br><span class="line">&gt;0实际读到的字节数,可以等于buf或小于buf</span><br><span class="line">=0对端关闭</span><br><span class="line">=-1异常</span><br><span class="line">1.errno == EINTR 被信号中断可以进行重启或退出处理</span><br><span class="line">2.  errno == EAGAIN (EWOULDBLOCK) 非阻塞方式读，并且没有数据</span><br><span class="line">3.  其他值   出现错误。--perror 打印错误信息 ,exit 退出程序。</span><br></pre></td></tr></table></figure><br><h3 id="tcp三次握手和四次挥手"><a class="markdownIt-Anchor" href="#tcp三次握手和四次挥手"></a> TCP三次握手和四次挥手</h3><p><img src="/images/javawz/image-20220210193456378.png" alt="image-20220210193456378"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TCP三次握手</span><br><span class="line">客户端: 发送SYN包 1(0)括号0代表这个数据包带0字节数据</span><br><span class="line">服务端: 收到后做应答   2000(0) ACK 2ACK是应答客户端发送的SYN包号+1</span><br><span class="line">客户端: 收到服务端的包后做出应答  ACK 2001</span><br><span class="line"></span><br><span class="line">TCP四次挥手</span><br><span class="line">客户端:发送FIN包   2(0)  ACK 2001</span><br><span class="line">服务端;    收到后回一个ACK包   ACK 3</span><br><span class="line">这时候TCP属于半关闭状态</span><br><span class="line">服务端:发送FIN包  FIN 2001(0) ACK 3</span><br><span class="line">客户端:发送ACK包  ACK 2002</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MTU、mss、半关闭</span><br><span class="line"></span><br><span class="line">MTU： 最大传输单元    受协议限制   以太网1500   IP 65535</span><br><span class="line"></span><br><span class="line">mss： 受MTU 标示一个数据包携带数据的上限数。 </span><br><span class="line"></span><br><span class="line">win： 滑动窗口——当前本端 能接收的数据上限值。(单位：字节)</span><br></pre></td></tr></table></figure><br><p>使用TCP建立连接的机器,如果机器A发送数据包给机器B，机器B没有收到的话，机器A会重新发送一次</p><h3 id="协议上限分析"><a class="markdownIt-Anchor" href="#协议上限分析"></a> 协议上限分析</h3><p><img src="/images/javawz/image-20220210200444005.png" alt="image-20220210200444005"></p><h3 id="多进程并发服务器程序实现"><a class="markdownIt-Anchor" href="#多进程并发服务器程序实现"></a> 多进程并发服务器程序实现</h3><p><img src="/images/javawz/image-20220210204704757.png" alt="image-20220210204704757"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sigchild</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>;</span></span><br><span class="line"></span><br><span class="line">    newact.sa_handler = do_sigchild;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGCHLD, &amp;newact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="comment">//子进程工作</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            Close(listenfd);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                n = Read(connfd, buf, MAXLINE);</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">                        inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                        ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                    buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line"></span><br><span class="line">                Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                Write(connfd, buf, n);</span><br><span class="line">            &#125;</span><br><span class="line">            Close(connfd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Close(connfd);</span><br><span class="line">        &#125;  <span class="keyword">else</span></span><br><span class="line">            perr_exit(<span class="string">"fork"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程并发服务器程序实现"><a class="markdownIt-Anchor" href="#多线程并发服务器程序实现"></a> 多线程并发服务器程序实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> &#123;</span>                     <span class="comment">//定义一个结构体, 将地址结构跟cfd捆绑</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_work</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> *<span class="title">ts</span> = (<span class="title">struct</span> <span class="title">s_info</span>*)<span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];      <span class="comment">//#define INET_ADDRSTRLEN 16  可用"[+d"查看</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n = Read(ts-&gt;connfd, buf, MAXLINE);                     <span class="comment">//读客户端</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"the client %d closed...\n"</span>, ts-&gt;connfd);</span><br><span class="line">            <span class="keyword">break</span>;                                              <span class="comment">//跳出循环,关闭cfd</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">                inet_ntop(AF_INET, &amp;(*ts).cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                ntohs((*ts).cliaddr.sin_port));                 <span class="comment">//打印客户端信息(IP/PORT)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);                           <span class="comment">//小写--&gt;大写</span></span><br><span class="line"></span><br><span class="line">        Write(STDOUT_FILENO, buf, n);                           <span class="comment">//写出至屏幕</span></span><br><span class="line">        Write(ts-&gt;connfd, buf, n);                              <span class="comment">//回写给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">    Close(ts-&gt;connfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> <span class="title">ts</span>[256];</span>      <span class="comment">//根据最大线程数创建结构体数组.</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);                     <span class="comment">//创建一个socket, 得到lfd</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));                             <span class="comment">//地址结构清零</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);                   <span class="comment">//指定本地任意IP</span></span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);                           <span class="comment">//指定端口号 8000</span></span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)); <span class="comment">//绑定</span></span><br><span class="line"></span><br><span class="line">    Listen(listenfd, <span class="number">128</span>);      <span class="comment">//设置同一时刻链接服务器上限数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepting client connect ...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);   <span class="comment">//阻塞监听客户端链接请求</span></span><br><span class="line">        ts[i].cliaddr = cliaddr;</span><br><span class="line">        ts[i].connfd = connfd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 达到线程最大数时，pthread_create出错处理, 增加服务器稳定性 */</span></span><br><span class="line">        pthread_create(&amp;tid, <span class="literal">NULL</span>, do_work, (<span class="keyword">void</span>*)&amp;ts[i]);</span><br><span class="line">        pthread_detach(tid);                                                    <span class="comment">//子线程分离,防止僵线程产生.</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tcp状态转换"><a class="markdownIt-Anchor" href="#tcp状态转换"></a> TCP状态转换</h3><p><img src="/images/javawz/image-20220211012542123.png" alt="image-20220211012542123"></p><p>RST标志位表示客户端异常断开,服务端无法接收ACK,所以客户端操作系统会发送一个RST标志,然后让服务端回到LISTEN状态,重新接收连接</p><p>2MSL在linux中是</p><p>TIME_WAIT状态是确保主动关闭端发送的最后一个ACK能顺利到达</p><p>**CLOSED：**表示初始状态。</p><p>**LISTEN：**该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</p><p>**SYN_SENT：**这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</p><p><strong>SYN_RCVD:</strong> 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</p><p>**ESTABLISHED：**表示连接已经建立。</p><p><strong>FIN_WAIT_1:</strong> FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：</p><p>FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。</p><p>FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。</p><p><strong>FIN_WAIT_2</strong>：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。</p><p><strong>TIME_WAIT:</strong> 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</p><p><strong>CLOSING:</strong> 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</p><p><strong>CLOSE_WAIT:</strong> 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</p><p><strong>LAST_ACK:</strong> 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</p><h3 id="2msl"><a class="markdownIt-Anchor" href="#2msl"></a> 2MSL</h3><p>2MSL (Maximum Segment Lifetime)</p><p>RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p><h4 id="程序设计中的问题"><a class="markdownIt-Anchor" href="#程序设计中的问题"></a> 程序设计中的问题</h4><p>做一个测试，首先启动server，然后启动client，用Ctrl-C终止server，马上再运行server，运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">itcast$ ./server</span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure><p>这是因为，虽然server的应用程序终止了，但TCP协议层的连接并没有完全断开，因此不能再次监听同样的server端口。我们用netstat命令查看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">itcast$ netstat -apn |grep 6666</span><br><span class="line">tcp        1      0 192.168.1.11:38103      192.168.1.11:6666       CLOSE_WAIT  3525/client     </span><br><span class="line">tcp        0      0 192.168.1.11:6666       192.168.1.11:38103      FIN_WAIT2   -</span><br></pre></td></tr></table></figure><p>server终止时，socket描述符会自动关闭并发FIN段给client，client收到FIN后处于CLOSE_WAIT状态，但是client并没有终止，也没有关闭socket描述符，因此不会发FIN给server，因此server的TCP连接处于FIN_WAIT2状态。</p><p>现在用Ctrl-C把client也终止掉，再观察现象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">itcast$ netstat -apn |grep 6666</span><br><span class="line">tcp        0      0 192.168.1.11:6666       192.168.1.11:38104      TIME_WAIT   -</span><br><span class="line">itcast$ ./server</span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure><p>client终止时自动关闭socket描述符，server的TCP连接收到client发的FIN段后处于TIME_WAIT状态。TCP协议规定，<strong>主动关闭连接的一方要处于TIME_WAIT状态</strong>，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态，因为我们先Ctrl-C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端口。</p><p>MSL在RFC 1122中规定为两分钟，但是各操作系统的实现不同，在Linux上一般经过半分钟后就可以再次启动server了。至于为什么要规定TIME_WAIT的时间，可参考UNP 2.7节。</p><h3 id="半关闭"><a class="markdownIt-Anchor" href="#半关闭"></a> 半关闭</h3><p>当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。</p><p>从程序的角度，可以使用API来控制实现半连接状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int shutdown(int sockfd, int how);</span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line">how:允许为shutdown操作选择以下几种方式:</span><br><span class="line">SHUT_RD(0)：关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span><br><span class="line">该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(1):关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</span><br><span class="line">SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span><br></pre></td></tr></table></figure><p>使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。</p><p><strong>shutdown不考虑描述符的引用计数，直接关闭描述符</strong>。也可选择中止一个方向的连接，只中止读或只中止写。</p><p>注意:</p><ol><li><p>如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。</p></li><li><p>在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但，如果一个进程close(sfd)将不会影响到其它进程。</p></li></ol><h4 id="端口复用"><a class="markdownIt-Anchor" href="#端口复用"></a> 端口复用</h4><p>在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:6666）没有完全断开，而我们重新监听的是lis-tenfd（0.0.0.0:6666），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。</p><p>在server代码的socket()和bind()调用之间插入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int opt = 1;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));</span><br></pre></td></tr></table></figure><p>有关setsockopt可以设置的其它选项请参考UNP第7章。</p><h2 id="多路io转接服务器"><a class="markdownIt-Anchor" href="#多路io转接服务器"></a> 多路I/O转接服务器</h2><p>多路IO转接服务器也叫做多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件。</p><p>主要使用的方法有三种</p><h3 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h3><ol><li><p>select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数</p></li><li><p>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力</p></li></ol><p><img src="/images/javawz/image-20220214185634906.png" alt="image-20220214185634906"></p><p><img src="/images/javawz/image-20220214190814350.png" alt="image-20220214190814350"></p><p>如果要修改文件描述符上限需要重新编译内核</p><p>如果有两个文件描述符,一个是1号文件描述符另一个是1023号文件描述符触发了读事件,则需要for循环遍历1023次才能找到对应的两个事件,解决办法是创建一个数组来保存文件描述符,防止多余的遍历</p><p>满足监听条件的集合和原有集合都是同一个集合,所有要提前保存好原有集合,防止数据被覆盖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line">/* According to earlier standards */</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">nfds: 监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态</span><br><span class="line">readfds：监控有读数据到达文件描述符集合，传入传出参数</span><br><span class="line">writefds：监控写数据到达文件描述符集合，传入传出参数</span><br><span class="line">exceptfds：监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</span><br><span class="line">timeout：定时阻塞监控时间，3种情况</span><br><span class="line">1.NULL，永远等下去</span><br><span class="line">2.设置timeval，等待固定时间</span><br><span class="line">3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span><br><span class="line">struct timeval &#123;</span><br><span class="line">long tv_sec; /* seconds */</span><br><span class="line">long tv_usec; /* microseconds */</span><br><span class="line">&#125;;</span><br><span class="line">void FD_CLR(int fd, fd_set *set); //把文件描述符集合里fd清0</span><br><span class="line">int FD_ISSET(int fd, fd_set *set); //测试文件描述符集合里fd是否置1</span><br><span class="line">void FD_SET(int fd, fd_set *set); //把文件描述符集合里fd位置1</span><br><span class="line">void FD_ZERO(fd_set *set); //把文件描述符集合里所有位清0</span><br></pre></td></tr></table></figure><h3 id="select实现"><a class="markdownIt-Anchor" href="#select实现"></a> select实现</h3><p><img src="/images/javawz/image-20220214203149162.png" alt="image-20220214203149162"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, n, maxi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nready, client[FD_SETSIZE];                 <span class="comment">/* 自定义数组client, 防止遍历1024个文件描述符  FD_SETSIZE默认为1024 */</span></span><br><span class="line">    <span class="keyword">int</span> maxfd, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ], str[INET_ADDRSTRLEN];         <span class="comment">/* #define INET_ADDRSTRLEN 16 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存放服务器和客户端的ip和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>, <span class="title">serv_addr</span>;</span></span><br><span class="line"><span class="comment">//客户端clie_addr的长度</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    fd_set rset, allset;                            <span class="comment">/* rset 读事件文件描述符集合 allset用来暂存 */</span></span><br><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置端口复用</span></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空serv_addr</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"><span class="comment">//设置服务器端口和ip</span></span><br><span class="line">    serv_addr.sin_family= AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port= htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定端口和ip</span></span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"><span class="comment">//设置监听</span></span><br><span class="line">    Listen(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    maxfd = listenfd;                                           <span class="comment">/* 起初 listenfd 即为最大文件描述符 */</span></span><br><span class="line"></span><br><span class="line">    maxi = <span class="number">-1</span>;                                                  <span class="comment">/* 将来用作client[]的下标, 初始值指向0个元素之前下标位置 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        client[i] = <span class="number">-1</span>;                                         <span class="comment">/* 用-1初始化client[] */</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;allset);</span><br><span class="line">    FD_SET(listenfd, &amp;allset);                                  <span class="comment">/* 构造select监控文件描述符集 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;   </span><br><span class="line">        rset = allset;                                          <span class="comment">/* 每次循环时都从新设置select监控信号集 */</span></span><br><span class="line">        nready = select(maxfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready &lt; <span class="number">0</span>)</span><br><span class="line">            perr_exit(<span class="string">"select error"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123;                        <span class="comment">/* 说明有新的客户端链接请求 */</span></span><br><span class="line"></span><br><span class="line">            clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">            connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);       <span class="comment">/* Accept 不会阻塞 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">                    inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                    ntohs(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">                <span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) &#123;                            <span class="comment">/* 找client[]中没有使用的位置 */</span></span><br><span class="line">                    client[i] = connfd;                         <span class="comment">/* 保存accept返回的文件描述符到client[]里 */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == FD_SETSIZE) &#123;                              <span class="comment">/* 达到select能监控的文件个数上限 1024 */</span></span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">"too many clients\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FD_SET(connfd, &amp;allset);                            <span class="comment">/* 向监控文件描述符集合allset添加新的文件描述符connfd */</span></span><br><span class="line"><span class="comment">//如果connfn大于maxfd则交换</span></span><br><span class="line">            <span class="keyword">if</span> (connfd &gt; maxfd)</span><br><span class="line">                maxfd = connfd;                                 <span class="comment">/* select第一个参数需要 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">                maxi = i;                                       <span class="comment">/* 保证maxi存的总是client[]最后一个元素下标 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) &#123;                               <span class="comment">/* 检测哪个clients 有数据就绪 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((n = Read(sockfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>) &#123;    <span class="comment">/* 当client关闭链接时,服务器端也关闭对应链接 */</span></span><br><span class="line">                    Close(sockfd);</span><br><span class="line">                    FD_CLR(sockfd, &amp;allset);                        <span class="comment">/* 解除select对此文件描述符的监控 */</span></span><br><span class="line">                    client[i] = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                    Write(sockfd, buf, n);</span><br><span class="line">                    Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;                                          <span class="comment">/* 跳出for, 但还在while中 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220214204935192.png" alt="image-20220214204935192"></p><h3 id="poll"><a class="markdownIt-Anchor" href="#poll"></a> poll</h3><p><img src="/images/javawz/image-20220215183748654.png" alt="image-20220215183748654"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line">struct pollfd &#123;</span><br><span class="line">int fd; /* 文件描述符 */</span><br><span class="line">short events; /* 监控的事件 */</span><br><span class="line">short revents; /* 监控事件中满足条件返回的事件 */</span><br><span class="line">&#125;;</span><br><span class="line">POLLIN普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND</span><br><span class="line">POLLRDNORM数据可读</span><br><span class="line">POLLRDBAND优先级带数据可读</span><br><span class="line">POLLPRI 高优先级可读数据</span><br><span class="line">POLLOUT普通或带外数据可写</span><br><span class="line">POLLWRNORM数据可写</span><br><span class="line">POLLWRBAND优先级带数据可写</span><br><span class="line">POLLERR 发生错误</span><br><span class="line">POLLHUP 发生挂起</span><br><span class="line">POLLNVAL 描述字不是一个打开的文件</span><br><span class="line"></span><br><span class="line">nfds 监控数组中有多少文件描述符需要被监控</span><br><span class="line"></span><br><span class="line">timeout 毫秒级等待</span><br><span class="line">-1：阻塞等，#define INFTIM -1 Linux中没有定义此宏</span><br><span class="line">0：立即返回，不阻塞进程</span><br><span class="line">&gt;0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值</span><br></pre></td></tr></table></figure><p>如果不再监控某个文件描述符时，可以把pollfd中，fd设置为-1，poll不再监控此pollfd，下次返回时，把revents设置为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, maxi, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">int</span> nready;                                 <span class="comment">/*接收poll返回值, 记录满足监听事件的fd个数*/</span></span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    Listen(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;                    <span class="comment">/* 要监听的第一个文件描述符 存入client[0]*/</span></span><br><span class="line">    client[<span class="number">0</span>].events = POLLIN;                  <span class="comment">/* listenfd监听普通读事件 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">        client[i].fd = <span class="number">-1</span>;                      <span class="comment">/* 用-1初始化client[]里剩下元素 0也是文件描述符,不能用 */</span></span><br><span class="line"></span><br><span class="line">    maxi = <span class="number">0</span>;                                   <span class="comment">/* client[]数组有效元素中最大元素下标 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        nready = poll(client, maxi+<span class="number">1</span>, <span class="number">-1</span>);      <span class="comment">/* 阻塞监听是否有客户端链接请求 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLIN) &#123;       <span class="comment">/* listenfd有读事件就绪 */</span></span><br><span class="line"></span><br><span class="line">            clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);<span class="comment">/* 接收客户端请求 Accept 不会阻塞 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">                    inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                    ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">                <span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    client[i].fd = connfd;      <span class="comment">/* 找到client[]中空闲的位置,存放accept返回的connfd */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == OPEN_MAX)                  <span class="comment">/* 达到了最大客户端数 */</span></span><br><span class="line">                perr_exit(<span class="string">"too many clients"</span>);</span><br><span class="line"></span><br><span class="line">            client[i].events = POLLIN;          <span class="comment">/* 设置刚刚返回的connfd,监控读事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">                maxi = i;                       <span class="comment">/* 更新client[]中最大元素下标 */</span></span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;                       <span class="comment">/* 没有更多就绪事件时,继续回到poll阻塞 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= maxi; i++) &#123;           <span class="comment">/* 前面的if没满足,说明没有listenfd满足. 检测client[] 看是那个connfd就绪 */</span></span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (client[i].revents &amp; POLLIN) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* connection reset by client */</span></span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) &#123;  <span class="comment">/* 收到RST标志 */</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"client[%d] aborted connection\n"</span>, i);</span><br><span class="line">                        Close(sockfd);</span><br><span class="line">                        client[i].fd = <span class="number">-1</span>;      <span class="comment">/* poll中不监控该文件描述符,直接置为-1即可,不用像select中那样移除 */</span></span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        perr_exit(<span class="string">"read error"</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;            <span class="comment">/* 说明客户端先关闭链接 */</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, i);</span><br><span class="line">                    Close(sockfd);</span><br><span class="line">                    client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                    Writen(sockfd, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h3><p>epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p><p>目前epell是linux大规模并发网络程序中的热门首选模型。</p><p>epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</p><p>可以使用cat命令查看一个进程可以打开的socket描述符上限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure><p>如有需要，可以通过修改配置文件的方式修改该上限值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/security/limits.conf</span><br><span class="line">在文件尾部写入以下配置,soft软限制，hard硬限制。如下图所示。</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 100000</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220215203019930.png" alt="image-20220215203019930"></p><h4 id="基础api"><a class="markdownIt-Anchor" href="#基础api"></a> 基础API</h4><ol><li>创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_create(int size)size：监听数目</span><br></pre></td></tr></table></figure><ol start="2"><li>控制某个epoll监控的文件描述符上的事件：注册、修改、删除。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</span><br><span class="line">epfd：为epoll_creat的句柄</span><br><span class="line">op：表示动作，用3个宏来表示：</span><br><span class="line">EPOLL_CTL_ADD (注册新的fd到epfd)，</span><br><span class="line">EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</span><br><span class="line">EPOLL_CTL_DEL (从epfd删除一个fd)；</span><br><span class="line">event：告诉内核需要监听的事件</span><br><span class="line"></span><br><span class="line">struct epoll_event &#123;</span><br><span class="line">__uint32_t events; /* Epoll events */</span><br><span class="line">epoll_data_t data; /* User data variable */</span><br><span class="line">&#125;;</span><br><span class="line">typedef union epoll_data &#123;</span><br><span class="line">void *ptr;</span><br><span class="line">int fd;</span><br><span class="line">uint32_t u32;</span><br><span class="line">uint64_t u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure><ol start="3"><li>等待所监控文件描述符上有事件的产生，类似于select()调用。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</span><br><span class="line">events：用来存内核得到事件的集合，</span><br><span class="line">maxevents：告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</span><br><span class="line">timeout：是超时时间</span><br><span class="line">-1：阻塞</span><br><span class="line">0：立即返回，非阻塞</span><br><span class="line">&gt;0：指定毫秒</span><br><span class="line">返回值：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220215203335277.png" alt="image-20220215203335277"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 5000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">int</span>  n, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nready, efd, res;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tep</span>, <span class="title">ep</span>[<span class="title">OPEN_MAX</span>];</span>       <span class="comment">//tep: epoll_ctl参数  ep[] : epoll_wait参数</span></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));      <span class="comment">//端口复用</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    efd = epoll_create(OPEN_MAX);               <span class="comment">//创建epoll模型, efd指向红黑树根节点</span></span><br><span class="line">    <span class="keyword">if</span> (efd == <span class="number">-1</span>)</span><br><span class="line">        perr_exit(<span class="string">"epoll_create error"</span>);</span><br><span class="line"></span><br><span class="line">    tep.events = EPOLLIN; tep.data.fd = listenfd;           <span class="comment">//指定lfd的监听时间为"读"</span></span><br><span class="line">    res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep);    <span class="comment">//将lfd及对应的结构体设置到树上,efd可找到该树</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">        perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        <span class="comment">/*epoll为server阻塞监听事件, ep为struct epoll_event类型数组, OPEN_MAX为数组容量, -1表永久阻塞*/</span></span><br><span class="line">        nready = epoll_wait(efd, ep, OPEN_MAX, <span class="number">-1</span>); </span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            perr_exit(<span class="string">"epoll_wait error"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nready; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(ep[i].events &amp; EPOLLIN))      <span class="comment">//如果不是"读"事件, 继续循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ep[i].data.fd == listenfd) &#123;    <span class="comment">//判断满足事件的fd是不是lfd            </span></span><br><span class="line">                clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);    <span class="comment">//接受链接</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>, </span><br><span class="line">                        inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)), </span><br><span class="line">                        ntohs(cliaddr.sin_port));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"cfd %d---client %d\n"</span>, connfd, ++num);</span><br><span class="line"></span><br><span class="line">                tep.events = EPOLLIN; tep.data.fd = connfd;</span><br><span class="line">                res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep);</span><br><span class="line">                <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">                    perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                <span class="comment">//不是lfd, </span></span><br><span class="line">                sockfd = ep[i].data.fd;</span><br><span class="line">                n = Read(sockfd, buf, MAXLINE);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;                       <span class="comment">//读到0,说明客户端关闭链接</span></span><br><span class="line">                    res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);  <span class="comment">//将该文件描述符从红黑树摘除</span></span><br><span class="line">                    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">                        perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line">                    Close(sockfd);                  <span class="comment">//关闭与该客户端的链接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, sockfd);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;                 <span class="comment">//出错</span></span><br><span class="line">                    perror(<span class="string">"read n &lt; 0 error: "</span>);</span><br><span class="line">                    res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line">                    Close(sockfd);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                            <span class="comment">//实际读到了字节数</span></span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);   <span class="comment">//转大写,写回给客户端</span></span><br><span class="line"></span><br><span class="line">                    Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                    Writen(sockfd, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Close(listenfd);</span><br><span class="line">    Close(efd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件模型"><a class="markdownIt-Anchor" href="#事件模型"></a> 事件模型</h3><p>EPOLL事件有两种模型：</p><p>Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。</p><p>Level Triggered (LT) 水平触发只要有数据都会触发。</p><p>思考如下步骤：</p><ol><li><p>假定我们已经把一个用来从管道中读取数据的文件描述符(RFD)添加到epoll描述符。</p></li><li><p>管道的另一端写入了2KB的数据</p></li><li><p>调用epoll_wait，并且它会返回RFD，说明它已经准备好读取操作</p></li><li><p>读取1KB的数据</p></li><li><p>调用epoll_wait……</p></li></ol><p>在这个过程中，有两种工作模式：</p><h4 id="et模式"><a class="markdownIt-Anchor" href="#et模式"></a> ET模式</h4><p>ET模式即Edge Triggered工作模式。</p><p>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。</p><ol><li><p>基于非阻塞文件句柄</p></li><li><p>只有当read或者write返回EAGAIN(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次read时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。</p></li></ol><h4 id="lt模式"><a class="markdownIt-Anchor" href="#lt模式"></a> LT模式</h4><p>LT模式即Level Triggered工作模式。</p><p>与ET模式不同的是，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll，无论后面的数据是否被使用。</p><p>LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。</p><p>ET(edge-triggered)：ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once).</p><p>基于管道epoll ET触发模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> efd, i;</span><br><span class="line">    <span class="keyword">int</span> pfd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], ch = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">    pipe(pfd);</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;             <span class="comment">//子 写</span></span><br><span class="line">        close(pfd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//aaaa\n</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXLINE/<span class="number">2</span>; i++)</span><br><span class="line">                buf[i] = ch;</span><br><span class="line">            buf[i<span class="number">-1</span>] = <span class="string">'\n'</span>;</span><br><span class="line">            ch++;</span><br><span class="line">            <span class="comment">//bbbb\n</span></span><br><span class="line">            <span class="keyword">for</span> (; i &lt; MAXLINE; i++)</span><br><span class="line">                buf[i] = ch;</span><br><span class="line">            buf[i<span class="number">-1</span>] = <span class="string">'\n'</span>;</span><br><span class="line">            ch++;</span><br><span class="line">            <span class="comment">//aaaa\nbbbb\n</span></span><br><span class="line">            write(pfd[<span class="number">1</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pfd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;       <span class="comment">//父 读</span></span><br><span class="line">        struct epoll_event event;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>[10];</span>        <span class="comment">//epoll_wait就绪返回event</span></span><br><span class="line">        <span class="keyword">int</span> res, len;</span><br><span class="line"></span><br><span class="line">        close(pfd[<span class="number">1</span>]);</span><br><span class="line">        efd = epoll_create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        event.events = EPOLLIN | EPOLLET;     <span class="comment">// ET 边沿触发</span></span><br><span class="line">        <span class="comment">//event.events = EPOLLIN;                 // LT 水平触发 (默认)</span></span><br><span class="line">        event.data.fd = pfd[<span class="number">0</span>];</span><br><span class="line">        epoll_ctl(efd, EPOLL_CTL_ADD, pfd[<span class="number">0</span>], &amp;event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            res = epoll_wait(efd, resevent, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"res %d\n"</span>, res);</span><br><span class="line">            <span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == pfd[<span class="number">0</span>]) &#123;</span><br><span class="line">                len = read(pfd[<span class="number">0</span>], buf, MAXLINE/<span class="number">2</span>);</span><br><span class="line">                write(STDOUT_FILENO, buf, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(pfd[<span class="number">0</span>]);</span><br><span class="line">        close(efd);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll阻塞io"><a class="markdownIt-Anchor" href="#epoll阻塞io"></a> epoll阻塞IO</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> efd;</span><br><span class="line"></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>[10];</span></span><br><span class="line">    <span class="keyword">int</span> res, len;</span><br><span class="line"></span><br><span class="line">    efd = epoll_create(<span class="number">10</span>);</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;     <span class="comment">/* ET 边沿触发 */</span></span><br><span class="line">    <span class="comment">//event.events = EPOLLIN;                 /* 默认 LT 水平触发 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line"></span><br><span class="line">    cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    event.data.fd = connfd;</span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        res = epoll_wait(efd, resevent, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"res %d\n"</span>, res);</span><br><span class="line">        <span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == connfd) &#123;</span><br><span class="line">            len = read(connfd, buf, MAXLINE/<span class="number">2</span>);         <span class="comment">//readn(500)   </span></span><br><span class="line">            write(STDOUT_FILENO, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll非阻塞io"><a class="markdownIt-Anchor" href="#epoll非阻塞io"></a> epoll非阻塞IO</h3><p>假设我们在程序中规定数据包前50个字节是对这个数据包的总述，因此我们一次读50个字节然后判断是否要完全读取这个数据包，这时候就要用到边沿性触发机制。</p><p>如果客户端只发送200Byte数据，而服务器端一次读400Byte，这时read函数是阻塞等待剩下的200Byte的，所以要设置非阻塞fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> efd, flag;</span><br><span class="line"></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>[10];</span></span><br><span class="line">    <span class="keyword">int</span> res, len;</span><br><span class="line"></span><br><span class="line">    efd = epoll_create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN | EPOLLET;     <span class="comment">/* ET 边沿触发，默认是水平触发 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//event.events = EPOLLIN;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line">    cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    flag = fcntl(connfd, F_GETFL);          <span class="comment">/* 修改connfd为非阻塞读 */</span></span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    fcntl(connfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">    event.data.fd = connfd;</span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);      <span class="comment">//将connfd加入监听红黑树</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"epoll_wait begin\n"</span>);</span><br><span class="line">        res = epoll_wait(efd, resevent, <span class="number">10</span>, <span class="number">-1</span>);        <span class="comment">//最多10个, 阻塞监听</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"epoll_wait end res %d\n"</span>, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == connfd) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((len = read(connfd, buf, MAXLINE/<span class="number">2</span>)) &gt;<span class="number">0</span> )    <span class="comment">//非阻塞读, 轮询</span></span><br><span class="line">                write(STDOUT_FILENO, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll反应堆模型"><a class="markdownIt-Anchor" href="#epoll反应堆模型"></a> epoll反应堆模型</h3><p>libevent     跨平台</p><p>epoll — 服务器 — 监听 — cfd ---- 可读 ---- epoll返回 ---- read – cfd从树上摘下 — 设置监听cfd写事件， 操作</p><p>— 小写转大写 – 等待epoll_wait 返回 — 回写客户端 – cfd从树上摘下 ----- 设置监听cfd读事件， 操作 – epoll继续监听。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evt[i].events = EPOLLIN, evt[I].data.fd == cfd       *ptr     struct &#123;int fd, void (*func)(void *arg), void *arv&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__func__ //获取当前函数名</span><br><span class="line">__FILE__//获取当前文件名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s\n%s\n&quot;, __func__, __FILE__);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220218003454575.png" alt="image-20220218003454575"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *epoll基于非阻塞I/O事件驱动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS  1024                                    <span class="comment">//监听上限数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT   8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">senddata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述就绪文件描述符相关信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;                                                 <span class="comment">//要监听的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> events;                                             <span class="comment">//对应的监听事件</span></span><br><span class="line">    <span class="keyword">void</span> *arg;                                              <span class="comment">//泛型参数</span></span><br><span class="line">    <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg);       <span class="comment">//回调函数</span></span><br><span class="line">    <span class="keyword">int</span> status;                                             <span class="comment">//是否在监听:1-&gt;在红黑树上(监听), 0-&gt;不在(不监听)</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFLEN];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">long</span> last_active;                                       <span class="comment">//记录每次加入红黑树 g_efd 的时间值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_efd;                                                  <span class="comment">//全局变量, 保存epoll_create返回的文件描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> <span class="title">g_events</span>[<span class="title">MAX_EVENTS</span>+1];</span>                    <span class="comment">//自定义结构体类型数组. +1--&gt;listen fd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将结构体 myevent_s 成员变量 初始化*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventset</span><span class="params">(struct myevent_s *ev, <span class="keyword">int</span> fd, <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;call_back = call_back;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// memset(ev-&gt;buf, 0, sizeof(ev-&gt;buf));</span></span><br><span class="line">    <span class="comment">//ev-&gt;len = 0;</span></span><br><span class="line">    ev-&gt;last_active = time(<span class="literal">NULL</span>);                       <span class="comment">//调用eventset函数的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 epoll监听的红黑树 添加一个 文件描述符 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventadd</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">int</span> events, struct myevent_s *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> = &#123;</span><span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    epv.events = ev-&gt;events = events;       <span class="comment">//EPOLLIN 或 EPOLLOUT</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;status == <span class="number">1</span>) &#123;                                          <span class="comment">//已经在红黑树 g_efd 里</span></span><br><span class="line">        op = EPOLL_CTL_MOD;                                         <span class="comment">//修改其属性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                <span class="comment">//不在红黑树里</span></span><br><span class="line">        op = EPOLL_CTL_ADD;                 <span class="comment">//将其加入红黑树 g_efd, 并将status置1</span></span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(efd, op, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)                       <span class="comment">//实际添加/修改</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"event add failed [fd=%d], events[%d]\n"</span>, ev-&gt;fd, events);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"event add OK [fd=%d], op=%d, events[%0X]\n"</span>, ev-&gt;fd, op, events);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从epoll 监听的 红黑树中删除一个 文件描述符*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventdel</span><span class="params">(<span class="keyword">int</span> efd, struct myevent_s *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> = &#123;</span><span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;status != <span class="number">1</span>)                                        <span class="comment">//不在红黑树上</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;                                             <span class="comment">//修改状态</span></span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv);                <span class="comment">//从红黑树 efd 上将 ev-&gt;fd 摘除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  当有文件描述符就绪, epoll返回, 调用该函数 与客户端建立链接 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptconn</span><span class="params">(<span class="keyword">int</span> lfd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cin</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="built_in">cin</span>);</span><br><span class="line">    <span class="keyword">int</span> cfd, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cfd = accept(lfd, (struct sockaddr *)&amp;<span class="built_in">cin</span>, &amp;len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EINTR) &#123;</span><br><span class="line">            <span class="comment">/* 暂时不做出错处理 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s: accept, %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_EVENTS; i++)                                <span class="comment">//从全局数组g_events中找一个空闲元素</span></span><br><span class="line">            <span class="keyword">if</span> (g_events[i].status == <span class="number">0</span>)                                <span class="comment">//类似于select中找值为-1的元素</span></span><br><span class="line">                <span class="keyword">break</span>;                                                  <span class="comment">//跳出 for</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == MAX_EVENTS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: max connect limit[%d]\n"</span>, __func__, MAX_EVENTS);</span><br><span class="line">            <span class="keyword">break</span>;                                                      <span class="comment">//跳出do while(0) 不执行后续代码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>) &#123;             <span class="comment">//将cfd也设置为非阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: fcntl nonblocking failed, %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 给cfd设置一个 myevent_s 结构体, 回调函数 设置为 recvdata */</span></span><br><span class="line"></span><br><span class="line">        eventset(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);   </span><br><span class="line">        eventadd(g_efd, EPOLLIN, &amp;g_events[i]);                         <span class="comment">//将cfd添加到红黑树g_efd中,监听读事件</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"new connect [%s:%d][time:%ld], pos[%d]\n"</span>, </span><br><span class="line">            inet_ntoa(<span class="built_in">cin</span>.sin_addr), ntohs(<span class="built_in">cin</span>.sin_port), g_events[i].last_active, i);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = recv(fd, ev-&gt;buf, <span class="keyword">sizeof</span>(ev-&gt;buf), <span class="number">0</span>);            <span class="comment">//读文件描述符, 数据存入myevent_s成员buf中</span></span><br><span class="line"></span><br><span class="line">    eventdel(g_efd, ev);        <span class="comment">//将该节点从红黑树上摘除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        ev-&gt;len = len;</span><br><span class="line">        ev-&gt;buf[len] = <span class="string">'\0'</span>;                                <span class="comment">//手动添加字符串结束标记</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"C[%d]:%s\n"</span>, fd, ev-&gt;buf);</span><br><span class="line"></span><br><span class="line">        eventset(ev, fd, senddata, ev);                     <span class="comment">//设置该 fd 对应的回调函数为 senddata</span></span><br><span class="line">        eventadd(g_efd, EPOLLOUT, ev);                      <span class="comment">//将fd加入红黑树g_efd中,监听其写事件</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        close(ev-&gt;fd);</span><br><span class="line">        <span class="comment">/* ev-g_events 地址相减得到偏移元素位置 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[fd=%d] pos[%ld], closed\n"</span>, fd, ev-g_events);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(ev-&gt;fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"recv[fd=%d] error[%d]:%s\n"</span>, fd, errno, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">senddata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = send(fd, ev-&gt;buf, ev-&gt;len, <span class="number">0</span>);                    <span class="comment">//直接将数据 回写给客户端。未作处理</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    printf("fd=%d\tev-&gt;buf=%s\ttev-&gt;len=%d\n", fd, ev-&gt;buf, ev-&gt;len);</span></span><br><span class="line"><span class="comment">    printf("send len = %d\n", len);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"send[fd=%d], [%d]%s\n"</span>, fd, len, ev-&gt;buf);</span><br><span class="line">        eventdel(g_efd, ev);                                <span class="comment">//从红黑树g_efd中移除</span></span><br><span class="line">        eventset(ev, fd, recvdata, ev);                     <span class="comment">//将该fd的 回调函数改为 recvdata</span></span><br><span class="line">        eventadd(g_efd, EPOLLIN, ev);                       <span class="comment">//从新添加到红黑树上， 设为监听读事件</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(ev-&gt;fd);                                      <span class="comment">//关闭链接</span></span><br><span class="line">        eventdel(g_efd, ev);                                <span class="comment">//从红黑树g_efd中移除</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"send[fd=%d] error %s\n"</span>, fd, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建 socket, 初始化lfd */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initlistensocket</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    fcntl(lfd, F_SETFL, O_NONBLOCK);                                            <span class="comment">//将socket设为非阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg);  */</span></span><br><span class="line">    eventset(&amp;g_events[MAX_EVENTS], lfd, acceptconn, &amp;g_events[MAX_EVENTS]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* void eventadd(int efd, int events, struct myevent_s *ev) */</span></span><br><span class="line">    eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                                               <span class="comment">//bzero(&amp;sin, sizeof(sin))</span></span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">bind(lfd, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"></span><br><span class="line">listen(lfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port = SERV_PORT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        port = atoi(argv[<span class="number">1</span>]);                           <span class="comment">//使用用户指定端口.如未指定,用默认端口</span></span><br><span class="line"></span><br><span class="line">    g_efd = epoll_create(MAX_EVENTS+<span class="number">1</span>);                 <span class="comment">//创建红黑树,返回给全局 g_efd </span></span><br><span class="line">    <span class="keyword">if</span> (g_efd &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create efd in %s err %s\n"</span>, __func__, strerror(errno));</span><br><span class="line"></span><br><span class="line">    initlistensocket(g_efd, port);                      <span class="comment">//初始化监听socket</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>+1];</span>            <span class="comment">//保存已经满足就绪事件的文件描述符数组 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"server running:port[%d]\n"</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> checkpos = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 超时验证，每次测试100个链接，不测试listenfd 当客户端60秒内没有和服务器通信，则关闭此客户端链接 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> now = time(<span class="literal">NULL</span>);                          <span class="comment">//当前时间</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++, checkpos++) &#123;         <span class="comment">//一次循环检测100个。 使用checkpos控制检测对象</span></span><br><span class="line">            <span class="keyword">if</span> (checkpos == MAX_EVENTS)</span><br><span class="line">                checkpos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (g_events[checkpos].status != <span class="number">1</span>)         <span class="comment">//不在红黑树 g_efd 上</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> duration = now - g_events[checkpos].last_active;       <span class="comment">//客户端不活跃的世间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (duration &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                close(g_events[checkpos].fd);                           <span class="comment">//关闭与该客户端链接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"[fd=%d] timeout\n"</span>, g_events[checkpos].fd);</span><br><span class="line">                eventdel(g_efd, &amp;g_events[checkpos]);                   <span class="comment">//将该客户端 从红黑树 g_efd移除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*监听红黑树g_efd, 将满足的事件的文件描述符加至events数组中, 1秒没有事件满足, 返回 0*/</span></span><br><span class="line">        <span class="keyword">int</span> nfd = epoll_wait(g_efd, events, MAX_EVENTS+<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"epoll_wait error, exit\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfd; i++) &#123;</span><br><span class="line">            <span class="comment">/*使用自定义结构体myevent_s类型指针, 接收 联合体data的void *ptr成员*/</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">events</span>[<span class="title">i</span>].<span class="title">data</span>.<span class="title">ptr</span>;</span>  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123;           <span class="comment">//读就绪事件</span></span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123;         <span class="comment">//写就绪事件</span></span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 退出前释放所有资源 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="心跳包和乒乓包"><a class="markdownIt-Anchor" href="#心跳包和乒乓包"></a> 心跳包和乒乓包</h3><p>心跳包:</p><p>​在应用层自定义一个协议。例如服务器每隔一段时间发送一个123的数据包，客户端收到后会回一个456的数据包，当服务器收到客户端发送来的456之后就认为客户端还保持连接，如果服务器发送了123之后没有得到客户端的回应，则每隔3秒持续发送123给客户端，持续发送3次之后还没有得到回应，则认为客户端掉线了，服务端则close(cfd)且让客户端重新连接</p><p><img src="/images/javawz/image-20220218181416978.png" alt="image-20220218181416978"></p><p>乒乓包：</p><p>​在判别网络通不通的同时还可以携带一些数据。例如：朋友圈的小圆点，客户端每隔一段时间询问有没有动态更新，服务器马上回应有或没有，如果有则回复有，客户端收到后会让小圆点变红</p><p><img src="/images/javawz/image-20220218182244501.png" alt="image-20220218182244501"></p><h3 id="设置tcp属性"><a class="markdownIt-Anchor" href="#设置tcp属性"></a> 设置TCP属性</h3><p>SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“host unreachable(主机不可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为EHOSTUNREACH。</p><p>根据上面的介绍我们可以知道对端以一种非优雅的方式断开连接的时候，我们可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keepAlive = 1;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive));</span><br></pre></td></tr></table></figure><p>如果我们不能接受如此之长的等待时间，从TCP-Keepalive-HOWTO上可以知道一共有两种方式可以设置，一种是修改内核关于网络方面的 配置参数，另外一种就是SOL_TCP字段的TCP_KEEPIDLE， TCP_KEEPINTVL， TCP_KEEPCNT三个选项。</p><ol><li>The tcp_keepidle parameter specifies the interval of inactivity that causes TCP to generate a KEEPALIVE transmission for an application that requests them. tcp_keepidle defaults to 14400 (two hours).</li></ol><p>/*开始首次KeepAlive探测前的TCP空闭时间 */</p><ol start="2"><li>The tcp_keepintvl parameter specifies the interval between the nine retriesthat are attempted if a KEEPALIVE transmission is not acknowledged. tcp_keep ntvldefaults to 150 (75 seconds).</li></ol><p>/* 两次KeepAlive探测间的时间间隔 */</p><ol start="3"><li>The tcp_keepcnt option specifies the maximum number of keepalive probes tobe sent. The value of TCP_KEEPCNT is an integer value between 1 and n, where n s the value of the systemwide tcp_keepcnt parameter.</li></ol><p>/* 判定断开前的KeepAlive探测次数*/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int keepIdle = 1000;</span><br><span class="line">int keepInterval = 10;</span><br><span class="line">int keepCount = 10;</span><br><span class="line"></span><br><span class="line">Setsockopt(listenfd, SOL_TCP, TCP_KEEPIDLE, (void *)&amp;keepIdle, sizeof(keepIdle));</span><br><span class="line">Setsockopt(listenfd, SOL_TCP,TCP_KEEPINTVL, (void *)&amp;keepInterval, sizeof(keepInterval));</span><br><span class="line">Setsockopt(listenfd,SOL_TCP, TCP_KEEPCNT, (void *)&amp;keepCount, sizeof(keepCount));</span><br></pre></td></tr></table></figure><p>SO_KEEPALIVE设置空闲2小时才发送一个“保持存活探测分节”，不能保证实时检测。对于判断网络断开时间太长，对于需要及时响应的程序不太适应。</p><p>当然也可以修改时间间隔参数，但是会影响到所有打开此选项的套接口！关联了完成端口的socket可能会忽略掉该套接字选项。</p><h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3><p><img src="/images/javawz/image-20220220022756899.png" alt="image-20220220022756899"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __THREADPOOL_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __THREADPOOL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">threadpool_t</span> <span class="title">threadpool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function threadpool_create</span></span><br><span class="line"><span class="comment"> * @descCreates a threadpool_t object.</span></span><br><span class="line"><span class="comment"> * @param thr_num  thread num</span></span><br><span class="line"><span class="comment"> * @param max_thr_num  max thread size</span></span><br><span class="line"><span class="comment"> * @param queue_max_size   size of the queue.</span></span><br><span class="line"><span class="comment"> * @return a newly created thread pool or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">threadpool_t</span> *threadpool_create(<span class="keyword">int</span> min_thr_num, <span class="keyword">int</span> max_thr_num, <span class="keyword">int</span> queue_max_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function threadpool_add</span></span><br><span class="line"><span class="comment"> * @desc add a new task in the queue of a thread pool</span></span><br><span class="line"><span class="comment"> * @param pool     Thread pool to which add the task.</span></span><br><span class="line"><span class="comment"> * @param function Pointer to the function that will perform the task.</span></span><br><span class="line"><span class="comment"> * @param argument Argument to be passed to the function.</span></span><br><span class="line"><span class="comment"> * @return 0 if all goes well,else -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_add</span><span class="params">(<span class="keyword">threadpool_t</span> *pool, <span class="keyword">void</span>*(*function)(<span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function threadpool_destroy</span></span><br><span class="line"><span class="comment"> * @desc Stops and destroys a thread pool.</span></span><br><span class="line"><span class="comment"> * @param pool  Thread pool to destroy.</span></span><br><span class="line"><span class="comment"> * @return 0 if destory success else -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_destroy</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc get the thread num</span></span><br><span class="line"><span class="comment"> * @pool pool threadpool</span></span><br><span class="line"><span class="comment"> * @return # of the thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_all_threadnum</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * desc get the busy thread num</span></span><br><span class="line"><span class="comment"> * @param pool threadpool</span></span><br><span class="line"><span class="comment"> * return # of the busy thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_busy_threadnum</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"threadpool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_TIME 10                 <span class="comment">/*10s检测一次*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_WAIT_TASK_NUM 10            <span class="comment">/*如果queue_size &gt; MIN_WAIT_TASK_NUM 添加新的线程到线程池*/</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_THREAD_VARY 10          <span class="comment">/*每次创建和销毁线程的个数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *(*function)(<span class="keyword">void</span> *);          <span class="comment">/* 函数指针，回调函数 */</span></span><br><span class="line">    <span class="keyword">void</span> *arg;                          <span class="comment">/* 上面函数的参数 */</span></span><br><span class="line">&#125; <span class="keyword">threadpool_task_t</span>;                    <span class="comment">/* 各子线程任务结构体 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述线程池相关信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadpool_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;               <span class="comment">/* 用于锁住本结构体 */</span>    </span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> thread_counter;     <span class="comment">/* 记录忙状态线程个数de琐 -- busy_thr_num */</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> queue_not_full;      <span class="comment">/* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> queue_not_empty;     <span class="comment">/* 任务队列里不为空时，通知等待任务的线程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> *threads;                 <span class="comment">/* 存放线程池中每个线程的tid。数组 */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> adjust_tid;               <span class="comment">/* 存管理线程tid */</span></span><br><span class="line">    <span class="keyword">threadpool_task_t</span> *task_queue;      <span class="comment">/* 任务队列 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min_thr_num;                    <span class="comment">/* 线程池最小线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> max_thr_num;                    <span class="comment">/* 线程池最大线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> live_thr_num;                   <span class="comment">/* 当前存活线程个数 */</span></span><br><span class="line">    <span class="keyword">int</span> busy_thr_num;                   <span class="comment">/* 忙状态线程个数 */</span></span><br><span class="line">    <span class="keyword">int</span> wait_exit_thr_num;              <span class="comment">/* 要销毁的线程个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> queue_front;                    <span class="comment">/* task_queue队头下标 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_rear;                     <span class="comment">/* task_queue队尾下标 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_size;                     <span class="comment">/* task_queue队中实际任务数 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_max_size;                 <span class="comment">/* task_queue队列可容纳任务数上限 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shutdown;                       <span class="comment">/* 标志位，线程池使用状态，true或false */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function void *threadpool_thread(void *threadpool)</span></span><br><span class="line"><span class="comment"> * @desc the worker thread</span></span><br><span class="line"><span class="comment"> * @param threadpool the pool which own the thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadpool_thread</span><span class="params">(<span class="keyword">void</span> *threadpool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function void *adjust_thread(void *threadpool);</span></span><br><span class="line"><span class="comment"> * @desc manager thread</span></span><br><span class="line"><span class="comment"> * @param threadpool the threadpool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">adjust_thread</span><span class="params">(<span class="keyword">void</span> *threadpool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * check a thread is alive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_thread_alive</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_free</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">threadpool_t</span> *threadpool_create(<span class="keyword">int</span> min_thr_num, <span class="keyword">int</span> max_thr_num, <span class="keyword">int</span> queue_max_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">threadpool_t</span> *pool = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((pool = (<span class="keyword">threadpool_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">threadpool_t</span>))) == <span class="literal">NULL</span>) </span><br><span class="line">&#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"malloc threadpool fail"</span>);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">/*跳出do while*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;min_thr_num = min_thr_num;</span><br><span class="line">        pool-&gt;max_thr_num = max_thr_num;</span><br><span class="line">        pool-&gt;busy_thr_num = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;live_thr_num = min_thr_num;               <span class="comment">/* 活着的线程数 初值=最小线程数 */</span></span><br><span class="line">        pool-&gt;queue_size = <span class="number">0</span>;                           <span class="comment">/* 有0个产品 */</span></span><br><span class="line">        pool-&gt;queue_max_size = queue_max_size;</span><br><span class="line">        pool-&gt;queue_front = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queue_rear = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;shutdown = <span class="literal">false</span>;                         <span class="comment">/* 不关闭线程池 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 根据最大线程上限数， 给工作线程数组开辟空间, 并清零 */</span></span><br><span class="line">        pool-&gt;threads = (<span class="keyword">pthread_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>)*max_thr_num); </span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"malloc threads fail"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threads, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>)*max_thr_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 队列开辟空间 */</span></span><br><span class="line">        pool-&gt;task_queue = (<span class="keyword">threadpool_task_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">threadpool_task_t</span>)*queue_max_size);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;task_queue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"malloc task_queue fail"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化互斥琐、条件变量 */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;(pool-&gt;lock), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_mutex_init(&amp;(pool-&gt;thread_counter), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_cond_init(&amp;(pool-&gt;queue_not_empty), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_cond_init(&amp;(pool-&gt;queue_not_full), <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"init the lock or cond fail"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 启动 min_thr_num 个 work thread */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min_thr_num; i++) &#123;</span><br><span class="line">            pthread_create(&amp;(pool-&gt;threads[i]), <span class="literal">NULL</span>, threadpool_thread, (<span class="keyword">void</span> *)pool);<span class="comment">/*pool指向当前线程池*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"start thread 0x%x...\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pool-&gt;threads[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_create(&amp;(pool-&gt;adjust_tid), <span class="literal">NULL</span>, adjust_thread, (<span class="keyword">void</span> *)pool);<span class="comment">/* 启动管理者线程 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    threadpool_free(pool);      <span class="comment">/* 前面代码调用失败时，释放poll存储空间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向线程池中 添加一个任务 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_add</span><span class="params">(<span class="keyword">threadpool_t</span> *pool, <span class="keyword">void</span>*(*function)(<span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ==为真，队列已经满， 调wait阻塞 */</span></span><br><span class="line">    <span class="keyword">while</span> ((pool-&gt;queue_size == pool-&gt;queue_max_size) &amp;&amp; (!pool-&gt;shutdown)) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;(pool-&gt;queue_not_full), &amp;(pool-&gt;lock));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;shutdown) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清空 工作线程 调用的回调函数 的参数arg */</span></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;task_queue[pool-&gt;queue_rear].arg != <span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;task_queue[pool-&gt;queue_rear].arg);</span><br><span class="line">        pool-&gt;task_queue[pool-&gt;queue_rear].arg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*添加任务到任务队列里*/</span></span><br><span class="line">    pool-&gt;task_queue[pool-&gt;queue_rear].function = function;</span><br><span class="line">    pool-&gt;task_queue[pool-&gt;queue_rear].arg = arg;</span><br><span class="line">    pool-&gt;queue_rear = (pool-&gt;queue_rear + <span class="number">1</span>) % pool-&gt;queue_max_size;       <span class="comment">/* 队尾指针移动, 模拟环形 */</span></span><br><span class="line">    pool-&gt;queue_size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*添加完任务后，队列不为空，唤醒线程池中 等待处理任务的线程*/</span></span><br><span class="line">    pthread_cond_signal(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程池中各个工作线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadpool_thread</span><span class="params">(<span class="keyword">void</span> *threadpool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">threadpool_t</span> *pool = (<span class="keyword">threadpool_t</span> *)threadpool;</span><br><span class="line">    <span class="keyword">threadpool_task_t</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/* Lock must be taken to wait on conditional variable */</span></span><br><span class="line">        <span class="comment">/*刚创建出线程，等待任务队列里有任务，否则阻塞等待任务队列里有任务后再唤醒接收任务*/</span></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*queue_size == 0 说明没有任务，调 wait 阻塞在条件变量上, 若有任务，跳过该while*/</span></span><br><span class="line">        <span class="keyword">while</span> ((pool-&gt;queue_size == <span class="number">0</span>) &amp;&amp; (!pool-&gt;shutdown)) &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread 0x%x is waiting\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">            pthread_cond_wait(&amp;(pool-&gt;queue_not_empty), &amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*清除指定数目的空闲线程，如果要结束的线程个数大于0，结束线程*/</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;wait_exit_thr_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pool-&gt;wait_exit_thr_num--;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*如果线程池里线程个数大于最小值时可以结束当前线程*/</span></span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;live_thr_num &gt; pool-&gt;min_thr_num) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"thread 0x%x is exiting\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">                    pool-&gt;live_thr_num--;</span><br><span class="line">                    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">                    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*如果指定了true，要关闭线程池里的每个线程，自行退出处理*/</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;shutdown) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread 0x%x is exiting\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);     <span class="comment">/* 线程自行结束 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*从任务队列里获取任务, 是一个出队操作*/</span></span><br><span class="line">        task.function = pool-&gt;task_queue[pool-&gt;queue_front].function;</span><br><span class="line">        task.arg = pool-&gt;task_queue[pool-&gt;queue_front].arg;</span><br><span class="line"></span><br><span class="line">        pool-&gt;queue_front = (pool-&gt;queue_front + <span class="number">1</span>) % pool-&gt;queue_max_size;       <span class="comment">/* 出队，模拟环形队列 */</span></span><br><span class="line">        pool-&gt;queue_size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*通知可以有新的任务添加进来*/</span></span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queue_not_full));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*任务取出后，立即将 线程池琐 释放*/</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*执行任务*/</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 0x%x start working\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));                            <span class="comment">/*忙状态线程数变量琐*/</span></span><br><span class="line">        pool-&gt;busy_thr_num++;                                                   <span class="comment">/*忙状态线程数+1*/</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        (*(task.function))(task.arg);                                           <span class="comment">/*执行回调函数任务*/</span></span><br><span class="line">        <span class="comment">//task.function(task.arg);                                              /*执行回调函数任务*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*任务结束处理*/</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 0x%x end working\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pool-&gt;busy_thr_num--;                                       <span class="comment">/*处理掉一个任务，忙状态数线程数-1*/</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 管理线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">adjust_thread</span><span class="params">(<span class="keyword">void</span> *threadpool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">threadpool_t</span> *pool = (<span class="keyword">threadpool_t</span> *)threadpool;</span><br><span class="line">    <span class="keyword">while</span> (!pool-&gt;shutdown) &#123;</span><br><span class="line"></span><br><span class="line">        sleep(DEFAULT_TIME);                                    <span class="comment">/*定时 对线程池管理*/</span></span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">        <span class="keyword">int</span> queue_size = pool-&gt;queue_size;                      <span class="comment">/* 关注 任务数 */</span></span><br><span class="line">        <span class="keyword">int</span> live_thr_num = pool-&gt;live_thr_num;                  <span class="comment">/* 存活 线程数 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        <span class="keyword">int</span> busy_thr_num = pool-&gt;busy_thr_num;                  <span class="comment">/* 忙着的线程数 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 创建新线程 算法： 任务数大于最小线程池个数, 且存活的线程数少于最大线程个数时 如：30&gt;=10 &amp;&amp; 40&lt;100*/</span></span><br><span class="line">        <span class="keyword">if</span> (queue_size &gt;= MIN_WAIT_TASK_NUM &amp;&amp; live_thr_num &lt; pool-&gt;max_thr_num) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;(pool-&gt;lock));  </span><br><span class="line">            <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*一次增加 DEFAULT_THREAD 个线程*/</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;max_thr_num &amp;&amp; add &lt; DEFAULT_THREAD_VARY</span><br><span class="line">                    &amp;&amp; pool-&gt;live_thr_num &lt; pool-&gt;max_thr_num; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;threads[i] == <span class="number">0</span> || !is_thread_alive(pool-&gt;threads[i])) &#123;</span><br><span class="line">                    pthread_create(&amp;(pool-&gt;threads[i]), <span class="literal">NULL</span>, threadpool_thread, (<span class="keyword">void</span> *)pool);</span><br><span class="line">                    add++;</span><br><span class="line">                    pool-&gt;live_thr_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 销毁多余的空闲线程 算法：忙线程X2 小于 存活的线程数 且 存活的线程数 大于 最小线程数时*/</span></span><br><span class="line">        <span class="keyword">if</span> ((busy_thr_num * <span class="number">2</span>) &lt; live_thr_num  &amp;&amp;  live_thr_num &gt; pool-&gt;min_thr_num) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 一次销毁DEFAULT_THREAD个线程, 隨機10個即可 */</span></span><br><span class="line">            pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">            pool-&gt;wait_exit_thr_num = DEFAULT_THREAD_VARY;      <span class="comment">/* 要销毁的线程数 设置为10 */</span></span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DEFAULT_THREAD_VARY; i++) &#123;</span><br><span class="line">                <span class="comment">/* 通知处在空闲状态的线程, 他们会自行终止*/</span></span><br><span class="line">                pthread_cond_signal(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_destroy</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pool-&gt;shutdown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*先销毁管理线程*/</span></span><br><span class="line">    pthread_join(pool-&gt;adjust_tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;live_thr_num; i++) &#123;</span><br><span class="line">        <span class="comment">/*通知所有的空闲线程*/</span></span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;live_thr_num; i++) &#123;</span><br><span class="line">        pthread_join(pool-&gt;threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    threadpool_free(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放任务队列和所有的锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_free</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;task_queue) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;task_queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;threads) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threads);</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">        pthread_mutex_destroy(&amp;(pool-&gt;lock));</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pthread_mutex_destroy(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pthread_cond_destroy(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">        pthread_cond_destroy(&amp;(pool-&gt;queue_not_full));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取所有活着的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_all_threadnum</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all_threadnum = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">    all_threadnum = pool-&gt;live_thr_num;</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">    <span class="keyword">return</span> all_threadnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取忙碌的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_busy_threadnum</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> busy_threadnum = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    busy_threadnum = pool-&gt;busy_thr_num;</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    <span class="keyword">return</span> busy_threadnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断线程是否活着</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_thread_alive</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kill_rc = pthread_kill(tid, <span class="number">0</span>);     <span class="comment">//发0号信号，测试线程是否存活</span></span><br><span class="line">    <span class="keyword">if</span> (kill_rc == ESRCH) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试*/</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="comment">/* 线程池中的线程，模拟处理业务 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">process</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 0x%x working on task %d\n "</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self(),*(<span class="keyword">int</span> *)arg);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"task %d is end\n"</span>,*(<span class="keyword">int</span> *)arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">threadpool_t</span> *thp = threadpool_create(<span class="number">3</span>,<span class="number">100</span>,<span class="number">100</span>);<span class="comment">/*创建线程池，池里最小3个线程，最大100，队列最大100*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pool inited"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int *num = (int *)malloc(sizeof(int)*20);</span></span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">20</span>], i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        num[i]=i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add task %d\n"</span>,i);</span><br><span class="line">        threadpool_add(thp, process, (<span class="keyword">void</span>*)&amp;num[i]);     <span class="comment">/* 向线程池中添加任务 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">10</span>);                                          <span class="comment">/* 等子线程完成任务 */</span></span><br><span class="line">    threadpool_destroy(thp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="udp服务器"><a class="markdownIt-Anchor" href="#udp服务器"></a> UDP服务器</h3><p>无连接的不可靠报文传递</p><p>无需创建连接，所以UDP开销较小，数据传输速度快，实时性较强。</p><p>多用于对实时性要求较高的通信场合，如视频会议、电话会议等</p><p>缺点：数据传输不可靠，传输数据的正确率、传输顺序和流量都得不到控制和保证。</p><p>使用UDP协议进行数据传输，为保证数据的正确性，我们需要在应用层添加辅助校验协议来弥补UDP的不足，以达到数据可靠传输的目的。</p><p>UDP也有可能出现缓冲区被填满后，再接收数据时丢包的现象。由于它没有TCP滑动窗口的机制，通常采用如下两种方法解决：</p><ol><li><p>服务器应用层设计流量控制，控制发送数据速度。</p></li><li><p>借助setsockopt函数改变接收缓冲区大小。如：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</span><br><span class="line">int n = 220x1024</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;n, sizeof(n));</span><br></pre></td></tr></table></figure><h4 id="cs模型-udp"><a class="markdownIt-Anchor" href="#cs模型-udp"></a> C/S模型-UDP</h4><p><img src="/images/javawz/image-20220220232755019.png" alt="image-20220220232755019"></p><p>由于UDP不需要维护连接，程序逻辑简单了很多，但是UDP协议是不可靠的，保证通讯可靠性的机制需要在应用层实现。</p><h4 id="sendto"><a class="markdownIt-Anchor" href="#sendto"></a> sendto</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sendto(int s, const void *buf, int len, unsigned int flags, const struct sockaddr *to, int tolen);</span><br></pre></td></tr></table></figure><p>返回值说明：</p><p>成功则返回实际传送出去的字符数，失败返回-1，错误原因会存于errno 中。</p><p>参数说明：</p><p>    s：   socket描述符；<br>　　　　buf： UDP数据报缓存区（包含待发送数据）；<br>　　　　len：  UDP数据报的长度；<br>　　　　flags：调用方式标志位（一般设置为0）；<br>　　　　to：　 指向接收数据的主机地址信息的结构体（sockaddr_in需类型转换）；<br>　　　　tolen：to所指结构体的长度；</p><br><br><h4 id="recvfrom"><a class="markdownIt-Anchor" href="#recvfrom"></a> recvfrom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int recvfrom(int s, void *buf, int len, unsigned int flags,struct sockaddr *from, int *fromlen);</span><br></pre></td></tr></table></figure><p>返回值说明：</p><p>  成功则返回实际接收到的字符数，失败返回-1，错误原因会存于errno 中。</p><p>  参数说明：</p><p>    s：     socket描述符；</p><p>    buf：    UDP数据报缓存区（包含所接收的数据）；<br>    len：    缓冲区长度。<br>    flags：  调用操作方式（一般设置为0）。<br>    from：   指向发送数据的客户端地址信息的结构体（sockaddr_in需类型转换）；<br>    fromlen：指针，指向from结构体长度值。</p><h4 id="serverc"><a class="markdownIt-Anchor" href="#serverc"></a> Server.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ,<span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">                inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                ntohs(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line"></span><br><span class="line">        n = sendto(sockfd, buf, n, <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">"sendto error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="clientc"><a class="markdownIt-Anchor" href="#clientc"></a> Client.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sockfd, n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, BUFSIZ, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        n = sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">"sendto error"</span>);</span><br><span class="line"></span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);         <span class="comment">//NULL:不关心对端信息</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line"></span><br><span class="line">        write(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="udp实现广播"><a class="markdownIt-Anchor" href="#udp实现广播"></a> UDP实现广播</h3><pre><code>IP：192.168.42.255(广播)   IP：192.168.42.1(网关)广播需要设置套接字开启广播功能   int flag = 1;    setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;flag, sizeof(flag));给sockfd开放广播权限。</code></pre><p>客户端需要绑定端口号</p><h4 id="server"><a class="markdownIt-Anchor" href="#server"></a> server</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8000                                    <span class="comment">/* 无关紧要 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1500</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BROADCAST_IP <span class="meta-string">"192.168.42.255"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000                                    <span class="comment">/* 重要 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>, <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造用于UDP通信的套接字 */</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;                        <span class="comment">/* IPv4 */</span></span><br><span class="line">    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);         <span class="comment">/* 本地任意IP INADDR_ANY = 0 */</span></span><br><span class="line">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启广播权限</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造 client 地址 IP+端口  192.168.7.255+9000 */</span></span><br><span class="line">    bzero(&amp;clientaddr, <span class="keyword">sizeof</span>(clientaddr));</span><br><span class="line">    clientaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, BROADCAST_IP, &amp;clientaddr.sin_addr.s_addr);</span><br><span class="line">    clientaddr.sin_port = htons(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"Drink %d glasses of water\n"</span>, i++);</span><br><span class="line">        <span class="comment">//fgets(buf, sizeof(buf), stdin);</span></span><br><span class="line">        sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;clientaddr, <span class="keyword">sizeof</span>(clientaddr));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="client"><a class="markdownIt-Anchor" href="#client"></a> Client</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">localaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> confd;</span><br><span class="line">    <span class="keyword">ssize_t</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建一个socket</span></span><br><span class="line">    confd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化本地端地址</span></span><br><span class="line">    bzero(&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));</span><br><span class="line">    localaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span> , &amp;localaddr.sin_addr.s_addr);</span><br><span class="line">    localaddr.sin_port = htons(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(confd, (struct sockaddr *)&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));  <span class="comment">//显示绑定不能省略</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"...bind ok...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = recvfrom(confd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    close(confd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组播"><a class="markdownIt-Anchor" href="#组播"></a> 组播</h3><p>广播是把数据报发送给所有的机器,容易造成广播风暴，所以推荐使用组播</p><p>组播组可以是永久的也可以是临时的。组播组地址中，有一部分由官方分配的，称为永久组播组。永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">224.0.0.0～224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；</span><br><span class="line">224.0.1.0～224.0.1.255是公用组播地址，可以用于Internet；欲使用需申请。</span><br><span class="line">224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效；</span><br><span class="line">239.0.0.0～239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效。（局域网使用）</span><br></pre></td></tr></table></figure><p>可使用ip ad命令查看网卡编号，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">itcast$ ip ad</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:0a:c4:f4 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet6 fe80::20c:29ff:fe0a:c4f4/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>eth0网卡的编号是2</p><p><code>if_nametoindex</code>函数可以根据网卡名，获取网卡序号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned int if_nametoindex(const char *ifname);//传递网卡名字</span><br></pre></td></tr></table></figure><h3 id="serverc-2"><a class="markdownIt-Anchor" href="#serverc-2"></a> Server.c</h3><p>服务端要开启组播权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define GROUP &quot;239.0.0.2&quot;</span><br><span class="line">struct ip_mreqn group;</span><br><span class="line"></span><br><span class="line">inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);        /* 设置组地址 */</span><br><span class="line">inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;group.imr_address);      /* 本地任意IP */</span><br><span class="line">group.imr_ifindex = if_nametoindex(&quot;eth0&quot;);             /* 给出网卡名,转换为对应编号: eth0 --&gt; 编号  命令:ip ad */</span><br><span class="line">setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, sizeof(group));  /* 组播权限 */</span><br></pre></td></tr></table></figure><h4 id="查看ip_mreqn结构体"><a class="markdownIt-Anchor" href="#查看ip_mreqn结构体"></a> 查看ip_mreqn结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo grep -r &quot;ip_mreqn&quot; /usr/ -n</span><br><span class="line"></span><br><span class="line">struct ip_mreqn &#123;</span><br><span class="line">     struct in_addr  imr_multiaddr;      /* IP multicast address of group 组地址*/ </span><br><span class="line">     struct in_addr  imr_address;        /* local IP address of interface 本地ip*/</span><br><span class="line">     int     imr_ifindex;        /* Interface index 网卡编号*/</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1500</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">"239.0.0.2"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>, <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE] = <span class="string">"itcast\n"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);                <span class="comment">/* 构造用于UDP通信的套接字 */</span></span><br><span class="line">    </span><br><span class="line">    bzero(&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;                        <span class="comment">/* IPv4 */</span></span><br><span class="line">    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);         <span class="comment">/* 本地任意IP INADDR_ANY = 0 */</span></span><br><span class="line">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);        <span class="comment">/* 设置组地址 */</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;group.imr_address);      <span class="comment">/* 本地任意IP */</span></span><br><span class="line">    group.imr_ifindex = if_nametoindex(<span class="string">"eth0"</span>);             <span class="comment">/* 给出网卡名,转换为对应编号: eth0 --&gt; 编号  命令:ip ad */</span></span><br><span class="line"></span><br><span class="line">    setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, <span class="keyword">sizeof</span>(group));  <span class="comment">/* 组播权限 */</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;clientaddr, <span class="keyword">sizeof</span>(clientaddr));                 <span class="comment">/* 构造 client 地址 IP+端口 */</span></span><br><span class="line">    clientaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, GROUP, &amp;clientaddr.sin_addr.s_addr); <span class="comment">/* IPv4  239.0.0.2+9000 */</span></span><br><span class="line">    clientaddr.sin_port = htons(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"itcast %d\n"</span>, i++);</span><br><span class="line">        <span class="comment">//fgets(buf, sizeof(buf), stdin);</span></span><br><span class="line">        sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;clientaddr, <span class="keyword">sizeof</span>(clientaddr));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clientc-2"><a class="markdownIt-Anchor" href="#clientc-2"></a> client.c</h3><p>客户端要加入组播</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define GROUP &quot;239.0.0.2&quot;</span><br><span class="line"></span><br><span class="line">inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);                        /* 设置组地址 */</span><br><span class="line">inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;group.imr_address);                      /* 使用本地任意IP添加到组播组 */</span><br><span class="line">group.imr_ifindex = if_nametoindex(&quot;eth0&quot;);                             /* 通过网卡名--&gt;编号 ip ad */</span><br><span class="line">    </span><br><span class="line">setsockopt(confd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, sizeof(group));/* 设置client 加入多播组 */</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">"239.0.0.2"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">localaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> confd;</span><br><span class="line">    <span class="keyword">ssize_t</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span>                                                  <span class="comment">/* 组播结构体 */</span></span><br><span class="line"></span><br><span class="line">    confd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));                                   <span class="comment">/* 初始化 */</span></span><br><span class="line">    localaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span> , &amp;localaddr.sin_addr.s_addr);</span><br><span class="line">    localaddr.sin_port = htons(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    bind(confd, (struct sockaddr *)&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));</span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);                        <span class="comment">/* 设置组地址 */</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;group.imr_address);                      <span class="comment">/* 使用本地任意IP添加到组播组 */</span></span><br><span class="line">    group.imr_ifindex = if_nametoindex(<span class="string">"eth0"</span>);                             <span class="comment">/* 通过网卡名--&gt;编号 ip ad */</span></span><br><span class="line">    </span><br><span class="line">    setsockopt(confd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, <span class="keyword">sizeof</span>(group));<span class="comment">/* 设置client 加入多播组 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = recvfrom(confd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    close(confd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="socket-ipc本地套接字domain"><a class="markdownIt-Anchor" href="#socket-ipc本地套接字domain"></a> socket IPC（本地套接字domain）</h3><p>使用UNIX Domain Socket的过程和网络socket十分相似，也要先调用socket()创建一个socket文件描述符，address family指定为AF_UNIX，type可以选择SOCK_DGRAM或SOCK_STREAM，protocol参数仍然指定为0即可。</p><p>UNIX Domain Socket与网络socket编程最明显的不同在于地址格式不同，用结构体sockaddr_un表示，网络编程的socket地址是IP地址加端口号，而UNIX Domain Socket的地址是一个socket类型的文件在文件系统中的路径，这个socket文件由bind()调用创建，如果调用bind()时该文件已存在，则bind()错误返回。</p><p>对比网络套接字地址结构和本地套接字地址结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">__kernel_sa_family_t sin_family; /* Address family */  地址结构类型</span><br><span class="line">__be16 sin_port; /* Port number */端口号</span><br><span class="line">struct in_addr sin_addr;/* Internet address */IP地址</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sockaddr_un &#123;</span><br><span class="line">__kernel_sa_family_t sun_family; /* AF_UNIX */地址结构类型</span><br><span class="line">char sun_path[UNIX_PATH_MAX]; /* pathname */socket文件名(含路径)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下程序将UNIX Domain socket绑定到一个地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size = offsetof(struct sockaddr_un, sun_path) + strlen(un.sun_path);</span><br><span class="line">#define offsetof(type, member) ((int)&amp;((type *)0)-&gt;MEMBER)</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220223213103304.png" alt="image-20220223213103304"></p><h4 id="offsetof"><a class="markdownIt-Anchor" href="#offsetof"></a> offsetof</h4><p><img src="/images/javawz/image-20220223213748406.png" alt="image-20220223213748406"></p><h4 id="unlink"><a class="markdownIt-Anchor" href="#unlink"></a> unlink</h4><p>删除pathname指定的硬链接,并由pathname所引用的文件链接计数减1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int unlink(const char *pathname);</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220223214357895.png" alt="image-20220223214357895"></p><p><img src="/images/javawz/image-20220223214309111.png" alt="image-20220223214309111"></p><h4 id="server-2"><a class="markdownIt-Anchor" href="#server-2"></a> server</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_ADDR  <span class="meta-string">"serv.socket"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd, len, size, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    lfd = Socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path,SERV_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);     <span class="comment">/* servaddr total len */</span></span><br><span class="line"></span><br><span class="line">    unlink(SERV_ADDR);                              <span class="comment">/* 确保bind之前serv.sock文件不存在,bind会创建该文件 */</span></span><br><span class="line">    Bind(lfd, (struct sockaddr *)&amp;servaddr, len);           <span class="comment">/* 参3不能是sizeof(servaddr) */</span></span><br><span class="line"></span><br><span class="line">    Listen(lfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accept ...\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;cliaddr, (<span class="keyword">socklen_t</span> *)&amp;len);</span><br><span class="line"></span><br><span class="line">        len -= offsetof(struct sockaddr_un, sun_path);      <span class="comment">/* 得到文件名的长度 */</span></span><br><span class="line">        cliaddr.sun_path[len] = <span class="string">'\0'</span>;                       <span class="comment">/* 确保打印时,没有乱码出现 */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client bind filename %s\n"</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((size = read(cfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">            write(cfd, buf, size);</span><br><span class="line">        &#125;</span><br><span class="line">        close(cfd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="client-2"><a class="markdownIt-Anchor" href="#client-2"></a> Client</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;         </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_ADDR <span class="meta-string">"serv.socket"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIE_ADDR <span class="meta-string">"clie.socket"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  cfd, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    cfd = Socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    cliaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(cliaddr.sun_path,CLIE_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(cliaddr.sun_path);     <span class="comment">/* 计算客户端地址结构有效长度 */</span></span><br><span class="line"></span><br><span class="line">    unlink(CLIE_ADDR);</span><br><span class="line">    Bind(cfd, (struct sockaddr *)&amp;cliaddr, len);                                 <span class="comment">/* 客户端也需要bind, 不能依赖自动绑定*/</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));                                          <span class="comment">/* 构造server 地址 */</span></span><br><span class="line">    servaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path,SERV_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);   <span class="comment">/* 计算服务器端地址结构有效长度 */</span></span><br><span class="line"></span><br><span class="line">    Connect(cfd, (struct sockaddr *)&amp;servaddr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;协议的概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#协议的概念&quot;&gt;&lt;/a&gt; 协议的概念&lt;/h3&gt;
&lt;h4 id=&quot;什么是协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是协议&quot;&gt;&lt;/a&gt; 什么是
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>线程同步</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/30/linux083%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/30/linux083线程同步/</id>
    <published>2022-01-29T17:35:19.000Z</published>
    <updated>2022-02-20T13:09:49.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-互斥锁"><a class="markdownIt-Anchor" href="#1-互斥锁"></a> 1 互斥锁</h3><h4 id="11互斥锁的使用步骤"><a class="markdownIt-Anchor" href="#11互斥锁的使用步骤"></a> 1.1互斥锁的使用步骤</h4><ul><li><p>第1步：创建一把互斥锁</p><ul><li><code>pthread_mutex_t mutex;</code></li></ul></li><li><p>初始化互斥锁</p><ul><li><code>pthread_mutex_init(&amp;mutex);</code>—相当于mutex=1</li></ul></li><li><p>在代码中寻找共享资源（也称为临界区）</p><ul><li><code>pthread_mutex_lock(&amp;mutex); -- mutex = 0</code></li></ul></li><li><p>临界区代码</p><ul><li><code>pthread_mutex_unlock(&amp;mutex); -- mutex = 1</code></li></ul></li><li><p>释放互斥锁资源</p><ul><li><code>pthread_mutex_destroy(&amp;mutex);</code></li></ul></li></ul><p>注意：必须在所有操作共享资源的线程上都加上锁否则不能起到同步的效果</p><h4 id="12-练习"><a class="markdownIt-Anchor" href="#12-练习"></a> 1.2 练习</h4><ul><li>编写思路：</li></ul><p>1 定义一把互斥锁，应该为一全局变量</p><p><code>pthread_mutex_t mutex;</code></p><p>2 在main函数中对mutex进行初始化</p><p><code>pthread_mutex_init(&amp;mutex, NULL);</code></p><p>3 创建两个线程，在两个线程中加锁和解锁</p><p>4 主线程释放互斥锁资源</p><p><code>pthread_mutex_destroy(&amp;mutex);</code></p><p><img src="/images/javawz/image-20220130014052263.png" alt="image-20220130014052263"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread1</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"world\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread2</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"HELLO "</span>);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WORLD\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1;</span><br><span class="line"><span class="keyword">pthread_t</span> thread2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机数种子</span></span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//互斥锁初始化</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">ret = pthread_create(&amp;thread1, <span class="literal">NULL</span>, mythread1, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = pthread_create(&amp;thread2, <span class="literal">NULL</span>, mythread2, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束</span></span><br><span class="line">pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放互斥锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-死锁"><a class="markdownIt-Anchor" href="#13-死锁"></a> 1.3 死锁</h3><p>死锁并不是linux提供给用户的一种使用方法，而是由于用户使用互斥锁不当引起的一种现象。</p><ul><li>常见的死锁有两种：<ul><li>第一种：自己锁自己，如下图代码片段</li><li>第二种 线程A拥有A锁，请求获得B锁；线程B拥有B锁，请求获得A锁，这样造成线程A和线程B都不释放自己的锁，而且还想得到对方的锁，从而产生死锁，如下图所示：</li></ul></li></ul><p><img src="/images/javawz/image-20220130014154167.png" alt="image-20220130014154167"></p><ul><li>如何解决死锁：<ul><li>让线程按照一定的顺序去访问共享资源</li><li>在访问其他锁的时候，需要先将自己的锁解开</li><li>调用<code>pthread_mutex_trylock</code>，如果加锁不成功会立刻返回</li></ul></li></ul><p>​自己锁自己.<br>​注意点: 线程在异常退出的时候也需要解锁.<br>A线程占用着A锁, 又想去获得B锁; B线程占用着B锁, 又想去获得A锁,<br>​  两个线程都不释放自己的锁, 又想去获得对方的锁, 从而造成了死锁.<br>​  解决方法:<br>​  1 需要先释放自己的锁再去获得其他锁<br>​  2 避免使用嵌套的锁, 让线程按照一定的顺序加锁<br>​  3 可以调用<code>pthread_mutex_trylock</code>函数加锁, 该函数不阻塞, 所以不会产生死锁.</p><h3 id="2-读写锁"><a class="markdownIt-Anchor" href="#2-读写锁"></a> 2 读写锁</h3><ul><li>什么是读写锁<ul><li>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。<strong>写独占、读共享。</strong></li></ul></li><li>读写锁使用场合<ul><li>读写锁非常适合于对数据结构读的次数远大于写的情况。</li></ul></li><li>读写锁特性<ul><li>读写锁是“写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞。</li><li>读写锁是“读模式加锁”时，如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</li><li>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高</li></ul></li><li>读写锁场景练习:<ul><li>线程A加写锁成功, 线程B请求读锁<ul><li>线程B阻塞</li></ul></li><li>线程A持有读锁, 线程B请求写锁<ul><li>线程B阻塞</li></ul></li><li>线程A拥有读锁, 线程B请求读锁<ul><li>线程B加锁成功</li></ul></li><li>线程A持有读锁, 然后线程B请求写锁, 然后线程C请求读锁<ul><li>B阻塞，c阻塞 - 写的优先级高</li><li>A解锁，B线程加写锁成功，C继续阻塞</li><li>B解锁，C加读锁成功</li></ul></li><li>线程A持有写锁, 然后线程B请求读锁, 然后线程C请求写锁<ul><li>BC阻塞</li><li>A解锁，C加写锁成功，B继续阻塞</li><li>C解锁，B加读锁成功</li></ul></li></ul></li><li>读写锁总结</li></ul><p>读并行，写独占，当读写同时等待锁的时候写的优先级高</p><ul><li><p>读写锁主要操作函数</p><ul><li>定义一把读写锁<ul><li><code>pthread_rwlock_t rwlock;</code></li></ul></li><li>初始化读写锁<ul><li><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></li><li>函数参数</li><li>rwlock-读写锁</li><li>attr-读写锁属性，传NULL为默认属性</li></ul></li><li>销毁读写锁<ul><li><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></li></ul></li><li>加读锁<ul><li><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></li></ul></li><li>尝试加读锁<ul><li><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></li></ul></li><li>加写锁<ul><li><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></li></ul></li><li>尝试加写锁<ul><li><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></li></ul></li><li>解锁<ul><li><code>int pthread_rwlock_unlock(&amp;pthread_rwlock_t *rwlock);</code></li></ul></li></ul></li><li><p>练习：3个线程不定时写同一全局资源，5个线程不定时读同一全局资源。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读写锁测试程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把读写锁</span></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写线程回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_write</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加写锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">cur = number;</span><br><span class="line">cur++;</span><br><span class="line">number = cur;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]-W:[%d]\n"</span>, i, cur);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读线程回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_read</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加读锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">cur = number;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]-R:[%d]\n"</span>, i, cur);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">pthread_t</span> thread[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//读写锁初始化</span></span><br><span class="line">pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建3个写子线程</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">pthread_create(&amp;thread[i], <span class="literal">NULL</span>, thread_write, &amp;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建5个读子线程</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">pthread_create(&amp;thread[i], <span class="literal">NULL</span>, thread_read, &amp;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回收子线程</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n; j++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_join(thread[j], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-条件变量"><a class="markdownIt-Anchor" href="#3-条件变量"></a> 3 条件变量</h3><ul><li>条件本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。<ul><li>使用互斥量保护共享数据;</li><li>使用条件变量可以使线程阻塞, 等待某个条件的发生, 当条件满足的时候解除阻塞.</li></ul></li><li>条件变量的两个动作:<ul><li>条件不满足, 阻塞线程</li><li>条件满足, 通知阻塞的线程解除阻塞, 开始工作.</li></ul></li><li>条件变量相关函数<ul><li><code>pthread_cond_t cond;</code><ul><li>定义一个条件变量</li></ul></li></ul></li><li><code>int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);</code><ul><li>函数描述:初始化条件变量</li><li>函数参数:<ul><li>cond: 条件变量</li><li>attr: 条件变量属性, 通常传NULL</li></ul></li><li>函数返回值:成功返回0, 失败返回错误号</li></ul></li><li><code>int pthread_cond_destroy(pthread_cond_t *cond);</code><ul><li>函数描述: 销毁条件变量</li><li>函数参数: 条件变量</li><li>返回值: 成功返回0, 失败返回错误号</li></ul></li><li><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code><ul><li>函数描述: 条件不满足, 引起线程阻塞并解锁;<ul><li>​     条件满足, 解除线程阻塞, 并加锁</li></ul></li><li>函数参数:<ul><li>cond: 条件变量</li><li>mutex: 互斥锁变量</li></ul></li><li>函数返回值: 成功返回0, 失败返回错误号</li></ul></li><li><code>int pthread_cond_signal(pthread_cond_t *cond);</code><ul><li>函数描述: 唤醒至少一个阻塞在该条件变量上的线程</li><li>函数参数: 条件变量</li><li>函数返回值: 成功返回0, 失败返回错误号</li></ul></li><li><code>pthread_cond_broadcas(pthread_cond_t *cond)</code><ul><li>唤醒睡眠的线程，一次唤醒所有睡眠的线程</li><li>函数参数: 条件变量</li></ul></li></ul><p>4 使用条件变量的代码片段</p><p><img src="/images/javawz/image-20220130015559506.png" alt="image-20220130015559506"></p><p>上述代码中，生产者线程调用<code>pthread_cond_signal</code>函数会使消费者线程在<code>pthread_cond_wait</code>处解除阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用条件变量实现生产者和消费者模型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line">NODE *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生产一个节点</span></span><br><span class="line">pNode = (NODE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span>(pNode==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"malloc error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pNode-&gt;data = rand()%<span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"P:[%d]\n"</span>, pNode-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">pNode-&gt;next = head;</span><br><span class="line">head = pNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知消费者线程解除阻塞</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//若条件不满足,需要阻塞等待</span></span><br><span class="line"><span class="comment">//若条件不满足,则阻塞等待并解锁;</span></span><br><span class="line"><span class="comment">//若条件满足(被生成者线程调用pthread_cond_signal函数通知),解除阻塞并加锁 </span></span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C:[%d]\n"</span>, head-&gt;data);</span><br><span class="line">pNode = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pNode);</span><br><span class="line">pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1;</span><br><span class="line"><span class="keyword">pthread_t</span> thread2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化互斥锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量初始化</span></span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建生产者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建消费者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束</span></span><br><span class="line">pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放互斥锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放条件变量</span></span><br><span class="line">pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用条件变量实现生产者和消费者模型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line">NODE *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生产一个节点</span></span><br><span class="line">pNode = (NODE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span>(pNode==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"malloc error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pNode-&gt;data = rand()%<span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"P[%d]:[%d]\n"</span>, n, pNode-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">pNode-&gt;next = head;</span><br><span class="line">head = pNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知消费者线程解除阻塞</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//若条件不满足,需要阻塞等待</span></span><br><span class="line"><span class="comment">//若条件不满足,则阻塞等待并解锁;</span></span><br><span class="line"><span class="comment">//若条件满足(被生成者线程调用pthread_cond_signal函数通知),解除阻塞并加锁 </span></span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C[%d]:[%d]\n"</span>, n, head-&gt;data);</span><br><span class="line">pNode = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pNode);</span><br><span class="line">pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">pthread_t</span> thread2[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化互斥锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量初始化</span></span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i]= i;</span><br><span class="line"><span class="comment">//创建生产者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread1[i], <span class="literal">NULL</span>, producer, &amp;arr[i]);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建消费者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread2[i], <span class="literal">NULL</span>, consumer, &amp;arr[i]);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_join(thread1[i], <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(thread2[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放互斥锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放条件变量</span></span><br><span class="line">pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h3><p>1 信号量介绍</p><p>​信号量相当于多把锁, 可以理解为是加强版的互斥锁</p><p>2 相关函数</p><p>定义信号量 <code>sem_t sem</code>;</p><ul><li><p><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></p><ul><li>函数描述: 初始化信号量</li><li>函数参数:<ul><li>sem: 信号量变量</li><li>pshared: 0表示线程同步, 1表示进程同步</li><li>value: 最多有几个线程操作共享数据</li></ul></li><li>函数返回值:成功返回0, 失败返回-1, 并设置errno值</li></ul></li><li><p><code>int sem_wait(sem_t *sem);</code></p><ul><li>函数描述: 调用该函数一次, 相当于<code>sem--</code>, 当sem为0的时候, 引起阻塞</li><li>函数参数: 信号量变量</li><li>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</li></ul></li><li><p><code>int sem_post(sem_t *sem);</code></p><ul><li>函数描述: 调用一次, 相当于<code>sem++</code></li><li>` 函数参数: 信号量变量</li><li>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</li></ul></li><li><p><code>int sem_trywait(sem_t *sem);</code></p><ul><li>函数描述: 尝试加锁, 若失败直接返回, 不阻塞</li><li>函数参数: 信号量变量</li><li>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</li></ul></li><li><p><code>int sem_destroy(sem_t *sem);</code></p><ul><li>函数描述: 销毁信号量</li><li>函数参数: 信号量变量</li><li>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</li></ul></li></ul><p>3 信号量代码片段:</p><p><img src="/images/javawz/image-20220130020118740.png" alt="image-20220130020118740"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用信号量实现生产者和消费者模型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line">NODE *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> sem_producer;</span><br><span class="line"><span class="keyword">sem_t</span> sem_consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生产一个节点</span></span><br><span class="line">pNode = (NODE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span>(pNode==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"malloc error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pNode-&gt;data = rand()%<span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"P:[%d]\n"</span>, pNode-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">sem_wait(&amp;sem_producer); <span class="comment">//--</span></span><br><span class="line"></span><br><span class="line">pNode-&gt;next = head;</span><br><span class="line">head = pNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">sem_post(&amp;sem_consumer);  <span class="comment">//相当于++</span></span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">sem_wait(&amp;sem_consumer); <span class="comment">//相当于--</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C:[%d]\n"</span>, head-&gt;data);</span><br><span class="line">pNode = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">sem_post(&amp;sem_producer); <span class="comment">//相当于++</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pNode);</span><br><span class="line">pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1;</span><br><span class="line"><span class="keyword">pthread_t</span> thread2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化信号量</span></span><br><span class="line">sem_init(&amp;sem_producer, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">sem_init(&amp;sem_consumer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建生产者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建消费者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束</span></span><br><span class="line">pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放信号量资源</span></span><br><span class="line">sem_destroy(&amp;sem_producer);</span><br><span class="line">sem_destroy(&amp;sem_consumer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-互斥锁&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-互斥锁&quot;&gt;&lt;/a&gt; 1 互斥锁&lt;/h3&gt;
&lt;h4 id=&quot;11互斥锁的使用步骤&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11互斥锁的使用步骤
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>守护进程和线程</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/24/linux082%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/24/linux082守护进程和线程/</id>
    <published>2022-01-24T12:30:39.000Z</published>
    <updated>2022-01-29T19:12:09.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="守护进程"><a class="markdownIt-Anchor" href="#守护进程"></a> 守护进程</h2><h3 id="11-守护进程介绍"><a class="markdownIt-Anchor" href="#11-守护进程介绍"></a> 1.1 守护进程介绍</h3><p>Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字，如vsftpd</p><p>Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。</p><ul><li>总结守护进程的特点：<ul><li>Linux后台服务进程</li><li>独立于控制终端</li><li>周期性的执行某种任务</li><li>不受用户登陆和注销的影响</li><li>一般采用以d结尾的名字</li></ul></li></ul><h3 id="12-进程组和会话"><a class="markdownIt-Anchor" href="#12-进程组和会话"></a> 1.2 进程组和会话</h3><ul><li><p>进程组</p><ul><li>进程组是一个或者多个进程的集合，每个进程都属于一个进程组，引入进程组是为了简化对进程的管理。当父进程创建子进程的时候，默认子进程与父进程属于同一个进程组。</li><li>进程组ID==第一个进程ID（组长进程）。如父进程创建了多个子进程，父进程和多个子进程同属于一个组，而由于父进程是进程组里的第一个进程，所以父进程就是这个组的组长, 组长ID==父进程ID。</li><li>可以使用kill -SIGKILL -进程组ID(负的)来将整个进程组内的进程全部杀死。</li><li>只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</li><li>进程组生存期：从进程组创建到最后一个进程离开</li></ul></li><li><p>会话</p><ul><li>一个会话是一个或多个进程组的集合。</li><li>创建会话的进程不能是进程组组长</li><li>创建会话的进程成为一个进程组的组长进程，同时也成为会话的会长。</li><li>需要有root权限（ubuntu不需要）</li><li>新创建的会话丢弃原有的控制终端</li><li>建立新会话时，先调用fork, 父进程终止，子进程调用setsid函数</li><li>可以使用<code>ps ajx</code>来查看进程组ID和会话ID</li><li>可以fork出几个子进程，然后查看进程组ID和会话ID</li></ul></li><li><p>进程组和会话的关系图</p><p><img src="/images/javawz/image-20220124220938860.png" alt="image-20220124220938860"></p></li></ul><h3 id="13-创建守护进程的模型"><a class="markdownIt-Anchor" href="#13-创建守护进程的模型"></a> 1.3 创建守护进程的模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t setsid(void);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功后，将返回调用进程的（新）会话ID。一旦出错，</span><br><span class="line">返回（pid_t）-1，并设置errno以指示错误。</span><br></pre></td></tr></table></figure><ul><li><p>第1步：fork子进程，父进程退出</p><ul><li>子进程继承了父进程的进程组ID, 但具有一个新的进程ID,这样就保证了子进程不是一个进程组的组长ID,这对于下面要做的setsid函数的调用是必要的前提条件</li></ul></li><li><p>第2步：子进程调用setsid函数创建新会话</p><ul><li>调用这个函数以后</li><li>该进程成为新会话的首进程，是会话的会长</li><li>成为一个新进程组的组长进程，是进程组组长</li><li>不受控制终端的影响</li></ul></li><li><p>第3步：改变当前工作目录<code>chdir</code></p><ul><li>如：a.out在U盘上，启动这个程序，这个程序的当前的工作目录就是这个u盘，如果u盘拔掉后进程的当前工作目录将消失，a.out将不能正常工作。</li></ul></li><li><p>第4步：重设文件掩码  <code>mode &amp; ~umask</code></p><ul><li>子进程会继承父进程的掩码</li><li>增加子进程程序操作的灵活性</li><li><code>umask(0000);</code>最右边的0代表八进制</li></ul></li><li><p>第5步：关闭文件描述符</p><ul><li>守护进程不受控制终端的影响所以可以关闭，以释放资源</li><li><code>close(STDIN_FILENO);</code></li><li><code>close(STDOUT_FILENO);</code></li><li><code>close(STDERR_FILENO);</code></li></ul></li><li><p>第6步：执行核心工作</p><ul><li>守护进程的核心代码逻辑</li></ul></li></ul><h3 id="14练习"><a class="markdownIt-Anchor" href="#14练习"></a> 1.4练习</h3><p>​编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。</p><p>分析：首先要按照1.3介绍的守护进行的步骤创建一个守护进程</p><p>题目要求每隔2S钟，所以需要一个定时器，2S钟触发一次，需要调用<code>setitimer</code>函数创建一个定时器，并且要捕获SIGALRM信号，然后在SIGALRM信号处理函数里面完成获取系统时间，然后将时间写入文件。</p><ul><li>用到的主要知识点：<ul><li>创建守护进程的模型</li><li>setitimer函数的使用</li><li>sigaction函数</li><li>文件I/O操作</li><li>获取系统时间函数time，将<code>time_t</code>类型转换为字符串ctime函数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建守护进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"mydemon.log"</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0755</span>);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前的系统时间</span></span><br><span class="line"><span class="keyword">time_t</span> t;</span><br><span class="line">time(&amp;t);</span><br><span class="line">    <span class="comment">//将时间转换为字符串形式</span></span><br><span class="line"><span class="keyword">char</span> *p = ctime(&amp;t);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将时间写入文件</span></span><br><span class="line">write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//父进程fork子进程, 然后父进程退出</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span> || pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子进程调用setsid函数创建会话</span></span><br><span class="line">setsid();</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变当前的工作目录</span></span><br><span class="line">chdir(<span class="string">"/home/itcast/log"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变文件掩码</span></span><br><span class="line">umask(<span class="number">0000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭标准输入,输出和错误输出文件描述符</span></span><br><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心操作</span></span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = myfunc;</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置时钟</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tm</span>;</span></span><br><span class="line">tm.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">tm.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">tm.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">tm.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">setitimer(ITIMER_REAL, &amp;tm, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化:<br> 1 不再频繁的打开和关闭文件<br> 2 如何控制log文件大小  test.log</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写守护进程: 每隔2秒获取一次系统时间,并将时间写入文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//获取当前系统时间</span></span><br><span class="line"><span class="keyword">time_t</span> tm;</span><br><span class="line">time(&amp;tm);</span><br><span class="line"><span class="keyword">char</span> *p = ctime(&amp;tm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//新建文件</span></span><br><span class="line">fd = open(<span class="string">"./mydaemon.log"</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写文件</span></span><br><span class="line">write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//fork子进程，父进程退出</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span> || pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子进程调用setsid函数创建新会话</span></span><br><span class="line">setsid();</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变当前工作目录chdir</span></span><br><span class="line">chdir(<span class="string">"/home/itcast"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重设文件掩码</span></span><br><span class="line">umask(<span class="number">0000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭标准输入,标准输出, 标准错误输出这三个文件描述符</span></span><br><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心工作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = sighandler;</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用setitimer函数设置时钟</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tm</span>;</span></span><br><span class="line">tm.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">tm.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">tm.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">tm.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">setitimer(ITIMER_REAL, &amp;tm, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取文件大小</span></span><br><span class="line"><span class="keyword">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">if</span>(size&gt;<span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd);</span><br><span class="line">            <span class="comment">//文件重命名</span></span><br><span class="line">rename(<span class="string">"./mydaemon.log"</span>, <span class="string">"./mydaemon.log.bak"</span>);</span><br><span class="line">flag =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>守护进程的特点:&emsp;1 一个linux后台服务进程&emsp;2 不依赖于控制终端&emsp;3 周期性执行某些任务&emsp;4 不受用户登录和注销的影响&emsp;5 一般以d结尾<p>进程组和会话:<br> 进程组: 一个进程包含多个进程<br> 会话: 多个组组成一个会话.<br> 创建会话的进程不能是组长进程;<br> 一般创建会话是父进程先fork子进程, 然后父进程退出, 让子进程调用setsid函数<br> 创建一个会话, 这个子进程既是会长也是组长;<br> 只要是创建了会话, 这个进程就脱离了控制终端的影响.</p><p>创建守护进程模型:<br>1 父进程fork子进程, 然后父进程退出.<br>目的是: 子进程肯定不是组长进程, 为后续调用setsid函数提供了条件.<br>2 子进程调用setsid函数创建一个新的会话.<br>  1 该子进程成了该会话的会长<br>  2 该子进程成了该组的组长进程.<br>  3 不再受控制终端的影响了<br>3 改变当前的工作目录, chdir  -----不是必须的<br>4 重设文件掩码, umask(0000)  -----不是必须的<br>5 关闭<code>STDIN_FILENO STDOUT_FILENO STDERR_FILENO</code>  —不是必须的<br>6 核心操作</p><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><ul><li><h3 id="21-什么是线程"><a class="markdownIt-Anchor" href="#21-什么是线程"></a> 2.1 什么是线程</h3><ul><li>轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。</li><li>进程：拥有独立的地址空间，拥有PCB，相当于独居。</li><li>线程：有PCB，但没有独立的地址空间，多个线程共享进程空间，相当于合租。</li></ul></li></ul><p><img src="/images/javawz/image-20220124231226369.png" alt="image-20220124231226369"></p><ul><li><p>在Linux操作系统下：</p><ul><li>线程：最小的执行单位</li><li>进程：最小分配资源单位，可看成是只有一个线程的进程。</li></ul></li><li><p>线程的特点</p><ul><li>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</li><li>线程是轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</li><li>从内核里看进程和线程是一样的，都有各自不同的PCB.</li><li>进程可以蜕变成线程</li><li>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</li></ul></li></ul><p><img src="/images/javawz/image-20220124231358842.png" alt="image-20220124231358842"></p><ul><li>查看指定线程的LWP号：<code>ps –Lf pid</code></li><li>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数 clone。</li><li>如果复制对方的地址空间，那么就产出一个“进程”；</li><li>如果共享对方的地址空间，就产生一个“线程”。</li></ul><p>so：<strong>Linux内核是不区分进程和线程的, 只在用户层面上进行区分</strong>。</p><p>所以，线程所有操作函数<code>pthread_*</code> 是库函数，而非系统调用。</p><h3 id="22-线程共享资源"><a class="markdownIt-Anchor" href="#22-线程共享资源"></a> 2.2 线程共享资源</h3><ul><li>文件描述符表</li><li>每种信号的处理方式</li><li>当前工作目录</li><li>用户ID和组ID</li><li>内存地址空间 (<code>.text/.data/.bss/heap/共享库</code>)</li></ul><h3 id="23-线程非共享资源"><a class="markdownIt-Anchor" href="#23-线程非共享资源"></a> 2.3 线程非共享资源</h3><ul><li>线程id</li><li>处理器现场和栈指针(内核栈)</li><li>独立的栈空间(用户空间栈)</li><li>errno变量</li><li>信号屏蔽字</li><li>调度优先级</li></ul><h3 id="24-线程优-缺点"><a class="markdownIt-Anchor" href="#24-线程优-缺点"></a> 2.4  线程优、缺点</h3><ul><li>优点：<ul><li>提高程序并发性</li><li>开销小</li><li>数据通信、共享数据方便</li></ul></li><li>缺点：<ul><li>库函数，不稳定</li><li>gdb调试、编写困难</li><li>对信号支持不好</li></ul></li></ul><p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p><h3 id="25-pthread_create函数"><a class="markdownIt-Anchor" href="#25-pthread_create函数"></a> 2.5  pthread_create函数</h3><ul><li>头文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br></pre></td></tr></table></figure><ul><li>函数作用：</li><li>创建一个新线程</li><li>函数原型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread, </span><br><span class="line"></span><br><span class="line">const pthread_attr_t *attr,</span><br><span class="line"></span><br><span class="line">      void *(*start_routine) (void *),</span><br><span class="line"></span><br><span class="line"> void *arg</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>返回值</p><ul><li>成功，返回0</li><li>失败，返回错误号</li></ul></li><li><p>函数参数：</p><ul><li><code>pthread_t</code>：传出参数，保存系统为我们分配好的线程ID</li><li>当前Linux中可理解为：<code>typedef unsigned long int pthread_t</code>。</li><li>attr：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。</li><li><code>start_routine</code>：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。</li><li>arg：线程主函数执行期间所使用的参数。</li></ul></li><li><p>注意点</p><ul><li>由于<code>pthread_create</code>的错误码不保存在errno中，因此不能直接用<code>perror()</code>打印错误信息，可以先用<code>strerror()</code>把错误码转换成错误信息再打印。<code>strerror要包含头文件#include&lt;string.h&gt;</code></li><li>如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。</li></ul></li><li><p>练习题：</p></li></ul><p>1 编写程序创建一个线程。</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_t pthread_self(void);</span><br><span class="line"></span><br><span class="line">函数作用：获得线程自身的ID。pthread_t的类型为unsigned long int，所以在打印的时候要使用%lu方式，否则显示结果出问题。</span><br><span class="line"></span><br><span class="line">pthread_self() //获取当前线程id</span><br></pre></td></tr></table></figure><br><h4 id="多线程编译是要指定库"><a class="markdownIt-Anchor" href="#多线程编译是要指定库"></a> 多线程编译是要指定库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc xxx.c -l pthread -o xxx</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>2 编写程序创建一个线程，并给线程传递一个<code>int</code>参数</p><p>3 编写程序创建一个线程，并给线程传递一个结构体参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程: 传递参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int n = *(int *)arg;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> *<span class="title">p</span> = (<span class="title">struct</span> <span class="title">Test</span> *)<span class="title">arg</span>;</span></span><br><span class="line"><span class="comment">//struct Test *p = arg;</span></span><br><span class="line"><span class="comment">//printf("n==[%d]\n", n);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d][%s]\n"</span>, p-&gt;data, p-&gt;name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">99</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;t, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(struct Test));</span><br><span class="line">t.data = <span class="number">88</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(t.name, <span class="string">"xiaowen"</span>);</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="comment">//int ret = pthread_create(&amp;thread, NULL, mythread, &amp;n);</span></span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, &amp;t);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 编写程序，主线程循环创建5个子线程，并让子线程判断自己是第几个子线程。</p><p>练习4分析：最后每个子线程打印出来的值并不是想象中的值，比如都是5，分析其原因：</p><p>在创建子线程的时候使用循环因子作为参数传递给子线程，这样主线程和多个子线程就会共享变量i（变量i在main函数中定义，在整个进程都一直有效）所以在子线程看来变量i是合法的栈内存空间。</p><p>那么为什么最后每个子线程打印出来的值都是5呢?</p><p>是由于主线程可能会在一个cpu时间片内连续创建了5个子线程，此时变量i的值变成了5，当主线程失去cpu的时间片后，子线程得到cpu的时间片，子线程访问的是变量i的内存空间的值，所以打印出来值为5.</p><p><img src="/images/javawz/image-20220124232632703.png" alt="image-20220124232632703"></p><p>主线程和子线程共享同一块内存空间</p><p><img src="/images/javawz/image-20220124232651711.png" alt="image-20220124232651711"></p><p>主线程和子线程分时使用cpu资源</p><p>解决办法：不能使多个子线程都共享同一块内存空间，应该使每个子线程访问不同的内存空间，可以在主线程定义一个数组：<code>int arr[5];</code>，然后创建线程的时候分别传递不同的数组元素，这样每个子线程访问的就是互不相同的内存空间，这样就可以打印正确的值。</p><p>如下图：</p><p><img src="/images/javawz/image-20220124232725306.png" alt="image-20220124232725306"></p><p>多个子线程各自访问不同的内存空间</p><ul><li>根据测试程序还可以得出结论：<ul><li>如果主线程早于子线程退出，则子线程可能得不到执行，因为主线程退出，整个进程空间都会被回收，子线程没有了生存空间，所以也就得不到执行。</li><li>线程之间（包含主线程和子线程）可以共享同一变量，包含全局变量或者非全局变量（但是非全局变量必须在其有效的生存期内）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环创建子线程,并且打印是第几个子线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:child thread, pid==[%d], id==[%ld]\n"</span>, i, getpid(), pthread_self());</span><br><span class="line">sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">pthread_t</span> thread[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">ret = pthread_create(&amp;thread[i], <span class="literal">NULL</span>, mythread, &amp;arr[i]);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26pthread_exit函数"><a class="markdownIt-Anchor" href="#26pthread_exit函数"></a> 2.6pthread_exit函数</h3><p>在线程中禁止调用exit函数，否则会导致整个进程退出，取而代之的是调用<code>pthread_exit</code>函数，这个函数是使一个线程退出，如果主线程调用<code>pthread_exit</code>函数也不会使整个进程退出，不影响其他线程的执行。</p><ul><li><p>函数描述</p><ul><li>将单个线程退出</li></ul></li><li><p>函数原型</p><ul><li><code>void pthread_exit(void *retval);</code></li></ul></li><li><p>函数参数</p><ul><li>retval表示线程退出状态，通常传NULL</li></ul></li></ul><p>另注意，<code>pthread_exit</code>或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了，栈空间就会被回收。</p><p>练习：编写程序测试<code>pthread_exit</code>函数使一个线程退出。</p><p>通过程序测试得知，<code>pthread_exit</code>函数只是使一个线程退出，假如子线程里面调用了exit函数，会使整个进程终止；如果主线程调用了<code>pthread_exit</code>函数，并不影响子线程，只是使主线程自己退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程退出函数测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> g_var = <span class="number">9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"><span class="comment">//printf("[%p]\n", &amp;g_var);</span></span><br><span class="line"><span class="comment">//pthread_exit(&amp;g_var);</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;t, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line">t.data = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(t.name, <span class="string">"xiaowen"</span>);</span><br><span class="line">pthread_exit(&amp;t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//回收子线程</span></span><br><span class="line"><span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">pthread_join(thread, &amp;p);</span><br><span class="line"><span class="comment">//int n = *(int *)p;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> *<span class="title">pt</span> = (<span class="title">struct</span> <span class="title">Test</span> *)<span class="title">p</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child exit status:[%d],[%s],[%p]\n"</span>,  pt-&gt;data, pt-&gt;name, p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="27-pthread_join函数"><a class="markdownIt-Anchor" href="#27-pthread_join函数"></a> 2.7 pthread_join函数</h3><ul><li><p>函数描述：阻塞等待线程退出，获取线程退出状态。其作用，对应进程中的waitpid() 函数。</p></li><li><p>函数原型：<code>int pthread_join(pthread_t thread, void **retval);</code></p></li><li><p>函数返回值：</p><ul><li>成功：0；</li><li>失败：错误号</li></ul></li><li><p>函数参数：</p><ul><li>thread：线程ID</li><li>retval：存储线程结束状态，整个指针和<code>pthread_exit</code>的参数是同一块内存地址。</li></ul></li></ul><p>练习：编写程序，使主线程获取子线程的退出状态。</p><p>一般先定义<code>void *ptr; 然后pthread_join(threadid, &amp;ptr);</code></p><h3 id="28-pthread_detach函数"><a class="markdownIt-Anchor" href="#28-pthread_detach函数"></a> 2.8 pthread_detach函数</h3><p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p><p>进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</p><p>也可使用 pthread_create函数参2(线程属性)来设置线程分离。<code>pthread_detach</code>函数是在创建线程之后调用的。</p><ul><li>函数描述<ul><li>实现线程分离</li></ul></li><li>函数原型<ul><li><code>int pthread_detach(pthread_t thread);</code></li></ul></li><li>函数返回值<ul><li>成功：0；</li><li>失败：错误号</li></ul></li></ul><p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用<code>pthread_ join</code>获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。不能对一个已经处于detach状态的线程调用<code>pthread_ join</code>，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了<code>pthread_detach</code>就不能再调用<code>pthread_ join</code>了。</p><p>练习：编写程序，在创建线程之后设置线程的分离状态。</p><p>说明：如果线程已经设置了分离状态，则再调用<code>pthread_ join</code>就会失败，可用这个方法验证是否已成功设置分离状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置子线程为分离属性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置线程为分离属性</span></span><br><span class="line">pthread_detach(thread);</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程设置分离属性,则pthread_join不再阻塞,立刻返回</span></span><br><span class="line">ret = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_join error:[%s]\n"</span>, strerror(ret));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="29-pthread_cancel函数"><a class="markdownIt-Anchor" href="#29-pthread_cancel函数"></a> 2.9 pthread_cancel函数</h3><ul><li><p>函数描述</p></li><li><p>杀死(取消)线程。其作用，对应进程中 kill() 函数。</p></li><li><p>函数原型</p></li><li><p><code>int pthread_cancel(pthread_t thread);</code></p></li><li><p>函数返回值</p></li><li><p>成功：0；</p></li><li><p>失败：错误号</p></li><li><p>【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。</p></li><li><p>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</p></li><li><p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write… 执行命令<code>man 7 pthreads</code>可以查看具备这些取消点的系统调用列表。可粗略认为一个系统调用(进入内核)即为一个取消点。还以通过调用<code>pthread_testcancel</code>函数设置一个取消点。</p><ul><li>函数原型：<code>void pthread_testcancel(void);</code></li></ul></li></ul><p>练习：编写程序，让主线程取消子线程的执行。</p><p>先测试一下没有取消点看看能否使线程取消；然后调用<code>pthread_testcancel</code>设置一个取消点，看看能够使线程取消。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置取消点</span></span><br><span class="line"><span class="comment">//pthread_testcancel();</span></span><br><span class="line"><span class="comment">//printf也有取消点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消子线程</span></span><br><span class="line">pthread_cancel(thread);</span><br><span class="line"></span><br><span class="line">pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="210-pthread_equal函数"><a class="markdownIt-Anchor" href="#210-pthread_equal函数"></a> 2.10 pthread_equal函数</h3><ul><li>函数描述：</li><li>比较两个线程ID是否相等。</li><li>函数原型</li><li><code>int pthread_equal(pthread_t t1, pthread_t t2);</code></li></ul><p>注意：这个函数是为了以能够扩展使用的， 有可能Linux在未来线程ID <code>pthread_t</code>类型被修改为结构体实现。</p><h3 id="211-进程函数和线程函数比较"><a class="markdownIt-Anchor" href="#211-进程函数和线程函数比较"></a> 2.11 进程函数和线程函数比较</h3><table><thead><tr><th>进程</th><th>线程</th></tr></thead><tbody><tr><td><strong>fork</strong></td><td><strong>pthread_create</strong></td></tr><tr><td><strong>exit</strong></td><td><strong>pthread_exit</strong></td></tr><tr><td><strong>wait/waitpid</strong></td><td><strong>pthread_join</strong></td></tr><tr><td><strong>kill</strong></td><td><strong>pthread_cancel</strong></td></tr><tr><td><strong>getpid</strong></td><td><strong>pthread_self</strong></td></tr></tbody></table><p><br><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较线程ID是否相等</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较线程ID</span></span><br><span class="line"><span class="comment">//if(pthread_equal(thread, pthread_self())!=0)</span></span><br><span class="line"><span class="keyword">if</span>(pthread_equal(pthread_self(), pthread_self())!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"two thread id is same\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"two thread id is not same\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-线程属性"><a class="markdownIt-Anchor" href="#3-线程属性"></a> 3 线程属性</h3><p>linux下线程的属性是可以根据实际项目需要，进行设置，之前讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题，如果对程序的性能提出更高的要求，则需要设置线程属性，本节以设置线程的分离属性为例讲解设置线程属性。</p><ul><li><p>线程的分离状态决定一个线程以什么样的方式来终止自己，有两种状态：</p><ul><li>非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</li><li>分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</li></ul></li><li><p>设置线程属性分为以下步骤</p></li><li><p>第1步：定义线程属性类型类型的变量</p><ul><li><code>pthread_attr_t attr;</code></li></ul></li><li><p>第2步：对线程属性变量进行初始化</p><ul><li><code>int pthread_attr_init (pthread_attr_t* attr);</code></li></ul></li><li><p>第3步：设置线程为分离属性</p></li><li><p><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code></p><ul><li>参数:<ul><li>attr: 线程属性</li><li>detachstate:<ul><li><code>PTHREAD_CREATE_DETACHED</code>(分离)</li><li><code>PTHREAD_CREATE_JOINABLE</code>（非分离)</li></ul></li></ul></li></ul></li></ul><p>注意：这一步完成之后调用<code>pthread_create</code>函数创建线程，</p><p>则创建出来的线程就是分离线程；其实上述三步就是</p><p><code>pthread_create</code>的第二个参数做准备工作。</p><ul><li>第4步：释放线程属性资源<ul><li><code>int pthread_attr_destroy(pthread_attr_t *attr);</code></li><li>参数：线程属性</li></ul></li></ul><p>练习：编写程序，创建一个分离属性的线程。</p><p>验证：设置为分离属性的线程是不能够被<code>pthread_join</code>函数回收的，</p><p>可以通过调用<code>pthread_join</code>函数测试该线程是否已经是分离属性的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在创建子线程的时候设置分离属性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义pthread_attr_t类型的变量</span></span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化attr变量</span></span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置attr为分离属性</span></span><br><span class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, &amp;attr, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放线程属性</span></span><br><span class="line">pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证子线程是否为分离属性</span></span><br><span class="line">ret = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_join error:[%s]\n"</span>, strerror(ret));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-线程同步"><a class="markdownIt-Anchor" href="#4-线程同步"></a> 4 线程同步</h3><h4 id="41-线程同步的概念"><a class="markdownIt-Anchor" href="#41-线程同步的概念"></a> 4.1 线程同步的概念</h4><p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p><h4 id="42-线程同步的例子"><a class="markdownIt-Anchor" href="#42-线程同步的例子"></a> 4.2 线程同步的例子</h4><p>创建两个线程，让两个线程共享一个全局变量<code>int number</code>， 然后让每个线程数5000次数，看最后打印出这个number值是多少？</p><p>线程A代码片段：</p><p><img src="/images/javawz/image-20220128210559848.png" alt="image-20220128210559848"></p><p>线程B代码片段：</p><p><img src="/images/javawz/image-20220128210619983.png" alt="image-20220128210619983"></p><ul><li><p>代码片段说明</p><ul><li>代码中使用调用usleep是为了让两个子线程能够轮流使用CPU，避免一个子线程在一个时间片内完成5000次数数。</li><li>对number执行++操作，使用了中间变量cur是为了尽可能的模拟cpu时间片用完而让出cpu的情况。</li></ul></li><li><p>测试结果</p><ul><li>经过多次测试最后的结果显示，有可能会出现number值少于5000*2=10000的情况。</li></ul></li><li><p>分析原因</p><ul><li>假如子线程A执行完了cur++操作，还没有将cur的值赋值给number失去了cpu的执行权，子线程B得到了cpu执行权，而子线程B最后执行完了number=cur，而后失去了cpu的执行权；此时子线程A又重新得到cpu的执行权，并执行number=cur操作，这样会把线程B刚刚写回number的值被覆盖了，造成number值不符合预期的值。</li></ul><p><img src="/images/javawz/image-20220128210754455.png" alt="image-20220128210754455"></p></li><li><p>数据混乱的原因</p><ul><li>资源共享（独享资源则不会）</li><li>调度随机（线程操作共享资源的先后顺序不确定）</li><li>线程间缺乏必要的同步机制。</li></ul></li></ul><p>以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p><ul><li><p>如何解决问题</p><ul><li>原子操作的概念</li></ul><p>原子操作指的是该操作要么不做，要么就完成。</p><ul><li>使用互斥锁解决同步问题</li></ul><p>使用互斥锁其实是模拟原子操作，互斥锁示意图：</p></li></ul><p>Linux中提供一把互斥锁mutex（也称之为互斥量）。每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p><p>资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</p><p><img src="/images/javawz/image-20220128210816722.png" alt="image-20220128210816722"></p><p>线程1访问共享资源的时候要先判断锁是否锁着，如果锁着就阻塞等待；若锁是解开的就将这把锁加锁，此时可以访问共享资源，访问完成后释放锁，这样其他线程就有机会获得锁。</p><p>应该注意：图中同一时刻，只能有一个线程持有该锁，只要该线程未完成操作就不释放锁。</p><p>​使用互斥锁之后，两个线程由并行操作变成了串行操作，效率降低了，但是数据不一致的问题得到解决了。</p><h4 id="43互斥锁主要相关函数"><a class="markdownIt-Anchor" href="#43互斥锁主要相关函数"></a> 4.3互斥锁主要相关函数</h4><ul><li><p><code>pthread_mutex_t</code>类型</p><ul><li>其本质是一个结构体，为简化理解，应用时可忽略其实现细节，简单当成整数看待。</li><li><code>pthread_mutex_t mutex;</code>变量mutex只有两种取值1、0。</li></ul></li><li><p><code>pthread_mutex_init</code>函数</p><ul><li>函数描述：<ul><li>初始化一个互斥锁(互斥量) —&gt; 初值可看作1</li></ul></li><li>函数原型：<ul><li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></li></ul></li><li>函数参数<ul><li>mutex：传出参数，调用时应传<code>&amp;mutex</code></li><li>attr：互斥锁属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。</li></ul></li></ul></li><li><p><strong>restrict关键字</strong>：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改互斥量mutex的两种初始化方式：</p><ul><li><strong>静态初始化</strong>：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。</li><li><code>pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</code></li><li><strong>动态初始化</strong>：局部变量应采用动态初始化。</li></ul></li></ul><p><code>pthread_mutex_init(&amp;mutex, NULL);</code></p><ul><li><p><code>pthread_mutex_destroy</code>函数</p></li><li><p>函数描述</p><ul><li>销毁一个互斥锁</li></ul></li><li><p>函数原型</p><ul><li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></li></ul></li><li><p>函数参数</p><ul><li>mutex—互斥锁变量</li></ul></li><li><p><code>pthread_mutex_lock</code>函数</p><ul><li>函数描述<ul><li>对互斥所加锁，可理解为将<code>mutex--</code></li></ul></li><li>函数原型<ul><li><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></li></ul></li><li>函数参数<ul><li>mutex—互斥锁变量</li></ul></li></ul></li><li><p><code>pthread_mutex_unlock</code>函数</p><ul><li>函数描述</li><li>对互斥所解锁，可理解为将mutex ++</li><li>函数原型</li><li><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li></ul></li><li><p><code>pthread_mutex_trylock</code>函数</p><ul><li>函数描述<ul><li>尝试加锁</li></ul></li><li>函数原型<ul><li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></li></ul></li><li>函数参数<ul><li>mutex—互斥锁变量</li></ul></li></ul></li></ul><h4 id="44-加锁和解锁"><a class="markdownIt-Anchor" href="#44-加锁和解锁"></a> 4.4 加锁和解锁</h4><ul><li>lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</li><li>unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</li></ul><p>练习：使用互斥锁解决两个线程数数不一致的问题。</p><p>代码片段：在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好。</p><p><img src="/images/javawz/image-20220128211719750.png" alt="image-20220128211719750"></p><p>总结：使用互斥锁之后，两个线程由并行变为了串行，效率降低了，但是可以使两个线程同步操作共享资源，从而解决了数据不一致的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 50000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mythread1</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">n = number;</span><br><span class="line">n++;</span><br><span class="line">number = n;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"A: [%d]\n"</span>,number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mythread2</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">n = number;</span><br><span class="line">n++;</span><br><span class="line">number = n;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"B: [%d]\n"</span>,number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1;</span><br><span class="line"><span class="keyword">pthread_t</span> thread2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret1 = pthread_create(&amp;thread1,<span class="literal">NULL</span>,mythread1,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret1 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error: [%s]\n"</span>,strerror(ret1));</span><br><span class="line"><span class="keyword">return</span> ret1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ret2 = pthread_create(&amp;thread2,<span class="literal">NULL</span>,mythread2,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret2 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error: [%s]\n"</span>,strerror(ret2));</span><br><span class="line"><span class="keyword">return</span> ret2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> *retval1;</span><br><span class="line"><span class="keyword">void</span> *retval2;</span><br><span class="line"><span class="keyword">int</span> join_ret = pthread_join(thread1,&amp;retval1);</span><br><span class="line"><span class="keyword">if</span>(join_ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_join error [%s]\n"</span>,strerror(join_ret));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> join_ret2 = pthread_join(thread2,&amp;retval2);</span><br><span class="line"><span class="keyword">if</span>(join_ret2 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_join error [%s]\n"</span>,strerror(join_ret2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"number [%d]"</span>,number);</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥锁: 线程A和线程B共同访问共享资源, 当线程A想访问共享资源的时候,<br>要先获得锁, 如果锁被占用, 则加锁不成功需要阻塞等待对方释放锁;<br>若锁没有被占用, 则获得锁成功–加锁, 然后操作共享资源, 操作完之后,<br>必须解锁, 同理B也是和A一样.<br>也就是说, 同时不能有两个线程访问共享资源, 属于互斥操作.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;守护进程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#守护进程&quot;&gt;&lt;/a&gt; 守护进程&lt;/h2&gt;
&lt;h3 id=&quot;11-守护进程介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-守护进程介绍&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>使用信号完成两个进程交替数数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/23/linux081%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%88%90%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%95%B0%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/23/linux081使用信号完成两个进程交替数数/</id>
    <published>2022-01-23T12:30:23.000Z</published>
    <updated>2022-01-23T12:33:05.975Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用SIGUSR1和SIGUSR2在父子进程间交替数数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"F:[%d]\n"</span>, num);</span><br><span class="line">num += <span class="number">2</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C:[%d]\n"</span>, num);</span><br><span class="line">num += <span class="number">2</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num=<span class="number">0</span>;</span><br><span class="line">flag  = <span class="number">1</span>;</span><br><span class="line">signal(SIGUSR1, func1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">kill(pid, SIGUSR2);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num=<span class="number">1</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">signal(SIGUSR2, func2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">kill(getppid(), SIGUSR1);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>SIGCHLD</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/23/linux080SIGCHLD/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/23/linux080SIGCHLD/</id>
    <published>2022-01-23T11:15:47.000Z</published>
    <updated>2022-01-23T12:29:57.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="产生sigchld信号的条件"><a class="markdownIt-Anchor" href="#产生sigchld信号的条件"></a> 产生SIGCHLD信号的条件</h3><ul><li><p>子进程结束的时候</p></li><li><p>子进程收到SIGSTOP信号</p></li><li><p>当子进程停止时，收到SIGCONT信号</p></li></ul><h3 id="sigchld信号的作用"><a class="markdownIt-Anchor" href="#sigchld信号的作用"></a> SIGCHLD信号的作用</h3><p>​子进程退出后，内核会给它的父进程发送SIGCHLD信号，父进程收到这个信号后可以对子进程进行回收。</p><p>​使用SIGCHLD信号完成对子进程的回收可以避免父进程阻塞等待而不能执行其他操作，只有当父进程收到SIGCHLD信号之后才去调用信号捕捉函数完成对子进程的回收，未收到SIGCHLD信号之前可以处理其他操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对SIGCHLD信号测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child [%d]\n"</span>,pid);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">signal(SIGCHLD,sighandler);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fater [%d]\n"</span>,pid);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -19 子进程id号 //对子进程发送SIGSTOP信号,然后产生SIGCHLD信号</span><br><span class="line">kill -18 子进程id号 //对子进程发送SIGCONT信号,然后产生SIGCHLD信号</span><br></pre></td></tr></table></figure><h3 id="使用sigchld信号完成对子进程的回收"><a class="markdownIt-Anchor" href="#使用sigchld信号完成对子进程的回收"></a> 使用SIGCHLD信号完成对子进程的回收</h3><ul><li><p>练习：父进程创建三个子进程，然后让父进程捕获SIGCHLD信号完成对子进程的回收。</p></li><li><p>注意点：</p></li><li><p>有可能还未完成信号处理函数的注册三个子进程都退出了。</p></li><li><p>解决办法：可以在fork之前先将SIGCHLD信号阻塞，当完成信号处理函数的注册后在解除阻塞。</p></li><li><p>当SIGCHLD信号函数处理期间, SIGCHLD信号若再次产生是被阻塞的,而且若产生了多次, 则该信号只会被处理一次, 这样可能会产生僵尸进程。</p></li><li><p>解决办法: 可以在信号处理函数里面使用while(1)循环回收, 这样就有可能出现捕获一次SIGCHLD信号但是回收了多个子进程的情况，从而可以避免产生僵尸进程。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父进程使用SICCHLD信号完成对子进程的回收</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitchild</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> wpid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回收子进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line"><span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child is quit, wpid==[%d]\n"</span>, wpid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child is living, wpid==[%d]\n"</span>, wpid);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"no child is living, wpid==[%d]\n"</span>, wpid);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将SIGCHLD信号阻塞</span></span><br><span class="line"><span class="keyword">sigset_t</span> mask;</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line">sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//fork子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) <span class="comment">//fork失败的情况</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>) <span class="comment">//父进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: fpid==[%d], cpid==[%d]\n"</span>, getpid(), pid);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: fpid==[%d], cpid==[%d]\n"</span>, getppid(), getpid());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:father: fpid==[%d]\n"</span>, i, getpid());</span><br><span class="line"><span class="comment">//signal(SIGCHLD, waitchild);</span></span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = waitchild;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除对SIGCHLD信号的阻塞</span></span><br><span class="line">sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第1个子进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:child: cpid==[%d]\n"</span>, i, getpid());</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第2个子进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:child: cpid==[%d]\n"</span>, i, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第3个子进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:child: cpid==[%d]\n"</span>, i, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;产生sigchld信号的条件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#产生sigchld信号的条件&quot;&gt;&lt;/a&gt; 产生SIGCHLD信号的条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;子进程结束的时候&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>sigaction函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/22/linux079sigaction/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/22/linux079sigaction/</id>
    <published>2022-01-22T13:10:27.000Z</published>
    <updated>2022-01-23T08:35:04.927Z</updated>
    
    <content type="html"><![CDATA[<ul><li>sigaction函数</li><li>函数说明：注册一个信号处理函数</li><li>函数原型：</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</span><br></pre></td></tr></table></figure><ul><li>函数参数：</li><li>signum：捕捉的信号</li><li>act：  传入参数，新的处理方式。</li><li>oldact： 传出参数，旧的处理方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction &#123;</span><br><span class="line"></span><br><span class="line">void  (*sa_handler)(int);// 信号处理函数</span><br><span class="line"></span><br><span class="line">void  (*sa_sigaction)(int, siginfo_t *, void *); //信号处理函数</span><br><span class="line"></span><br><span class="line">sigset_t  sa_mask; //信号处理函数执行期间需要阻塞的信号</span><br><span class="line"></span><br><span class="line">int    sa_flags; //通常为0，表示使用默认标识</span><br><span class="line"></span><br><span class="line">void   (*sa_restorer)(void);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>总结：</p><ul><li>sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作</li><li>sa_mask: 用来指定在信号处理函数执行期间需要被屏蔽的信号，特别是当某个信号被处理时，它自身会被自动放入进程的信号掩码，因此在信号处理函数执行期间这个信号不会再度发生。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</li><li>sa_flags：通常设置为0，使用默认属性。</li><li>sa_restorer：已不再使用</li></ul></li><li><p>练习：编写程序，使用sigaction函数注册信号捕捉函数，并使用这个程序验证信号是否支持排队。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sigaction函数测试---注册信号处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">sleep(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = sighandler;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);  <span class="comment">//在信号处理函数执行期间, 不阻塞任何信号</span></span><br><span class="line">sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signal(SIGQUIT, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>知识点: 信号处理不支持排队:</p></li><li><p>在XXX信号处理函数执行期间, XXX信号是被阻塞的, 如果该信号产生了多次, 在XXX信号处理函数结束之后,  该XXX信号只被处理一次.</p></li><li><p>在XXX信号处理函数执行期间,如果阻塞了YYY信号, 若YYY信号产生了多次, 当XXX信号处理函数结束后, YYY信号只会被处理一次.</p></li><li><p>内核实现信号捕捉的过程</p></li></ul><p>如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这称为捕捉信号。由于信号处理函数的代码是在用户空间的，处理过程比较复杂，举例如下：</p><p>用户程序注册了SIGQUIT信号的处理函数sighandler。</p><p>当前正在执行main函数，这时发生中断或异常切换到内核态。</p><p>在中断处理完毕后要返回用户态的main函数之前检查到有信号SIGQUIT递达。</p><p>内核决定返回用户态后不是恢复main函数的上下文继续执行，而是执行sighandler函数，sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系，是两个独立的控制流程。</p><p>sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态。</p><p>如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行了。</p><p><img src="/images/javawz/wps7CFB.tmp.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;sigaction函数&lt;/li&gt;
&lt;li&gt;函数说明：注册一个信号处理函数&lt;/li&gt;
&lt;li&gt;函数原型：&lt;/li&gt;
&lt;/ul&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>信号集相关函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/22/linux078%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/22/linux078信号集相关函数/</id>
    <published>2022-01-22T06:35:35.000Z</published>
    <updated>2022-01-22T13:07:07.163Z</updated>
    
    <content type="html"><![CDATA[<p>由于信号集属于内核的一块区域，用户不能直接操作内核空间，为此，内核提供了一些信号集相关的接口函数，使用这些函数用户就可以完成对信号集的相关操作。</p><p>信号集是一个能表示多个信号的数据类型，<code>sigset_t set</code>，set即一个信号集。既然是一个集合，就需要对集进行添加、删除等操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sigset_t类型的定义在signal.h文件中的第49行处:</span><br><span class="line">typedef __sigset_t sigset_t;</span><br><span class="line">__sigset_t的定义在sigset.h文件中的26，27行处: </span><br><span class="line"># define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span><br><span class="line"></span><br><span class="line">  typedef struct</span><br><span class="line">  &#123;</span><br><span class="line">    unsigned long int __val[_SIGSET_NWORDS];</span><br><span class="line">  &#125; __sigset_t;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">上述变量类型的定义的查找有个小窍门： 可以执行gcc的预处理命令：</span><br><span class="line">gcc -E test.c -o test.i 这样头文件就会展开，可以直接到test.i文件中看到相关变量类型的定义。</span><br></pre></td></tr></table></figure><p>信号集相关函数</p><ul><li><code>int sigemptyset(sigset_t *set);</code></li></ul><p>函数说明：将某个信号集清0</p><p>函数返回值：成功：0；失败：-1，设置errno</p><ul><li><code>int sigfillset(sigset_t *set);</code></li></ul><p>函数说明：将某个信号集置1</p><p>函数返回值：成功：0；失败：-1，设置errno</p><ul><li><code>int sigaddset(sigset_t *set, int signum);</code></li></ul><p>函数说明：将某个信号加入信号集合中</p><p>函数返回值：成功：0；失败：-1，设置errno</p><ul><li><code>int sigdelset(sigset_t *set, int signum);</code></li></ul><p>函数说明：将某信号从信号清出信号集</p><p>函数返回值：成功：0；失败：-1，设置errno</p><ul><li><code>int sigismember(const sigset_t *set, int signum);</code></li></ul><p>函数说明：判断某个信号是否在信号集中</p><p>函数返回值：在：1；不在：0；出错：-1，设置errno</p><ul><li>sigprocmask函数</li></ul><p>函数说明：用来屏蔽信号、解除屏蔽也使用该函数。其本质，读</p><p>取或修改进程控制块中的信号屏蔽字（阻塞信号集）。</p><p>特别注意，屏蔽信号只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢弃处理。</p><p>函数原型：<code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code></p><p>函数返回值：成功：0；失败：-1，设置errno</p><p>函数参数：</p><p>how参数取值：假设当前的信号屏蔽字为mask</p><p><code>SIG_BLOCK</code>: 当how设置为此值，set表示需要屏蔽的信号。<strong>相当于</strong> mask = mask | set</p><p><code>SIG_UNBLOCK</code>: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~set</p><p><code>SIG_SETMASK</code>: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于mask = set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</p><p>set：传入参数，是一个自定义信号集合。由参数how来指示如何修改当前信号屏蔽字。</p><p>oldset：传出参数，保存旧的信号屏蔽字。</p><ul><li>sigpending函数</li></ul><p>函数原型：<code>int sigpending(sigset_t *set);</code></p><p>函数说明：读取当前进程的未决信号集</p><p>函数参数：set传出参数</p><p>函数返回值：成功：0；失败：-1，设置errno</p><p>练习：编写程序，设置阻塞信号集并把所有常规信号的未决状态打印至屏幕。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号集相关函数测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册SIGINT和SIGQUIT的信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line">signal(SIGQUIT, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义sigset_t类型的变量</span></span><br><span class="line"><span class="keyword">sigset_t</span> pending, mask, oldmask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">sigemptyset(&amp;pending);</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line">sigemptyset(&amp;oldmask);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将SIGINT和SIGQUIT加入到阻塞信号集中</span></span><br><span class="line">sigaddset(&amp;mask, SIGINT);</span><br><span class="line">sigaddset(&amp;mask, SIGQUIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将mask中的SIGINT和SIGQUIT信号加入到阻塞信号集中</span></span><br><span class="line"><span class="comment">//sigprocmask(SIG_BLOCK, &amp;mask, NULL);</span></span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;oldmask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取未决信号集</span></span><br><span class="line">sigpending(&amp;pending);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">32</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断某个信号是否在集合中</span></span><br><span class="line"><span class="keyword">if</span>(sigismember(&amp;pending, i)==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k++%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从阻塞信号集中解除对SIGINT和SIGQUIT的阻塞</span></span><br><span class="line"><span class="comment">//sigprocmask(SIG_UNBLOCK, &amp;mask, NULL);</span></span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于信号集属于内核的一块区域，用户不能直接操作内核空间，为此，内核提供了一些信号集相关的接口函数，使用这些函数用户就可以完成对信号集的相关操作。&lt;/p&gt;
&lt;p&gt;信号集是一个能表示多个信号的数据类型，&lt;code&gt;sigset_t set&lt;/code&gt;，set即一个信号集。既然
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>未决信号集和阻塞信号集的关系</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/22/linux077%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/22/linux077未决信号集和阻塞信号集的关系/</id>
    <published>2022-01-22T05:56:34.000Z</published>
    <updated>2022-01-22T07:37:44.866Z</updated>
    
    <content type="html"><![CDATA[<p>未决信号集和阻塞信号集的关系</p><p>阻塞信号集是当前进程要阻塞的信号的集合，未决信号集是当前进程中还处于未决状态的信号的集合，这两个集合存储在内核的PCB中。</p><ul><li>下面以SIGINT为例说明信号未决信号集和阻塞信号集的关系：</li><li>编号从1开始</li><li>当进程收到一个SIGINT信号（信号编号为2），首先这个信号会保存在未决信号集合中，此时对应的2号编号的这个位置上置为1，表示处于未决状态；在这个信号需要被处理之前首先要在阻塞信号集中的编号为2的位置上去检查该值是否为1：</li><li>如果为1，表示SIGNIT信号被当前进程阻塞了，这个信号暂时不被处理，所以未决信号集上该位置上的值保持为1，表示该信号处于未决状态；</li><li>如果为0，表示SIGINT信号没有被当前进程阻塞，这个信号需要被处理，内核会对SIGINT信号进行处理（执行默认动作，忽略或者执行用户自定义的信号处理函数），并将未决信号集中编号为2的位置上将1变为0，表示该信号已经处理了，这个时间非常短暂，用户感知不到。</li></ul><p>当SIGINT信号从阻塞信号集中解除阻塞之后，该信号就会被处理。</p><p><img src="/images/javawz/wpsB642.tmp.jpg" alt="img"></p><p>未决信号集和阻塞信号集的数据类型都是<code>sigset_t</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;未决信号集和阻塞信号集的关系&lt;/p&gt;
&lt;p&gt;阻塞信号集是当前进程要阻塞的信号的集合，未决信号集是当前进程中还处于未决状态的信号的集合，这两个集合存储在内核的PCB中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下面以SIGINT为例说明信号未决信号集和阻塞信号集的关系：&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>setitimer函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/22/linux076setitimer%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/22/linux076setitimer函数/</id>
    <published>2022-01-21T16:27:46.000Z</published>
    <updated>2022-01-22T05:19:25.228Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>函数原型</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);</span><br></pre></td></tr></table></figure><ul><li><strong>函数描述</strong></li></ul><p>设置定时器(闹钟)，可代替alarm函数，精度微秒us，可以实现周期定时。</p><ul><li><p><strong>函数返回值</strong></p><ul><li>成功：0；</li><li>失败：-1，设置errno值</li></ul></li><li><p><strong>函数参数：</strong></p></li><li><p>which：指定定时方式</p></li><li><p>自然定时：<code>ITIMER_REAL</code> → <strong>14）SIGALRM</strong>计算自然时间</p></li><li><p>虚拟空间计时(用户空间)：<code>ITIMER_VIRTUAL</code>→ <strong>26）SIGVTALRM</strong> 只计算进程占用cpu的时间</p></li><li><p>运行时计时(用户+内核)：<code>ITIMER_PROF</code> → <strong>27）SIGPROF</strong>计算占用cpu及执行系统调用的时间</p></li><li><p>new_value：<code>struct itimerval</code>, 负责设定timeout时间。</p><ul><li><code>itimerval.it_value</code>: 设定第一次执行function所延迟的秒数</li><li><code>itimerval.it_interval</code>: 设定以后每几秒执行function</li></ul></li><li><p>old_value： 存放旧的timeout值，一般指定为NULL</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct itimerval &#123; </span><br><span class="line"></span><br><span class="line">  struct timerval it_interval; // 闹钟触发周期</span><br><span class="line"></span><br><span class="line">  struct timerval it_value; // 闹钟触发时间</span><br><span class="line"></span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"> struct timeval &#123; </span><br><span class="line"></span><br><span class="line">  long tv_sec; // 秒</span><br><span class="line"></span><br><span class="line">  long tv_usec; // 微秒</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>练习: 使用setitimer实现每隔一秒打印一次hello, world。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo [%d]\n"</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册捕获SIGALRM信号处理函数</span></span><br><span class="line">signal(SIGALRM,sighandler);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tm</span>;</span></span><br><span class="line"><span class="comment">//周期性时间赋值</span></span><br><span class="line">tm.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">tm.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//第一次触发的时间,3秒后每隔1秒发送一次SIGALRM信号</span></span><br><span class="line">tm.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">tm.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setitimer(ITIMER_REAL,&amp;tm,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>alarm函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/21/linux075alarm%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/21/linux075alarm函数/</id>
    <published>2022-01-21T12:20:15.000Z</published>
    <updated>2022-01-21T12:34:18.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="alarm函数"><a class="markdownIt-Anchor" href="#alarm函数"></a> alarm函数</h3><ul><li><p>函数原型：<code>unsigned int alarm(unsigned int seconds);</code></p></li><li><p>函数描述：设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。</p></li><li><p>函数返回值：返回0或剩余的秒数，无失败。例如：</p></li></ul><p><img src="/images/javawz/wps5652.tmp.jpg" alt="img"></p><ul><li>常用操作：取消定时器alarm(0)，返回旧闹钟余下秒数。</li></ul><p>alarm使用的是自然定时法，与进程状态无关，就绪、运行、挂起(阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm都计时。</p><br><p>=============================================================================</p><br><p>练习题1：编写一个程序测试alarm函数</p><p>练习题2：编写程序，测试你的电脑1秒种能数多个数字。</p><ul><li><p>使用time命令查看程序执行的时间。程序运行的瓶颈在于IO，优化程序，首选优化IO。</p></li><li><p>实际执行时间 = 系统时间 + 用户时间 + 损耗时间</p></li></ul><p>损耗的时间主要来来自文件IO操作，IO操作会有用户区到内核区的切换，切换的次数越多越耗时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal函数测试---注册信号处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line">signal(SIGALRM, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = alarm(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"first: n==[%d]\n"</span>, n);</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">n = alarm(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//n = alarm(0); //取消时钟</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"second: n==[%d]\n"</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试1秒钟可以数多少数字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//一秒钟后发送信号</span></span><br><span class="line">alarm(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]"</span>, i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="time命令"><a class="markdownIt-Anchor" href="#time命令"></a> time命令</h3><p>查看程序使用的时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time 程序名</span><br><span class="line"></span><br><span class="line">real   实际执行时间</span><br><span class="line">user    用户时间</span><br><span class="line">sys     系统时间(内核时间)</span><br></pre></td></tr></table></figure><p>实际执行时间 = 系统时间 + 用户时间 + 损耗时间<br>损耗时间= 实际执行时间-(系统时间 + 用户时间 )<br>每一个数字都直接打印:<code>printf(&quot;[%d]\n&quot;, i++);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">real    0m1.217s</span><br><span class="line">user    0m0.120s</span><br><span class="line">sys     0m0.252s</span><br><span class="line">15734次</span><br></pre></td></tr></table></figure><p><code>损耗时间= 1.217-(0.120+0.252)=0.845</code><br>文件重定向之后:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time ./alarm_uncle  &gt; test.log</span><br><span class="line">real    0m1.003s</span><br><span class="line">user    0m0.520s</span><br><span class="line">sys     0m0.428s</span><br><span class="line">2191879次</span><br></pre></td></tr></table></figure><p><code>损耗时间=1.003-(0.520+0.428)=0.055</code><br>原因是: 调用<code>printf</code>函数打印数字遇到<code>\n</code>才会打印, 打印过程涉及到从<br>用户区到内核区的切换, 切换次数越多消耗的时间越长, 效率越低;<br>而使用文件重定向, 由于文件操作是带缓冲的, 所以涉及到用户区到内核区的<br>切换次数大大减少,从而使损耗降低.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;alarm函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#alarm函数&quot;&gt;&lt;/a&gt; alarm函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数原型：&lt;code&gt;unsigned int alarm(unsigned int seco
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>abort函数和raise函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/20/linux074abort%E5%87%BD%E6%95%B0%E5%92%8Craise%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/20/linux074abort函数和raise函数/</id>
    <published>2022-01-20T12:16:22.000Z</published>
    <updated>2022-01-20T13:51:22.352Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>raise函数</p><ul><li><p>函说描述：给当前进程发送指定信号(自己给自己发)</p></li><li><p>函数原型：</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int raise(int sig);</span><br></pre></td></tr></table></figure><ul><li><p>函数返回值：成功：0，失败非0值</p></li><li><p>函数拓展:</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise(signo) == kill(getpid(), signo);</span><br></pre></td></tr></table></figure><ul><li><p>abort函数</p></li><li><p>函数描述：给自己发送异常终止信号 <strong>6) SIGABRT</strong>，并产生core文件</p></li><li><p>函数原型：<code>void abort(void);</code></p></li><li><p>设置core文件大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited//无限制大小</span><br><span class="line">ulimit -x//x代表的是 下面带-的参数,比如-c</span><br><span class="line">yxc19980620c@yc:~/my/demo05$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 15434</span><br><span class="line">max locked memory       (kbytes, -l) 65536</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 15434</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure></li><li><p>函数拓展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abort() == kill(getpid(), SIGABRT);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//raise和abort函数测-</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给当前进程发送SIGINT信号</span></span><br><span class="line">raise(SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给当前进程发送SIGABRT</span></span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;raise函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函说描述：给当前进程发送指定信号(自己给自己发)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>信号相关函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/20/linux073%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/20/linux073信号相关函数/</id>
    <published>2022-01-20T10:38:02.000Z</published>
    <updated>2022-01-20T10:45:23.684Z</updated>
    
    <content type="html"><![CDATA[<h3 id="signal函数"><a class="markdownIt-Anchor" href="#signal函数"></a> signal函数</h3><ul><li><p>函数作用：注册信号捕捉函数</p></li><li><p>函数原型</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line"></span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br></pre></td></tr></table></figure><ul><li><p>函数参数</p><ul><li>signum：信号编号</li><li>handler：信号处理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal函数测试---注册信号处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//while(1)</span></span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="kill函数命令"><a class="markdownIt-Anchor" href="#kill函数命令"></a> kill函数/命令</h3><ul><li><p>描述：给指定进程发送指定信号</p></li><li><p>kill命令：kill -SIGKILL 进程PID</p></li><li><p>kill函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int kill(pid_t pid, int sig);</span><br></pre></td></tr></table></figure></li><li><p>函数返回值：</p><ul><li>成功：0；</li><li>失败：-1，设置errno</li></ul></li><li><p>函数参数：</p><ul><li>sig信号参数：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</li><li>pid参数：</li><li>pid &gt; 0: 发送信号给指定的进程。</li><li>pid = 0: 发送信号给与调用kill函数进程属于同一进程组的所有进程。</li><li>pid &lt; -1:  取|pid|发给对应进程组。</li><li>pid = -1：发送给进程有权限发送的系统中所有进程。</li></ul></li></ul><p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal函数测试---注册信号处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">kill(getpid(), SIGINT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;signal函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#signal函数&quot;&gt;&lt;/a&gt; signal函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数作用：注册信号捕捉函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数原型&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>信号的基本概念</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/20/linux072%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/20/linux072信号的基本概念/</id>
    <published>2022-01-20T08:51:19.000Z</published>
    <updated>2022-01-22T16:21:43.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号介绍"><a class="markdownIt-Anchor" href="#信号介绍"></a> 信号介绍</h2><ul><li>信号的概念</li></ul><p>信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</p><ul><li><p>信号在我们的生活中随处可见，例如：</p><ul><li><p>古代战争中摔杯为号；</p></li><li><p>现代战争中的信号弹;</p></li><li><p>体育比赛中使用的信号枪…</p></li></ul></li><li><p>信号的特点</p><ul><li>简单</li><li>不能携带大量信息</li><li>满足某个特点条件才会产生</li></ul></li></ul><h2 id="2-信号的机制"><a class="markdownIt-Anchor" href="#2-信号的机制"></a> 2 信号的机制</h2><p>进程A给进程B发送信号，进程B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕后再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</p><p><code>每个进程收到的所有信号，都是由内核负责发送的。</code></p><p>进程A给进程B发送信号示意图：</p><p><img src="/images/javawz/wps6534.tmp.jpg" alt="img"></p><p><img src="/images/javawz/image-20220120172232030.png" alt="image-20220120172232030"></p><h3 id="21信号的状态"><a class="markdownIt-Anchor" href="#21信号的状态"></a> 2.1信号的状态</h3><p>信号有三种状态：产生、未决和递达。</p><ul><li><p>信号的产生</p><ul><li>按键产生，如：Ctrl+c(终止进程SIGINT)、Ctrl+z(挂起进程SIGTSTP)、Ctrl+\(退出进程SIGQUIT)</li><li>系统调用产生，如：kill、raise、abort</li><li>软件条件产生，如：定时器alarm</li><li>硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</li><li>命令产生，如：kill命令</li></ul></li><li><p>未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。</p></li><li><p>递达：递送并且到达进程。</p></li></ul><h3 id="22-信号的处理方式"><a class="markdownIt-Anchor" href="#22-信号的处理方式"></a> 2.2 信号的处理方式</h3><ul><li><p>执行默认动作</p></li><li><p>忽略信号(丢弃不处理)</p></li><li><p>捕捉信号(调用用户的自定义的处理函数)</p></li></ul><h3 id="23-信号的特质"><a class="markdownIt-Anchor" href="#23-信号的特质"></a> 2.3 信号的特质</h3><p>信号的实现手段导致信号<code>有很强的延时性</code>，但对于用户来说，时间非常短，不易察觉。</p><p>Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集</strong>。</p><p>注:表示PCB的task_struct结构体定义在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/src/linux-headers-4.4.0-97/include/linux/sched.h:1390</span><br></pre></td></tr></table></figure><h3 id="24-阻塞信号集和未决信号集"><a class="markdownIt-Anchor" href="#24-阻塞信号集和未决信号集"></a> 2.4 阻塞信号集和未决信号集</h3><p>Linux内核的进程控制块PCB是一个结构体，这个结构体里面包含了信号相关的信息，主要有阻塞信号集和未决信号集。</p><ul><li><p>阻塞信号集中保存的都是被当前进程阻塞的信号。若当前进程收到的是阻塞信号集中的某些信号，这些信号需要暂时被阻塞，不予处理。</p></li><li><p>信号产生后由于某些原因(主要是阻塞)不能抵达，这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态；若是信号从阻塞信号集中解除阻塞，则该信号会被处理，并从未决信号集中去除。</p></li></ul><h3 id="25信号的四要素"><a class="markdownIt-Anchor" href="#25信号的四要素"></a> 2.5信号的四要素</h3><ul><li>通过<code>man 7 signal</code>可以查看信号相关信息</li><li>信号编号</li><li>信号的名字</li><li>信号的默认处理(默认终止进程)</li><li>信号如何产生</li></ul><h4 id="1-信号的编号"><a class="markdownIt-Anchor" href="#1-信号的编号"></a> 1 信号的编号</h4><p>使用kill -l命令可以查看当前系统有哪些信号，不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。</p><h4 id="2-信号的名称"><a class="markdownIt-Anchor" href="#2-信号的名称"></a> 2 信号的名称</h4><h4 id="3-产生信号的事件"><a class="markdownIt-Anchor" href="#3-产生信号的事件"></a> 3 产生信号的事件</h4><h4 id="4信号的默认处理动作"><a class="markdownIt-Anchor" href="#4信号的默认处理动作"></a> 4信号的默认处理动作</h4><p><strong>Term</strong>：终止进程</p><p><strong>Ign</strong>：忽略信号 (默认即时对该种信号忽略操作)</p><p><strong>Core</strong>：终止进程，生成Core文件。(查验死亡原因，用于gdb调试)</p><p><strong>Stop</strong>：停止（暂停）进程</p><p><strong>Cont</strong>：继续运行进程</p><ul><li><p>特别需要注意的是：The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.(无法捕获、阻止或忽略信号SIGKILL和SIGSTOP。)</p></li><li><p>几个常用到的信号</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">SIGINT、SIGQUIT、SIGKILL、SIGSEGV、SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM、SIGTERM、SIGCHLD、SIGSTOP、SIGCONT</span><br><span class="line"></span><br><span class="line">SIGHUP        1       A     在控制终端上是挂起信号, 或者控制进程结束</span><br><span class="line">SIGINT        2       A     从键盘输入的中断</span><br><span class="line">SIGQUIT       3       C     从键盘输入的退出</span><br><span class="line">SIGILL        4       C     无效硬件指令</span><br><span class="line">SIGABRT       6       C     非正常终止, 可能来自 abort(3)</span><br><span class="line">SIGFPE        8       C     浮点运算例外</span><br><span class="line">SIGKILL       9      AEF    杀死进程信号</span><br><span class="line">SIGSEGV      11       C     无效的内存引用</span><br><span class="line">SIGPIPE      13       A     管道中止: 写入已经关闭读取的管道</span><br><span class="line">SIGALRM      14       A     来自 alarm(2) 的超时信号</span><br><span class="line">SIGTERM      15       A     终止信号</span><br><span class="line">SIGUSR1   30,10,16    A     用户定义的信号 1</span><br><span class="line">SIGUSR2   31,12,17    A     用户定义的信号 2</span><br><span class="line">SIGCHLD   20,17,18    B     子进程结束或停止</span><br><span class="line">SIGCONT   19,18,25          继续停止的进程</span><br><span class="line">SIGSTOP   17,19,23   DEF    停止进程</span><br><span class="line">SIGTSTP   18,20,24    D     终端上发出的停止信号</span><br><span class="line">SIGTERM      15       A     终止信号</span><br><span class="line">SIGUSR1   30,10,16    A     用户定义的信号 1</span><br><span class="line">SIGUSR2   31,12,17    A     用户定义的信号 2</span><br><span class="line">SIGCHLD   20,17,18    B     子进程结束或停止</span><br><span class="line">SIGFPE        8       C     浮点运算例外</span><br><span class="line">SIGABRT       6       C     非正常终止, 可能来自 abort(3)</span><br><span class="line">SIGQUIT       3       C     从键盘输入的退出</span><br><span class="line">SIGILL        4       C     无效硬件指令</span><br><span class="line">SIGABRT       6       C     非正常终止, 可能来自 abort(3)</span><br><span class="line">SIGFPE        8       C     浮点运算例外</span><br><span class="line">SIGKILL       9      AEF    杀死进程信号</span><br><span class="line">SIGSEGV      11       C     无效的内存引用</span><br><span class="line">SIGPIPE      13       A     管道中止: 写入无人读取的管道</span><br><span class="line">SIGALRM      14       A     来自 alarm(2) 的超时信号</span><br><span class="line">SIGTERM      15       A     终止信号</span><br><span class="line">SIGUSR1   30,10,16    A     用户定义的信号 1</span><br><span class="line">SIGUSR2   31,12,17    A     用户定义的信号 2</span><br><span class="line">SIGCHLD   20,17,18    B     子进程结束或停止</span><br><span class="line">SIGCONT   19,18,25          继续停止的进程</span><br><span class="line">SIGSTOP   17,19,23   DEF    停止进程</span><br><span class="line">SIGTSTP   18,20,24    D     终端上发出的停止信号</span><br><span class="line">SIGTTIN   21,21,26    D     后台进程试图从控制终端(tty)输入</span><br><span class="line">SIGTTOU   22,22,27    D     后台进程试图在控制终端(tty)输出</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;信号介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#信号介绍&quot;&gt;&lt;/a&gt; 信号介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;信号的概念&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>第二章物理层</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/20/第二章物理层/</id>
    <published>2022-01-19T17:14:47.000Z</published>
    <updated>2022-01-23T18:36:47.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="物理层定义的标准"><a class="markdownIt-Anchor" href="#物理层定义的标准"></a> 物理层定义的标准</h3><p>1.物理层解决如何在连接各种计算机的传输媒体上传输数据比特流 （0101…）。<br>物理层的主要任务：确定传输媒体的接口的一些特性：<br>1）机械特性：接口形状，大小，引线数目。<br>2）电气特性：规定电压范围（-5V到5V）。<br>3）功能特性：例如规定-5V是0，+5V是1.<br>4)过程特性：（规程特性）规定建立连接时各个相关部件的工作步骤(比如一个大可乐瓶和一个小可乐瓶,他们的瓶盖都是通用的,说明接口一样大小)。</p><h3 id="数据通信基础知识"><a class="markdownIt-Anchor" href="#数据通信基础知识"></a> 数据通信基础知识</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;物理层定义的标准&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#物理层定义的标准&quot;&gt;&lt;/a&gt; 物理层定义的标准&lt;/h3&gt;
&lt;p&gt;1.物理层解决如何在连接各种计算机的传输媒体上传输数据比特流 （0101…）。&lt;br&gt;
物理层的主要任务：确
      
    
    </summary>
    
      <category term="计算机网络原理" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>内存映射区</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/19/linux071%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/19/linux071内存映射区/</id>
    <published>2022-01-19T11:37:10.000Z</published>
    <updated>2022-01-19T16:36:41.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="存储映射区介绍"><a class="markdownIt-Anchor" href="#存储映射区介绍"></a> 存储映射区介绍</h3><p>​存储映射<code>I/O (Memory-mapped I/O)</code>使一个磁盘文件与存储空间中的一个缓冲区相映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样，就可在不使用read和write函数的情况下，使用地址（指针）完成I/O操作。</p><p>使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。</p><img src="/images/javawz/image-20220119222706887.png" height="140%" width="35%"><h3 id="mmap函数"><a class="markdownIt-Anchor" href="#mmap函数"></a> mmap函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br></pre></td></tr></table></figure><h4 id="函数作用"><a class="markdownIt-Anchor" href="#函数作用"></a> 函数作用:</h4><p>建立存储映射区</p><h4 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> 函数原型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br></pre></td></tr></table></figure><h4 id="函数返回值"><a class="markdownIt-Anchor" href="#函数返回值"></a> 函数返回值：</h4><p>成功：返回创建的映射区首地址；</p><p>失败：<code>MAP_FAILED</code>宏 并设置errno</p><h4 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数：</h4><p>addr: 指定映射的起始地址, 通常设为NULL, 由系统指定</p><p>length：映射到内存的文件长度</p><p>prot：映射区的保护方式, 最常用的:</p><p>读：<code>PROT_READ</code></p><p>写：<code>PROT_WRITE</code></p><p>读写：<code>PROT_READ | PROT_WRITE</code></p><p>flags：映射区的特性, 可以是</p><p><code>MAP_SHARED</code>: 写入映射区的数据会写回文件, 且允许其他映射该文件的进程共享。</p><p><code>MAP_PRIVATE</code>: 对映射区的写入操作会产生一个映射区的复制(copy-on-write), 对此区域所做的修改不会写回原文件。</p><p>fd：由open返回的文件描述符, 代表要映射的文件。</p><p>offset：以文件开始处的偏移量, <strong>必须是4k的整数倍</strong>, 通常为0, 表示从文件头开始映射。</p><h3 id="munmap函数"><a class="markdownIt-Anchor" href="#munmap函数"></a> munmap函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br></pre></td></tr></table></figure><h4 id="函数作用-2"><a class="markdownIt-Anchor" href="#函数作用-2"></a> 函数作用:</h4><p>释放由mmap函数建立的存储映射区</p><h4 id="函数原型-2"><a class="markdownIt-Anchor" href="#函数原型-2"></a> 函数原型:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int munmap(void *addr, size_t length);</span><br></pre></td></tr></table></figure><h4 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值：</h4><p>成功：返回0</p><p>失败：返回-1，设置errno值</p><h4 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数:</h4><p>addr：调用mmap函数成功返回的映射区首地址</p><p>length：映射区大小（mmap函数的第二个参数）</p><h4 id="mmap注意事项"><a class="markdownIt-Anchor" href="#mmap注意事项"></a> mmap注意事项</h4><p>创建映射区的过程中，隐含着一次对映射文件的读操作，将文件内容读取到映射区</p><p>当MAP_SHARED时，要求：映射区的权限应 &lt;=文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</p><p>映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭。</p><p>特别注意，当映射文件大小为0时，不能创建映射区。所以，用于映射的文件必须要有实际大小；mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。</p><p>munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。</p><p>文件偏移量必须为0或者4K的整数倍</p><p>mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</p><h4 id="有关mmap函数的使用总结"><a class="markdownIt-Anchor" href="#有关mmap函数的使用总结"></a> 有关mmap函数的使用总结</h4><p>第一个参数写成NULL</p><p>第二个参数要映射的文件大小 &gt; 0</p><p>第三个参数：PROT_READ 、PROT_WRITE</p><p>第四个参数：MAP_SHARED 或者 MAP_PRIVATE</p><p>第五个参数：打开的文件对应的文件描述符</p><p>第六个参数：4k的整数倍</p><h4 id="mmap函数相关思考题"><a class="markdownIt-Anchor" href="#mmap函数相关思考题"></a> mmap函数相关思考题</h4><p>可以open的时候O_CREAT一个新文件来创建映射区吗?</p><p>答:不可以,因为刚刚创建出来的文件大小是0</p><p>如果open时O_RDONLY, mmap时PROT参数指定<code>PROT_READ|PROT_WRITE</code>会怎样？</p><p>答:open的权限应该大于等于mmap</p><p>mmap映射完成之后, 文件描述符关闭，对mmap映射有没有影响？</p><p>答:没有影响</p><p>如果文件偏移量为1000会怎样？</p><p>答:必须为4K的整倍数</p><p>对mem越界操作会怎样？</p><p>答:出错</p><p>如果<code>mem++</code>，munmap可否成功？</p><p>答:出错</p><p>mmap什么情况下会调用失败？</p><p>答:指定错误参数或内存不足的时候</p><p>如果不检测mmap的返回值，会怎样？</p><p>答:如果mmap返回的是-1,而又不检测,从而会使用错误的指针</p><h4 id="mmap应用练习"><a class="markdownIt-Anchor" href="#mmap应用练习"></a> mmap应用练习</h4><p>练习1：使用mmap完成对文件的读写操作</p><p>练习:2：使用mmap完成父子进程间通信</p><p>图解说明</p><p><img src="/images/javawz/wps1FD2.tmp.jpg" alt="img"></p><p>思路</p><p>调用mmap函数创建存储映射区，返回映射区首地址ptr</p><p>调用fork函数创建子进程，子进程也拥有了映射区首地址</p><p>父子进程可以通过映射区首地址指针ptr完成通信</p><p>调用munmap函数释放存储映射区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用mmap函数完成父子进程间通信</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line"><span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./test.log"</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//void * addr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);</span></span><br><span class="line"><span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(addr, <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%s]"</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习3：使用mmap完成没有血缘关系的进程间通</p><p>思路：两个进程都打开相同的文件，然后调用mmap函数建立存储映射区，这样两个进程共享同一个存储映射区。</p><h4 id="mmap_read"><a class="markdownIt-Anchor" href="#mmap_read"></a> mmap_read</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用mmap函数完成两个不相干进程间通信</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line"><span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./test.log"</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立共享映射区</span></span><br><span class="line"><span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">memcpy</span>(buf, addr, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf=[%s]\n"</span>, buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mmap_write"><a class="markdownIt-Anchor" href="#mmap_write"></a> mmap_write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用mmap函数完成两个不相干进程间通信</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line"><span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./test.log"</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立共享映射区</span></span><br><span class="line"><span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(addr, <span class="string">"0123456789"</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用mmap函数建立匿名映射"><a class="markdownIt-Anchor" href="#使用mmap函数建立匿名映射"></a> 使用mmap函数建立匿名映射：</h4><p>必须是有血缘关系之间的进程使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br></pre></td></tr></table></figure><p><code>MAP_ANONYMOUS</code>必须和<code>MAP_SHARED</code>一起使用，而且fd指定为-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用mmap匿名映射完成父子进程间通信</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line"><span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"><span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(addr, <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%s]"</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;存储映射区介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#存储映射区介绍&quot;&gt;&lt;/a&gt; 存储映射区介绍&lt;/h3&gt;
&lt;p&gt;​	存储映射&lt;code&gt;I/O (Memory-mapped I/O)&lt;/code&gt;使一个磁盘文件与存储空间中的一
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>fifo函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/17/linux070fifo%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/17/linux070fifo函数/</id>
    <published>2022-01-17T10:59:33.000Z</published>
    <updated>2022-01-17T17:01:09.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fifo介绍"><a class="markdownIt-Anchor" href="#fifo介绍"></a> FIFO介绍</h3><p><strong>FIFO常被称为命名管道</strong>，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间通信。<strong>但通过FIFO，不相关的进程也能交换数据。</strong></p><p>​FIFO是Linux基础文件类型中的一种（文件类型为p，可通过ls -l查看文件类型）。但FIFO文件在磁盘上没有数据块，文件大小为0，仅仅用来标识内核中一条通道。进程可以打开这个文件进行read/write，实际上是在读写内核缓冲区，这样就实现了进程间通信。</p><h3 id="创建管道"><a class="markdownIt-Anchor" href="#创建管道"></a> 创建管道</h3><h4 id="方式1-使用命令-mkfifo"><a class="markdownIt-Anchor" href="#方式1-使用命令-mkfifo"></a> 方式1-使用命令 mkfifo</h4><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo 管道名</span><br></pre></td></tr></table></figure><p>例如：mkfifo myfifo</p><h4 id="方式2-使用函数"><a class="markdownIt-Anchor" href="#方式2-使用函数"></a> 方式2-使用函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">参数一是文件名</span><br><span class="line">参数2是文件权限</span><br><span class="line">成功返回0</span><br><span class="line">失败返回-1并设置errno</span><br></pre></td></tr></table></figure><p>参数说明和返回值可以查看man 3 mkfifo</p><p>当创建了一个FIFO，就可以使用open函数打开它，常见的文件I/O函数都可用于FIFO。如：close、read、write、unlink等。</p><p>FIFO严格遵循先进先出（first in first out），对FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。<strong>它们不支持诸如lseek()等文件定位操作。</strong></p><h3 id="access函数"><a class="markdownIt-Anchor" href="#access函数"></a> access函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br></pre></td></tr></table></figure><p>函数声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int access(const char* pathname, int mode);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F_OK 值为0，判断文件是否存在</span><br><span class="line"> </span><br><span class="line">X_OK 值为1，判断对文件是可执行权限</span><br><span class="line"> </span><br><span class="line">W_OK 值为2，判断对文件是否有写权限</span><br><span class="line"> </span><br><span class="line">R_OK 值为4，判断对文件是否有读权限</span><br><span class="line"> </span><br><span class="line">注：后三种可以使用或“|”的方式，一起使用，如W_OK|R_OK</span><br></pre></td></tr></table></figure><p>返回值：成功0，失败-1</p><h3 id="使用fifo完成两个进程通信"><a class="markdownIt-Anchor" href="#使用fifo完成两个进程通信"></a> 使用FIFO完成两个进程通信</h3><p>使用FIFO完成两个进程通信的示意图</p><p><img src="/images/javawz/wps1DAE.tmp.jpg" alt="img"></p><h3 id="fifo_writec"><a class="markdownIt-Anchor" href="#fifo_writec"></a> fifo_write.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = access(<span class="string">"./myfifo"</span>,F_OK);<span class="comment">//判断文件是否存在</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//创建管道文件</span></span><br><span class="line">ret = mkfifo(<span class="string">"myfifo"</span>,<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"mkfifo error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开管道文件</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./myfifo"</span>,O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建缓冲区并且初始化为0</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">"%d hello\n"</span>,++i);</span><br><span class="line">        <span class="comment">//写数据到管道文件</span></span><br><span class="line">write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fifo_readc"><a class="markdownIt-Anchor" href="#fifo_readc"></a> fifo_read.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//打开管道文件</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./myfifo"</span>,O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//读管道文件</span></span><br><span class="line">len = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"len[%d]  %s"</span>,len,buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;fifo介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fifo介绍&quot;&gt;&lt;/a&gt; FIFO介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;FIFO常被称为命名管道&lt;/strong&gt;，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
</feed>
