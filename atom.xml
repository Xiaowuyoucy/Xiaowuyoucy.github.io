<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanChen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowuyoucy.github.io/"/>
  <updated>2022-01-14T16:10:22.065Z</updated>
  <id>https://xiaowuyoucy.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第一章计算机网络概述</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/14/计算机网络概述/</id>
    <published>2022-01-13T16:56:27.000Z</published>
    <updated>2022-01-14T16:10:22.065Z</updated>
    
    <content type="html"><![CDATA[<h3 id="局域网"><a class="markdownIt-Anchor" href="#局域网"></a> 局域网</h3><p><img src="/images/javawz/image-20220114011444766.png" alt="image-20220114011444766"></p><p>每一间课室的电脑都连接到同一台交换机上,楼道上会形成很多网线,不雅观</p><p><img src="/images/javawz/image-20220114012723065.png" alt="image-20220114012723065"></p><p>电脑到交换机距离的网线不超过100米，交换机到交换机的网线也不超过一百米</p><p><img src="/images/javawz/image-20220114013131827.png" alt="image-20220114013131827"></p><p>接入层交换机的接口比较多，汇聚层的接口比较少，但要求输入和输出的带宽高</p><p><img src="/images/javawz/image-20220114013417969.png" alt="image-20220114013417969"></p><p>中间的网线承担了两个课室的流量，不规范</p><p>总结：局域网覆盖范围小，自己花钱买设备带宽固定，自己维护</p><h3 id="intenet和广域网"><a class="markdownIt-Anchor" href="#intenet和广域网"></a> Intenet和广域网</h3><p><img src="/images/javawz/image-20220114014449047.png" alt="image-20220114014449047"></p><p>Intenet有很多 IPS运营商组成，他们都有自己的机房，对网民提供访问Internet连接（可以是ADSL或光纤）</p><p>广域网：距离远（可以超过100米） 花钱租带宽</p><p>我们买的带宽是指从我们这里到运营商那一段的带宽，比如我们拉了100兆的网线，意思就是从我们这里到运营商接口那里是100兆的</p><p>公网地址是全球唯一的，不会重复</p><h3 id="规划ip地址介绍mac地址"><a class="markdownIt-Anchor" href="#规划ip地址介绍mac地址"></a> 规划IP地址介绍MAC地址</h3><p><img src="/images/javawz/image-20220114020833334.png" alt="image-20220114020833334"></p><p>一般路由器地址是自己网段的第一个地址</p><p>例如自己网段是13.0.0.0 路由器地址就是13.0.0.1</p><p>MAC地址：网卡生产时的物理地址，48位二进制表示，也是全球唯一，不重复的</p><p>网关: 数据到其他网段需要给的机器(一般是路由器)</p><p>DNS：解析域名的服务器，比如我们打开<code>www.baidu.com</code>，电脑会先请求DNS服务器，然后DNS服务器会返回一个域名对应的ip地址回来</p><h3 id="数据包和数据帧"><a class="markdownIt-Anchor" href="#数据包和数据帧"></a> 数据包和数据帧</h3><p><img src="/images/javawz/image-20220114022359765.png" alt="image-20220114022359765"></p><p><img src="/images/javawz/image-20220114022439593.png" alt="image-20220114022439593"></p><p>IP地址决定最后给谁</p><p>MAC地址决定下一跳给谁</p><p>数据包最大1500字节,如果数据超过1500个字节会切片,然后给每个数据包编号</p><h3 id="访问网站数据传输过程"><a class="markdownIt-Anchor" href="#访问网站数据传输过程"></a> 访问网站数据传输过程</h3><p><img src="/images/javawz/image-20220114023846946.png" alt="image-20220114023846946"></p><p>网站服务器收到请求之后会将网页打包成很多数据包，每个数据包都有编号，然后再一个个放到网卡缓存里，每个数据包都有源ip地址，目标ip地址，源mac地址和目标mac地址。</p><p>数据包发送到客户机网卡的缓存之后，客户机会发送接收下一个数据包的请求，然后服务器收到之后会将上一个发送的数据包删除掉，再发下一个数据包。</p><p>客户机会一边接收数据包，一边将数据包排好序一个个的显示出来，最终形成一个网页</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;局域网&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#局域网&quot;&gt;&lt;/a&gt; 局域网&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/image-20220114011444766.png&quot; alt=&quot;image-2022
      
    
    </summary>
    
      <category term="计算机网络原理" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>进程回收函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/12/linux063%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/12/linux063进程回收函数/</id>
    <published>2022-01-12T08:07:38.000Z</published>
    <updated>2022-01-12T17:59:27.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="wait函数"><a class="markdownIt-Anchor" href="#wait函数"></a> wait函数</h3><h4 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br></pre></td></tr></table></figure><h4 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> 函数原型：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t wait(int *status);</span><br></pre></td></tr></table></figure><h4 id="函数作用"><a class="markdownIt-Anchor" href="#函数作用"></a> 函数作用：</h4><p>阻塞并等待子进程退出</p><p>回收子进程残留资源</p><p>获取子进程结束状态(退出原因)。</p><h4 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值：</h4><p>成功：清理掉的子进程ID；</p><p>失败：-1 (没有子进程)</p><p>status参数：子进程的退出状态 – 传出参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WIFEXITED(status)：为非0    → 进程正常结束</span><br><span class="line"></span><br><span class="line">WEXITSTATUS(status)：获取进程退出状态 </span><br><span class="line"></span><br><span class="line">WIFSIGNALED(status)：为非0 → 进程异常终止</span><br><span class="line"></span><br><span class="line">WTERMSIG(status)：取得进程终止的信号编号。</span><br></pre></td></tr></table></figure><p>wait函数练习</p><p>使用wait函数完成父进程对子进程的回收</p><h3 id="waitpid函数"><a class="markdownIt-Anchor" href="#waitpid函数"></a> waitpid函数</h3><h4 id="头文件-2"><a class="markdownIt-Anchor" href="#头文件-2"></a> 头文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br></pre></td></tr></table></figure><h4 id="函数原型-2"><a class="markdownIt-Anchor" href="#函数原型-2"></a> 函数原型：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid, int *status, in options);</span><br></pre></td></tr></table></figure><h4 id="函数作用-2"><a class="markdownIt-Anchor" href="#函数作用-2"></a> 函数作用</h4><p>同wait函数</p><h4 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数</h4><p>参数：</p><p>pid：</p><p>pid = -1 等待任意一个子进程。与wait等效。</p><p>pid &gt; 0 等待其进程ID与pid相等的子进程。等待指定的pid</p><p>pid = 0 等待进程组ID与目前进程相同的任何子进程，也就是说任何和调用</p><p>waitpid()函数的进程在同一个进程组的进程。</p><p>pid &lt; -1 等待其组ID等于pid的绝对值的任一子进程。(适用于子进程在其他组的情况)</p><p>status: 子进程的退出状态，用法同wait函数。</p><p>options：设置为WNOHANG，函数非阻塞，设置为0，函数阻塞。</p><h5 id="调用一次wait或waitpid只能回收一个子进程"><a class="markdownIt-Anchor" href="#调用一次wait或waitpid只能回收一个子进程"></a> <code>调用一次wait或waitpid只能回收一个子进程</code></h5><h4 id="函数返回值"><a class="markdownIt-Anchor" href="#函数返回值"></a> 函数返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;0：返回回收掉的子进程ID；</span><br><span class="line"></span><br><span class="line">-1：无子进程</span><br><span class="line"></span><br><span class="line">=0：参3为WNOHANG，且子进程正在运行。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父进程调用wait函数完成对子进程的回收</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) <span class="comment">//fork失败的情况</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: [%d], pid==[%d], fpid==[%d]\n"</span>, pid, getpid(),getppid());</span><br><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">pid_t</span> wpid = wait(&amp;status);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"wpid==[%d]\n"</span>, wpid);</span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(status)) <span class="comment">//正常退出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child normal exit, status==[%d]\n"</span>, WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status)) <span class="comment">//被信号杀死</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child killed by signal, signo==[%d]\n"</span>, WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: pid==[%d], fpid==[%d]\n"</span>, getpid(), getppid());</span><br><span class="line">sleep(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) <span class="comment">//fork失败的情况</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: [%d], pid==[%d], fpid==[%d]\n"</span>, pid, getpid(),getppid());</span><br><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="comment">//pid_t wpid = wait(&amp;status);</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">pid_t</span> wpid = waitpid(<span class="number">-1</span>,&amp;status,WNOHANG);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf("wpid==[%d]\n", wpid);</span></span><br><span class="line">        <span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status)) <span class="comment">//正常退出</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child normal exit, status==[%d]\n"</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status)) <span class="comment">//被信号杀死</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child killed by signal, signo==[%d]\n"</span>, WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(wpid == <span class="number">0</span>) <span class="comment">//子进程还活着</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">// printf("child is living,wpid[%d]\n",wpid);</span></span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(wpid == <span class="number">-1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"no child is living wpid[%d]\n"</span>,wpid);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: pid==[%d], fpid==[%d]\n"</span>, getpid(), getppid());</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sleep函数"><a class="markdownIt-Anchor" href="#sleep函数"></a> sleep函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep(5);//表示睡眠5秒</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;wait函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#wait函数&quot;&gt;&lt;/a&gt; wait函数&lt;/h3&gt;
&lt;h4 id=&quot;头文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#头文件&quot;&gt;&lt;/a&gt; 头文件&lt;
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>孤儿进程和僵尸进程</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/12/linux062%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/12/linux062孤儿进程和僵尸进程/</id>
    <published>2022-01-12T07:24:59.000Z</published>
    <updated>2022-01-12T07:32:54.843Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要进行进程资源的回收"><a class="markdownIt-Anchor" href="#为什么要进行进程资源的回收"></a> 为什么要进行进程资源的回收</h4><p>当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB资源，必须由它的父进程调用wait或者waitpid函数完成对子进程的回收，避免造成系统资源的浪费。</p><h3 id="孤儿进程"><a class="markdownIt-Anchor" href="#孤儿进程"></a> 孤儿进程</h3><h4 id="孤儿进程的概念"><a class="markdownIt-Anchor" href="#孤儿进程的概念"></a> 孤儿进程的概念：</h4><p>若子进程的父进程已经死掉，而子进程还存活着，这个进程就成了孤儿进程。</p><p>为了保证每个进程都有一个父进程，孤儿进程会被init进程领养，init进程成为了孤儿进程的养父进程，当孤儿进程退出之后，由init进程完成对孤儿进程的回收。</p><h4 id="模拟孤儿进程的案例"><a class="markdownIt-Anchor" href="#模拟孤儿进程的案例"></a> 模拟孤儿进程的案例</h4><p>编写模拟孤儿进程的代码讲解孤儿进程，验证孤儿进程的父进程是否由原来的父进程变成了init进程。</p><h3 id="僵尸进程"><a class="markdownIt-Anchor" href="#僵尸进程"></a> 僵尸进程</h3><h4 id="僵尸进程的概念"><a class="markdownIt-Anchor" href="#僵尸进程的概念"></a> 僵尸进程的概念:</h4><p>若子进程死了，父进程还活着， 但是父进程没有调用wait或waitpid函数完成对子进程的回收，则该子进程就成了僵尸进程。</p><h4 id="如何解决僵尸进程"><a class="markdownIt-Anchor" href="#如何解决僵尸进程"></a> 如何解决僵尸进程</h4><p>由于僵尸进程是一个已经死亡的进程，所以不能使用kill命令将其杀死</p><p>通过杀死其父进程的方法可以消除僵尸进程。</p><p>杀死其父进程后，这个僵尸进程会被init进程领养，由init进程完成对僵尸进程的回收。</p><h4 id="模拟僵尸进程的案例"><a class="markdownIt-Anchor" href="#模拟僵尸进程的案例"></a> 模拟僵尸进程的案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//孤儿进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) <span class="comment">//fork失败的情况</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: [%d], pid==[%d], fpid==[%d]\n"</span>, pid, getpid(),getppid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: pid==[%d], fpid==[%d]\n"</span>, getpid(), getppid());</span><br><span class="line">sleep(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: pid==[%d], fpid==[%d]\n"</span>, getpid(), getppid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//僵尸进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) <span class="comment">//fork失败的情况</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: [%d], pid==[%d], fpid==[%d]\n"</span>, pid, getpid(),getppid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: pid==[%d], fpid==[%d]\n"</span>, getpid(), getppid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写模拟僵尸进程的代码讲解僵尸进程, 验证若子进程先于父进程退出, 而父进程没有调用wait或者waitpid函数进行回收, 从而使子进程成为了僵尸进程.</p><p>孤儿进程: 父进程先退出, 子进程就变成了孤儿进程, 此时被init进程领养,<br>当孤儿进程退出之后, 就会被init进程回收.</p><p>僵尸进程: 子进程先退出, 父进程没有完成对子进程的回收, 此时子进程就变成了僵尸进程.<br>如何解决僵尸进程:<br>不能使用kill -9杀死僵尸进程, 原因是僵尸进程是一个死掉的进程;<br>应该使用杀死僵尸进程父进程的方法来解决僵尸进程;<br>原因是: 杀死其父进程可以让init进程领养僵尸进程,最后由init进程回收僵尸进程.</p><p><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要进行进程资源的回收&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么要进行进程资源的回收&quot;&gt;&lt;/a&gt; 为什么要进行进程资源的回收&lt;/h4&gt;
&lt;p&gt;当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PC
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>exec函数族</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/12/linux061exec%E5%87%BD%E6%95%B0%E6%97%8F/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/12/linux061exec函数族/</id>
    <published>2022-01-12T07:02:22.000Z</published>
    <updated>2022-01-12T07:24:05.348Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数作用和函数介绍"><a class="markdownIt-Anchor" href="#函数作用和函数介绍"></a> 函数作用和函数介绍</h4><p>有的时候需要在一个进程里面执行其他的命令或者是用户自定义的应用程序，此时就用到了exec函数族当中的函数。</p><p>使用方法一般都是在父进程里面调用fork创建处子进程，然后在子进程里面调用exec函数。</p><h3 id="execl函数"><a class="markdownIt-Anchor" href="#execl函数"></a> execl函数</h3><p>函数原型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, ... /* (char  *) NULL */);</span><br></pre></td></tr></table></figure><p>参数介绍：</p><p>path: 要执行的程序的绝对路径</p><p>变参arg: 要执行的程序的需要的参数</p><p>arg:占位，通常写应用程序的名字</p><p>arg后面的: 命令的参数</p><p>参数写完之后: NULL</p><p>返回值：若是成功，则不返回，不会再执行exec函数后面的代码；若是失败，会执行execl后面的代码，可以用perror打印错误原因。</p><p>execl函数一般执行自己写的程序。</p><h4 id="execlp函数"><a class="markdownIt-Anchor" href="#execlp函数"></a> execlp函数</h4><p>函数原型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int execlp(const char *file, const char *arg, .../* (char  *) NULL */);</span><br></pre></td></tr></table></figure><p>参数介绍：</p><p>file: 执行命令的名字, 根据PATH环境变量来搜索该命令</p><p>arg:占位</p><p>arg后面的: 命令的参数</p><p>参数写完之后: NULL</p><p>返回值：若是成功，则不返回，不会再执行exec函数后面的代码；若是失败，会执行exec后面的代码，可以用perror打印错误原因。</p><p>execlp函数一般是执行系统自带的程序或者是命令.</p><h4 id="exec函数族原理介绍"><a class="markdownIt-Anchor" href="#exec函数族原理介绍"></a> exec函数族原理介绍</h4><p>exec族函数的实现原理图：</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execlp(“ls”, “ls”, “-l”, NULL);</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220112151630526.png" alt="image-20220112151630526"></p><p>总结：</p><p>exec函数是用一个新程序替换了当前进程的代码段、数据段、堆和栈；原有的进程空间没有发生变化，并没有创建新的进程，进程PID没有发生变化。</p><p>如果想在一个进程内部执行系统命令或者是应用程序, 优先应该想到如下方式:</p><p>先fork(), 然后在子进程里面执行execl拉起可执行程序或者命令.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid = fork();</span><br><span class="line">if(pid==0)</span><br><span class="line">&#123;</span><br><span class="line">execl(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execl: 一般用于执行用户自定义的应用程序.<br>execp: 一般用于执行系统命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fork函数测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) <span class="comment">//fork失败的情况</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: [%d], pid==[%d], fpid==[%d]\n"</span>, pid, getpid(),getppid());</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: pid==[%d], fpid==[%d]\n"</span>, getpid(), getppid());</span><br><span class="line"><span class="comment">//execl("/bin/ls", "ls", "-l", NULL);</span></span><br><span class="line"><span class="comment">//execl("./test", "test", "hello", "world", "ni", "hao", NULL);</span></span><br><span class="line"><span class="comment">//execlp("ls", "ls", "-l", NULL);</span></span><br><span class="line">execlp(<span class="string">"./test"</span>, <span class="string">"TESTING"</span>, <span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"ni"</span>, <span class="string">"hao"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//execlp("./iitest", "test", "hello", "world", "ni", "hao", NULL);</span></span><br><span class="line">perror(<span class="string">"execl error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;函数作用和函数介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数作用和函数介绍&quot;&gt;&lt;/a&gt; 函数作用和函数介绍&lt;/h4&gt;
&lt;p&gt;有的时候需要在一个进程里面执行其他的命令或者是用户自定义的应用程序，此时就用到了exec函数族当中的函
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ps和kill命令</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/12/linux060ps%E5%92%8Ckill%E5%91%BD%E4%BB%A4/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/12/linux060ps和kill命令/</id>
    <published>2022-01-12T06:47:50.000Z</published>
    <updated>2022-01-12T06:51:59.541Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep &quot;xxx&quot;</span><br><span class="line"></span><br><span class="line">ps ajx | grep &quot;xxx&quot;</span><br></pre></td></tr></table></figure><p>-a：（all）当前系统所有用户的进程</p><p>-u：查看进程所有者及其他一些信息</p><p>-x：显示没有控制终端的进程 – 不能与用户进行交互的进程【输入、输出】</p><p>-j: 列出与作业控制相关的信息</p><p>kill -l 查看系统有哪些信号</p><p>kill -9 pid 杀死某个线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-A 显示所有进程（等价于-e）(utility)</span><br><span class="line">-a 显示一个终端的所有进程，除了会话引线</span><br><span class="line">-N 忽略选择。</span><br><span class="line">-d 显示所有进程，但省略所有的会话引线(utility)</span><br><span class="line">-x 显示没有控制终端的进程，同时显示各个命令的具体路径。dx不可合用。（utility）</span><br><span class="line">-p pid 进程使用cpu的时间</span><br><span class="line">-u uid or username 选择有效的用户id或者是用户名</span><br><span class="line">-g gid or groupname 显示组的所有进程。</span><br><span class="line">U username 显示该用户下的所有进程，且显示各个命令的详细路径。如:ps U zhang;(utility)</span><br><span class="line">-f 全部列出，通常和其他选项联用。如：ps -fa or ps -fx and so on.</span><br><span class="line">-l 长格式（有F,wchan,C 等字段）</span><br><span class="line">-j 作业格式</span><br><span class="line">-o 用户自定义格式。</span><br><span class="line">v 以虚拟存储器格式显示</span><br><span class="line">s 以信号格式显示</span><br><span class="line">-m 显示所有的线程</span><br><span class="line">-H 显示进程的层次(和其它的命令合用，如：ps -Ha)（utility）</span><br><span class="line">e 命令之后显示环境（如：ps -d e; ps -a e）(utility)</span><br><span class="line">h 不显示第一行</span><br><span class="line"></span><br><span class="line">ps命令常用用法（方便查看系统进程）</span><br><span class="line"></span><br><span class="line">1）ps a 显示现行终端机下的所有程序，包括其他用户的程序。</span><br><span class="line">2）ps -A 显示所有进程。</span><br><span class="line">3）ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。</span><br><span class="line">4）ps -e 此参数的效果和指定&quot;A&quot;参数相同。</span><br><span class="line">5）ps e 列出程序时，显示每个程序所使用的环境变量。</span><br><span class="line">6）ps f 用ASCII字符显示树状结构，表达程序间的相互关系。</span><br><span class="line">7）ps -H 显示树状结构，表示程序间的相互关系。</span><br><span class="line">8）ps -N 显示所有的程序，除了执行ps指令终端机下的程序之外。</span><br><span class="line">9）ps s 采用程序信号的格式显示程序状况。</span><br><span class="line">10）ps S 列出程序时，包括已中断的子程序资料。</span><br><span class="line">11）ps -t&lt;终端机编号&gt; 　指定终端机编号，并列出属于该终端机的程序的状况。</span><br><span class="line">12）ps u 　以用户为主的格式来显示程序状况。</span><br><span class="line">13）ps x 　显示所有程序，不以终端机来区分。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">USER    用户名</span><br><span class="line">UID    用户ID（User ID）</span><br><span class="line">PID    进程ID（Process ID）</span><br><span class="line">PPID    父进程的进程ID（Parent Process id）</span><br><span class="line">SID    会话ID（Session id）</span><br><span class="line">%CPU    进程的cpu占用率</span><br><span class="line">%MEM    进程的内存占用率</span><br><span class="line">VSZ    进程所使用的虚存的大小（Virtual Size）</span><br><span class="line">RSS    进程使用的驻留集大小或者是实际内存的大小，Kbytes字节。</span><br><span class="line">TTY    与进程关联的终端（tty）</span><br><span class="line">STAT    进程的状态：进程状态使用字符表示的（STAT的状态码）</span><br><span class="line">R 运行    Runnable (on run queue)            正在运行或在运行队列中等待。</span><br><span class="line">S 睡眠    Sleeping                休眠中, 受阻, 在等待某个条件的形成或接受到信号。</span><br><span class="line">I 空闲    Idle</span><br><span class="line">Z 僵死    Zombie（a defunct process)        进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。</span><br><span class="line">D 不可中断    Uninterruptible sleep (ususally IO)    收到信号不唤醒和不可运行, 进程必须等待直到有中断发生。</span><br><span class="line">T 终止    Terminate                进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行。</span><br><span class="line">P 等待交换页</span><br><span class="line">W 无驻留页    has no resident pages        没有足够的记忆体分页可分配。</span><br><span class="line">X 死掉的进程</span><br><span class="line">&lt; 高优先级进程                    高优先序的进程</span><br><span class="line">N 低优先    级进程                    低优先序的进程</span><br><span class="line">L 内存锁页    Lock                有记忆体分页分配并缩在记忆体内</span><br><span class="line">s 进程的领导者（在它之下有子进程）；</span><br><span class="line">l 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）</span><br><span class="line">+ 位于后台的进程组 </span><br><span class="line">START    进程启动时间和日期</span><br><span class="line">TIME    进程使用的总cpu时间</span><br><span class="line">COMMAND    正在执行的命令行命令</span><br><span class="line">NI    优先级(Nice)</span><br><span class="line">PRI    进程优先级编号(Priority)</span><br><span class="line">WCHAN    进程正在睡眠的内核函数名称；该函数的名称是从/root/system.map文件中获得的。</span><br><span class="line">FLAGS    与进程相关的数字标识</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>fork函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/12/linux059fork%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/12/linux059fork函数/</id>
    <published>2022-01-12T05:58:43.000Z</published>
    <updated>2022-01-12T06:24:29.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure><h4 id="函数作用"><a class="markdownIt-Anchor" href="#函数作用"></a> 函数作用：</h4><p>创建子进程</p><h4 id="原型"><a class="markdownIt-Anchor" href="#原型"></a> 原型:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void);</span><br></pre></td></tr></table></figure><p>函数参数：无</p><h4 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值：</h4><p>调用成功:父进程返回子进程的PID，子进程返回0；</p><p>调用失败:返回-1，设置errno值。</p><h4 id="fork函数代码片段实例"><a class="markdownIt-Anchor" href="#fork函数代码片段实例"></a> fork函数代码片段实例</h4><p><img src="/images/javawz/wps6E52.tmp.jpg" alt="img"></p><p>调用fork函数的内核实现原理:</p><p><img src="/images/javawz/wps6E53.tmp.jpg" alt="img"></p><h3 id="fork函数总结"><a class="markdownIt-Anchor" href="#fork函数总结"></a> fork函数总结</h3><h4 id="fork函数的返回值"><a class="markdownIt-Anchor" href="#fork函数的返回值"></a> fork函数的返回值？</h4><p>父进程返回子进程的PID，是一个大于0数;</p><p>子进程返回0；</p><p>特别需要注意的是：不是fork函数在一个进程中返回2个值，而是在父子进程各自返回一个值。</p><h4 id="子进程创建成功后代码的执行位置"><a class="markdownIt-Anchor" href="#子进程创建成功后代码的执行位置"></a> 子进程创建成功后，代码的执行位置？</h4><p>父进程执行到什么位置，子进程就从哪里执行</p><h4 id="如何区分父子进程"><a class="markdownIt-Anchor" href="#如何区分父子进程"></a> 如何区分父子进程</h4><p>通过fork函数的返回值</p><p>父子进程的执行顺序</p><p>不一定，哪个进程先抢到CPU，哪个进程就先执行</p><h3 id="getpidgetppid"><a class="markdownIt-Anchor" href="#getpidgetppid"></a> getpid/getppid</h3><h4 id="头文件-2"><a class="markdownIt-Anchor" href="#头文件-2"></a> 头文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure><p>getpid 得到当前进程的PID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t getpid(void);</span><br></pre></td></tr></table></figure><p>getppid得到当前进程的父进程的PID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t getppid(void);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fork函数测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork, pid:[%d]\n"</span>, getpid());</span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="comment">//pid_t fork(void);</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) <span class="comment">//fork失败的情况</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: [%d], pid==[%d], fpid==[%d]\n"</span>, pid, getpid(),getppid());</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: pid==[%d], fpid==[%d]\n"</span>, getpid(), getppid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"after fork, pid:[%d]\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环创建n个子程序"><a class="markdownIt-Anchor" href="#循环创建n个子程序"></a> 循环创建n个子程序</h3><p><img src="/images/javawz/image-20220112141606532.png" alt="image-20220112141606532"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环创建n个子进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) <span class="comment">//fork失败的情况</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: pid==[%d], fpid==[%d]\n"</span>, getpid(),getppid());</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: pid==[%d], fpid==[%d]\n"</span>, getpid(), getppid());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第1个子进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]--[%d]: child\n"</span>, i, getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第2个子进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]--[%d]: child\n"</span>, i, getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第3个子进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]--[%d]: child\n"</span>, i, getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]--[%d]: child\n"</span>, i, getpid());</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证父子进程能否共享全局变量"><a class="markdownIt-Anchor" href="#验证父子进程能否共享全局变量"></a> 验证父子进程能否共享全局变量</h3><p>父子进程不能共享全局变量:</p><p>如果父子进程只是对全局变量做读操作,则父子进程在内存中只有一份，属于共享。但是如果父子进程中的如何一个进程对该全局变量做修改操作，会在内存中拷贝一个副本，然后在这个副本上进行修改，修改完成以后映射回去</p><p>写时复制，读时共享</p><p><img src="/images/javawz/image-20220112141851453.png" alt="image-20220112141851453"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fork函数测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_var = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) <span class="comment">//fork失败的情况</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: [%d], pid==[%d], fpid==[%d]\n"</span>, pid, getpid(),getppid());</span><br><span class="line">g_var++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%p]"</span>, &amp;g_var);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>); <span class="comment">//为了避免父进程还没有执行, 子进程已经结束了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%p]"</span>, &amp;g_var);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: pid==[%d], fpid==[%d]\n"</span>, getpid(), getppid());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: g_var==[%d]\n"</span>, g_var);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;头文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#头文件&quot;&gt;&lt;/a&gt; 头文件&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>进程状态切换</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/12/linux058%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/12/linux058进程状态切换/</id>
    <published>2022-01-12T05:47:47.000Z</published>
    <updated>2022-01-12T05:58:25.229Z</updated>
    
    <content type="html"><![CDATA[<p>进程基本的状态有5种。分别为<strong>初始态，就绪态，</strong><a href="http://baike.baidu.com/subview/1730379/1730379.htm" target="_blank" rel="noopener"><strong>运行态</strong></a><strong>，挂起态与终止态</strong>。其中初始态为进程准备阶段，常与就绪态结合来看。</p><p><img src="/images/javawz/image-20220112134907216.png" alt="image-20220112134907216"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进程基本的状态有5种。分别为&lt;strong&gt;初始态，就绪态，&lt;/strong&gt;&lt;a href=&quot;http://baike.baidu.com/subview/1730379/1730379.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;stron
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>PCB相关概念</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/12/linux057PCB%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/12/linux057PCB相关概念/</id>
    <published>2022-01-12T03:41:44.000Z</published>
    <updated>2022-01-12T03:45:52.722Z</updated>
    
    <content type="html"><![CDATA[<p>每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p><p><code>/usr/src/linux-headers-4.4.0-96/include/linux/sched.h</code>文件的1390行处可以查看<code>struct task_struct</code>结构体定义。其内部成员有很多，我们重点掌握以下部分即可：</p><p>进程id。系统中每个进程有唯一的id，在C语言中用<code>pid_t</code>类型表示，其实就是一个非负整数。</p><p>进程的状态，有就绪、运行、挂起、停止等状态。</p><p>进程切换时需要保存和恢复的一些CPU寄存器。</p><p>描述虚拟地址空间的信息。</p><p>描述控制终端的信息。</p><p>当前工作目录（Current Working Directory）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getcwd --pwd</span><br><span class="line">chdir 更改当前工作目录</span><br></pre></td></tr></table></figure><p>umask掩码。</p><p>文件描述符表，包含很多指向file结构体的指针。</p><p>和信号相关的信息。</p><p>用户id和组id。</p><p>会话（Session）和进程组。</p><p>进程可以使用的资源上限（Resource Limit）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/usr/src/linux-headers-4.4.0-96/include/linux/sched.h&lt;/code&gt;文
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>并行和并发的概念</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/12/linux056%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/12/linux056并行和并发的概念/</id>
    <published>2022-01-11T18:48:13.000Z</published>
    <updated>2022-01-11T18:50:04.935Z</updated>
    
    <content type="html"><![CDATA[<p>并发，在一个时间段内, 是在同一个cpu上, 同时运行多个程序。</p><p>如：若将CPU的1S的时间分成1000个时间片，每个进程执行完一个时间片必须无条件让出CPU的使用权，这样1S中就可以执行1000个进程。</p><p><img src="/images/javawz/wpsE977.tmp.jpg" alt="img"></p><p><img src="/images/javawz/wpsE978.tmp.jpg" alt="img"></p><p><img src="/images/javawz/wpsE989.tmp.jpg" alt="img"></p><p><img src="/images/javawz/wpsE98A.tmp.jpg" alt="img"></p><p>并行性指两个或两个以上的程序在同一时刻发生(需要有多颗)。</p><p><img src="/images/javawz/wpsE98B.tmp.jpg" alt="img"></p><p><img src="/images/javawz/wpsE98C.tmp.jpg" alt="img"></p><p>​并发: 在一个时间段内, 一个CPU上, 有多个程序在执行.<br>​并行: 在一个时间片内, 有多个程序在执行(前提是有多个cpu)<br>​cpu会将一个大的时间段分成多个小的时间片, 让进程轮流使用CPU的时间片.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;并发，在一个时间段内, 是在同一个cpu上, 同时运行多个程序。&lt;/p&gt;
&lt;p&gt;如：若将CPU的1S的时间分成1000个时间片，每个进程执行完一个时间片必须无条件让出CPU的使用权，这样1S中就可以执行1000个进程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ja
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>程序和进程</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/12/linux055%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/12/linux055程序和进程/</id>
    <published>2022-01-11T18:29:20.000Z</published>
    <updated>2022-01-11T18:47:27.417Z</updated>
    
    <content type="html"><![CDATA[<h3 id="程序和进程"><a class="markdownIt-Anchor" href="#程序和进程"></a> 程序和进程</h3><p>程序，是指编译好的二进制文件，在磁盘上，占用磁盘空间, 是一个静态的概念.</p><p>进程，一个启动的程序， 进程占用的是系统资源，如：物理内存，CPU，终端等，是一个动态的概念</p><p>程序 → 剧本(纸)</p><p>进程 → 戏(舞台、演员、灯光、道具…)</p><p>同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响)</p><p>同一个程序可以在多个终端执行, 类似与同一台戏可以在多个舞台演出.<br>每启动一个程序都会有一个进程PID, 即使是相同的程序多次启动也会有个不同的PID.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;程序和进程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#程序和进程&quot;&gt;&lt;/a&gt; 程序和进程&lt;/h3&gt;
&lt;p&gt;程序，是指编译好的二进制文件，在磁盘上，占用磁盘空间, 是一个静态的概念.&lt;/p&gt;
&lt;p&gt;进程，一个启动的程序， 进程占用的是
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>fcntl函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/11/linux054fcntl%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/11/linux054fcntl函数/</id>
    <published>2022-01-10T17:35:43.000Z</published>
    <updated>2022-01-10T17:42:52.338Z</updated>
    
    <content type="html"><![CDATA[<h4 id="fcntl函数"><a class="markdownIt-Anchor" href="#fcntl函数"></a> fcntl函数</h4><p>函数描述: 改变已经打开的文件的属性</p><h4 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> 函数原型:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fcntl(int fd, int cmd, ... /* arg */ );</span><br></pre></td></tr></table></figure><p>若cmd为F_DUPFD, 复制文件描述符, 与dup相同</p><p>若cmd为F_GETFL, 获取文件描述符的flag属性值</p><p>若cmd为 F_SETFL, 设置文件描述符的flag属性</p><h4 id="函数返回值返回值取决于cmd"><a class="markdownIt-Anchor" href="#函数返回值返回值取决于cmd"></a> 函数返回值:返回值取决于cmd</h4><p>成功:</p><p>若cmd为F_DUPFD, 返回一个新的文件描述符</p><p>若cmd为F_GETFL, 返回文件描述符的flags值</p><p>若cmd为 F_SETFL, 返回0</p><p>失败返回-1, 并设置errno值.</p><h3 id="fcntl函数常用的操作"><a class="markdownIt-Anchor" href="#fcntl函数常用的操作"></a> fcntl函数常用的操作:</h3><h4 id="1复制一个新的文件描述符"><a class="markdownIt-Anchor" href="#1复制一个新的文件描述符"></a> 1.复制一个新的文件描述符:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int newfd = fcntl(fd, F_DUPFD, 0);</span><br></pre></td></tr></table></figure><h4 id="2获取文件的属性标志"><a class="markdownIt-Anchor" href="#2获取文件的属性标志"></a> 2.获取文件的属性标志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int flag = fcntl(fd, F_GETFL, 0)</span><br></pre></td></tr></table></figure><h4 id="3-设置文件状态标志"><a class="markdownIt-Anchor" href="#3-设置文件状态标志"></a> 3 设置文件状态标志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag = flag | O_APPEND;</span><br><span class="line"></span><br><span class="line">fcntl(fd, F_SETFL, flag)</span><br></pre></td></tr></table></figure><h4 id="4-常用的属性标志"><a class="markdownIt-Anchor" href="#4-常用的属性标志"></a> 4 常用的属性标志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O_APPEND-----设置文件打开为末尾添加</span><br><span class="line"></span><br><span class="line">O_NONBLOCK-----设置打开的文件描述符为非阻塞</span><br></pre></td></tr></table></figure><p><br><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改文件描述符的flag属性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得和设置fd的flags属性</span></span><br><span class="line"><span class="keyword">int</span> flags = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">flags = flags | O_APPEND;</span><br><span class="line">fcntl(fd, F_SETFL, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写文件</span></span><br><span class="line">write(fd, <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;fcntl函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fcntl函数&quot;&gt;&lt;/a&gt; fcntl函数&lt;/h4&gt;
&lt;p&gt;函数描述: 改变已经打开的文件的属性&lt;/p&gt;
&lt;h4 id=&quot;函数原型&quot;&gt;&lt;a class=&quot;markdownIt
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>dup2函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/10/linux053dup2%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/10/linux053dup2函数/</id>
    <published>2022-01-10T10:12:57.000Z</published>
    <updated>2022-01-10T16:46:01.368Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javawz/image-20220110181303574.png" alt="image-20220110181303574"></p><p>快速生成可执行文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make 源文件名(去掉.c后缀)</span><br><span class="line">例如当前目录下有一个main.c文件</span><br><span class="line">make main//会生成一个main可执行文件</span><br></pre></td></tr></table></figure><h3 id="dup2函数"><a class="markdownIt-Anchor" href="#dup2函数"></a> dup2函数</h3><h4 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure><p>函数描述: 复制文件描述符</p><h4 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> 函数原型:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int dup2(int oldfd, int newfd);</span><br></pre></td></tr></table></figure><h4 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数:</h4><p><code>oldfd-</code>原来的文件描述符</p><p><code>newfd-</code>复制成的新的文件描述符</p><h4 id="函数返回值"><a class="markdownIt-Anchor" href="#函数返回值"></a> 函数返回值:</h4><p>成功: 将oldfd复制给newfd, 两个文件描述符指向同一个文件</p><p>失败: 返回-1, 设置errno值</p><p>假设newfd已经指向了一个文件，首先close原来打开的文件，然后newfd指向oldfd指向的文件.</p><p>若newfd没有被占用，newfd指向oldfd指向的文件.</p><h4 id="dup2函数实现重定向操作"><a class="markdownIt-Anchor" href="#dup2函数实现重定向操作"></a> dup2函数实现重定向操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//使用dup2函数实现标准输出重定向操作</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//打开文件</span><br><span class="line">int fd = open(argv[1], O_RDWR | O_CREAT, 0777);</span><br><span class="line">if(fd&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;open error&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> //调用dup2函数实现文件重定向操作</span><br><span class="line">dup2(fd, STDOUT_FILENO);</span><br><span class="line"></span><br><span class="line">printf(&quot;ni hao hello world&quot;);</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220111004510141.png" alt="image-20220111004510141"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javawz/image-20220110181303574.png&quot; alt=&quot;image-20220110181303574&quot;&gt;&lt;/p&gt;
&lt;p&gt;快速生成可执行文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>linux052dup函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/10/linux052dup%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/10/linux052dup函数/</id>
    <published>2022-01-10T09:30:54.000Z</published>
    <updated>2022-01-10T09:54:41.360Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../themes/pure/source/images/javawz/image-20220110173058857.png" alt="image-20220110173058857"></p><h3 id="dup函数"><a class="markdownIt-Anchor" href="#dup函数"></a> dup函数</h3><h4 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure><p>函数描述: 复制文件描述符</p><h4 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> 函数原型:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int dup(int oldfd);</span><br></pre></td></tr></table></figure><h4 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数:</h4><p><code>oldfd -</code>要复制的文件描述符</p><h4 id="函数返回值"><a class="markdownIt-Anchor" href="#函数返回值"></a> 函数返回值:</h4><p>成功: 返回最小且没被占用的文件描述符</p><p>失败: 返回-1, 设置errno值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//测试dup函数复制文件描述符</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//打开文件</span><br><span class="line">int fd = open(argv[1], O_RDWR);</span><br><span class="line">if(fd&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;open error&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用dup函数复制fd</span><br><span class="line">int newfd = dup(fd);</span><br><span class="line">printf(&quot;newfd:[%d], fd:[%d]\n&quot;, newfd, fd);</span><br><span class="line"></span><br><span class="line">//使用fd对文件进行写操作</span><br><span class="line">write(fd, &quot;hello world&quot;, strlen(&quot;hello world&quot;));</span><br><span class="line"></span><br><span class="line">//调用lseek函数移动文件指针到开始处</span><br><span class="line">lseek(fd, 0, SEEK_SET);</span><br><span class="line"></span><br><span class="line">//使用newfd读文件</span><br><span class="line">char buf[64];</span><br><span class="line">memset(buf, 0x00, sizeof(buf));</span><br><span class="line">int n = read(newfd, buf, sizeof(buf));</span><br><span class="line">printf(&quot;read over: n==[%d], buf==[%s]\n&quot;, n, buf);</span><br><span class="line"></span><br><span class="line">//关闭文件</span><br><span class="line">close(fd);</span><br><span class="line">close(newfd);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../../themes/pure/source/images/javawz/image-20220110173058857.png&quot; alt=&quot;image-20220110173058857&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;dup函数&quot;&gt;&lt;a class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>目录操作相关函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/10/linux051%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/10/linux051目录操作相关函数/</id>
    <published>2022-01-10T08:43:59.000Z</published>
    <updated>2022-01-10T08:56:14.139Z</updated>
    
    <content type="html"><![CDATA[<h4 id="opendir函数"><a class="markdownIt-Anchor" href="#opendir函数"></a> opendir函数</h4><p>函数描述:打开一个目录</p><p>函数原型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIR *opendir(const char *name);</span><br></pre></td></tr></table></figure><p>函数返回值: 指向目录的指针</p><p>函数参数: 要遍历的目录(相对路径或者绝对路径)</p><h4 id="readdir函数"><a class="markdownIt-Anchor" href="#readdir函数"></a> readdir函数</h4><p>函数描述: 读取目录内容–目录项</p><p>函数原型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct dirent *readdir(DIR *dirp);</span><br></pre></td></tr></table></figure><p>函数返回值: 读取的目录项指针，有错误发生或读取到目录文件尾则返回NULL。，出错会设置errno变量</p><p>成功时，返回1。在目录末尾，返回0。在出现错误时，返回-1，并正确设置errno。</p><p>函数参数: opendir函数的返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct dirent</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> ino_t d_ino;       // 此目录进入点的inode</span><br><span class="line"></span><br><span class="line"> off_t d_off;        // 目录文件开头至此目录进入点的位移</span><br><span class="line"></span><br><span class="line"> signed short int d_reclen;  // d_name 的长度, 不包含NULL 字符</span><br><span class="line"></span><br><span class="line">   unsigned char d_type;   // d_name 所指的文件类型 </span><br><span class="line"></span><br><span class="line"> char d_name[256];  // 文件名</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">d_type的取值: </span><br><span class="line"> DT_BLK - 块设备</span><br><span class="line"></span><br><span class="line"> DT_CHR - 字符设备</span><br><span class="line"> </span><br><span class="line"> DT_DIR - 目录</span><br><span class="line"></span><br><span class="line"> DT_LNK - 软连接</span><br><span class="line"></span><br><span class="line"> DT_FIFO - 管道</span><br><span class="line"></span><br><span class="line"> DT_REG - 普通文件</span><br><span class="line"></span><br><span class="line"> DT_SOCK - 套接字</span><br><span class="line"> </span><br><span class="line"> DT_UNKNOWN - 未知</span><br></pre></td></tr></table></figure><br><p><img src="/images/javawz/wps8867.tmp.jpg" alt="img"></p><h4 id="closedir函数"><a class="markdownIt-Anchor" href="#closedir函数"></a> closedir函数</h4><p>函数描述: 关闭目录</p><p>函数原型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int closedir(DIR *dirp);</span><br></pre></td></tr></table></figure><p>函数返回值: 成功返回0, 失败返回-1</p><p>函数参数: opendir函数的返回值</p><p>读取目录内容的一般步骤</p><p>1 DIR *pDir = opendir(“dir”);  //打开目录</p><p>2 while((p=readdir(pDir))!=NULL){} //循环读取文件</p><p>3 closedir(pDir);  //关闭目录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;opendir函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#opendir函数&quot;&gt;&lt;/a&gt; opendir函数&lt;/h4&gt;
&lt;p&gt;函数描述:打开一个目录&lt;/p&gt;
&lt;p&gt;函数原型:&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>stat和lstat函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/10/linux050stat%E5%92%8Clstat%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/10/linux050stat和lstat函数/</id>
    <published>2022-01-10T08:13:48.000Z</published>
    <updated>2022-01-10T08:26:51.848Z</updated>
    
    <content type="html"><![CDATA[<h4 id="id命令"><a class="markdownIt-Anchor" href="#id命令"></a> id命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># id //显示当前用户ID</span><br></pre></td></tr></table></figure><p>函数描述: 获取文件属性</p><h4 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> 函数原型:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int stat(const char *pathname, struct stat *buf);</span><br><span class="line"></span><br><span class="line">int lstat(const char *pathname, struct stat *buf);</span><br></pre></td></tr></table></figure><h4 id="函数返回值"><a class="markdownIt-Anchor" href="#函数返回值"></a> 函数返回值：</h4><p>成功返回 0</p><p>失败返回 -1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct stat &#123;</span><br><span class="line">    dev_t          st_dev;        //文件的设备编号</span><br><span class="line">    ino_t           st_ino;        //节点</span><br><span class="line">    mode_t         st_mode;      //文件的类型和存取的权限</span><br><span class="line">    nlink_t         st_nlink;     //连到该文件的硬连接数目，刚建立的文件值为1</span><br><span class="line">    uid_t           st_uid;       //用户ID</span><br><span class="line">    gid_t           st_gid;       //组ID</span><br><span class="line">    dev_t          st_rdev;      //(设备类型)若此文件为设备文件，则为其设备编号</span><br><span class="line">    off_t          st_size;      //文件字节数(文件大小)</span><br><span class="line">    blksize_t       st_blksize;   //块大小(文件系统的I/O 缓冲区大小)</span><br><span class="line">    blkcnt_t        st_blocks;    //块数</span><br><span class="line">    time_t         st_atime;     //最后一次访问时间</span><br><span class="line">    time_t         st_mtime;     //最后一次修改时间</span><br><span class="line">    time_t         st_ctime;     //最后一次改变时间(指属性)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-st_mode -- 16位整数</span><br><span class="line">0-2 bit -- 其他人权限</span><br><span class="line">S_IROTH      00004  读权限</span><br><span class="line">S_IWOTH     00002  写权限</span><br><span class="line">S_IXOTH      00001  执行权限</span><br><span class="line">S_IRWXO     00007  掩码, 过滤 st_mode中除其他人权限以外的信息</span><br><span class="line">3-5 bit -- 所属组权限</span><br><span class="line">S_IRGRP     00040  读权限</span><br><span class="line">S_IWGRP    00020  写权限</span><br><span class="line">      S_IXGRP     00010   执行权限</span><br><span class="line">S_IRWXG    00070  掩码, 过滤 st_mode中除所属组权限以外的信息</span><br><span class="line">6-8 bit -- 文件所有者权限</span><br><span class="line">S_IRUSR    00400    读权限</span><br><span class="line">S_IWUSR   00200    写权限</span><br><span class="line">S_IXUSR    00100     执行权限</span><br><span class="line">S_IRWXU   00700    掩码, 过滤 st_mode中除文件所有者权限以外的信息</span><br><span class="line">If (st_mode &amp; S_IRUSR)   -----为真表明可读</span><br><span class="line">                 If (st_mode &amp; S_IWUSR)  ------为真表明可写</span><br><span class="line">                 If (st_mode &amp; S_IXUSR)   ------为真表明可执行</span><br><span class="line">12-15 bit -- 文件类型</span><br><span class="line">S_IFSOCK         0140000 套接字</span><br><span class="line">S_IFLNK          0120000 符号链接（软链接）</span><br><span class="line">      S_IFREG          0100000 普通文件</span><br><span class="line">S_IFBLK           0060000 块设备</span><br><span class="line">S_IFDIR           0040000 目录</span><br><span class="line">     S_IFCHR           0020000 字符设备</span><br><span class="line">S_IFIFO           0010000 管道</span><br><span class="line">S_IFMT 0170000 掩码,过滤 st_mode中除文件类型以外的信息</span><br><span class="line">If ((st_mode &amp; S_IFMT)==S_IFREG) ----为真普通文件</span><br><span class="line">                 if(S_ISREG(st_mode))   ------为真表示普通文件</span><br><span class="line">                 if(S_ISDIR(st.st_mode))  ------为真表示目录文件</span><br></pre></td></tr></table></figure><p>判断是什么文件的宏函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S_ISREG();//判断是否为普通文件</span><br><span class="line">S_ISDIR();//判断是否为目录</span><br><span class="line">S_ISCHR();//判断是否为字符设备文件</span><br><span class="line">S_ISBLK();//判断是否为块设备文件</span><br><span class="line">S_ISFIFO();//判断是否为管道文件</span><br><span class="line">S_ISLNK();//判断是否为符号链接文件</span><br><span class="line">S_ISSOCK()//判断是否为套接字文件</span><br></pre></td></tr></table></figure><p>stat函数和lstat函数的区别</p><p>对于普通文件, 这两个函数没有区别, 是一样的.</p><p>对于连接文件,调用lstat函数获取的是链接文件本身的属性信息;</p><pre><code>而stat函数获取的是链接文件指向的文件的属性信息.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;id命令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#id命令&quot;&gt;&lt;/a&gt; id命令&lt;/h4&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>read函数阻塞和非阻塞</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/10/linux049read%E5%87%BD%E6%95%B0%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/10/linux049read函数阻塞和非阻塞/</id>
    <published>2022-01-10T05:24:06.000Z</published>
    <updated>2022-01-10T05:26:31.039Z</updated>
    
    <content type="html"><![CDATA[<p>通过读普通文件测试得知: read函数在读完文件内容之后, 若再次read,则read函数会立刻返回, 表明read函数读普通文件是非阻塞的.</p><p>​设备文件: <code>/dev/tty</code>  标准输入<code>STDIN_FILENO</code><br>通过读<code>/dev/tty</code>终端设备文件, 表明read函数读设备文件是阻塞的.</p><br><p>结论: 阻塞和非阻塞不是read函数的属性, 而是文件本身的属性.<br>socket(套接字)，pipe（管道）这两种文件都是阻塞的.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过读普通文件测试得知: read函数在读完文件内容之后, 若再次read,则read函数会立刻返回, 表明read函数读普通文件是非阻塞的.&lt;/p&gt;
&lt;p&gt;​	设备文件: &lt;code&gt;/dev/tty&lt;/code&gt;  标准输入&lt;code&gt;STDIN_FILENO&lt;/cod
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>lseek函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/10/linux048lseek%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/10/linux048lseek函数/</id>
    <published>2022-01-09T16:25:39.000Z</published>
    <updated>2022-01-09T17:05:34.569Z</updated>
    
    <content type="html"><![CDATA[<p>要包含头文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure><p>函数原型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">off_t lseek(int fd, off_t offset, int whence);</span><br><span class="line"></span><br><span class="line">参数1 文件描述符</span><br><span class="line">参数2 参数offset 为根据参数whence 来移动读写位置的位移数。</span><br><span class="line">参数3 whence 为下列其中一种:</span><br><span class="line">        SEEK_SET 参数offset 即为新的读写位置.</span><br><span class="line">        SEEK_CUR 以目前的读写位置往后增加offset 个位移量.</span><br><span class="line">        SEEK_END 将读写位置指向文件尾后再增加offset 个位移量. 当whence 值为SEEK_CUR 或</span><br><span class="line">        SEEK_END 时, 参数offet 允许负值的出现.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下列是教特别的使用方式:</span><br><span class="line">1) 欲将读写位置移到文件开头时:lseek(int fildes, 0, SEEK_SET);</span><br><span class="line">2) 欲将读写位置移到文件尾时:lseek(int fildes, 0, SEEK_END);</span><br><span class="line">3) 想要取得目前文件位置时:lseek(int fildes, 0, SEEK_CUR);</span><br></pre></td></tr></table></figure><p>返回值：当调用成功时则返回目前的读写位置, 也就是距离文件开头多少个字节. 若有错误则返回-1, errno 会存放错误代码.</p><h4 id="获取文件大小"><a class="markdownIt-Anchor" href="#获取文件大小"></a> 获取文件大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int size = lseek(fd,0,SEEK_END);</span><br><span class="line">printf(&quot;size:%d \n&quot;,size);</span><br></pre></td></tr></table></figure><h4 id="文件拓展"><a class="markdownIt-Anchor" href="#文件拓展"></a> 文件拓展:</h4><p>就是将文件扩大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd,2000,SEEK_END);//拓展2000个字节</span><br><span class="line">write(fd,&apos;a&apos;,1);//写一些字符后生效</span><br></pre></td></tr></table></figure><p>拓展之后需要手动写随便一些东西才生效</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd1 = open(<span class="string">"./newfile"</span>,O_RDWR | O_CREAT,<span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fd1 == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"open:"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取文件大小</span></span><br><span class="line"><span class="keyword">int</span> size = lseek(fd1,<span class="number">0</span>,SEEK_END);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"size:%d\n"</span>,size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展文件</span></span><br><span class="line"><span class="keyword">int</span> ret = lseek(fd1,<span class="number">2000</span>,SEEK_END);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret);</span><br><span class="line">write(fd1,<span class="string">"a"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">close(fd1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要包含头文件:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>read和write函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/08/linux047read%E5%92%8Cwirte%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/08/linux047read和wirte函数/</id>
    <published>2022-01-08T15:04:52.000Z</published>
    <updated>2022-01-08T15:28:07.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="read函数"><a class="markdownIt-Anchor" href="#read函数"></a> read函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">要包含头文件</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">函数原型</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">参数1 int fd, //文件描述符</span><br><span class="line">参数2 void *buf,//缓冲区地址</span><br><span class="line">参数3 size_t count //要读取的字节个数</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。</span><br></pre></td></tr></table></figure><h3 id="write函数"><a class="markdownIt-Anchor" href="#write函数"></a> write函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">要包含头文件</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">函数原型</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">fd：文件描述符；</span><br><span class="line">buf：指定的缓冲区，即指针，指向一段内存单元；</span><br><span class="line">nbyte：要写入文件指定的字节数；</span><br><span class="line"></span><br><span class="line">返回值：写入文档的字节数（成功）；-1（出错）</span><br><span class="line">write函数把buf中nbyte写入文件描述符handle所指的文档，成功时返回写的字节数，错误时返回-1.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;read函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#read函数&quot;&gt;&lt;/a&gt; read函数&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>open函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/08/linux046open%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/08/linux046open函数/</id>
    <published>2022-01-08T13:23:33.000Z</published>
    <updated>2022-01-09T17:05:23.101Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">头文件：#include&lt;fcntl.h&gt;//在centos6.0中只要此头文件就可以</span><br><span class="line">       #include&lt;sys/types.h&gt;</span><br><span class="line">       #include&lt;sys/stat.h&gt;</span><br><span class="line">功能：打开和创建文件（建立一个文件描述符，其他的函数可以通过文</span><br><span class="line">     件描述符对指定文件进行读取与写入的操作。）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int open(const char*pathname,int flags);</span><br><span class="line">int open(const char*pathname,int flags,mode_t mode);</span><br><span class="line">参数说明：</span><br><span class="line">1.pathname</span><br><span class="line">  要打开或创建的目标文件</span><br><span class="line">2.flags</span><br><span class="line">  打开文件时，可以传入多个参数选项，用下面的</span><br><span class="line">  一个或者多个常量进行“或”运算，构成falgs</span><br><span class="line">  参数：</span><br><span class="line">  O_RDONLY:   只读打开</span><br><span class="line">  O_WRONLY:   只写打开</span><br><span class="line">  O_RDWR:     读，写打开</span><br><span class="line">这三个常量，必须制定一个且只能指定一个</span><br><span class="line">  O_CREAT:    若文件不存在，则创建它，需要使</span><br><span class="line">              用mode选项。来指明新文件的访问权限</span><br><span class="line">  O_APPEND:   追加写，如果文件已经有内容，这次打开文件所</span><br><span class="line">              写的数据附加到文件的末尾而不覆盖原来的内容</span><br><span class="line">  O_EXCL如果要创建的文件已存在，则返回-1，并且修改errno的值</span><br><span class="line"></span><br><span class="line">  O_TRUNC如果文件存在，并且以只写/读写方式打开，则清空文件全部内容(即将其长度截短为0)            </span><br><span class="line"></span><br><span class="line">判断文件是否存在 O_CREAT |  O_EXCL 必须同时使用</span><br></pre></td></tr></table></figure><p>ps：open函数具体使用那个，和具体应用场景相关，如目标文件存在，使用两个参数的open，如果目标文件不存在，需要open创建，则第三个参数表示创建文件的默认权限</p><p>创建文件时 :本地有一个掩码,可以用<code>umake</code>命令查询</p><p><code>文件实际权限=文件掩码取反 &amp; 文件权限</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例如创建一个文件的权限是777,文件掩码是002</span><br><span class="line">111 111 111 777</span><br><span class="line">000 000 010 002</span><br><span class="line">111 111 101 &amp;111 111 111 777按位取反得来</span><br><span class="line"></span><br><span class="line">111 111 101 </span><br><span class="line">&amp; </span><br><span class="line">111 111 111 = </span><br><span class="line">111 111 101 实际权限是775</span><br></pre></td></tr></table></figure><h4 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">成功：新打开的文件描述符</span><br><span class="line">失败：-1</span><br><span class="line">open返回的文件描述符一定是最小的而且没有被使用的</span><br></pre></td></tr></table></figure><h4 id="close"><a class="markdownIt-Anchor" href="#close"></a> close</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">头文件：#include&lt;unistd.h&gt;</span><br><span class="line">功能：关闭一个已经打开的文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int close(int fd)</span><br><span class="line">参数说明：</span><br><span class="line"> fd：是需要关闭的文件描述符</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">成功：返回0；</span><br><span class="line">失败：返回-1，并设置errno</span><br></pre></td></tr></table></figure><h5 id="打开的文件描述符一定要记得关闭否则资源会被大量的占用导致内存不够"><a class="markdownIt-Anchor" href="#打开的文件描述符一定要记得关闭否则资源会被大量的占用导致内存不够"></a> 打开的文件描述符一定要记得关闭，否则资源会被大量的占用，导致内存不够</h5><h4 id="open函数中的erron全局变量"><a class="markdownIt-Anchor" href="#open函数中的erron全局变量"></a> open函数中的erron全局变量</h4><p>错误宏定义位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第1-34个错误定义</span><br><span class="line">/usr/include/asm-generic/errno-base.h</span><br><span class="line"></span><br><span class="line">第35-133个错误定义</span><br><span class="line">/usr/include/asm-generic/errno.h</span><br></pre></td></tr></table></figure><p>是记录系统的最后一次错误代码.</p><p>代码是一个int型的值</p><h4 id="使用perror读错误的信息"><a class="markdownIt-Anchor" href="#使用perror读错误的信息"></a> 使用perror读错误的信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">头文件</span><br><span class="line">stdio.h</span><br><span class="line">void perror(const char *s)</span><br><span class="line">用来将上一个函数发生错误的原因输出到标准设备(stderr)</span><br><span class="line">参数s所指的字符串会先打印出,后面再加上错误原因字符串</span><br><span class="line">此错误原因依照全局变量errno的值来决定要输出的字符串</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>C库函数与系统函数的关系</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/08/linux045C%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/08/linux045C库函数与系统函数的关系/</id>
    <published>2022-01-08T10:52:02.000Z</published>
    <updated>2022-01-08T12:58:43.141Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javawz/image-20220108185220142.png" alt="image-20220108185220142"></p><h3 id="printf是如何显示消息的"><a class="markdownIt-Anchor" href="#printf是如何显示消息的"></a> printf是如何显示消息的</h3><p>首先printf函数有一个stdout指针</p><p>stdout是FILE*指针</p><p>priintf会调用系统应用层wirte函数,然后wirte函数会从用户空间转换为内核空间，然后调用sys_wirte()函数(系统调用)，接着sys_write()会调用内核层的设备驱动函数,通过设备驱动操作硬件显示字符串</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javawz/image-20220108185220142.png&quot; alt=&quot;image-20220108185220142&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;printf是如何显示消息的&quot;&gt;&lt;a class=&quot;markdownIt-Anc
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
</feed>
