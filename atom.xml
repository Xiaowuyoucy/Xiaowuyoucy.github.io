<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanChen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowuyoucy.github.io/"/>
  <updated>2021-07-01T11:26:35.242Z</updated>
  <id>https://xiaowuyoucy.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>deque容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/01/cpp0080-STL%E7%9A%84Deque%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/01/cpp0080-STL的Deque容器/</id>
    <published>2021-07-01T05:05:02.000Z</published>
    <updated>2021-07-01T11:26:35.242Z</updated>
    
    <content type="html"><![CDATA[<h4 id="deque简介"><a class="markdownIt-Anchor" href="#deque简介"></a> Deque简介</h4><p>deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数组，而vector是单端的。</p><p>deque在接口上和vector非常相似，在许多操作的地方可以直接替换。</p><p>deque可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。</p><p>deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。</p><p>#include &lt;deque&gt;</p><h4 id="deque对象的默认构造"><a class="markdownIt-Anchor" href="#deque对象的默认构造"></a> deque对象的默认构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deque采用模板类实现，deque对象的默认构造形式：deque&lt;T&gt; deqT;  </span><br><span class="line"></span><br><span class="line">deque &lt;int&gt; deqInt;            //一个存放int的deque容器。</span><br><span class="line">deque &lt;float&gt; deq Float;     //一个存放float的deque容器。</span><br><span class="line">deque &lt;string&gt; deq String;     //一个存放string的deque容器。</span><br><span class="line">...   </span><br><span class="line"> //尖括号内还可以设置指针类型或自定义类型。</span><br></pre></td></tr></table></figure><h4 id="deque末尾的添加移除操作"><a class="markdownIt-Anchor" href="#deque末尾的添加移除操作"></a> deque末尾的添加移除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.push_back(elem);//在容器尾部添加一个数据</span><br><span class="line">deque.push_front(elem);//在容器头部插入一个数据</span><br><span class="line">deque.pop_back();    //删除容器最后一个数据</span><br><span class="line">deque.pop_front();//删除容器第一个数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqInt;</span><br><span class="line">deqInt.push_back(1);</span><br><span class="line">deqInt.push_back(3);</span><br><span class="line">deqInt.push_back(5);</span><br><span class="line">deqInt.push_back(7);</span><br><span class="line">deqInt.push_back(9);</span><br><span class="line">deqInt.pop_front();</span><br><span class="line">deqInt.pop_front();</span><br><span class="line">deqInt.push_front(11);</span><br><span class="line">deqInt.push_front(13);</span><br><span class="line">deqInt.pop_back();</span><br><span class="line">deqInt.pop_back();</span><br><span class="line">//deqInt  &#123; 13,11,5&#125;</span><br></pre></td></tr></table></figure><h4 id="deque的数据存取"><a class="markdownIt-Anchor" href="#deque的数据存取"></a> deque的数据存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.at(idx);  //返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span><br><span class="line">deque[idx];  //返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span><br><span class="line">deque.front();   //返回第一个数据。</span><br><span class="line">deque.back();  //返回最后一个数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqInt;</span><br><span class="line">deqInt.push_back(1);</span><br><span class="line">deqInt.push_back(3);</span><br><span class="line">deqInt.push_back(5);</span><br><span class="line">deqInt.push_back(7);</span><br><span class="line">deqInt.push_back(9);</span><br><span class="line"></span><br><span class="line">int iA = deqInt.at(0);//1</span><br><span class="line">int iB = deqInt[1];//3</span><br><span class="line">deqInt.at(0) = 99;//99</span><br><span class="line">deqInt[1] = 88;//88</span><br><span class="line"></span><br><span class="line">int iFront = deqInt.front();//99</span><br><span class="line">int iBack = deqInt.back();//9</span><br><span class="line">deqInt.front() = 77;//77</span><br><span class="line">deqInt.back() = 66;//66</span><br></pre></td></tr></table></figure><h4 id="deque与迭代器"><a class="markdownIt-Anchor" href="#deque与迭代器"></a> deque与迭代器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.begin();  //返回容器中第一个元素的迭代器。</span><br><span class="line">deque.end();  //返回容器中最后一个元素之后的迭代器。</span><br><span class="line">deque.rbegin();  //返回容器中倒数第一个元素的迭代器。</span><br><span class="line">deque.rend();   //返回容器中倒数最后一个元素之后的迭代器。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqInt;</span><br><span class="line">deqInt.push_back(1);</span><br><span class="line">deqInt.push_back(3);</span><br><span class="line">deqInt.push_back(5);</span><br><span class="line">deqInt.push_back(7);</span><br><span class="line">deqInt.push_back(9);</span><br><span class="line"></span><br><span class="line">for (deque&lt;int&gt;::iterator it=deqInt.begin(); it!=deqInt.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it;</span><br><span class="line">cout &lt;&lt; &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">// 1 3 5 7 9</span><br><span class="line"></span><br><span class="line">for (deque&lt;int&gt;::reverse_iterator rit=deqInt.rbegin(); rit!=deqInt.rend(); ++rit)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *rit;</span><br><span class="line">cout &lt;&lt; &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//9 7 5 3 1</span><br></pre></td></tr></table></figure><h4 id="deque对象的带参数构造"><a class="markdownIt-Anchor" href="#deque对象的带参数构造"></a> deque对象的带参数构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deque(beg,end);    //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</span><br><span class="line">deque(n,elem);   //构造函数将n个elem拷贝给本身。</span><br><span class="line">deque(const deque  &amp;deq);  //拷贝构造函数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqIntA;</span><br><span class="line">deqIntA.push_back(1);</span><br><span class="line">deqIntA.push_back(3);</span><br><span class="line">deqIntA.push_back(5);</span><br><span class="line">deqIntA.push_back(7);</span><br><span class="line">deqIntA.push_back(9);</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt; deqIntB(deqIntA.begin(),deqIntA.end());//1 3 5 7 9</span><br><span class="line">deque&lt;int&gt; deqIntC(5,8);//8 8 8 8 8</span><br><span class="line">deque&lt;int&gt; deqIntD(deqIntA);//1 3 5 7 9</span><br></pre></td></tr></table></figure><h4 id="deque的赋值"><a class="markdownIt-Anchor" href="#deque的赋值"></a> deque的赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.assign(beg,end);    //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</span><br><span class="line">deque.assign(n,elem);  //将n个elem拷贝赋值给本身。</span><br><span class="line">deque&amp; operator=(const deque &amp;deq);//重载等号操作符 </span><br><span class="line">deque.swap(deq);  // 将vec与本身的元素互换</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqIntA,deqIntB,deqIntC,deqIntD;</span><br><span class="line">deqIntA.push_back(1);</span><br><span class="line">deqIntA.push_back(3);</span><br><span class="line">deqIntA.push_back(5);</span><br><span class="line">deqIntA.push_back(7);</span><br><span class="line">deqIntA.push_back(9);</span><br><span class="line"></span><br><span class="line">deqIntB.assign(deqIntA.begin(),deqIntA.end());// 1 3 5 7 9</span><br><span class="line"></span><br><span class="line">deqIntC.assign(5,8);//8 8 8 8 8</span><br><span class="line"></span><br><span class="line">deqIntD = deqIntA;//1 3 5 7 9</span><br><span class="line"></span><br><span class="line">deqIntC.swap(deqIntD);//互换</span><br></pre></td></tr></table></figure><h4 id="deque的大小"><a class="markdownIt-Anchor" href="#deque的大小"></a> deque的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.size();   //返回容器中元素的个数</span><br><span class="line">deque.empty();   //判断容器是否为空</span><br><span class="line">deque.resize(num);   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">deque.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqIntA;</span><br><span class="line">deqIntA.push_back(1);</span><br><span class="line">deqIntA.push_back(3);</span><br><span class="line">deqIntA.push_back(5);</span><br><span class="line"></span><br><span class="line">int iSize = deqIntA.size();  //3</span><br><span class="line"></span><br><span class="line">if (!deqIntA.empty())</span><br><span class="line">&#123;</span><br><span class="line">deqIntA.resize(5);//1 3 5 0 0</span><br><span class="line">deqIntA.resize(7,1);//1 3 5 0 0 1 1</span><br><span class="line">deqIntA.resize(2);//1 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque的插入"><a class="markdownIt-Anchor" href="#deque的插入"></a> deque的插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deque.insert(pos,elem);   //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br><span class="line">deque.insert(pos,n,elem);   //在pos位置插入n个elem数据，无返回值。</span><br><span class="line">deque.insert(pos,beg,end);   //在pos位置插入[beg,end)区间的数据，无返回值。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqA;</span><br><span class="line">deque&lt;int&gt; deqB;</span><br><span class="line"></span><br><span class="line">deqA.push_back(1);</span><br><span class="line">deqA.push_back(3);</span><br><span class="line">deqA.push_back(5);</span><br><span class="line">deqA.push_back(7);</span><br><span class="line">deqA.push_back(9);</span><br><span class="line"></span><br><span class="line">deqB.push_back(2);</span><br><span class="line">deqB.push_back(4);</span><br><span class="line">deqB.push_back(6);</span><br><span class="line">deqB.push_back(8);</span><br><span class="line"></span><br><span class="line">deqA.insert(deqA.begin(), 11);//&#123;11, 1, 3, 5, 7, 9&#125;</span><br><span class="line">deqA.insert(deqA.begin()+1,2,33);//&#123;11,33,33,1,3,5,7,9&#125;</span><br><span class="line">deqA.insert(deqA.begin() , deqB.begin() , deqB.end() );//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span><br></pre></td></tr></table></figure><h4 id="deque的删除"><a class="markdownIt-Anchor" href="#deque的删除"></a> deque的删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deque.clear();//移除容器的所有数据</span><br><span class="line">deque.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">deque.erase(pos);    //删除pos位置的数据，返回下一个数据的位置。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">删除区间内的元素</span><br><span class="line">deqInt是用deque&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。</span><br><span class="line">deque&lt;int&gt;::iterator itBegin=deqInt.begin()+1;</span><br><span class="line">deque&lt;int&gt;::iterator itEnd=deqInt.begin()+3;</span><br><span class="line">deqInt.erase(itBegin,itEnd);</span><br><span class="line">//此时容器deqInt包含按顺序的1,6,9三个元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假设 deqInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素</span><br><span class="line">for(deque&lt;int&gt;::iterator it=deqInt.being(); it!=deqInt.end(); )    //小括号里不需写  ++it</span><br><span class="line">&#123;</span><br><span class="line">   if(*it == 3)</span><br><span class="line">   &#123;</span><br><span class="line">        it  =  deqInt.erase(it);       //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span><br><span class="line">         //此时，不执行  ++it；  </span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">       ++it;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除deqInt的所有元素</span><br><span class="line">deqInt.clear();//容器为空</span><br></pre></td></tr></table></figure><h3 id="基本操作代码"><a class="markdownIt-Anchor" href="#基本操作代码"></a> 基本操作代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//deque容器初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d2(<span class="number">10</span>,<span class="number">5</span>); <span class="comment">//带参数构造函数</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d3(d2.begin(),d2.end());</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d4(d3); <span class="comment">//拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deque赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="comment">//d.assign(10,5);  赋值</span></span><br><span class="line"><span class="comment">//d.assign(d1.begin(),d1.end());</span></span><br><span class="line"></span><br><span class="line">d = d1;  <span class="comment">//重载= 赋值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (d1.empty())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"不空!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//d1.resize(5);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; d1.size() &lt;&lt; endl;</span></span><br><span class="line">d1.resize(<span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deque插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"></span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">30</span>);</span><br><span class="line">d.push_front(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size();i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = d.begin(); it != d.end(); it++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">while (d.size() &gt; 0)&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; d.back() &lt;&lt; "被删除!" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">d.pop_back();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "大小:" &lt;&lt; d.size() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//头删除</span></span><br><span class="line"><span class="keyword">while</span> (!d.empty())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d.front() &lt;&lt; <span class="string">"被删除!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">d.pop_front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deque容器插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.insert(d.begin(),<span class="number">100</span>); <span class="comment">//头插法</span></span><br><span class="line">d.insert(d.end(), <span class="number">200</span>); <span class="comment">//尾差法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = d.begin(); it != d.end(); it++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//test03();</span></span><br><span class="line"><span class="comment">//test04();</span></span><br><span class="line">test06();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例代码"><a class="markdownIt-Anchor" href="#案例代码"></a> 案例代码</h3><p>sort排序第三个参数是判断规则函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool mycompare(int v1,int v2)&#123;</span><br><span class="line"></span><br><span class="line">return v1 &gt; v2; // 排序从大大小</span><br><span class="line">//return v1 &lt; v2; //从小到大</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Player(<span class="built_in">string</span> name, <span class="keyword">int</span> score) :name(name), score(score)&#123;&#125;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> score; <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建选手</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_Player</span><span class="params">(<span class="built_in">vector</span>&lt;Player&gt;&amp; v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> nameseed = <span class="string">"ABCDE"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"选手"</span>;</span><br><span class="line">name += nameseed[i];</span><br><span class="line"><span class="function">Player <span class="title">p</span><span class="params">(name,<span class="number">0</span>)</span></span>;  <span class="comment">//创建选手</span></span><br><span class="line">v.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycompare</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v1 &gt; v2)&#123;  <span class="comment">//从大到小</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Set_Player_Score</span><span class="params">(<span class="built_in">vector</span>&lt;Player&gt;&amp; plist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Player&gt;::iterator it = plist.begin(); it != plist.end();it++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dscore;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> score = <span class="number">50</span> + rand() % <span class="number">50</span>; <span class="comment">//打分</span></span><br><span class="line">dscore.push_back(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序 sort</span></span><br><span class="line">sort(dscore.begin(), dscore.end(), mycompare);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (deque&lt;int&gt;::iterator it = dscore.begin(); it != dscore.end();it ++)&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; *it &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">dscore.pop_front(); <span class="comment">//去除最高分</span></span><br><span class="line">dscore.pop_back(); <span class="comment">//去除最低分</span></span><br><span class="line"><span class="comment">//分数总结</span></span><br><span class="line"><span class="keyword">int</span> totalscore = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator dit = dscore.begin(); dit != dscore.end(); dit++)&#123;</span><br><span class="line">totalscore += *dit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> scoreavg = totalscore / dscore.size();</span><br><span class="line">(*it).score = scoreavg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示5名选手得分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show_Player_Score</span><span class="params">(<span class="built_in">vector</span>&lt;Player&gt;&amp; plist)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Player&gt;::iterator it = plist.begin(); it != plist.end(); it++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名:"</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">" 分数:"</span> &lt;&lt; it-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Player&gt;  vPlayer;  <span class="comment">//存放我们的选手信息</span></span><br><span class="line">Create_Player(vPlayer); <span class="comment">//创建选手</span></span><br><span class="line">Set_Player_Score(vPlayer);</span><br><span class="line">Show_Player_Score(vPlayer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//评委打分案例(sort 算法排序)</span></span><br><span class="line"><span class="comment">//创建 5 个选手(姓名，得分)，10 个评委对 5 个选手进行打分</span></span><br><span class="line"><span class="comment">//得分规则：去除最高分，去除最低分，取出平均分</span></span><br><span class="line"><span class="comment">//按得分对 5 名选手进行排名</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;deque简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#deque简介&quot;&gt;&lt;/a&gt; Deque简介&lt;/h4&gt;
&lt;p&gt;deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>STL的vector容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/29/cpp0079-STL%E7%9A%84vector%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/29/cpp0079-STL的vector容器/</id>
    <published>2021-06-29T05:23:08.000Z</published>
    <updated>2021-06-29T06:11:06.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stl的vector容器"><a class="markdownIt-Anchor" href="#stl的vector容器"></a> STL的vector容器</h1><h4 id="1vector容器简介"><a class="markdownIt-Anchor" href="#1vector容器简介"></a> 1Vector容器简介</h4><p>vector是将元素置于一个动态数组中加以管理的容器。</p><p>vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。</p><p>vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时</p><h4 id="2vector对象的默认构造"><a class="markdownIt-Anchor" href="#2vector对象的默认构造"></a> 2vector对象的默认构造</h4><p>vector采用模板类实现，vector对象的默认构造形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; vecT; </span><br><span class="line">vector&lt;int&gt; vecInt;        //一个存放int的vector容器。</span><br><span class="line">vector&lt;float&gt; vecFloat;     //一个存放float的vector容器。</span><br><span class="line">vector&lt;string&gt; vecString;   //一个存放string的vector容器。</span><br><span class="line">...    //尖括号内还可以设置指针类型或自定义类型。</span><br><span class="line">Class CA&#123;&#125;;</span><br><span class="line">vector&lt;CA*&gt; vecpCA;  //用于存放CA对象的指针的vector容器。</span><br><span class="line">vector&lt;CA&gt; vecCA;     //用于存放CA对象的vector容器。由于容器元素的存放是按值复制的方式进行的，所以此时CA必须提供CA的拷贝构造函数，以保证CA对象间拷贝正常。</span><br></pre></td></tr></table></figure><h4 id="3vector对象的带参数构造"><a class="markdownIt-Anchor" href="#3vector对象的带参数构造"></a> 3vector对象的带参数构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector(beg,end);    //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</span><br><span class="line">vector(n,elem);   //构造函数将n个elem拷贝给本身。</span><br><span class="line">vector(const vector &amp;vec);  //拷贝构造函数</span><br><span class="line"></span><br><span class="line">int  iArray[] = &#123;0,1,2,3,4&#125;;</span><br><span class="line">vector&lt;int&gt;  vecIntA( iArray,  iArray+5 );</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vecIntB (  vecIntA.begin() , vecIntA.end()  );   //用构造函数初始化容器vecIntB </span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vecIntB (  vecIntA.begin() , vecIntA.begin()+3  );  </span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vecIntC(3,9); //此代码运行后，容器vecIntB就存放3个元素，每个元素的值是9。</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vecIntD(vecIntA);</span><br></pre></td></tr></table></figure><h4 id="4vector的赋值"><a class="markdownIt-Anchor" href="#4vector的赋值"></a> 4vector的赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">理论知识</span><br><span class="line">vector.assign(beg,end);    //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</span><br><span class="line">vector.assign(n,elem);  //将n个elem拷贝赋值给本身。</span><br><span class="line">vector&amp; operator=(const vector  &amp;vec);//重载等号操作符</span><br><span class="line">vector.swap(vec);  // 将vec与本身的元素互换。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;int&gt; vecIntA, vecIntB, vecIntC, vecIntD;</span><br><span class="line">int  iArray[] = &#123;0,1,2,3,4&#125;;</span><br><span class="line">vecIntA.assign(iArray,iArray+5);</span><br><span class="line"></span><br><span class="line">vecIntB.assign( vecIntA.begin(),  vecIntA.end() );    //用其它容器的迭代器作参数。</span><br><span class="line"></span><br><span class="line">vecIntC.assign(3,9);</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vecIntD;</span><br><span class="line">vecIntD = vecIntA;</span><br><span class="line"></span><br><span class="line">vecIntA.swap(vecIntD);</span><br></pre></td></tr></table></figure><h4 id="5vector的大小"><a class="markdownIt-Anchor" href="#5vector的大小"></a> 5vector的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">理论知识</span><br><span class="line">vector.size();   //返回容器中元素的个数</span><br><span class="line"></span><br><span class="line">vector.empty();   //判断容器是否为空</span><br><span class="line"></span><br><span class="line">vector.resize(num);   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line"></span><br><span class="line">vector.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line"></span><br><span class="line">vi.reserve(num);//设置容量</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如   vecInt是vector&lt;int&gt;  声明的容器，现已包含1,2,3元素。</span><br><span class="line">int iSize = vecInt.size();//iSize == 3;</span><br><span class="line">bool bEmpty = vecInt.empty();// bEmpty == false;</span><br><span class="line">执行vecInt.resize(5);  //此时里面包含1,2,3,0,0元素。</span><br><span class="line">再执行vecInt.resize(8,3);  //此时里面包含1,2,3,0,0,3,3,3元素。</span><br><span class="line">再执行vecInt.resize(2);  //此时里面包含1,2元素。</span><br></pre></td></tr></table></figure><h4 id="6vector末尾的添加移除操作"><a class="markdownIt-Anchor" href="#6vector末尾的添加移除操作"></a> 6vector末尾的添加移除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vecInt;</span><br><span class="line">vecInt.push_back(1);  //在容器尾部加入一个元素</span><br><span class="line">vecInt.push_back(3);  </span><br><span class="line">vecInt.push_back(5);  </span><br><span class="line">vecInt.push_back(7); </span><br><span class="line">vecInt.push_back(9); </span><br><span class="line">vecInt.pop_back();    //移除容器中最后一个元素</span><br><span class="line">vecInt.pop_back();</span><br><span class="line">//&#123;5 ,7 ,9&#125;</span><br></pre></td></tr></table></figure><h4 id="7vector的数据存取"><a class="markdownIt-Anchor" href="#7vector的数据存取"></a> 7vector的数据存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">理论知识</span><br><span class="line">vec.at(idx);  //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span><br><span class="line">vec[idx];  //返回索引idx所指的数据，越界时，运行直接报错</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vecInt;    //假设包含1 ,3 ,5 ,7 ,9</span><br><span class="line">vecInt.at(2) == vecInt[2];//5</span><br><span class="line">vecInt.at(2) = 8;  或  vecInt[2] = 8;</span><br><span class="line">vecInt 就包含 1, 3, 8, 7, 9值</span><br><span class="line"></span><br><span class="line">int iF = vector.front();//iF==1</span><br><span class="line">int iB = vector.back();//iB==9</span><br><span class="line">vector.front() = 11;//vecInt包含&#123;11,3,8,7,9&#125;</span><br><span class="line">vector.back() = 19;//vecInt包含&#123;11,3,8,7,19&#125;</span><br></pre></td></tr></table></figure><h4 id="8迭代器基本原理"><a class="markdownIt-Anchor" href="#8迭代器基本原理"></a> 8迭代器基本原理</h4><p>迭代器是一个“可遍历STL容器内全部或部分元素”的对象。</p><p>迭代器指出容器中的一个特定位置。</p><p>迭代器就如同一个指针。</p><p>迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围。</p><p>这里大概介绍一下迭代器的类别。<br><code>输入迭代器</code>：也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</p><p><code>输出迭代器</code>：也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</p><p><code>正向迭代器</code>：组合输入迭代器和输出迭代器的功能，还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。</p><p><code>双向迭代器</code>：组合正向迭代器的功能，还可以通过–操作符向后移动位置。<br>随机访问迭代器：组合双向迭代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</p><p>目前本系列教程所用到的容器，都支持双向迭代器或随机访问迭代器，下面将会详细介绍这两个类别的迭代器。</p><h4 id="9双向迭代器与随机访问迭代器"><a class="markdownIt-Anchor" href="#9双向迭代器与随机访问迭代器"></a> 9双向迭代器与随机访问迭代器</h4><p>双向迭代器支持的操作：</p><p>it++, ++it,  it–,  --it，*it， itA = itB，</p><p>itA == itB，itA != itB</p><p>​     其中list,set,multiset,map,multimap支持双向迭代器。</p><p>随机访问迭代器支持的操作：</p><p>在双向迭代器的操作基础上添加</p><p>it+=i， it-=i， it+i(或it=it+i)，it[i],</p><p>itA&lt;itB,  itA&lt;=itB, itA&gt;itB, itA&gt;=itB 的功能。</p><p>​     其中vector，deque支持随机访问迭代器。</p><h4 id="10vector与迭代器的配合使用"><a class="markdownIt-Anchor" href="#10vector与迭代器的配合使用"></a> 10vector与迭代器的配合使用</h4><p><img src="/images/javawz/1624945151928.png" alt="1624945151928"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;  vecInt; //假设包含1,3,5,7,9元素</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it;//声明容器vector&lt;int&gt;的迭代器。</span><br><span class="line"></span><br><span class="line">it = vecInt.begin();    // *it == 1</span><br><span class="line"></span><br><span class="line">++it;//或者it++;  *it == 3  ，前++的效率比后++的效率高，前++返回引用，后++返回值。</span><br><span class="line"></span><br><span class="line">it += 2;//*it == 7</span><br><span class="line"></span><br><span class="line">it = it+1;//*it == 9</span><br><span class="line"></span><br><span class="line">++it;// it == vecInt.end();  此时不能再执行*it,会出错!</span><br></pre></td></tr></table></figure><p>正向遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(vector&lt;int&gt;::iterator it=vecInt.begin(); it!=vecInt.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">      int iItem = *it; </span><br><span class="line">      cout &lt;&lt; iItem;    //或直接使用  cout &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(vector&lt;int&gt;::reverse_iterator rit=vecInt.rbegin(); rit!=vecInt.rend(); ++rit)    //注意，小括号内仍是++rit</span><br><span class="line">&#123;</span><br><span class="line">int iItem  = *rit;</span><br><span class="line">      cout &lt;&lt; iItem;//或直接使用cout &lt;&lt; *rit;</span><br><span class="line">&#125;</span><br><span class="line">此时将打印出9,7,5,3,1</span><br><span class="line">注意，这里迭代器的声明采用vector&lt;int&gt;::reverse_iterator，而非vector&lt;int&gt;::iterator。</span><br></pre></td></tr></table></figure><p>迭代器还有其它两种声明方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::const_iterator 与 vector&lt;int&gt;::const_reverse_iterator</span><br></pre></td></tr></table></figure><p>以上两种分别是vector&lt;int&gt;::iterator 与vector&lt;int&gt;::reverse_iterator 的只读形式，使用这两种迭代器时，不会修改到容器中的值。</p><p>备注：不过容器中的insert和erase方法仅接受这四种类型中的iterator，其它三种不支持。《Effective STL》建议我们尽量使用iterator取代const_iterator、reverse_iterator和const_reverse_iterator。</p><h4 id="11vector的插入"><a class="markdownIt-Anchor" href="#11vector的插入"></a> 11vector的插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector.insert(pos,elem);   //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br><span class="line">vector.insert(pos,n,elem);   //在pos位置插入n个elem数据，无返回值。</span><br><span class="line">vector.insert(pos,beg,end);   //在pos位置插入[beg,end)区间的数据，无返回值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">简单案例</span><br><span class="line">vector&lt;int&gt; vecA;</span><br><span class="line">vector&lt;int&gt; vecB;</span><br><span class="line"></span><br><span class="line">vecA.push_back(1);</span><br><span class="line">vecA.push_back(3);</span><br><span class="line">vecA.push_back(5);</span><br><span class="line">vecA.push_back(7);</span><br><span class="line">vecA.push_back(9);</span><br><span class="line"></span><br><span class="line">vecB.push_back(2);</span><br><span class="line">vecB.push_back(4);</span><br><span class="line">vecB.push_back(6);</span><br><span class="line">vecB.push_back(8);</span><br><span class="line"></span><br><span class="line">vecA.insert(vecA.begin(), 11);//&#123;11, 1, 3, 5, 7, 9&#125;</span><br><span class="line">vecA.insert(vecA.begin()+1,2,33);//&#123;11,33,33,1,3,5,7,9&#125;</span><br><span class="line">vecA.insert(vecA.begin() , vecB.begin() , vecB.end() );//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span><br></pre></td></tr></table></figure><h4 id="12vector的删除"><a class="markdownIt-Anchor" href="#12vector的删除"></a> 12vector的删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">理论知识</span><br><span class="line">vector.clear();//移除容器的所有数据</span><br><span class="line">vec.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">vec.erase(pos);    //删除pos位置的数据，返回下一个数据的位置。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">简单案例:</span><br><span class="line">删除区间内的元素</span><br><span class="line">vecInt是用vector&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。</span><br><span class="line">vector&lt;int&gt;::iterator itBegin=vecInt.begin()+1;</span><br><span class="line">vector&lt;int&gt;::iterator itEnd=vecInt.begin()+2;</span><br><span class="line">vecInt.erase(itBegin,itEnd);</span><br><span class="line">//此时容器vecInt包含按顺序的1,6,9三个元素。</span><br><span class="line"></span><br><span class="line">假设 vecInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素</span><br><span class="line">for(vector&lt;int&gt;::iterator it=vecInt.being(); it!=vecInt.end(); )    //小括号里不需写  ++it</span><br><span class="line">&#123;</span><br><span class="line">   if(*it == 3)</span><br><span class="line">   &#123;</span><br><span class="line">        it  =  vecInt.erase(it);       //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span><br><span class="line">         //此时，不执行  ++it；  </span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">       ++it;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除vecInt的所有元素</span><br><span class="line">vecInt.clear();//容器为空</span><br></pre></td></tr></table></figure><h3 id="巧用swap收缩vector空间容量"><a class="markdownIt-Anchor" href="#巧用swap收缩vector空间容量"></a> 巧用swap收缩vector空间容量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"></span><br><span class="line">vi.resize(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">vi.reserve(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vi.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cap: "</span> &lt;&lt; vi.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"================================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vi).swap(vi); <span class="comment">//先创建一个匿名对象,用vi的元素个数初始化,然后交换vi的ptr指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vi.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cap: "</span> &lt;&lt; vi.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reserve预留空间提高程序效率"><a class="markdownIt-Anchor" href="#reserve预留空间提高程序效率"></a> reserve预留空间提高程序效率</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">int</span> * pAddress = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">vi.reserve(<span class="number">100000</span>);<span class="comment">//如果提前知道了数据的个数,可以提前设置好容量的大小,避免频繁改动内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vi.push_back(i);</span><br><span class="line"><span class="keyword">if</span> (pAddress != &amp;vi[<span class="number">0</span>]) &#123;</span><br><span class="line">pAddress = &amp;vi[<span class="number">0</span>];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::left);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"vi的内存变动了"</span> &lt;&lt; num &lt;&lt; <span class="string">"次"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stl的vector容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stl的vector容器&quot;&gt;&lt;/a&gt; STL的vector容器&lt;/h1&gt;
&lt;h4 id=&quot;1vector容器简介&quot;&gt;&lt;a class=&quot;markdownIt-Anc
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>STL的string容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/29/cpp0078-STL%E7%9A%84string%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/29/cpp0078-STL的string容器/</id>
    <published>2021-06-29T04:18:51.000Z</published>
    <updated>2021-06-29T06:10:53.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stl的string容器"><a class="markdownIt-Anchor" href="#stl的string容器"></a> STL的string容器</h1><h3 id="1string概念"><a class="markdownIt-Anchor" href="#1string概念"></a> 1String概念</h3><p>string是STL的字符串类型，通常用来表示字符串。而在使用string之前，字符串通常是用char<em>表示的。string与char</em>都可以用来表示字符串，那么二者有什么区别呢。</p><p>string和char*的比较</p><p>string是一个类, char*是一个指向字符的指针。</p><p>string封装了char*，管理这个字符串，是一个char*型的容器。</p><p>string不用考虑内存释放和越界。</p><p>string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</p><p>string提供了一系列的字符串操作函数（这个等下会详讲）</p><p>查找find，拷贝copy，删除erase，替换replace，插入insert</p><h3 id="2string的构造函数"><a class="markdownIt-Anchor" href="#2string的构造函数"></a> 2string的构造函数</h3><p>默认构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string();    //构造一个空的字符串string s1。</span><br></pre></td></tr></table></figure><p>拷贝构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(const string &amp;str); //构造一个与str一样的string。如string s1(s2)。</span><br></pre></td></tr></table></figure><p>带参数的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string(const char *s);  //用字符串s初始化</span><br><span class="line"></span><br><span class="line">string(int n,char c);  //用n个字符c初始化</span><br></pre></td></tr></table></figure><h4 id="3string的存取字符操作"><a class="markdownIt-Anchor" href="#3string的存取字符操作"></a> 3string的存取字符操作</h4><p>string类的字符操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const char &amp;operator[] (int n) const;</span><br><span class="line"></span><br><span class="line">const char &amp;at(int n) const;</span><br><span class="line"></span><br><span class="line">char &amp;operator[] (int n);</span><br><span class="line"></span><br><span class="line">char &amp;at(int n);</span><br></pre></td></tr></table></figure><p>operator[]和at()均返回当前字符串中第n个字符，但二者是有区别的。</p><p>​    主要区别在于at()在越界时会抛出异常，[]在刚好越界时会返回(char)0，再继续越界时，编译器直接出错。如果你的程序希望可以通过try,catch捕获异常，建议采用at()。</p><h3 id="4从string取得const-char的操作"><a class="markdownIt-Anchor" href="#4从string取得const-char的操作"></a> 4从string取得const char*的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *c_str() const;   //返回一个以&apos;\0&apos;结尾的字符串的首地址</span><br></pre></td></tr></table></figure><h3 id="5把string拷贝到char指向的内存空间的操作"><a class="markdownIt-Anchor" href="#5把string拷贝到char指向的内存空间的操作"></a> 5把string拷贝到char*指向的内存空间的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int copy(char *s, int n, int pos=0) const;</span><br></pre></td></tr></table></figure><p>把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目。注意要保证s所指向的空间足够大以容纳当前字符串，不然会越界。</p><h3 id="6string的长度"><a class="markdownIt-Anchor" href="#6string的长度"></a> 6string的长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int length() const;   //返回当前字符串的长度。长度不包括字符串结尾的&apos;\0&apos;。</span><br><span class="line">bool empty() const;     //当前字符串是否为空</span><br></pre></td></tr></table></figure><h3 id="7string的赋值"><a class="markdownIt-Anchor" href="#7string的赋值"></a> 7string的赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string &amp;operator=(const string &amp;s);//把字符串s赋给当前的字符串</span><br><span class="line"></span><br><span class="line">string &amp;assign(const char *s); //把字符串s赋给当前的字符串</span><br><span class="line"></span><br><span class="line">string &amp;assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串</span><br><span class="line"></span><br><span class="line">string &amp;assign(const string &amp;s);  //把字符串s赋给当前字符串</span><br><span class="line"></span><br><span class="line">string &amp;assign(int n,char c);  //用n个字符c赋给当前字符串</span><br><span class="line"></span><br><span class="line">string &amp;assign(const string &amp;s,int start, int n);  //把字符串s中从start开始的n个字符赋给当前字符串</span><br></pre></td></tr></table></figure><h3 id="8string字符串连接"><a class="markdownIt-Anchor" href="#8string字符串连接"></a> 8string字符串连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string &amp;operator+=(const string &amp;s);  //把字符串s连接到当前字符串结尾</span><br><span class="line"></span><br><span class="line">string &amp;operator+=(const char *s);//把字符串s连接到当前字符串结尾</span><br><span class="line"></span><br><span class="line">string &amp;append(const char *s);    //把字符串s连接到当前字符串结尾</span><br><span class="line"></span><br><span class="line">string &amp;append(const char *s,int n);  //把字符串s的前n个字符连接到当前字符串结尾</span><br><span class="line"></span><br><span class="line">string &amp;append(const string &amp;s);   //同operator+=()</span><br><span class="line"></span><br><span class="line">string &amp;append(const string &amp;s,int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span><br><span class="line"></span><br><span class="line">string &amp;append(int n, char c);   //在当前字符串结尾添加n个字符c</span><br></pre></td></tr></table></figure><h4 id="9string的比较"><a class="markdownIt-Anchor" href="#9string的比较"></a> 9string的比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int compare(const string &amp;s) const;  //与字符串s比较</span><br><span class="line">int compare(const char *s) const;   //与字符串s比较</span><br></pre></td></tr></table></figure><p>compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的A比小写的a小。</p><h3 id="10string的子串"><a class="markdownIt-Anchor" href="#10string的子串"></a> 10string的子串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string substr(int pos=0, int n=npos) const;    //返回由pos开始的n个字符组成的子字符串</span><br></pre></td></tr></table></figure><h3 id="11string的查找-和-替换"><a class="markdownIt-Anchor" href="#11string的查找-和-替换"></a> 11string的查找 和 替换</h3><h4 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int find(char c,int pos=0) const;  //从pos开始查找字符c在当前字符串的位置 </span><br><span class="line"></span><br><span class="line">int find(const char *s, int pos=0) const;  //从pos开始查找字符串s在当前字符串的位置</span><br><span class="line"></span><br><span class="line">int find(const string &amp;s, int pos=0) const;  //从pos开始查找字符串s在当前字符串中的位置</span><br><span class="line"></span><br><span class="line">find函数如果查找不到，就返回-1</span><br><span class="line"></span><br><span class="line">int rfind(char c, int pos=npos) const;   //从pos开始从后向前查找字符c在当前字符串中的位置 </span><br><span class="line"></span><br><span class="line">int rfind(const char *s, int pos=npos) const;</span><br><span class="line"></span><br><span class="line">int rfind(const string &amp;s, int pos=npos) const;</span><br><span class="line">//rfind是反向查找的意思，如果查找不到， 返回-1</span><br></pre></td></tr></table></figure><h4 id="替换"><a class="markdownIt-Anchor" href="#替换"></a> 替换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string &amp;replace(int pos, int n, const char *s);//删除从pos开始的n个字符，然后在pos处插入串s</span><br><span class="line"></span><br><span class="line">string &amp;replace(int pos, int n, const string &amp;s);  //删除从pos开始的n个字符，然后在pos处插入串s</span><br><span class="line"></span><br><span class="line">void swap(string &amp;s2);    //交换当前字符串与s2的值</span><br></pre></td></tr></table></figure><h3 id="12string的区间删除和插入"><a class="markdownIt-Anchor" href="#12string的区间删除和插入"></a> 12String的区间删除和插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string &amp;insert(int pos, const char *s);</span><br><span class="line">string &amp;insert(int pos, const string &amp;s);</span><br><span class="line">//前两个函数在pos位置插入字符串s</span><br><span class="line">string &amp;insert(int pos, int n, char c);  //在pos位置 插入n个字符c</span><br><span class="line"></span><br><span class="line">string &amp;erase(int pos=0, int n=npos);  //删除pos开始的n个字符，返回修改后的字符串</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//char* 和 string转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string类型转换为char*字符串</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = s.c_str();</span><br><span class="line"></span><br><span class="line"><span class="comment">//char*类型字符串转换为string类型字符串</span></span><br><span class="line"><span class="keyword">char</span>* str2 = <span class="string">"acbd"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(str2)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s; <span class="comment">//默认构造</span></span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"acbd"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string容器字符串赋值和存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//string容器赋值</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s = <span class="string">"abcd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s2;</span><br><span class="line">s2.assign(<span class="string">"pppp"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//string容器存取</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s3.size();i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s3.size();i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//【】访问方式访问越界时候，不会抛异常，直接挂掉</span></span><br><span class="line"><span class="comment">//at会抛出异常</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; s3[100] &lt;&lt; endl;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3.at(<span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (...)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"访问越界!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string容器拼接操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"aaa"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"bbb"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string s3 = s1 + s2;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; s3 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s1 += s2;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; s1 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法方式 append</span></span><br><span class="line">s1.append(s2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string查找和替换 比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">" acbdefg"</span>;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">string</span> target = <span class="string">"bd"</span>;</span><br><span class="line"><span class="keyword">int</span> pos = s.find(target);</span><br><span class="line"><span class="keyword">char</span>* target2 = <span class="string">"ef"</span>;</span><br><span class="line"><span class="keyword">int</span> pos2 = s.find(target2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pos:"</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pos2:"</span> &lt;&lt; pos2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos3 = s.rfind(target);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pos3:"</span> &lt;&lt; pos3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串替换</span></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"acbd"</span>;</span><br><span class="line">s.replace(<span class="number">0</span>, <span class="number">2</span>, s1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string 比较 子串 插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较</span></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"abd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = s1.compare(s2);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s1 &gt; s2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s1 &lt; s2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s1 == s2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="built_in">string</span> s4 = s3.substr(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s4"</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">"abcd"</span>;</span><br><span class="line">s5.insert(<span class="number">0</span>, <span class="string">"pppp"</span>);</span><br><span class="line"><span class="built_in">string</span> s6 = <span class="string">"qqqq"</span>;</span><br><span class="line">s5.insert(s5.size(), s6);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">s5.erase(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="comment">//test03();</span></span><br><span class="line"><span class="comment">//test04();</span></span><br><span class="line"><span class="comment">//test05();</span></span><br><span class="line">test06();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stl的string容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stl的string容器&quot;&gt;&lt;/a&gt; STL的string容器&lt;/h1&gt;
&lt;h3 id=&quot;1string概念&quot;&gt;&lt;a class=&quot;markdownIt-Ancho
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>STL基础理论</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/29/cpp0077-STL%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/29/cpp0077-STL基础理论/</id>
    <published>2021-06-29T03:39:14.000Z</published>
    <updated>2021-06-29T03:56:38.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stl实用技术专题"><a class="markdownIt-Anchor" href="#stl实用技术专题"></a> STL实用技术专题</h1><h2 id="stl标准模板库理论基础"><a class="markdownIt-Anchor" href="#stl标准模板库理论基础"></a> STL(标准模板库)理论基础</h2><h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3><p>STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现在C<ins>中，但在被引入C</ins>之前该技术就已经存在了很长的一段时间。</p><p>STL的从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文 件：&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt; 和&lt;utility&gt;。</p><p>​                                  <img src="/images/javawz/1624938401945.png" alt="1624938401945"></p><p>STL详细的说六大组件</p><p>–  容器（Container）</p><p>–  算法（Algorithm）</p><p>–  迭代器（Iterator）</p><p>–  仿函数（Function object）</p><p>–  适配器（Adaptor）</p><p>–  空间配制器（allocator）</p><h3 id="使用stl的好处"><a class="markdownIt-Anchor" href="#使用stl的好处"></a> 使用STL的好处</h3><p>1）STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p><p>2）STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。</p><p>例如，在STL的vector容器中，可以放入元素、基础数据类型变量、元素的地址；</p><p>STL的sort()函数可以用来操作vector,list等容器。</p><p>1）  程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p><p>2） STL具有高可重用性，高性能，高移植性，跨平台的优点。</p><p>高可重用性：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p><p>高性能：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种)</p><p>高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。</p><p>​         跨平台：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。</p><p>3） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p><p>4） 了解到STL的这些好处，我们知道STL无疑是最值得C<ins>程序员骄傲的一部分。每一个C＋＋程序员都应该好好学习STL。只有能够熟练使用STL的程序员，才是好的C</ins>程序员。</p><p>5）  总之：招聘工作中，经常遇到C<ins>程序员对STL不是非常了解。大多是有一个大致的映像，而对于在什么情况下应该使用哪个容器和算法都感到比较茫然。STL是C</ins>程序员的一项不可或缺的基本技能，掌握它对提升C++编程大有裨益。</p><h3 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h3><p>在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。</p><p>经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在 细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用已有的实现构造自己的特定类型下的数据结构，通过设置一些模板，STL容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。</p><p>容器部分主要由头文 件&lt;vector&gt;,&lt;list&gt;,&lt;deque&gt;,&lt;set&gt;,&lt;map&gt;,&lt;stack&gt; 和&lt;queue&gt;组成。对于常用的一些容器和容器适配器（可以看作由其它容器实现的容器），可以通过下表总结一下它们和相应头文件的对应关系。</p><h4 id="容器的概念"><a class="markdownIt-Anchor" href="#容器的概念"></a> 容器的概念</h4><p>用来管理一组元素</p><p><img src="/images/javawz/1624938571486.png" alt="1624938571486"></p><h3 id="容器的分类"><a class="markdownIt-Anchor" href="#容器的分类"></a> 容器的分类</h3><p>序列式容器（Sequence containers）</p><p>每个元素都有固定位置－－取决于插入时机和地点，和元素值无关。</p><p>vector、deque、list</p><p>关联式容器（Associated containers）</p><p>元素位置取决于特定的排序准则，和插入顺序无关</p><p>set、multiset、map、multimap</p><p><img src="/images/javawz/1624938647706.png" alt="1624938647706"></p><h3 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h3><p>迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化， 这种简化在STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通 过迭代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。</p><p>迭代器部分主要由头文件&lt;utility&gt;,&lt;iterator&gt;和&lt;memory&gt;组 成。&lt;utility&gt;是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，&lt;iterator&gt;中提供了迭代器 使用的许多方法，而对于&lt;memory&gt;的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生 的临时对象提供机制,&lt;memory&gt;中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器。</p><h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3><p>函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使 用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提 供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种 类中的其他类型。</p><p>STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以 你所指定的规则对序列进行稳定性排序等等。这样一来，只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要 的功能并大大地提升效率。</p><p>算法部分主要由头文件&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;组 成。&lt;algorithm&gt;是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上 都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。&lt;numeric&gt;体积很 小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。&lt;functional&gt;中则定义了一些模板类， 用以声明函数对象。</p><h3 id="c标准库"><a class="markdownIt-Anchor" href="#c标准库"></a> C++标准库</h3><p>C<ins>强大的功能来源于其丰富的类库及库函数资源。C</ins>标准库的内容总共在50个标准头文件中定义。在C++开发中，要尽可能地利用标准库完 成。这样做的直接好处包括：（1）成本：已经作为标准提供，何苦再花费时间、人力重新开发呢；（2）质量：标准库的都是经过严格测试的，正确性有保证； （3）效率：关于人的效率已经体现在成本中了，关于代码的执行效率要相信实现标准库的大牛们的水平；（4）良好的编程风格：采用行业中普遍的做法进行开发。</p><p>在C++程序设计课程中，尤其是作为第一门程序设计课程，我们注重了语法、语言的机制等方面的内容。程序设计能力的培养有个过程，跨过基本的原 理性知识直接进入到工程</p><p>中的普遍做法，由于跨度决定了其难度。再者，在掌握了基本原理的基础上，在认识标准库的问题上完全可以凭借实践，逐步地掌握。标准 库的学习不需要认认真真地读书，需要的是在了解概貌的情况下，在实践中深入。</p><p>这个任务就是要知道C++程序设计课程中不讲的，但对程序设计又很重要的这部分内容。至少我们要能先回答出“有什么”的问题。</p><p>C++标准库的内容分为10类，分别是（建议在阅读中，将你已经用过或听说过的头文件划出来）：</p><p>C1. 标准库中与语言支持功能相关的头文件</p><p><img src="/images/javawz/1624938841622.png" alt="1624938841622"></p><p>C2. 支持流输入/输出的头文件</p><p><img src="/images/javawz/1624938863804.png" alt="1624938863804"></p><p><img src="/images/javawz/1624938872087.png" alt="1624938872087"></p><p><img src="/images/javawz/1624938893530.png" alt="1624938893530"></p><p><img src="/images/javawz/1624938910448.png" alt="1624938910448"></p><p><img src="/images/javawz/1624938922112.png" alt="1624938922112"></p><p>C<ins>标准库的所有头文件都没有扩展名。C</ins>标准库以&lt;cname&gt;形式的标准头文件提供。在 &lt;cname&gt;形式标准的头文件中，与宏相关的名称在全局作用域中定义，其他名称在std命名空间中声明。在C++中还可以使用name.h 形式的标准C库头文件名</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stl实用技术专题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stl实用技术专题&quot;&gt;&lt;/a&gt; STL实用技术专题&lt;/h1&gt;
&lt;h2 id=&quot;stl标准模板库理论基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hre
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>文件操作</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/29/cpp0076-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/29/cpp0076-文件操作/</id>
    <published>2021-06-29T01:27:59.000Z</published>
    <updated>2021-06-29T02:56:37.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文本文件操作"><a class="markdownIt-Anchor" href="#文本文件操作"></a> 文本文件操作</h1><p><img src="/images/javawz/1624931175526.png" alt="1624931175526"></p><p>ifstream类，它是从istream类派生的，用来支持从磁盘文件的输入。<br>ofstream类，它是从ostream类派生的，用来支持向磁盘文件的输出。<br>fstream类，它是从iostream类派生的，用来支持对磁盘文件的输入输出。</p><h3 id="文件的打开与关闭"><a class="markdownIt-Anchor" href="#文件的打开与关闭"></a> 文件的打开与关闭</h3><h4 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h4><p>所谓打开(open)文件是一种形象的说法，如同打开房门就可以进入房间活<br>动一样。<br>打开文件是指在文件读写之前做必要的准备工作，包括：</p><p>1）为文件流对象和指定的磁盘文件建立关联，以便使文件流流向指定的磁盘<br>文件。</p><p>2）指定文件的工作方式，如，该文件是作为输入文件还是输出文件，是ASCII<br>文件还是二进制文件等。<br>以上工作可以通过两种不同的方法实现。</p><ol><li></li></ol><p>调用文件流的成员函数open。如<br>ofstream outfile; //定义ofstream类(输出文件流类)对象outfile<br>outfile.open(“f1.dat”,ios::out); <a href="//xn--f1-1v2cr9attq17hwkl.xn--dat-wu9dv7iw01ampkoo5book">//使文件流与f1.dat文件建立关联</a><br>第2行是调用输出文件流的成员函数open打开磁盘文件f1.dat，并指定它为输出<br>文件，<br>文件流对象ouFile将向磁盘文件f1.dat输出数据。ios::out是I/O模式的一<br>种，表示以输出方式打开一个文件。或者简单地说，此时f1.dat是一个输出文<br>件，接收从内存输出的数据。<br>调用成员函数open的一般形式为：<br>文件流对象.open(磁盘文件名, 输入输出方式);<br>磁盘文件名可以包括路径，如&quot;c:\new\f1.dat&quot;，如缺省路径，则默认为当<br>前目录下的文件。</p><ol start="2"><li></li></ol><p>在定义文件流对象时指定参数<br>在声明文件流类时定义了带参数的构造函数，其中包含了打开磁盘文件<br>的功能。因此，可以在定义文件流对象时指定参数，调用文件流类的构造函数</p><p><img src="/images/javawz/1624930197915.png" alt="1624930197915"></p><p>几点说明：</p><ol><li><p>新版本的I/O类库中不提供ios::nocreate和ios::noreplace。</p></li><li><p>每一个打开的文件都有一个文件指针，该指针的初始位置由I/O方式指定，<br>每次读写都从文件指针的当前位置开始。每读入一个字节，指针就后移一个字<br>节。当文 件指针移到最后，就会遇到文件结束EOF（文件结束符也占一个字节，<br>其值为-1)，此时流对象的成员函数eof的值为非0值(一般设为1)，表示文件结<br>束 了。</p></li><li><p>可以用“位或”运算符“|”对输入输出方式进行组合，如表13.6中最后3行<br>所示那样。还可以举出下面一些例子：<br>ios::in | ios:: noreplace //打开一个输入文件，若文件不存在则返回打开失<br>败的信息<br>ios::app | ios::nocreate //打开一个输出文件，在文件尾接着写数据，若文件不存在，则返回打开失败的信息<br>ios::out l ios::noreplace //打开一个新文件作为输出文件，如果文件已存<br>在则返回打开失败的信息<br>ios::in l ios::out I ios::binary //打开一个二进制文件，可读可写<br>但不能组合互相排斥的方式，如 ios::nocreate l ios::noreplace。</p></li><li><p>如果打开操作失败，open函数的返回值为0(假)，如果是用调用构造函数的<br>方式打开文件的，则流对象的值为0。可以据此测试打开是否成功。如<br>if(outfile.open(“f1.bat”, ios::app) ==0)<br>cout &lt;&lt;“open error”;<br>或<br>if( !outfile.open(“f1.bat”, ios::app) )<br>cout &lt;&lt;“open error”;</p></li></ol><h4 id="关闭文件"><a class="markdownIt-Anchor" href="#关闭文件"></a> 关闭文件</h4><p>在对已打开的磁盘文件的读写操作完成后，应关闭该文件。关闭文件用<br>成员函数close。如<br>ouFile.close();<br>//将输出文件流所关联的磁盘文件关闭<br>所谓关闭，实际上是解除该磁盘文件与文件流的关联，原来设置的工作方式也<br>失效，这样，就不能再通过文件流对该文件进行输入或输出。此时可以将文件<br>流与其他磁盘文件建立关联，通过文件流对新的文件进行输入或输出。如<br>ouFile.open(“f2.dat”,ios::app|ios::nocreate);<br>此时文件流ouFile与f2.dat建立关联，并指定了f2.dat的工作方式。</p><h3 id="c对ascii文件的读写操作"><a class="markdownIt-Anchor" href="#c对ascii文件的读写操作"></a> C++对ASCII文件的读写操作</h3><p>如果文件的每一个字节中均以ASCII代码形式存放数据,即一个字节存放一<br>个字符,这个文件就是ASCII文件(或称字符文件)。程序可以从ASCII文件中读入若<br>干个字符,也可以向它输出一些字符。</p><ol><li></li></ol><p>用流插入运算符<code>&lt;&lt;</code>和流提取运算符<code>&gt;&gt;</code>输入输出标准类型的数据。<code>&lt;&lt;</code><br>和<code>&gt;&gt;</code>都已在iostream中被重载为能用于ostream和istream类对象的标准类型的<br>输入输出。由于ifstream和<br>ofstream分别是ostream和istream类的派生类；因此<br>它们从ostream和istream类继承了公用的重载函数，所以在对磁盘文件的操作<br>中，可以通过文件流对象和流插入运算符<code>&lt;&lt;</code>及<br>流提取运算符<code>&gt;&gt;</code>实现对磁盘<br>文件的读写，如同用cin、cout和&lt;&lt;、&gt;&gt;对标准设备进行读写一样。</p><ol start="2"><li></li></ol><p>用文件流的put、get、geiline等成员函数进行字符的输入输出，：用C++<br>流成员函数put输出单个字符、C++<br>get()函数读入一个字符和C++<br>getline()函数读<br>入一行字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> sourceFileName[] = <span class="string">"source.txt"</span>;</span><br><span class="line"><span class="keyword">char</span> destFileName[] = <span class="string">"dest.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="comment">//用构造函数打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ifstream fin(sourceFileName,ios::in); //打开输入文件</span></span><br><span class="line"><span class="comment">//ofstream fout(destFileName,ios::out); //打开输出文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">ifstream fin;</span><br><span class="line">ofstream fout;</span><br><span class="line"></span><br><span class="line">fin.open(sourceFileName,ios::in);</span><br><span class="line"><span class="comment">//以写追加模式打开文件</span></span><br><span class="line">fout.open(destFileName,ios::out | ios::app);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断文件是否打开成功</span></span><br><span class="line"><span class="comment">//这里</span></span><br><span class="line"><span class="keyword">if</span> (!fin || !fout)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> (fin.get(ch))</span><br><span class="line">&#123;</span><br><span class="line">fout &lt;&lt; ch;</span><br><span class="line"><span class="comment">//fout.put(ch); //输出一个字符到文件里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">fin.close();</span><br><span class="line">fout.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c对二进制文件的读写操作"><a class="markdownIt-Anchor" href="#c对二进制文件的读写操作"></a> C++对二进制文件的读写操作</h1><h3 id="文本模式"><a class="markdownIt-Anchor" href="#文本模式"></a> 文本模式</h3><p>在linux系统平台下是以<code>\n</code>作为换行符的</p><p>在windows系统平台下是以<code>\r\n</code>作为换行符</p><p>文本模式和二进制模式在Linux下是不区分的,但在windows模式下是区分的,因为windows模式下的换行符<code>\r\n</code>要进行转换</p><h3 id="二进制模式"><a class="markdownIt-Anchor" href="#二进制模式"></a> 二进制模式</h3><p>不进行编码转换,将内存中的内容原封不动的输出到文件或将内容原封不动的输入到内存中</p><p>1.用ios::binary模式打开文件</p><p>2.以二进制方式写到文件</p><p>​对象名.write(地址,要写入的字节大小)</p><p>3.以二进制方式读到内存</p><p>​对象名.read(地址,要读入的字节大小)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person() &#123;</span><br><span class="line">m_Age = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(m_Name,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">const</span> <span class="keyword">char</span> * name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">m_Age = age;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(m_Name, name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m_Name &lt;&lt; <span class="string">"  "</span> &lt;&lt; m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line"><span class="keyword">char</span> m_Name[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"小花"</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> fileName[] = <span class="string">"binary.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以二进制方式打开文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(fileName, ios::out | ios::binary)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(fileName, ios::in | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fin || !fout) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"文件打开失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写二进制文件,首位参数需要转换类型为char *</span></span><br><span class="line">fout.write((<span class="keyword">char</span> *) &amp;p1,<span class="keyword">sizeof</span>(p1));</span><br><span class="line">fout.write((<span class="keyword">char</span> *) &amp;p2,<span class="keyword">sizeof</span>(p2));</span><br><span class="line">fout.close();</span><br><span class="line"></span><br><span class="line">Person tP1, tP2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读二进制文件,首位参数需要转换类型为char *</span></span><br><span class="line">fin.read((<span class="keyword">char</span> *)&amp;tP1,<span class="keyword">sizeof</span>(tP1));</span><br><span class="line">fin.read((<span class="keyword">char</span> *)&amp;tP2,<span class="keyword">sizeof</span>(tP2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示输出</span></span><br><span class="line">tP1.show();</span><br><span class="line">tP2.show();</span><br><span class="line"></span><br><span class="line">fin.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文本文件操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#文本文件操作&quot;&gt;&lt;/a&gt; 文本文件操作&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1624931175526.png&quot; alt=&quot;16249311755
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>标准输入输出</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/28/cpp0075-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/28/cpp0075-标准输入输出/</id>
    <published>2021-06-28T04:14:14.000Z</published>
    <updated>2021-06-29T03:45:06.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准输入输出"><a class="markdownIt-Anchor" href="#标准输入输出"></a> 标准输入输出</h1><p><img src="/images/javawz/1624853954352.png" alt="1624853954352"></p><p><img src="/images/javawz/1624853711081.png" alt="1624853711081"></p><h3 id="缓冲区"><a class="markdownIt-Anchor" href="#缓冲区"></a> 缓冲区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有缓冲区的输入输出对象</span><br><span class="line">cout//标准输出</span><br><span class="line">cin//标准输入</span><br><span class="line">clog//打印日志</span><br><span class="line"></span><br><span class="line">没有缓冲区的输出对象</span><br><span class="line">cerr  //标准出错</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/1624853775895.png" alt="1624853775895"></p><h3 id="标准输入流-常用的cin成员方法"><a class="markdownIt-Anchor" href="#标准输入流-常用的cin成员方法"></a> 标准输入流 常用的cin成员方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ch 代表字符变量</span><br><span class="line">buff 代表字符数组</span><br><span class="line">size代表字符数组长度</span><br><span class="line"></span><br><span class="line">cin.get() //一次只能读取一个字符</span><br><span class="line">cin.get(ch) //读一个字符</span><br><span class="line">cin.get(buff,size) //可以读字符串</span><br><span class="line">cin.getline(buff,size)//输入一行</span><br><span class="line"></span><br><span class="line">cin.ignore() //从缓冲区取走一个字符并丢弃</span><br><span class="line">cin.ignore(2) //从缓冲区取走2个字符并丢弃</span><br><span class="line">cin.ignore(2,&apos;\n&apos;) //从缓冲区取走2个字符并丢弃,遇到\n提前结束</span><br><span class="line"></span><br><span class="line">cin.peek();//偷窥缓冲区内容,返回缓冲区第一个字符,不取走字符</span><br><span class="line"></span><br><span class="line">cin.putback(ch) //把ch放回缓冲区</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cin的operator&gt;&gt;操作符 //根据回车来刷新缓冲区  根据空格来隔离每个变量的内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> myInt;</span><br><span class="line"><span class="keyword">long</span> myLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; myInt;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; myLong;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; buf;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"myInt: "</span> &lt;&lt; myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"myLong: "</span> &lt;&lt; myLong &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"buf: "</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.get()方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.get()如果读到的不是EOF标识符，那么会永远的阻塞等待</span></span><br><span class="line"><span class="comment">//从键盘来讲ctrl+z 代表EOF标识符</span></span><br><span class="line"><span class="keyword">while</span> ((ch = <span class="built_in">cin</span>.get() )!= EOF) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"从输入缓冲区去读取数据，如果缓冲区中没有数据，就阻塞"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//cin.get(a); //从输入缓冲区去读取数据，如果有就给a</span></span><br><span class="line"><span class="comment">//cin.get(b);</span></span><br><span class="line"><span class="comment">//cin.get(c);</span></span><br><span class="line"><span class="comment">//cin.get(a).get(b).get(c);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; "a  =" &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "b  =" &lt;&lt; b&lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "c  =" &lt;&lt; c&lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.get(buf, <span class="number">10</span>, <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.getline()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入一个字符串 aa bb cc dd"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(buf, <span class="number">128</span>); <span class="comment">//从输入缓冲区中读数据到buf中，最多读128 ，知道遇到\n为止</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"buf:"</span> &lt;&lt;buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.ignore()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf1[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">char</span> buf2[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入一个字符串 aa  bb cc dd"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; buf1; <span class="comment">//aa</span></span><br><span class="line"><span class="built_in">cin</span>.ignore(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cin</span>.getline(buf2, <span class="number">128</span>);<span class="comment">// bb cc dd</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"buf1:"</span> &lt;&lt; buf1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"buf2:"</span> &lt;&lt; buf2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.putback()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入一个数字或者字符串"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ch = <span class="built_in">cin</span>.get(); <span class="comment">//从输入缓冲区去读一个字符</span></span><br><span class="line"><span class="keyword">if</span> ((ch &gt;= <span class="string">'0'</span>) &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的是一个数字"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="comment">//此时数字第一个字符已经读出来了。 需要将ch放回到输入缓冲区</span></span><br><span class="line"><span class="built_in">cin</span>.putback(ch); <span class="comment">//将ch仍会缓冲区， 位置就缓冲区的头部。</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"num ="</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的是一个字符串"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//cin.putback(ch);</span></span><br><span class="line"><span class="built_in">cin</span>.getline(buf, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"buf:"</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//test1();</span></span><br><span class="line"><span class="comment">//test2();</span></span><br><span class="line"><span class="comment">//test3();</span></span><br><span class="line"><span class="comment">//test4();</span></span><br><span class="line"><span class="comment">//test5();</span></span><br><span class="line">test6();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准输出流-cout常用的方法"><a class="markdownIt-Anchor" href="#标准输出流-cout常用的方法"></a> 标准输出流 cout常用的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cout.flush() //刷新缓冲区</span><br><span class="line"></span><br><span class="line">cout.put(ch)//输出一个字符</span><br><span class="line"></span><br><span class="line">cout.write(str,strLen) //输出一个字符串</span><br><span class="line"></span><br><span class="line">cout.width(10) //设置10个位宽</span><br><span class="line">cout.fill(&apos;*&apos;) //位宽空余的地方用*代替</span><br><span class="line"></span><br><span class="line">cout.setf(ios::oct) //设置八进制输出</span><br><span class="line">cout.unsetf(ios::dex) //卸载当前默认的十进制输出方式</span><br><span class="line">cout.setf(ios::showbase);//把八进制的0和十六进制的0x显示出来</span><br><span class="line">cout.setf(ios::left);//设置左对齐</span><br></pre></td></tr></table></figure><h3 id="cout常用控制符"><a class="markdownIt-Anchor" href="#cout常用控制符"></a> cout常用控制符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flush</span><br><span class="line">endl</span><br><span class="line">oct</span><br><span class="line">dec</span><br><span class="line">hex</span><br><span class="line">setbase</span><br><span class="line">setw</span><br><span class="line">setfill</span><br><span class="line">setprecision</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/1624857186021.png" alt="1624857186021"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cout.put()</span></span><br><span class="line"><span class="comment">cout.write() //向输出缓冲区中写数据</span></span><br><span class="line"><span class="comment">cout.width()</span></span><br><span class="line"><span class="comment">cout.fill()</span></span><br><span class="line"><span class="comment">cout.setf(标记)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">操作符、控制符</span></span><br><span class="line"><span class="comment">flush</span></span><br><span class="line"><span class="comment">endl</span></span><br><span class="line"><span class="comment">oct</span></span><br><span class="line"><span class="comment">dec</span></span><br><span class="line"><span class="comment">hex</span></span><br><span class="line"><span class="comment">setbase</span></span><br><span class="line"><span class="comment">setw</span></span><br><span class="line"><span class="comment">setfill</span></span><br><span class="line"><span class="comment">setprecision</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hello "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>.put(<span class="string">'h'</span>).put(<span class="string">'e'</span>).put(<span class="string">'l'</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"hello wolrd"</span>;</span><br><span class="line"><span class="built_in">cout</span>.write(str, <span class="built_in">strlen</span>(str));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>.write(str, <span class="built_in">strlen</span>(str) - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//使⽤类成员函数</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "&lt;start&gt;";</span></span><br><span class="line"><span class="comment">cout.width(30); //设置接下来要输出的长度，是30</span></span><br><span class="line"><span class="comment">cout.fill('*'); //将没有填充的多余的空间，填充成*</span></span><br><span class="line"><span class="comment">cout.setf(ios::showbase);//#include&lt;iomanip&gt;</span></span><br><span class="line"><span class="comment">cout.setf(ios::internal);//设置</span></span><br><span class="line"><span class="comment">cout &lt;&lt; hex &lt;&lt; 123 &lt;&lt; "&lt;End&gt;\n";</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使⽤ 操作符、控制符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;Start&gt;"</span></span><br><span class="line">&lt;&lt; setw(<span class="number">30</span>)</span><br><span class="line">&lt;&lt; setfill(<span class="string">'*'</span>)</span><br><span class="line">&lt;&lt; setiosflags(ios::showbase)<span class="comment">//基数</span></span><br><span class="line">&lt;&lt; setiosflags(ios::internal)</span><br><span class="line">&lt;&lt; hex</span><br><span class="line">&lt;&lt; <span class="number">123</span></span><br><span class="line">&lt;&lt; <span class="string">"&lt;End&gt;\n"</span></span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">int</span>a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"inputa:"</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"dec:"</span> &lt;&lt; dec &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//以⼗进制形式输出整数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hex:"</span> &lt;&lt; hex &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//以⼗六进制形式输出整数a</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"oct:"</span> &lt;&lt; setbase(<span class="number">8</span>) &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//以⼋进制形式输出整数a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*pt = <span class="string">"China"</span>;<span class="comment">//pt指向字符串"China"</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; pt &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指定域宽为,输出字符串</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'*'</span>) &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; pt &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指定域宽,输出字符串,空⽩处以'*'填&gt;充</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>pi = <span class="number">22.0</span> / <span class="number">7.0</span>;<span class="comment">//计算pi值</span></span><br><span class="line"><span class="comment">//按指数形式输出,8位⼩数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setiosflags(ios::scientific) &lt;&lt; setprecision(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pi="</span> &lt;&lt; pi &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出pi值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pi="</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; pi &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//改为⼩数形式输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; "pi=" &lt;&lt; setprecision(4) &lt;&lt; pi &lt;&lt; endl;//改为位⼩数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> a = <span class="number">123.456</span>, b = <span class="number">3.14159</span>, c = <span class="number">-3214.67</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setiosflags(ios::right) &lt;&lt; setprecision(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//       123.45</span></span><br><span class="line"><span class="comment">//          3.14</span></span><br><span class="line"><span class="comment">//    -3214.67</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test1();</span></span><br><span class="line"><span class="comment">//test2();</span></span><br><span class="line"><span class="comment">//test3(); </span></span><br><span class="line">test4();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标准输入输出&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#标准输入输出&quot;&gt;&lt;/a&gt; 标准输入输出&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1624853954352.png&quot; alt=&quot;16248539543
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>事件选择模型</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/25/WS004%E4%BA%8B%E4%BB%B6%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/25/WS004事件选择模型/</id>
    <published>2021-06-24T23:51:59.000Z</published>
    <updated>2021-06-25T17:34:03.736Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/javawz/事件选择模型.png" height="100%" width="200%"><hr><img src="/images/javawz/事件模型对比select模型流程图1.png" height="100%" width="100%"><h1 id="事件选择模型"><a class="markdownIt-Anchor" href="#事件选择模型"></a> 事件选择模型</h1><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><h3 id="windows处理用户行为的两种方式"><a class="markdownIt-Anchor" href="#windows处理用户行为的两种方式"></a> windows处理用户行为的两种方式</h3><ul><li><p>消息机制</p><ul><li><p>核心：消息队列</p><ul><li><p>处理过程</p><ul><li>所有的用户操作，比如点鼠标，摁键盘，点软件上的按钮…等等，所有操作均依次按顺序被记录，装进一个队列</li></ul></li><li><p>特点</p><ul><li>消息队列由操作系统维护，咱们做的操作，然后把消息取出来，分类处理</li><li>有先后顺序</li></ul></li><li><p>其他</p><ul><li>我们之后教大家win32,MFC课程，这部分都是基于这个消息队列，会给大家详细介绍，大家暂时从宏观理解</li><li>我们下个模型，异步选择就是基于这个消息的</li></ul></li></ul></li></ul></li><li><p>事件机制</p><ul><li><p>核心：事件集合</p><ul><li><p>处理过程</p><ul><li>根据需求，我们为用户的特定操作绑定一个事件，事件由我们自己调用API创建，需要多少创建多少</li><li>将事件投递给系统，系统就帮咱们监视着，所以不能无限创建，太多系统运行就卡了</li><li>如果操作发生了，比如用户按鼠标了，那么对应的事件就会被置成有信号，也就是类似1变2了，用个数标记aaa</li><li>我们直接获取到有信号的事件，然后处理</li></ul></li><li><p>特点</p><ul><li>所有事件都是咱们自己定义的，系统只是帮咱们置有无信号，所以我们自己掌管定义…</li><li>无序的</li></ul></li><li><p>其他</p><ul><li>咱们这个事件选择，就是应用这个</li></ul></li></ul></li></ul></li></ul><h2 id="事件选择的逻辑"><a class="markdownIt-Anchor" href="#事件选择的逻辑"></a> 事件选择的逻辑</h2><h3 id="整体逻辑跟select差不多你看这个叫wsaeventselect-名字上一看就是select的进化版"><a class="markdownIt-Anchor" href="#整体逻辑跟select差不多你看这个叫wsaeventselect-名字上一看就是select的进化版"></a> 整体逻辑跟select差不多，你看这个叫WSAEventSelect 名字上一看，就是select的进化版</h3><h3 id="第一步"><a class="markdownIt-Anchor" href="#第一步"></a> 第一步</h3><ul><li><p>创建一个事件对象（变量）</p><ul><li>WSACreateEvent</li></ul></li></ul><h3 id="第二步"><a class="markdownIt-Anchor" href="#第二步"></a> 第二步</h3><ul><li><p>为每一个事件对象绑定个socket以及操作accept,read,close…并投递给系统</p><ul><li><p>投递给系统，咱们就完全不用管了，系统自己监管</p><ul><li>咱们就去做别的事儿去了</li></ul></li><li><p>WSAEventSelect</p></li></ul></li></ul><h3 id="第三步"><a class="markdownIt-Anchor" href="#第三步"></a> 第三步</h3><ul><li><p>查看事件是否有信号</p><ul><li>WSAWaitForMultipleEvents</li></ul></li></ul><h3 id="第四步"><a class="markdownIt-Anchor" href="#第四步"></a> 第四步</h3><ul><li><p>有信号的话就分类处理</p><ul><li>WSAEnumNetworkEvents</li></ul></li></ul><h2 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h2><h3 id="网络头文件-网络库"><a class="markdownIt-Anchor" href="#网络头文件-网络库"></a> 网络头文件 网络库</h3><ul><li><p>最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。</p></li><li><p>#include &lt;WinSock2.h&gt;<br>#pragma comment(lib,“ws2_32.lib”)</p><ul><li><p>函数库</p><ul><li><p>winsock2.h</p><ul><li><p>windows socket 第2版</p><ul><li>第一版是 winsock.h</li><li>查看具体区别</li></ul></li><li><p>目前网络库有哪些版本？</p><ul><li><p>1.0<br>1.1<br>2.0<br>2.1<br>2.2</p><ul><li><p>演示MSDN</p><ul><li><p>查这个函数的详细信息</p><ul><li>WSAStartup</li></ul></li></ul></li></ul></li></ul></li><li><p>我们的开发环境支持哪个版本？</p><ul><li>打开头文件，看咱们当前编译器环境支持的最高版本</li></ul></li></ul></li><li><p>ws2_32.lib</p><ul><li><p>windows socket 第2版  32位</p><ul><li>不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll</li></ul></li></ul></li><li><p>wsock32.lib</p><ul><li>winsock.h 第一版网络库 对应的库文件</li></ul></li><li><p>这里不区分大小写</p></li></ul></li></ul></li></ul><h3 id="打开网络库"><a class="markdownIt-Anchor" href="#打开网络库"></a> 打开网络库</h3><ul><li><p>int WSAStartup(<br>WORD      wVersionRequired,<br>LPWSADATA lpWSAData<br>);</p><ul><li><p>功能</p><ul><li><p>打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用</p></li><li><p>w windows<br>s  socket<br>a Asynchronous  异步<br>startup   启动</p><ul><li><p>同步与异步</p><ul><li><p>同步</p><ul><li>阻塞/卡死状态</li></ul></li><li><p>异步</p><ul><li>多个工作同时进行</li></ul></li></ul></li></ul></li></ul></li><li><p>参数1</p><ul><li><p>我们要使用的库的版本</p></li><li><p>类型是 WORD</p><ul><li>转定义：unsigned  short</li></ul></li><li><p>WORD wVersionRequired = MAKEWORD(2,2);</p><ul><li><p>MAKEWORD(主版本,副版本)， 1.0 2.2</p></li><li><p>wVersionRequired</p><ul><li>数据高位/高地址是副版本</li><li>数据低位/低地址是主版本</li><li>用调试+计算器演示数据原理</li></ul></li></ul></li><li><p>位运算，内存操作，小端存储</p></li></ul></li><li><p>参数2</p><ul><li><p>LPWSADATA lpWSAData</p><ul><li><p>系统通过这个参数给我们一些配置信息</p><ul><li><p>注意</p><ul><li>当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则</li></ul></li></ul></li><li><p>看下有哪些信息</p><ul><li><p>struct WSAData {<br>WORD           wVersion;<br>WORD           wHighVersion;<br>unsigned short iMaxSockets;<br>unsigned short iMaxUdpDg;<br>char           *lpVendorInfo;<br>char           szDescription[WSADESCRIPTION_LEN + 1];<br>char           szSystemStatus[WSASYS_STATUS_LEN + 1];<br>}</p><ul><li><p>wVersion</p><ul><li>我们要使用的版本</li></ul></li><li><p>wHighVersion</p><ul><li>系统能提供给我们最高的版本</li></ul></li><li><p>iMaxSockets</p><ul><li>返回可用的socket的数量，2版本之后就没用了</li></ul></li><li><p>iMaxUdpDg</p><ul><li>UDP数据报信息的大小，2版本之后就没用了</li></ul></li><li><p>lpVendorInfo</p><ul><li>供应商特定的信息，2版本之后就没用了</li></ul></li><li><p>szDescription<br>szSystemStatus</p><ul><li>当前库的描述信息，2.0是第二版的意思</li></ul></li></ul></li></ul></li><li><p>当输入的版本不存在</p><ul><li><p>输入1.3， 2.3</p><ul><li><p>有主版本，没有副版本</p><ul><li>得到该主版本的最大副版本 1.1 2.2并使用</li></ul></li></ul></li><li><p>输入3.1  3.3</p><ul><li><p>超过最大版本号</p><ul><li>使用系统能提供的最大的版本 2.2</li></ul></li></ul></li><li><p>输入 0.0 0.1 0.3</p><ul><li><p>主版本是0</p><ul><li>网络库打开失败，不支持请求的套接字版本</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>返回0为执行正确</p></li><li><p>失败</p><ul><li>这些宏的本质</li><li>WSASYSNOTREADY   10091       底层网络子系统尚未准备好进行网络通信。                                                  系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下<br>WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。      要使用的版本不支持<br>WSAEPROCLIM        10067         已达到对Windows套接字实现支持的任务数量的限制。                                 Windows Sockets实现可能限制同时使用它的应用程序的数量<br>WSAEINPROGRESS 10036          正在阻止Windows Sockets 1.1操作。                                                          当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止<br>WSAEFAULT            10014          lpWSAData参数不是有效指针。                                                                 参数写错了</li></ul></li></ul></li></ul></li></ul><h3 id="校验版本"><a class="markdownIt-Anchor" href="#校验版本"></a> 校验版本</h3><ul><li><p>2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion)</p><ul><li><p>HIBYTE是高位 副版本</p></li><li><p>LOBYTE是地位 主版本</p></li><li><p>逻辑</p><ul><li>只要有一个不是2，说明系统不支持我们要的2.2版本</li></ul></li></ul></li><li><p>关闭库<br>并结束函数，可以给出相应提示</p><ul><li>WSACleanup();</li><li>return 0；</li></ul></li></ul><h3 id="创建socket"><a class="markdownIt-Anchor" href="#创建socket"></a> 创建SOCKET</h3><ul><li><p>SOCKET  socket(<br>int af,<br>int type,<br>int protocol<br>);</p><ul><li><p>作用</p><ul><li>创建一个SOCKET</li></ul></li><li><p>SOCKET介绍</p><ul><li><p>什么是socket</p><ul><li>将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了，</li><li>也就是说，SOCKET是我们调用协议进行通信的 操作接口</li></ul></li><li><p>意义</p><ul><li><p>将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。</p><ul><li>网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些</li></ul></li></ul></li><li><p>本质</p><ul><li><p>就是一种数据类型，转定义看下类型</p><ul><li><p>就是一个整数</p><ul><li>uint</li></ul></li><li><p>但是这个数是唯一的</p><ul><li>标识着我当前的应用程序，协议特点等信息</li><li>ID，门牌号</li></ul></li></ul></li></ul></li><li><p>应用</p><ul><li><p>我们网络通信的函数，全部都要使用SOCKET</p><ul><li>演示</li></ul></li><li><p>逻辑</p><ul><li>每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET</li></ul></li></ul></li><li><p>所以</p><ul><li>网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程</li></ul></li></ul></li><li><p>参数1</p><ul><li><p>地址的类型</p><ul><li><p>比如大家联系我</p><ul><li><p>手机</p><ul><li>15512345678</li></ul></li><li><p>固定电话</p><ul><li>7881234</li></ul></li><li><p>ＱＱ</p><ul><li>40916626</li></ul></li><li><p>微信</p><ul><li>c3_xin666</li></ul></li><li><p>找上门</p><ul><li>内蒙古 xxxxxxx</li></ul></li><li><p>…</p></li></ul></li><li><p>AF_INET  2</p><ul><li><p>ipv4</p><ul><li><p>Internet协议版本4（IPv4）地址系列。</p><ul><li><p>192.168.1.103</p><ul><li>0.0.0.0  ~  255.255.255.255</li><li>点分十进制表示法</li></ul></li></ul></li><li><p>4字节 32位的地址</p><ul><li><p>个数快不够</p><ul><li>就是无符号int类型的范围  0 ~ 4294967295</li></ul></li></ul></li></ul></li></ul></li><li><p>AF_INET6  23</p><ul><li><p>ipv6</p><ul><li><p>Internet协议版本6（IPv6）地址系列。</p><ul><li>2001:0:3238:DFE1:63::FEFB</li></ul></li><li><p>16字节  128位的地址</p><ul><li>这个地球每寸一个IP</li></ul></li></ul></li></ul></li><li><p>AF_BTH  32</p><ul><li><p>蓝牙地址系列。<br>如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。</p><ul><li>6B:2D:BC:A9:8C:12</li></ul></li></ul></li><li><p>AF_IRDA  26</p><ul><li>红外数据协会（IrDA）地址系列。<br>仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。</li></ul></li><li><p>通信地址不仅仅只有IP地址</p></li></ul></li></ul></li><li><p>参数2</p><ul><li><p>套接字类型</p><ul><li><p>SOCK_STREAM    1</p><ul><li>一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。</li></ul></li><li><p>SOCK_DGRAM    2</p><ul><li>一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。</li></ul></li><li><p>SOCK_RAW   3</p><ul><li>一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。</li></ul></li><li><p>SOCK_RDM   4</p><ul><li>一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。<br>仅在安装了可靠多播协议时才支持此类型值。</li></ul></li><li><p>SOCK_SEQPACKET   5</p><ul><li>一种套接字类型，提供基于数据报的伪流数据包。</li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>协议的类型</p><ul><li><p>IPPROTO_TCP</p><ul><li>传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_UDP</p><ul><li>用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_ICMP</p><ul><li>Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_IGMP</p><ul><li>Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_RM</p><ul><li>用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。<br>仅在安装了可靠多播协议时才支持此协议值。</li></ul></li><li><p>整理下</p><ul><li>通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。</li><li>想要使用一个协议，咱们设备得支持才行，比如红外</li><li>参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型</li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功返回可用的socket</p><ul><li><p>不用了就一定要销毁套接字</p><ul><li>closesocket(socketListen);</li></ul></li></ul></li><li><p>失败返回INVALID_SOCKET</p><ul><li><p>关闭网络库</p><ul><li>WSACleanup();</li></ul></li><li><p>可用WSAGetLasterror()返回错误码</p></li></ul></li></ul></li></ul></li></ul><h3 id="绑定地址与端口"><a class="markdownIt-Anchor" href="#绑定地址与端口"></a> 绑定地址与端口</h3><ul><li><p>int bind(<br>SOCKET              s,<br>const sockaddr *addr,<br>int                 namelen<br>);</p><ul><li><p>作用</p><ul><li><p>给我们的socket绑定端口号与具体地址</p><ul><li><p>地址</p><ul><li><p>找到咱们的电脑</p><ul><li>只有一个</li></ul></li></ul></li><li><p>端口号</p><ul><li><p>找到我们机器上对应的软件，比如QQ，浏览器等等，都对应着自己的端口号</p><ul><li>多个</li></ul></li><li><p>每一种通信的端口号是唯一的</p></li><li><p>同一个软件可能占用多个端口号</p></li></ul></li></ul></li></ul></li><li><p>参数1</p><ul><li>上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号</li></ul></li><li><p>参数2</p><ul><li><p>结构体</p><ul><li>地址类型</li><li>装IP地址</li><li>端口号</li></ul></li><li><p>结构体类型</p><ul><li><p>sockaddr</p></li><li><p>该参数使用方法</p><ul><li><p>SOCKADDR_IN sockAddress;<br>sockAddress.sin_family = AF_INET;<br>sockAddress.sin_addr.s_addr = inet_addr(“127.0.0.1”);<br>sockAddress.sin_port = 12345;<br>(sockaddr*)&amp;sockAddress强转添加到参数2上</p><ul><li><p>成员1</p><ul><li>跟socket函数参数1是一样的</li></ul></li><li><p>成员2</p><ul><li><p>IP地址</p><ul><li><p><a href="http://192.168.xxx.xxx" target="_blank" rel="noopener">192.168.xxx.xxx</a></p><ul><li>可以在控制台输入指令  ipconfig 就能看到了</li><li>或者在网络设置中，能找到这个地址</li><li>我就不演示了，我不想让你们发现我</li></ul></li><li><p>127.0.0.1</p><ul><li>回送地址  本地回环地址  本地网络测试</li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>端口号</p><ul><li><p>本质</p><ul><li><p>就是一个整数</p><ul><li>0~65535</li></ul></li><li><p>IP是我们机器的地址，端口就是我们具体的软件的通信口，一个软件可能会占用多个接口，比如一个软件可以聊天，可以下载，可以看视频…那么这些不同的通信内容，往往会有各自的协议，各自的端口。</p><ul><li>IP是公司地址，端口就是各个部门的地址了</li></ul></li></ul></li><li><p>填写哪个值呢？</p><ul><li><p>理论上只要这个范围0~65535都可以</p><ul><li><p>实际</p><ul><li><p>介于0～1023，为系统保留占用端口号</p><ul><li>21端口分配给FTP(文件传输协议)服务<br>25端口分配给SMTP（简单邮件传输协议）服务<br>80端口分配给HTTP服务</li></ul></li></ul></li><li><p>所以</p><ul><li><p>我们不能写这个范围的</p><ul><li><p>我们的范围就是1024~65535</p><ul><li>稍微大点儿，1万多</li></ul></li><li><p>但是注意一点，端口号是唯一的，比如1234已经被别的软件占用了，那么你再使用1234这个端口号，那么就会绑定失败，因为已经呗占用了</p><ul><li>给大家演示下</li></ul></li><li><p>那大家如何查看自己要用的端口号有没有被占用呢？</p><ul><li><p>打开运行cmd输入netstat -ano</p><ul><li>查看被使用的所有端口</li></ul></li><li><p>netstat -aon|findstr “12345”</p><ul><li>检查我们要使用的端口号是否被使用了</li><li>使用了就会显示使用的程序，未被使用就啥都不显示</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>参数2的类型大小</p><ul><li>sizeof(参数2)</li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功返回0</p></li><li><p>失败返回SOCKET_ERROR</p><ul><li>具体错误码通过int WSAGetLastError(void);获得</li><li>closesocket(socketListen);<br>WSACleanup();</li></ul></li></ul></li></ul></li></ul><h3 id="开始监听"><a class="markdownIt-Anchor" href="#开始监听"></a> 开始监听</h3><ul><li><p>int WSAAPI listen(<br>SOCKET s,<br>int    backlog<br>);</p><ul><li><p>作用</p><ul><li>将套接字置于正在侦听传入连接的状态。</li></ul></li><li><p>参数1</p><ul><li>服务器端的socket，也就是socket函数创建的</li></ul></li><li><p>参数2</p><ul><li><p>挂起连接队列的最大长度。</p><ul><li><p>就是说，比如有100个用户链接请求，但是系统一次只能处理20个，那么剩下的80个不能不理人家，所以系统就创建个队列记录这些暂时不能处理，一会儿处理的链接请求，依先后顺序处理，那这个队列到底多大？就是这个参数设置，比如2，那么就允许两个新链接排队的。这个肯定不能无限大，那内存不够了。</p></li><li><p>我们可以手动设置这个参数，但是别大了。可能2<sub>10多，</sub>20多。</p></li><li><p>我们一般填写这个参数</p><ul><li><p>SOMAXCONN</p><ul><li>作用是让系统自动选择最合适的个数</li><li>不同的系统环境不一样，所以这个合适的数也都不一样</li></ul></li></ul></li></ul></li></ul></li><li><p>WSAAPI</p><ul><li><p>调用约定</p><ul><li><p>这个我们可以忽略，这是给系统看的，跟咱们没关</p></li><li><p>决定三</p><ul><li>函数名字的编译方式</li><li>参数的入栈顺序</li><li>函数的调用时间</li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功</p><ul><li>返回0</li></ul></li><li><p>失败</p><ul><li><p>SOCKET_ERROR</p></li><li><p>具体错误码</p><ul><li><p>WSAGetLastError()</p></li><li><p>释放</p><ul><li>closesocket(socketListen);</li><li>WSACleanup();</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="事件选择"><a class="markdownIt-Anchor" href="#事件选择"></a> 事件选择</h3><ul><li><p>创建一个事件对象</p><ul><li><p>WSAEVENT WSAAPI WSACreateEvent();</p><ul><li><p>成功</p><ul><li>返回一个事件</li></ul></li><li><p>失败</p><ul><li><p>返回WSA_INVALID_EVENT</p></li><li><p>WSAGetLastError获取错误码</p></li><li><p>关闭</p><ul><li>::closesocket(socketServer);<br>::WSACleanup();</li></ul></li></ul></li><li><p>转定义</p><ul><li><p>HANDLE</p><ul><li><p>句柄</p><ul><li><p>ID</p></li><li><p>内核对象</p><ul><li><p>由系统在内核申请</p></li><li><p>由操作系统访问</p></li><li><p>我们不能定位其内容，也不能修改</p><ul><li><p>void*</p><ul><li>通用类型指针</li></ul></li><li><p>对内核的保护，对规则的保护，从而使操作系统有序的平稳的，有效的运行，而不会随便出问题</p></li></ul></li><li><p>调用函数创建，调用函数释放</p><ul><li>如果我们没有调用释放，那么他可能就一直存在于内核，造成内核内存泄漏， 这种只能重启电脑</li></ul></li><li><p>内核对象有哪些</p><ul><li>socket</li><li>Kernel Objects</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>几个函数</p><ul><li><p>BOOL WSAAPI WSACloseEvent<br>(<br>WSAEVENT hEvent<br>);</p><ul><li><p>关闭/释放事件句柄</p><ul><li>不用就要释放</li></ul></li></ul></li><li><p>BOOL WSAAPI WSAResetEvent<br>(<br>WSAEVENT hEvent<br>);</p><ul><li>重置WSAEventSelect函数使用的事件对象状态的正确方法是将事件对象的句柄传递给hEventObject参数中的WSAEnumNetworkEvents函数。 这将重置事件对象并以原子方式调整套接字上活动FD事件的状态。</li></ul></li><li><p>BOOL WSAAPI WSASetEvent<br>(<br>WSAEVENT hEvent<br>);</p><ul><li>将指定事件主动置成有信号</li></ul></li></ul></li></ul></li><li><p>绑定并投递</p><ul><li><p>int WSAAPI WSAEventSelect<br>(<br>SOCKET   s,<br>WSAEVENT hEventObject,<br>long     lNetworkEvents<br>);</p><ul><li><p>功能</p><ul><li>给事件绑上socket与操作码，并投递给操作系统</li></ul></li><li><p>参数1</p><ul><li><p>被绑定的socket</p><ul><li>最终，每个socket都会被绑定一个事件</li></ul></li></ul></li><li><p>参数2</p><ul><li><p>事件对象</p><ul><li>逻辑，就是讲参数1与参数2绑定在一起</li></ul></li></ul></li><li><p>参数3</p><ul><li><p>具体事件</p><ul><li><p>FD_ACCEPT</p><ul><li><p>有客户端链接</p><ul><li>与服务器socket绑定</li></ul></li></ul></li><li><p>FD_READ</p><ul><li><p>有客户端发来消息</p><ul><li>与客户端socket绑定</li><li>可多个属性并列 用 |</li></ul></li></ul></li><li><p>FD_CLOSE</p><ul><li><p>客户端下线了</p><ul><li>与客户端socket绑定</li><li>包含强制下线，正常下线</li></ul></li></ul></li><li><p>FD_WRITE</p><ul><li><p>可以给客户端发信</p><ul><li>与客户端socket绑定</li><li>会在accept后立即主动产生该信号</li><li>可以说明，客户端连接成功，即可随时send</li></ul></li><li><p>有特点</p><ul><li>代码写完给大家测试</li></ul></li></ul></li><li><p>FD_CONNECT</p><ul><li>客户端一方，给服务器绑定这个</li></ul></li><li><p>0</p><ul><li><p>取消事件监视</p><ul><li>WSAEventSelect（FD_ACCEPT | FD_READ）；</li><li>WSAEventSelect（0）；</li></ul></li></ul></li><li><p>FD_OOB</p><ul><li><p>带外数据</p><ul><li>不多说了，一般不使用</li></ul></li></ul></li><li><p>FD_QOS</p><ul><li><p>套接字服务质量状态发生变化消息通知</p><ul><li>比如：当网络发生拥堵时：用户下载，看电影，聊天，听歌…好多用网事件一起在做，那么计算机网速是有限的，每秒可以处理多少数据，这时候，计算机就会把要紧事优先，比如可以降低下载的速度，以保证看电影流畅，这时候，下载的服务质量就发生了变化。如果投放了这个事件，就会接收到信号了</li><li>通过这些小问题的介绍，大家就要注意到实际应用中的问题了，稍微记一下</li></ul></li><li><p>WSAIoctl</p><ul><li>得到服务质量信息</li><li>char strOut[2048] = { 0 };<br>DWORD nLen = 2048;<br>WSAIoctl(socketServer, SIO_QOS, 0, 0, strOut, nLen, &amp;nLen, NULL, NULL);</li></ul></li></ul></li><li><p>FD_GROUP_QOS</p><ul><li><p>保留</p><ul><li>还没有对其赋值具体意义，还没用呢</li></ul></li><li><p>想要接收套接字组QoS更改的通知。</p></li></ul></li><li><p>重叠I/O模型中</p><ul><li><p>FD_ROUTING_ INTERFACE_CHANGE</p><ul><li><p>想要接收指定目标的路由接口更改通知。</p></li><li><p>数据到达对方的所经过的线路改变了，由于是动态优化选择</p></li><li><p>要通过此函数WSAIoctl注册之后，才可以</p><ul><li>SIO_ROUTING_ INTERFACE_CHANGE</li></ul></li></ul></li><li><p>FD_ADDRESS_ LIST_CHANGE</p><ul><li><p>想要接收套接字地址族的本地地址列表更改通知。</p><ul><li>咱们服务器，链接了很多客户端，那服务器就记录着所有的客户端的地址信息，也就是相当于一个列表，当多一个或者少一个，就是变化了， 咱们就能得到相关的信号了</li></ul></li><li><p>要通过此函数WSAIoctl注册之后，才可以有效</p><ul><li>SIO_ADDRESS_ LIST_CHANGE</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功</p><ul><li>返回0</li></ul></li><li><p>失败</p><ul><li><p>失败SOCKET_ERROR</p><ul><li>WSACloseEvent(wsaEvent);<br>closesocket(socketServer);<br>WSACleanup();</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>询问事件</p><ul><li><p>DWORD WSAAPI WSAWaitForMultipleEvents(<br>DWORD          cEvents,<br>const WSAEVENT *lphEvents,<br>BOOL           fWaitAll,<br>DWORD          dwTimeout,<br>BOOL           fAlertable<br>);</p><ul><li><p>作用</p><ul><li>获取发生信号的事件</li></ul></li><li><p>参数1</p><ul><li><p>事件个数</p><ul><li><p>定义事件列表（数组）个数是</p><ul><li><p>WSA_MAXIMUM_WAIT_EVENTS</p><ul><li>64个</li><li>该函数参数1最大64</li></ul></li><li><p>可以变大</p><ul><li>方法我们在逻辑讲完了再讲，有一点儿复杂</li><li>不像select模型，直接就能变大，因为select本身就是个数组，然后遍历就行了，比较直接，事件选择是异步投放，由系统管理，咱们就不能随便修改了，要按照规则来</li></ul></li></ul></li></ul></li></ul></li><li><p>参数2</p><ul><li>事件列表</li></ul></li><li><p>参数3</p><ul><li><p>事件等待方式</p><ul><li><p>TRUE</p><ul><li>所有的事件都产生信号，才返回</li></ul></li><li><p>FALSE</p><ul><li>任何一个事件产生信号，立即返回</li><li>返回值减去WSA_WAIT_EVENT_0表示事件对象的索引，其状态导致函数返回。</li><li>如果在调用期间发出多个事件对象的信号，则这是信号事件对象的数组索引，其中所有信号事件对象的索引值最小。</li></ul></li></ul></li></ul></li><li><p>参数4</p><ul><li><p>超时间隔，以毫秒为单位。 跟select参数5一样的意义</p></li><li><p>123</p><ul><li><p>等待123毫秒</p><ul><li>超时返回WSA_WAIT_TIMEOUT</li></ul></li></ul></li><li><p>0</p><ul><li>检查事件对象的状态并立即返回。不管有没有信号</li></ul></li><li><p>WSA_INFINITE</p><ul><li>等待直到事件发生</li></ul></li></ul></li><li><p>参数5</p><ul><li><p>TRUE</p><ul><li>重叠IO模型使用</li></ul></li><li><p>FALSE</p><ul><li>咱们这个事件选择模型填写FALSE</li></ul></li></ul></li><li><p>返回值</p><ul><li><p>数组下标的运算值</p><ul><li><p>参数3为true</p><ul><li>所有的事件均有信号</li></ul></li><li><p>参数3为false</p><ul><li>返回值减去WSA_WAIT_EVENT_0==数组中事件的下标</li></ul></li></ul></li><li><p>WSA_WAIT_IO_COMPLETION</p><ul><li>参数5为TRUE，才会返回这个值</li></ul></li><li><p>WSA_WAIT_TIMEOUT</p><ul><li>超时了，continue即可</li></ul></li><li><p>WSA_WAIT_FAILED</p><ul><li>出错了</li></ul></li></ul></li></ul></li></ul></li><li><p>列举事件</p><ul><li><p>int WSAAPI WSAEnumNetworkEvents(<br>SOCKET             s,<br>WSAEVENT           hEventObject,<br>LPWSANETWORKEVENTS lpNetworkEvents<br>);</p><ul><li><p>获取事件类型，并将事件上的信号重置</p><ul><li>accept recv close等等</li></ul></li><li><p>参数1</p><ul><li>对应的socket</li></ul></li><li><p>参数2</p><ul><li>对应的事件</li></ul></li><li><p>参数3</p><ul><li><p>触发的事件类型在这里装着</p></li><li><p>是一个结构体指针</p><ul><li><p>struct _WSANETWORKEVENTS<br>{<br>long lNetworkEvents;<br>int  iErrorCode[FD_MAX_EVENTS];<br>}</p><ul><li><p>成员1：具体操作</p><ul><li>一个信号可能包含两个消息，以按位或的形式存在</li></ul></li><li><p>参数2：错误码数组</p><ul><li>FD_ACCEPT事件错误码在FD_ACCEPT_BIT下标里</li><li>没有错误，对应的就是0</li></ul></li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功</p><ul><li>0</li></ul></li><li><p>失败</p><ul><li>SOCKET_ERROR</li><li>WSAGetLastError()得到错误码</li></ul></li></ul></li></ul></li></ul></li><li><p>事件分类处理逻辑</p><ul><li><p>if (lpNetworkEvents-&gt;lNetworkEvents &amp; FD_ACCEPT)<br>{<br>if (lpNetworkEvents-&gt;iErrorCode[FD_ACCEPT_BIT] == 0)<br>{<br>//接受链接<br>//创建事件<br>//投放事件<br>//元素增加<br>}<br>}</p></li><li><p>用switch可以嘛？</p><ul><li>不行，有大bug</li></ul></li><li><p>else if可以嘛？</p><ul><li>不太行，有小bug</li></ul></li></ul></li></ul><h3 id="有序处理"><a class="markdownIt-Anchor" href="#有序处理"></a> 有序处理</h3><ul><li><p>for (i = Index; i &lt; EventTotal; i++)<br>{<br>Index = WSAWaitForMultipleEvents(1, &amp;EventArray[i], TRUE, 1000, FALSE);<br>if ((Index != WSA_WAIT_FAILED) &amp;&amp; (Index != WSA_WAIT_TIMEOUT))<br>{<br>WSAEnumNetworkEvents(SocketArray[i], EventArray[i], &amp;NetworkEvents);<br>//分类处理<br>}<br>}</p></li><li><p>最开始就一个一个检测</p><ul><li><p>不绝对的公平，只是相对公平，相对有序</p><ul><li>让大家在一轮循环下都能得到处理</li><li>但是并不能完全解决顺序问题，只是达到相对公平</li><li>所以，事件选择模型不能用于大用户，多访问</li></ul></li></ul></li></ul><h3 id="增加事件数量"><a class="markdownIt-Anchor" href="#增加事件数量"></a> 增加事件数量</h3><ul><li><p>一个一个来，一个大数组就行了啊</p><ul><li>结合线程池</li></ul></li><li><p>一组一组来</p><ul><li><p>单线程，一组一组顺序处理就好了</p></li><li><p>创建多个线程，每个线程处理一个事件表，最大64</p><ul><li>提醒</li></ul></li></ul></li></ul><h3 id="释放"><a class="markdownIt-Anchor" href="#释放"></a> 释放</h3><h3 id="对比select的结构吐"><a class="markdownIt-Anchor" href="#对比select的结构吐"></a> 对比select的结构吐</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/javawz/事件选择模型.png&quot; height=&quot;100%&quot; width=&quot;200%&quot;&gt;
&lt;hr&gt;
&lt;img src=&quot;/images/javawz/事件模型对比select模型流程图1.png&quot; height=&quot;100%&quot; width=&quot;
      
    
    </summary>
    
      <category term="Windows网络编程" scheme="https://xiaowuyoucy.github.io/categories/Windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>IP地址的划分和子网掩码计算方法</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/23/jiw005-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%92%E5%88%86%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/23/jiw005-IP地址的划分和子网掩码计算方法/</id>
    <published>2021-06-22T21:50:56.000Z</published>
    <updated>2021-06-22T22:45:38.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ip地址的划分"><a class="markdownIt-Anchor" href="#ip地址的划分"></a> IP地址的划分</h1><p>ip地址转二进制</p><p>192.168.1.110</p><p>11000000  10101000  00000001  01101110</p><h3 id="地址分类"><a class="markdownIt-Anchor" href="#地址分类"></a> 地址分类</h3><p>A类:</p><p>1.0.0.1~126.255.255.254</p><p>0 &lt; A类 &lt; 127</p><p>本地回环地址:</p><p>127.0.0.1~127.255.255.255</p><p>B类:</p><p>128.0.0.1~191.255.255.254</p><p>128 &lt;= B类 &lt; 192</p><p>C类:</p><p>192.0.0.1~223.255.255.254</p><p>D类:</p><p>组播用的</p><p>E类:</p><p>科研用的</p><hr><p>私有ip地址范围:</p><p>局域网地址:</p><p>A类:</p><p>10.0.0.0 ~ 10.255.255.255</p><p>ip个数 = 65536 *255</p><p>B类:</p><p>172.16.0.0 ~ 172.31.255.255</p><p>ip个数 = 16 * 65536</p><p>C类:</p><p>192.168.0.0 ~ 192.168.255.255</p><p>ip个数 =  65536</p><h1 id="子网掩码计算方法"><a class="markdownIt-Anchor" href="#子网掩码计算方法"></a> 子网掩码计算方法</h1><p>子网掩码的作用规定了一个子网的ip地址范围大小：</p><p>不同网段访问要通过路由器或三层交换机</p><p>192.168.11.0/24 === 192.168.11.0 netmask 255.255.255.0</p><p>24 代表子网掩码是24个1</p><p>192.168.11.0    网络号</p><p>192.168.11.1   起始地址</p><p>192.168.11.254   结束地址</p><p>192.168.11.255   广播地址</p><p>例如有一个ip是192.168.1.110</p><p>子网掩码是255.255.255.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">11000000101010000000000101101110</span><br><span class="line"></span><br><span class="line">11111111111111111111111100000000</span><br><span class="line"></span><br><span class="line">11111111对应的部分是不能修改的</span><br><span class="line">也就是</span><br><span class="line">110000001010100000000001   这部分是不能修改的</span><br><span class="line">能修改的是01101110这部分</span><br></pre></td></tr></table></figure><p>一般的可以修改部分全是0是网络号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.0</span><br><span class="line"></span><br><span class="line">子网掩码  </span><br><span class="line">11111111        11111111        11111111        00000000</span><br><span class="line">IP地址</span><br><span class="line">11000000        10101000        00000001        01101110</span><br><span class="line">网络号    </span><br><span class="line">11000000        10101000        00000001        00000000</span><br></pre></td></tr></table></figure><p>起始ip:是网络号+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">子网掩码  </span><br><span class="line">11111111        11111111        11111111        00000000</span><br><span class="line">网络号    </span><br><span class="line">11000000        10101000        00000001        00000000</span><br><span class="line">起始ip</span><br><span class="line">11000000        10101000        00000001        00000001</span><br><span class="line">192.168.1.1</span><br></pre></td></tr></table></figure><p>结束ip:是广播ip-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">子网掩码  </span><br><span class="line">11111111        11111111        11111111        00000000</span><br><span class="line">255.255.255.0</span><br><span class="line">网络号    </span><br><span class="line">11000000        10101000        00000001        00000000</span><br><span class="line">192.168.1.0</span><br><span class="line">起始ip</span><br><span class="line">11000000        10101000        00000001        00000001</span><br><span class="line">192.168.1.1</span><br><span class="line">结束ip</span><br><span class="line">11000000        10101000        00000001        11111110</span><br><span class="line">192.168.1.254</span><br><span class="line">广播ip</span><br><span class="line">11000000        10101000        00000001        11111111</span><br></pre></td></tr></table></figure><p>广播ip:是可修改部分全是1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">子网掩码  </span><br><span class="line">11111111        11111111        11111111        00000000</span><br><span class="line">网络号    </span><br><span class="line">11000000        10101000        00000001        00000000</span><br><span class="line">广播ip</span><br><span class="line">11000000        10101000        00000001        11111111</span><br><span class="line">192.168.1.255</span><br></pre></td></tr></table></figure><h3 id="子网掩码只能用以下的数字"><a class="markdownIt-Anchor" href="#子网掩码只能用以下的数字"></a> 子网掩码只能用以下的数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">000000000</span><br><span class="line">12810000000</span><br><span class="line">19211000000</span><br><span class="line">22411100000</span><br><span class="line">24011110000</span><br><span class="line">24811111000</span><br><span class="line">25211111100</span><br><span class="line">25411111110</span><br><span class="line">25511111111</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ip地址的划分&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ip地址的划分&quot;&gt;&lt;/a&gt; IP地址的划分&lt;/h1&gt;
&lt;p&gt;ip地址转二进制&lt;/p&gt;
&lt;p&gt;192.168.1.110&lt;/p&gt;
&lt;p&gt;11000000  10101000	 
      
    
    </summary>
    
      <category term="计算机网络TCP/IP传输协议/网络抓包" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CTCP-IP%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP的三次握手和四次挥手</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/23/jiw004-TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/23/jiw004-TCP的三次握手和四次挥手/</id>
    <published>2021-06-22T21:03:51.000Z</published>
    <updated>2021-06-22T21:52:10.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp三次握手"><a class="markdownIt-Anchor" href="#tcp三次握手"></a> TCP三次握手</h1><p><img src="/images/javawz/1624396879962.png" alt="1624396879962"></p><p>ack的值永远等于上一个数据包seq的值加1</p><p>ack也叫期望值</p><p><img src="/images/javawz/1624397329411.png" alt="1624397329411"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三次握手：</span><br><span class="line">“喂，你听得到吗？”</span><br><span class="line">“我听得到呀，你听得到我吗？”</span><br><span class="line">“我能听到你，今天 balabala……”</span><br></pre></td></tr></table></figure><h1 id="tcp的四次挥手"><a class="markdownIt-Anchor" href="#tcp的四次挥手"></a> TCP的四次挥手</h1><p><img src="/images/javawz/1624398035519.png" alt="1624398035519"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端:我们分手吧</span><br><span class="line">服务端:好的,我知道了</span><br><span class="line">服务端:我们分手吧</span><br><span class="line">客户端:好的再见</span><br></pre></td></tr></table></figure><h3 id="tcp的数据传输过程"><a class="markdownIt-Anchor" href="#tcp的数据传输过程"></a> tcp的数据传输过程：</h3><h5 id="syn表示建立连接"><a class="markdownIt-Anchor" href="#syn表示建立连接"></a> SYN表示建立连接，</h5><h5 id="fin表示关闭连接"><a class="markdownIt-Anchor" href="#fin表示关闭连接"></a> FIN表示关闭连接，</h5><h5 id="ack表示响应"><a class="markdownIt-Anchor" href="#ack表示响应"></a> ACK表示响应，</h5><h5 id="psh表示有data数据传输"><a class="markdownIt-Anchor" href="#psh表示有data数据传输"></a> PSH表示有DATA数据传输，</h5><h5 id="urg表示紧急指针"><a class="markdownIt-Anchor" href="#urg表示紧急指针"></a> URG表示紧急指针</h5><h5 id="rst表示连接重置"><a class="markdownIt-Anchor" href="#rst表示连接重置"></a> RST表示连接重置。</h5><h1 id="tcp的11种状态"><a class="markdownIt-Anchor" href="#tcp的11种状态"></a> TCP的11种状态</h1><h2 id="tcp三次握手建立连接"><a class="markdownIt-Anchor" href="#tcp三次握手建立连接"></a> TCP三次握手建立连接</h2><p><strong>Tcp头部</strong></p><p><img src="/images/javawz/823435-20170323092941611-1541980584.png" alt="img"></p><p>六个标志位中，我们要用到三个：</p><p><strong>SYN</strong>：SYN=  1 表示这是一个连接请求或连接接受报文。在建立连接时用来进行同步序号（个人理解是，在建立连接的时候，提醒对方记录本方的起始序号）。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若是同意建立连接，则应响应的报文段中使SYN=1、ACK=1。因此SYN=1表示该报文是一个连接请求报文或者是一个连接请求接收报文。</p><p><strong>ACK</strong>：确认号只有在该位设置为1的时候才生效，当该位为0是表示确认号无效。TCP规定，在TCP连接建立后所有传送的数据报文段ACK都必须设置为1。</p><p><strong>FIN</strong>：当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</p><p>此外我们还需要用到序号和确认号：</p><p><strong>序号</strong>：占4个字节，它的范围在0-2^32-1，序号随着通信的进行不断的递增，当达到最大值的时候重新回到0在开始递增。TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按照顺序编号。整个要传送的字节流的起始号必须在连接建立时设置。首部中的序列号字段指的是本报文段所发送的数据的第一个字节的序号。例如，一个报文序号是301，而携带的数据共有100字节。则表示本次报文中的序号是301，下一个报文的序号是401.重复一下，每一个报文的序号是该报文包含的字节中第一个字节的编号。</p><p><strong>确认号</strong>：占4个字节，确认号，是对下一个想要接受的字节的期望，这里隐式确认了对上一个数据包的成功接收。如上例，在成功接收了序号为301的数据包，想要接收下一个数据包因为上个数据包包含100字节，所以此时的确认号应该是401，表示希望接收下一个序号是401的数据包。</p><p>三次握手过程：</p><p><img src="/images/javawz/823435-20170323092953893-1865298744.png" alt="img"></p><p><strong>过程描述：</strong></p><p>首先由Client发出请求连接即 SYN=1 ACK=0 (请看头字段的介绍)，TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x。</p><p>然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y，ack=x+1。</p><p>再然后 Client 再进行一次确认，但不用SYN 了，这时即为 ACK=1, seq=x+1，ack=y+1。</p><p><strong>为什么要进行三次握手（两次确认）：</strong></p><p>为什么A还要发送一侧确认呢？这主要是为了防止已失效的连接请求报文突然又传送到了B，因而产生错误。</p><p>所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况。A发出连接请求，但因连接请求丢失而未收到确认。于是A再次重传一次连接请求。后来收到了确认建立了连接。数据传输完毕后，就释放了连接。A供发送了两个连接请求的报文段，其中第一个丢失，第二个到达了B。没有“已失效的连接请求报文段”。</p><p>现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段。但是B收到此失效的连接请求报文段后，就误认为是A有发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。</p><p>由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样拜拜浪费了。</p><p>采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。</p><p><strong>另一种解释：</strong></p><p>这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题,  无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求,  而是为了满足&quot;在不可靠信道上可靠地传输信息&quot;这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了,  那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息,  对方一定能收到, 或者你不关心是否要保证对方收到你的消息,  那就能像UDP那样直接发送消息就可以了”。这可视为对“三次握手”目的的另一种解答思路。</p><h2 id="四次挥手关闭连接"><a class="markdownIt-Anchor" href="#四次挥手关闭连接"></a> 四次挥手关闭连接</h2><p><img src="/images/javawz/823435-20170323093037486-665986934.png" alt="img"></p><p>当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1,  服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。  A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack =  u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。</p><p><strong>l 为什么要等待呢？</strong></p><p>l 为了防止这种情况：A接到B的释放连接请求后会发送一个确认信息，但是如果这个确认信息丢了，也就是B没有收到确认释放连接，那么B就会重发一个释放连接请求，这时候A还处于TIME_WAIT状态，所以会再次发送一个确认信息。</p><p><strong>l Q2为什么TIME_WAIT 状态还需要等2*MSL秒之后才能返回到CLOSED 状态呢？</strong></p><p>l A2因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED 状态（就好比从SYN_SENT  状态到ESTABLISH  状态那样），但是我们必须假想网络是不可靠的，你无法保证你最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK  状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT 状态的作用就是用来重发可能丢失的ACK报文。</p><h2 id="11种状态"><a class="markdownIt-Anchor" href="#11种状态"></a> 11种状态</h2><p><img src="/images/javawz/823435-20170323093050424-1255848578.png" alt="img"></p><p>简单解释：</p><p><strong>l CLOSED</strong>：初始状态，表示TCP连接是“关闭着的”或“未打开的”。</p><p><strong>l LISTEN</strong> ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。</p><p><strong>l SYN_RCVD</strong> ：表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。</p><p><strong>l SYN_SENT</strong> ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。</p><p><strong>l ESTABLISHED</strong> ：表示TCP连接已经成功建立。</p><p><strong>l FIN_WAIT_1</strong> ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2  两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2  状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1  状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。</p><p><strong>l FIN_WAIT_2</strong> ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2  状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。</p><p><strong>l TIME_WAIT</strong> ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment  Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC  1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED  可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况）</p><p>l <strong>CLOSING</strong> ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING  状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。</p><p><strong>l CLOSE_WAIT</strong> ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。</p><p><strong>l LAST_ACK</strong> ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。</p><p><strong>CLOSING状态：</strong></p><p><img src="/images/javawz/823435-20170323093109565-59098561.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcp三次握手&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tcp三次握手&quot;&gt;&lt;/a&gt; TCP三次握手&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1624396879962.png&quot; alt=&quot;16243968
      
    
    </summary>
    
      <category term="计算机网络TCP/IP传输协议/网络抓包" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CTCP-IP%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP/IP协议模型</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/23/jiw003-TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/23/jiw003-TCP-IP协议/</id>
    <published>2021-06-22T20:51:49.000Z</published>
    <updated>2021-06-22T21:52:06.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcpip协议模型"><a class="markdownIt-Anchor" href="#tcpip协议模型"></a> TCP/IP协议模型</h1><p>tcp/ip协议5层</p><p>物理层</p><p>数据链接层</p><p>网络层</p><p>传输层</p><p>应用层</p><p><img src="/images/javawz/1624395408699.png" alt="1624395408699"></p><h3 id="数据封装和解封装过程"><a class="markdownIt-Anchor" href="#数据封装和解封装过程"></a> 数据封装和解封装过程</h3><p><img src="/images/javawz/20210303141707592.png" alt="数据封装过程"></p><p><img src="/images/javawz/20210303142309447.png" alt="数据解封装过程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcpip协议模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tcpip协议模型&quot;&gt;&lt;/a&gt; TCP/IP协议模型&lt;/h1&gt;
&lt;p&gt;tcp/ip协议5层&lt;/p&gt;
&lt;p&gt;物理层&lt;/p&gt;
&lt;p&gt;数据链接层&lt;/p&gt;
&lt;p&gt;网络层&lt;/p&gt;

      
    
    </summary>
    
      <category term="计算机网络TCP/IP传输协议/网络抓包" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CTCP-IP%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>jiw002-OSI的七层模型</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/23/jiw002-OSI%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/23/jiw002-OSI的七层模型/</id>
    <published>2021-06-22T20:41:52.000Z</published>
    <updated>2021-06-22T20:50:39.089Z</updated>
    
    <content type="html"><![CDATA[<p>网络工程师：</p><h3 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h3><p>1层，通信介质的信号到数字信号（二进制0101）</p><p>负责从电信号/光信号/电磁波信号转换到数字信号</p><p>或</p><p>从数字信号转换到电信号/光信号/电磁波信号</p><h3 id="数据链接层"><a class="markdownIt-Anchor" href="#数据链接层"></a> 数据链接层</h3><p>2层 局域网之间计算机通信  通过mac地址通信   arp协议</p><h3 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h3><p>3层 IP地址，路由（通过网络访问全世界）<br>公网的ip地址相当于门牌号（全世界网络互连） ：<br>私网的ip地址相当于房间号（局域网内部网络互连）</p><h3 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h3><p>4层 tcp/udp</p><p>tcp（可靠，速度慢）</p><p>udp （不可靠，速度快）</p><p>端口（让不同的应用程序，同时使用网络）</p><p>开发：</p><h3 id="会话层"><a class="markdownIt-Anchor" href="#会话层"></a> 会话层</h3><p>5层 控制发包的数据  会话层控制传输层，建立三次握手</p><h3 id="表示层"><a class="markdownIt-Anchor" href="#表示层"></a> 表示层</h3><p>6层 文件格式</p><h3 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h3><p>7层应用程序使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络工程师：&lt;/p&gt;
&lt;h3 id=&quot;物理层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#物理层&quot;&gt;&lt;/a&gt; 物理层&lt;/h3&gt;
&lt;p&gt;1层，通信介质的信号到数字信号（二进制0101）&lt;/p&gt;
&lt;p&gt;负责从电信号/光信号/电磁波信号转换到数字信号
      
    
    </summary>
    
      <category term="计算机网络TCP/IP传输协议/网络抓包" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CTCP-IP%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>网络的重要性和局域网简介</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/23/jiw001-%E7%BD%91%E7%BB%9C%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91%E7%AE%80%E4%BB%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/23/jiw001-网络的重要性和局域网简介/</id>
    <published>2021-06-22T20:34:11.000Z</published>
    <updated>2021-06-22T20:41:07.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络的重要性和局域网简介"><a class="markdownIt-Anchor" href="#网络的重要性和局域网简介"></a> 网络的重要性和局域网简介</h1><p>网络的重要性：所有的操作系统都有网络！</p><p>教室这么多的电脑如何上网的？</p><p>网卡（mac地址）可以通过MAX地址查询网卡生产厂商</p><p>有线（双绞线传播电信号）双向，同时收发</p><p>无线（无线电波）发的时候，不能收</p><h3 id="交换扩充网线插槽让更多的人在同一个局域网共享上网"><a class="markdownIt-Anchor" href="#交换扩充网线插槽让更多的人在同一个局域网共享上网"></a> 交换（扩充网线插槽，让更多的人，在同一个局域网共享上网）</h3><p>傻瓜交换机（tplink/dlink/水星…）</p><p>程控交换机（配置管理，可控思科、华为、华三）</p><h3 id="路由双网卡"><a class="markdownIt-Anchor" href="#路由双网卡"></a> 路由（双网卡）</h3><p>内网卡…-交换机 192.168.16.0/24（192.168.16.1-192.168.16.254）</p><p>外网卡 运营商 122.71.64.2（铁通）</p><h3 id="查公网ip的方法"><a class="markdownIt-Anchor" href="#查公网ip的方法"></a> 查公网ip的方法：</h3><p>windows，打开浏览器，访问百度，搜IP即可</p><p>Linux：curl <a href="http://ifconfig.me" target="_blank" rel="noopener">ifconfig.me</a></p><p>扩展：高级路由器还有上网行为管理器和防火墙功能哦</p><p>10Mbps==1.25MB 1.1M</p><p>100Mbps == 12MR 300KB/s 500KB/s</p><h3 id="论坛鸿鹄论坛网络工程师"><a class="markdownIt-Anchor" href="#论坛鸿鹄论坛网络工程师"></a> 论坛：鸿鹄论坛（网络工程师）</h3><p>CCNA入门<br>CCNP广度<br>CCIE深度<br>HCIA<br>HCIP<br>HCIE</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络的重要性和局域网简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#网络的重要性和局域网简介&quot;&gt;&lt;/a&gt; 网络的重要性和局域网简介&lt;/h1&gt;
&lt;p&gt;网络的重要性：所有的操作系统都有网络！&lt;/p&gt;
&lt;p&gt;教室这么多的电脑如何上网的？&lt;
      
    
    </summary>
    
      <category term="计算机网络TCP/IP传输协议/网络抓包" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CTCP-IP%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>标准程序库异常和继承标准程序异常库</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/23/cpp0074-%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93%E5%BC%82%E5%B8%B8/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/23/cpp0074-标准程序库异常/</id>
    <published>2021-06-22T19:38:36.000Z</published>
    <updated>2021-06-22T20:18:05.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准程序库异常"><a class="markdownIt-Anchor" href="#标准程序库异常"></a> 标准程序库异常</h1><p><img src="/images/javawz/1624390861118.png" alt="1624390861118"></p><p>标准异常类的成员：</p><p>在上述继承体系中，每个类都有提供了构造函数、复制构造函数、和赋值操作符重载。</p><p>logic_error类及其子类、runtime_error类及其子类，它们的构造函数是接受一个string类型的形式参数，用于异常信息的描述；</p><p>所有的异常类都有一个what()方法，返回const char* 类型（C风格字<br>符串）的值，描述异常信息。</p><p><img src="/images/javawz/1624390983938.png" alt="1624390983938"></p><p><img src="/images/javawz/1624390999226.png" alt="1624390999226"></p><p><img src="/images/javawz/1624391003325.png" alt="1624391003325"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mydiv</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> out_of_range(<span class="string">"除数不能为0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mydiv(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (out_of_range&amp; oor) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; oor.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承标准程序异常基类"><a class="markdownIt-Anchor" href="#继承标准程序异常基类"></a> 继承标准程序异常基类</h1><h5 id="继承异常基类需要重写virtual-char-const-what-const成员函数"><a class="markdownIt-Anchor" href="#继承异常基类需要重写virtual-char-const-what-const成员函数"></a> 继承异常基类需要重写<code>virtual char const* what() const</code>成员函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> :</span><span class="keyword">public</span> exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyException(<span class="keyword">const</span> <span class="keyword">char</span> * error)</span><br><span class="line">&#123;</span><br><span class="line">pError = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(error) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(pError,error);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="keyword">const</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pError;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~MyException() &#123;</span><br><span class="line"><span class="keyword">if</span> (pError != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] pError;</span><br><span class="line">pError = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *pError;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">div</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">0.0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> MyException(<span class="string">"除数不能为0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">div(<span class="number">100.0</span>,<span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (exception&amp; oor) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; oor.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标准程序库异常&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#标准程序库异常&quot;&gt;&lt;/a&gt; 标准程序库异常&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1624390861118.png&quot; alt=&quot;16243908
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>select模型</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/21/WS003select%E6%A8%A1%E5%9E%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/21/WS003select模型/</id>
    <published>2021-06-21T14:48:18.000Z</published>
    <updated>2021-06-21T01:36:04.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="select模型"><a class="markdownIt-Anchor" href="#select模型"></a> select模型</h1><h2 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h2><h3 id="1-解决基本cs模型中accept-rcev-傻等的问题"><a class="markdownIt-Anchor" href="#1-解决基本cs模型中accept-rcev-傻等的问题"></a> 1、解决基本c/s模型中，accept rcev 傻等的问题</h3><ul><li><p>傻等阻塞</p></li><li><p>执行阻塞</p><ul><li>send recv accept</li><li>在执行的复制黏贴的过程中都是阻塞的</li><li>所以注意，select没模型是解决傻等的问题的，不解决这几个函数本身的阻塞问题，这几个函数本身阻塞的问题，我们接下来的模型会慢慢深入讲解，有五种模型呢~</li></ul></li></ul><h3 id="2-实现多个客户端链接与多个客户端分别通信"><a class="markdownIt-Anchor" href="#2-实现多个客户端链接与多个客户端分别通信"></a> 2、实现多个客户端链接，与多个客户端分别通信</h3><h3 id="3-用于服务器客户端就不用这个了因为只有一个socket"><a class="markdownIt-Anchor" href="#3-用于服务器客户端就不用这个了因为只有一个socket"></a> 3、用于服务器，客户端就不用这个了，因为只有一个socket</h3><ul><li>客户端recv等时候，也不能send啊？</li><li>只需要单独创建一根线程，recv放线程里，就完事儿~</li></ul><h2 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h2><h3 id="网络头文件-网络库"><a class="markdownIt-Anchor" href="#网络头文件-网络库"></a> 网络头文件 网络库</h3><ul><li><p>最底层的网络函数，大家用QT MFC wpf，或者百度下载的很多其他的封装好的网络库，都是对咱们讲的这些最本质的网络函数的二次封装，咱们讲的是通用的，讲完这个大家也可以自己封装函数库给别人用了。</p></li><li><p>#include &lt;WinSock2.h&gt;<br>#pragma comment(lib,“ws2_32.lib”)</p><ul><li><p>函数库</p><ul><li><p>winsock2.h</p><ul><li><p>windows socket 第2版</p><ul><li>第一版是 winsock.h</li><li>查看具体区别</li></ul></li><li><p>目前网络库有哪些版本？</p><ul><li><p>1.0<br>1.1<br>2.0<br>2.1<br>2.2</p><ul><li><p>演示MSDN</p><ul><li><p>查这个函数的详细信息</p><ul><li>WSAStartup</li></ul></li></ul></li></ul></li></ul></li><li><p>我们的开发环境支持哪个版本？</p><ul><li>打开头文件，看咱们当前编译器环境支持的最高版本</li></ul></li></ul></li><li><p>ws2_32.lib</p><ul><li><p>windows socket 第2版  32位</p><ul><li>不管是64编译环境还是32编译环境，都是用这个，并没有ws2_64.dll</li></ul></li></ul></li><li><p>wsock32.lib</p><ul><li>winsock.h 第一版网络库 对应的库文件</li></ul></li><li><p>这里不区分大小写</p></li></ul></li></ul></li></ul><h3 id="打开网络库"><a class="markdownIt-Anchor" href="#打开网络库"></a> 打开网络库</h3><ul><li><p>int WSAStartup(<br>WORD      wVersionRequired,<br>LPWSADATA lpWSAData<br>);</p><ul><li><p>功能</p><ul><li><p>打开网络库/启动网络库，启动了这个库，这个库里的函数/功能才能使用</p></li><li><p>w windows<br>s  socket<br>a Asynchronous  异步<br>startup   启动</p><ul><li><p>同步与异步</p><ul><li><p>同步</p><ul><li>阻塞/卡死状态</li></ul></li><li><p>异步</p><ul><li>多个工作同时进行</li></ul></li></ul></li></ul></li></ul></li><li><p>参数1</p><ul><li><p>我们要使用的库的版本</p></li><li><p>类型是 WORD</p><ul><li>转定义：unsigned  short</li></ul></li><li><p>WORD wVersionRequired = MAKEWORD(2,2);</p><ul><li><p>MAKEWORD(主版本,副版本)， 1.0 2.2</p></li><li><p>wVersionRequired</p><ul><li>数据高位/高地址是副版本</li><li>数据低位/低地址是主版本</li><li>用调试+计算器演示数据原理</li></ul></li></ul></li><li><p>位运算，内存操作，小端存储</p></li></ul></li><li><p>参数2</p><ul><li><p>LPWSADATA lpWSAData</p><ul><li><p>系统通过这个参数给我们一些配置信息</p><ul><li><p>注意</p><ul><li>当看到参数有 LP P前缀的时候，是说我们这里要传对应类型变量的地址，这是win32API 的规范 或者叫规则</li></ul></li></ul></li><li><p>看下有哪些信息</p><ul><li><p>struct WSAData {<br>WORD           wVersion;<br>WORD           wHighVersion;<br>unsigned short iMaxSockets;<br>unsigned short iMaxUdpDg;<br>char           *lpVendorInfo;<br>char           szDescription[WSADESCRIPTION_LEN + 1];<br>char           szSystemStatus[WSASYS_STATUS_LEN + 1];<br>}</p><ul><li><p>wVersion</p><ul><li>我们要使用的版本</li></ul></li><li><p>wHighVersion</p><ul><li>系统能提供给我们最高的版本</li></ul></li><li><p>iMaxSockets</p><ul><li>返回可用的socket的数量，2版本之后就没用了</li></ul></li><li><p>iMaxUdpDg</p><ul><li>UDP数据报信息的大小，2版本之后就没用了</li></ul></li><li><p>lpVendorInfo</p><ul><li>供应商特定的信息，2版本之后就没用了</li></ul></li><li><p>szDescription<br>szSystemStatus</p><ul><li>当前库的描述信息，2.0是第二版的意思</li></ul></li></ul></li></ul></li><li><p>当输入的版本不存在</p><ul><li><p>输入1.3， 2.3</p><ul><li><p>有主版本，没有副版本</p><ul><li>得到该主版本的最大副版本 1.1 2.2并使用</li></ul></li></ul></li><li><p>输入3.1  3.3</p><ul><li><p>超过最大版本号</p><ul><li>使用系统能提供的最大的版本 2.2</li></ul></li></ul></li><li><p>输入 0.0 0.1 0.3</p><ul><li><p>主版本是0</p><ul><li>网络库打开失败，不支持请求的套接字版本</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>返回0为执行正确</p></li><li><p>失败</p><ul><li>这些宏的本质</li><li>WSASYSNOTREADY   10091       底层网络子系统尚未准备好进行网络通信。                                                  系统配置问题，重启下电脑，检查ws2_32库是否存在，或者是否在环境配置目录下<br>WSAVERNOTSUPPORTED 10092 此特定Windows套接字实现不提供所请求的Windows套接字支持的版本。      要使用的版本不支持<br>WSAEPROCLIM        10067         已达到对Windows套接字实现支持的任务数量的限制。                                 Windows Sockets实现可能限制同时使用它的应用程序的数量<br>WSAEINPROGRESS 10036          正在阻止Windows Sockets 1.1操作。                                                          当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码，其他操作均禁止<br>WSAEFAULT            10014          lpWSAData参数不是有效指针。                                                                 参数写错了</li></ul></li></ul></li></ul></li></ul><h3 id="校验版本"><a class="markdownIt-Anchor" href="#校验版本"></a> 校验版本</h3><ul><li><p>2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion)</p><ul><li><p>HIBYTE是高位 副版本</p></li><li><p>LOBYTE是地位 主版本</p></li><li><p>逻辑</p><ul><li>只要有一个不是2，说明系统不支持我们要的2.2版本</li></ul></li></ul></li><li><p>关闭库<br>并结束函数，可以给出相应提示</p><ul><li>WSACleanup();</li><li>return 0；</li></ul></li></ul><h3 id="创建socket"><a class="markdownIt-Anchor" href="#创建socket"></a> 创建SOCKET</h3><ul><li><p>SOCKET  socket(<br>int af,<br>int type,<br>int protocol<br>);</p><ul><li><p>作用</p><ul><li>创建一个SOCKET</li></ul></li><li><p>SOCKET介绍</p><ul><li><p>什么是socket</p><ul><li>将底层复杂的协议体系，执行流程，进行了封装，封装完的结果，就是一个SOCKET了，</li><li>也就是说，SOCKET是我们调用协议进行通信的 操作接口</li></ul></li><li><p>意义</p><ul><li><p>将复杂的协议过程与我们编程人员分开，我们直接操作一个简单SOCKET就行了，对于底层的协议 过程细节，完全不用知道，这就大大方便了我们。</p><ul><li>网络编程难就难在协议本身的复杂性，简单就简单在我们编程层面完全不用考虑哪些</li></ul></li></ul></li><li><p>本质</p><ul><li><p>就是一种数据类型，转定义看下类型</p><ul><li><p>就是一个整数</p><ul><li>uint</li></ul></li><li><p>但是这个数是唯一的</p><ul><li>标识着我当前的应用程序，协议特点等信息</li><li>ID，门牌号</li></ul></li></ul></li></ul></li><li><p>应用</p><ul><li><p>我们网络通信的函数，全部都要使用SOCKET</p><ul><li>演示</li></ul></li><li><p>逻辑</p><ul><li>每个客户端有一个SOCKET，服务器有一个SOCKET，通信时候，就需要这个SOCKET做参数，给谁通信，就要传递谁的SOCKET</li></ul></li></ul></li><li><p>所以</p><ul><li>网络编程，理论层面SOCKET是网络封装的精华，代码层面就是不停的使用SOCKET这个变量，所以又叫SOCKET编程</li></ul></li></ul></li><li><p>参数1</p><ul><li><p>地址的类型</p><ul><li><p>比如大家联系我</p><ul><li><p>手机</p><ul><li>15512345678</li></ul></li><li><p>固定电话</p><ul><li>7881234</li></ul></li><li><p>ＱＱ</p><ul><li>40916626</li></ul></li><li><p>微信</p><ul><li>c3_xin666</li></ul></li><li><p>找上门</p><ul><li>内蒙古 xxxxxxx</li></ul></li><li><p>…</p></li></ul></li><li><p>AF_INET  2</p><ul><li><p>ipv4</p><ul><li><p>Internet协议版本4（IPv4）地址系列。</p><ul><li><p>192.168.1.103</p><ul><li>0.0.0.0  ~  255.255.255.255</li><li>点分十进制表示法</li></ul></li></ul></li><li><p>4字节 32位的地址</p><ul><li><p>个数快不够</p><ul><li>就是无符号int类型的范围  0 ~ 4294967295</li></ul></li></ul></li></ul></li></ul></li><li><p>AF_INET6  23</p><ul><li><p>ipv6</p><ul><li><p>Internet协议版本6（IPv6）地址系列。</p><ul><li>2001:0:3238:DFE1:63::FEFB</li></ul></li><li><p>16字节  128位的地址</p><ul><li>这个地球每寸一个IP</li></ul></li></ul></li></ul></li><li><p>AF_BTH  32</p><ul><li><p>蓝牙地址系列。<br>如果计算机安装了蓝牙适配器和驱动程序，则Windows XP SP2或更高版本支持此地址系列。</p><ul><li>6B:2D:BC:A9:8C:12</li></ul></li></ul></li><li><p>AF_IRDA  26</p><ul><li>红外数据协会（IrDA）地址系列。<br>仅当计算机安装了红外端口和驱动程序时，才支持此地址系列。</li></ul></li><li><p>通信地址不仅仅只有IP地址</p></li></ul></li></ul></li><li><p>参数2</p><ul><li><p>套接字类型</p><ul><li><p>SOCK_STREAM    1</p><ul><li>一种套接字类型，提供带有OOB数据传输机制的顺序，可靠，双向，基于连接的字节流。 此套接字类型使用传输控制协议（TCP）作为Internet地址系列（AF_INET或AF_INET6）。</li></ul></li><li><p>SOCK_DGRAM    2</p><ul><li>一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列（AF_INET或AF_INET6）。</li></ul></li><li><p>SOCK_RAW   3</p><ul><li>一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字。 要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。 要操作IPv6标头，必须在套接字上设置IPV6_HDRINCL套接字选项。</li></ul></li><li><p>SOCK_RDM   4</p><ul><li>一种套接字类型，提供可靠的消息数据报。 这种类型的一个示例是Windows中的实用通用多播（PGM）多播协议实现，通常称为可靠多播节目。<br>仅在安装了可靠多播协议时才支持此类型值。</li></ul></li><li><p>SOCK_SEQPACKET   5</p><ul><li>一种套接字类型，提供基于数据报的伪流数据包。</li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>协议的类型</p><ul><li><p>IPPROTO_TCP</p><ul><li>传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_UDP</p><ul><li>用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_ICMP</p><ul><li>Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_IGMP</p><ul><li>Internet组管理协议（IGMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。</li></ul></li><li><p>IPPROTO_RM</p><ul><li>用于可靠多播的PGM协议。 当af参数为AF_INET且类型参数为SOCK_RDM时，这是一个可能的值。 在针对Windows Vista及更高版本发布的Windows SDK上，此协议也称为IPPROTO_PGM。<br>仅在安装了可靠多播协议时才支持此协议值。</li></ul></li><li><p>整理下</p><ul><li>通过参数3得到一个事儿，参数1 2 3三者是配套的，是一套参数，不是随便填的，即使用不同的协议，那要添加对应的那套参数。</li><li>想要使用一个协议，咱们设备得支持才行，比如红外</li><li>参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型</li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功返回可用的socket</p><ul><li><p>不用了就一定要销毁套接字</p><ul><li>closesocket(socketListen);</li></ul></li></ul></li><li><p>失败返回INVALID_SOCKET</p><ul><li><p>关闭网络库</p><ul><li>WSACleanup();</li></ul></li><li><p>可用WSAGetLasterror()返回错误码</p></li></ul></li></ul></li></ul></li></ul><h3 id="绑定地址与端口"><a class="markdownIt-Anchor" href="#绑定地址与端口"></a> 绑定地址与端口</h3><ul><li><p>int bind(<br>SOCKET              s,<br>const sockaddr *addr,<br>int                 namelen<br>);</p><ul><li><p>作用</p><ul><li><p>给我们的socket绑定端口号与具体地址</p><ul><li><p>地址</p><ul><li><p>找到咱们的电脑</p><ul><li>只有一个</li></ul></li></ul></li><li><p>端口号</p><ul><li><p>找到我们机器上对应的软件，比如QQ，浏览器等等，都对应着自己的端口号</p><ul><li>多个</li></ul></li><li><p>每一种通信的端口号是唯一的</p></li><li><p>同一个软件可能占用多个端口号</p></li></ul></li></ul></li></ul></li><li><p>参数1</p><ul><li>上一个函数创建了socket，绑定了协议信息（地址类型，套接字类型，协议类型），咱们bind函数就是绑定实质的地址，端口号</li></ul></li><li><p>参数2</p><ul><li><p>结构体</p><ul><li>地址类型</li><li>装IP地址</li><li>端口号</li></ul></li><li><p>结构体类型</p><ul><li><p>sockaddr</p></li><li><p>该参数使用方法</p><ul><li><p>SOCKADDR_IN sockAddress;<br>sockAddress.sin_family = AF_INET;<br>sockAddress.sin_addr.s_addr = inet_addr(“127.0.0.1”);<br>sockAddress.sin_port = 12345;<br>(sockaddr*)&amp;sockAddress强转添加到参数2上</p><ul><li><p>成员1</p><ul><li>跟socket函数参数1是一样的</li></ul></li><li><p>成员2</p><ul><li><p>IP地址</p><ul><li><p><a href="http://192.168.xxx.xxx" target="_blank" rel="noopener">192.168.xxx.xxx</a></p><ul><li>可以在控制台输入指令  ipconfig 就能看到了</li><li>或者在网络设置中，能找到这个地址</li><li>我就不演示了，我不想让你们发现我</li></ul></li><li><p>127.0.0.1</p><ul><li>回送地址  本地回环地址  本地网络测试</li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>端口号</p><ul><li><p>本质</p><ul><li><p>就是一个整数</p><ul><li>0~65535</li></ul></li><li><p>IP是我们机器的地址，端口就是我们具体的软件的通信口，一个软件可能会占用多个接口，比如一个软件可以聊天，可以下载，可以看视频…那么这些不同的通信内容，往往会有各自的协议，各自的端口。</p><ul><li>IP是公司地址，端口就是各个部门的地址了</li></ul></li></ul></li><li><p>填写哪个值呢？</p><ul><li><p>理论上只要这个范围0~65535都可以</p><ul><li><p>实际</p><ul><li><p>介于0～1023，为系统保留占用端口号</p><ul><li>21端口分配给FTP(文件传输协议)服务<br>25端口分配给SMTP（简单邮件传输协议）服务<br>80端口分配给HTTP服务</li></ul></li></ul></li><li><p>所以</p><ul><li><p>我们不能写这个范围的</p><ul><li><p>我们的范围就是1024~65535</p><ul><li>稍微大点儿，1万多</li></ul></li><li><p>但是注意一点，端口号是唯一的，比如1234已经被别的软件占用了，那么你再使用1234这个端口号，那么就会绑定失败，因为已经呗占用了</p><ul><li>给大家演示下</li></ul></li><li><p>那大家如何查看自己要用的端口号有没有被占用呢？</p><ul><li><p>打开运行cmd输入netstat -ano</p><ul><li>查看被使用的所有端口</li></ul></li><li><p>netstat -aon|findstr “12345”</p><ul><li>检查我们要使用的端口号是否被使用了</li><li>使用了就会显示使用的程序，未被使用就啥都不显示</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>参数3</p><ul><li><p>参数2的类型大小</p><ul><li>sizeof(参数2)</li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功返回0</p></li><li><p>失败返回SOCKET_ERROR</p><ul><li>具体错误码通过int WSAGetLastError(void);获得</li><li>closesocket(socketListen);<br>WSACleanup();</li></ul></li></ul></li></ul></li></ul><h3 id="开始监听"><a class="markdownIt-Anchor" href="#开始监听"></a> 开始监听</h3><ul><li><p>int WSAAPI listen(<br>SOCKET s,<br>int    backlog<br>);</p><ul><li><p>作用</p><ul><li>将套接字置于正在侦听传入连接的状态。</li></ul></li><li><p>参数1</p><ul><li>服务器端的socket，也就是socket函数创建的</li></ul></li><li><p>参数2</p><ul><li><p>挂起连接队列的最大长度。</p><ul><li><p>就是说，比如有100个用户链接请求，但是系统一次只能处理20个，那么剩下的80个不能不理人家，所以系统就创建个队列记录这些暂时不能处理，一会儿处理的链接请求，依先后顺序处理，那这个队列到底多大？就是这个参数设置，比如2，那么就允许两个新链接排队的。这个肯定不能无限大，那内存不够了。</p></li><li><p>我们可以手动设置这个参数，但是别大了。可能2<sub>10多，</sub>20多。</p></li><li><p>我们一般填写这个参数</p><ul><li><p>SOMAXCONN</p><ul><li>作用是让系统自动选择最合适的个数</li><li>不同的系统环境不一样，所以这个合适的数也都不一样</li></ul></li></ul></li></ul></li></ul></li><li><p>WSAAPI</p><ul><li><p>调用约定</p><ul><li><p>这个我们可以忽略，这是给系统看的，跟咱们没关</p></li><li><p>决定三</p><ul><li>函数名字的编译方式</li><li>参数的入栈顺序</li><li>函数的调用时间</li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>成功</p><ul><li>返回0</li></ul></li><li><p>失败</p><ul><li><p>SOCKET_ERROR</p></li><li><p>具体错误码</p><ul><li><p>WSAGetLastError()</p></li><li><p>释放</p><ul><li>closesocket(socketListen);</li><li>WSACleanup();</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h3><ul><li><p>逻辑</p><ul><li><p>1、每个客户端都有socket，服务器也有自己的socket，将所有的socket装进一个数据结构里，即数组</p><ul><li>两种</li></ul></li><li><p>2、通过select函数，遍历1中的socket数组，当某个socket有响应，select就会通过其参数/返回值反馈出来。</p><ul><li>我们就做相应处理</li></ul></li><li><p>3、我们就做相应处理</p><ul><li><p>如果检测到的是服务器socket</p><ul><li>那就是有客户端链接</li><li>调用accept</li></ul></li><li><p>如果检测到的是客户端socket</p><ul><li>那就是客户端请求通信</li><li>send或者recv</li></ul></li></ul></li></ul></li><li><p>第一步</p><ul><li><p>定义一个装客户端socket结构</p><ul><li><p>fd_set  clientSet;</p><ul><li><p>fd_set网络定义好的专门给咱们用的</p></li><li><p>转定义看下fd_set的声明</p><ul><li><p>64</p><ul><li>默认FD_SETSIZE是64, 大家可以在Winsock2.h前声明这个宏，给他更大的值，他就更大了，不要过大</li><li>因为原理就是不听的遍历检测，越多肯定效率越低，延迟越大，所以大家尽量不要太大，几百个，1024就差不多了，当然大家不怕慢，可以设置更多~</li><li>所以，select模型应用，就是小用户量访问量，几十几百，简单方便。</li></ul></li></ul></li></ul></li><li><p>四个操作fd_set的参数宏</p><ul><li><p>依次转定义看下逻辑</p></li><li><p>FD_ZERO</p><ul><li>讲集合清0</li><li>FD_ZERO(&amp;clientSet);</li></ul></li><li><p>FD_SET</p><ul><li><p>向集合中添加一个socket</p><ul><li>当数量不足64，并且不存在的时候</li></ul></li><li><p>FD_SET(socket, &amp;setRead);</p></li></ul></li><li><p>FD_CLR</p><ul><li><p>结合中删除指定socket</p></li><li><p>FD_CLR(socket, &amp;setRead);</p><ul><li>我们要手动释放</li></ul></li></ul></li><li><p>FD_ISSET</p><ul><li><p>判断一个socket是否在集合中</p><ul><li>不在返回0</li><li>在返回非0</li></ul></li><li><p>FD_ISSET(socket, &amp;setRead)</p></li></ul></li></ul></li></ul></li></ul></li><li><p>第二步</p><ul><li><p>select</p><ul><li><p>作用</p><ul><li>监视socket集合，如果某个socket发生事件（链接或者收发数据），通过返回值以及参数告诉我们</li></ul></li><li><p>函数原型</p><ul><li><p>int WSAAPI select<br>(<br>int           nfds,<br>fd_set        *readfds,<br>fd_set        *writefds,<br>fd_set        *exceptfds,<br>const timeval *timeout<br>);</p><ul><li><p>参数1</p><ul><li><p>忽略</p><ul><li>填0</li></ul></li><li><p>这个参数仅仅是为了兼容Berkeley sockets.</p></li></ul></li><li><p>参数2</p><ul><li><p>检查是否有可读的socket</p><ul><li>即客户端发来消息了，该socket就会被设置</li></ul></li><li><p>&amp;setRead</p><ul><li>初始化为所有的socket，通过select投放给系统，系统将有事件发生的socket再赋值回来，调用后，这个参数就只剩下有请求的socket</li></ul></li></ul></li><li><p>参数3</p><ul><li><p>检查是否有可写的socket</p><ul><li>就是可以给哪些客户端套接字发消息，即send</li><li>只要链接成功建立起来了，那该客户端套接字就是可写的</li></ul></li><li><p>&amp;setWrite</p><ul><li>初始化为所有的socket，通过select投放给系统，系统将可写的socket再赋值回来，调用后，这个参数就是装着可以被send数据的客户端socket</li><li>一般我们就直接send了，所以这个参数逻辑上，用的不是非常多</li></ul></li></ul></li><li><p>参数4</p><ul><li><p>检查套接字上的异常错误</p><ul><li>用法跟2 3一样</li><li>将有异常错误的套接字重新装进来，，反馈给我们</li></ul></li><li><p>得到异常套接字上的具体错误码</p><ul><li><p>getsockopt （socket，SOL_SOCKET，  SO_ERROR, buf , buflen）</p><ul><li>错误信息通过参数4返给我们</li></ul></li></ul></li></ul></li><li><p>参数5</p><ul><li><p>最大等待时间</p><ul><li>比如当客户端没有请求时，那么select函数可以等一会儿，一段时间过后，还没有，就继续执行select下面的语句，如果有了，就立刻执行下面的语句</li></ul></li><li><p>TIMEVAL</p><ul><li><p>两个成员</p><ul><li><p>tv_sec</p><ul><li>秒</li></ul></li><li><p>tv_usec</p><ul><li>微秒</li></ul></li></ul></li><li><p>0 0</p><ul><li>非阻塞状态，立刻返回</li></ul></li><li><p>3 4</p><ul><li>那就再无客户端响应的情况下等待3秒4微秒</li></ul></li></ul></li><li><p>NULL</p><ul><li><p>select完全阻塞</p><ul><li>直到客户端有反应，我才继续</li></ul></li></ul></li></ul></li><li><p>返回值</p><ul><li><p>0</p><ul><li><p>客户端在等待时间内没有反应</p></li><li><p>处理</p><ul><li>continue就行了</li></ul></li></ul></li><li><blockquote><p>0</p></blockquote><ul><li>有客户端请求交流了</li></ul></li><li><p>SOCKET_ERROR</p><ul><li>发生了错误</li><li>得到错误码WSAGetLastError()</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>第四步</p><ul><li><blockquote><p>0处理</p></blockquote><ul><li><p>客户端socket有事件</p><ul><li><p>可读的</p><ul><li><p>遍历响应socket集合</p><ul><li><p>如果是socketServer</p><ul><li>accept</li></ul></li><li><p>客户端socket</p><ul><li><p>recv</p><ul><li><p>0</p><ul><li><p>客户端正常下线</p><ul><li>要在socket集合中删除对应的客户端socket</li></ul></li></ul></li><li><blockquote><p>0</p></blockquote><ul><li>客户端发来了消息，buf中</li></ul></li><li><p>socket_error</p><ul><li>客户端有错误发生</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>可写的</p><ul><li><p>调用send</p><ul><li><p>成功返回发送的字节数</p></li><li><p>失败返回socket_error</p><ul><li>WSAGetLastError的到错误码</li></ul></li></ul></li></ul></li><li><p>有异常的</p><ul><li><p>getsockopt （socket，SOL_SOCKET，  SO_ERROR, buf , buflen）</p><ul><li><p>作用</p><ul><li>将socket上产生的异常，通过参数4返回给咱们</li></ul></li><li><p>返回值</p><ul><li><p>成功返回0</p></li><li><p>失败返回sock_error</p><ul><li>WSAGetLastError得到错误码</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li><p>代码结构</p><ul><li>select模型的代码，也会有细节优化的，结构稍有变化的，但是原理都一样，咱们讲的就是最笨，思路最简单的方法，让大家理解这个模型的处理本质</li></ul></li><li><p>结构核心</p><ul><li><p>参数2</p><ul><li><p>处理accept与recv傻等的问题</p><ul><li>这是select结构对比基本模型的最大的作用</li><li>所以大家看网上的一些代码，基本都是只有参数2，参数3，4都是NULL</li></ul></li></ul></li><li><p>参数3</p><ul><li>send随时都能发，并不一定由参数3决定send</li></ul></li></ul></li><li><p>流程总结</p><ul><li><p>socket集合</p><ul><li><p>select判断有没有响应的</p><ul><li><p>返回0：没有，继续挑</p></li><li><p>返回&gt;0：有响应的</p><ul><li><p>可读的</p><ul><li>accept</li><li>recv</li></ul></li><li><p>可写的</p><ul><li><p>send</p><ul><li>不是非得从此处调用send</li></ul></li></ul></li><li><p>异常的</p><ul><li>getsockopt</li></ul></li></ul></li><li><p>sock_error</p></li></ul></li></ul></li></ul></li><li><p>select是阻塞的</p><ul><li><p>不等待</p><ul><li>执行阻塞</li></ul></li><li><p>半等待</p><ul><li>执行阻塞+软阻塞</li></ul></li><li><p>全等待</p><ul><li><p>执行阻塞+硬阻塞</p><ul><li>死等</li></ul></li></ul></li></ul></li></ul><h3 id="释放socket"><a class="markdownIt-Anchor" href="#释放socket"></a> 释放socket</h3><ul><li><p>释放所有socket</p></li><li><p>控制台点x退出</p><ul><li><p>主函数投递一个监视</p><ul><li>SetConsoleCtrlHandler(HandlerRoutine, FALSE);</li></ul></li><li><p>处理函数</p><ul><li>BOOL WINAPI HandlerRoutine(DWORD dwCtrlType )<br>{<br>switch (dwCtrlType)<br>{<br>case CTRL_CLOSE_EVENT:<br>{<br>释放socket;<br>}<br>}<br>return TRUE;<br>}</li></ul></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">SOCKET serverSocket;</span><br><span class="line">fd_set allSocket;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">ExitFun</span><span class="params">(DWORD dwCtrlType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (dwCtrlType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> CTRL_CLOSE_EVENT:</span><br><span class="line">FD_CLR(serverSocket, &amp;allSocket);</span><br><span class="line"><span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; allSocket.fd_count; i++) &#123;</span><br><span class="line">closesocket(allSocket.fd_array[i]);</span><br><span class="line">&#125;</span><br><span class="line">FD_ZERO(&amp;allSocket);</span><br><span class="line">closesocket(serverSocket);</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SetConsoleCtrlHandler(ExitFun, TRUE);</span><br><span class="line"></span><br><span class="line">WORD wdVersion = MAKEWORD(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">WSADATA wdSockMsg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nRes = WSAStartup(wdVersion, &amp;wdSockMsg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != nRes) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"WSAStartup Error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (HIBYTE(wdSockMsg.wVersion) != <span class="number">2</span> || LOBYTE(wdSockMsg.wVersion) != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"网络库版本出错"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (serverSocket == INVALID_SOCKET) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"socket Error: "</span> &lt;&lt; WSAGetLastError() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sockaddr_in si;</span><br><span class="line">si.sin_family = AF_INET;</span><br><span class="line">si.sin_port = htons(<span class="number">12346</span>);</span><br><span class="line">si.sin_addr.S_un.S_addr = inet_addr(<span class="string">"192.168.1.103"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == bind(serverSocket, (sockaddr *)&amp;si, <span class="keyword">sizeof</span>(si)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"bind Error: "</span> &lt;&lt; WSAGetLastError() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">closesocket(serverSocket);</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == listen(serverSocket,SOMAXCONN))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"listen Error: "</span> &lt;&lt; WSAGetLastError() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">closesocket(serverSocket);</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化allSocket变量</span></span><br><span class="line">FD_ZERO(&amp;allSocket);</span><br><span class="line"><span class="comment">//将服务器套接字添加到allSocket中</span></span><br><span class="line">FD_SET(serverSocket,&amp;allSocket);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//设置等待时间</span></span><br><span class="line">TIMEVAL waitTime;</span><br><span class="line">waitTime.tv_sec = <span class="number">3</span>;</span><br><span class="line">waitTime.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用临时的fd_set变量,防止被覆盖掉</span></span><br><span class="line">fd_set readAllSocket = allSocket;</span><br><span class="line">fd_set writeAllSocket = allSocket;</span><br><span class="line">fd_set exAllSocket = allSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入select,将有消息的套接字选出来</span></span><br><span class="line"><span class="keyword">int</span> nStRes = select(<span class="number">0</span>, &amp;readAllSocket, &amp;writeAllSocket, &amp;exAllSocket, &amp;waitTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有消息</span></span><br><span class="line"><span class="keyword">if</span> (nStRes == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有消息</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nStRes &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//处理有请求的套接字</span></span><br><span class="line"><span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; readAllSocket.fd_count; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果是服务器套接字,说明有accept请求</span></span><br><span class="line"><span class="keyword">if</span> (readAllSocket.fd_array[i] == serverSocket) &#123;</span><br><span class="line">sockaddr_in clientAddr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> addrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">SOCKET clientSocket = accept(serverSocket,(sockaddr *)&amp;clientAddr,&amp;addrLen);</span><br><span class="line"><span class="keyword">if</span> (clientSocket == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"accept Error: "</span> &lt;&lt; WSAGetLastError() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (allSocket.fd_count == FD_SETSIZE) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"服务器已满"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">send(clientSocket, <span class="string">"服务器爆满,请稍后连接..."</span>, <span class="keyword">sizeof</span>(<span class="string">"服务器爆满,请稍后连接...\n"</span>), <span class="number">0</span>);</span><br><span class="line">closesocket(clientSocket);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"连接服务器成功 : "</span> &lt;&lt; inet_ntoa(clientAddr.sin_addr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> sendRes = send(clientSocket, <span class="string">"连接成功..."</span>, <span class="keyword">sizeof</span>(<span class="string">"连接成功..."</span>) + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">FD_SET(clientSocket, &amp;allSocket);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收消息</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">char</span> recBuf[<span class="number">1500</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> recvRes = recv(readAllSocket.fd_array[i], recBuf, <span class="keyword">sizeof</span>(recBuf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (recvRes == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> WSAError = WSAGetLastError();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"recv Error: "</span> &lt;&lt; WSAError &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (WSAError == <span class="number">10054</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"客户端强制下线了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">FD_CLR(readAllSocket.fd_array[i],&amp;allSocket);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (recvRes == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"客户端下线了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">FD_CLR(readAllSocket.fd_array[i], &amp;allSocket);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; recBuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//for readAllsocket</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理异常错误</span></span><br><span class="line"><span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; exAllSocket.fd_count; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> exBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> exLen = <span class="number">1024</span>;</span><br><span class="line">getsockopt(exAllSocket.fd_array[i], SOL_SOCKET, SO_ERROR, exBuf, &amp;exLen);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"异常错误: "</span> &lt;&lt; exBuf&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">// for exAllSocket</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//else if 有消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//select出错了</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"select Error: "</span> &lt;&lt; WSAGetLastError() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//while(true)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; allSocket.fd_count; i++) &#123;</span><br><span class="line">closesocket(allSocket.fd_array[i]);</span><br><span class="line">&#125;</span><br><span class="line">closesocket(serverSocket);</span><br><span class="line">WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;select模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#select模型&quot;&gt;&lt;/a&gt; select模型&lt;/h1&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#特点&quot;&gt;&lt;/a&gt; 
      
    
    </summary>
    
      <category term="Windows网络编程" scheme="https://xiaowuyoucy.github.io/categories/Windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>异常类型和异常变量的生命周期</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/20/cpp0073-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%82%E5%B8%B8%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/20/cpp0073-异常类型和异常变量的生命周期/</id>
    <published>2021-06-20T00:14:35.000Z</published>
    <updated>2021-06-20T00:57:23.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常类型和异常变量的生命周期"><a class="markdownIt-Anchor" href="#异常类型和异常变量的生命周期"></a> 异常类型和异常变量的生命周期</h1><p>throw的异常是有类型的，可以使，数字、字符串、类对象。</p><p>throw的异常是有类型的，catch严格按照类型进行匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">MyException()&#123;&#125;</span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">MyException(<span class="keyword">const</span> <span class="keyword">char</span> * str)&#123;</span><br><span class="line">mStr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(mStr,str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line">MyException(<span class="keyword">const</span> MyException &amp; mE) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; mStr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(mE.mStr) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;mStr,mE.mStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mStr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~MyException() &#123;</span><br><span class="line"><span class="keyword">if</span> (mStr != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] mStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"对象析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> * mStr;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个匿名对象</span></span><br><span class="line"><span class="keyword">throw</span> MyException(<span class="string">"未知异常"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">test01();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MyException mE) &#123;</span><br><span class="line">mE.what();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h4 id="throw抛出去的如果是普通类型或者引用变量它的生命周期是在catch结束后释放掉"><a class="markdownIt-Anchor" href="#throw抛出去的如果是普通类型或者引用变量它的生命周期是在catch结束后释放掉"></a> throw抛出去的如果是普通类型或者引用变量,它的生命周期是在catch结束后释放掉</h4><h4 id="如果throw抛出去的是一个指针那么在进入catch前被释放掉"><a class="markdownIt-Anchor" href="#如果throw抛出去的是一个指针那么在进入catch前被释放掉"></a> 如果throw抛出去的是一个指针,那么在进入catch前被释放掉</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">MyException()&#123;&#125;</span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">MyException(<span class="keyword">const</span> <span class="keyword">char</span> * str)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"对象构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mStr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(mStr,str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line">MyException(<span class="keyword">const</span> MyException &amp; mE) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; mStr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(mE.mStr) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;mStr,mE.mStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mStr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~MyException() &#123;</span><br><span class="line"><span class="keyword">if</span> (mStr != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] mStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"对象析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> * mStr;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个匿名对象,如果抛出的是指针,会在进入catch前就释放掉该指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;(MyException(未知异常))"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> &amp;(MyException(<span class="string">"未知异常"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个匿名对象,抛出一个普通对象,用引用去接</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"MyException(未知异常)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> MyException(<span class="string">"未知异常"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个匿名对象,抛出一个普通对象</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"MyException(未知异常) 用普通对象来接"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> MyException(<span class="string">"未知异常"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (MyException * mE) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"未知异常"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"================================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">test02();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MyException &amp; mE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"未知异常"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"================================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">test03();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MyException  mE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"未知异常"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/1624150637188.png" alt="1624150637188"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常类型和异常变量的生命周期&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#异常类型和异常变量的生命周期&quot;&gt;&lt;/a&gt; 异常类型和异常变量的生命周期&lt;/h1&gt;
&lt;p&gt;throw的异常是有类型的，可以使，数字、字符串、类对象。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>异常接口声明</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/20/cpp0072-%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/20/cpp0072-异常接口声明/</id>
    <published>2021-06-19T23:55:35.000Z</published>
    <updated>2021-06-20T00:05:55.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常接口声明"><a class="markdownIt-Anchor" href="#异常接口声明"></a> 异常接口声明</h1><p>为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类<br>型，例如：</p><p><code>void func() throw (A, B, C , D);</code>这个函数func（）能够且只能抛出类<br>型A B C D及其子类型的异常。</p><p>如果在函数声明中没有包含异常接口声明，则次函数可以抛掷任何类型的<br>异常，例如：<br><code>void func();</code></p><p>一个不抛掷任何类型异常的函数可以声明为：<br><code>void func() throw();</code></p><p>如果一个函数抛出了它的异常接口声明所不允许抛出的异常，unexpected<br>函数会被调用，该函数默认行为调用terminate函数中止程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//只能抛出int,double,char这三个类型的异常</span></span><br><span class="line"><span class="comment">//在VS中可能抛出其他类型的异常不会出错,但在Linux会报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * gStr = <span class="string">"abc"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span><span class="title">throw</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">double</span>,<span class="keyword">char</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> gStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span><span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以抛出所有类型的异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">test01();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span> * y) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">double</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常接口声明&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#异常接口声明&quot;&gt;&lt;/a&gt; 异常接口声明&lt;/h1&gt;
&lt;p&gt;为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类&lt;br&gt;
型，例如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void 
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>栈解旋</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/20/cpp0071-%E6%A0%88%E8%A7%A3%E6%97%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/20/cpp0071-栈解旋/</id>
    <published>2021-06-19T23:33:40.000Z</published>
    <updated>2021-06-19T23:41:28.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈解旋"><a class="markdownIt-Anchor" href="#栈解旋"></a> 栈解旋</h1><p>异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的<br>所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈<br>的解旋(unwinding)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Person() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"对象构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Person() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"对象析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dev</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p1, p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dev(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">test01();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">double</span> y) <span class="comment">//异常是根据类型进行匹配的 可以是catch (double)不接收异常的值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"除数为: "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test02();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/1624146025433.png" alt="1624146025433"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;栈解旋&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#栈解旋&quot;&gt;&lt;/a&gt; 栈解旋&lt;/h1&gt;
&lt;p&gt;异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的&lt;br&gt;
所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>异常基本语法</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/20/cpp0070-%E5%BC%82%E5%B8%B8%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/20/cpp0070-异常基本语法/</id>
    <published>2021-06-19T23:26:16.000Z</published>
    <updated>2021-06-19T23:33:13.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常基本语法"><a class="markdownIt-Anchor" href="#异常基本语法"></a> 异常基本语法</h1><p>如果抛出异常后,不处理异常,程序会自动结束</p><p>异常是一层层向上抛出的,直到处理异常为止,如果抛到顶层还没有处理,程序自动结束.</p><p>c++的异常是必须处理的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//抛异常</span><br><span class="line">throw 变量/对象/值/指针  </span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">//可能会出现异常的语句块</span><br><span class="line">&#125;</span><br><span class="line">catch(类型/类型 变量名)</span><br><span class="line">&#123;</span><br><span class="line">//处理异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/1624145192251.png" alt="1624145192251"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dev</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> y; <span class="comment">//抛异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dev(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">//可能会出现异常</span></span><br><span class="line">test01();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">double</span> y) <span class="comment">//异常是根据类型进行匹配的 可以是catch (double)不接收异常的值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test02();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常基本语法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#异常基本语法&quot;&gt;&lt;/a&gt; 异常基本语法&lt;/h1&gt;
&lt;p&gt;如果抛出异常后,不处理异常,程序会自动结束&lt;/p&gt;
&lt;p&gt;异常是一层层向上抛出的,直到处理异常为止,如果抛到顶层还没有处
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>类型转换</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/20/cpp0069-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/20/cpp0069-类型转换/</id>
    <published>2021-06-19T21:52:15.000Z</published>
    <updated>2021-06-19T23:09:22.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h1><p>C++提供了4种类型转换，分别处理不同的场合应用</p><h3 id="static_cast-静态类型转换"><a class="markdownIt-Anchor" href="#static_cast-静态类型转换"></a> static_cast 静态类型转换。</h3><p>可以转换基本数据类型和具有继承关系的对象指针或引用</p><p><code>static_cast&lt;目标类型&gt; (标识符)</code></p><p><img src="/images/javawz/1624139983807.png" alt="1624139983807"></p><h3 id="reinterpret_cast重新解释类型转换"><a class="markdownIt-Anchor" href="#reinterpret_cast重新解释类型转换"></a> reinterpret_cast重新解释类型转换。</h3><p>仅仅重新解释类型，但没有进行二进制的转换：</p><p>1. 转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。</p><p>2. 在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。但不能将非32bit的实例转成指针。</p><p>3. 最普通的用途就是在函数指针类型之间进行转换。</p><p>4. 很难保证移植性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*VFun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span><span class="params">(*DFun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">VFun vf = <span class="literal">NULL</span>;</span><br><span class="line">DFun df = <span class="keyword">reinterpret_cast</span>&lt;DFun&gt;(vf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dynamic_cast-子类和父类之间的多态类型转换"><a class="markdownIt-Anchor" href="#dynamic_cast-子类和父类之间的多态类型转换"></a> dynamic_cast 子类和父类之间的多态类型转换。</h3><p><code>dynamic_cast&lt;目标类型&gt; (标识符)</code></p><p>只能转换具有继承关系的指针或引用,会做类型安全检查</p><p>只能从子类转父类,因为一般子类内存空间是大于等于父类的,如果子类内存空间大于父类，把父类指针转换成子类指针,会越界处理，所以不安全。</p><p>如果转换失败返回NULL</p><p><img src="/images/javawz/1624140927217.png" alt="1624140927217"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> * mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> * mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * pBase = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">Son * pSon = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">Animal * pAnimal = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//pSon = dynamic_cast&lt;Son *&gt;(pBase); 父类指针不能装子类指针</span></span><br><span class="line"><span class="comment">//pSon = dynamic_cast&lt;Son *&gt;(pAnimal); 不具有继承关系的不能转换</span></span><br><span class="line">pBase = <span class="keyword">dynamic_cast</span>&lt;Son *&gt;(pSon); <span class="comment">//子类转父类可以</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const_cast-去掉const属性转换"><a class="markdownIt-Anchor" href="#const_cast-去掉const属性转换"></a> const_cast 去掉const属性转换。</h3><p><code>const_cast&lt;目标类型&gt;(标识符)</code></p><p>目标类类型只能是指针或引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> * mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> * mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; b = a;</span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(b);</span><br><span class="line"></span><br><span class="line">c = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Base * a = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">const</span> Base *b = a;</span><br><span class="line">Base * c = <span class="keyword">const_cast</span>&lt;Base *&gt;(b);</span><br><span class="line">c = <span class="keyword">new</span>(Base);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"==========================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> c;</span><br><span class="line">c = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//基础数据类型</span></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象数据类型</span></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类型转换&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类型转换&quot;&gt;&lt;/a&gt; 类型转换&lt;/h1&gt;
&lt;p&gt;C++提供了4种类型转换，分别处理不同的场合应用&lt;/p&gt;
&lt;h3 id=&quot;static_cast-静态类型转换&quot;&gt;&lt;a class=
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>类模板中的static成员</title>
    <link href="https://xiaowuyoucy.github.io/2021/06/19/cpp0068-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84static%E6%88%90%E5%91%98/"/>
    <id>https://xiaowuyoucy.github.io/2021/06/19/cpp0068-类模板中的static成员/</id>
    <published>2021-06-18T23:33:17.000Z</published>
    <updated>2021-06-18T23:38:27.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类模板中的static成员"><a class="markdownIt-Anchor" href="#类模板中的static成员"></a> 类模板中的static成员</h1><p>类模板中的static成员单独属于每一个实例化出来的类</p><p>也就是说每个具体化类的static成员都是不一样的,没有关联的</p><p>例如有一个模板类A中有一个static成员</p><p>类<code>A&lt;int&gt;</code>和类<code>A&lt;double&gt;</code>都有自己的static成员,他们两个的static成员是不同且没有关联的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T value;</span><br><span class="line"><span class="keyword">static</span> T a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">A</span>&lt;T&gt;:</span>:a = <span class="number">0</span>;<span class="comment">//类中的静态成员需要在类的外部进行初始化。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 模板类通过二次编译根据调用的代码生成了两个不同的类A  一个是A&lt;int&gt; 一个A&lt;char&gt;</span></span><br><span class="line">A&lt;<span class="keyword">int</span>&gt; a1, a2, a3;</span><br><span class="line">A&lt;<span class="keyword">char</span>&gt; b1, b2, b3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A&lt;<span class="keyword">int</span>&gt;::a = <span class="number">20</span>; <span class="comment">//改变A&lt;int&gt;的静态成员</span></span><br><span class="line">A&lt;<span class="keyword">char</span>&gt;::a = <span class="string">'X'</span>;<span class="comment">//改变A&lt;char&gt;的静态成员</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a1:a = "</span> &lt;&lt; a1.a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//20</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b1:a = "</span> &lt;&lt; b1.a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//'X'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a2:a = "</span> &lt;&lt; a2.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a3:a = "</span> &lt;&lt; a3.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b2:a= "</span> &lt;&lt; b2.a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//'X'</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b3:a = "</span> &lt;&lt; b3.a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//'X'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类模板中的static成员&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类模板中的static成员&quot;&gt;&lt;/a&gt; 类模板中的static成员&lt;/h1&gt;
&lt;p&gt;类模板中的static成员单独属于每一个实例化出来的类&lt;/p&gt;
&lt;p&gt;也就是说
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
</feed>
