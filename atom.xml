<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanChen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowuyoucy.github.io/"/>
  <updated>2021-04-22T17:49:33.840Z</updated>
  <id>https://xiaowuyoucy.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数重载和函数指针</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/23/cpp0015-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/23/cpp0015-函数重载和函数指针/</id>
    <published>2021-04-22T16:12:36.000Z</published>
    <updated>2021-04-22T17:49:33.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数重载和函数指针"><a class="markdownIt-Anchor" href="#函数重载和函数指针"></a> 函数重载和函数指针</h1><p>函数重载与函数指针<br>当使⽤用重载函数名对函数指针进⾏行赋值时<br>根据重载规则挑选与函数指针参数列表⼀一致的候选者<br>严格匹配候选者的函数类型与函数指针的函数类型</p><p>函数指针，调用的时候是不能够发生函数重载的</p><h3 id="函数指针基本语法"><a class="markdownIt-Anchor" href="#函数指针基本语法"></a> 函数指针基本语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"func2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一种函数指针定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(My_func)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种函数指针定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*My_func2)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//第三种函数指针定义</span></span><br><span class="line"><span class="keyword">int</span>(*fp3)(<span class="keyword">int</span>, <span class="keyword">int</span>) = func;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt;d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 定义一个函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(myfunctype)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">//定义了一个函数类型， 返回值void 参数列表是 int，int   ,, void()(int,int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 定义一个函数指针类型 </span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*myfunctype_pointer)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">//定义了一个函数指针类型， 返回值void 参数列表是 int，int   ,, void(*)(int,int)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1  定义一个函数指针</span></span><br><span class="line">myfunctype * fp1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">fp1 = func;</span><br><span class="line"></span><br><span class="line">fp1(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 定义一个函数指针</span></span><br><span class="line">myfunctype_pointer fp2 = <span class="literal">NULL</span>;</span><br><span class="line">fp2 = func;</span><br><span class="line">fp2(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 直接定义一个函数指针</span></span><br><span class="line"><span class="keyword">void</span>(*fp3)(<span class="keyword">int</span>, <span class="keyword">int</span>) = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">fp3 = func;</span><br><span class="line"></span><br><span class="line">fp3(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" -----------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时的fp3 是 void(*)(int,int)</span></span><br><span class="line"><span class="comment">//fp3(10, 30, 30); //fp3 恒定指向一个 函数入口，void func(int, int) 的函数入口</span></span><br><span class="line"><span class="comment">//fp3(10, 30, 40, 50); //想要通过函数指针，发生函数重载 是不可能。</span></span><br><span class="line">fp3(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(*fp4)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>) = func; <span class="comment">//在堆函数指针赋值的时候，函数指针会根据自己的类型 找到一个重载函数</span></span><br><span class="line"></span><br><span class="line">fp4(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//fp4(10, 10, 10, 10);</span></span><br><span class="line"><span class="comment">//函数指针，调用的时候是不能够发生函数重载的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(*fp5)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>) = func;<span class="comment">// void func(int ,int ,int ,int )</span></span><br><span class="line">fp5(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数重载和函数指针&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数重载和函数指针&quot;&gt;&lt;/a&gt; 函数重载和函数指针&lt;/h1&gt;
&lt;p&gt;函数重载与函数指针&lt;br&gt;
当使⽤用重载函数名对函数指针进⾏行赋值时&lt;br&gt;
根据重载规则挑选与函数指
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>函数重载</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/23/cpp0014-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/23/cpp0014-函数重载/</id>
    <published>2021-04-22T16:12:36.000Z</published>
    <updated>2021-04-22T16:38:09.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数重载"><a class="markdownIt-Anchor" href="#函数重载"></a> 函数重载</h1><p>函数重载(Function Overload)：用同一个函数名定义不同的函数，当函<br>数名和不同的参数搭配时函数的含义不同。</p><h3 id="重载规则"><a class="markdownIt-Anchor" href="#重载规则"></a> 重载规则</h3><p>1,函数名相同。<br>2,参数个数不同,参数的类型不同,参数顺序不同,均可构成重载。<br>3,返回值类型不影响重载。</p><h3 id="调用准则"><a class="markdownIt-Anchor" href="#调用准则"></a> 调用准则</h3><p>1,严格匹配,找到则调用。<br>2,通过隐式转换寻求一个匹配,找到则调用。</p><h3 id="编译器调用重载函数的准则"><a class="markdownIt-Anchor" href="#编译器调用重载函数的准则"></a> 编译器调用重载函数的准则:</h3><p>1.将所有同名函数作为候选者<br>2.尝试寻找可行的候选函数<br>3.精确匹配实参<br>4.通过默认参数能够匹配实参<br>5.通过默认类型转换匹配实参<br>6.匹配失败<br>7.最终寻找到的可行候选函数不唯一，则出现二义性，编译失败。<br>8.无法匹配所有候选者，函数未定义，编译失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//决定一个函数的  1 返回值， 2 参数列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span><span class="comment">//void (*fp)(int)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"func1 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数重载 是对一种函数的 添加的 意义， 对一个函数名  添加多中不同的实现  （+）</span></span><br><span class="line"><span class="comment">//函数重载， 就是对参数列表的 变换不是 函数返回值的变化</span></span><br><span class="line"><span class="comment">//返回值必须一样，参数列表不同， 并且函数名 相同的函数 都是重载函数</span></span><br><span class="line"><span class="comment">//void func(int a, int b = 10)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"func2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">","</span> &lt;&lt;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数 完全相同 也不是一个函数重载</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void func(int a, int b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"func3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">", "</span> &lt;&lt; b &lt;&lt; <span class="string">", "</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值类型不同，不能构成重载</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char func()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"print double "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">float</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"print float"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"print int"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"print char"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义一个 指向void func(int a)的函数指针</span></span><br><span class="line"><span class="comment">//void(*fp)(int) = func;//fp 就是执行 void()(int) 这种函数类型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fp(10);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(<span class="number">10</span>); <span class="comment">//编译器 会根据用户传递的参数类型和个数 进行重载函数的匹配</span></span><br><span class="line"><span class="comment">//如果说函数重载 加上了默认参数， 回导致调用函数的时候出现二义性，</span></span><br><span class="line"><span class="comment">//记住：  函数重载 最好不要有默认参数，</span></span><br><span class="line">func(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">func(<span class="number">10</span>, <span class="number">20</span>, <span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//print(10); //void print(int a)</span></span><br><span class="line"><span class="comment">//print(1.1);//void print(double a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//print(1.1f); // 经过隐式转换 会调用void print(double a)</span></span><br><span class="line"><span class="comment">//print('a'); //经过隐式转化， 'a' -&gt;int   void print(int a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//print("asbdasd");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1 严格进行参数列表匹配</span></span><br><span class="line"><span class="comment">//2 如果隐式转换可以找到匹配 那么依然可以调用</span></span><br><span class="line"><span class="comment">//3 如果匹配不到， 直接报错。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载底层实现name-mangling"><a class="markdownIt-Anchor" href="#重载底层实现name-mangling"></a> 重载底层实现（name mangling）</h3><p>C++利用 name mangling(倾轧)技术,来改名函数名,区分参数不同的同<br>名函数。<br>实现原理:用 <code>v c i f l d</code>表示 <code>void char int float long double</code> 及其引<br>用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> a)</span></span>; <span class="comment">// func_c(char a)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">int</span> b,<span class="keyword">double</span> c)</span></span>; <span class="comment">//func_cid(char a,int b,double c);</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数重载&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数重载&quot;&gt;&lt;/a&gt; 函数重载&lt;/h1&gt;
&lt;p&gt;函数重载(Function Overload)：用同一个函数名定义不同的函数，当函&lt;br&gt;
数名和不同的参数搭配时函数的含义不同。&lt;
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>函数的默认参数和占位参数</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/22/cpp0013-%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%92%8C%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/22/cpp0013-函数的默认参数和占位参数/</id>
    <published>2021-04-22T15:48:32.000Z</published>
    <updated>2021-04-22T16:12:03.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数的默认参数和占位参数"><a class="markdownIt-Anchor" href="#函数的默认参数和占位参数"></a> 函数的默认参数和占位参数</h1><h3 id="默认参数规则"><a class="markdownIt-Anchor" href="#默认参数规则"></a> 默认参数规则</h3><p>只有参数列表后面部分的参数才可以提供默认参数值<br>一旦在一个函数调用中开始使用默认参数值，那么这个参数后的所有参<br>数都必须使用默认参数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qiuLiFangTiTiJi</span><span class="params">(<span class="keyword">int</span> l = <span class="number">10</span>, <span class="keyword">int</span> w = <span class="number">20</span>, <span class="keyword">int</span> h = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> l * w * h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> w = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; qiuLiFangTiTiJi() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; qiuLiFangTiTiJi(l) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; qiuLiFangTiTiJi(l, w) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; qiuLiFangTiTiJi(l, w, h) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="占位参数"><a class="markdownIt-Anchor" href="#占位参数"></a> 占位参数</h3><p>函数占位参数<br>占位参数只有参数类型声明，⽽而没有参数名声明<br>一般情况下，在函数体内部⽆无法使⽤用占位参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">float</span> = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max2(<span class="number">410</span>,<span class="number">330</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数的默认参数和占位参数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数的默认参数和占位参数&quot;&gt;&lt;/a&gt; 函数的默认参数和占位参数&lt;/h1&gt;
&lt;h3 id=&quot;默认参数规则&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; 
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>内联函数</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/22/cpp0012-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/22/cpp0012-内联函数/</id>
    <published>2021-04-22T15:30:23.000Z</published>
    <updated>2021-04-22T15:47:32.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内联函数"><a class="markdownIt-Anchor" href="#内联函数"></a> 内联函数</h1><p>c 语言中有宏函数的概念。宏函数的特点是内嵌到调用代码中去,避免了<br>函数调用 的开销。但是由于宏函数的处理发生在预处理阶段,缺失了语法检测<br>和有可能带来的语意差错</p><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点：</h3><p>1）内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直<br>接忽略内联请求。<br>2）C<ins>编译器直接将函数体插入在函数调用的地方 。<br>3）内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)。<br>4）内联函数是一种特殊的函数，具有普通函数的特征（参数检查，返回类型<br>等）。<br>5） 内联函数由 编译器处理，直接将编译后的函数体插入调用的地方，<br>宏代码片段 由预处理器处理， 进行简单的文本替换，没有任何编译过程。<br>6）C</ins>中内联编译的限制：</p><p>  不能存在任何形式的循环语句<br>  不能存在过多的条件判断语句<br>  函数体不能过于庞大<br>  不能对函数进行取址操作<br>  函数内联声明必须在调用语句之前<br>7）编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优<br>势只是省去了函数调用时压栈，跳转和返回的开销。因此，当函数体的执行开<br>销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> max = Max(a, b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内联函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内联函数&quot;&gt;&lt;/a&gt; 内联函数&lt;/h1&gt;
&lt;p&gt;c 语言中有宏函数的概念。宏函数的特点是内嵌到调用代码中去,避免了&lt;br&gt;
函数调用 的开销。但是由于宏函数的处理发生在预处理阶段,
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>const引用</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/22/cpp0011-const%E5%BC%95%E7%94%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/22/cpp0011-const引用/</id>
    <published>2021-04-22T15:26:26.000Z</published>
    <updated>2021-04-22T15:27:25.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="const引用"><a class="markdownIt-Anchor" href="#const引用"></a> const引用</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const引用一般用在形参上，来限制  被引用的变量不能被修改，</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; re )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"re "</span> &lt;&lt; re &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// a必须初始化</span></span><br><span class="line"><span class="comment">//int &amp; b = a;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是一个const 常量， 必须用const 引用来接收它</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;re1 = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"re1 "</span> &lt;&lt; re1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"re1 "</span> &lt;&lt; re1 &lt;&lt; <span class="string">", x: "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;re2 = <span class="number">10</span>;<span class="comment">// 用const 引用 引用一个字面量</span></span><br><span class="line"><span class="comment">// 当用一个const 引用  去引用一个字面量的时候， 字面量他是没有地址，</span></span><br><span class="line"><span class="comment">//引用是无法 对字面量取地址的， 临时创建一个 int temp， 10 ---&gt;temp</span></span><br><span class="line"><span class="comment">//const int &amp;re2 = temp;</span></span><br><span class="line"><span class="comment">//用re2 就是代表 temp，re2是const的引用，你无法去改变temp的值</span></span><br><span class="line"><span class="comment">//int &amp;re2 = 10;         //非常量引用 必须是左值。 左值就是可以放在=左边的表达式，左值是可以赋值，是有内存空间的</span></span><br><span class="line"><span class="comment">//如果想对一个字面量做引用的话，只能用 const 的引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"re2 = "</span> &lt;&lt; re2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(re2)"</span> &lt;&lt; <span class="keyword">sizeof</span>(re2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;const引用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#const引用&quot;&gt;&lt;/a&gt; const引用&lt;/h1&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>指针引用</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/22/cpp0010-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/22/cpp0010-指针引用/</id>
    <published>2021-04-22T15:15:14.000Z</published>
    <updated>2021-04-22T15:19:03.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针引用"><a class="markdownIt-Anchor" href="#指针引用"></a> 指针引用</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_malloc</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> **pp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">*pp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针引用做函数参数,优化二级指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_malloc2</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> * &amp;pp)</span><span class="comment">//pp 代表 *pp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">pp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">my_malloc(<span class="number">100</span>, &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">my_malloc2(<span class="number">4</span>, p);</span><br><span class="line"></span><br><span class="line">*p = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;指针引用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#指针引用&quot;&gt;&lt;/a&gt; 指针引用&lt;/h1&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>引用的本质</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/22/cpp0009-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/22/cpp0009-引用的本质/</id>
    <published>2021-04-22T14:28:42.000Z</published>
    <updated>2021-04-22T14:32:32.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用的本质"><a class="markdownIt-Anchor" href="#引用的本质"></a> 引用的本质</h1><p>在研究引用的时候 ，可以将引用理解为 一个 常指针<br>在理解引用的时候， 可以将引用理解为 一个变量的别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> &amp;a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motifyTeacher</span><span class="params">(Teacher &amp;t)</span> <span class="comment">//</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t.id = <span class="number">100</span>; <span class="comment">// 如果说t是一个常指针， *t 就是指针指向内存空间  (*t).id = 100</span></span><br><span class="line"><span class="comment">//当你要试图修改或者获取已经初始化的引用的时候， 编译器会有一个隐藏的*的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motifyA</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">const</span> a)</span>   <span class="comment">//常指针 也是一个常量， 也是必须要初始化，  也不能被修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*a = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motifyB</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = <span class="number">1000</span>; <span class="comment">//a 实际上是一个常量指针， 但是如果你给一个a赋值，编译器会有一个隐形的操作， *</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在研究引用的时候 ，可以将引用理解为 一个 常指针</span></span><br><span class="line"><span class="comment">//在理解引用的时候， 可以将引用理解为 一个变量的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">20</span>;</span><br><span class="line">Teacher t1 = &#123; <span class="number">1</span>, <span class="string">"zhangsan"</span> &#125;;</span><br><span class="line"></span><br><span class="line">motifyA(&amp;value);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"value = "</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">motifyB(value);  <span class="comment">// int value --&gt; int &amp;a  , int&amp; a = value 给引用指定指向哪个变量的时候， 编译器提供又有了一个隐形的操作</span></span><br><span class="line"> <span class="comment">// a = &amp;value;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"value = "</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">motifyTeacher(t1);  <span class="comment">//如果说 motifyTeacher 的形参是一个常指针，Teacher *const t = &amp;t1;</span></span><br><span class="line"><span class="comment">//编译器发现 Teacher &amp;t 形参是一个引用， Teacher &amp;t = &amp;t1;</span></span><br><span class="line"><span class="comment">//当给引用初始化的时候， 会有一个&amp;  的隐形操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motifyAA</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*a = <span class="number">100</span>;   <span class="comment">//间接的赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motifyBB</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> <span class="comment">//int &amp;a = a;    a = &amp;a;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = <span class="number">200</span>; <span class="comment">//*a = 200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//条件一</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">motifyAA(&amp;a); <span class="comment">//int*a = &amp;a; //建立了关联</span></span><br><span class="line"></span><br><span class="line">motifyBB(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c_a = 20;//常量在初始化之后，不能够再修改了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;re = a; <span class="comment">//引用必须初始化.  引用在初始化之后，也不能够被改变</span></span><br><span class="line">re = b; <span class="comment">// a = b 而不是 让re引用指向b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"re = "</span> &lt;&lt; re &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">re = <span class="number">100</span>; <span class="comment">//是该的a 还是b？</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"re = "</span> &lt;&lt; re &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 引用 可能是一个 常量？</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(TypeA): "</span> &lt;&lt; <span class="keyword">sizeof</span>(TypeA) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(TypeB):"</span> &lt;&lt; <span class="keyword">sizeof</span>(TypeB) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过对引用求大小， 发现不管引用是什么类型 都是4个字节，都跟指针的大小一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 引用可能是一个 指针？</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引用的本质&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引用的本质&quot;&gt;&lt;/a&gt; 引用的本质&lt;/h1&gt;
&lt;p&gt;在研究引用的时候 ，可以将引用理解为 一个 常指针&lt;br&gt;
在理解引用的时候， 可以将引用理解为 一个变量的别名&lt;/p&gt;
&lt;f
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>引用的基本概念</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/22/cpp0008-%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/22/cpp0008-引用的基本概念/</id>
    <published>2021-04-22T13:35:32.000Z</published>
    <updated>2021-04-22T19:44:07.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用的基本概念"><a class="markdownIt-Anchor" href="#引用的基本概念"></a> 引用的基本概念</h1><p>给变量起别名</p><h3 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h3><p>1 引用没有定义,是一种关系型声明。声明它和原有某一变量(实体)的关<br>系。故 而类型与原类型保持一致,且不分配内存。与被引用的变量有相同的地<br>址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp; re = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;a = "</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;re = "</span> &lt;&lt; &amp;re &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/1619099566174.png" alt="1619099566174"></p><p>2 声明的时候必须初始化,一经声明,不可变更。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//int &amp;re; //Error</span></span><br><span class="line"><span class="keyword">int</span> &amp;re = a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; re &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 可对引用,再次引用。多次引用的结果,是某一变量具有多个别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//int &amp;re; //Error</span></span><br><span class="line"><span class="keyword">int</span> &amp;re = a;</span><br><span class="line"><span class="keyword">int</span> &amp;re2 = re;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; re &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; re2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;re &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;re2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 &amp;符号前有数据类型时,是引用。其它皆为取地址。</p><p>引用做函数参数或函数返回值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">float</span> score;</span><br><span class="line"><span class="keyword">int</span> sex;</span><br><span class="line">&#125;Student;</span><br><span class="line"><span class="comment">//交换两个变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tem = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tem;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结构体变量</span></span><br><span class="line"><span class="function">Student &amp; <span class="title">my_print</span><span class="params">(Student &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.sex &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student XiaoMing = &#123; <span class="string">"XiaoMing"</span>,<span class="number">100.0f</span>,<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>, b = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">my_swap(a, b);</span><br><span class="line">my_print(XiaoMing);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引用的基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引用的基本概念&quot;&gt;&lt;/a&gt; 引用的基本概念&lt;/h1&gt;
&lt;p&gt;给变量起别名&lt;/p&gt;
&lt;h3 id=&quot;规则&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>枚举的增强</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/15/cpp0007-%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%A2%9E%E5%BC%BA/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/15/cpp0007-枚举的增强/</id>
    <published>2021-04-15T15:10:03.000Z</published>
    <updated>2021-04-15T15:11:30.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="枚举的增强"><a class="markdownIt-Anchor" href="#枚举的增强"></a> 枚举的增强</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Son &#123;</span><br><span class="line">xiaom,</span><br><span class="line">xiaoh,</span><br><span class="line">xiaol,</span><br><span class="line">xiaolan,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//可以省略enum关键字不写</span></span><br><span class="line">Son house = xiaom;</span><br><span class="line"><span class="comment">//c++中,枚举变量只能用枚举常量来赋值</span></span><br><span class="line"><span class="comment">//house = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; house &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.get();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;枚举的增强&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#枚举的增强&quot;&gt;&lt;/a&gt; 枚举的增强&lt;/h1&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>const的增强</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/15/cpp0006-const%E7%9A%84%E5%A2%9E%E5%BC%BA/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/15/cpp0006-const的增强/</id>
    <published>2021-04-15T14:19:28.000Z</published>
    <updated>2021-04-15T14:58:24.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="const的增强"><a class="markdownIt-Anchor" href="#const的增强"></a> const的增强</h1><p><code>const int * a</code>表示指针指向的内存空间不可以修改</p><p><code>int * const a</code>表示不能修改a的指向</p><p><code>const int * const a</code> 表示a的内存和a所指向的内存都不可以修改</p><p><img src="../../themes/pure/source/images/javawz/1618497147515.png" alt="1618497147515"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//在c语言中a是一个假常量,c++中a是一个真的常量,只不过在编译阶段完成,而不是预处理阶段</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个临时变量的地址赋值给p1,所以修改*p1时,a不会改变</span></span><br><span class="line"><span class="keyword">int</span> * p1 = (<span class="keyword">int</span> *)&amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++中const修饰过的整型变量可以声明数组,c语言不可以</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[a] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">*p1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../themes/pure/source/images/javawz/1618498667603.png" alt="1618498667603"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;const的增强&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#const的增强&quot;&gt;&lt;/a&gt; const的增强&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;const int * a&lt;/code&gt;表示指针指向的内存空间不可以修改&lt;/p&gt;
&lt;p&gt;&lt;cod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>三目运算符的加强</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/15/cpp0005-%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8A%A0%E5%BC%BA/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/15/cpp0005-三目运算符的加强/</id>
    <published>2021-04-14T17:53:25.000Z</published>
    <updated>2021-04-15T14:18:49.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三目运算符的加强"><a class="markdownIt-Anchor" href="#三目运算符的加强"></a> 三目运算符的加强</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//三目运算符可以用作左值,返回的是a或b的引用</span></span><br><span class="line"><span class="comment">//c语言则不行,除非这样写(a &gt; b ? &amp;a : &amp;b) = 100;</span></span><br><span class="line">(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.get();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三目运算符的加强&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#三目运算符的加强&quot;&gt;&lt;/a&gt; 三目运算符的加强&lt;/h1&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语言对C的增强和bool</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/15/cpp0004-C-%E8%AF%AD%E8%A8%80%E5%AF%B9C%E7%9A%84%E5%A2%9E%E5%BC%BA%E5%92%8Cbool/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/15/cpp0004-C-语言对C的增强和bool/</id>
    <published>2021-04-14T17:53:25.000Z</published>
    <updated>2021-04-14T18:31:06.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c语言对c的增强和bool"><a class="markdownIt-Anchor" href="#c语言对c的增强和bool"></a> C++语言对C的增强和bool</h1><ul><li><p>变量定义</p><ul><li>c语言:早期版本中规定要定义在函数首部</li><li>c++:在函数内随便一个位置都可以</li></ul></li><li><p>c<ins>对定义全局变量的检测能力增强了,c语言在同一个地方可以定义多次重名的全局变量,c</ins>不可以.</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_a;</span><br><span class="line"><span class="keyword">int</span> g_a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">c语言会处理成:</span></span><br><span class="line"><span class="comment">int g_a;</span></span><br><span class="line"><span class="comment">g_a = 2;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>struct</code>的类型增强<ul><li>C++定义<code>struct</code>变量时可以不用加<code>struct</code>关键字</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//可以不用加struct关键字</span></span><br><span class="line">student xiaoming;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++不可以没有函数类型,c语言可以没有函数类型,默认是int</p><p>C++填写函数参数必须是对应个数,C语言可以不对应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c语言可以没有函数类型,默认为int</span></span><br><span class="line">fun()&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1(<span class="keyword">int</span> a) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入过多的参数,c语言也不会出错</span></span><br><span class="line">fun1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">61</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++引入了<code>bool</code>类型来表示<code>true</code>和<code>false</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">bool</span>)flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(flag) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (flag = <span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (flag = <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c语言对c的增强和bool&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c语言对c的增强和bool&quot;&gt;&lt;/a&gt; C++语言对C的增强和bool&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;变量定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;c语言:早期版本中
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义命名空间</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/15/cpp0003-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/15/cpp0003-自定义命名空间/</id>
    <published>2021-04-14T17:37:03.000Z</published>
    <updated>2021-04-14T18:29:54.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义命名空间"><a class="markdownIt-Anchor" href="#自定义命名空间"></a> 自定义命名空间</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">语法:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">namespace 自定义命名空间名&#123;</span></span><br><span class="line"><span class="comment">内容</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xiaochenyanA &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xiaochenyanB &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以嵌套定义命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> xiaochenyanC &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">float</span> score;</span><br><span class="line">&#125;<span class="keyword">student_t</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> xiaochenyanD &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> score;</span><br><span class="line">&#125;<span class="keyword">student_t</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认使用xiaochenyanC命名空间下的变量或对象,不建议这样做</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> xiaochenyanC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> xiaochenyanA;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> xiaochenyanB;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> xiaochenyanB::xiaochenyanC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">student_t</span> xiaoming = &#123; <span class="number">100.0f</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; xiaoming.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//如果命名空间中的对象冲突,需要使用命名空间名来引用对象</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (xiaochenyanA::a = <span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; xiaochenyanA::a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; xiaochenyanB::a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//程序暂停</span></span><br><span class="line"><span class="built_in">cin</span>.get();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自定义命名空间&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#自定义命名空间&quot;&gt;&lt;/a&gt; 自定义命名空间&lt;/h1&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>namespace命名空间</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/15/cpp0002-namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/15/cpp0002-namespace命名空间/</id>
    <published>2021-04-14T16:43:28.000Z</published>
    <updated>2021-04-14T18:29:40.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="namespace命名空间"><a class="markdownIt-Anchor" href="#namespace命名空间"></a> namespace命名空间</h1><p>假如同一个公司有两个张三，当你叫张三的时候，两个张三都会回头。这就出现了二义性。</p><p>为了区分这两个张三，就引进了命名空间。</p><p>第一个张三可以叫为张三A</p><p>第二个张三可以叫为张三B</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//方式1，可以直接使用std内的元素</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2，可以直接使用cout</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3，通过命名空间名来引用cout</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//只能在本复合语句内使用</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a;<span class="comment">//出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;namespace命名空间&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#namespace命名空间&quot;&gt;&lt;/a&gt; namespace命名空间&lt;/h1&gt;
&lt;p&gt;假如同一个公司有两个张三，当你叫张三的时候，两个张三都会回头。这就出现了二义性
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>第一个c++程序 hello world</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/15/cpp0001%E7%AC%AC%E4%B8%80%E4%B8%AAc-%E7%A8%8B%E5%BA%8F-hello-world/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/15/cpp0001第一个c-程序-hello-world/</id>
    <published>2021-04-14T16:37:42.000Z</published>
    <updated>2021-04-14T16:42:43.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个c程序-hello-world"><a class="markdownIt-Anchor" href="#第一个c程序-hello-world"></a> 第一个c++程序 hello world</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cout 表示输出流，将hello world流到终端</p><p>endl 表示换行</p><p>cin 表示输入流，从键盘输入内容流到变量a中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">0</span></span><br><span class="line"><span class="comment">//可以理解为注释,编译器会忽略里面的代码</span></span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一个c程序-hello-world&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一个c程序-hello-world&quot;&gt;&lt;/a&gt; 第一个c++程序 hello world&lt;/h1&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>第四章网络层</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/14/计算机网络原理笔记-第四章网络层/</id>
    <published>2021-04-14T15:31:49.000Z</published>
    <updated>2021-04-14T16:06:16.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机网络原理笔记-第四章-网络层"><a class="markdownIt-Anchor" href="#计算机网络原理笔记-第四章-网络层"></a> 计算机网络原理笔记 第四章 网络层</h3><ul><li><ul><li><a href="#网络层提供得两种服务">网络层提供得两种服务</a></li></ul></li><li><ul><li><a href="#1.虚电路服务">1.虚电路服务</a></li></ul></li><li><p><a href="#2.数据包服务">2.数据包服务</a></p></li><li><p><a href="#虚电路服务与数据报服务的对比">虚电路服务与数据报服务的对比</a></p></li><li><p><a href="#网际协议 IP">网际协议 IP</a></p></li><li><ul><li><a href="#1.虚拟互联网">1.虚拟互联网</a></li></ul></li><li><p><a href="#2.IP地址">2.IP地址</a></p><ul><li><p><a href="#3.划分子网和构造超网">3.划分子网和构造超网</a></p></li><li><p><a href="#4.IP地址与硬件地址">4.IP地址与硬件地址</a></p></li><li><p><a href="#5.**ARP & RARP**">5.<strong>ARP &amp; RARP</strong></a></p></li><li><p><a href="#6.IP数据报格式">6.IP数据报格式</a></p></li><li><p><a href="#7.IP转发分组的流程">7.IP转发分组的流程</a></p></li><li><p><a href="#网际控制报文协议 ICMP">网际控制报文协议 ICMP</a></p></li><li><p><a href="#互联网的路由选择协议">互联网的路由选择协议</a></p></li><li><ul><li><p><a href="#（1）内部网关协议RIP">（1）内部网关协议RIP</a></p></li><li><p><a href="#(2)内部网关协议OSPF">(2)内部网关协议OSPF</a></p></li></ul></li><li><p><a href="#IP多播">IP多播</a></p></li><li><p><a href="#网络地址转换NAT">网络地址转换NAT</a></p></li></ul></li></ul><p><span id="网络层提供得两种服务"></span></p><h2 id="网络层提供得两种服务"><a class="markdownIt-Anchor" href="#网络层提供得两种服务"></a> 网络层提供得两种服务</h2><p><strong>网络层提供的两种服务</strong></p><ul><li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。</li><li>争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是<strong>网络</strong>还是网络层提供的两种服务</li><li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。</li><li>争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？ ？</li><li>两种服务：网络层应该向运输层提供怎样得服务<ul><li>虚电路服务</li><li>数据包服务</li></ul></li></ul><p><span id="1.虚电路服务"></span></p><h3 id="1虚电路服务"><a class="markdownIt-Anchor" href="#1虚电路服务"></a> 1.虚电路服务</h3><p>面向连接的通信方式</p><ul><li>建立<strong>虚电路</strong>(Virtual Circuit)，以保证双方通信所需的一切网络资源。</li><li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点。<br><img src="/images/javawz/20200430162831795.png" alt="在这里插入图片描述"><br><strong>虚电路是逻辑连接</strong></li><li>虚电路表示这只是一条<strong>逻辑上的连接</strong>，分组都沿着这条逻辑连接按照存储转发方式传送，而<strong>并不是真正建立了一条物理连接</strong>。</li><li>请注意，电路交换的电话通信是先建立了一条真正的连接。因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。</li></ul><p>.<br>.<br><span id="2.数据包服务"></span></p><h3 id="2数据包服务"><a class="markdownIt-Anchor" href="#2数据包服务"></a> 2.数据包服务</h3><p><img src="/images/javawz/20200430163756614.png" alt="在这里插入图片描述"><br><img src="/images/javawz/20200506083348375.png" alt="在这里插入图片描述"></p><p><strong>因特网采用的设计思路</strong></p><ul><li>网络层向上只提供简单灵活的、无连接的、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。</li><li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li><li>网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</li></ul><p>.<br>.</p><p><strong>尽最大努力交付的好处</strong></p><ul><li>由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</li><li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。</li><li>采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用。</li><li>因特网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</li></ul><p>.<br>.<br><span id="虚电路服务与数据报服务的对比"></span></p><h3 id="虚电路服务与数据报服务的对比"><a class="markdownIt-Anchor" href="#虚电路服务与数据报服务的对比"></a> 虚电路服务与数据报服务的对比</h3><ul><li><table><thead><tr><th>对比的方面</th><th>虚电路服务</th><th>数据报服务</th></tr></thead><tbody><tr><td>思路</td><td>可靠通信应当由网络来保证</td><td>可靠通信应当由用户主机来保证</td></tr><tr><td>连接的建立</td><td>必须有</td><td>不需要</td></tr><tr><td>终点地址</td><td>仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td>每个分组都有终点的完整地址</td></tr><tr><td>分组的转发</td><td>属于同一条虚电路的分组均按照同一路由进行转发</td><td>每个分组独立选择路由进行转发</td></tr><tr><td>当结点出故障时</td><td>所有通过出故障的结点的虚电路均不能工作</td><td>出故障的结点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点时不一定按发送顺序</td></tr><tr><td>端到端的差错处理和流量控制</td><td>可以由网络负责，也可以由用户主机负责</td><td>由用户主机负责</td></tr></tbody></table></li></ul><p>.<br>.<br><span id="网际协议 IP"></span></p><h2 id="网际协议-ip"><a class="markdownIt-Anchor" href="#网际协议-ip"></a> 网际协议 IP</h2><p><img src="/images/javawz/20200507093025535.png" alt="在这里插入图片描述"><br><span id="1.虚拟互联网"></span></p><h3 id="1虚拟互联网"><a class="markdownIt-Anchor" href="#1虚拟互联网"></a> 1.虚拟互联网</h3><p><strong>网络层中间设备</strong><br>中间设备又称为中间系统或中继(relay)系统。</p><ul><li>物理层中继系统：转发器(repeater)。</li><li>数据链路层中继系统：网桥或桥接器(bridge)。</li><li>网络层中继系统：路由器(router)。</li><li>网络层以上的中继系统：网关(gateway)。<br>注： 现在说的网关一般指的是路由器接口，网关地址一般习惯使用本网段第一个地址或者最后一个地址</li></ul><p><img src="/images/javawz/20200502224434522.png" alt="在这里插入图片描述"></p><p><img src="/images/javawz/20200502224345992.png" alt="在这里插入图片描述"><br><strong>虚拟互连网络的意义</strong></p><ul><li>所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。</li><li>使用 IP 协议的虚拟互连网络可简称为 IP 网。</li><li>使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。</li></ul><p>.<br>.<br><span id="2.IP地址"></span></p><h3 id="2ip地址"><a class="markdownIt-Anchor" href="#2ip地址"></a> 2.IP地址</h3><p><strong>本小节我转载了与韩老师讲解思路一致 但是总结的更详细的IP地址与划分博文合集笔记供大家阅读</strong><br><strong>点下方链接就可进入</strong></p><blockquote><p><strong><a href="https://blog.csdn.net/LeeQiang8023/article/details/105896270" target="_blank" rel="noopener">1、IP地址和子网划分学习笔记之《预备知识：进制计数》</a></strong></p><p><strong><a href="https://blog.csdn.net/LeeQiang8023/article/details/105896390" target="_blank" rel="noopener">2、IP地址和子网划分学习笔记之《IP地址详解》</a></strong></p><p><strong><a href="https://blog.csdn.net/LeeQiang8023/article/details/105896584" target="_blank" rel="noopener">3、IP地址和子网划分学习笔记之《子网掩码详解》</a></strong><br><span id="3.划分子网和构造超网"></span></p></blockquote><h3 id="3划分子网和构造超网"><a class="markdownIt-Anchor" href="#3划分子网和构造超网"></a> 3.划分子网和构造超网</h3><p><strong>本小节我转载了与韩老师讲解思路一致 但是总结的更详细的IP地址与划分博文合集笔记供大家阅读</strong><br><strong>点下方链接就可进入</strong></p><blockquote><p><strong><a href="https://blog.csdn.net/LeeQiang8023/article/details/105896492" target="_blank" rel="noopener">4、IP地址和子网划分学习笔记之《子网划分详解》</a></strong></p><p><strong><a href="https://blog.csdn.net/LeeQiang8023/article/details/105896531" target="_blank" rel="noopener">5、IP地址和子网划分学习笔记之《超网合并详解》</a></strong><br><span id="4.IP地址与硬件地址"></span></p></blockquote><h3 id="4ip地址与硬件地址"><a class="markdownIt-Anchor" href="#4ip地址与硬件地址"></a> 4.IP地址与硬件地址</h3><p><strong>本小节我转载了与韩老师讲解思路一致 但是总结的更详细的IP地址与划分博文合集笔记供大家阅读</strong><br><strong>点下方链接就可进入</strong></p><blockquote><p><strong><a href="https://blog.csdn.net/LeeQiang8023/article/details/105896390" target="_blank" rel="noopener">2、IP地址和子网划分学习笔记之《IP地址详解》</a></strong></p></blockquote><p>.<br>.<br><span id="5.**ARP & RARP**"></span></p><h3 id="5arp-rarp"><a class="markdownIt-Anchor" href="#5arp-rarp"></a> 5.<strong>ARP &amp; RARP</strong></h3><p><img src="/images/javawz/20200506112109402.png" alt="在这里插入图片描述"><br><strong>ARP简介</strong></p><p>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。</p><p>每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p><p>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。<br><img src="/images/javawz/20200506112227720.png" alt="在这里插入图片描述"></p><p><strong>ARP高速缓存的作用</strong></p><p>为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。</p><p>当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。</p><p>.</p><p>.<br><strong>使用</strong> <strong>ARP</strong> <strong>的四种典型情况</strong></p><ul><li>发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li><li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li></ul><p>.<br>.</p><p><strong>应当注意的问题</strong></p><p>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。</p><p>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p><p>从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。</p><p>只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。</p><p>.<br>.<br><strong>逆地址解析协议 RARP</strong></p><p>逆地址解析协议 RARP 使只知道自己硬件地址的主机能够知道其 IP 地址。</p><p>.<br><span id="6.IP数据报格式"></span></p><h3 id="6ip数据报格式"><a class="markdownIt-Anchor" href="#6ip数据报格式"></a> 6.IP数据报格式</h3><p><strong>IP数据包</strong><br><img src="/images/javawz/20200506085348654.png" alt="在这里插入图片描述"></p><p>一个 IP 数据包由首部和数据两部分组成。</p><ul><li>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><p><img src="/images/javawz/20200506085505183.png" alt="在这里插入图片描述"></p><p><strong>IP 数据报首部的固定部分中的各字段</strong></p><ul><li><strong>版本</strong>——占4位，指IP协议的版本，目前使用的IP协议版本号为4（即IPv4）</li><li><strong>首部长度</strong>——占4位，课表示的最大数值 是15个单位(一个单位为4字节)，因此IP的首部长度的最大值是60字节。</li><li><strong>区分服务</strong>——让数据包加上一个标记，来告诉网络上那些传输的数据，这些数据包在传的时候 是着急还是不着急。QOS服务质量</li><li><strong>总长度</strong>——占16位，指首部和数据之和的长度，单位位字节，因此数据报的最大长度位65535字节。总长度必须不超过最大传送单元MTU。</li><li><strong>标识</strong>——占16位，它是一个计数器，用老产生数据报的标识，不是序号，每产生一个数据包，就增加1。</li><li><strong>标志</strong>——占3位，目前只有前两位有意义。标志字段的最低位是MF。 MF=1表示后面“还有分片”。MF=0表示最后一个分片。标志字段中间的一位是DF。 只有当DF=0时才允许分片。<br><img src="/images/javawz/20200506094017932.png" alt="在这里插入图片描述"></li><li><strong>生存时间</strong> 记位TTL （Time To Live） 占8位，数据报在网络中可通过的路由器数的最大值<br>数据包没过一个路由器 TTL-1</li><li><strong>协议</strong>——协议（8位）字段指出此数据报携带的数据使用何种学语以便目的主机的IP层讲数据部分交给哪个处理<br><img src="/images/javawz/20200506101736822.png" alt="在这里插入图片描述"></li><li><strong>首部检验和</strong>——首部检验和(16 位)字段只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。<br><img src="/images/javawz/20200506102016792.png" alt="在这里插入图片描述"><br><img src="/images/javawz/20200506102238549.png" alt="在这里插入图片描述"></li></ul><p>.<br>.<br><strong>IP数据报首部的可变部分</strong></p><p>IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。</p><p>选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。</p><p>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。</p><p>实际上这些选项很少被使用。</p><p>.<br>.<br><span id="7.IP转发分组的流程"></span></p><h3 id="7ip转发分组的流程"><a class="markdownIt-Anchor" href="#7ip转发分组的流程"></a> 7.IP转发分组的流程</h3><p><strong>数据包如何路由</strong><br><img src="/images/javawz/20200507093926598.png" alt="在这里插入图片描述"></p><p><strong>IP路由</strong></p><ul><li><p>路由就是路由器从一个网段到另外一个网段转发数据包的过程，即数据包通过路由器转发，就是数据路由。</p></li><li><p>网络畅通条件，要求数据包必须能够到达目标地址，同时数据包必须能够返回发送地址。</p></li><li><p>这就要求沿途经过的路由器必须知道到目标网络如何转发数据包，即到达目的网络下一跳转发给哪个路由器，也就是必须有到达目标网络的路由，沿途的路由器还必须有数据包返回所需的路由。<br>.</p></li><li><blockquote><p><strong>数据路由</strong>：路由器在不同网段转发数据包<br><strong>网络畅通的条件</strong>：能去能回<br>沿途的路由器必须知道目标网络下一跳给哪个接口<br>沿途的路由器必须知道源网络下一跳给哪个接口</p></blockquote></li></ul><p><img src="/images/javawz/20200506204208551.png" alt="在这里插入图片描述"></p><ul><li>如图所示，计算机PC0 ping PC1，网络要想通，要求沿途的路由器Router0，Router1，Router2，Router3都必须有到192.168.1.0/24网络的路由，这样数据包才能到达PC1。</li><li>PC1要回应数据包给PC0，沿途所有的路由器必须有到192.168.0.0/24网络的路由，这样数据包才能回来。</li></ul><p>.<br>.<br><strong>配置静态路由</strong><br><img src="/images/javawz/20200506205100202.png" alt="在这里插入图片描述"></p><p><strong>默认路由</strong></p><ul><li>网络地址和子网掩码都为0，如图所示配置，这就意味着到任何网络下一跳转发给10.0.0.2。</li><li>网络地址和子网掩码均为0的路由就是默认路由。<ul><li>Router(config)#ip route 0.0.0.0 0.0.0.0 10.0.0.2</li></ul></li></ul><p>.<br>.<br><strong>Windows上的默认路由和网关</strong></p><ul><li>计算机也有路由表，我们可以在计算机上运行route print显示Windows操作系统上的路由表。</li><li>运行netstat –r也可以显示Windows操作系统上的路由表。</li><li>如图所示，给计算机配置网关就是给计算机添加默认路由。<br><img src="/images/javawz/20200506212853937.png" alt="在这里插入图片描述"></li></ul><p>.<br>.</p><ul><li>如果不配置计算机的网关，使用以下命令添加默认路由。</li><li>如图所示，去掉本地连接的网关，在命令提示符下，输入route print ，可以看到没有默认路由了，该计算机也不能访问其他网段，ping 202.99.160.68 提示“目标主机不可到达”。<br><img src="/images/javawz/20200506212957308.png" alt="在这里插入图片描述"><br>.<br>.</li><li>如图所示，在命令提示符下，输入route /?可以看到该命令的帮助。</li><li>输入route add 0.0.0.0 mask 0.0.0.0 192.168.8.1，添加默认路由。</li><li>输入route print 可以显示路由表，默认路由已经出现。</li><li>Ping 202.99.160.68 可以ping通。<br><img src="/images/javawz/20200506213204945.png" alt="在这里插入图片描述"></li></ul><p>.<br>.</p><ul><li>如图所示，内网的计算机需要配置IP地址、子网掩码和网关，网关就是Server的内网网卡的IP地址。在Server的两个连接，内网的网卡不需要配置网关，但是连接Internet的网卡需要配置默认网关。<br><img src="/images/javawz/20200506213316454.png" alt="在这里插入图片描述"><br>.<br>.<br><strong>注意</strong></li><li>IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。</li><li>当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。</li><li>网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。<br>.<br>.<br><span id="网际控制报文协议 ICMP"></span></li></ul><h2 id="网际控制报文协议-icmp"><a class="markdownIt-Anchor" href="#网际控制报文协议-icmp"></a> 网际控制报文协议 ICMP</h2><p><strong>ICMP简介</strong></p><p>为了提高 IP 数据报交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。</p><p>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</p><p>ICMP 不是高层协议，而是 IP 层的协议。</p><p>ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。<br>.<br>.<br><strong>ICMP报文格式</strong><br><img src="/images/javawz/20200507091405628.png" alt="在这里插入图片描述"><br>.<br>.<br><strong>ICMP报文的类型</strong></p><ul><li>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</li><li>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。</li><li>差错报告报文有五种：终点不可达 ，源点抑制(Source quench) ，时间超过 ，参数问题 ，改变路由（重定向）(Redirect)</li><li>询问报文有两种：回送请求和回答报文，时间戳请求和回答报文<br><img src="/images/javawz/20200507091541236.png" alt="在这里插入图片描述"><img src="/images/javawz/20200507091556553.png" alt="在这里插入图片描述"></li></ul><p><strong>差错报告报告报文的数据字段的内容</strong><br><img src="/images/javawz/20200507091643165.png" alt="在这里插入图片描述"><br>.<br>.<br><strong>ICMP应用举例</strong></p><ul><li>PING 用来测试两个主机之间的连通性。<ul><li>PING 使用了 ICMP 回送请求与回送回答报文。</li></ul></li><li>PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。</li><li>Pathping</li><li>tracert<br><img src="/images/javawz/20200507092729465.png" alt="在这里插入图片描述"></li></ul><p>.<br>.<br><strong>ping命令诊断网络故障</strong></p><ul><li>PING（Packet Internet Grope），因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP回声请求消息给目的地并报告是否收到所希望的ICMP回声应答。</li><li>ping指的是端对端连通，通常用来作为可用性的检查， 但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。 严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。</li><li>如果你打开IE浏览器访问网站失败，你可以通过ping命令测试到Internet的网络连通，可以为你排除网络故障提供线索，下面展示ping命令返回的信息以及分析其原因。</li></ul><p>.<br><strong>目标主机不可到达</strong><br><img src="/images/javawz/20200507103301406.png" alt="在这里插入图片描述"><br><strong>目标网络不可到达</strong><br><img src="/images/javawz/20200507103340478.png" alt="在这里插入图片描述"><br><strong>请求超时</strong><br><img src="/images/javawz/20200507103422784.png" alt="在这里插入图片描述"></p><p><strong>通过延迟评估网络带宽</strong><br><img src="/images/javawz/20200507103834272.png" alt="在这里插入图片描述"><br>.<br>.<br><strong>Pathping跟踪数据包的路径</strong></p><p>使用ping能够判断网络通还是不通，比如请求超时，你就不能判断什么位置出现的网络故障造成的请求超时。使用pathping命令能跟踪数据包的路径，能够查出故障点，并且能够计算路由器转发丢包率和链路丢包率以及延迟，据此能够判断出网络拥塞情况。<br><img src="/images/javawz/2020050710393134.png" alt="在这里插入图片描述"><br><span id="互联网的路由选择协议"></span></p><h2 id="互联网的路由选择协议"><a class="markdownIt-Anchor" href="#互联网的路由选择协议"></a> 互联网的路由选择协议</h2><p>路由选择协议的核心就是路由算法，一个理想的路由算法应该以下特点：</p><ul><li>算法必须是正确的和完整的：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机</li><li>算法在计算上应简单</li><li>算法应能适应通信量和网络拓扑的变化：即要有自适应性。</li><li>算法应具有稳定性</li><li>算法应该是公平的</li><li>算法应该是最佳的</li></ul><p><strong>路由选择包括静态和动态：</strong></p><ul><li><p>静态（非自适应路由选择）：简单和开销较小，但不能及时适应网络状态的变化，适用于简单的小网络</p></li><li><p>动态（自适应路由）：能较好地适应网络状态的变化。但实现起来较为复杂，开销比较大。</p></li><li><p>互联网才用的路由选择协议主要是<strong>自适应、分布式路由选择协议</strong>，由于以下两个原因，互联网采用分层次的路由选择协议：</p><ul><li>互联网的规模非常大，如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大</li><li>许多单位不愿意外界了解自己单位网路的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网上。</li></ul><p>.</p></li><li><p>为此，把整个互联网划分为许多较小的自治系统AS（autonomous system）。自治系统AS是在单一技术管理下的一组路由器，这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个AS对其他AS表现出的是一个单一的和一直的路由选择策略。</p></li></ul><p>这样就把路由选择协议划分为两大类：<br><strong>内部网关协议IGP</strong>（Interior Gateway protocol）:也叫作域内路由选择，即在一个自治系统内部使用的路由选择协议，如RIP和OSPF协议。<br><strong>外部网关协议EGP</strong>（External Gateway Protocol）：也叫作域间路由选择，若源主机和目的主机处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。<br><span id="（1）内部网关协议RIP"></span></p><h3 id="1内部网关协议rip"><a class="markdownIt-Anchor" href="#1内部网关协议rip"></a> （1）内部网关协议RIP</h3><p>RIP是一种<strong>分布式的基于距离向量的路由选择协议</strong>。<br>RIP要求每一个路由器都要维护从它自己到其他每一个目的网络距离记录。<br>距离的定义：从一个路由器到直接连接的网络的距离定义为1/0，其中每经过一次路由器就加1，也称为“跳数”。<br>分布式路由的特点就是：每一个路由器都要不断地和其他一些路由器交换路由信息，周期性广播。</p><p><strong>RIP协议的特点：</strong></p><ul><li>仅和相邻路由器交换信息。</li><li>路由器交换的信息使当前本路由器所知道的全部信息，即自己现在的路由表，包括到本自治网络的最短距离，以及到每个网络应经过的下一跳路由器。</li><li>按照固定的时间间隔交换路由信息。</li><li>路由器刚刚开始工作时，它的路由表是空的，经过若干次更新后，所有路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。</li><li>距离向量算法：找出每个目的网络的最短距离算法。</li></ul><blockquote><p>收到相邻路由器（其地址为 X）的一个 RIP 报文：<br>(1) 先修改此 RIP 报文中的所有项目：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。<br>(2) 对修改后的 RIP 报文中的每一个项目，重复以下步骤：<br>若项目中的目的网络不在路由表中，则把该项目加到路由表中。<br>否则<br>​ 若下一跳字段给出的路由器地址是同样的，则把收到的项 目 替换原路由表中的项目。<br>否则<br>​ 若收到项目中的距离小于路由表中的距离，则进行更新，<br>否则，什么也不做。<br>(3) 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为16（距离为16表示不可达）。</p></blockquote><p><strong>RIP协议的优缺点</strong></p><ul><li>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。</li><li>RIP 协议最大的优点就是实现简单，开销较小。</li><li>RIP 限制了网络的规模，它能使用的最大距离为 <strong>15（16 表示不可达）。</strong></li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li></ul><p>.<br>.<br><span id="(2)内部网关协议OSPF"></span></p><h3 id="2内部网关协议ospf"><a class="markdownIt-Anchor" href="#2内部网关协议ospf"></a> (2)内部网关协议OSPF</h3><p><strong>OSPF 协议的基本特点</strong></p><p>“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。</p><p>“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF</p><p>OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p><p>是分布式的链路状态协议。</p><p>.<br>.<br><strong>三个要点</strong></p><p><strong>向本自治系统中所有路由器发送信息</strong>，这里使用的方法是洪泛法。</p><p>发送的信息就是与本路由器<strong>相邻</strong>的所有路由器的链路状态，但这只是路由器所知道的<strong>部分信息</strong>。</p><p>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。</p><p>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p><p>.<br>.<br><strong>链路状态数据库</strong></p><ul><li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。</li><li>这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。</li><li>OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点。 \</li></ul><p><strong>OSPF 划分为两种不同的区域</strong><br><img src="/images/javawz/20200511145155197.png" alt="在这里插入图片描述"></p><p><strong>划分区域</strong></p><ul><li>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。</li><li>在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。</li><li>OSPF 使用层次结构的区域划分。在上层的区域叫作主干区域(backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。<br><img src="/images/javawz/20200511145252579.png" alt="在这里插入图片描述"><br><img src="/images/javawz/20200511145303192.png" alt="在这里插入图片描述"></li></ul><p><strong>OSPF 直接用 IP 数据报传送</strong></p><ul><li>OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>OSPF 构成的数据报很短。这样做可减少路由信息的通信量。</li><li>数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</li></ul><p>.<br>.<br><strong>OSPF 的其他特点</strong></p><ul><li>OSPF 对不同的链路可根据 IP 分组的不同服务类型 TOS 而设置成不同的代价。因此，OSPF 对于不同类型的业务可计算出不同的路由。</li><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫作多路径间的负载平衡。</li><li>所有在 OSPF 路由器之间交换的分组都具有鉴别的功能。</li><li>支持可变长度的子网划分和无分类编址 CIDR。</li><li>每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。</li></ul><p><img src="/images/javawz/20200511145739994.png" alt="在这里插入图片描述"></p><p><strong>OSPF 的五种分组类型</strong></p><ul><li>类型1，问候(Hello)分组。</li><li>类型2，数据库描述(Database Description)分组。</li><li>类型3，链路状态请求(Link State Request)分组。</li><li>类型4，链路状态更新(Link State Update)分组， 用洪泛法对全网更新链路状态。</li><li>类型5，链路状态确认(Link State Acknowledgment) 分组。<br><img src="/images/javawz/20200511150003451.png" alt="在这里插入图片描述"><br><img src="/images/javawz/20200511150049489.png" alt="在这里插入图片描述"></li></ul><p>.<br>.<br><strong>OSPF 的其他特点</strong></p><ul><li>OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。</li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。</li><li>OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。<br><span id="IP多播"></span></li></ul><h2 id="ip多播"><a class="markdownIt-Anchor" href="#ip多播"></a> IP多播</h2><p><span id="网络地址转换NAT"></span></p><h2 id="网络地址转换nat"><a class="markdownIt-Anchor" href="#网络地址转换nat"></a> 网络地址转换NAT</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机网络原理笔记-第四章-网络层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机网络原理笔记-第四章-网络层&quot;&gt;&lt;/a&gt; 计算机网络原理笔记 第四章 网络层&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#网
      
    
    </summary>
    
      <category term="计算机网络原理" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章 数据链路层</title>
    <link href="https://xiaowuyoucy.github.io/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://xiaowuyoucy.github.io/2021/04/01/计算机网络原理笔记-第三章-数据链路层/</id>
    <published>2021-03-31T16:50:41.000Z</published>
    <updated>2021-03-31T18:00:00.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算网络原理-第三章-数据链路层"><a class="markdownIt-Anchor" href="#计算网络原理-第三章-数据链路层"></a> 计算网络原理 第三章 数据链路层</h3><ul><li><a href="#数据链路层（一）">数据链路层（一）</a></li><li><ul><li><a href="#3.1 使用点对点信道的数据链路层">3.1 使用点对点信道的数据链路层</a></li><li><ul><li><a href="#3.1.1 数据链路层和帧">3.1.1 数据链路层和帧</a></li><li><a href="#3.1.2 三个基本问题">3.1.2 三个基本问题</a></li></ul></li></ul></li><li><a href="#数据链路层的信道类型">数据链路层的信道类型</a></li><li><ul><li><a href="#3.2 点对点协议 PPP">3.2 点对点协议 PPP</a></li><li><ul><li><a href="#3.2.1 PPP协议的特点">3.2.1 PPP协议的特点</a></li><li><a href="#3.2.2 PPP协议的帧格式">3.2.2 PPP协议的帧格式</a></li><li><a href="#3.2.3 PPP协议的工作状态">3.2.3 PPP协议的工作状态</a></li></ul></li><li><a href="#3.3 使用广播信道的数据链路层(局域网)">3.3 使用广播信道的数据链路层(局域网)</a></li><li><ul><li><a href="#3.3.1 局域网的数据链路层">3.3.1 局域网的数据链路层</a></li></ul></li></ul></li></ul><p><span id="数据链路层（一）"></span></p><h1 id="数据链路层一"><a class="markdownIt-Anchor" href="#数据链路层一"></a> 数据链路层（一）</h1><p><span id="3.1 使用点对点信道的数据链路层"></span></p><h2 id="31-使用点对点信道的数据链路层"><a class="markdownIt-Anchor" href="#31-使用点对点信道的数据链路层"></a> 3.1 使用点对点信道的数据链路层</h2><p><span id="3.1.1 数据链路层和帧"></span></p><h3 id="311-数据链路层和帧"><a class="markdownIt-Anchor" href="#311-数据链路层和帧"></a> 3.1.1 数据链路层和帧</h3><p><em><strong>*数据发送模型*</strong></em><br><img src="/images/javawz/20200425225800499.gif" alt><br><em><strong>*数据链路层的信道类型*</strong></em><br>数据链路层使用的信道主要有以下两种类型：</p><ul><li>点对点信道。这种信道使用一对一的点对点通信方式。</li><li>广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li></ul><p>.<br>.</p><p><strong>链路与数据链路</strong></p><ul><li>**链路(link)**是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</li></ul><blockquote><p>一条链路只是一条通路的一个组成部分。</p></blockquote><ul><li><strong>数据链路(data link)</strong> 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</li></ul><blockquote><ul><li>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。</li><li>一般的适配器都包括了数据链路层和物理层这两层的功能。</li></ul></blockquote><p><strong>帧</strong></p><ul><li>数据链路层传送的是<strong>帧</strong><br><img src="/images/javawz/20200425231742936.png" alt="-"><img src="/images/javawz/20200425231834393.png" alt="在这里插入图片描述"></li></ul><p>.<br>.<span id="3.1.2 三个基本问题"></span></p><h3 id="312-三个基本问题"><a class="markdownIt-Anchor" href="#312-三个基本问题"></a> 3.1.2 三个基本问题</h3><p><strong>1.封装成帧</strong></p><ul><li><strong>封装成帧(framing)</strong> 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</li><li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。<br><img src="/images/javawz/20200426172625769.png" alt="在这里插入图片描述"></li><li>用控制字符进行帧定界的方法举例</li></ul><blockquote><p>试想：帧还未发送完，发送端出了问题，只能重发该帧。接收端却收到了前面的“半截子帧”，它会抛弃吗？为什么？</p></blockquote><p><img src="/images/javawz/20200426172811364.png" alt="在这里插入图片描述"></p><p><strong>2.透明传输</strong></p><blockquote><ul><li>若传输的数据是ASCII码中“可打印字符(共95个)“集时，一切正常。</li><li>若传输的数据不是仅由”可打印字符”组成时，就会出问题，如下<br><img src="/images/javawz/20200426173915485.png" alt="在这里插入图片描述"></li></ul></blockquote><p><strong>用字节填充法解决透明传输问题</strong></p><ul><li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。</li><li><strong>字节填充</strong>(byte stuffing)或<strong>字符填充</strong>(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li><li>如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li><li>当传送的帧是用文本文件组成的帧时（文本文件中的字都是从键盘上输入的），其数据部分显然不会出现像SOH或EOT这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。<br><img src="/images/javawz/20200426174326691.png" alt="在这里插入图片描述"></li></ul><p>.<br>.<br><strong>3.差错控制</strong></p><ul><li>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0 而 0 也可能变成 1。</li><li>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率</strong> BER (Bit Error Rate)。</li><li>误码率与信噪比有很大的关系。</li><li>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。</li></ul><p><strong>循环冗余检验的原理</strong></p><ul><li>在数据链路层传送的帧中，广泛使用了<strong>循环冗余检验</strong> CRC 的检错技术。</li><li>在发送端，先把数据划分为组。假定每组 <em>k</em> 个比特。</li><li>假设待传送的一组数据 <em>M</em> = 101001（现在 <em>k</em> = 6）。我们在 <em>M</em> 的后面再添加供差错检测用的 <em>n</em> 位<strong>冗余码</strong>一起发送。</li></ul><p><strong>冗余码的计算</strong></p><ul><li>用二进制的模 2 运算进行 2<em>n</em> 乘 <em>M</em> 的运算，这相当于在 <em>M</em> 后面添加 <em>n</em> 个 0。</li><li>得到的 (<em>k</em> + <em>n</em>) 位的数除以事先选定好的长度为 (<em>n</em> + 1) 位的<strong>除数</strong> <em>P</em>，得出<strong>商</strong>是 <em>Q</em> 而余数是 <em>R</em>，<strong>余数</strong> <em>R</em> 比除数 <em>P</em> 少1 位，即 <em>R</em> 是 <em>n</em> 位。</li></ul><p><strong>冗余码的计算举例</strong></p><blockquote><p>现在 <em>k</em> = 6, <em>M</em> = 101001。<br>设 <em>n</em> = 3, 除数 <em>P</em> = 1101，<br>被除数是 2<em>n**M</em> = 101001000。<br>模 2 运算的结果是：商 <em>Q</em> = 110101，<br>余数 <em>R</em> = 001。<br>把余数 <em>R</em> 作为冗余码添加在数据 <em>M</em> 的后面发送出去。发送的数据是：2<em>n**M</em> + <em>R</em><br>即：101001001，共 (<em>k</em> + <em>n</em>) 位。</p></blockquote><p><strong>循环冗余检验的原理说明</strong><br><img src="/images/javawz/20200426190323318.png" alt="在这里插入图片描述"><br><strong>帧检验序列 FCS</strong><br>在数据后面添加上的冗余码称为<strong>帧检验序列</strong> FCS (Frame Check Sequence)。</p><p>循环冗余检验 CRC 和帧检验序列 FCS并不等同。</p><ul><li>CRC 是一种常用的<strong>检错方法</strong>，而 FCS 是添加在数据后面的<strong>冗余码</strong>。</li><li>FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。</li></ul><p><strong>接收端对收到的每一帧进行 CRC 检验</strong></p><ul><li>(1) 若得出的余数 <em>R</em> = 0，则判定这个帧没有差错，就<strong>接受</strong>(accept)。</li><li>(2) 若余数 <em>R</em> ≠ 0，则判定这个帧有差错，就<strong>丢弃</strong>。</li><li>但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。<br>只要经过严格的挑选，并使用位数足够多的除数 <em>P</em>，那么出现检测不到的差错的概率就很小很小。</li></ul><p><strong>补零位数比除数位数少一</strong></p><blockquote><p>异或运算<br>1+1=0 1+0=0 0+1=0 0+0=0</p></blockquote><p><strong>除数由两台计算机数据链路层协议决定</strong></p><p><em><strong>*小结：CRC差错检测技术*</strong></em><br>仅用循环冗余检验 CRC 差错检测技术只能做到<strong>无差错接受</strong>(accept)。</p><ul><li>“无差错接受”是指：“凡是接受的帧（<strong>即不包括丢弃的帧</strong>），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。</li><li>要做到“<strong>可靠传输</strong>”（即发送什么就收到什么）就必须再加上<strong>确认</strong>和<strong>重传</strong>机制。<ul><li>考虑：帧重复、帧丢失、帧乱序的情况</li></ul></li></ul><p>可以说“CRC是一种<strong>无比特差错</strong>，而不是<strong>无传输差错</strong>的检测机制”<br>OSI/RM模型的观点:数据链路层要做成无传输差错的!但这种理念目前不被接受。</p><p>.<br>.<br>.<span id="数据链路层的信道类型"></span></p><h1 id="数据链路层的信道类型"><a class="markdownIt-Anchor" href="#数据链路层的信道类型"></a> 数据链路层的信道类型</h1><p>•数据链路层使用的信道主要有以下两种类型：</p><ul><li>点对点信道。 这种信道使用一对一的点对点通信方式。</li><li>广播信道。 这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发。</li></ul><p>.<br>·<span id="3.2 点对点协议 PPP"></span></p><h2 id="32-点对点协议-ppp"><a class="markdownIt-Anchor" href="#32-点对点协议-ppp"></a> 3.2 点对点协议 PPP</h2><ul><li><p>现在全世界使用得最多的数据链路层协议是<strong>点对点协议</strong> PPP (Point-to-Point Protocol)。</p></li><li><p>用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议。</p><p><strong>用户到 ISP 的链路使用 PPP 协议</strong><br><img src="/images/javawz/20200426211558866.png" alt="在这里插入图片描述"></p><p><span id="3.2.1 PPP协议的特点"></span></p></li></ul><h3 id="321-ppp协议的特点"><a class="markdownIt-Anchor" href="#321-ppp协议的特点"></a> 3.2.1 PPP协议的特点</h3><p><strong>PPP 协议应满足的需求</strong></p><ul><li>简单——这是首要的要求</li><li>封装成帧</li><li>透明性</li><li>多种网络层协议</li><li>多种类型链路</li><li>差错检测</li><li>检测连接状态</li><li>最大传送单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ul><p>·</p><p><strong>PPP 协议不需要的功能</strong></p><ul><li>纠错</li><li>流量控制</li><li>序号</li><li>多点线路</li><li>半双工或单工链路</li></ul><p><strong>PPP 协议的组成</strong></p><ul><li>1992 年制订了 PPP 协议。经过 1993 年和 1994 年的修订，现在的 PPP 协议已成为因特网的正式标准[RFC 1661]。<ul><li>PPP 协议有三个组成部分</li><li>一个将 IP 数据报封装到串行链路的方法。</li><li>链路控制协议 LCP (Link Control Protocol)。</li><li>网络控制协议 NCP (Network Control Protocol)。</li></ul></li></ul><p>.<br>.<span id="3.2.2 PPP协议的帧格式"></span></p><h3 id="322-ppp协议的帧格式"><a class="markdownIt-Anchor" href="#322-ppp协议的帧格式"></a> 3.2.2 PPP协议的帧格式</h3><ul><li>标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进- - 制表示是 01111110）。</li><li>地址字段 A 只置为 0xFF。地址字段实际上并不起作用。</li><li>控制字段 C 通常置为 0x03。</li><li>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。<br><img src="/images/javawz/20200427080007332.png" alt="在这里插入图片描述"></li></ul><p><strong>透明传输问题</strong></p><ul><li>当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）。</li><li>当 PPP 用在异步传输时，就使用一种特殊的 字符填充法 。</li></ul><p><strong>字符填充</strong></p><ul><li>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E)。</li><li>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D)。</li><li>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。</li></ul><p>.<br><strong>零比特填充</strong></p><ul><li>PPP 协议用在 SONET/SDH 链路时，是使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。</li><li>在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除。<br><img src="/images/javawz/2020042708083468.png" alt="在这里插入图片描述"><br>.<br>.<br><strong>不提供使用序号和确认 的可靠传输</strong></li><li>PPP 协议之所以不使用序号和确认机制是出于以下的考虑：<ul><li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li><li>在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li><li>帧检验序列 FCS 字段可保证无差错接受。<br>.<br>.</li></ul></li></ul><p><span id="3.2.3 PPP协议的工作状态"></span></p><h3 id="323-ppp协议的工作状态"><a class="markdownIt-Anchor" href="#323-ppp协议的工作状态"></a> 3.2.3 PPP协议的工作状态</h3><ul><li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li><li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li><li>这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li><li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。<br><img src="/images/javawz/20200427081935529.png" alt="在这里插入图片描述"><br>.<br>.</li></ul><p><span id="3.3 使用广播信道的数据链路层(局域网)"></span></p><h2 id="33-使用广播信道的数据链路层局域网"><a class="markdownIt-Anchor" href="#33-使用广播信道的数据链路层局域网"></a> 3.3 使用广播信道的数据链路层(局域网)</h2><p><span id="3.3.1 局域网的数据链路层"></span></p><h3 id="331-局域网的数据链路层"><a class="markdownIt-Anchor" href="#331-局域网的数据链路层"></a> 3.3.1 局域网的数据链路层</h3><p>局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>局域网具有如下的一些主要优点：</p><ul><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。<br><img src="/images/javawz/20200427082103326.png" alt="在这里插入图片描述"></li></ul><p>.<br>.<br><strong>媒体共享技术</strong></p><p>静态划分信道</p><ul><li>频分复用</li><li>时分复用</li><li>波分复用</li><li>码分复用</li></ul><p>动态媒体接入控制（多点接入）</p><ul><li>随机接入</li><li>受控接入 ，如多点线路探询(polling)，或轮询。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算网络原理-第三章-数据链路层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算网络原理-第三章-数据链路层&quot;&gt;&lt;/a&gt; 计算网络原理 第三章 数据链路层&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#数据链路层（一）&quot;&gt;数据链路
      
    
    </summary>
    
      <category term="计算机网络原理" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://xiaowuyoucy.github.io/2021/03/29/yyy0002%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://xiaowuyoucy.github.io/2021/03/29/yyy0002正则表达式/</id>
    <published>2021-03-29T08:23:07.000Z</published>
    <updated>2021-03-29T15:08:59.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h1><h3 id="点号应用之简单的数据提取"><a class="markdownIt-Anchor" href="#点号应用之简单的数据提取"></a> 点号应用之简单的数据提取</h3><p>利用点匹配我们想要的数据并提取出来可以匹配任何一个单字符除换行符外</p><p>1个点号只能匹配字符,如123456789abcde… .等,必须为<code>半角</code>的如果想要匹配全半数字,字母，或汉字,就必须要<code>2个点号</code></p><h3 id="星号正则的认识与应用"><a class="markdownIt-Anchor" href="#星号正则的认识与应用"></a> 星号正则的认识与应用</h3><p><code>*</code>星号表示之前的元素出现任意次数或0次</p><p>比如: 4.*8我们来看一下他是什么意思，星号出现在点号的后面，这代表点号有出现也行，没有出现也行:</p><p>打个比方，他可以匹配48、41238、412345678、4012345670123458</p><h3 id="问号和加号的认识与应用"><a class="markdownIt-Anchor" href="#问号和加号的认识与应用"></a> 问号和加号的认识与应用</h3><p><img src="/images/javawz/1617009958851.png" alt="1617009958851"></p><h3 id="连字符和范围描述符的认识与应用"><a class="markdownIt-Anchor" href="#连字符和范围描述符的认识与应用"></a> 连字符和范围描述符的认识与应用</h3><p>在学习&quot;-&quot;连字符前，我们先来认识一个强大的符号: [ ]， 这个[ ]所括的内容，可以不按顺序进行匹配。[] 范围描述符 范围描述符。如: [a-z]表示从a到z之间的任意一个。</p><p>-  连字符</p><p>A一般都与&quot;[]”起使用，只有连字符在字符组内部</p><p>时，并且出现在两个字符之间时，才能表示字符的范围;如果出现在字符组的开头，则只能表示连字符本身</p><p>例如:</p><p>[0-9]匹配任意0到9的数字</p><p>[a-z]匹配所有小写字母</p><p>[A-Z]匹配所有大写字母</p><p>当然，你可以把它们混在一起写成[a-z0-9]、[0-9a-zA-z]的样 子都可以下面我们举2个例子就明白了</p><p>必从一个网页源码中，区分出数字并提取出来</p><h3 id="脱字符和美元符的认识与应用"><a class="markdownIt-Anchor" href="#脱字符和美元符的认识与应用"></a> 脱字符^和美元符$的认识与应用</h3><p><img src="/images/javawz/1617012879072.png" alt="1617012879072"></p><p>排除:<code>[^1-9]匹配除了1到9的数字,其他的都可以匹配</code></p><h3 id="转义符的认识与应用"><a class="markdownIt-Anchor" href="#转义符的认识与应用"></a> 转义符\的认识与应用</h3><p><code>\</code>转义符作用:把正 则的元字符转换成元字符本身</p><p>如果需要匹配的某个字符本身就是元字符(如:<code>.?*+</code>) ，正则表达式将如何处理呢?</p><p>比如:我想要检索互联网的主机名，也就是我们说的网址,如: www.23 .com我们的正则语句要怎么写呢?</p><p>想的快的会员就会说，我直接就用www.23.com来匹配点号可以匹配任何字符包括点号本身，当然， 这样是可以匹配到。</p><p>但是，<a href="http://xn--www123-hh4kv70g1eb.com" target="_blank" rel="noopener">如果有www123.com</a></p><p>www223. com它们同样也会被匹配出来，唯一的解决办法就是把点号用转义符转换成他自身。</p><h3 id="字符组简记法"><a class="markdownIt-Anchor" href="#字符组简记法"></a> 字符组简记法</h3><p><img src="/images/javawz/1617019185120.png" alt="1617019185120"></p><p><img src="/images/javawz/1617019408172.png" alt="1617019408172"></p><h3 id="大括号与选择符的认识与应用"><a class="markdownIt-Anchor" href="#大括号与选择符的认识与应用"></a> 大括号与选择符的认识与应用</h3><p><img src="/images/javawz/1617020477744.png" alt="1617020477744"></p><h3 id="子表达式的认识与应用"><a class="markdownIt-Anchor" href="#子表达式的认识与应用"></a> 子表达式的认识与应用</h3><p><img src="/images/javawz/1617026254233.png" alt="1617026254233"></p><h3 id="贪婪和懒惰的匹配"><a class="markdownIt-Anchor" href="#贪婪和懒惰的匹配"></a> 贪婪和懒惰的匹配</h3><p><img src="/images/javawz/1617028212400.png" alt="1617028212400"></p><table><thead><tr><th>通配符匹配规则：</th></tr></thead><tbody><tr><td>* ：任意数量的字符</td></tr><tr><td>？：任何单个字符</td></tr><tr><td>正则 匹配规则：</td></tr><tr><td>*         前面元素出现0次以上</td></tr><tr><td>.            匹配任何单个字符</td></tr><tr><td>?           前面元素出现0次或1次</td></tr><tr><td>+          前面元素出现1次以上</td></tr><tr><td>^         表示开头。</td></tr><tr><td>$           表示结尾。</td></tr><tr><td>.*           表示0个以上的任意字符。</td></tr><tr><td>[  ]          范围描述符。[a-z]表示从a到z之间的任意一个。</td></tr><tr><td>\w          英文字母和数字。即[0-9 A-Z a-z]。</td></tr><tr><td>\W          非英文字母和数字</td></tr><tr><td>\s          空字符，即[\t\n\r\f]。</td></tr><tr><td>\S          非空字符。</td></tr><tr><td>\d           数字，即[0-9]。</td></tr><tr><td>\D          非数字。</td></tr><tr><td>\b          词边界字符（在范围描述符外部时）</td></tr><tr><td>\B          非词边界字符</td></tr><tr><td>\b         退格符（0x08）（在范围描述符内部时）</td></tr><tr><td>{m,n}        前面元素最少出现m次,最多出现n次</td></tr><tr><td>|           选择</td></tr><tr><td>(  )           群组</td></tr><tr><td>其他字符   该字符本身</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#正则表达式&quot;&gt;&lt;/a&gt; 正则表达式&lt;/h1&gt;
&lt;h3 id=&quot;点号应用之简单的数据提取&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#点号应用之简单的
      
    
    </summary>
    
      <category term="易语言" scheme="https://xiaowuyoucy.github.io/categories/%E6%98%93%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据类型</title>
    <link href="https://xiaowuyoucy.github.io/2021/03/29/yyy0001%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/03/29/yyy0001数据类型/</id>
    <published>2021-03-29T07:07:49.000Z</published>
    <updated>2021-03-29T08:22:32.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1><p>什么是变量的数据类型呢?实际就是指变量内所存储的数据的类型。</p><p>下面我们来讲讲变量内所能存储的基本数据类型。</p><h3 id="1字节型"><a class="markdownIt-Anchor" href="#1字节型"></a> 1.字节型。</h3><p>可容纳0到255之间的数值。</p><h3 id="2短整数型"><a class="markdownIt-Anchor" href="#2短整数型"></a> 2.短整数型。</h3><p>可容纳-32,768到32,767之间的数值，尺寸为2个字节。</p><h3 id="3整数型"><a class="markdownIt-Anchor" href="#3整数型"></a> 3.整数型。</h3><p>可容纳-2,147 ,483,648到2,147,483,647之间的数值，尺寸为4个字节。</p><h3 id="4长整数型"><a class="markdownIt-Anchor" href="#4长整数型"></a> 4.长整数型。</h3><p>可容纳-9,223,372,036,854,775,808到</p><p>9,223,372,036,854,775,807之间的数值，尺寸为8个字节。</p><h3 id="5小数型"><a class="markdownIt-Anchor" href="#5小数型"></a> 5.小数型。</h3><p>可容纳3.4E +/- 38 (7位小数)之间的数值，尺寸为4个字节。</p><h3 id="6双精度小数型"><a class="markdownIt-Anchor" href="#6双精度小数型"></a> 6.双精度小数型。</h3><p>可容纳1.7E +/- 308 (15位小数)之间的数值，尺寸为8个字节。</p><h3 id="7逻辑型"><a class="markdownIt-Anchor" href="#7逻辑型"></a> 7.逻辑型。</h3><p>值只可能为“真&quot;或“假”，尺寸为2个字节。“真&quot;和“假&quot;为系统预定义常量，其对应的英文常量名称为“true&quot;和false&quot;.</p><h3 id="8日期时间型"><a class="markdownIt-Anchor" href="#8日期时间型"></a> 8.日期时间型。</h3><p>用作记录日期及时间，尺寸为8个字节。</p><h3 id="9文本型"><a class="markdownIt-Anchor" href="#9文本型"></a> 9.文本型。</h3><p>用作记录一段文本，文本由以字节0结束的一系列字符组成。</p><h3 id="10字节集"><a class="markdownIt-Anchor" href="#10字节集"></a> 10.字节集。</h3><p>用作记录一段字节型数据。 字节集与字节数组之间可以互相转换，在程序中允许使用字节数组的地方也可以使用字节集，或者相反。字节数组的使用方法，譬如用中括号对(“[]&quot;)加索引数值引用字节成员，使用数组型数值数据进行赋值等等，都可以被字节集所使用。两者之间唯一的不同是字节集可以变长，因此可把字节集看作可变长的字节数组。</p><h3 id="11子程序指针"><a class="markdownIt-Anchor" href="#11子程序指针"></a> 11.子程序指针。</h3><p>用作指向一个子程序，尺寸为4个字节。</p><p>在以上的基本数据类型中，字节型、短整数型、整数型、长整数型、小数型、双精度小数型被统称为“数值型”，它们之间可以任意转换。不过编程需要注意转换可能带来的精度丢失。譬如:将整数257转换为字节后的结果为1，这是因为值257超出了字节型数据的最大上限255,从而产生了溢出。查看变量所可以使用的数据类型，在定义变量中双击类型就可以查看所支持的所有数据类型。</p><h1 id="创建变量"><a class="markdownIt-Anchor" href="#创建变量"></a> 创建变量</h1><h3 id="局部变量"><a class="markdownIt-Anchor" href="#局部变量"></a> 局部变量</h3><p><img src="../../themes/pure/source/images/javawz/1617002258932.png" alt="1617002258932"></p><p>快捷键: <code>ctrl + L</code></p><p>子程序内有效</p><h3 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h3><p><img src="../../themes/pure/source/images/javawz/1617002541052.png" alt="1617002541052"></p><p>快捷键:<code>ctrl +G</code></p><p>整个程序有效</p><h3 id="程序集变量"><a class="markdownIt-Anchor" href="#程序集变量"></a> 程序集变量</h3><p><img src="../../themes/pure/source/images/javawz/1617003138851.png" alt="1617003138851"></p><p>点击程序集1按下<code>回车键</code></p><p>整个程序集有效</p><h5 id="变量可以先使用后声明"><a class="markdownIt-Anchor" href="#变量可以先使用后声明"></a> 变量可以先使用后声明</h5><h3 id="易语言规定用代表日期类型数据"><a class="markdownIt-Anchor" href="#易语言规定用代表日期类型数据"></a> 易语言规定用<code>[]</code>代表日期类型数据</h3><p><code>[年-月-日 时-分-秒]</code></p><p><code>[年:月:日 时:分:秒]</code></p><p>[2020-1-1 11-11-22]</p><p>[2020:1:1 11:11:22]</p><h3 id="静态变量和非静态变量的区别"><a class="markdownIt-Anchor" href="#静态变量和非静态变量的区别"></a> 静态变量和非静态变量的区别</h3><h5 id="静态变量"><a class="markdownIt-Anchor" href="#静态变量"></a> 静态变量</h5><p>经过第一次初始化之后,后面就不用初始化了</p><p>子程序结束,变量不释放</p><h5 id="非静态变量"><a class="markdownIt-Anchor" href="#非静态变量"></a> 非静态变量</h5><p>每次都会初始化</p><p>子程序结束,变量释放</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据类型&quot;&gt;&lt;/a&gt; 数据类型&lt;/h1&gt;
&lt;p&gt;什么是变量的数据类型呢?实际就是指变量内所存储的数据的类型。&lt;/p&gt;
&lt;p&gt;下面我们来讲讲变量内所能存储的基本数据类型。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="易语言" scheme="https://xiaowuyoucy.github.io/categories/%E6%98%93%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>介绍Android系统的发展历史和发行版本</title>
    <link href="https://xiaowuyoucy.github.io/2021/03/29/%E4%BB%8B%E7%BB%8DAndroid%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E5%92%8C%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC/"/>
    <id>https://xiaowuyoucy.github.io/2021/03/29/介绍Android系统的发展历史和发行版本/</id>
    <published>2021-03-28T16:11:26.000Z</published>
    <updated>2021-03-28T16:11:53.533Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="https://xiaowuyoucy.github.io/categories/Android/"/>
    
    
  </entry>
  
</feed>
