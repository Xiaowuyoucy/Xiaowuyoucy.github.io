<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanChen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowuyoucy.github.io/"/>
  <updated>2022-04-27T09:49:35.272Z</updated>
  <id>https://xiaowuyoucy.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法</title>
    <link href="https://xiaowuyoucy.github.io/2022/04/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2022/04/27/排序算法/</id>
    <published>2022-04-27T07:10:54.000Z</published>
    <updated>2022-04-27T09:49:35.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3><h4 id="稳定性"><a class="markdownIt-Anchor" href="#稳定性"></a> 稳定性</h4><p><strong>冒泡排序是一种稳定的排序算法</strong></p><p><strong>选择排序效率：O（n<sup>2</sup>)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************* 排序规则 *********************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">冒泡排序算法的运作如下：（从后往前）</span></span><br><span class="line"><span class="comment">1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span></span><br><span class="line"><span class="comment">2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</span></span><br><span class="line"><span class="comment">3. 针对所有的元素重复以上的步骤，除了最后一个。</span></span><br><span class="line"><span class="comment">4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">稳定性:冒泡排序是一种稳定排序算法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序(升序)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> len)</span><span class="comment">//O(n²)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">// 外层</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j - <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 0: 没有排好, 1: 已经排好</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; flag==<span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;<span class="comment">// 默认已经排好</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = tmp;</span><br><span class="line">flag = <span class="number">0</span>;<span class="comment">// 没有排好</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//定义整型数组</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">11</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">//计算数组长度</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"待排序数组序列: "</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">bubbleSort(<span class="built_in">array</span>, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"冒泡排序之后的序列:"</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h3><h4 id="稳定性-2"><a class="markdownIt-Anchor" href="#稳定性-2"></a> 稳定性</h4><p><strong>选择排序是不稳定的排序方法</strong></p><p><strong>选择排序效率：O（n<sup>2</sup>)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------- 排序规则 --------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">它的工作原理是每一次从待排序的数据元素中选出</span></span><br><span class="line"><span class="comment">最小（或最大）的一个元素，存放在序列的起始位</span></span><br><span class="line"><span class="comment">置，直到全部待排序的数据元素排完。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">稳定性:选择排序是不稳定的排序方法 如:[5,5,3]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序(升序排列)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min = <span class="number">0</span>;<span class="comment">// 指向最小的元素的位置</span></span><br><span class="line"><span class="comment">// 外层循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">min = i;</span><br><span class="line"><span class="comment">// 内存循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[min] &gt; <span class="built_in">array</span>[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 保存最小的元素的位置</span></span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否需要交换</span></span><br><span class="line"><span class="keyword">if</span> (min != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 找到了新的最小值</span></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="keyword">int</span> tmp = <span class="built_in">array</span>[min];</span><br><span class="line"><span class="built_in">array</span>[min] = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="built_in">array</span>[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//定义整型数组</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">12</span>, <span class="number">5</span>, <span class="number">33</span>, <span class="number">6</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">//计算数组长度</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"待排序数组序列: "</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">selectionSort(<span class="built_in">array</span>, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"选择排序之后的序列:"</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************* 排序规则 *******************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">每次处理就是将无序数列的第一个元素与有序数列</span></span><br><span class="line"><span class="comment">的元素从后往前逐个进行比较，找出插入位置，将</span></span><br><span class="line"><span class="comment">该元素插入到有序数列的合适位置中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">稳定性:插入排序是稳定的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序算法(升序排列)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;<span class="comment">// 存储基准数</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">// 坑的位置</span></span><br><span class="line"><span class="comment">// 遍历无序序列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">index = i;</span><br><span class="line">tmp = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="comment">// 遍历有序序列(从后往前)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 基准数根有序序列中的元素比较</span></span><br><span class="line"><span class="keyword">if</span> (tmp &lt; <span class="built_in">array</span>[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 有序序列元素后移</span></span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="comment">// 坑的位置</span></span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 填坑</span></span><br><span class="line"><span class="built_in">array</span>[index] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//定义整型数组</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">12</span>, <span class="number">5</span>, <span class="number">33</span>, <span class="number">6</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">//计算数组长度</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"待排序数组序列: "</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">insertionSort(<span class="built_in">array</span>, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入排序之后的序列:"</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="稳定性-3"><a class="markdownIt-Anchor" href="#稳定性-3"></a> 稳定性</h4><p><strong>插入排序是稳定的排序算法</strong></p><p><strong>插入排序效率：O(n<sup>2</sup>)</strong></p><h3 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h3><h4 id="稳定性-4"><a class="markdownIt-Anchor" href="#稳定性-4"></a> 稳定性</h4><p><strong>希尔排序是不稳定的排序算法。</strong></p><p><strong>希尔排序的效率：O（n*logn）≈ O（1.3*n）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************** 排序规则 ****************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；</span></span><br><span class="line"><span class="comment">随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰</span></span><br><span class="line"><span class="comment">被分成一组，算法便终止。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">稳定性: 希尔排序是非稳定排序算法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*****************************************************************/</span></span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 步长</span></span><br><span class="line"><span class="keyword">int</span> gap = len;</span><br><span class="line"><span class="keyword">while</span> (gap &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 步长递减公式</span></span><br><span class="line">gap = gap / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 分组, 对每一组, 进行插入排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gap; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp;<span class="comment">// 基准数</span></span><br><span class="line"><span class="keyword">int</span> index;<span class="comment">// 坑的位置</span></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="comment">// 无序序列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + gap; j &lt; len; j += gap)</span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="built_in">array</span>[j];</span><br><span class="line">index = j;</span><br><span class="line"><span class="comment">// 有序序列(从后往前遍历)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j - gap; k &gt;= <span class="number">0</span>; k -= gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp &lt; <span class="built_in">array</span>[k])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 后移</span></span><br><span class="line"><span class="built_in">array</span>[k + gap] = <span class="built_in">array</span>[k];</span><br><span class="line"><span class="comment">// 位置</span></span><br><span class="line">index = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 填坑</span></span><br><span class="line"><span class="built_in">array</span>[index] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//定义整型数组</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">12</span>, <span class="number">5</span>, <span class="number">33</span>, <span class="number">6</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">//计算数组长度</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"待排序数组序列: "</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">shellSort(<span class="built_in">array</span>, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"希尔排序之后的序列:"</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3><h4 id="稳定性-5"><a class="markdownIt-Anchor" href="#稳定性-5"></a> 稳定性</h4><p><strong>归并排序是一种稳定的排序算法。</strong></p><p><strong>排序效率： O(N*logN)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个有序数列a[first...mid]和a[mid+1...last]合并。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> mid, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> leftStart = first;<span class="comment">//左有序序列起点</span></span><br><span class="line"><span class="keyword">int</span> leftEnd = mid;<span class="comment">//左有序序列终点</span></span><br><span class="line"><span class="keyword">int</span> rightStart = mid + <span class="number">1</span>;<span class="comment">//右有序序列起点</span></span><br><span class="line"><span class="keyword">int</span> rightEnd = last;<span class="comment">//右有序序列终点</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;<span class="comment">//两个有序序列合并之后的有序序列长度</span></span><br><span class="line"><span class="keyword">int</span> i = leftStart, j = rightStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个有序序列中的元素合并到第三个有序序列中(a的左半部分和右半部分合并到temp中)</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= leftEnd &amp;&amp; j &lt;= rightEnd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//按照从小到大的顺序放入到temp中</span></span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">&#123;</span><br><span class="line">temp[length++] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp[length++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果左半部分还有元素, 直接放到temp中</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= leftEnd)</span><br><span class="line">&#123;</span><br><span class="line">temp[length++] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果右半部分还有元素, 直接放到temp中</span></span><br><span class="line"><span class="keyword">while</span> (j &lt;= rightEnd)</span><br><span class="line">&#123;</span><br><span class="line">temp[length++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将temp中排好的序列拷贝到a数组中</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//只替换已排好序的那一部分</span></span><br><span class="line">a[leftStart + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first &lt; last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到数组的中间位置</span></span><br><span class="line"><span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//左边有序</span></span><br><span class="line">mergeSort(a, first, mid, temp);  </span><br><span class="line"><span class="comment">//右边有序</span></span><br><span class="line">mergeSort(a, mid + <span class="number">1</span>, last, temp); </span><br><span class="line"><span class="comment">//再将二个有序数列合并</span></span><br><span class="line">mergeArray(a, first, mid, last, temp); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//定义整型数组</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">12</span>, <span class="number">5</span>, <span class="number">33</span>, <span class="number">6</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">//计算数组长度</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"待排序数组序列: "</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建合适大小的临时数组</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">mergeSort(<span class="built_in">array</span>, <span class="number">0</span>, len - <span class="number">1</span>, p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"归并排序之后的序列:"</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3><p>将一个数组变成完全二插树</p><p><img src="/images/javawz/image-20220423155542270.png" alt="image-20220423155542270"></p><p>将完全二插树变成大顶堆(每一个父节点数必须大于左右结点数)或小顶堆</p><p>最后一个非叶子结点的位置: 数组长度 / 2  - 1</p><p><img src="/images/javawz/image-20220423160008111.png" alt="image-20220423160008111"></p><p>将第一个结点和最后一个结点交换</p><p><img src="/images/javawz/image-20220423160339867.png" alt="image-20220423160339867"></p><p>再次进行一次大顶堆初始化</p><p><img src="/images/javawz/image-20220423160602459.png" alt="image-20220423160602459"></p><p>将第一个结点和倒数第二个结点交换</p><p><img src="/images/javawz/image-20220423160654345.png" alt="image-20220423160654345"></p><p>再次进行大顶堆初始化</p><p><img src="/images/javawz/image-20220423160827881.png" alt="image-20220423160827881"></p><p>将第一个结点和倒数第三个结点交换</p><p><img src="/images/javawz/image-20220423160936804.png" alt="image-20220423160936804"></p><p>然后进行大顶堆优化</p><p><img src="/images/javawz/image-20220423161648658.png" alt="image-20220423161648658"></p><p>将第一个和倒数第四个交换</p><p><img src="/images/javawz/image-20220423161757724.png" alt="image-20220423161757724"></p><p>再次进行大顶堆优化</p><p><img src="/images/javawz/image-20220423161914987.png" alt="image-20220423161914987"></p><p>将第一个和倒数第五个交换</p><p><img src="/images/javawz/image-20220423162000297.png" alt="image-20220423162000297"></p><p>再次进行大顶堆优化</p><p><img src="/images/javawz/image-20220423162102108.png" alt="image-20220423162102108"></p><p>将第一个和倒数第六个交换</p><p><img src="/images/javawz/image-20220423162159693.png" alt="image-20220423162159693"></p><p>进行大顶堆优化</p><p><img src="/images/javawz/image-20220423170513121.png" alt="image-20220423170513121"></p><p>将第一个和倒数第七个交换</p><p><img src="/images/javawz/image-20220423170550850.png" alt="image-20220423170550850"></p><p>进行大顶堆优化</p><p><img src="/images/javawz/image-20220423170628012.png" alt="image-20220423170628012"></p><p>将第一个和倒数第八个交换</p><p>因为倒数第八个已经是可以交换的最后一个了,所以不需要大顶堆优化了,这是我们的序列已经排好序了</p><p><img src="/images/javawz/image-20220423170700601.png" alt="image-20220423170700601"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> index,<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[index];</span><br><span class="line">arr[index] = arr[max];</span><br><span class="line">arr[max] = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> index,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lchild = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> rchild = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lchild &lt; len &amp;&amp; arr[lchild] &gt; arr[max])</span><br><span class="line">&#123;</span><br><span class="line">max = lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rchild &lt; len &amp;&amp; arr[rchild] &lt; arr[max])</span><br><span class="line">&#123;</span><br><span class="line">max = rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (max != index) &#123;</span><br><span class="line">Swap(arr,index,max);</span><br><span class="line">HeapAdjust(arr,max,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">HeapAdjust(arr,i,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">Swap(arr,<span class="number">0</span>,i);</span><br><span class="line">HeapAdjust(arr, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = rand() % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> start = time(<span class="literal">NULL</span>);</span><br><span class="line">HeapSort(arr,len);</span><br><span class="line">PrintArr(arr,len);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> end = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"time: "</span> &lt;&lt; end - start &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序总结"><a class="markdownIt-Anchor" href="#排序总结"></a> 排序总结</h3><p><img src="/images/javawz/image-20220423121229212.png" alt="image-20220423121229212"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#冒泡排序&quot;&gt;&lt;/a&gt; 冒泡排序&lt;/h3&gt;
&lt;h4 id=&quot;稳定性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#稳定性&quot;&gt;&lt;/a&gt; 稳定性&lt;/h4&gt;
&lt;
      
    
    </summary>
    
      <category term="cpp" scheme="https://xiaowuyoucy.github.io/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树插入查找删除实现</title>
    <link href="https://xiaowuyoucy.github.io/2022/04/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E6%9F%A5%E6%89%BE%E5%88%A0%E9%99%A4%E5%AE%9E%E7%8E%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/04/21/二叉树插入查找删除实现/</id>
    <published>2022-04-21T05:27:04.000Z</published>
    <updated>2022-04-24T04:19:08.928Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2132-插入算法"><a class="markdownIt-Anchor" href="#2132-插入算法"></a> 2.1.3.2 插入算法</h3><ul><li>​插入新节点的过程<ul><li>​若二叉排序树T为空，则为待插入的关键字key申请一个新结点，并令其为根；</li><li>​若二叉排序树T不为空，则将key和根的关键字比较：<ul><li>​若二者相等，则说明树中已有此关键字key，无须插入。</li><li>​若key&lt;T→key，则将key插入根的左子树中。</li><li>​若key&gt;T→key，则将它插入根的右子树中。<br>子树中的插入过程与上述的树中插入过程相同。如此进行下去，直到将key作为一个新的叶结点的关键字插入到二叉排序树中，或者直到发现树中已有此关键字为止。</li></ul></li></ul></li></ul><h3 id="2133-查找算法"><a class="markdownIt-Anchor" href="#2133-查找算法"></a> 2.1.3.3 查找算法</h3><ul><li>​查找步骤<ul><li>若二叉树T为空树,则搜索失败,否则:</li><li>若查找的数x等于T根节点的数据域的值,则查找成功,否则:</li><li>若查找的数x小于T根节点的数据域的值,则搜索左子树,否则:</li><li>查找右子树</li></ul></li></ul><h3 id="2134-删除算法"><a class="markdownIt-Anchor" href="#2134-删除算法"></a> 2.1.3.4 删除算法</h3><ul><li>​删除步骤（分三种情况）<ul><li>若p结点为叶子结点，即该节点左子树PL和右子树PR均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。</li></ul></li><li><img src="/images/javawz/image-20220421133239230.png" alt="image-20220421133239230"></li><li>若p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点f的左子树（当p是左子树）或右子树（当p是右子树）即可，作此修改也不破坏二叉排序树的特性。</li><li><img src="/images/javawz/image-20220421133507075.png" alt="image-20220421133507075"></li><li>若p结点的左子树和右子树均不空。在删去p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整。比较好的做法是，找到p的直接前驱（或直接后继）s，用s来替换结点p，然后再删除结点s。</li><li><img src="/images/javawz/image-20220421133531725.png" alt="image-20220421133531725"></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TREENODE</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line">TREENODE * leftChild;</span><br><span class="line">TREENODE * rightChild;</span><br><span class="line">TREENODE * father;</span><br><span class="line">&#125;TreeNode,*PTreeNode;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertTreeNode</span><span class="params">(PTreeNode * root,<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">PTreeNode p = <span class="keyword">new</span> TreeNode;</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0x00</span>,<span class="keyword">sizeof</span> TreeNode);</span><br><span class="line"></span><br><span class="line">p-&gt;key = key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((*root) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">*root = p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key &lt; (*root)-&gt;key &amp;&amp; (*root)-&gt;leftChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">(*root)-&gt;leftChild = p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (key &gt; (*root)-&gt;key &amp;&amp; (*root)-&gt;rightChild == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*root)-&gt;rightChild = p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key &lt; (*root)-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line">InsertTreeNode(&amp;(*root)-&gt;leftChild,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; (*root)-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line">InsertTreeNode(&amp;(*root)-&gt;rightChild, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"key 是树中的一员"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTree</span><span class="params">(PTreeNode * root, <span class="keyword">int</span> buf[],<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">InsertTreeNode(root,buf[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span><span class="params">(PTreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PrintTree(root-&gt;leftChild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;key &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">PrintTree(root-&gt;rightChild);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteTreeNode</span><span class="params">(PTreeNode * root ,<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((*root) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((*root)-&gt;key == key)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((*root)-&gt;rightChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">PTreeNode p = (*root);</span><br><span class="line"></span><br><span class="line">(*root) = (*root)-&gt;leftChild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((*root)-&gt;leftChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">PTreeNode p = (*root);</span><br><span class="line"></span><br><span class="line">(*root) = (*root)-&gt;rightChild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PTreeNode q = (*root);</span><br><span class="line"></span><br><span class="line">PTreeNode s = (*root)-&gt;leftChild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (s-&gt;rightChild)</span><br><span class="line">&#123;</span><br><span class="line">q = s;</span><br><span class="line">s = s-&gt;rightChild;</span><br><span class="line">&#125;</span><br><span class="line">(*root)-&gt;key = s-&gt;key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((*root) != q)</span><br><span class="line">&#123;</span><br><span class="line">q-&gt;rightChild = s-&gt;leftChild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">q-&gt;leftChild = s-&gt;leftChild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key &lt; (*root)-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line">DeleteTreeNode(&amp;(*root)-&gt;leftChild, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; (*root)-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line">DeleteTreeNode(&amp;(*root)-&gt;rightChild, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function">PTreeNode <span class="title">SearchTree</span><span class="params">(PTreeNode root, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line"><span class="keyword">return</span> SearchTree(root-&gt;leftChild, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (key &gt; root-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> SearchTree(root-&gt;rightChild, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最大值</span></span><br><span class="line"><span class="function">PTreeNode <span class="title">SearchMaxTree</span><span class="params">(PTreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;rightChild == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> SearchMaxTree(root-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最小值</span></span><br><span class="line"><span class="function">PTreeNode <span class="title">SearchMinTree</span><span class="params">(PTreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;leftChild == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> SearchMinTree(root-&gt;leftChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> buff[] = &#123; <span class="number">-2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">55</span>,<span class="number">33</span>,<span class="number">44</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(buff) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">PTreeNode root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">CreateTree(&amp;root, buff, len);</span><br><span class="line"></span><br><span class="line">PrintTree(root);</span><br><span class="line"></span><br><span class="line">InsertTreeNode(&amp;root,<span class="number">-20</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">PrintTree(root);</span><br><span class="line">InsertTreeNode(&amp;root, <span class="number">-10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">PrintTree(root);</span><br><span class="line">InsertTreeNode(&amp;root, <span class="number">-8</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">PrintTree(root);</span><br><span class="line"></span><br><span class="line">DeleteTreeNode(&amp;root, <span class="number">-10</span>);</span><br><span class="line">DeleteTreeNode(&amp;root, <span class="number">-8</span>);</span><br><span class="line">DeleteTreeNode(&amp;root, <span class="number">-20</span>);</span><br><span class="line">DeleteTreeNode(&amp;root, <span class="number">55</span>);</span><br><span class="line">DeleteTreeNode(&amp;root, <span class="number">-2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">PrintTree(root);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; SearchTree(root, <span class="number">33</span>)-&gt;key &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; SearchMinTree(root)-&gt;key &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; SearchMaxTree(root)-&gt;key &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2132-插入算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2132-插入算法&quot;&gt;&lt;/a&gt; 2.1.3.2 插入算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;​	插入新节点的过程
&lt;ul&gt;
&lt;li&gt;​	若二叉排序树T为空，则为待插入的关键字k
      
    
    </summary>
    
      <category term="cpp" scheme="https://xiaowuyoucy.github.io/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>AStar寻路算法</title>
    <link href="https://xiaowuyoucy.github.io/2022/04/18/AStar%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2022/04/18/AStar寻路算法/</id>
    <published>2022-04-17T21:12:11.000Z</published>
    <updated>2022-04-17T21:38:32.183Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javawz/%E6%97%A0%E6%A0%87%E9%A2%98-1650229998726.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROWS 50<span class="comment">// 行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLS 60 <span class="comment">// 列</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZXDJ 10<span class="comment">// 直线代价</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XXDJ 14  <span class="comment">// 斜线代价</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 保存树节点的个数</span></span><br><span class="line"><span class="keyword">int</span> deepNum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 节点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPoint</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> y;<span class="comment">// y坐标</span></span><br><span class="line"><span class="keyword">int</span> x;<span class="comment">// x坐标</span></span><br><span class="line"><span class="keyword">int</span> g;  <span class="comment">// 从起点到当前点的代价</span></span><br><span class="line"><span class="keyword">int</span> h;  <span class="comment">// 从当前点到终点的代价</span></span><br><span class="line"><span class="keyword">int</span> w;  <span class="comment">// 权值</span></span><br><span class="line"><span class="keyword">int</span> f;  <span class="comment">// 总代价</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取F值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">f = g + h + w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 树节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">MyPoint pos; <span class="comment">// 位置</span></span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode *&gt; child;    <span class="comment">// 子结点</span></span><br><span class="line">TreeNode * Parent;  <span class="comment">// 父节点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代表方向</span></span><br><span class="line"><span class="keyword">enum</span> FANXIAN&#123; p_up, p_down, p_left, p_right, p_upleft,p_upright, p_downleft, p_downright&#125;;</span><br><span class="line"><span class="comment">// 地图</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">map</span>[ROWS][COLS] = &#123;</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 标记地图,如果是false代表没有访问过,如果是true代表访问过</span></span><br><span class="line"><span class="keyword">bool</span> isMap[ROWS][COLS] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="comment">// 打印地图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMap</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> m_map[ROWS][COLS])</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROWS; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (m_map[i][j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"- "</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"| "</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">255</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"* "</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取H值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHValue</span><span class="params">(MyPoint cur,MyPoint endPoint)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = ((endPoint.x &gt; cur.x) ? endPoint.x - cur.x : cur.x - endPoint.x);</span><br><span class="line"><span class="keyword">int</span> y = ((endPoint.y &gt; cur.y) ? endPoint.y - cur.y : cur.y - endPoint.y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (x + y) * ZXDJ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否满足入树条件</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsNeedAdd</span><span class="params">(MyPoint cur,<span class="keyword">unsigned</span><span class="keyword">char</span> m_map[ROWS][COLS],<span class="keyword">bool</span> m_isMap[ROWS][COLS] )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断位置是否在地图中</span></span><br><span class="line"><span class="keyword">if</span> (cur.x &lt; <span class="number">0</span> || cur.x &gt;= COLS || cur.y &lt; <span class="number">0</span> || cur.y &gt;= ROWS ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断当前位置是不是障碍点</span></span><br><span class="line"><span class="keyword">if</span> (m_map[cur.y][cur.x] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断当前点有没有被访问过</span></span><br><span class="line"><span class="keyword">if</span> (m_isMap[cur.y][cur.x]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取存放最小F值的结点容器指针</span></span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode *&gt;::<span class="function">iterator <span class="title">GetMinFValue</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode *&gt; &amp; buff)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt;::iterator it = buff.begin();</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt;::iterator min = it;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;it != buff.end();it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*min)-&gt;pos.f &gt; (*it) -&gt;pos.f)</span><br><span class="line">&#123;</span><br><span class="line">min = it;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根节点</span></span><br><span class="line">TreeNode * pRoot;</span><br><span class="line"><span class="comment">// 删除树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTree</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;child.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">DeleteTree(root-&gt;child[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root-&gt;child.clear();</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt;(root-&gt;child).swap(root-&gt;child);</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">deepNum--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放发散的结点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt;buff;</span><br><span class="line"><span class="comment">// 存放当前结点</span></span><br><span class="line">TreeNode * curTreeNode = <span class="keyword">new</span> TreeNode;</span><br><span class="line"><span class="built_in">memset</span>(curTreeNode,<span class="number">0x00</span>,<span class="keyword">sizeof</span> TreeNode);</span><br><span class="line">    </span><br><span class="line">deepNum++;</span><br><span class="line">pRoot = curTreeNode;</span><br><span class="line"></span><br><span class="line">TreeNode * newTreeNode;</span><br><span class="line">    </span><br><span class="line">MyPoint  beginPoint = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;<span class="comment">// 起点</span></span><br><span class="line">MyPoint  endPoint = &#123; ROWS - <span class="number">2</span>,COLS<span class="number">-9</span> &#125;;    <span class="comment">// 终点</span></span><br><span class="line">    <span class="comment">// 设置当前点位置是起点位置</span></span><br><span class="line">curTreeNode-&gt;pos.x = beginPoint.x;</span><br><span class="line">curTreeNode-&gt;pos.y = beginPoint.y;</span><br><span class="line"><span class="comment">// 存放是否找到终点,true代表找到</span></span><br><span class="line"><span class="keyword">bool</span> isFindEnd= <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将起点设置为已经访问过</span></span><br><span class="line">isMap[beginPoint.y][beginPoint.x] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从当前点开始发散</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">// 创建一个新结点用来存放发散出来的点</span></span><br><span class="line">newTreeNode = <span class="keyword">new</span> TreeNode;</span><br><span class="line"><span class="comment">// 使新结点的位置等于当前结点的位置</span></span><br><span class="line">newTreeNode-&gt;pos = curTreeNode-&gt;pos;</span><br><span class="line"><span class="keyword">switch</span> (i)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">// 上</span></span><br><span class="line"><span class="keyword">case</span> p_up:</span><br><span class="line">newTreeNode-&gt;pos.y--;</span><br><span class="line">newTreeNode-&gt;pos.g = ZXDJ;  <span class="comment">// g值是直线代价</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 下</span></span><br><span class="line"><span class="keyword">case</span> p_down:</span><br><span class="line">newTreeNode-&gt;pos.y++;</span><br><span class="line">newTreeNode-&gt;pos.g = ZXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 左</span></span><br><span class="line"><span class="keyword">case</span> p_left:</span><br><span class="line">newTreeNode-&gt;pos.x--;</span><br><span class="line">newTreeNode-&gt;pos.g = ZXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 右</span></span><br><span class="line"><span class="keyword">case</span> p_right:</span><br><span class="line">newTreeNode-&gt;pos.x++;</span><br><span class="line">newTreeNode-&gt;pos.g = ZXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 左上</span></span><br><span class="line"><span class="keyword">case</span> p_upleft:</span><br><span class="line">newTreeNode-&gt;pos.x--;</span><br><span class="line">newTreeNode-&gt;pos.y--;</span><br><span class="line">newTreeNode-&gt;pos.g = XXDJ; <span class="comment">//g值是斜线代价</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 右上</span></span><br><span class="line"><span class="keyword">case</span> p_upright:</span><br><span class="line">newTreeNode-&gt;pos.x++;</span><br><span class="line">newTreeNode-&gt;pos.y--;</span><br><span class="line">newTreeNode-&gt;pos.g = XXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 左下</span></span><br><span class="line"><span class="keyword">case</span> p_downleft:</span><br><span class="line">newTreeNode-&gt;pos.x--;</span><br><span class="line">newTreeNode-&gt;pos.y++;</span><br><span class="line">newTreeNode-&gt;pos.g = XXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 右下</span></span><br><span class="line"><span class="keyword">case</span> p_downright:</span><br><span class="line">newTreeNode-&gt;pos.x++;</span><br><span class="line">newTreeNode-&gt;pos.y++;</span><br><span class="line">newTreeNode-&gt;pos.g = XXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算 新结点的h值</span></span><br><span class="line">newTreeNode-&gt;pos.h = GetHValue(newTreeNode-&gt;pos,endPoint);</span><br><span class="line"><span class="comment">// 计算新结点的f值</span></span><br><span class="line">newTreeNode-&gt;pos.SetF();</span><br><span class="line"><span class="comment">// 判断新结点是否满足入树的条件</span></span><br><span class="line"><span class="keyword">if</span> (IsNeedAdd(newTreeNode-&gt;pos,<span class="built_in">map</span>,isMap)) &#123;</span><br><span class="line"><span class="comment">// 将新结点添加到当前点的子结点中</span></span><br><span class="line">curTreeNode-&gt;child.push_back(newTreeNode);</span><br><span class="line"><span class="comment">// 使新结点中的父节点指针成员指向当前结点</span></span><br><span class="line">newTreeNode-&gt;Parent = curTreeNode;</span><br><span class="line"><span class="comment">// 添加到buff数组中</span></span><br><span class="line">buff.push_back(newTreeNode);</span><br><span class="line"><span class="comment">// 标记新结点已经被访问过</span></span><br><span class="line">isMap[newTreeNode-&gt;pos.y][newTreeNode-&gt;pos.x] = <span class="literal">true</span>;</span><br><span class="line">deepNum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不满足入树条件则删除新结点</span></span><br><span class="line"><span class="keyword">delete</span> newTreeNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 判断buff数组是否为空,如果为空则退出循环</span></span><br><span class="line"><span class="keyword">if</span> (buff.empty()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 获取最小F值的容器位置</span></span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt;::iterator it = GetMinFValue(buff);</span><br><span class="line"><span class="comment">// 使当前点指向最小F值的结点</span></span><br><span class="line">curTreeNode = *it;</span><br><span class="line"><span class="comment">// 删除buff中最小F值的结点</span></span><br><span class="line">buff.erase(it);</span><br><span class="line"><span class="comment">// 判断是否找到终点</span></span><br><span class="line"><span class="keyword">if</span> (curTreeNode-&gt;pos.x == endPoint.x &amp;&amp; curTreeNode-&gt;pos.y == endPoint.y)</span><br><span class="line">&#123;</span><br><span class="line">isFindEnd = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否找到终点</span></span><br><span class="line"><span class="keyword">if</span> (isFindEnd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置起点到终点的路径路线</span></span><br><span class="line"><span class="keyword">while</span> (curTreeNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[curTreeNode-&gt;pos.y][curTreeNode-&gt;pos.x] = <span class="number">255</span>;</span><br><span class="line">curTreeNode = curTreeNode-&gt;Parent;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 打印地图</span></span><br><span class="line">PrintMap(<span class="built_in">map</span>);</span><br><span class="line"><span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="comment">// 删除树</span></span><br><span class="line">DeleteTree(pRoot);</span><br><span class="line"><span class="built_in">cin</span>.get();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javawz/%E6%97%A0%E6%A0%87%E9%A2%98-1650229998726.png&quot; alt&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="cpp" scheme="https://xiaowuyoucy.github.io/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>图(graph)</title>
    <link href="https://xiaowuyoucy.github.io/2022/04/08/%E5%9B%BE-graph/"/>
    <id>https://xiaowuyoucy.github.io/2022/04/08/图-graph/</id>
    <published>2022-04-07T18:03:59.000Z</published>
    <updated>2022-04-15T23:35:12.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的相关概念"><a class="markdownIt-Anchor" href="#图的相关概念"></a> 图的相关概念</h2><h3 id="图的定义和术语"><a class="markdownIt-Anchor" href="#图的定义和术语"></a> 图的定义和术语</h3><p>图的定义：图是由<strong>顶点的有穷非空集合</strong>和<strong>顶点之间的边的集合</strong>组成，通常表示为：G = (V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p><p>图中的元素称为顶点(Vertex)</p><p>顶点必须是有穷的非空集合,因此一个图至少有一个顶点。</p><p>顶点之间的逻辑关系用边(Edge)来表示,边集可以是空的。</p><p><strong>无向边</strong>：若顶点Vi 到Vj 的边没有方向，则称这条边为无向边，用无序偶对<code>（Vi ，Vj）</code>来表示。</p><p><strong>有向边</strong>：若从顶点Vi 到Vj的边有方向，则称这条边为有向边，也称为弧(Arc)。用有序偶对<code>&lt;Vi ，Vj&gt;</code>来表示。<code>Vi</code>称为弧尾(Tail)或初始点，<code>Vj</code>称为弧头(Head)或终端点。</p><p>注意: <code>&lt; Vi ，Vj &gt;</code>和<code>&lt; Vj ，Vi &gt;</code>是两条不同的有向边。<br><strong>无向图</strong>: 如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。</p><p>图例(G1):</p><p><img src="/images/javawz/image-20220408020846032.png" alt="image-20220408020846032"></p><p><strong>有向图</strong>: 如果图中任意顶点之间的边都是有向边，则称该图为有向图。<br>图例(G2):</p><p><img src="/images/javawz/image-20220408020925632.png" alt="image-20220408020925632"></p><p><strong>无向完全图</strong>：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有<code>n(n-1)/2</code>条边。<br>图例(G3)</p><p><img src="/images/javawz/image-20220408021013033.png" alt="image-20220408021013033"></p><p><strong>有向完全图</strong>：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n(n-1)条边。</p><p><img src="/images/javawz/image-20220408021041958.png" alt="image-20220408021041958"></p><p>总结: 图G的顶点数n和边数e的关系<br><strong>（1）若G是无向图，则0≤e≤n(n-1)/2</strong><br>恰有n(n-1)/2条边的无向图称无向完全图(Undireet-ed Complete Graph)<br><strong>（2）若G是有向图，则0≤e≤n(n-1)。</strong><br>恰有n(n-1)条边的有向图称为有向完全图(Directed Complete Graph)。<br>注意：<br>　完全图具有最多的边数。任意一对顶点间均有边相连。<br><strong>稀疏图</strong>: 有很少条边或弧的图。<br><strong>稠密图</strong>: 有很多条边或弧的图。<br><strong>权</strong>: 有时图的边或弧具有与它相关的数,这种与图的边或弧相关的数叫做权。</p><p><img src="/images/javawz/image-20220408025046325.png" alt="image-20220408025046325"></p><p><strong>网</strong>：带权的图通常称为网。<br><strong>度</strong>：顶点的度是指<strong>和该顶点关联的边的数目</strong>。</p><p><strong>无向图的度</strong>：与这个顶点相关联的边的条数，边的数量等于各个顶点度数和的一半。</p><p><strong>有向图的度：</strong></p><ul><li><strong>入度</strong>：有向图中以顶点（v）为头的弧的数目，称为（v）的入度。</li><li><strong>出度</strong>：有向图中以顶点（v）为尾的弧的数目，称为（v）的出度。</li><li><strong>弧的数量=各个顶点出度和 = 各个顶点的入度和</strong></li></ul><p><strong>邻接点</strong>：对于无向图，同一边上的两个顶点称为邻接点。<br><strong>子图</strong>: 假设两个图G=(V,E)和G1=(V1,E1),如果V1⊆V且E1⊆E则G1为G的子图<br><strong>路径的长度</strong>: 路径上的边或弧的数目。</p><p><img src="/images/javawz/image-20220408030319392.png" alt="image-20220408030319392"></p><p>上图中左侧B到D的路径长为2，右侧B到D的路径为3</p><h3 id="连通图相关术语"><a class="markdownIt-Anchor" href="#连通图相关术语"></a> 连通图相关术语</h3><p>在无向图G=(V,E)中，如果从顶点v到顶点w有路径，则称v和w是相通的。**如果对图中任意两个顶点Vi和Vj 属于E，则两个顶点是连通的，则称G是连通图。**如下图1，它的顶点A都顶点B、C、D都是连通的，但显然顶点A与顶点E或F就无路径，因此不能算是连通图。而图2，顶点A、B、C、D相互都是连通的，所以它本身是连通图。</p><p><img src="/images/javawz/image-20220408021246414.png" alt="image-20220408021246414"></p><h4 id="连通图生成树"><a class="markdownIt-Anchor" href="#连通图生成树"></a> 连通图生成树</h4><p>连通图的生成树<strong>是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。</strong><br><strong>极小连通子图是相对于连通图来说的。</strong><br>比如下图的图1是一个普通图，但显然它不是生成树，当去掉两条构成环的边后，比如图2或图3，就满足n个顶点n-1条边且连通的定义了。它们都是一棵生成树。从这里也知道，如果一个图有n个顶点和小于n-1条边，则是非连通图，如果它多于n-1条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。比如图2和图3，随便加哪两顶点的边都将构成环。<strong>不过有n-1条边并不一定是生成树</strong>，比如图4。</p><p><img src="/images/javawz/image-20220408021408335.png" alt="image-20220408021408335"></p><p><img src="/images/javawz/image-20220408021419655.png" alt="image-20220408021419655"></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>图按照<strong>有无方向</strong>分为<strong>无向图</strong>和<strong>有向图</strong>。<br>无向图由<strong>顶点</strong>和<strong>边</strong>构成。<br>有向图由<strong>顶点</strong>和弧构成，弧有<strong>弧头</strong>和<strong>弧尾</strong>之分。<br>图按照<strong>边或弧的多少</strong>分为<strong>稀疏图</strong>和<strong>稠密图</strong>。<br>如果<strong>任意两个顶点之间都存在边</strong>叫<strong>完全图</strong>，有向的叫有向完全图。<br>与顶点相关联的边的条数叫做度，有向图顶点分为入度和出度。<br>图上的边或弧带权则称为网。</p><p>无向图中<strong>连通</strong>且<strong>n个顶点n-1条边</strong>叫生成树。</p><h2 id="12-图的存储结构"><a class="markdownIt-Anchor" href="#12-图的存储结构"></a> 1.2、图的存储结构</h2><p><strong>图</strong>可以用<strong>顺序存储</strong>或链式存储</p><p><strong>顺序存储:邻接矩阵</strong></p><p><strong>链式存储:邻接表</strong></p><h3 id="121邻接矩阵"><a class="markdownIt-Anchor" href="#121邻接矩阵"></a> 1.2.1邻接矩阵</h3><p><img src="/images/javawz/image-20220408041335770.png" alt="image-20220408041335770"></p><p>图的邻接矩阵存储方式是用两个数组来表示图。</p><ul><li>一个一维数组存储图中顶点信息。</li><li>一个二维数组（邻接矩阵）存储图中的边或弧的信息。</li></ul><p>设图G有n个顶点，则邻接矩阵是一个n*n的方阵，定义为：</p><p><img src="/images/javawz/image-20220408021823273.png" alt="image-20220408021823273"></p><p>看一个实例，下图左就是一个<strong>无向图</strong>。</p><p><img src="/images/javawz/image-20220408021856686.png" alt="image-20220408021856686"></p><p>从上面可以看出，<strong>无向图的边数组是一个对称矩阵</strong>。所谓对称矩阵就是n阶矩阵的元满足a<sub>ij</sub> = a<sub>ji</sub>  ，即从矩阵的左上角到右下角的主对角线为轴，右上角的元和左下角相对应的元全都是相等的。<br>从这个矩阵中，很容易知道图中的信息。</p><ul><li><p>（1）<strong>判断任意两顶点是否有边无边；</strong></p></li><li><p>（2）<strong>某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行或（第i列）的元素之和；</strong></p></li><li><p>（3）**求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍，**arc[i][j]为1就是邻接点；</p><p>而有向图讲究入度和出度，顶点v2的入度为2，正好是第i列各数之和。顶点v2的出度为1，即第i行的各数之和。</p></li></ul><p><img src="/images/javawz/image-20220408034350690.png" alt="image-20220408034350690"></p><p>若图G是<strong>网图</strong>，有n个顶点，则邻接矩阵是一个n*n的方阵，定义为：</p><p><img src="/images/javawz/image-20220408034407319.png" alt="image-20220408034407319"></p><p>这里的w<sub>ij</sub>表示(v<sub>i</sub>,v<sub>j</sub>)上的权值。无穷大表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。下面左图就是一个有向网图，下图就是它的邻接矩阵。</p><p><img src="/images/javawz/image-20220408034504461.png" alt="image-20220408034504461"></p><h3 id="创建无向图和有向图代码示例"><a class="markdownIt-Anchor" href="#创建无向图和有向图代码示例"></a> 创建无向图和有向图代码示例</h3><h4 id="无向图"><a class="markdownIt-Anchor" href="#无向图"></a> 无向图</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大的顶点数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertex 50 </span></span><br><span class="line"><span class="comment">//存放顶点名称的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexInfo[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义图的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 顶点数组 - 存储顶点的名字  等价于  vertex[MaxVertex][9]  最多存放MaxVertex个顶点</span></span><br><span class="line">VertexInfo vertex[MaxVertex];</span><br><span class="line"><span class="comment">// 边的数组  二维矩阵</span></span><br><span class="line"><span class="keyword">int</span> edge[MaxVertex][MaxVertex];</span><br><span class="line"><span class="comment">// 顶点的个数</span></span><br><span class="line"><span class="keyword">int</span> vertexNum;</span><br><span class="line"><span class="comment">// 边的条数</span></span><br><span class="line"><span class="keyword">int</span> edgeNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求用户输入的顶点在顶点数组中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocalVertex</span><span class="params">(Graph &amp;g, VertexInfo v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 遍历顶点数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(v, g.vertex[i]) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 找到了,返回元素的下标</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没找到</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建一个图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(Graph &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入图的顶点数和边数: 顶点 边"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入"</span> &lt;&lt; g.vertexNum &lt;&lt; <span class="string">"个顶点的值"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; g.vertex[i]; <span class="comment">//初始化每个顶点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化所有边都不存在</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.vertexNum; ++j)</span><br><span class="line">&#123;</span><br><span class="line">g.edge[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入"</span> &lt;&lt; g.edgeNum &lt;&lt; <span class="string">"条边, 顶点1 顶点2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">VertexInfo v1, v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.edgeNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line"><span class="comment">// 求用户输入的顶点在顶点数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> m = LocalVertex(g, v1); <span class="comment">//获取v1在二维数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> n = LocalVertex(g, v2); <span class="comment">//获取v2在二维数组中的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边对应的二维数组赋值</span></span><br><span class="line">g.edge[m][n] = <span class="number">1</span>;</span><br><span class="line">g.edge[n][m] = <span class="number">1</span>;<span class="comment">// 无向图 对称关系</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印图 - </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintGraph</span><span class="params">(Graph&amp; g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 水平表头</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 垂直的</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.vertexNum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.edge[i][j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Graph graph;</span><br><span class="line">CreateGraph(graph);</span><br><span class="line">PrintGraph(graph);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有向图"><a class="markdownIt-Anchor" href="#有向图"></a> 有向图</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertex 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexInfo[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义图的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 顶点数组 - 存储顶点的名字</span></span><br><span class="line">VertexInfo vertex[MaxVertex];</span><br><span class="line"><span class="comment">// 边的数组</span></span><br><span class="line"><span class="keyword">int</span> edge[MaxVertex][MaxVertex];</span><br><span class="line"><span class="comment">// 顶点的个数</span></span><br><span class="line"><span class="keyword">int</span> vertexNum;</span><br><span class="line"><span class="comment">// 边的条数</span></span><br><span class="line"><span class="keyword">int</span> edgeNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求用户输入的顶点在顶点数组中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocalVertex</span><span class="params">(Graph &amp;g, VertexInfo v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 遍历顶点数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(v, g.vertex[i]) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 找到了,返回元素的下标</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没找到</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建一个图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(Graph &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入图的顶点数和边数: 顶点 边"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入"</span> &lt;&lt; g.vertexNum &lt;&lt; <span class="string">"个顶点的值"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; g.vertex[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化所有边都不存在</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.vertexNum; ++j)</span><br><span class="line">&#123;</span><br><span class="line">g.edge[i][j] = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &lt;B, A&gt;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入"</span> &lt;&lt; g.edgeNum &lt;&lt; <span class="string">"条边, 弧尾 弧头 权重"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">VertexInfo v1, v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.edgeNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;</span><br><span class="line"><span class="comment">// 求用户输入的顶点在顶点数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> m = LocalVertex(g, v1);</span><br><span class="line"><span class="keyword">int</span> n = LocalVertex(g, v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边对应的二维数组赋值</span></span><br><span class="line">g.edge[m][n] = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印图 - </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintGraph</span><span class="params">(Graph&amp; g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 水平表头</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 垂直的</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.vertexNum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g.edge[i][j] == INT_MAX)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"∞"</span> &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.edge[i][j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Graph g;</span><br><span class="line">CreateGraph(g);</span><br><span class="line">PrintGraph(g);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h3><p><img src="/images/javawz/image-20220408220553196.png" alt="image-20220408220553196"></p><p>邻接矩阵是不错的一种图存储结构，但是，对于边数相对顶点较少的图，这种结构存在对存储空间的极大浪费。因此，找到一种数组与链表相结合的存储方法称为邻接表。</p><p>邻接表的存储方式是这样的：<br>（1）图中<strong>顶点用一个一维数组存储</strong>，当然，<strong>顶点也可以用单链表来存储</strong>，<br>不过，数组可以较容易的读取顶点的信息，更加方便。<br>（2）图中<strong>每个顶点vi的所有邻接点构成一个线性表</strong>，由于邻接点的个数不定，所以，用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。<br>数据结构定义:</p><p><img src="/images/javawz/image-20220408220721949.png" alt="image-20220408220721949"></p><p>例如，下图就是一个无向图的邻接表的结构。</p><p><img src="/images/javawz/image-20220408220750174.png" alt="image-20220408220750174"></p><p>从图中可以看出，顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。</p><p>对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可。如下图所示。</p><p><img src="/images/javawz/image-20220408220813779.png" alt="image-20220408220813779"></p><p><img src="/images/javawz/image-20220408220827738.png" alt="image-20220408220827738"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertex 100</span></span><br><span class="line"><span class="comment">// 邻接点的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edgeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 当前顶点在顶点数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> position;</span><br><span class="line"><span class="comment">// 指向后继节点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edgeNode</span>* <span class="title">next</span>;</span></span><br><span class="line"><span class="comment">// 节点相关的信息 - info</span></span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点数组的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 顶点的名字</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">9</span>];</span><br><span class="line"><span class="comment">// 指向临接点结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edgeNode</span>* <span class="title">first</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 邻接表图结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GraphList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 顶点数组</span></span><br><span class="line">Vertex head[MaxVertex];</span><br><span class="line"><span class="comment">// 顶点的个数</span></span><br><span class="line"><span class="keyword">int</span> vertexNum;</span><br><span class="line"><span class="comment">// 边的条数</span></span><br><span class="line"><span class="keyword">int</span> edgeNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取点对应的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocalVertex</span><span class="params">(GraphList&amp;g, <span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, g.head[i].name) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 没找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(GraphList &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入图的顶点数和边数: 顶点 边"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入"</span> &lt;&lt; g.vertexNum &lt;&lt; <span class="string">"个顶点的值"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; g.head[i].name;</span><br><span class="line">g.head[i].first = <span class="literal">NULL</span>;<span class="comment">// 目前没有邻接点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入"</span> &lt;&lt; g.edgeNum &lt;&lt; <span class="string">"条边, 顶点1 顶点2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> v1[<span class="number">9</span>], v2[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.edgeNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line"><span class="comment">// 以M为头结点的链表, n是m的;邻接点</span></span><br><span class="line"><span class="comment">// 求用户输入的顶点在顶点数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> m = LocalVertex(g, v1);</span><br><span class="line"><span class="keyword">int</span> n = LocalVertex(g, v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表中添加邻接点</span></span><br><span class="line">edgeNode* pNew = <span class="keyword">new</span> edgeNode;</span><br><span class="line"><span class="comment">// init pNew</span></span><br><span class="line">pNew-&gt;position = n;<span class="comment">// 当前的节点在顶点数组中的位置</span></span><br><span class="line"><span class="comment">// pNew添加到头结点数组第m个元素 对应的链表中</span></span><br><span class="line"><span class="comment">// 头插法  尾插法需要遍历到尾部 ，麻烦，因此用头插法</span></span><br><span class="line">pNew-&gt;next = g.head[m].first;</span><br><span class="line">g.head[m].first = pNew;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="comment">// 以N为头结点的链表, m是n的;邻接点</span></span><br><span class="line">edgeNode* pNew1 = <span class="keyword">new</span> edgeNode;</span><br><span class="line"><span class="comment">// init pNew1</span></span><br><span class="line">pNew1-&gt;position = m;<span class="comment">// 当前的节点在顶点数组中的位置</span></span><br><span class="line"><span class="comment">// pNew添加到头结点数组第m个元素 对应的链表中</span></span><br><span class="line"><span class="comment">// 头插法</span></span><br><span class="line">pNew1-&gt;next = g.head[n].first;</span><br><span class="line">g.head[n].first = pNew1;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintGraphList</span><span class="params">(GraphList&amp; g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line">edgeNode* pNode = g.head[i].first;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.head[i].name &lt;&lt; <span class="string">": "</span>;</span><br><span class="line"><span class="keyword">while</span> (pNode != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> index = pNode-&gt;position;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.head[index].name &lt;&lt; <span class="string">" ,"</span>;</span><br><span class="line">pNode = pNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GraphList g;</span><br><span class="line">CreateGraph(g);</span><br><span class="line">PrintGraphList(g);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历"></a> 图的遍历</h3><p>图的遍历和树的遍历类似，希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫图的遍历。</p><p>对于图的遍历来说，如何避免因回路陷入死循环，就需要科学地设计遍历方案，通常有两种遍历次序方案：<strong>深度优先遍历</strong>和<strong>广度优先遍历</strong>。</p><h4 id="深度优先遍历dfsdepth-first-search"><a class="markdownIt-Anchor" href="#深度优先遍历dfsdepth-first-search"></a> 深度优先遍历(DFSdepth first search)</h4><p><img src="/images/javawz/image-20220409030209152.png" alt="image-20220409030209152"></p><p><strong>深度优先遍历，也有称为深度优先搜索，简称DFS</strong>。其实，<strong>就像是一棵树的前序遍历</strong>。<br>它从图中某个结点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中的所有顶点都被访问到为止。<br><strong>深度优先搜索是通过栈来实现的。</strong><br>下图中的数字显示了深度优先搜索顶点被访问的顺序</p><p><img src="/images/javawz/image-20220408221013803.png" alt="image-20220408221013803"></p><p>为了实现深度优先搜索，首先选择一个起始顶点并需要遵守三个规则：</p><ul><li>如果可能，访问一个邻接的未访问顶点，标记它，并把它放入栈中。</li><li>当不能执行规则1时，如果栈不空，就从栈中弹出一个顶点。</li><li>如果不能执行规则1和规则2，就完成了整个搜索过程。</li></ul><h4 id="邻接矩阵深度优先遍历"><a class="markdownIt-Anchor" href="#邻接矩阵深度优先遍历"></a> 邻接矩阵深度优先遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph&amp; g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[g.vertexNum];</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line">visited[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从顶点数组中的第一个开始访问</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;<span class="comment">// int - 顶点数组的下标</span></span><br><span class="line">visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">st.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!st.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 遍历所有的顶点, 找邻接点 - 栈顶元素对应的邻接点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 栈顶元素在顶点数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> top = st.top();</span><br><span class="line"><span class="keyword">if</span> (!visited[i] &amp;&amp; g.edge[top][i] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 遍历该顶点</span></span><br><span class="line">visited[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">// 邻接点压栈</span></span><br><span class="line">st.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 栈顶的顶点与其余的顶点组成的边全部判断了一遍</span></span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接表深度优先遍历"><a class="markdownIt-Anchor" href="#邻接表深度优先遍历"></a> 邻接表深度优先遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphList&amp; g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 保证顶点不被重复遍历</span></span><br><span class="line"><span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[g.vertexNum];</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line">visited[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从顶点数组中找一个顶点, 开始遍历 - 0</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;<span class="comment">// int - 顶点在顶点数组中的下标</span></span><br><span class="line">st.push(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line">visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.head[<span class="number">0</span>].name &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当栈为空, 遍历完成</span></span><br><span class="line"><span class="keyword">while</span> (!st.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 顶点在顶点数组中的下标取出来</span></span><br><span class="line"><span class="keyword">int</span> top = st.top();</span><br><span class="line"><span class="comment">// 找下标对应的顶点的邻接点</span></span><br><span class="line">edgeNode* pNode = g.head[top].first;</span><br><span class="line"><span class="keyword">while</span> (pNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果节点被遍历过了</span></span><br><span class="line"><span class="keyword">while</span> (pNode &amp;&amp; visited[pNode-&gt;position])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 指针后移</span></span><br><span class="line">pNode = pNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到了没有被访问的</span></span><br><span class="line"><span class="keyword">if</span> (pNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line">visited[pNode-&gt;position] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.head[pNode-&gt;position].name &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">// 找新的顶点pNode-&gt;position的邻接点</span></span><br><span class="line"><span class="comment">// 链表和链表直接做跳转</span></span><br><span class="line">pNode = g.head[pNode-&gt;position].first;</span><br><span class="line">st.push(pNode-&gt;position);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历bfs-breadth-first-search"><a class="markdownIt-Anchor" href="#广度优先遍历bfs-breadth-first-search"></a> 广度优先遍历(BFS Breadth First Search)</h3><p>广度优先遍历，又称为广度优先搜索，简称BFS。图的广度优先遍历就类<strong>似于树的层序遍历</strong>了。</p><p>在深度优先搜索中，算法表现得好像要尽快地远离起始点似的。相反，在广度优先搜索中，<strong>算法好像要尽可能地靠近起始点。它首先访问起始顶点的所有邻接点，然后再访问较远的区域。它是用队列来实现的。</strong><br>下面图中的数字显示了广度优先搜索顶点被访问的顺序。</p><p><img src="/images/javawz/image-20220409004002534.png" alt="image-20220409004002534"></p><p>实现广度优先搜索，也要遵守三个规则：</p><ul><li>访问下一个未来访问的邻接点，这个顶点必须是当前顶点的邻接点，标记它，并把它插入到队列中。</li><li>如果因为已经没有未访问顶点而不能执行规则1时，那么从队列头取一个顶点，并使其成为当前顶点。</li><li>如果因为队列为空而不能执行规则2，则搜索结束。</li></ul><h4 id="邻接矩阵广度优先遍历"><a class="markdownIt-Anchor" href="#邻接矩阵广度优先遍历"></a> 邻接矩阵广度优先遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph&amp; g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 保证顶点不被重复遍历</span></span><br><span class="line"><span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[g.vertexNum];</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line">visited[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找一个顶点, 开始访问 - 0</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">// 存储顶点的下标</span></span><br><span class="line">visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">q.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果队列为空, 遍历完成</span></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 队头顶点的下标值拿出来</span></span><br><span class="line"><span class="keyword">int</span> front = q.front();</span><br><span class="line"><span class="comment">// 遍历所有的顶点, 找邻接点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果没被访问, 并且两顶点互为邻接点</span></span><br><span class="line"><span class="keyword">if</span> (!visited[i] &amp;&amp; g.edge[front][i] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 访问,并且入队列</span></span><br><span class="line">visited[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有的邻接点都访问完成,出队列</span></span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表广度优先遍历"><a class="markdownIt-Anchor" href="#邻接表广度优先遍历"></a> 邻接表广度优先遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(GraphList&amp; g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 保证顶点不被重复遍历</span></span><br><span class="line"><span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[g.vertexNum];</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line">visited[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从顶点数组中找一个顶点, 开始遍历 - 0</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">// int - 顶点在顶点数组中的下标</span></span><br><span class="line">q.push(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line">visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.head[<span class="number">0</span>].name &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列为空,遍历完成</span></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 取出队头元素值, 顶点在顶点数组中的下标</span></span><br><span class="line"><span class="keyword">int</span> front = q.front();</span><br><span class="line"><span class="comment">// 找队头元素对应的定点的所有的邻接点</span></span><br><span class="line">edgeNode* pNode = g.head[front].first;</span><br><span class="line"><span class="keyword">while</span> (pNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果没有被访问</span></span><br><span class="line"><span class="keyword">if</span> (!visited[pNode-&gt;position])</span><br><span class="line">&#123;</span><br><span class="line">visited[pNode-&gt;position] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.head[pNode-&gt;position].name &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">// 邻接点入队列</span></span><br><span class="line">q.push(pNode-&gt;position);</span><br><span class="line">&#125;</span><br><span class="line">pNode = pNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有的临界点发全部被访问</span></span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迪杰斯特拉dijkstra算法"><a class="markdownIt-Anchor" href="#迪杰斯特拉dijkstra算法"></a> 迪杰斯特拉(Dijkstra)算法</h3><p>visit表示该点是否被访问过</p><p>dist数组存放起点到各个点的距离</p><p><img src="/images/javawz/image-20220414071801628.png" alt="image-20220414071801628"></p><p>以济南为中间结点，济南到武汉的距离为400且小于北京直接到武汉的距离，所以更新dist数组中北京到武汉的距离为400，并将visit数组中的济南点设置为1，代表已访问过</p><p><img src="/images/javawz/image-20220414072024176.png" alt="image-20220414072024176"></p><p>以武汉为中间结点，武汉到北京的距离是400 + 200 等于600，更新dist数组，因为武汉到其他点只有北京一个没有被访问过，所以当更新了武汉到北京的距离之后，visit数组中的武汉点可以设置为1，代表已经访问过。</p><p>最后剩下北京点没有被访问过，因为北京点是目标点，所以visit数组中的北京点可以直接设置为1</p><p><img src="/images/javawz/image-20220414072333490.png" alt="image-20220414072333490"></p><p><img src="/images/javawz/image-20220414072738740.png" alt="image-20220414072738740"></p><p>初始化北京到其他点的距离</p><p><img src="/images/javawz/image-20220414072819782.png" alt="image-20220414072819782"></p><p>选择北京到达其他点最近的点，北京到天津的距离为100，是最近的点，所以选择天津作为中间结点</p><p>天津到郑州的距离为1000,1000小于1200，所以更新dist数组</p><p>天津到济南的距离为400 更新dist数组</p><p><img src="/images/javawz/image-20220414073224878.png" alt="image-20220414073224878"></p><p>将天津设置为已访问的结点</p><p>现在剩下济南，郑州，长沙，海南没有被访问过</p><p><img src="/images/javawz/image-20220414073244767.png" alt="image-20220414073244767"></p><p>选择北京到剩下的结点中最短距离的结点济南作为中间点</p><p>济南到郑州的距离为400 + 400 = 800,  800 &lt; 1000所以更新dist数组</p><p>济南到长沙的距离为400 + 1300 = 1700,更新dist数组</p><p>济南到海南的距离为400 + 1400 = 1800,更新dist数组</p><p><img src="/images/javawz/image-20220414073614721.png" alt="image-20220414073614721"></p><p>将济南结点设置为已访问过的结点</p><p>现在剩下郑州,长沙,海南三个结点没有被访问过.</p><p>选择北京到剩下结点中最短距离的结点作为中间结点</p><p>这里选择郑州作为中间结点</p><p>郑州到长沙的距离为800 + 500 = 1300,1300 &lt; 1700,所以更新dist数组</p><p><img src="/images/javawz/image-20220414073955303.png" alt="image-20220414073955303"></p><p>将郑州设置为已访问过的结点</p><p>选择北京到剩下结点中最短的距离作为中间结点</p><p>这里选择长沙,长沙到海南的距离是1300 + 1500 = 2800 ,2800 &gt; 1800,所以不用更新dist数组</p><p><img src="/images/javawz/image-20220414074324676.png" alt="image-20220414074324676"></p><p>将长沙设置为已访问的结点</p><p>最后剩下海南结点没有被访问</p><p>因为海南结点是最后一个结点,所以直接将海南结点设置为已访问结点即可</p><p><strong>最后dist数组中存放了北京到达其他城市的最短距离</strong></p><p><img src="/images/javawz/image-20220414074546109.png" alt="image-20220414074546109"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义顶点的最大值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertex 50</span></span><br><span class="line"><span class="comment">//定义顶点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexInfo[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//定义一个图的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//一维数组 -- 顶点信息</span></span><br><span class="line">VertexInfo vertex[MaxVertex];</span><br><span class="line"><span class="comment">//二维数组 -- 边或者弧 对应关系 或者 权</span></span><br><span class="line"><span class="keyword">int</span> edge[MaxVertex][MaxVertex];</span><br><span class="line"><span class="comment">//顶点的个数</span></span><br><span class="line"><span class="keyword">int</span> vertexNum;</span><br><span class="line"><span class="comment">//边的条数</span></span><br><span class="line"><span class="keyword">int</span> edgeNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找顶点在一维数组中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">localVertex</span><span class="params">(Graph &amp;g, VertexInfo v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//遍历顶点数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//寻找值与v相等的顶点</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(v, g.vertex[i]) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用邻接矩阵创建图 -- 有向的网图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(Graph &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入图的顶点数和边数(用空格间隔)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入图的"</span> &lt;&lt; g.vertexNum &lt;&lt; <span class="string">"个顶点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//循环输入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//接收顶点的值</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; g.vertex[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化顶点之间的对应关系</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.vertexNum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化为最大值</span></span><br><span class="line">g.edge[i][j] = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义变量</span></span><br><span class="line"><span class="keyword">int</span> w;<span class="comment">//权重</span></span><br><span class="line">VertexInfo v1, v2;<span class="comment">//顶点</span></span><br><span class="line"><span class="comment">//输入边和权重</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"依次输入"</span> &lt;&lt; g.edgeNum &lt;&lt; <span class="string">"条边的 弧尾 弧头  权重"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//循环输入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.edgeNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到v1在一维数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> m = localVertex(g, v1);</span><br><span class="line"><span class="comment">//找到v2在一维数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> n = localVertex(g, v2);</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">g.edge[m][n] = w;</span><br><span class="line"><span class="comment">//如果是无向图</span></span><br><span class="line">g.edge[n][m] = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGraph</span><span class="params">(Graph &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"打印图 -- 邻接矩阵:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.vertexNum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g.edge[i][j] == INT_MAX)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"∞"</span> &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.edge[i][j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个数组,标记节点是否已经被访问</span></span><br><span class="line"><span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[g.vertexNum];</span><br><span class="line"><span class="comment">//数组初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//全部标记为未访问</span></span><br><span class="line">visited[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建栈对象</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="comment">//从数组的第一个顶点开始</span></span><br><span class="line"><span class="comment">//访问第一个顶点</span></span><br><span class="line">visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//打印第一个顶点</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">//下标压栈</span></span><br><span class="line">st.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!st.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//取出顶点</span></span><br><span class="line"><span class="keyword">int</span> top = st.top();</span><br><span class="line"><span class="comment">//顶点的邻接点 -- 没有被访问过</span></span><br><span class="line"><span class="keyword">if</span> (!visited[i] &amp;&amp; g.edge[top][i] &lt; INT_MAX)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line">visited[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">//下标压栈</span></span><br><span class="line">st.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找完一遍,栈顶元素出栈</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= g.vertexNum)</span><br><span class="line">&#123;</span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个数组,标记顶点是否被访问</span></span><br><span class="line"><span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[g.vertexNum];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//false -- 未访问</span></span><br><span class="line">visited[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个队列对象</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="comment">//第一个顶点标记为已访问</span></span><br><span class="line">visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//打印第一个顶点</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">//顶点在数组中的下标,入队列</span></span><br><span class="line">q.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> front = q.front();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//寻找队列中队头的顶点的邻接点</span></span><br><span class="line"><span class="keyword">if</span> (!visited[i] &amp;&amp; g.edge[front][i] &lt; INT_MAX)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//标记为已访问</span></span><br><span class="line">visited[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">//下标入队列</span></span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找完所有的邻接点之后,下标出队列</span></span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] visited;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最短路径</span></span><br><span class="line"><span class="comment">// 迪杰斯特拉(Dijkstra)算法</span></span><br><span class="line"><span class="comment">// path哪一顶点到当前点的距离最近</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstraPath</span><span class="params">(Graph &amp;g, <span class="keyword">int</span> *path, <span class="keyword">int</span> *dist, <span class="keyword">int</span> v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pos = v0;<span class="comment">// 访问的起始顶点</span></span><br><span class="line"><span class="comment">//定义一个数组, 标记顶点是否已经被访问</span></span><br><span class="line"><span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[g.vertexNum];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line">visited[i] = <span class="literal">false</span>;<span class="comment">//顶点未访问</span></span><br><span class="line"><span class="keyword">if</span> (i != v0) <span class="comment">//排除顶点到出发点的计算</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化所有点的最近邻接点都是V0点</span></span><br><span class="line">path[i] = v0;</span><br><span class="line"><span class="comment">// v0到各个顶点的权重</span></span><br><span class="line">dist[i] = g.edge[v0][i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[v0] &lt;&lt; <span class="string">" 到 "</span> &lt;&lt; g.vertex[i]</span><br><span class="line">&lt;&lt; <span class="string">" 距离: dist["</span> &lt;&lt; i &lt;&lt; <span class="string">"]="</span> &lt;&lt; dist[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// path[]数组 - 到当前点的最近的邻接点</span></span><br><span class="line"><span class="comment">// dist[] 数组 - 从出发点到各个点的最短距离</span></span><br><span class="line"><span class="comment">// i == v0没有任何意义, 不存在路径</span></span><br><span class="line">path[i] = <span class="number">-1</span>;</span><br><span class="line">dist[i] = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把v0标记为已访问</span></span><br><span class="line">visited[v0] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line">min = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.vertexNum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 没有被访问, 并且找到了拥有更小权值的边</span></span><br><span class="line"><span class="comment">// path[]数组 - 到当前点的最近的邻接点</span></span><br><span class="line"><span class="comment">// dist[] 数组 - 从出发点到各个点的最短距离</span></span><br><span class="line"><span class="keyword">if</span> (!visited[j] &amp;&amp; min&gt;dist[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//保存最小值</span></span><br><span class="line">min = dist[j];</span><br><span class="line"><span class="comment">//保存位置</span></span><br><span class="line">pos = j;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+++ 顶点更新: pos ="</span> &lt;&lt; pos</span><br><span class="line">&lt;&lt; <span class="string">"顶点为: "</span> &lt;&lt; g.vertex[pos] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pos位置的顶点标记为已访问</span></span><br><span class="line">visited[pos] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dist V0点到各个点的距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.vertexNum; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// g.edge[pos][j] &lt; INT_MAX - 判断pos-&gt;j这条边是存在的</span></span><br><span class="line"><span class="keyword">if</span> (!visited[j] &amp;&amp; dist[pos] + g.edge[pos][j] &lt; dist[j] &amp;&amp; g.edge[pos][j] &lt; INT_MAX)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 更新最短距离</span></span><br><span class="line"><span class="comment">//例如 将j看成E  pos看成B，求出A到E最短路径</span></span><br><span class="line">dist[j] = dist[pos] + g.edge[pos][j];</span><br><span class="line"><span class="comment">//更新路径, 到顶点j最近的顶点是pos</span></span><br><span class="line">path[j] = pos;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"=== 更新最短距离: dist["</span> &lt;&lt; j</span><br><span class="line">&lt;&lt; <span class="string">"] = "</span> &lt;&lt; dist[j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v0 - 起始点</span></span><br><span class="line"><span class="comment">// v  - 到达点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(Graph &amp;g, <span class="keyword">int</span> *path, <span class="keyword">int</span> v0, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个栈对象</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">int</span> temp = v;</span><br><span class="line"><span class="keyword">while</span> (temp != v0)</span><br><span class="line">&#123;</span><br><span class="line">st.push(temp);</span><br><span class="line"><span class="comment">//寻找上一个顶点</span></span><br><span class="line">temp = path[temp];</span><br><span class="line">&#125;</span><br><span class="line">st.push(v0);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印路径</span></span><br><span class="line"><span class="keyword">while</span> (!st.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g.vertex[st.top()] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义一个图的对象</span></span><br><span class="line">Graph g;</span><br><span class="line"><span class="comment">//用邻接矩阵创建图</span></span><br><span class="line">createGraph(g);</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">printGraph(g);</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"深度优先搜索"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">DFS(g);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"广度优先搜索"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BFS(g);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==================================================</span></span><br><span class="line"><span class="comment">==================================================*/</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"迪杰斯特拉(Dijkstra)算法"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// path数组 - 到当前点的最近的邻接点</span></span><br><span class="line"><span class="keyword">int</span> path[<span class="number">50</span>];</span><br><span class="line"><span class="comment">// dist[] 数组 - 从出发点到各个点的最短距离</span></span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">50</span>];</span><br><span class="line"><span class="comment">// 出发点</span></span><br><span class="line"><span class="keyword">int</span> v0 = <span class="number">0</span>;</span><br><span class="line">dijkstraPath(g, path, dist, v0);</span><br><span class="line"><span class="comment">// A-&gt;D怎么走?多么长?</span></span><br><span class="line"><span class="comment">// dist[3] = A-&gt;D的最短距离</span></span><br><span class="line"><span class="comment">// path[3]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; g.vertexNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"路径: "</span>;</span><br><span class="line">showPath(g, path, v0, i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"路径长度: "</span> &lt;&lt; dist[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Keyboard not found, press F1 to continue..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图的相关概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#图的相关概念&quot;&gt;&lt;/a&gt; 图的相关概念&lt;/h2&gt;
&lt;h3 id=&quot;图的定义和术语&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#图的定义和术语&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="cpp" scheme="https://xiaowuyoucy.github.io/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>树和二叉树</title>
    <link href="https://xiaowuyoucy.github.io/2022/04/04/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://xiaowuyoucy.github.io/2022/04/04/树和二叉树/</id>
    <published>2022-04-04T14:07:32.000Z</published>
    <updated>2022-04-24T06:28:26.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树基本概念"><a class="markdownIt-Anchor" href="#树基本概念"></a> 树基本概念</h2><p><img src="/images/javawz/image-20220405195856497.png" alt="image-20220405195856497"></p><p>树的定义：</p><p>由一个或多个(n≥0)结点组成的有限集合T，有且仅有一个结点称为根（root），当n&gt;1时，其余的结点分为<strong>m(m≥0)个互不相交的有限集合</strong>T1,T2，…，Tm。每个集合本身又是棵树，被称作这个根的子树 。</p><ul><li><p>树的结构特点</p><ul><li>非线性结构，有一个直接前驱，但可能有多个直接后继（1:n）</li><li>树的定义具有递归性，树中还有树。</li><li>树可以为空，即节点个数为0。</li></ul></li><li><p>若干术语</p><ul><li>根 -&gt; 即根结点(没有前驱)</li><li>叶子 -&gt; 即终端结点(没有后继)</li><li>森林 -&gt; 指m棵不相交的树的集合(例如删除A后的子树个数)</li><li>有序树 -&gt; 结点各子树从左至右有序，不能互换（左为第一）</li><li>无序树 -&gt; 结点各子树可互换位置。</li><li>双亲 -&gt; 即上层的那个结点(直接前驱) parent</li><li>孩子 -&gt; 即下层结点的子树 (直接后继) child</li><li>兄弟 -&gt; 同一双亲下的同层结点（孩子之间互称兄弟）sibling</li><li>堂兄弟 -&gt; 即双亲位于同一层的结点（但并非同一双亲）cousin</li><li>祖先 -&gt; 即从根到该结点所经分支的所有结点</li><li>子孙 -&gt; 即该结点下层子树中的任一结点</li></ul><p><img src="/images/javawz/image-20220405200058191.png" alt="image-20220405200058191"></p><ul><li>结点 -&gt; 即树的数据元素</li><li>结点的度 -&gt; 结点挂接的子树数（有几个直接后继就是几度）</li><li>结点的层次 -&gt; 从根到该结点的层数（根结点算第一层）</li><li>终端结点 -&gt; 即度为0的结点，即叶子</li><li>分支结点 -&gt; 除树根以外的结点（也称为内部结点）</li><li>树的度 -&gt; 所有结点度中的最大值（Max{各结点的度}）</li><li>树的深度(或高度) -&gt; 指所有结点中最大的层数（Max{各结点的层次}）</li><li>上图中的结点数＝ 13，树的度＝ 3，树的深度＝ 4</li></ul></li></ul><h2 id="树的表示法"><a class="markdownIt-Anchor" href="#树的表示法"></a> 树的表示法</h2><h3 id="图形表示法"><a class="markdownIt-Anchor" href="#图形表示法"></a> 图形表示法</h3><p><strong>事物之间的逻辑关系</strong>可以通过数的形式很直观的表示出来，如下图：</p><p><img src="/images/javawz/image-20220405200248743.png" alt="image-20220405200248743"></p><h3 id="广义表表示法"><a class="markdownIt-Anchor" href="#广义表表示法"></a> 广义表表示法</h3><p><img src="/images/javawz/image-20220405200307911.png" alt="image-20220405200307911"></p><p>用广义表表示法表示上图：</p><p>中国（河北（保定，石家庄），广东（广州，东莞），山东（青岛，济南））</p><p><strong>根作为由子树森林组成的表的名字写在表的左边</strong></p><h3 id="左孩子右兄弟表示法"><a class="markdownIt-Anchor" href="#左孩子右兄弟表示法"></a> 左孩子右兄弟表示法</h3><p><img src="/images/javawz/image-20220405200422721.png" alt="image-20220405200422721"></p><p>左孩子右兄弟表示法可以将一颗多叉树转化为一颗二叉树：</p><p><img src="/images/javawz/image-20220405200439643.png" alt="image-20220405200439643"></p><h2 id="二叉树概念"><a class="markdownIt-Anchor" href="#二叉树概念"></a> 二叉树概念</h2><h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3><ul><li>定义</li></ul><p>n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成 。</p><ul><li>逻辑结构</li></ul><p>一对二（1：2）</p><ul><li><p>基本特征:</p><ul><li>每个结点最多只有两棵子树（<strong>不存在度大于2的结点</strong>）；</li><li>左子树和右子树次序不能颠倒（<strong>有序树</strong>）。</li></ul></li><li><p>基本形态：</p></li></ul><p><img src="/images/javawz/image-20220405200902582.png" alt="image-20220405200902582"></p><ul><li>二叉树性质<ul><li>性质1: 在二叉树的第i层上至多有2<sup>i</sup>&gt;-1个结点（i&gt;0）</li><li>性质2: 深度为k的二叉树至多有2<sup>k</sup>-1个结点（k&gt;0）</li><li>性质3: 对于任何一棵二叉树，若2度的结点数有n2个，则叶子数（n0）必定为n2＋1 （即n0=n2+1）</li></ul></li></ul><p><img src="/images/javawz/wps41A8.tmp.png" alt="img">概念解释：</p><ul><li><strong>满二叉树</strong></li><li>一棵深度为k 且有2<sup>k</sup> -1个结点的二叉树。</li></ul><p>​     <strong>特点：每层都“充满”了结点</strong></p><p><img src="/images/javawz/image-20220405201353966.png" alt="image-20220405201353966"></p><p><strong>完全二叉树</strong></p><p>深度为k 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k 的满二叉树中编号从1至n的结点一一对应。</p><p><img src="/images/javawz/image-20220405201428010.png" alt="image-20220405201428010"></p><p><strong>理解：k-1层与满二叉树完全相同，第k层结点尽力靠左</strong></p><ul><li><p>性质4: 具有n个结点的完全二叉树的深度必为[log<sub>2</sub>n] + 1</p></li><li><p><strong>性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）</strong></p></li></ul><p><img src="/images/javawz/image-20220405201708193.png" alt="image-20220405201708193"></p><p>使用此性质可以使用完全二叉树实现树的顺序存储。</p><p>如果不是完全二叉树咋整???</p><p>------ 将其转换成完全二叉树即可</p><h3 id="二叉树的表示"><a class="markdownIt-Anchor" href="#二叉树的表示"></a> 二叉树的表示</h3><ul><li>二叉链表示法<ul><li>存储结构</li></ul></li></ul><p><img src="/images/javawz/image-20220405201828550.png" alt="image-20220405201828550"></p><p>结点数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">intdata;</span><br><span class="line">struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h4 id="三叉链表表示法"><a class="markdownIt-Anchor" href="#三叉链表表示法"></a> 三叉链表表示法</h4><ul><li><p>存储结构</p><p><img src="/images/javawz/image-20220405202021310.png" alt="image-20220405202021310"></p></li></ul><p>每个节点有三个指针域，其中两个分别指向子节点（左孩子，右孩子），还有一共指针指向该节点的父节点。</p><ul><li>节点数据类型定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//三叉链表</span><br><span class="line">typedef struct TriTNode </span><br><span class="line">&#123;</span><br><span class="line">int data;</span><br><span class="line">//左右孩子指针</span><br><span class="line">struct TriTNode *lchild, *rchild;</span><br><span class="line">struct TriTNode *parent;</span><br><span class="line">&#125;TriTNode, *TriTree;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a class="markdownIt-Anchor" href="#二叉树的遍历"></a> 二叉树的遍历</h3><ul><li>遍历定义</li></ul><p>指按某条搜索路线<strong>遍访每个结点且不重复</strong>（又称周游）。</p><ul><li>遍历用途</li></ul><p>它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。</p><ul><li>遍历方法</li></ul><p>牢记一种约定，<strong>对每个结点的查看都是“先左后右”</strong> 。</p><p>限定先左后右，树的遍历有三种实现方案：</p><p><strong>D</strong>LR         L<strong>D</strong>R         LR<strong>D</strong></p><p><strong>先</strong> (<strong>根</strong>)序遍历    <strong>中</strong> (<strong>根</strong>)序遍历     <strong>后</strong>(<strong>根</strong>)序遍历</p><p><strong>DLR</strong> <strong>— 先序遍历，即先根再左再右</strong></p><p><strong>LDR</strong> <strong>— 中序遍历，即先左再根再右</strong></p><p><strong>LRD</strong> <strong>— 后序遍历，即先左再右再根</strong></p><p><strong>注：“先、中、后”的意思是指访问的结点D是先于子树出现还是后于子树出现。</strong></p><h3 id="树的遍历代码实现"><a class="markdownIt-Anchor" href="#树的遍历代码实现"></a> 树的遍历，代码实现：</h3><h4 id="先序遍历"><a class="markdownIt-Anchor" href="#先序遍历"></a> 先序遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PreOrder(NODE *root )</span><br><span class="line">&#123;  </span><br><span class="line">    if (root) //非空二叉树</span><br><span class="line">    &#123;</span><br><span class="line">printf(“%d”,root-&gt;data); //访问D</span><br><span class="line">PreOrder(root-&gt;lchild); //递归遍历左子树</span><br><span class="line">PreOrder(root-&gt;rchild); //递归遍历右子树</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InOrder(NODE *root)</span><br><span class="line">&#123; </span><br><span class="line">if(root !=NULL)</span><br><span class="line">  &#123;  </span><br><span class="line">InOrder(root-&gt;lchild);</span><br><span class="line">      printf(“%d”,root-&gt;data);</span><br><span class="line">      InOrder(root-&gt;rchild); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PostOrder(NODE *root)</span><br><span class="line">&#123;</span><br><span class="line">if(root !=NULL) </span><br><span class="line">   &#123;</span><br><span class="line">PostOrder(root-&gt;lchild);</span><br><span class="line">        PostOrder(root-&gt;rchild);</span><br><span class="line">        printf(“%d”,root-&gt;data); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树的遍历，本质剖析：</p><p>从前面的三种遍历算法可以知道：如果将printf语句抹去，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//除去printf的遍历算法：</span><br><span class="line">XXX (NODE *root)</span><br><span class="line">&#123;  </span><br><span class="line">if(root) </span><br><span class="line">   &#123;</span><br><span class="line">XXX(root-&gt;lchild);</span><br><span class="line">        XXX(root-&gt;rchild);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从递归的角度看，这三种算法是完全相同的，或者说这三种遍历</strong></p><p><strong>算法的访问路径是相同的，只是访问结点的时机不同。</strong></p><p><img src="/images/javawz/image-20220405202919416.png" alt="image-20220405202919416"></p><p>从虚线的出发点到终点的路径上，每个结点经过3次。</p><p>​从虚线的出发点到终点的路径上，每个结点经过3次。</p><ul><li><strong>第1次经过时访问＝先序遍历</strong></li><li><strong>第2次经过时访问＝中序遍历</strong></li><li><strong>第3次经过时访问＝后序遍历</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BITREENODE</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> data;</span><br><span class="line">BITREENODE * lTreeNode;</span><br><span class="line">BITREENODE * rTreeNode;</span><br><span class="line">&#125;Bitreenode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STACKNODE</span> &#123;</span></span><br><span class="line">Bitreenode * node;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line">&#125;Stacknode;</span><br></pre></td></tr></table></figure><h3 id="计算二叉树中叶子结点的数目"><a class="markdownIt-Anchor" href="#计算二叉树中叶子结点的数目"></a> 计算二叉树中叶子结点的数目</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetTreeNumNode</span><span class="params">(Bitreenode * root,<span class="keyword">int</span> * num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;lTreeNode == <span class="literal">NULL</span> &amp;&amp; root-&gt;rTreeNode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*num)++;</span><br><span class="line">&#125;</span><br><span class="line">GetTreeNumNode(root-&gt;lTreeNode, num);</span><br><span class="line">GetTreeNumNode(root-&gt;rTreeNode, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树的深度"><a class="markdownIt-Anchor" href="#求二叉树的深度"></a> 求二叉树的深度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBitreeHeigth</span><span class="params">(Bitreenode * root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lHeight, rHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">lHeight = GetBitreeHeigth(root-&gt;lTreeNode);</span><br><span class="line">rHeight = GetBitreeHeigth(root-&gt;rTreeNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lHeight &gt; rHeight ? lHeight + <span class="number">1</span> : rHeight + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="copy二叉树"><a class="markdownIt-Anchor" href="#copy二叉树"></a> Copy二叉树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bitreenode * <span class="title">CopyBiTree</span><span class="params">(Bitreenode * root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bitreenode * newNode = (Bitreenode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Bitreenode));</span><br><span class="line">newNode-&gt;data = root-&gt;data;</span><br><span class="line">newNode-&gt;lTreeNode = CopyBiTree(root-&gt;lTreeNode);</span><br><span class="line">newNode-&gt;rTreeNode = CopyBiTree(root-&gt;rTreeNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的非递归遍历"><a class="markdownIt-Anchor" href="#树的非递归遍历"></a> 树的非递归遍历</h3><p>第一步:先将根节点和标识打包在一起组成一个新结点</p><p><img src="/images/javawz/image-20220405204352868.png" alt="image-20220405204352868"></p><p>第二步:把刚刚打包的新结点压入栈</p><p>第三步:循环,如果栈元素大于0则继续循环</p><p>第四步: 取出栈顶元素</p><p>第五步:判断栈顶元素中的树节点是否为NULL,如果是则跳出本次循环</p><p>第六步: 判断标识是否为MYTRUE,如果是则打印当前结点信息,否则如果标识是MYFALSE则将标识改为MYTRUE,然后将本结点的左右两个结点压入栈,最后把自己压入栈中</p><h4 id="入栈顺序"><a class="markdownIt-Anchor" href="#入栈顺序"></a> 入栈顺序</h4><p><img src="/images/javawz/image-20220405210112413.png" alt="image-20220405210112413"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">typedef struct STACKNODE &#123;</span><br><span class="line">Bitreenode * node;</span><br><span class="line">int flag;</span><br><span class="line">&#125;Stacknode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stacknode * NewStackNode(Bitreenode * node,int flag) &#123;</span><br><span class="line"></span><br><span class="line">Stacknode * newNode = (Stacknode *)malloc(sizeof(Stacknode));</span><br><span class="line">newNode-&gt;node = node;</span><br><span class="line">newNode-&gt;flag = MYFLASE;</span><br><span class="line"></span><br><span class="line">return newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void FeiDiGuiBianLi(Bitreenode * root) &#123;</span><br><span class="line">if (root == NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stack&lt;Stacknode *&gt; my_stack;</span><br><span class="line">my_stack.push(NewStackNode(root,MYFLASE));</span><br><span class="line"></span><br><span class="line">while (my_stack.size() &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">Stacknode * node = my_stack.top();</span><br><span class="line">my_stack.pop();</span><br><span class="line">if (node-&gt;node == NULL)</span><br><span class="line">&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (node-&gt;flag == MYTRUE)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; node-&gt;node-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">node-&gt;flag = MYTRUE;</span><br><span class="line">my_stack.push(node);</span><br><span class="line">my_stack.push(NewStackNode(node-&gt;node-&gt;rTreeNode,MYFLASE));</span><br><span class="line">my_stack.push(NewStackNode(node-&gt;node-&gt;lTreeNode, MYFLASE));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的创建"><a class="markdownIt-Anchor" href="#二叉树的创建"></a> 二叉树的创建</h3><p>如何才能确定一棵树？</p><p>结论：</p><p><strong>通过中序遍历和先序遍历可以确定一个树</strong></p><p>通过中序遍历和后续遍历可以确定一个树</p><p>通过先序遍历和后序遍历确定不了一个树。</p><p><strong>单独先序遍历：能求解根，但不能求解左子树什么时候结束、右子树什么时候开始。</strong></p><h3 id="号法创建树"><a class="markdownIt-Anchor" href="#号法创建树"></a> #号法创建树</h3><p>1、什么是#号法创建树</p><p>#创建树，让树的每一个节点都变成度数为2的树</p><p>先序遍历结果: 124###3##</p><p><img src="/images/javawz/image-20220405210423895.png" alt="image-20220405210423895"></p><p>#号法编程实践</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Bitreenode * CreateBiTree2()</span><br><span class="line">&#123;</span><br><span class="line">Bitreenode * T;</span><br><span class="line">char ch;</span><br><span class="line">char a;</span><br><span class="line">scanf(&quot;%c&quot;,&amp;ch);</span><br><span class="line">while (( a = getchar()) != &apos;\n&apos;);</span><br><span class="line">if (ch ==&apos;#&apos;) &#123;</span><br><span class="line">T = NULL;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">T = (Bitreenode *)malloc(sizeof(Bitreenode));</span><br><span class="line">T-&gt;data = ch;</span><br><span class="line">T-&gt;lTreeNode = CreateBiTree2();</span><br><span class="line">T-&gt;rTreeNode = CreateBiTree2();</span><br><span class="line">&#125;</span><br><span class="line">return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放树"><a class="markdownIt-Anchor" href="#释放树"></a> 释放树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void FreeBiTree(Bitreenode * root)</span><br><span class="line">&#123;</span><br><span class="line">if (root == NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FreeBiTree(root-&gt;lTreeNode);</span><br><span class="line">FreeBiTree(root-&gt;rTreeNode);</span><br><span class="line">free(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;树基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#树基本概念&quot;&gt;&lt;/a&gt; 树基本概念&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/image-20220405195856497.png&quot; alt=&quot;imag
      
    
    </summary>
    
      <category term="cpp" scheme="https://xiaowuyoucy.github.io/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>define中的特殊符号</title>
    <link href="https://xiaowuyoucy.github.io/2022/03/27/define%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"/>
    <id>https://xiaowuyoucy.github.io/2022/03/27/define中的特殊符号/</id>
    <published>2022-03-27T01:45:50.000Z</published>
    <updated>2022-03-27T04:26:18.975Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 符号&quot;\&quot;</strong><br>用于多行定义,每行的最后加上&quot;\&quot;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b)  \</span></span><br><span class="line">  <span class="keyword">if</span>(a&gt;b)\</span><br><span class="line">  <span class="keyword">return</span> a;\</span><br><span class="line">  <span class="keyword">else</span>\</span><br><span class="line">  <span class="keyword">return</span> b;</span><br></pre></td></tr></table></figure><p><strong>2.符号&quot;#“和”##&quot;</strong><br>#是把参数<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">字符串</a>化, ##是连接两个参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namesapce <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A(x) x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B(x) #x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C(x,y) x##y</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; A(<span class="string">"hello"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;B(hello)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;C(<span class="string">"hello"</span>,<span class="string">"world"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><h3 id="字符化操作符"><a class="markdownIt-Anchor" href="#字符化操作符"></a> #@ 字符化操作符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ToChar(x) #@x</span><br></pre></td></tr></table></figure><p><code>#@x</code>只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。作用是将传的单字符参数名转换成字符，以一对单引用括起来其实就是给x加上单引号，结果返回是一个<code>const char</code>。<br>举例说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a = ToChar(1);</span><br><span class="line">     ==&gt; char a=&apos;1&apos;;</span><br></pre></td></tr></table></figure><p>做个越界试验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a = ToChar(123);</span><br><span class="line">     ==&gt; char a=&apos;3&apos;;</span><br></pre></td></tr></table></figure><p>但是如果你的参数超过四个字符，编译器就给给你报错了！<code>error C2015: too many characters in constant</code> ：P</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1. 符号&amp;quot;\&amp;quot;&lt;/strong&gt;&lt;br&gt;
用于多行定义,每行的最后加上&amp;quot;\&amp;quot;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="cpp" scheme="https://xiaowuyoucy.github.io/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>libevent</title>
    <link href="https://xiaowuyoucy.github.io/2022/03/15/libevent/"/>
    <id>https://xiaowuyoucy.github.io/2022/03/15/libevent/</id>
    <published>2022-03-15T14:39:06.000Z</published>
    <updated>2022-03-27T04:27:44.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a class="markdownIt-Anchor" href="#学习目标"></a> <strong>学习目标</strong></h2><ul><li>描述什么是libevent并掌握如何安装</li><li>掌握event_base的作用和使用方法</li><li>熟练掌握libevent库中的事件循环</li><li>掌握event事件的使用方法</li><li>掌握bufferevent的工作方式</li><li>掌握使用libevent实现tcp服务器端流程</li><li>掌握使用Libevent实现tcp客户端流程</li></ul><h2 id="libevent介绍"><a class="markdownIt-Anchor" href="#libevent介绍"></a> libevent介绍</h2><p>1 事件驱动, 高性能, 轻量级, 专注于网络</p><p>2 源代码精炼, 易读</p><p>3 跨平台</p><p>4 支持多种I/O多路复用技术, 如epoll select poll等</p><p>5 支持I/O和信号等事件</p><h2 id="libevent的安装"><a class="markdownIt-Anchor" href="#libevent的安装"></a> <strong>libevent的安装</strong></h2><p>登录官方网站: <a href="http://libevent.org/" target="_blank" rel="noopener">http://libevent.org</a>, 查看相关信息</p><p>libevent源码下载主要分2个大版本：</p><ul><li><p>1.4.x 系列, 较为早期版本, 适合源码学习</p></li><li><p>2.x系列, 较新的版本, 代码量比1.4版本多很多, 功能也更完善。</p></li></ul><p>libevent的核心实现:</p><p>在linux上, 其实质就是epoll反应堆.</p><p>libevent是事件驱动, epoll反应堆也是事件驱动, 当要监测的事件发生的时候, 就会调用事件对应的回调函数, 执行相应操作. 特别提醒: 事件回调函数是由用户开发的, 但是不是由用户显示去调用的, 而是由libevent去调用的.</p><p>从官网<a href="http://libevent.org/" target="_blank" rel="noopener">http://libevent.org</a>上下载安装文件之后, 将安装文件上传到linux系统上;源码包的安装,以2.0.22版本为例,在官网可以下载到源码包libevent-2.0.22-stable.tar.gz, 安装步骤与第三方库源码包安装方式基本一致。</p><p>第一步: 解压libevent-2.0.22-stable.tar.gz</p><ul><li>解压: tar -zxvf libevent-2.0.22-stable.tar.gz</li><li>cd到libevent-2.0.22-stable目录下, 查看README文件, 该文件里描述了安装的详细步骤, 可参照这个文件进行安装.</li></ul><p>第二步: 进入源码目录:</p><ul><li>执行配置./configure, 检测安装环境, 生成</li><li>执行./configure的时候也可以指定路径,<code>./configure --prefix=/usr/xxxxx</code>,  这样就可以安装到指定的目录下, 但是这样在进行源代码编译的时候需要指定用-I头文件的路径和用-L库文件的路径.  若默认安装不指定–prefix, 则会安装到系统默认的路径下, 编译的时候可以不指定头文件和库文件所在的路径.</li><li>执行make命令编译整个项目文件.<ul><li>通过执行make命令, 会生成一些库文件(动态库和静态库)和可执行文件.</li></ul></li><li>执行sudo make install进行安装</li><li>安装需要root用户权限, 这一步需要输入当前用户的密码</li><li>执行这一步, 可以将刚刚编译成的库文件和可执行文件以及一些头文件拷贝到/usr/local目录下:</li></ul><p>----头文件拷贝到了<code>/usr/local/include</code>目录下;</p><p>----库文件拷贝到了<code>/usr/local/lib</code>目录下.</p><h2 id="libevent库的使用"><a class="markdownIt-Anchor" href="#libevent库的使用"></a> libevent库的使用</h2><p>进入到libevent-2.0.22-stable/sample下, 可以查看一些示例源代码文件.</p><p>使用libevent库编写代码在编译程序的时候需要指定库名:<code>-levent</code>;</p><p>安装文件的libevent库文件所在路径:libevent-2.0.22-stable/.libs;</p><p>编写代码的时候用到event.h头文件, 或者直接参考sample目录下的源代码文件也可以.</p><p><code>#include &lt;event2/event.h&gt;</code></p><p>编译源代码文件(以hello-world.c文件为例)</p><p><code>gcc hello-world.c -levent</code></p><p>由于安装的时候已经将头文件和库文件拷贝到了系统头文件所在路径/usr/local/include和系统库文件所在路径/usr/local/lib, 所以这里编译的时候可以不用指定<code>-I</code>和<code>-L</code></p><p>编译示例代码hello-world.c程序:</p><p><code>gcc -o hello-world hello-world.c -levent</code></p><p>测试: 在另一个终端窗口进行测试, 输入: nc 127.1 9995, 然后回车立刻显示Hello, World!字符串.</p><h2 id="libevent的使用"><a class="markdownIt-Anchor" href="#libevent的使用"></a> libevent的使用</h2><h3 id="libevent的地基-event_base"><a class="markdownIt-Anchor" href="#libevent的地基-event_base"></a> libevent的地基-event_base</h3><p>使用libevent 函数之前需要分配一个或者多个 event_base 结构体,  每个event_base结构体持有一个事件集合, 可以检测以确定哪个事件是激活的, event_base结构相当于epoll红黑树的树根节点,  每个event_base都有一种用于检测某种事件已经就绪的 “方法”(回调函数)</p><p>通常情况下可以通过event_base_new函数获得event_base结构。</p><p>下面介绍一些常用函数:</p><p>相关函数说明:</p><p>1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct event_base *event_base_new(void);  //event.h的L:337</span><br></pre></td></tr></table></figure><p>函数说明: 获得event_base结构</p><p>参数说明: 无</p><p>返回值:</p><p>成功返回event_base结构体指针;</p><p>失败返回NULL;</p><p>2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void event_base_free(struct event_base *);  //event.h的L:561</span><br></pre></td></tr></table></figure><p>函数说明: 释放event_base指针</p><p>3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_reinit(struct event_base *base); //event.h的L:349</span><br></pre></td></tr></table></figure><p>函数说明: 如果有子进程, 且子进程也要使用base, 则子进程需要对event_base重新初始化, 此时需要调用event_reinit函数.</p><p>函数参数: 由event_base_new返回的执行event_base结构的指针</p><p>返回值: 成功返回0, 失败返回-1</p><p>对于不同系统而言, event_base就是调用不同的多路IO接口去判断事件是否已经被激活, 对于linux系统而言, 核心调用的就是epoll, 同时支持poll和select.</p><p>查看libevent支持的后端的方法有哪些:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char **event_get_supported_methods(void);</span><br></pre></td></tr></table></figure><p>函数说明: 获得当前系统(或者称为平台)支持的方法有哪些</p><p>参数: 无</p><p>返回值: 返回二维数组, 类似与main函数的第二个参数<code>**argv</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char * event_base_get_method(const struct event_base *base);</span><br></pre></td></tr></table></figure><p>函数说明: 获得当前base节点使用的多路io方法</p><p>函数参数: event_base结构的base指针.</p><p>返回值: 获得当前base节点使用的多路io方法的指针</p><p>编写代码获得当前系统支持的多路IO方法和当前所使用的方法:</p><p>相关的代码片段如下:</p><h3 id="等待事件产生-循环等待event_loop"><a class="markdownIt-Anchor" href="#等待事件产生-循环等待event_loop"></a> 等待事件产生-循环等待event_loop</h3><p>libevent在地基打好之后, 需要等待事件的产生, 也就是等待事件被激活, 所以程序不能退出, 对于epoll来说, 我们需要自己控制循环, 而在libevent中也给我们提供了API接口, 类似where(1)的功能.</p><p>函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_base_loop(struct event_base *base, int flags);  //event.h的L:660</span><br></pre></td></tr></table></figure><p>函数说明: 进入循环等待事件</p><p>参数说明:</p><ul><li>base: 由event_base_new函数返回的指向event_base结构的指针</li><li>flags的取值：</li><li>#define EVLOOP_ONCE 0x01</li></ul><p>只触发一次, 如果事件没有被触发, 阻塞等待</p><ul><li>#define EVLOOP_NONBLOCK 0x02</li></ul><p>非阻塞方式检测事件是否被触发, 不管事件触发与否, 都会 立即返回.</p><p>这个函数一般不用, 而大多数都调用libevent给我们提供的另外一个API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_base_dispatch(struct event_base *base);  //event.h的L:364</span><br></pre></td></tr></table></figure><p>函数说明: 进入循环等待事件</p><p>参数说明:由event_base_new函数返回的指向event_base结构的指针</p><p>调用该函数, 相当于没有设置标志位的event_base_loop。程序将会一直运行, 直到没有需要检测的事件了, 或者被结束循环的API终止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int event_base_loopexit(struct event_base *base, const struct timeval *tv);</span><br><span class="line"></span><br><span class="line">int event_base_loopbreak(struct event_base *base);</span><br><span class="line"></span><br><span class="line">struct timeval &#123;</span><br><span class="line"></span><br><span class="line">long   tv_sec;           </span><br><span class="line"></span><br><span class="line">long   tv_usec;       </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两个函数的区别是如果正在执行激活事件的回调函数, 那么event_base_loopexit将在事件回调执行结束后终止循环（如果tv时间非NULL, 那么将等待tv设置的时间后立即结束循环）, 而event_base_loopbreak会立即终止循环。</p><h3 id="使用libevent库的步骤"><a class="markdownIt-Anchor" href="#使用libevent库的步骤"></a> 使用libevent库的步骤：</h3><p>1 创建根节点–event_base_new</p><p>2 设置监听事件和数据可读可写的事件的回调函数</p><p>设置了事件对应的回调函数以后, 当事件产生的时候会自动调用回调函数</p><p>3 事件循环–event_base_dispatch</p><p>相当于while(1), 在循环内部等待事件的发生,  若有事件发生则会触发事件对应的回调函数。</p><p>4 释放根节点–event_base_free</p><p>释放由event_base_new和event_new创建的资源, 分别调用event_base_free</p><p>和event_free函数.</p><h3 id="事件驱动-event"><a class="markdownIt-Anchor" href="#事件驱动-event"></a> 事件驱动-event</h3><p>事件驱动实际上是libevent的核心思想, 本小节主要介绍基本的事件event。</p><p>主要的状态转化：</p><p>主要几个状态：</p><p>无效的指针: 此时仅仅是定义了 struct event *ptr；</p><p>非未决：相当于创建了事件, 但是事件还没有处于被监听状态, 类似于我们使用epoll的时候定义了struct epoll_event ev并且对ev的两个字段进行了赋值, 但是此时尚未调用epoll_ctl对事件上树.</p><p>未决：就是对事件开始监听, 暂时未有事件产生。相当于调用epoll_ctl对要监听的事件上树, 但是没有事件产生.</p><p>激活：代表监听的事件已经产生, 这时需要处理, 相当于调用epoll_wait函数有返回, 当事件被激活以后,  libevent会调用该事件对应的回调函数.</p><p>libevent的事件驱动对应的结构体为struct event, 对应的函数在图上也比较清晰, 下面介绍一下主要的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct event *event_new(struct event_base *base, evutil_socket_t fd, short events, event_callback_fn cb, void *arg);</span><br></pre></td></tr></table></figure><p>函数说明: event_new负责创建event结构指针, 同时指定对应的地基base,  还有对应的文件描述符, 事件, 以及回调函数和回调函数的参数。</p><p>参数说明：</p><p>base: 对应的根节点–地基</p><p>fd: 要监听的文件描述符</p><p>events:要监听的事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define  EV_TIMEOUT   0x01  //超时事件</span><br><span class="line"></span><br><span class="line">#define  EV_READ    0x02   //读事件</span><br><span class="line"></span><br><span class="line">#define  EV_WRITE    0x04   //写事件</span><br><span class="line"></span><br><span class="line">#define  EV_SIGNAL   0x08   //信号事件</span><br><span class="line"></span><br><span class="line">#define  EV_PERSIST   0x10   //周期性触发</span><br><span class="line"></span><br><span class="line">#define  EV_ET     0x20   //边缘触发, 如果底层模型支持设置  则有效, 若不支持则无效.</span><br><span class="line"></span><br><span class="line">若要想设置持续的读事件则： EV_READ | EV_PERSIST</span><br></pre></td></tr></table></figure><p>cb 回调函数, 原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);</span><br></pre></td></tr></table></figure><p>注意: 回调函数的参数就对应于event_new函数的fd, event和arg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define evsignal_new(b, x, cb, arg)       \                                   </span><br><span class="line">   event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_add(struct event *ev, const struct timeval *timeout);</span><br></pre></td></tr></table></figure><p>函数说明: 将非未决态事件转为未决态, 相当于调用epoll_ctl函数(EPOLL_CTL_ADD), 开始监听事件是否产生, 相当于epoll的上树操作.</p><p>参数说明：</p><p>ev: 调用event_new创建的事件</p><p>timeout: 限时等待事件的产生, 也可以设置为NULL, 没有限时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_del(struct event *ev);</span><br></pre></td></tr></table></figure><p>函数说明: 将事件从未决态变为非未决态, 相当于epoll的下树（epoll_ctl调用 EPOLL_CTL_DEL操作）操作。</p><p>参数说明: ev指的是由event_new创建的事件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void event_free(struct event *ev);</span><br></pre></td></tr></table></figure><p>函数说明: 释放由event_new申请的event节点。</p><h2 id="编写一个基于event实现的tcp服务器"><a class="markdownIt-Anchor" href="#编写一个基于event实现的tcp服务器"></a> 编写一个基于event实现的tcp服务器：</h2><p>总体步骤：</p><p>1 搭建服务器的固定三步：</p><ul><li>创建socket</li><li>绑定bind</li><li>监听listen</li></ul><p>2 调用event_base_new函数创建event_base节点</p><p>3 创建要监听的事件event, 主要就是监听事件和读数据的事件</p><p>​     --设置好监听事件的回调函数,然后event_add上树----&gt;有新的连接, 则  调用accept接受新的连接----&gt;将这个新的连接设置好回调函数(一般 是设置读事件), 然后继续event_add上树,  若有客户端关闭连接则 从树上摘除该事件节点.</p><p>4 调用event_base_dispatch进入循环等待事件的发生</p><p>5 释放资源</p><p>调用event_base_free释放根节点和调用event_free释放事件节点</p><p>测试代码:</p><p>程序名称: 02_server.c</p><p>测试过程:</p><p>编译源代码: gcc -o 02_server 02_server.c -levent</p><p>启动程序: ./02_server</p><p>在其他终端窗口上使用nc命令进行测试: nc 127.1 8888, 多开几个终端窗口使用nc命令进行测试.</p><p>发现问题:</p><p>当使用多个客户端(nc命令模拟客户端程序)进行测试的时候, 特别是当关闭所有客户端程序的时候, 若再次开启nc命令, 会发现异常.</p><p>分析原因:</p><p>在02_server.c代码中,L:11处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct event *readev = NULL;</span><br></pre></td></tr></table></figure><p>是一个全局变量,  当有多个客户端请求服务的时候, 如2个客户端请求服务的时候, 第二次readev的值会将第一次readev的值覆盖掉:  代码L:55处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readev = event_new(base, cfd, EV_READ | EV_PERSIST, readcb,  base);</span><br></pre></td></tr></table></figure><p>可以进行如下的测试重现异常情况: 先后在终端A和B上执行<code>nc 127.1 8888</code>命令, 然后ctrl+c结束掉终端A上的nc命令, 再次进如到终端B上, 则会出现异常情况.(原因是由于readev是一个全局变量, 所以readev只能保留最后一次所赋的值, 当客户端退出后, 服务端会调用event_del(readev);从根节点上摘除该事件, 此时其实从base节点上摘掉的是最后一个event事件节点,  所以最后一个客户端会出现异常, 其实只要是开启了多个客户端, 而且关闭客户端的时候只要不是关闭最后一个客户端, 都会出现这种异常情况)</p><p>若先结束终端B上的nc命令, 不会出现异常情况.</p><p>解决办法: 可以将对应事件的文件描述符和事件做一个映射, 说的通俗一点就是可以将fd和event定义在一个结构体当中, 然后定义一个结构体数组, 这样可以使fd和event形成一个一对一的映射关系, 通过fd就可以找到event.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct event_fd</span><br><span class="line">&#123;</span><br><span class="line">   evutil_socket_t fd;</span><br><span class="line"></span><br><span class="line">   struct event *ev;</span><br><span class="line"></span><br><span class="line">&#125;event[MAX];</span><br></pre></td></tr></table></figure><p>详情见代码部分. 02_server_adv.c, 结合代码进行理解.</p><h2 id="自带buffer的事件-bufferevent"><a class="markdownIt-Anchor" href="#自带buffer的事件-bufferevent"></a> 自带buffer的事件-bufferevent</h2><p>bufferevent实际上也是一个event, 只不过比普通的event高级一些, 它的内部有两个缓冲区,  以及一个文件描述符（网络套接字）。一个网络套接字有读和写两个缓冲区, bufferevent同样也带有两个缓冲区,  还有就是libevent事件驱动的核心回调函数, 那么四个缓冲区以及触发回调的关系如下：</p><p>从图中可以得知, 一个bufferevent对应两个缓冲区, 三个回调函数, 分别是写回调, 读回调和事件回调.</p><p>bufferevent有三个回调函数：</p><p>读回调 – 当bufferevent将底层读缓冲区的数据读到自身的读缓冲区时触发读事件回调.</p><p>写回调 – 当bufferevent将自身写缓冲的数据写到底层写缓冲区的时候触发写事件回调, 由于数据最终是写入了内核的写缓冲区中, 应用程序已经无法控制, 这个事件对于应用程序来说基本没什么用, 只是通知功能.</p><p>事件回调 – 当bufferevent绑定的socket连接, 断开或者异常的时候触发事件回调.</p><p>主要使用的函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options);</span><br></pre></td></tr></table></figure><p>函数说明: bufferevent_socket_new 对已经存在socket创建bufferevent事件, 可用于后面讲到的连接监听器的回调函数中.</p><p>参数说明：</p><p>base :对应根节点</p><p>fd  :文件描述符</p><p>options : bufferevent的选项</p><p>BEV_OPT_CLOSE_ON_FREE – 释放bufferevent自动关闭底层接口(当bufferevent被释放以后, 文件描述符也随之被close)</p><p>BEV_OPT_THREADSAFE  – 使bufferevent能够在多线程下是安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *serv, int socklen);</span><br></pre></td></tr></table></figure><p>函数说明: 该函数封装了底层的socket与connect接口, 通过调用此函数, 可以将bufferevent事件与通信的socket进行绑定, 参数如下：</p><p>bev – 需要提前初始化的bufferevent事件</p><p>serv – 对端(一般指服务端)的ip地址, 端口, 协议的结构指针</p><p>socklen – 描述serv的长度</p><p>说明: 调用此函数以后, 通信的socket与bufferevent缓冲区做了绑定,  后面调用了bufferevent_setcb函数以后, 会对bufferevent缓冲区的读写操作的事件设置回调函数,  当往缓冲区中写数据的时候会触发写回调函数, 当数据从socket的内核缓冲区读到bufferevent读缓冲区中的时候会触发读回调函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void bufferevent_free(struct bufferevent *bufev);</span><br></pre></td></tr></table></figure><p>函数说明: 释放bufferevent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void bufferevent_setcb(struct bufferevent *bufev,</span><br><span class="line"></span><br><span class="line">   bufferevent_data_cb readcb, bufferevent_data_cb writecb,</span><br><span class="line"></span><br><span class="line">bufferevent_event_cb eventcb, void *cbarg);</span><br></pre></td></tr></table></figure><p>函数说明: bufferevent_setcb用于设置bufferevent的回调函数, readcb, writecb, eventcb分别对应了读回调, 写回调, 事件回调, cbarg代表回调函数的 参数。</p><p>回调函数的原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short what, void *ctx);</span><br></pre></td></tr></table></figure><p>What 代表 对应的事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEV_EVENT_EOF--遇到文件结束指示</span><br><span class="line"></span><br><span class="line">BEV_EVENT_ERROR--发生错误</span><br><span class="line"></span><br><span class="line">BEV_EVENT_TIMEOUT--发生超时</span><br><span class="line"></span><br><span class="line">BEV_EVENT_CONNECTED--请求的过程中连接已经完成</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bufferevent_write(struct bufferevent *bufev, const void *data, size_t size);</span><br></pre></td></tr></table></figure><p>bufferevent_write是将data的数据写到bufferevent的写缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf);</span><br></pre></td></tr></table></figure><p>bufferevent_write_buffer 是将数据写到写缓冲区另外一个写法, 实际上bufferevent的内部的两个缓冲区结构就是struct evbuffer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);</span><br></pre></td></tr></table></figure><p>bufferevent_read 是将bufferevent的读缓冲区数据读到data中, 同时将读到的数据从bufferevent的读缓冲清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bufferevent_read_buffer(struct bufferevent *bufev, struct evbuffer *buf);</span><br></pre></td></tr></table></figure><p>bufferevent_read_buffer 将bufferevent读缓冲数据读到buf中, 接口的另外一种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bufferevent_enable(struct bufferevent *bufev, short event);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bufferevent_disable(struct bufferevent *bufev, short event);</span><br></pre></td></tr></table></figure><p>bufferevent_enable与bufferevent_disable是设置事件是否生效, 如果设置为disable, 事件回调将不会被触发。</p><h2 id="链接监听器-evconnlistener"><a class="markdownIt-Anchor" href="#链接监听器-evconnlistener"></a> 链接监听器-evconnlistener</h2><p>链接监听器封装了底层的socket通信相关函数, 比如socket, bind, listen,  accept这几个函数。链接监听器创建后实际上相当于调用了socket, bind, listen, 此时等待新的客户端连接到来,  如果有新的客户端连接, 那么内部先进行调用accept处理, 然后调用用户指定的回调函数。可以先看看函数原型, 了解一下它是怎么运作的：</p><p>函数声明所在的头文件:  event2/listener.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct evconnlistener *evconnlistener_new_bind(struct event_base *base,</span><br><span class="line"></span><br><span class="line">  evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,</span><br><span class="line"></span><br><span class="line">const struct sockaddr *sa, int socklen);</span><br><span class="line"></span><br><span class="line">//backlog是监听队列数,最多可以有多少个客户端进行三次握手</span><br></pre></td></tr></table></figure><p>函数说明:</p><p>是在当前没有套接字的情况下对链接监听器进行初始化, 看最后2个参数实际上就是bind使用的关键参数,  backlog是listen函数的关键参数（略有不同的是, 如果<code>backlog是-1, 那么监听器会自动选择一个合适的值</code>, <code>如果填0, 那么监听器会认为listen函数已经被调用过了</code>）, ptr是回调函数的参数, cb是有新连接之后的回调函数, 但是注意这个回调函数触发的时候,  链接器已经处理好新连接了, 并将与新连接通信的描述符交给回调函数。flags 需要参考几个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LEV_OPT_LEAVE_SOCKETS_BLOCKING  文件描述符为阻塞的</span><br><span class="line"></span><br><span class="line">LEV_OPT_CLOSE_ON_FREE       关闭时自动释放</span><br><span class="line"></span><br><span class="line">LEV_OPT_REUSEABLE         端口复用</span><br><span class="line"></span><br><span class="line">LEV_OPT_THREADSAFE        分配锁, 线程安全</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct evconnlistener *evconnlistener_new(struct event_base *base,</span><br><span class="line"></span><br><span class="line">  evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,</span><br><span class="line"></span><br><span class="line">evutil_socket_t fd);</span><br></pre></td></tr></table></figure><p>evconnlistener_new函数与前一个函数不同的地方在与后2个参数, 使用本函数时, 认为socket已经初始化好, 并且bind完成, 甚至也可以做完listen, 所以大多数时候, 我们都可以使用第一个函数。</p><p>两个函数的回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*evconnlistener_cb)(struct evconnlistener *evl,  evutil_socket_t fd, struct sockaddr *cliaddr, int socklen, void *ptr);</span><br></pre></td></tr></table></figure><p>回调函数fd参数是与客户端通信的描述符, 并非是等待连接的监听的那个描述符, 所以cliaddr对应的也是新连接的对端地址信息, 已经是accept处理好的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void evconnlistener_free(struct evconnlistener *lev);</span><br></pre></td></tr></table></figure><p>函数说明: 释放链接监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int evconnlistener_enable(struct evconnlistener *lev);</span><br></pre></td></tr></table></figure><p>函数说明: 使链接监听器生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int evconnlistener_disable(struct evconnlistener *lev);</span><br></pre></td></tr></table></figure><p>函数说明: 使链接监听器失效</p><p>如果上述函数都较为了解了, 可以尝试去看懂hello-world.c的代码, 在安装包的sample目录下, 其中有涉及到信号的函数,  看看自己能否找到函数的原型在哪？实际上就是一个宏定义, 也是我们之前介绍的event_new函数, 只是对应一个信号事件而已,  处理机制略有不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define evsignal_new(b, x, cb, arg) \</span><br><span class="line"></span><br><span class="line">event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))</span><br></pre></td></tr></table></figure><p>代码测试:</p><p>思路hello-world.c代码中当使用nc客户端测试的时候为什么nc收到hello world之后就立刻关闭了.</p><p>答案: 当服务器收到新的连接请求的时候, 会自动触发listener_cb回调函数,  该函数中有往bufferevent缓冲区中写入的操作(调用bufferevent_write),  接着又会触发写回调函数conn_writecb的执行, 这个回调函数中调用了bufferevent_free,  该函数能够释放bufferevent, 同时会关闭socket连接.</p><p>若是按下crtl+c会将程序终止, 此时会触发异常事件的退出函数(conn_eventcb)</p><p>hello-world.c代码没有读事件触发, 可以将代码进行修改, 将bufferevent的读事件添加上.</p><p>思考: 如何修改hello-world.c添加读回调.</p><p>libevent客户端代码阅读和分析.</p><p>画hello-world.c代码的改进版的流程图.</p><p>总结的话:</p><p>对于bufferevent来说, 一个文件描述符, 2个缓冲区, 3个回调函数</p><p>文件描述符是用于和客户端进行通信的通信文件描述符, 并不是监听的文件描述符</p><p>2个缓冲区是指: 一个bufferevent包括读缓冲区和写缓冲区</p><p>3个回调函数指: 读回调函数 写回调函数 和事件回调函数(客户端关闭连接或者是被信号终止进程会触发事件回调函数)</p><p>其中写回调基本上没什么用, 事件回调指的是socket上的连接和断开,异常等情况会触发bufferevent的事件回调.</p><p>读回调函数的触发时机:</p><p>当socket的内核socket读缓冲区中有数据的时候, bufferevent会将内核缓冲区中的数据读到自身的读缓冲区, 会触发bufferevent的读操作, 此时会调用bufferevent的读回调函数.</p><p>写回调函数的触发时机:</p><p>当往bufferevent的写缓冲区写入数据的时候, bufferevent底层会把缓冲区中的数据写入到内核的socket的写缓冲区中, 此时会触发bufferevent的写回调函数, 最后由内核的驱动程序将数据发送出去.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#学习目标&quot;&gt;&lt;/a&gt; &lt;strong&gt;学习目标&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;描述什么是libevent并掌握如何安装&lt;/li&gt;
&lt;li&gt;掌握event_base的
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>循环</title>
    <link href="https://xiaowuyoucy.github.io/2022/03/06/%E5%BE%AA%E7%8E%AF/"/>
    <id>https://xiaowuyoucy.github.io/2022/03/06/循环/</id>
    <published>2022-03-06T08:32:48.000Z</published>
    <updated>2022-03-06T08:33:19.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标"><a class="markdownIt-Anchor" href="#目标"></a> 目标</h1><ul><li>了解循环</li><li>while语法【重点】</li><li>while应用</li><li>break和continue</li><li>while循环嵌套【重点】</li><li>while循环嵌套应用【难点】</li><li>for循环</li></ul><h1 id="一-循环简介"><a class="markdownIt-Anchor" href="#一-循环简介"></a> 一. 循环简介</h1><h2 id="11-循环的作用"><a class="markdownIt-Anchor" href="#11-循环的作用"></a> 1.1 循环的作用</h2><blockquote><p>思考：假如我有个女朋友，有一天我们闹矛盾生气了，女朋友说：道歉，说100遍“媳妇儿，我错了”。这个时候程序员会怎么做？</p><p>答：100遍<code>print('媳妇儿，我错了')</code></p></blockquote><blockquote><p>思考：复制粘贴100次吗？</p><p>答：重复执行100次一样的代码，程序中循环即可</p></blockquote><p>循环的作用：让代码更高效的重复执行。</p><h2 id="12-循环的分类"><a class="markdownIt-Anchor" href="#12-循环的分类"></a> 1.2 循环的分类</h2><p>在Python中，循环分为<code>while</code>和<code>for</code>两种，最终实现效果相同。</p><h1 id="二-while的语法"><a class="markdownIt-Anchor" href="#二-while的语法"></a> 二. while的语法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    条件成立重复执行的代码<span class="number">1</span></span><br><span class="line">    条件成立重复执行的代码<span class="number">2</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h2 id="21-快速体验"><a class="markdownIt-Anchor" href="#21-快速体验"></a> 2.1 快速体验</h2><p>需求：复现重复执行100次<code>print('媳妇儿，我错了')</code>（输出更简洁一些，我们这里设置5次）。</p><p>分析：初始值是0次，终点是5次，重复做的事情输出“媳妇儿， 我错了”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 循环的计数器</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">    print(<span class="string">'媳妇儿，我错了'</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'任务结束'</span>)</span><br></pre></td></tr></table></figure><h1 id="三-while的应用"><a class="markdownIt-Anchor" href="#三-while的应用"></a> 三. while的应用</h1><h2 id="31-应用一计算1-100累加和"><a class="markdownIt-Anchor" href="#31-应用一计算1-100累加和"></a> 3.1 应用一：计算1-100累加和</h2><p>分析：1-100的累加和，即1 + 2 + 3 + 4 +….，即前两个数字的相加结果 + 下一个数字( 前一个数字 + 1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    result += i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出5050</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><blockquote><p>注意：为了验证程序的准确性，可以先改小数值，验证结果正确后，再改成1-100做累加。</p></blockquote><h2 id="32-应用二计算1-100偶数累加和"><a class="markdownIt-Anchor" href="#32-应用二计算1-100偶数累加和"></a> 3.2 应用二：计算1-100偶数累加和</h2><p>分析：1-100的偶数和，即 2 + 4 + 6 + 8…，得到偶数的方法如下：</p><ul><li>偶数即是和2取余结果为0的数字，可以加入条件语句判断是否为偶数，为偶数则累加</li><li>初始值为0 / 2 , 计数器每次累加2</li></ul><h3 id="321-方法一条件判断和2取余数则累加"><a class="markdownIt-Anchor" href="#321-方法一条件判断和2取余数则累加"></a> 3.2.1 方法一：条件判断和2取余数则累加</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：条件判断和2取余数为0则累加计算</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        result += i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出2550</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h3 id="322-方法二计数器控制"><a class="markdownIt-Anchor" href="#322-方法二计数器控制"></a> 3.2.2 方法二：计数器控制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法二：计数器控制增量为2</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    result += i</span><br><span class="line">    i += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出2550</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h1 id="四-break和continue"><a class="markdownIt-Anchor" href="#四-break和continue"></a> 四、break和continue</h1><p>break和continue是循环中满足一定条件退出循环的两种不同方式。</p><h2 id="41-理解"><a class="markdownIt-Anchor" href="#41-理解"></a> 4.1 理解</h2><p>举例：一共吃5个苹果，吃完第一个，吃第二个…，这里&quot;吃苹果&quot;的动作是不是重复执行？</p><p>情况一：如果吃的过程中，吃完第三个吃饱了，则不需要再吃第4个和第五个苹果，即是吃苹果的动作停止，这里就是break控制循环流程，即<mark>终止此循环</mark>。</p><p>情况二：如果吃的过程中，吃到第三个吃出一个大虫子…,是不是这个苹果就不吃了，开始吃第四个苹果，这里就是continue控制循环流程，即<mark>退出当前一次循环继而执行下一次循环代码</mark>。</p><h3 id="411-情况一break"><a class="markdownIt-Anchor" href="#411-情况一break"></a> 4.1.1 情况一：break</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        print(<span class="string">f'吃饱了不吃了'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">f'吃了第<span class="subst">&#123;i&#125;</span>个苹果'</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/images/javawz/image-20190124114340900.png" alt="image-20190124114340900"></p><h3 id="412-情况二continue"><a class="markdownIt-Anchor" href="#412-情况二continue"></a> 4.1.2 情况二：continue</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">f'大虫子，第<span class="subst">&#123;i&#125;</span>个不吃了'</span>)</span><br><span class="line">        <span class="comment"># 在continue之前一定要修改计数器，否则会陷入死循环</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(<span class="string">f'吃了第<span class="subst">&#123;i&#125;</span>个苹果'</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/images/javawz/image-20190124114514775.png" alt="image-20190124114514775"></p><h1 id="五-while循环嵌套"><a class="markdownIt-Anchor" href="#五-while循环嵌套"></a> 五. while循环嵌套</h1><h2 id="51-应用场景"><a class="markdownIt-Anchor" href="#51-应用场景"></a> 5.1 应用场景</h2><p>故事梗概：有天女朋友又生气了，惩罚：说3遍“媳妇儿， 我错了”，这个程序是不是循环即可？但如果女朋友说：还要刷今天晚饭的碗，这个程序怎么书写？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    print(<span class="string">'媳妇儿， 我错了'</span>)</span><br><span class="line">print(<span class="string">'刷晚饭的碗'</span>)</span><br></pre></td></tr></table></figure><p>但如果女朋友还是生气，把这套惩罚要连续3天都执行，有如何书写程序？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    <span class="keyword">while</span> 条件:</span><br><span class="line">        print(<span class="string">'媳妇儿， 我错了'</span>)</span><br><span class="line">    print(<span class="string">'刷晚饭的碗'</span>)</span><br></pre></td></tr></table></figure><h2 id="52-语法"><a class="markdownIt-Anchor" href="#52-语法"></a> 5.2 语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>成立执行的代码</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> 条件<span class="number">2</span>:</span><br><span class="line">        条件<span class="number">2</span>成立执行的代码</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><blockquote><p>总结：所谓while循环嵌套，就是一个while里面嵌套一个while的写法，每个while和之前的基础语法是相同的。</p></blockquote><h2 id="53-快速体验复现场景"><a class="markdownIt-Anchor" href="#53-快速体验复现场景"></a> 5.3 快速体验：复现场景</h2><h3 id="531-代码"><a class="markdownIt-Anchor" href="#531-代码"></a> 5.3.1 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> j &lt; <span class="number">3</span>:</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">'媳妇儿，我错了'</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'刷晚饭的碗'</span>)</span><br><span class="line">    print(<span class="string">'一套惩罚结束----------------'</span>)</span><br><span class="line">    j += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="532-执行结果"><a class="markdownIt-Anchor" href="#532-执行结果"></a> 5.3.2 执行结果</h3><p><img src="/images/javawz/image-20190104161506542-6589706.png" alt="image-20190104161506542"></p><h3 id="533-理解执行流程"><a class="markdownIt-Anchor" href="#533-理解执行流程"></a> 5.3.3 理解执行流程</h3><p>当内部循环执行完成之后，再执行下一次外部循环的条件判断。</p><p><img src="/images/javawz/while2.png" alt></p><h1 id="六-while循环嵌套应用"><a class="markdownIt-Anchor" href="#六-while循环嵌套应用"></a> 六. while循环嵌套应用</h1><h2 id="61-应用一打印星号正方形"><a class="markdownIt-Anchor" href="#61-应用一打印星号正方形"></a> 6.1 应用一：打印星号(正方形)</h2><h3 id="611-需求"><a class="markdownIt-Anchor" href="#611-需求"></a> 6.1.1 需求</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><h3 id="612-代码"><a class="markdownIt-Anchor" href="#612-代码"></a> 6.1.2 代码</h3><p>分析：一行输出5个星号，重复打印5行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重复打印5行星星</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> j &lt;= <span class="number">4</span>:</span><br><span class="line">    <span class="comment"># 一行星星的打印</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= <span class="number">4</span>:</span><br><span class="line">        <span class="comment"># 一行内的星星不能换行，取消print默认结束符\n</span></span><br><span class="line">        print(<span class="string">'*'</span>, end=<span class="string">''</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 每行结束要换行，这里借助一个空的print，利用print默认结束符换行</span></span><br><span class="line">    print()</span><br><span class="line">    j += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="62-应用二打印星号三角形"><a class="markdownIt-Anchor" href="#62-应用二打印星号三角形"></a> 6.2 应用二：打印星号(三角形)</h2><h3 id="621-需求"><a class="markdownIt-Anchor" href="#621-需求"></a> 6.2.1 需求</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><h3 id="622-代码"><a class="markdownIt-Anchor" href="#622-代码"></a> 6.2.2 代码</h3><p>分析：<mark>一行输出星星的个数和行号是相等的</mark>，每行：重复打印行号数字个星号，将打印行星号的命令重复执行5次实现打印5行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重复打印5行星星</span></span><br><span class="line"><span class="comment"># j表示行号</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> j &lt;= <span class="number">4</span>:</span><br><span class="line">    <span class="comment"># 一行星星的打印</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="comment"># i表示每行里面星星的个数，这个数字要和行号相等所以i要和j联动</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">        print(<span class="string">'*'</span>, end=<span class="string">''</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    print()</span><br><span class="line">    j += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="63-九九乘法表"><a class="markdownIt-Anchor" href="#63-九九乘法表"></a> 6.3 九九乘法表</h2><h3 id="631-执行结果"><a class="markdownIt-Anchor" href="#631-执行结果"></a> 6.3.1 执行结果</h3><p><img src="/images/javawz/image-20190104163553616-6590953.png" alt="image-20190104163553616"></p><h3 id="632-代码"><a class="markdownIt-Anchor" href="#632-代码"></a> 6.3.2 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重复打印9行表达式</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &lt;= <span class="number">9</span>:</span><br><span class="line">    <span class="comment"># 打印一行里面的表达式 a * b = a*b</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;i&#125;</span>*<span class="subst">&#123;j&#125;</span>=<span class="subst">&#123;j*i&#125;</span>'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    print()</span><br><span class="line">    j += <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="七-for循环"><a class="markdownIt-Anchor" href="#七-for循环"></a> 七、for循环</h1><h2 id="71-语法"><a class="markdownIt-Anchor" href="#71-语法"></a> 7.1 语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 序列:</span><br><span class="line">    重复执行的代码<span class="number">1</span></span><br><span class="line">    重复执行的代码<span class="number">2</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h2 id="72-快速体验"><a class="markdownIt-Anchor" href="#72-快速体验"></a> 7.2 快速体验</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">'itheima'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/images/javawz/image-20190104164152311-6591312.png" alt="image-20190104164152311"></p><h2 id="73-break"><a class="markdownIt-Anchor" href="#73-break"></a> 7.3 break</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">'itheima'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">'e'</span>:</span><br><span class="line">        print(<span class="string">'遇到e不打印'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/images/javawz/image-20190104165242555-6591962.png" alt="image-20190104165242555"></p><h2 id="74-continue"><a class="markdownIt-Anchor" href="#74-continue"></a> 7.4 continue</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">'itheima'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">'e'</span>:</span><br><span class="line">        print(<span class="string">'遇到e不打印'</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/images/javawz/image-20190104165413160-6592053.png" alt="image-20190104165413160"></p><h1 id="八-else"><a class="markdownIt-Anchor" href="#八-else"></a> 八. else</h1><p>循环可以和else配合使用，else下方缩进的代码指的是<mark>当循环正常结束之后要执行的代码</mark>。</p><h2 id="81-whileelse"><a class="markdownIt-Anchor" href="#81-whileelse"></a> 8.1 while…else</h2><p>需求：女朋友生气了，要惩罚：连续说5遍“媳妇儿，我错了”，如果道歉正常完毕女朋友就原谅我了，这个程序怎么写？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    print(<span class="string">'媳妇儿，我错了'</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">print(<span class="string">'媳妇儿原谅我了...'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>思考： 这个print是不是没有循环也能执行？</p></blockquote><h3 id="811-语法"><a class="markdownIt-Anchor" href="#811-语法"></a> 8.1.1 语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    条件成立重复执行的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    循环正常结束之后要执行的代码</span><br></pre></td></tr></table></figure><h3 id="812-示例"><a class="markdownIt-Anchor" href="#812-示例"></a> 8.1.2 示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    print(<span class="string">'媳妇儿，我错了'</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'媳妇原谅我了，真开心，哈哈哈哈'</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20190125111816497.png" alt="image-20190125111816497"></p><h3 id="813-退出循环的方式"><a class="markdownIt-Anchor" href="#813-退出循环的方式"></a> 8.1.3 退出循环的方式</h3><p>需求：女朋友生气，要求道歉5遍：媳妇儿，我错了。道歉到第三遍的时候，媳妇埋怨这一遍说的不真诚，是不是就是要退出循环了？这个退出有两种可能性：</p><ul><li>更生气，不打算原谅，也不需要道歉了，程序如何书写？</li><li>只一遍不真诚，可以忍受，继续下一遍道歉，程序如何书写？</li></ul><ol><li>break</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">'这遍说的不真诚'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">'媳妇儿，我错了'</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'媳妇原谅我了，真开心，哈哈哈哈'</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20190125111952693.png" alt="image-20190125111952693"></p><blockquote><p>所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。</p></blockquote><ol start="2"><li>continue</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">'这遍说的不真诚'</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(<span class="string">'媳妇儿，我错了'</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'媳妇原谅我了，真开心，哈哈哈哈'</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20190125112111170.png" alt="image-20190125112111170"></p><blockquote><p>因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。</p></blockquote><h2 id="82-forelse"><a class="markdownIt-Anchor" href="#82-forelse"></a> 8.2 for…else</h2><h3 id="821-语法"><a class="markdownIt-Anchor" href="#821-语法"></a> 8.2.1 语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 序列:</span><br><span class="line">    重复执行的代码</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    循环正常结束之后要执行的代码</span><br></pre></td></tr></table></figure><blockquote><p>所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。</p></blockquote><h3 id="822-示例"><a class="markdownIt-Anchor" href="#822-示例"></a> 8.2.2 示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">'itheima'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'循环正常结束之后执行的代码'</span>)</span><br></pre></td></tr></table></figure><h3 id="823-退出循环的方式"><a class="markdownIt-Anchor" href="#823-退出循环的方式"></a> 8.2.3 退出循环的方式</h3><ol><li>break终止循环</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">'itheima'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">'e'</span>:</span><br><span class="line">        print(<span class="string">'遇到e不打印'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'循环正常结束之后执行的代码'</span>)</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/images/javawz/image-20190104165551501-6592151.png" alt="image-20190104165551501"></p><blockquote><p>没有执行else缩进的代码。</p></blockquote><ol start="2"><li>continue控制循环</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">'itheima'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">'e'</span>:</span><br><span class="line">        print(<span class="string">'遇到e不打印'</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'循环正常结束之后执行的代码'</span>)</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/images/javawz/image-20190104165714740-6592234.png" alt="image-20190104165714740"></p><blockquote><p>因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。</p></blockquote><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li>循环的作用：控制代码重复执行</li><li>while语法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    条件成立重复执行的代码<span class="number">1</span></span><br><span class="line">    条件成立重复执行的代码<span class="number">2</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><ul><li>while循环嵌套语法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>成立执行的代码</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> 条件<span class="number">2</span>:</span><br><span class="line">        条件<span class="number">2</span>成立执行的代码</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><ul><li>for循环语法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 序列:</span><br><span class="line">    重复执行的代码<span class="number">1</span></span><br><span class="line">    重复执行的代码<span class="number">2</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><ul><li>break退出整个循环</li><li>continue退出本次循环，继续执行下一次重复执行的代码</li><li>else<ul><li>while和for都可以配合else使用</li><li>else下方缩进的代码含义：当循环正常结束后执行的代码</li><li>break终止循环不会执行else下方缩进的代码</li><li>continue退出循环的方式执行else下方缩进的代码</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目标&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目标&quot;&gt;&lt;/a&gt; 目标&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;了解循环&lt;/li&gt;
&lt;li&gt;while语法【重点】&lt;/li&gt;
&lt;li&gt;while应用&lt;/li&gt;
&lt;li&gt;break和continue
      
    
    </summary>
    
      <category term="Python" scheme="https://xiaowuyoucy.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>条件语句</title>
    <link href="https://xiaowuyoucy.github.io/2022/03/06/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"/>
    <id>https://xiaowuyoucy.github.io/2022/03/06/条件语句/</id>
    <published>2022-03-06T08:03:30.000Z</published>
    <updated>2022-03-06T08:34:18.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标"><a class="markdownIt-Anchor" href="#目标"></a> 目标</h1><ul><li>条件语句作用</li><li>if语法</li><li>if…else…</li><li>多重判断</li><li>if嵌套</li></ul><h1 id="一-了解条件语句"><a class="markdownIt-Anchor" href="#一-了解条件语句"></a> 一. 了解条件语句</h1><p>假设一个场景：</p><ul><li>同学们这个年龄去过网吧吗？</li><li>去网吧进门想要上网必须做的一件事是做什么？（考虑重点）</li><li>为什么要把身份证给工作人员？</li><li>是不是就是为了判断是否成年？</li><li>是不是如果成年可以上网？如果不成年则不允许上网？</li></ul><p>其实这里所谓的判断就是条件语句，即<strong>条件成立执行某些代码，条件不成立则不执行这些代码</strong>。</p><h1 id="二-if-语法"><a class="markdownIt-Anchor" href="#二-if-语法"></a> 二. if 语法</h1><h2 id="21-语法"><a class="markdownIt-Anchor" href="#21-语法"></a> 2.1 语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    条件成立执行的代码<span class="number">1</span></span><br><span class="line">    条件成立执行的代码<span class="number">2</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h2 id="22-快速体验"><a class="markdownIt-Anchor" href="#22-快速体验"></a> 2.2 快速体验</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'条件成立执行的代码1'</span>)</span><br><span class="line">    print(<span class="string">'条件成立执行的代码2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下方的代码没有缩进到if语句块，所以和if条件无关</span></span><br><span class="line">print(<span class="string">'我是无论条件是否成立都要执行的代码'</span>)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="/images/javawz/image-20190103113457876-6486497.png" alt="image-20190103113457876"></p><h1 id="三-实例上网"><a class="markdownIt-Anchor" href="#三-实例上网"></a> 三. 实例：上网</h1><p>需求分析：如果用户年龄大于等于18岁，即成年，输出&quot;已经成年，可以上网&quot;。</p><h2 id="31-简单版"><a class="markdownIt-Anchor" href="#31-简单版"></a> 3.1 简单版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'已经成年，可以上网'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'系统关闭'</span>)</span><br></pre></td></tr></table></figure><h2 id="32-进阶版"><a class="markdownIt-Anchor" href="#32-进阶版"></a> 3.2 进阶版</h2><p>新增需求：用户可以输出自己的年龄，然后系统进行判断是否成年，成年则输出&quot;您的年龄是’用户输入的年龄’，已经成年，可以上网&quot;。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input接受用户输入的数据是字符串类型，条件是age和整型18做判断，所以这里要int转换数据类型</span></span><br><span class="line">age = int(input(<span class="string">'请输入您的年龄：'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">f'您的年龄是<span class="subst">&#123;age&#125;</span>,已经成年，可以上网'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">'系统关闭'</span>)</span><br></pre></td></tr></table></figure><h1 id="四-ifelse"><a class="markdownIt-Anchor" href="#四-ifelse"></a> 四. if…else…</h1><p>作用：条件成立执行if下方的代码; 条件不成立执行else下方的代码。</p><blockquote><p>思考：网吧上网的实例，如果成年，允许上网，如果不成年呢？是不是应该回复用户不能上网？</p></blockquote><h2 id="41-语法"><a class="markdownIt-Anchor" href="#41-语法"></a> 4.1 语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    条件成立执行的代码<span class="number">1</span></span><br><span class="line">    条件成立执行的代码<span class="number">2</span></span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    条件不成立执行的代码<span class="number">1</span></span><br><span class="line">    条件不成立执行的代码<span class="number">2</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h2 id="42-实用版网吧上网"><a class="markdownIt-Anchor" href="#42-实用版网吧上网"></a> 4.2 实用版：网吧上网</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">age = int(input(<span class="string">'请输入您的年龄：'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">f'您的年龄是<span class="subst">&#123;age&#125;</span>,已经成年，可以上网'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">f'您的年龄是<span class="subst">&#123;age&#125;</span>,未成年，请自行回家写作业'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'系统关闭'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果条件成立执行了某些代码，那么其他的情况的代码将不会执行。</p></blockquote><h1 id="五-多重判断"><a class="markdownIt-Anchor" href="#五-多重判断"></a> 五、多重判断</h1><blockquote><p>思考：中国合法工作年龄为18-60岁，即如果年龄小于18的情况为童工，不合法；如果年龄在18-60岁之间为合法工龄；大于60岁为法定退休年龄。</p></blockquote><h2 id="51-语法"><a class="markdownIt-Anchor" href="#51-语法"></a> 5.1 语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>成立执行的代码<span class="number">1</span></span><br><span class="line">    条件<span class="number">1</span>成立执行的代码<span class="number">2</span></span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>：</span><br><span class="line">条件<span class="number">2</span>成立执行的代码<span class="number">1</span></span><br><span class="line">    条件<span class="number">2</span>成立执行的代码<span class="number">2</span></span><br><span class="line">    ......</span><br><span class="line">......</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    以上条件都不成立执行执行的代码</span><br></pre></td></tr></table></figure><blockquote><p>多重判断也可以和else配合使用。一般else放到整个if语句的最后，表示以上条件都不成立的时候执行的代码。</p></blockquote><h2 id="52-实例工龄判断"><a class="markdownIt-Anchor" href="#52-实例工龄判断"></a> 5.2 实例：工龄判断</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = int(input(<span class="string">'请输入您的年龄：'</span>))</span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">f'您的年龄是<span class="subst">&#123;age&#125;</span>,童工一枚'</span>)</span><br><span class="line"><span class="keyword">elif</span> (age &gt;= <span class="number">18</span>) <span class="keyword">and</span> (age &lt;= <span class="number">60</span>):</span><br><span class="line">    print(<span class="string">f'您的年龄是<span class="subst">&#123;age&#125;</span>,合法工龄'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt; <span class="number">60</span>:</span><br><span class="line">    print(<span class="string">f'您的年龄是<span class="subst">&#123;age&#125;</span>,可以退休'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>拓展：<code>age &gt;= 18 and age &lt;= 60</code>可以化简为<code>18 &lt;= age &lt;= 60</code>。</p></blockquote><h1 id="六-if嵌套"><a class="markdownIt-Anchor" href="#六-if嵌套"></a> 六、if嵌套</h1><blockquote><p>思考：坐公交：如果有钱可以上车，没钱不能上车；上车后如果有空座，则可以坐下；如果没空座，就要站着。怎么书写程序？</p></blockquote><h2 id="61-语法"><a class="markdownIt-Anchor" href="#61-语法"></a> 6.1 语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>：</span><br><span class="line">条件<span class="number">1</span>成立执行的代码</span><br><span class="line">    条件<span class="number">1</span>成立执行的代码</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> 条件<span class="number">2</span>：</span><br><span class="line">    条件<span class="number">2</span>成立执行的代码</span><br><span class="line">        条件<span class="number">2</span>成立执行的代码</span><br></pre></td></tr></table></figure><blockquote><p>注意：条件2的if也是处于条件1成立执行的代码的缩进关系内部。</p></blockquote><h2 id="62-实例坐公交"><a class="markdownIt-Anchor" href="#62-实例坐公交"></a> 6.2 实例：坐公交</h2><h3 id="621-判断是否能上车"><a class="markdownIt-Anchor" href="#621-判断是否能上车"></a> 6.2.1 判断是否能上车</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1. 如果有钱，则可以上车</span></span><br><span class="line"><span class="string">    2. 上车后，如果有空座，可以坐下</span></span><br><span class="line"><span class="string">    上车后，如果没有空座，则站着等空座位</span></span><br><span class="line"><span class="string">如果没钱，不能上车</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 假设用 money = 1 表示有钱, money = 0表示没有钱</span></span><br><span class="line">money = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> money == <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">'土豪，不差钱，顺利上车'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'没钱，不能上车，追着公交车跑'</span>)</span><br></pre></td></tr></table></figure><h3 id="622-判断是否能坐下"><a class="markdownIt-Anchor" href="#622-判断是否能坐下"></a> 6.2.2 判断是否能坐下</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1. 如果有钱，则可以上车</span></span><br><span class="line"><span class="string">    2. 上车后，如果有空座，可以坐下</span></span><br><span class="line"><span class="string">    上车后，如果没有空座，则站着等空座位</span></span><br><span class="line"><span class="string">如果没钱，不能上车</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 假设用 money = 1 表示有钱, money = 0表示没有钱; seat = 1 表示有空座，seat = 0 表示没有空座</span></span><br><span class="line">money = <span class="number">1</span></span><br><span class="line">seat = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> money == <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">'土豪，不差钱，顺利上车'</span>)</span><br><span class="line">    <span class="keyword">if</span> seat == <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">'有空座，可以坐下'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'没有空座，站等'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'没钱，不能上车，追着公交车跑'</span>)</span><br></pre></td></tr></table></figure><h1 id="七-应用猜拳游戏"><a class="markdownIt-Anchor" href="#七-应用猜拳游戏"></a> 七. 应用：猜拳游戏</h1><p>需求分析：</p><ul><li><p>参与游戏的角色</p><ul><li>玩家<ul><li>手动出拳</li></ul></li><li>电脑<ul><li>随机出拳</li></ul></li></ul></li><li><p>判断输赢</p><ul><li>玩家获胜</li></ul><table><thead><tr><th>玩家</th><th>电脑</th></tr></thead><tbody><tr><td>石头</td><td>剪刀</td></tr><tr><td>剪刀</td><td>布</td></tr><tr><td>布</td><td>石头</td></tr></tbody></table><ul><li>平局<ul><li>玩家出拳 和 电脑出拳相同</li></ul></li><li>电脑获胜</li></ul></li></ul><p>随机做法：</p><pre><code>1. 导出random模块2. random.randint(开始,结束)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">提示：0-石头，1-剪刀，2-布</span></span><br><span class="line"><span class="string">1. 出拳</span></span><br><span class="line"><span class="string">玩家输入出拳</span></span><br><span class="line"><span class="string">电脑随机出拳</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. 判断输赢</span></span><br><span class="line"><span class="string">玩家获胜</span></span><br><span class="line"><span class="string">平局</span></span><br><span class="line"><span class="string">电脑获胜</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入random模块</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算电脑出拳的随机数字</span></span><br><span class="line">computer = random.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">print(computer)</span><br><span class="line"></span><br><span class="line">player = int(input(<span class="string">'请出拳：0-石头，1-剪刀，2-布：'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 玩家胜利 p0:c1 或 p1:c2 或 p2:c0</span></span><br><span class="line"><span class="keyword">if</span> (player == <span class="number">0</span> <span class="keyword">and</span> computer == <span class="number">1</span>) <span class="keyword">or</span> (player == <span class="number">1</span> <span class="keyword">and</span> computer == <span class="number">2</span>) <span class="keyword">or</span> (player == <span class="number">2</span> <span class="keyword">and</span> computer == <span class="number">0</span>):</span><br><span class="line">    print(<span class="string">'玩家获胜'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平局：玩家 == 电脑</span></span><br><span class="line"><span class="keyword">elif</span> player == computer:</span><br><span class="line">    print(<span class="string">'平局'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'电脑获胜'</span>)</span><br></pre></td></tr></table></figure><h1 id="八-三目运算符"><a class="markdownIt-Anchor" href="#八-三目运算符"></a> 八.  三目运算符</h1><p>三目运算符也叫三元运算符。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值<span class="number">1</span> <span class="keyword">if</span> 条件 <span class="keyword">else</span> 值<span class="number">2</span></span><br></pre></td></tr></table></figure><p>快速体验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">c = a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li>if语句语法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    条件成立执行的代码</span><br></pre></td></tr></table></figure><ul><li>if…else…</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    条件成立执行的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    条件不成立执行的代码</span><br></pre></td></tr></table></figure><ul><li>多重判断</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>成立执行的代码</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">    条件<span class="number">2</span>成立执行的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    以上条件都不成立执行的代码</span><br></pre></td></tr></table></figure><ul><li>if嵌套</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>成立执行的代码</span><br><span class="line">    <span class="keyword">if</span> 条件<span class="number">2</span>:</span><br><span class="line">        条件<span class="number">2</span>成立执行的代码</span><br><span class="line">        ....</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目标&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目标&quot;&gt;&lt;/a&gt; 目标&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;条件语句作用&lt;/li&gt;
&lt;li&gt;if语法&lt;/li&gt;
&lt;li&gt;if…else…&lt;/li&gt;
&lt;li&gt;多重判断&lt;/li&gt;
&lt;li&gt;if嵌套
      
    
    </summary>
    
      <category term="Python" scheme="https://xiaowuyoucy.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>数据类型转换和运算符</title>
    <link href="https://xiaowuyoucy.github.io/2022/03/06/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://xiaowuyoucy.github.io/2022/03/06/数据类型转换和运算符/</id>
    <published>2022-03-06T07:40:31.000Z</published>
    <updated>2022-03-06T08:02:49.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标"><a class="markdownIt-Anchor" href="#目标"></a> 目标</h1><ul><li>数据类型转换的必要性</li><li>数据类型转换常用方法</li></ul><h1 id="一-转换数据类型的作用"><a class="markdownIt-Anchor" href="#一-转换数据类型的作用"></a> 一. 转换数据类型的作用</h1><p>问：input()接收用户输入的数据都是字符串类型，如果用户输入1，想得到整型该如何操作？</p><p>答：转换数据类型即可，即将字符串类型转换成整型。</p><h1 id="二-转换数据类型的函数"><a class="markdownIt-Anchor" href="#二-转换数据类型的函数"></a> 二. 转换数据类型的函数</h1><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><mark>int(x [,base ])</mark></td><td style="text-align:center">将x转换为一个整数</td></tr><tr><td style="text-align:center"><mark>float(x )</mark></td><td style="text-align:center">将x转换为一个浮点数</td></tr><tr><td style="text-align:center">complex(real [,imag ])</td><td style="text-align:center">创建一个复数，real为实部，imag为虚部</td></tr><tr><td style="text-align:center"><mark>str(x )</mark></td><td style="text-align:center">将对象 x 转换为字符串</td></tr><tr><td style="text-align:center">repr(x )</td><td style="text-align:center">将对象 x 转换为表达式字符串</td></tr><tr><td style="text-align:center"><mark>eval(str )</mark></td><td style="text-align:center">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td style="text-align:center"><mark>tuple(s )</mark></td><td style="text-align:center">将序列 s 转换为一个元组</td></tr><tr><td style="text-align:center"><mark>list(s )</mark></td><td style="text-align:center">将序列 s 转换为一个列表</td></tr><tr><td style="text-align:center">chr(x )</td><td style="text-align:center">将一个整数转换为一个Unicode字符</td></tr><tr><td style="text-align:center">ord(x )</td><td style="text-align:center">将一个字符转换为它的ASCII整数值</td></tr><tr><td style="text-align:center">hex(x )</td><td style="text-align:center">将一个整数转换为一个十六进制字符串</td></tr><tr><td style="text-align:center">oct(x )</td><td style="text-align:center">将一个整数转换为一个八进制字符串</td></tr><tr><td style="text-align:center">bin(x )</td><td style="text-align:center">将一个整数转换为一个二进制字符串</td></tr></tbody></table><h1 id="三-快速体验"><a class="markdownIt-Anchor" href="#三-快速体验"></a> 三. 快速体验</h1><p>需求：input接收用户输入，用户输入“1”，将这个数据1转换成整型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 接收用户输入</span></span><br><span class="line">num = input(<span class="string">'请输入您的幸运数字：'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 打印结果</span></span><br><span class="line">print(<span class="string">f"您的幸运数字是<span class="subst">&#123;num&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 检测接收到的用户输入的数据类型 -- str类型</span></span><br><span class="line">print(type(num))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 转换数据类型为整型 -- int类型</span></span><br><span class="line">print(type(int(num)))</span><br></pre></td></tr></table></figure><h1 id="四-实验"><a class="markdownIt-Anchor" href="#四-实验"></a> 四. 实验</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. float() -- 转换成浮点型</span></span><br><span class="line">num1 = <span class="number">1</span></span><br><span class="line">print(float(num1))</span><br><span class="line">print(type(float(num1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. str() -- 转换成字符串类型</span></span><br><span class="line">num2 = <span class="number">10</span></span><br><span class="line">print(type(str(num2)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. tuple() -- 将一个序列转换成元组</span></span><br><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">print(tuple(list1))</span><br><span class="line">print(type(tuple(list1)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. list() -- 将一个序列转换成列表</span></span><br><span class="line">t1 = (<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line">print(list(t1))</span><br><span class="line">print(type(list(t1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. eval() -- 将字符串中的数据转换成Python表达式原本类型</span></span><br><span class="line">str1 = <span class="string">'10'</span></span><br><span class="line">str2 = <span class="string">'[1, 2, 3]'</span></span><br><span class="line">str3 = <span class="string">'(1000, 2000, 3000)'</span></span><br><span class="line">print(type(eval(str1)))</span><br><span class="line">print(type(eval(str2)))</span><br><span class="line">print(type(eval(str3)))</span><br></pre></td></tr></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li>转换数据类型常用的函数<ul><li>int()</li><li>float()</li><li>str()</li><li>list()</li><li>tuple()</li><li>eval()</li></ul></li></ul><h1 id="目标-2"><a class="markdownIt-Anchor" href="#目标-2"></a> 目标</h1><p>掌握常用运算符的作用</p><h1 id="运算符的分类"><a class="markdownIt-Anchor" href="#运算符的分类"></a> 运算符的分类</h1><ul><li>算数运算符</li><li>赋值运算符</li><li>复合赋值运算符</li><li>比较运算符</li><li>逻辑运算符</li></ul><h2 id="1-算数运算符"><a class="markdownIt-Anchor" href="#1-算数运算符"></a> 1. 算数运算符</h2><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th><th>实例</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">加</td><td>1 + 1 输出结果为 2</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">减</td><td>1-1 输出结果为 0</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">乘</td><td>2 * 2 输出结果为 4</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">除</td><td>10 / 2 输出结果为 5</td></tr><tr><td style="text-align:center">//</td><td style="text-align:center">整除</td><td>9 // 4 输出结果为2</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">取余</td><td>9 % 4 输出结果为 1</td></tr><tr><td style="text-align:center">**</td><td style="text-align:center">指数</td><td>2 ** 4 输出结果为 16，即 2 * 2 * 2 * 2</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">小括号</td><td>小括号用来提高运算优先级，即 (1 + 2) * 3 输出结果为 9</td></tr></tbody></table><blockquote><p>注意：</p></blockquote><ul><li>混合运算优先级顺序：<code>()</code>高于 <code>**</code> 高于 <code>*</code> <code>/</code> <code>//</code> <code>%</code> 高于 <code>+</code> <code>-</code></li></ul><h2 id="2-赋值运算符"><a class="markdownIt-Anchor" href="#2-赋值运算符"></a> 2. 赋值运算符</h2><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>=</td><td>赋值</td><td>将<code>=</code>右侧的结果赋值给等号左侧的变量</td></tr></tbody></table><ul><li>单个变量赋值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure><ul><li>多个变量赋值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num1, float1, str1 = <span class="number">10</span>, <span class="number">0.5</span>, <span class="string">'hello world'</span></span><br><span class="line">print(num1)</span><br><span class="line">print(float1)</span><br><span class="line">print(str1)</span><br></pre></td></tr></table></figure><ul><li>多变量赋相同值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = b = <span class="number">10</span></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h2 id="3-复合赋值运算符"><a class="markdownIt-Anchor" href="#3-复合赋值运算符"></a> 3. 复合赋值运算符</h2><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+=</td><td>加法赋值运算符</td><td>c += a 等价于 c = c + a</td></tr><tr><td>-=</td><td>减法赋值运算符</td><td>c -= a 等价于 c = c- a</td></tr><tr><td>*=</td><td>乘法赋值运算符</td><td>c *= a 等价于 c = c * a</td></tr><tr><td>/=</td><td>除法赋值运算符</td><td>c /= a 等价于 c = c / a</td></tr><tr><td>//=</td><td>整除赋值运算符</td><td>c //= a 等价于 c = c // a</td></tr><tr><td>%=</td><td>取余赋值运算符</td><td>c %= a 等价于 c = c % a</td></tr><tr><td>**=</td><td>幂赋值运算符</td><td>c ** = a 等价于 c = c ** a</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br><span class="line">a += <span class="number">1</span></span><br><span class="line"><span class="comment"># 输出101  a = a + 1,最终a = 100 + 1</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">b *= <span class="number">3</span></span><br><span class="line"><span class="comment"># 输出6  b = b * 3,最终b = 2 * 3</span></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">c = <span class="number">10</span></span><br><span class="line">c += <span class="number">1</span> + <span class="number">2</span></span><br><span class="line"><span class="comment"># 输出13, 先算运算符右侧1 + 2 = 3， c += 3 , 推导出c = 10 + 3</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h2 id="4-比较运算符"><a class="markdownIt-Anchor" href="#4-比较运算符"></a> 4. 比较运算符</h2><p>比较运算符也叫关系运算符， 通常用来判断。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>==</td><td>判断相等。如果两个操作数的结果相等，则条件结果为真(True)，否则条件结果为假(False)</td><td>如a=3,b=3，则（a == b) 为 True</td></tr><tr><td>!=</td><td>不等于 。如果两个操作数的结果不相等，则条件为真(True)，否则条件结果为假(False)</td><td>如a=3,b=3，则（a == b) 为 True如a=1,b=3，则(a != b) 为 True</td></tr><tr><td>&gt;</td><td>运算符左侧操作数结果是否大于右侧操作数结果，如果大于，则条件为真，否则为假</td><td>如a=7,b=3，则(a &gt; b) 为 True</td></tr><tr><td>&lt;</td><td>运算符左侧操作数结果是否小于右侧操作数结果，如果小于，则条件为真，否则为假</td><td>如a=7,b=3，则(a &lt; b) 为 False</td></tr><tr><td>&gt;=</td><td>运算符左侧操作数结果是否大于等于右侧操作数结果，如果大于，则条件为真，否则为假</td><td>如a=7,b=3，则(a &lt; b) 为 False如a=3,b=3，则(a &gt;= b) 为 True</td></tr><tr><td>&lt;=</td><td>运算符左侧操作数结果是否小于等于右侧操作数结果，如果小于，则条件为真，否则为假</td><td>如a=3,b=3，则(a &lt;= b) 为 True</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">7</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line">print(a == b)  <span class="comment"># False</span></span><br><span class="line">print(a != b)  <span class="comment"># True</span></span><br><span class="line">print(a &lt; b)   <span class="comment"># False</span></span><br><span class="line">print(a &gt; b)   <span class="comment"># True</span></span><br><span class="line">print(a &lt;= b)  <span class="comment"># False</span></span><br><span class="line">print(a &gt;= b)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="5-逻辑运算符"><a class="markdownIt-Anchor" href="#5-逻辑运算符"></a> 5. 逻辑运算符</h2><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔&quot;与&quot;：如果 x 为 False，x and y 返回 False，否则它返回 y 的值。</td><td>True and False， 返回 False。</td></tr><tr><td>or</td><td>x or y</td><td>布尔&quot;或&quot;：如果 x 是 True，它返回 True，否则它返回 y 的值。</td><td>False or True， 返回 True。</td></tr><tr><td>not</td><td>not x</td><td>布尔&quot;非&quot;：如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td>not True 返回 False, not False 返回 True</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line">print((a &lt; b) <span class="keyword">and</span> (b &lt; c))  <span class="comment"># True</span></span><br><span class="line">print((a &gt; b) <span class="keyword">and</span> (b &lt; c))  <span class="comment"># False</span></span><br><span class="line">print((a &gt; b) <span class="keyword">or</span> (b &lt; c))   <span class="comment"># True</span></span><br><span class="line">print(<span class="keyword">not</span> (a &gt; b))          <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h3 id="51-拓展"><a class="markdownIt-Anchor" href="#51-拓展"></a> 5.1 拓展</h3><p>数字之间的逻辑运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">c = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># and运算符，只要有一个值为0，则结果为0，否则结果为最后一个非0数字</span></span><br><span class="line">print(a <span class="keyword">and</span> b)  <span class="comment"># 0</span></span><br><span class="line">print(b <span class="keyword">and</span> a)  <span class="comment"># 0</span></span><br><span class="line">print(a <span class="keyword">and</span> c)  <span class="comment"># 0</span></span><br><span class="line">print(c <span class="keyword">and</span> a)  <span class="comment"># 0</span></span><br><span class="line">print(b <span class="keyword">and</span> c)  <span class="comment"># 2</span></span><br><span class="line">print(c <span class="keyword">and</span> b)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or运算符，只有所有值为0结果才为0，否则结果为第一个非0数字</span></span><br><span class="line">print(a <span class="keyword">or</span> b)  <span class="comment"># 1</span></span><br><span class="line">print(a <span class="keyword">or</span> c)  <span class="comment"># 2</span></span><br><span class="line">print(b <span class="keyword">or</span> c)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h1 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h1><ul><li>算数运算的优先级<ul><li>混合运算优先级顺序：<code>()</code>高于 <code>**</code> 高于 <code>*</code> <code>/</code> <code>//</code> <code>%</code> 高于 <code>+</code> <code>-</code></li></ul></li><li>赋值运算符<ul><li>=</li></ul></li><li>复合赋值运算符<ul><li>+=</li><li>-=</li><li>优先级<ol><li>先算复合赋值运算符右侧的表达式</li><li>再算复合赋值运算的算数运算</li><li>最后算赋值运算</li></ol></li></ul></li><li>比较运算符<ul><li>判断相等： ==</li><li>大于等于： &gt;=</li><li>小于等于：&lt;=</li><li>不等于： !=</li></ul></li><li>逻辑运算符<ul><li>与： and</li><li>或：or</li><li>非：not</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目标&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目标&quot;&gt;&lt;/a&gt; 目标&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;数据类型转换的必要性&lt;/li&gt;
&lt;li&gt;数据类型转换常用方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一-转换数据类型的作用&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Python" scheme="https://xiaowuyoucy.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>走进Linux世界</title>
    <link href="https://xiaowuyoucy.github.io/2022/03/04/%E8%B5%B0%E8%BF%9BLinux%E4%B8%96%E7%95%8C/"/>
    <id>https://xiaowuyoucy.github.io/2022/03/04/走进Linux世界/</id>
    <published>2022-03-03T16:07:14.000Z</published>
    <updated>2022-03-03T18:55:20.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="idcinternet-data-center-互联网数据中心"><a class="markdownIt-Anchor" href="#idcinternet-data-center-互联网数据中心"></a> IDC(Internet Data Center) 互联网数据中心</h3><p><img src="/images/javawz/image-20220304000832547.png" alt="image-20220304000832547"></p><p>IDC主机托管主要应用范围是网站发布、虚拟主机和电子商务等。</p><h3 id="物理服务器介绍"><a class="markdownIt-Anchor" href="#物理服务器介绍"></a> 物理服务器介绍</h3><p>一个机柜一般摆放7台到10台服务器,分为A,B路</p><p>服务器的高度单位是U</p><p>1U=1.75英寸</p><h3 id="物理服务器分类"><a class="markdownIt-Anchor" href="#物理服务器分类"></a> 物理服务器分类</h3><p>塔式服务器</p><p>机架式服务器</p><p>刀片服务器</p><h3 id="塔式服务器"><a class="markdownIt-Anchor" href="#塔式服务器"></a> 塔式服务器</h3><p>塔式服务器是我们⽣活中⻅得⽐较多的，主要是因为塔式服务器的外形结构和普通PC⽐较类似。塔式服务器尺⼨没有统⼀标准，由于塔式服务器的机箱⽐较⼤，服务器的配置也可以很⾼，冗余扩展更可以很⻬备，所以它的应⽤范围⾮常⼴，应该说⽬前使⽤率最⾼的⼀种服务器就是塔式服务器。</p><p><img src="/images/javawz/image-20220304001607076.png" alt="image-20220304001607076"></p><h3 id="机架式服务器"><a class="markdownIt-Anchor" href="#机架式服务器"></a> 机架式服务器</h3><p>机架式服务器的外形看来不像计算机，⽽像交换机，有1U（1U=1.75英⼨）、2U、4U等规格。机架式服务器安装在标准的19英⼨机柜⾥⾯。这种结构的多为功能型服务器。</p><p><img src="/images/javawz/image-20220304001701259.png" alt="image-20220304001701259"></p><h3 id="刀片式服务器"><a class="markdownIt-Anchor" href="#刀片式服务器"></a> 刀片式服务器</h3><p>刀片服务器是指在标准⾼度的机架式机箱内可插装多个卡式的服务器单元，是⼀种实现HAHD(⾼可⽤⾼密度)的低成本服务器平台，为特殊应⽤⾏业和⾼密度计算环境专⻔设计。刀片服务器就像“刀片”⼀样，每⼀块“刀片”实际上就是⼀块系统主板。</p><p><img src="/images/javawz/image-20220304001742181.png" alt="image-20220304001742181"></p><p>一个机柜如果超过10台服务器就有可能会超电，从而引起短路</p><p>所以机柜不允许超过10台服务器</p><p><img src="/images/javawz/image-20220304002750686.png" alt="image-20220304002750686"></p><p>如果服务器断网了，可以通过管理卡交换机来连接到服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;idcinternet-data-center-互联网数据中心&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#idcinternet-data-center-互联网数据中心&quot;&gt;&lt;/a&gt; IDC(Internet Data Center)
      
    
    </summary>
    
      <category term="RHCE" scheme="https://xiaowuyoucy.github.io/categories/RHCE/"/>
    
    
  </entry>
  
  <entry>
    <title>变量和数据类型与输出</title>
    <link href="https://xiaowuyoucy.github.io/2022/03/03/%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://xiaowuyoucy.github.io/2022/03/03/变量和数据类型/</id>
    <published>2022-03-03T15:33:52.000Z</published>
    <updated>2022-03-03T15:38:46.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标"><a class="markdownIt-Anchor" href="#目标"></a> 目标</h1><ul><li>注释的作用</li><li>注释的分类及语法</li><li>注释的特点</li></ul><h1 id="一-注释的作用"><a class="markdownIt-Anchor" href="#一-注释的作用"></a> 一. 注释的作用</h1><p>通过用自己熟悉的语言，在程序中对某些代码进行标注说明，这就是注释的作用，能够大大增强程序的可读性。</p><h1 id="二-注释的分类及语法"><a class="markdownIt-Anchor" href="#二-注释的分类及语法"></a> 二. 注释的分类及语法</h1><p>注释分为两类：<mark>单行注释</mark> 和 <mark>多行注释</mark>。</p><ul><li>单行注释</li></ul><p>只能注释一行内容，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释内容</span></span><br></pre></td></tr></table></figure><ul><li>多行注释</li></ul><p>可以注释多行内容，一般用在注释一段代码的情况， 语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">第一行注释</span></span><br><span class="line"><span class="string">第二行注释</span></span><br><span class="line"><span class="string">第三行注释</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">注释1</span></span><br><span class="line"><span class="string">注释2</span></span><br><span class="line"><span class="string">注释3</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>快捷键： <mark>ctrl + /</mark></p></blockquote><h2 id="21-快速体验"><a class="markdownIt-Anchor" href="#21-快速体验"></a> 2.1 快速体验</h2><ul><li>单行注释</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出hello world</span></span><br><span class="line">print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'hello Python'</span>)  <span class="comment"># 输出(简单的说明可以放到一行代码的后面，一般习惯代码后面添加两个空格再书写注释文字)</span></span><br></pre></td></tr></table></figure><ul><li>多行注释</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    下面三行都是输出的作用，输出内容分别是：</span></span><br><span class="line"><span class="string">    hello Python</span></span><br><span class="line"><span class="string">    hello itcast</span></span><br><span class="line"><span class="string">    hello itheima</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(<span class="string">'hello Python'</span>)</span><br><span class="line">print(<span class="string">'hello itcast'</span>)</span><br><span class="line">print(<span class="string">'hello itheima'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    下面三行都是输出的作用，输出内容分别是：</span></span><br><span class="line"><span class="string">    hello Python</span></span><br><span class="line"><span class="string">    hello itcast</span></span><br><span class="line"><span class="string">    hello itheima</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(<span class="string">'hello Python'</span>)</span><br><span class="line">print(<span class="string">'hello itcast'</span>)</span><br><span class="line">print(<span class="string">'hello itheima'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：解释器不执行任何的注释内容。</p></blockquote><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li>注释的作用</li></ul><p>用人类熟悉的语言对代码进行解释说明，方便后期维护。</p><ul><li>注释的分类<ul><li>单行： <code># 注释内容</code>，快捷键ctrl+/</li><li>多行：<code>&quot;&quot;&quot; 注释内容 &quot;&quot;&quot;</code> 或 <code>''' 注释内容 '''</code></li></ul></li><li>解释器不执行注释内容</li></ul><h1 id="定义变量"><a class="markdownIt-Anchor" href="#定义变量"></a> 定义变量</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 = 值</span><br></pre></td></tr></table></figure><blockquote><p>变量名自定义，要满足<mark>标识符</mark>命名规则。</p></blockquote><h2 id="21-标识符"><a class="markdownIt-Anchor" href="#21-标识符"></a> 2.1  标识符</h2><p>标识符命名规则是Python中定义各种名字的时候的统一规范，具体如下：</p><ul><li>由数字、字母、下划线组成</li><li>不能数字开头</li><li>不能使用内置关键字</li><li>严格区分大小写</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">False     None    True   and      as       assert   break     class  </span><br><span class="line">continue  def     del    elif     else     except   finally   for</span><br><span class="line">from      global  if     import   in       is       lambda    nonlocal</span><br><span class="line">not       or      pass   raise    return   try      while     with  </span><br><span class="line">yield</span><br></pre></td></tr></table></figure><h2 id="22-命名习惯"><a class="markdownIt-Anchor" href="#22-命名习惯"></a> 2.2 命名习惯</h2><ul><li>见名知义。</li><li>大驼峰：即每个单词首字母都大写，例如：<code>MyName</code>。</li><li>小驼峰：第二个（含）以后的单词首字母大写，例如：<code>myName</code>。</li><li>下划线：例如：<code>my_name</code>。</li></ul><h2 id="23-使用变量"><a class="markdownIt-Anchor" href="#23-使用变量"></a> 2.3 使用变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_name = <span class="string">'TOM'</span></span><br><span class="line">print(my_name)</span><br><span class="line"></span><br><span class="line">schoolName = <span class="string">'黑马程序员'</span></span><br><span class="line">print(schoolName)</span><br></pre></td></tr></table></figure><h2 id="24-认识bug"><a class="markdownIt-Anchor" href="#24-认识bug"></a> 2.4 认识bug</h2><p>所谓bug，就是程序中的错误。如果程序有错误，需要程序员排查问题，纠正错误。</p><p><img src="/images/javawz/image-20190115125845015-7528325.png" alt="image-20190115125845015"></p><h1 id="三-debug工具"><a class="markdownIt-Anchor" href="#三-debug工具"></a> 三. Debug工具</h1><p>Debug工具是PyCharm IDE中集成的用来调试程序的工具，在这里程序员可以查看程序的执行细节和流程或者调解bug。</p><p>Debug工具使用步骤：</p><ol><li>打断点</li><li>Debug调试</li></ol><h2 id="31-打断点"><a class="markdownIt-Anchor" href="#31-打断点"></a> 3.1 打断点</h2><ul><li>断点位置</li></ul><p>目标要调试的代码块的第一行代码即可，即一个断点即可。</p><ul><li>打断点的方法</li></ul><p>单击目标代码的行号右侧空白位置。</p><p><img src="/images/javawz/image-20190115130541289-7528741.png" alt="image-20190115130541289"></p><h2 id="32-debug调试"><a class="markdownIt-Anchor" href="#32-debug调试"></a> 3.2 Debug调试</h2><p>打成功断点后，在文件内部任意位置 — 右键 – Debug’文件名’ — 即可调出Debug工具面板 – 单击Step Over/F8，即可按步执行代码。</p><p><img src="/images/javawz/image-20190115130809100-7528889.png" alt="image-20190115130809100"></p><h3 id="321-debug输出面板分类"><a class="markdownIt-Anchor" href="#321-debug输出面板分类"></a> 3.2.1 Debug输出面板分类</h3><ul><li>Debugger<ul><li>显示变量和变量的细节</li></ul></li><li>Console<ul><li>输出内容</li></ul></li></ul><h1 id="四-认识数据类型"><a class="markdownIt-Anchor" href="#四-认识数据类型"></a> 四. 认识数据类型</h1><p><strong>在 Python 里为了应对不同的业务需求，也把数据分为不同的类型。</strong></p><p><img src="/images/javawz/image-20190111124628584-7181988.png" alt="image-20190111124628584"></p><blockquote><p>检测数据类型的方法：<code>type()</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">print(type(a))  <span class="comment"># &lt;class 'int'&gt; -- 整型</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1.1</span></span><br><span class="line">print(type(b))  <span class="comment"># &lt;class 'float'&gt; -- 浮点型</span></span><br><span class="line"></span><br><span class="line">c = <span class="literal">True</span></span><br><span class="line">print(type(c))  <span class="comment"># &lt;class 'bool'&gt; -- 布尔型</span></span><br><span class="line"></span><br><span class="line">d = <span class="string">'12345'</span></span><br><span class="line">print(type(d))  <span class="comment"># &lt;class 'str'&gt; -- 字符串</span></span><br><span class="line"></span><br><span class="line">e = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">print(type(e))  <span class="comment"># &lt;class 'list'&gt; -- 列表</span></span><br><span class="line"></span><br><span class="line">f = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">print(type(f))  <span class="comment"># &lt;class 'tuple'&gt; -- 元组</span></span><br><span class="line"></span><br><span class="line">h = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">print(type(h))  <span class="comment"># &lt;class 'set'&gt; -- 集合</span></span><br><span class="line"></span><br><span class="line">g = &#123;<span class="string">'name'</span>: <span class="string">'TOM'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">print(type(g))  <span class="comment"># &lt;class 'dict'&gt; -- 字典</span></span><br></pre></td></tr></table></figure><h1 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h1><ul><li>定义变量的语法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 = 值</span><br></pre></td></tr></table></figure><ul><li>标识符<ul><li>由数字、字母、下划线组成</li><li>不能数字开头</li><li>不能使用内置关键字</li><li>严格区分大小写</li></ul></li><li>数据类型<ul><li>整型：int</li><li>浮点型：float</li><li>字符串：str</li><li>布尔型：bool</li><li>元组：tuple</li><li>集合：set</li><li>字典：dict</li></ul></li></ul><h1 id="目标-2"><a class="markdownIt-Anchor" href="#目标-2"></a> 目标</h1><ul><li>格式化输出<ul><li>格式化符号</li><li>f-字符串</li></ul></li><li>print的结束符</li></ul><h1 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h1><p>作用：程序输出内容给用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'hello Python'</span>)</span><br><span class="line"></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">print(age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求：输出“今年我的年龄是18岁”</span></span><br></pre></td></tr></table></figure><h1 id="一-格式化输出"><a class="markdownIt-Anchor" href="#一-格式化输出"></a> 一.  格式化输出</h1><p>所谓的格式化输出即按照一定的格式输出内容。</p><h3 id="11-格式化符号"><a class="markdownIt-Anchor" href="#11-格式化符号"></a> 1.1 格式化符号</h3><table><thead><tr><th style="text-align:center">格式符号</th><th style="text-align:center">转换</th></tr></thead><tbody><tr><td style="text-align:center"><mark>%s</mark></td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center"><mark>%d</mark></td><td style="text-align:center">有符号的十进制整数</td></tr><tr><td style="text-align:center"><mark>%f</mark></td><td style="text-align:center">浮点数</td></tr><tr><td style="text-align:center">%c</td><td style="text-align:center">字符</td></tr><tr><td style="text-align:center">%u</td><td style="text-align:center">无符号十进制整数</td></tr><tr><td style="text-align:center">%o</td><td style="text-align:center">八进制整数</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">十六进制整数（小写ox）</td></tr><tr><td style="text-align:center">%X</td><td style="text-align:center">十六进制整数（大写OX）</td></tr><tr><td style="text-align:center">%e</td><td style="text-align:center">科学计数法（小写’e’）</td></tr><tr><td style="text-align:center">%E</td><td style="text-align:center">科学计数法（大写’E’）</td></tr><tr><td style="text-align:center">%g</td><td style="text-align:center">%f和%e的简写</td></tr><tr><td style="text-align:center">%G</td><td style="text-align:center">%f和%E的简写</td></tr></tbody></table><blockquote><p>技巧</p></blockquote><ul><li>%06d，表示输出的整数显示位数，不足以0补全，超出当前位数则原样输出</li><li>%.2f，表示小数点后显示的小数位数。</li></ul><h3 id="12-体验"><a class="markdownIt-Anchor" href="#12-体验"></a> 1.2 体验</h3><p>格式化字符串除了%s，还可以写为<code>f'{表达式}'</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span> </span><br><span class="line">name = <span class="string">'TOM'</span></span><br><span class="line">weight = <span class="number">75.5</span></span><br><span class="line">student_id = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM</span></span><br><span class="line">print(<span class="string">'我的名字是%s'</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的学号是0001</span></span><br><span class="line">print(<span class="string">'我的学号是%4d'</span> % student_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的体重是75.50公斤</span></span><br><span class="line">print(<span class="string">'我的体重是%.2f公斤'</span> % weight)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM，今年18岁了</span></span><br><span class="line">print(<span class="string">'我的名字是%s，今年%d岁了'</span> % (name, age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM，明年19岁了</span></span><br><span class="line">print(<span class="string">'我的名字是%s，明年%d岁了'</span> % (name, age + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM，明年19岁了</span></span><br><span class="line">print(<span class="string">f'我的名字是<span class="subst">&#123;name&#125;</span>, 明年<span class="subst">&#123;age + <span class="number">1</span>&#125;</span>岁了'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>f-格式化字符串是Python3.6中新增的格式化方法，该方法更简单易读。</p></blockquote><h3 id="13-转义字符"><a class="markdownIt-Anchor" href="#13-转义字符"></a> 1.3 转义字符</h3><ul><li><code>\n</code>：换行。</li><li><code>\t</code>：制表符，一个tab键（4个空格）的距离。</li></ul><h3 id="14-结束符"><a class="markdownIt-Anchor" href="#14-结束符"></a> 1.4 结束符</h3><blockquote><p>想一想，为什么两个print会换行输出？</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'输出的内容'</span>, end=<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>在Python中，print()， 默认自带<code>end=&quot;\n&quot;</code>这个换行结束符，所以导致每两个<code>print</code>直接会换行展示，用户可以按需求更改结束符。</p></blockquote><h1 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h1><ul><li>格式化符号<ul><li>%s：格式化输出字符串</li><li>%d：格式化输出整数</li><li>%f：格式化输出浮点数</li></ul></li><li>f-字符串<ul><li>f’{表达式}’</li></ul></li><li>转义字符<ul><li>\n：换行</li><li>\t：制表符</li></ul></li><li>print结束符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'内容'</span>, end=<span class="string">""</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目标&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目标&quot;&gt;&lt;/a&gt; 目标&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;注释的作用&lt;/li&gt;
&lt;li&gt;注释的分类及语法&lt;/li&gt;
&lt;li&gt;注释的特点&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一-注释的作用&quot;
      
    
    </summary>
    
      <category term="Python" scheme="https://xiaowuyoucy.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python简介</title>
    <link href="https://xiaowuyoucy.github.io/2022/03/03/Python%E7%AE%80%E4%BB%8B/"/>
    <id>https://xiaowuyoucy.github.io/2022/03/03/Python简介/</id>
    <published>2022-03-03T09:47:53.000Z</published>
    <updated>2022-03-03T15:34:12.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python介绍"><a class="markdownIt-Anchor" href="#python介绍"></a> Python介绍</h2><ol><li>简单、易学，适应人群广泛</li><li>免费、开源</li><li>应用领域广泛</li></ol><h1 id="python版本"><a class="markdownIt-Anchor" href="#python版本"></a> Python版本</h1><ul><li>Python 2.X</li><li>Python 3.X<ul><li>Python 3.5</li><li>Python 3.6</li><li>Python 3.7</li></ul></li></ul><h1 id="解释器的作用"><a class="markdownIt-Anchor" href="#解释器的作用"></a> 解释器的作用</h1><p>Python解释器作用：运行文件</p><ul><li>Python解释器种类<ul><li>CPython，C语言开发的解释器[官方]，应用广泛的解释器。</li><li>IPython，基于CPython的一种交互式解释器。</li><li>其他解释器<ul><li>PyPy，基于Python语言开发的解释器。</li><li>Jython，运行在Java平台的解释器，直接把Python代码编译成Java字节码执行。</li><li>IronPython，运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</li></ul></li></ul></li></ul><h1 id="下载python解释器"><a class="markdownIt-Anchor" href="#下载python解释器"></a> 下载Python解释器</h1><p>下载地址：<a href="https://www.python.org/downloads/release/python-372/" target="_blank" rel="noopener">https://www.python.org/downloads/release/python-372/</a></p><p>[单击上述链接] – 查找目标文件：Windows x86-64 executable installer – 单击即可下载。</p><p><img src="/images/javawz/image-20190110170855787-7111335.png" alt="image-20190110170855787-7111335"></p><h1 id="安装python解释器"><a class="markdownIt-Anchor" href="#安装python解释器"></a> 安装Python解释器</h1><p>双击可执行文件 — 勾选[pip] – [Next] – [勾选添加环境变量] – [Install]，按提示操作即可。</p><p><img src="/images/javawz/image-20190122112451519.png" alt="image-20190122112451519"></p><h2 id="pycharm"><a class="markdownIt-Anchor" href="#pycharm"></a> PyCharm</h2><ul><li>PyCharm的作用</li><li>下载安装PyCharm</li><li>PyCharm的基本使用</li><li>PyCharm的基本设置</li></ul><h2 id="pycharm的作用"><a class="markdownIt-Anchor" href="#pycharm的作用"></a> PyCharm的作用</h2><p>PyCharm是一种Python <mark>IDE</mark>（集成开发环境），带有一整套可以帮助用户在使用Python语言开发时<mark>提高其效率的工具</mark>，内部集成的功能如下：</p><ul><li>Project管理</li><li>智能提示</li><li>语法高亮</li><li>代码跳转</li><li>调试代码</li><li>解释代码(解释器)</li><li>框架和库</li><li>…</li></ul><blockquote><p>PythonCharm分为专业版（professional）和社区版（community），本视频以社区版为基准进行操作和讲解。</p></blockquote><h1 id="下载和安装"><a class="markdownIt-Anchor" href="#下载和安装"></a> 下载和安装</h1><h2 id="21-下载"><a class="markdownIt-Anchor" href="#21-下载"></a> 2.1 下载</h2><p>下载地址：<a href="http://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">http://www.jetbrains.com/pycharm/download/#section=windows</a></p><p><img src="/images/javawz/image-20190110172355909.png" alt="image-20190110172355909"></p><p>注意：这里选择Community(社区版)下载，专业版是收费版本，社区版可以满足我们基础编程需求。</p><h2 id="22-安装"><a class="markdownIt-Anchor" href="#22-安装"></a> 2.2 安装</h2><p>双击安装包 – [运行] – [允许你应用更改设备]: [是] – [Next] – [选择安装位置] – [Next] – [Install] – [Finish]。</p><p><img src="/images/javawz/image-20190108112855414-6918135.png" alt="image-20190108112855414-6918135"></p><h1 id="pycharm基本使用"><a class="markdownIt-Anchor" href="#pycharm基本使用"></a> PyCharm基本使用</h1><h2 id="31-新建项目"><a class="markdownIt-Anchor" href="#31-新建项目"></a> 3.1 新建项目</h2><p>打开PyCharm – [Create New Project] – 选择项目根目录和解释器版本 – [Create]，即可完成新建一个项目。</p><p><img src="/images/javawz/image-20190102112309128-6399389-1646321297852.png" alt="image-20190102112309128-6399389"></p><h2 id="32-新建文件并书写代码"><a class="markdownIt-Anchor" href="#32-新建文件并书写代码"></a> 3.2 新建文件并书写代码</h2><p>项目根目录或根目录内部任意位置 — 右键 – [New] – [Python File] – 输入文件名 – [OK]</p><blockquote><p>如果是将来要上传到服务器的文件，那么文件名切记不能用中文。</p></blockquote><p><img src="/images/javawz/image-20190102114520725-6400720.png" alt="image-20190102114520725-6400720"></p><p>双击打开文件，并书写一个最简单的Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure><h2 id="33-运行文件"><a class="markdownIt-Anchor" href="#33-运行文件"></a> 3.3 运行文件</h2><p>文件打开状态 – 空白位置 — 右键 – Run – 即可调出Pycharm的控制台输出程序结果。</p><p><img src="/images/javawz/image-20190102122728572-6403248.png" alt="image-20190102122728572-6403248"></p><h2 id="四-pycharm的基本设置"><a class="markdownIt-Anchor" href="#四-pycharm的基本设置"></a> 四. PyCharm的基本设置</h2><p>[file] – [Settings]/[Default Settings]。</p><h2 id="41-修改主题"><a class="markdownIt-Anchor" href="#41-修改主题"></a> 4.1 修改主题</h2><p>[Appearance &amp; Behavior] – [Appearance]</p><ul><li>Theme：修改主题</li><li>Name：修改主题字体</li><li>Size：修改主题字号</li></ul><h2 id="42-修改代码文字格式"><a class="markdownIt-Anchor" href="#42-修改代码文字格式"></a> 4.2 修改代码文字格式</h2><p>[Editor] – [Font]</p><ul><li>Font：修改字体</li><li>Size：修改字号</li><li>Line Spacing：修改行间距</li></ul><h2 id="43-修改解释器"><a class="markdownIt-Anchor" href="#43-修改解释器"></a> 4.3 修改解释器</h2><p>[Project: 项目名称] – [Project Interpreter] – [设置图标] – [Add] – 浏览到目标解释器 – [OK] – [OK]。</p><h2 id="44-项目管理"><a class="markdownIt-Anchor" href="#44-项目管理"></a> 4.4 项目管理</h2><h3 id="441-打开项目"><a class="markdownIt-Anchor" href="#441-打开项目"></a> 4.4.1 打开项目</h3><p>[File] – [Open] – 浏览选择目标项目根目录 – [OK] – 选择打开项目方式。</p><p>打开项目的方式共三种，分别如下</p><p><img src="/images/javawz/image-20190115095119315.png" alt="image-20190115095119315"></p><ol><li>This Window</li></ol><p>覆盖当前项目，从而打开目标项目</p><ol start="2"><li>New Window</li></ol><p>在新窗口打开，则打开两次PyCharm，每个PyCharm负责一个项目。</p><ol start="3"><li>Attach</li></ol><p>在当前项目中打开,且不覆盖</p><h3 id="442-关闭项目"><a class="markdownIt-Anchor" href="#442-关闭项目"></a> 4.4.2 关闭项目</h3><p>[File] – [Close Project]/[Close Projects in current window]</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li>PyCharm新建文件</li></ul><p>项目管理空白位置 — 右键 – New – PythonFile</p><ul><li>运行文件</li></ul><p>代码内部 — 右键 – Run</p><ul><li>修改代码文字格式</li></ul><p>[file] – [Settings]/[Default Settings] – [Editor] – [Font]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#python介绍&quot;&gt;&lt;/a&gt; Python介绍&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;简单、易学，适应人群广泛&lt;/li&gt;
&lt;li&gt;免费、开源&lt;/li&gt;
&lt;li&gt;应用领域广泛&lt;/li&gt;
      
    
    </summary>
    
      <category term="Python" scheme="https://xiaowuyoucy.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp介绍</title>
    <link href="https://xiaowuyoucy.github.io/2022/02/22/cpp%E4%BB%8B%E7%BB%8D/"/>
    <id>https://xiaowuyoucy.github.io/2022/02/22/cpp介绍/</id>
    <published>2022-02-21T16:57:55.000Z</published>
    <updated>2022-02-23T17:33:55.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><p>每个c++程序都从main函数开始执行</p><p>函数的定义格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">(多个语句构成的)函数体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语句"><a class="markdownIt-Anchor" href="#语句"></a> 语句</h3><p>C++程序的最小完整执行指令都是以分号结尾的语句。</p><p>可以将一条语句写在多个行，不管中间有多少空格、回车符、换行符，最后都是以分号作为语句的结束。</p><h3 id="程序注释"><a class="markdownIt-Anchor" href="#程序注释"></a> 程序注释</h3><h4 id="多行注释"><a class="markdownIt-Anchor" href="#多行注释"></a> 多行注释</h4><p>以/*开头，然后以*/结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">多行注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="单行注释"><a class="markdownIt-Anchor" href="#单行注释"></a> 单行注释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 单行注释</span><br></pre></td></tr></table></figure><p>块注释不能嵌套,既不能在块注释中再出现/* 或 */</p><h3 id="hello-world程序"><a class="markdownIt-Anchor" href="#hello-world程序"></a> hello world程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准输入输出库和cout"><a class="markdownIt-Anchor" href="#标准输入输出库和cout"></a> 标准输入输出库和cout</h3><p>要使用标准输入输出库就要包含头文件<code>#include&lt;iostream&gt;</code></p><p>stream是流的意思，io是输入input输出output的缩写。</p><p><code>#include</code>指令称为包含预处理指令,意思是用文件iostream的内容来替换掉这个预处理指令</p><p>cout对象代表的是标准输出流对象(既代表终端窗口)</p><h3 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h3><p>一个c<ins>程序可能会使用其他人写的库,例如有A库和B库,这两个库中的全局变量或函数的名字都有可能相同,为了避免冲突,c</ins>引入了命名空间将这两个库区分开来。</p><p>C++自带的标准库中的所有对象、函数等都属于一个叫std的标准命名空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std; 将整个标准名字空间std的名字都引入到程序中,写上这句话就可以直接调用std命名空间中的变量或函数了</span><br></pre></td></tr></table></figure><h4 id="名字空间限定"><a class="markdownIt-Anchor" href="#名字空间限定"></a> 名字空间限定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命名空间::变量/函数</span><br><span class="line">std::cout</span><br><span class="line">std::cout表示这是名字空间std的cout</span><br><span class="line"></span><br><span class="line">std::endl</span><br><span class="line">表示std命名空间中的endl,代表换行符</span><br></pre></td></tr></table></figure><h4 id="用using引入单个名字"><a class="markdownIt-Anchor" href="#用using引入单个名字"></a> 用using引入单个名字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using std::cout;</span><br><span class="line">cout &lt;&lt; &quot;123&quot; &lt;&lt; 456&quot;;</span><br><span class="line">引入之后,后面就不需要在用名字限定了</span><br><span class="line"></span><br><span class="line">输出运算符&lt;&lt;可以连续使用,这是因为cout &lt;&lt; &quot;123&quot; 返回的还是cout</span><br></pre></td></tr></table></figure><h3 id="字符串和字符"><a class="markdownIt-Anchor" href="#字符串和字符"></a> 字符串和字符</h3><p>单引号括起来的表示一个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;n&apos;  &apos;,&apos;  &apos;a&apos;</span><br></pre></td></tr></table></figure><p>双引号括起来的表示一个字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;abd&quot;   &quot;123&quot;    &quot;asd&quot;</span><br></pre></td></tr></table></figure><p><code>\n</code>和endl的区别</p><p><code>\n</code>和endl都表示换行符，endl会强制程序的缓冲区里面的数据立即输出</p><p><code>\t</code>表示制表符</p><h3 id="宏定义"><a class="markdownIt-Anchor" href="#宏定义"></a> 宏定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define 宏名 值</span><br><span class="line"></span><br><span class="line">#define PI 3.1415</span><br><span class="line">程序预处理阶段是,会将程序中所有的PI都用3.1415来替换</span><br></pre></td></tr></table></figure><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p>变量是命名的内存块。</p><p>在c++中变量也称为对象</p><p>每个变量都有一个数据类型,例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">double r;</span><br><span class="line">double area;</span><br></pre></td></tr></table></figure><h3 id="初始值"><a class="markdownIt-Anchor" href="#初始值"></a> {}初始值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i&#123;2&#125;;</span><br><span class="line">double r&#123;2.5&#125;;</span><br><span class="line">double area = 0;</span><br></pre></td></tr></table></figure><h3 id="标准输入流对象cin"><a class="markdownIt-Anchor" href="#标准输入流对象cin"></a> 标准输入流对象cin</h3><p>cin输入流对象,代表键盘对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double r;</span><br><span class="line">cin &gt;&gt; r;//重键盘输入一个数字到r中</span><br></pre></td></tr></table></figure><h3 id="用户自定义类型"><a class="markdownIt-Anchor" href="#用户自定义类型"></a> 用户自定义类型</h3><p>string类型</p><p>要使用string类型需要包含头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br></pre></td></tr></table></figure><p>string类型有一个size()成员函数,可以返回string对象的字符个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1 = &quot;abc&quot;;</span><br><span class="line">cout &lt;&lt; s1.size() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>substr(s,e)成员函数返回string对象下标s到e(不包含e)之间的字符构成的一个字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1 = &quot;123456&quot;;</span><br><span class="line">cout &lt;&lt; s1.substr(1,4) &lt;&lt; endl;//输出123</span><br></pre></td></tr></table></figure><p>可以用+将两个字符串对象拼接起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = &quot;abc&quot;;</span><br><span class="line">string s2 = &quot;def&quot;;</span><br><span class="line">cout &lt;&lt; s1 + s2 &lt;&lt; endl;//输出abcdef</span><br></pre></td></tr></table></figure><h3 id="数字表示"><a class="markdownIt-Anchor" href="#数字表示"></a> 数字表示</h3><p>用0b开头表示一串二进制表示一个二进制数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0b000010111</span><br></pre></td></tr></table></figure><h4 id="十六进制"><a class="markdownIt-Anchor" href="#十六进制"></a> 十六进制</h4><p>用0x表示16进制数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x12 0xFA0xFF</span><br></pre></td></tr></table></figure><h4 id="八进制"><a class="markdownIt-Anchor" href="#八进制"></a> 八进制</h4><p>用0开头表示8进制数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0120440777</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::dec// 以十进制方式输出</span><br><span class="line">std::hex// 以十六进制方式输出</span><br><span class="line">std::oct// 以八进制方式输出</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220222020913683.png" alt="image-20220222020913683"></p><h3 id="编译c程序"><a class="markdownIt-Anchor" href="#编译c程序"></a> 编译c++程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ 源文件名 -o 目标程序名</span><br><span class="line"></span><br><span class="line">g++ test.cpp -o test</span><br><span class="line">最终生成test程序</span><br></pre></td></tr></table></figure><h2 id="变量和数据类型"><a class="markdownIt-Anchor" href="#变量和数据类型"></a> 变量和数据类型</h2><p>变量的定义格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 变量名&#123;&#125;;</span><br></pre></td></tr></table></figure><p>{}方式的初始化称为列表初始化</p><p>如果{}里面没有值,对于基本类型的变量,初始值默认为0,有的编译器则会发出警告或报错</p><h3 id="信息损失则报错"><a class="markdownIt-Anchor" href="#信息损失则报错"></a> 信息损失则报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a&#123;1.2&#125;;//1.2会截取小数部分,导致信息损失,所以会报错</span><br></pre></td></tr></table></figure><h3 id="auto"><a class="markdownIt-Anchor" href="#auto"></a> auto</h3><p>用auto定义一个有初始值的变量时,不需要明确指定类型,因为编译器能自动从变量的初始值推断出该变量的数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto b = true;// bool</span><br><span class="line">auto ch&#123;&apos;x&apos;&#125;;// char</span><br><span class="line">auto i = 123;// int</span><br><span class="line">auto d&#123;1.2&#125;;// double</span><br><span class="line">auto z = d + i;// 从表达式的d+i的值来推断z的数据类型</span><br></pre></td></tr></table></figure><h3 id="typeid运算符"><a class="markdownIt-Anchor" href="#typeid运算符"></a> typeid运算符</h3><p>可以用typeid运算符查询得到一个数据类型或变量的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; typeid(int) .name() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; typeid(b).name() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="decltype"><a class="markdownIt-Anchor" href="#decltype"></a> decltype</h3><p>用decltype(exp)得到一个表达式的值的类型,并用这个类型来定义一个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(3 + 4.5) c;</span><br></pre></td></tr></table></figure><h3 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型"></a> 基本类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wchar_t 宽字符类型,在windows平台上是16位 2字节类型</span><br><span class="line">char16_t 表示UTF-16类型</span><br><span class="line">char32_t 表示UTF-32字符类型</span><br></pre></td></tr></table></figure><h3 id="整型文字常量"><a class="markdownIt-Anchor" href="#整型文字常量"></a> 整型文字常量</h3><p>字母u或U表示unsigned整型</p><p>字母l或L表示long整型</p><p>字母ll或LL表示 long long整型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">18u// unsigned</span><br><span class="line">18U// unsigned</span><br><span class="line"></span><br><span class="line">022L// long</span><br><span class="line">18l// long </span><br><span class="line"></span><br><span class="line">18LL// long long</span><br><span class="line">0x12uL// unsigned long </span><br><span class="line">18ULL// long long</span><br></pre></td></tr></table></figure><h3 id="浮点型文字常量"><a class="markdownIt-Anchor" href="#浮点型文字常量"></a> 浮点型文字常量</h3><p>默认是double</p><p>用f或F表示float</p><p>用l或L表示long double</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3.14</span><br><span class="line">3.14f</span><br><span class="line">3.14F</span><br><span class="line"></span><br><span class="line">3.14L</span><br><span class="line">3.14l</span><br></pre></td></tr></table></figure><h3 id="字符串文字常量"><a class="markdownIt-Anchor" href="#字符串文字常量"></a> 字符串文字常量</h3><p>L表示 wchar_t</p><p>u表示 char16_t</p><p>U表示 char32_t</p><p>u8前缀表示 UTF-8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L&apos;A&apos;// wchar_t</span><br><span class="line"></span><br><span class="line">u&apos;A&apos;// char16_t</span><br><span class="line"></span><br><span class="line">U&apos;A&apos;// char32_t</span><br><span class="line"></span><br><span class="line">u8&apos;A&apos;// utf-8</span><br><span class="line">u8&quot;abcd&quot;</span><br></pre></td></tr></table></figure><h3 id="原始字符串"><a class="markdownIt-Anchor" href="#原始字符串"></a> 原始字符串</h3><p>不需要处理转义字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R&quot;1234\n&quot;</span><br></pre></td></tr></table></figure><h3 id="格式化输出"><a class="markdownIt-Anchor" href="#格式化输出"></a> 格式化输出</h3><p>流操作符定义在2个头文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iomanip.h</span><br><span class="line">ios.h//ios头文件已经被iostream头文件包含,该头文件中的操纵符不带任何参数</span><br></pre></td></tr></table></figure><h4 id="iosh"><a class="markdownIt-Anchor" href="#iosh"></a> ios.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::dec;// 十进制输出</span><br><span class="line">std::hex;// 十六进制输出</span><br><span class="line">std::oct;// 八进制输出</span><br><span class="line"></span><br><span class="line">std::fixed;// 以固定精度形式输出</span><br><span class="line">std::scientific;// 以科学计数法形式输出</span><br><span class="line">std::hexfloat;// 以十六进制浮点形式输出</span><br><span class="line">std::defaultfloat; // 以默认形式输出</span><br></pre></td></tr></table></figure><h4 id="iomaniph"><a class="markdownIt-Anchor" href="#iomaniph"></a> iomanip.h</h4><p>iomanip的操纵符需要传递一个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::setw(n);//改变输出域的宽度</span><br><span class="line">std::setprecision(n)//改变浮点数的精度</span><br><span class="line"></span><br><span class="line">//改变填空字符,当setw的输出域宽度大于输出值的宽度时,默认的填空字符是空格,可以用setfill(ch)改变这个填空字符</span><br><span class="line">std::setfill(ch)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; setprecision(2) &lt;&lt; 3.1415926 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; setw(10) &lt;&lt; 3.1415926 &lt;&lt; endl</span><br><span class="line">cout &lt;&lt; setw(10) &lt;&lt; setfill(&apos;-&apos;) &lt;&lt; 3.1415926 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">3.1</span><br><span class="line">3.1</span><br><span class="line">----------3.1</span><br></pre></td></tr></table></figure><h3 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换"></a> 强制类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(类型) 值</span><br><span class="line">(int)123;</span><br><span class="line"></span><br><span class="line">static_cast&lt;类型&gt;值</span><br><span class="line">static_cast&lt;int&gt;123;</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a class="markdownIt-Anchor" href="#类型别名"></a> 类型别名</h3><p>可以用关键字using给一个数据类型起另外的名字,称为<strong>类型别名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using 别名 = 类型;</span><br><span class="line"></span><br><span class="line">using  INT = int;</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220223002707798.png" alt="image-20220223002707798"></p><p>上面的意思是 如果定义了 USING_COMPILER_A则执行下面这部分，否则则执行另外这部分。</p><h3 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h3><p>不同的枚举类型的值是不能相互比较或赋值的 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum class Day&#123;Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday&#125;;</span><br><span class="line"></span><br><span class="line">Day d&#123;Day::Tuesday&#125;;//定义一个Day类型的d变量并初始值为Tuesday</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数&quot;&gt;&lt;/a&gt; 函数&lt;/h3&gt;
&lt;p&gt;每个c++程序都从main函数开始执行&lt;/p&gt;
&lt;p&gt;函数的定义格式:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;
      
    
    </summary>
    
      <category term="cpp17从入门到精通" scheme="https://xiaowuyoucy.github.io/categories/cpp17%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>g++使用</title>
    <link href="https://xiaowuyoucy.github.io/2022/02/10/linux000g%E5%8A%A0%E5%8A%A0%E4%BD%BF%E7%94%A8/"/>
    <id>https://xiaowuyoucy.github.io/2022/02/10/linux000g加加使用/</id>
    <published>2022-02-09T17:01:38.000Z</published>
    <updated>2022-02-09T17:17:08.065Z</updated>
    
    <content type="html"><![CDATA[<p>g++是GNU组织推出的C++编译器。它不但可以用来编译传统的C++程序，也可以用来编译现代C++，比如<code>C++11/14</code>等。</p><p>g++的用法和gcc类似，编译C++的时候比gcc更简单，因为它会自动链接到C++标准库，而不像gcc需要手工指定。</p><p>g++编译程序的内部过程和gcc一样，也要经过4个阶段：预处理、编译、汇编和链接。</p><p>g++的基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ [选项] 准备编译的文件 [选项] [目标文件]</span><br></pre></td></tr></table></figure><h3 id="编译单个源文件"><a class="markdownIt-Anchor" href="#编译单个源文件"></a> 编译单个源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -o test</span><br></pre></td></tr></table></figure><p>test.cpp为需要编译的源文件，test为输出的可执行目录</p><h3 id="编译多个源文件"><a class="markdownIt-Anchor" href="#编译多个源文件"></a> 编译多个源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ testspeaker.cpp speaker.cpp -o testspeaker</span><br></pre></td></tr></table></figure><p>testspeaker.cpp speaker.cpp 需要编译的2个源文件</p><h3 id="更多参数详解"><a class="markdownIt-Anchor" href="#更多参数详解"></a> 更多参数详解</h3><p><strong>-E</strong><br>只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E test.cpp &gt; test.txt</span><br></pre></td></tr></table></figure><p><strong>-S</strong><br>只激活预处理和编译，就是指把文件编译成为汇编代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S test.cpp</span><br></pre></td></tr></table></figure><p>他将生成.s的汇编代码，你可以用文本编辑器察看</p><p><strong>-c</strong><br>只激活预处理,编译,和汇编,也就是他只把程序做成obj文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c</span><br></pre></td></tr></table></figure><p>他将生成.o的obj文件</p><h3 id="目录选项"><a class="markdownIt-Anchor" href="#目录选项"></a> 目录选项</h3><p><code>-Wl:rpath</code>,添加运行时库路径<br><code>-Wl:rpath</code>, 后面也是路径，运行的时候用。这条编译指令会在编译时记录到target文件中，所以编译之后的target文件在执行时会按这里给出的路径去找库文件。</p><p>如：<code>-Wl:rpath=/home/hello/lib</code></p><p>表示将<code>/home/hello/lib</code>目录作为程序运行时第一个寻找库文件的目录，程序寻找顺序是：<code>/home/hello/lib–&gt;/usr/lib–&gt;/usr/local/lib。</code></p><p>可以加多个包含路径，程序在运行时的寻找顺序为添加的顺序。</p><p><code>-L</code>,添加链接库路径<br><code>-L</code>后跟路径，告诉链接器从哪找库(.so文件)，只有在链接时会用到。</p><p>如：<code>-L /home/hello/lib</code></p><p>表示将<code>/home/hello/lib</code>目录作为第一个寻找库文件的目录，寻找顺序是：<code>/home/hello/lib–&gt;/usr/lib–&gt;/usr/local/lib</code>。</p><p>可以加多个包含路径，链接器的寻找顺序为添加的顺序。</p><p><code>-l</code>,添加引用链接库<br><code>-l</code> 在链接时用到，它的作用是告诉链接器，要用到哪个库。 如：<code>-l pthread</code></p><p>告诉链接器(linker)，程序需要链接pthread这个库,这里的pthread是库名不是文件名，<a href="http://xn--libpthread-0m4p18as1q4ojs42e4gcqyhhn4r.so" target="_blank" rel="noopener">具体来说文件句是libpthread.so</a></p><p><code>-I</code>,添加包含路径<br><code>-I</code>在编译时用，告诉编译器去哪个路径下找文件</p><p>如：<code>-I /home/hello/include</code></p><p>表示将<code>/home/hello/include</code>目录作为第一个寻找头文件的目录。</p><p>编译器的寻找顺序是：<code>/home/hello/include–&gt;/usr/include–&gt;/usr/local/include</code>。如果在<code>/home/hello/include</code>中有个文件hello.h，则在程序中用#include就能引用到这个文件。</p><p>可以加多个包含路径，编译器的寻找顺序为添加的顺序。</p><h3 id="调试选项"><a class="markdownIt-Anchor" href="#调试选项"></a> 调试选项</h3><p><code>-g</code><br>只是编译器，在编译的时候，产生调试信息。</p><p><code>-gstabs</code><br>此选项以stabs格式声称调试信息,但是不包括gdb调试信息.</p><p><code>-gstabs+</code><br>此选项以stabs格式声称调试信息,并且包含仅供gdb使用的额外调试信息.</p><p><code>-ggdb</code><br>此选项将尽可能的生成gdb的可以使用的调试信息.</p><p><code>-glevel</code><br>请求生成调试信息，同时用level指出需要多少信息，默认的level值是2<br>链接选项</p><p><code>-static</code>此选项将禁止使用动态库。<br>优点：程序运行不依赖于其他库</p><p>缺点：文件比较大</p><p><code>-shared</code> 指定生成动态链接库<br>优点：生成文件比较小</p><p>缺点：运行时需要系统提供动态库</p><p><code>-symbolic</code> 建立共享目标文件的时候,把引用绑定到全局符号上.<br>对所有无法解析的引用作出警告(除非用连接编辑选项 <code>-Xlinker -z -Xlinker defs</code>取代)。</p><p>注：只有部分系统支持该选项.</p><h3 id="错误与警告"><a class="markdownIt-Anchor" href="#错误与警告"></a> 错误与警告</h3><p><code>-Wall</code><br>一般使用该选项，允许发出GCC能够提供的所有有用的警告。也可以用-W{warning}来标记指定的警告。</p><p><code>-pedantic</code><br>允许发出ANSI/ISO C标准所列出的所有警告</p><p><code>-pedantic-errors</code><br>允许发出ANSI/ISO C标准所列出的错误</p><p><code>-werror</code><br>把所有警告转换为错误，以在警告发生时中止编译过程</p><p><code>-w</code><br>关闭所有警告,建议不要使用此项<br>预处理选项</p><p><code>-Dmacro</code><br>相当于C语言中的#define macro</p><p><code>-Dmacro=defn</code><br>相当于C语言中的#define macro=defn</p><p><code>-Umacro</code><br>相当于C语言中的#undef macro</p><p><code>-undef</code><br>取消对任何非标准宏的定义<br>其他选项</p><p><code>-o</code><br>制定目标名称,缺省的时候,g++编译出来的文件是a.out</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-O</span><br><span class="line">-O0</span><br><span class="line">-O1</span><br><span class="line">-O2</span><br><span class="line">-O3</span><br></pre></td></tr></table></figure><p>编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高</p><p><code>-fpic</code><br>编译器就生成位置无关目标码.适用于共享库(shared library).</p><p><code>-fPIC</code><br>编译器就输出位置无关目标码.适用于动态连接(dynamic linking),即使分支需要大范围转移.</p><p><code>-v</code><br>显示详细的编译、汇编、连接命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;g++是GNU组织推出的C++编译器。它不但可以用来编译传统的C++程序，也可以用来编译现代C++，比如&lt;code&gt;C++11/14&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;g++的用法和gcc类似，编译C++的时候比gcc更简单，因为它会自动链接到C++标准库，而不像gcc需要手
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>网络配置2</title>
    <link href="https://xiaowuyoucy.github.io/2022/02/08/linux000%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE2/"/>
    <id>https://xiaowuyoucy.github.io/2022/02/08/linux000网络配置2/</id>
    <published>2022-02-08T10:43:17.000Z</published>
    <updated>2022-02-08T10:47:48.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu1604-命令行配置网络"><a class="markdownIt-Anchor" href="#ubuntu1604-命令行配置网络"></a> Ubuntu16.04 命令行配置网络</h1><h3 id="1-切换root"><a class="markdownIt-Anchor" href="#1-切换root"></a> 1. 切换root</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line"> </span><br><span class="line">sudo passwd root #首次需给root配置密码</span><br></pre></td></tr></table></figure><h3 id="2-查看网卡信息"><a class="markdownIt-Anchor" href="#2-查看网卡信息"></a> 2. 查看网卡信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure><p>看见如eth0或enp5s0或ens33或ens192等就可以，比如我的是enp3s0</p><h3 id="3-配置系统网络"><a class="markdownIt-Anchor" href="#3-配置系统网络"></a> 3. 配置系统网络</h3><p>网络接口配置文件: <code>/etc/network/interfaces</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#无需改动</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line">#添加以下：</span><br><span class="line">auto enp3s0   #开机自动连接网络(enp3s0 为网卡名称,ifconfig -a看自己的)</span><br><span class="line"> </span><br><span class="line">iface enp3s0 inet static  #static表示使用固定ip，dhcp表述使用动态ip</span><br><span class="line"> </span><br><span class="line">address 192.168.1.84      #设置ip地址</span><br><span class="line"> </span><br><span class="line">netmask 255.255.255.0     #设置子网掩码</span><br><span class="line"> </span><br><span class="line">gateway 192.168.1.1       #设置网关</span><br><span class="line"> </span><br><span class="line">dns-nameservers 8.8.8.8   #设置DNS,谷歌dns</span><br><span class="line">#dns-nameservers 202.106.0.20  北京市联通dns</span><br></pre></td></tr></table></figure><h3 id="4-重启网络服务"><a class="markdownIt-Anchor" href="#4-重启网络服务"></a> 4. 重启网络服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service networking restart</span><br></pre></td></tr></table></figure><p>然后ifconfig 查看ip信息</p><p><strong>没效果就 reboot重启电脑</strong></p><p><strong><code>ping www.baidu.com</code> 如下已连通</strong></p><p><img src="/images/javawz/20200515111943424.png" alt="img"></p><p>OK.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu1604-命令行配置网络&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ubuntu1604-命令行配置网络&quot;&gt;&lt;/a&gt; Ubuntu16.04 命令行配置网络&lt;/h1&gt;
&lt;h3 id=&quot;1-切换root&quot;&gt;&lt;a class
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>网络配置</title>
    <link href="https://xiaowuyoucy.github.io/2022/02/08/linux000%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>https://xiaowuyoucy.github.io/2022/02/08/linux000网络配置/</id>
    <published>2022-02-08T10:24:04.000Z</published>
    <updated>2022-02-08T10:41:19.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu1804的网络配置静态ip和动态ip"><a class="markdownIt-Anchor" href="#ubuntu1804的网络配置静态ip和动态ip"></a> Ubuntu18.04的网络配置（静态IP和动态IP）</h1><h3 id="查看ubuntu系统的版本号命令"><a class="markdownIt-Anchor" href="#查看ubuntu系统的版本号命令"></a> 查看Ubuntu系统的版本号命令</h3><p><code>cat /etc/issue</code>或者 <code>lsb_release -a</code></p><h3 id="切换root命令"><a class="markdownIt-Anchor" href="#切换root命令"></a> 切换root命令</h3><p><code>sudo -i</code> 或者 <code>sudo -s</code></p><p><strong>提示：以下操作均在root用户下进行，如在普通用户，请自行加上sudo！</strong></p><h3 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h3><p>Ubuntu从17.10开始，已放弃在<code>/etc/network/interfaces</code>里配置IP地址，即使配置也不会生效，而是改成netplan方式，配置写在<code>/etc/netplan/01-netcfg.yaml</code>或者类似名称的yaml文件里，如下：</p><p>VMware14里安装的Ubuntu18.04.1 Desktop版本下的配置文件名：</p><p><img src="/images/javawz/1404518-20200614223934337-1576886527.png" alt="img"></p><p>VMware14里安装的Ubuntu18.04.4 Server版本下的配置文件名：</p><p><img src="/images/javawz/1404518-20200614224306528-1449186048.png" alt="img"></p><p>阿里云Ubuntu18.04.4 Server版本下的配置文件名：</p><p><img src="/images/javawz/1404518-20200614224537679-1678462440.png" alt="img"></p><h3 id="下面以vmware14里安装的ubuntu-18044-server版本为例vmware网络连接选择的桥接模式"><a class="markdownIt-Anchor" href="#下面以vmware14里安装的ubuntu-18044-server版本为例vmware网络连接选择的桥接模式"></a> 下面以VMware14里安装的Ubuntu 18.04.4 Server版本为例（VMware网络连接选择的桥接模式）</h3><h4 id="一-配置静态ip地址"><a class="markdownIt-Anchor" href="#一-配置静态ip地址"></a> 一、配置静态IP地址</h4><p>打开配置文件：<code>vim /etc/netplan/50-cloud-init.yaml</code>，写入以下配置内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        ens33:                  # 配置的网卡名称</span><br><span class="line">            dhcp4: no           # 关闭dhcp4</span><br><span class="line">            dhcp6: no           # 关闭dhcp6</span><br><span class="line">            addresses: [192.168.0.120/24]       # 设置本机IP地址及掩码</span><br><span class="line">            gateway4: 192.168.0.1               # 设置网关</span><br><span class="line">            nameservers:</span><br><span class="line">                    addresses: [114.114.114.114, 8.8.8.8]       # 设置DNS</span><br><span class="line">    version: 2</span><br></pre></td></tr></table></figure><p>截图</p><p><img src="/images/javawz/1404518-20200614231300863-237073454.png" alt="img"></p><p>配置完成后，保存并退出，执行<code>netplan apply</code>命令可以让配置直接生效</p><p>以前的重启网络服务命令 <code>/etc/init.d/networking restart</code> 或者 <code>service networking restar</code> 都是无法使用的（做测试时发现18.04.1的Desktop版本还是可以使用的，但/etc/netplan/下的yaml配置文件并不会生效）。</p><h4 id="验证是否配置成功"><a class="markdownIt-Anchor" href="#验证是否配置成功"></a> 验证是否配置成功</h4><p><code>ifconfig -a</code></p><p><img src="/images/javawz/1404518-20200614222201955-990276377.png" alt="img"></p><h4 id="验证是否能ping通外网"><a class="markdownIt-Anchor" href="#验证是否能ping通外网"></a> 验证是否能ping通外网</h4><p><code>ping -c 4 baidu.com</code></p><p><img src="/images/javawz/1404518-20200614222251773-819407962.png" alt="img"></p><h4 id="二-配置动态ip地址"><a class="markdownIt-Anchor" href="#二-配置动态ip地址"></a> 二、配置动态IP地址</h4><p>打开配置文件：<code>vim /etc/netplan/50-cloud-init.yaml</code>，写入以下配置内容（其实只需要开启dhcp就可以）：</p><p><img src="/images/javawz/1404518-20200614230042002-1549179355.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">network: </span><br><span class="line">   ethernets: </span><br><span class="line">       ens33: #配置网卡名称</span><br><span class="line">           dhcp4: true#开启dhcp4</span><br><span class="line">           dhcp4: true#开启dhcp4</span><br><span class="line">   version: 2</span><br></pre></td></tr></table></figure><p>保存并退出，执行 <code>netplan apply</code>命令让配置生效，用上述方法验证是否配置成功！</p><p>这里顺便也记录下Ubuntu 18.04.1 Desktop版本的配置，和18.04.4 Server版本略有区别（VMware网络连接选择的也是桥接模式）</p><p><code>vim /etc/netplan/01-network-manager-all.yaml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  # renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">          ens33:</span><br><span class="line">                  dhcp4: no</span><br><span class="line">                  dhcp6: no</span><br><span class="line">                  addresses: [192.168.0.130/24]</span><br><span class="line">                  gateway4: 192.168.0.1</span><br><span class="line">                  nameservers:</span><br><span class="line">                          addresses: [114.114.114.144, 8.8.8.8]</span><br></pre></td></tr></table></figure><p>截图</p><p><img src="/images/javawz/1404518-20200615081736202-1829516241.png" alt="img"></p><h3 id="这里有几点需要注意"><a class="markdownIt-Anchor" href="#这里有几点需要注意"></a> 这里有几点需要注意：</h3><p>1、Ubuntu 18.04.1 Desktop版本配置的时候需要将renderer: NetworkManager一行注释掉，否则netplan命令无法生效；</p><p>2、配置信息要严格按照yaml语言的语法格式，每个配置项使用空格缩进表示层级关系；<strong>缩进不允许使用tab，只允许空格；缩进的空格数不重要，只要相同层级的元素左对齐即可，否则netplan命令会报错；</strong></p><p>3、对应配置项后跟着冒号，之后要接个空格，否则netplan命令也会报错。</p><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><p>重新启停以太网卡命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33 down//关闭</span><br><span class="line"></span><br><span class="line">ifconfig ens33 up//开启</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu1804的网络配置静态ip和动态ip&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ubuntu1804的网络配置静态ip和动态ip&quot;&gt;&lt;/a&gt; Ubuntu18.04的网络配置（静态IP和动态IP）&lt;/h1&gt;
&lt;h3 id
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/31/linux084%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/31/linux084网络基础/</id>
    <published>2022-01-31T08:50:57.000Z</published>
    <updated>2022-03-26T10:43:52.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="协议的概念"><a class="markdownIt-Anchor" href="#协议的概念"></a> 协议的概念</h3><h4 id="什么是协议"><a class="markdownIt-Anchor" href="#什么是协议"></a> 什么是协议</h4><p>从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。</p><p>假设，A、B双方欲传输文件。规定：</p><p>第一次，传输文件名，接收方接收到文件名，应答OK给传输方；</p><p>第二次，发送文件的尺寸，接收方接收到该数据再次应答一个OK；</p><p>第三次，传输文件内容。同样，接收方接收数据完成后应答OK表示文件内容接收成功。</p><p>由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形成了一个最简单的数据传输规则。双方都按此规则发送、接收数据。A、B之间达成的这个相互遵守的规则即为协议。</p><p>这种仅在A、B之间被遵守的协议称之为<strong>原始协议</strong>。当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为一个<strong>标准协议</strong>。最早的ftp协议就是由此衍生而来。</p><p>TCP协议注重数据的传输。http协议着重于数据的解释。</p><h4 id="典型协议"><a class="markdownIt-Anchor" href="#典型协议"></a> 典型协议</h4><p>传输层 常见协议有TCP/UDP协议。</p><p>应用层 常见的协议有HTTP协议，FTP协议。</p><p>网络层 常见协议有IP协议、ICMP协议、IGMP协议。</p><p>网络接口层 常见协议有ARP协议、RARP协议。</p><p>TCP<a href="http://baike.baidu.com/view/544903.htm" target="_blank" rel="noopener">传输控制协议</a>（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的<a href="http://baike.baidu.com/view/239605.htm" target="_blank" rel="noopener">传输层</a>通信协议。</p><p>UDP用户数据报协议（User Datagram Protocol）是<a href="http://baike.baidu.com/view/113948.htm" target="_blank" rel="noopener">OSI</a>参考模型中一种无连接的<a href="http://baike.baidu.com/view/239605.htm" target="_blank" rel="noopener">传输层</a>协议，提供面向事务的简单不可靠信息传送服务。</p><p>HTTP<a href="http://baike.baidu.com/view/468465.htm" target="_blank" rel="noopener">超文本传输协议</a>（Hyper Text Transfer Protocol）是<a href="http://baike.baidu.com/view/6825.htm" target="_blank" rel="noopener">互联网</a>上应用最为广泛的一种<a href="http://baike.baidu.com/view/16603.htm" target="_blank" rel="noopener">网络协议</a>。</p><p>FTP文件传输协议（File Transfer Protocol）</p><p>IP协议是<a href="http://baike.baidu.com/view/1706.htm" target="_blank" rel="noopener">因特网</a>互联协议（Internet Protocol）</p><p>ICMP协议是Internet控制<a href="http://baike.baidu.com/view/175122.htm" target="_blank" rel="noopener">报文</a>协议（Internet Control Message Protocol）它是<a href="http://baike.baidu.com/view/2221037.htm" target="_blank" rel="noopener">TCP/IP协议族</a>的一个子协议，用于在IP<a href="http://baike.baidu.com/view/23880.htm" target="_blank" rel="noopener">主机</a>、<a href="http://baike.baidu.com/view/18655.htm" target="_blank" rel="noopener">路由</a>器之间传递控制消息。</p><p>IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。</p><p><a href="http://baike.baidu.com/view/32698.htm" target="_blank" rel="noopener">ARP</a>协议是正向<a href="http://baike.baidu.com/view/149421.htm" target="_blank" rel="noopener">地址解析协议</a>（Address Resolution Protocol），通过已知的IP，寻找对应主机的<a href="http://baike.baidu.com/view/69334.htm" target="_blank" rel="noopener">MAC地址</a>。</p><p><a href="http://baike.baidu.com/view/32772.htm" target="_blank" rel="noopener">RARP</a>是反向地址转换协议，通过MAC地址确定IP地址。</p><h3 id="网络应用程序设计模式"><a class="markdownIt-Anchor" href="#网络应用程序设计模式"></a> 网络应用程序设计模式</h3><h4 id="cs模式"><a class="markdownIt-Anchor" href="#cs模式"></a> C/S模式</h4><p>​传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p><p>优点:</p><ol><li>协议选用灵活</li><li>可以提前缓存数据。</li></ol><p>缺点:</p><pre><code> 1. 对用户的安全构成威胁   2. 开发工作量较大，调试困难</code></pre><h4 id="bs模式"><a class="markdownIt-Anchor" href="#bs模式"></a> B/S模式</h4><p>浏览器()/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p><p>优点:</p><ol><li>比较安全</li><li>开发工作简洁,只需要开发服务端</li><li>跨平台</li></ol><p>缺点:</p><ol><li>要求使用http协议</li><li>不可以提前缓存数据</li></ol><h3 id="分层模型"><a class="markdownIt-Anchor" href="#分层模型"></a> 分层模型</h3><h4 id="osi七层模型"><a class="markdownIt-Anchor" href="#osi七层模型"></a> OSI七层模型</h4><p><img src="/images/javawz/image-20220131174614011.png" alt="image-20220131174614011"></p><ol><li><p><strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做<strong>比特</strong>。</p></li><li><p><strong>数据链路层</strong>：定义了如何让格式化数据以<strong>帧</strong>为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1</p></li><li><p><strong>网络层</strong>：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。<strong>数据包</strong></p></li><li><p><strong>传输层</strong>：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做<strong>段</strong>。</p></li><li><p><strong>会话层</strong>：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</p></li><li><p><strong>表示层</strong>：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</p></li><li><p><strong>应用层</strong>：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</p></li></ol><h4 id="tcpip四层模型"><a class="markdownIt-Anchor" href="#tcpip四层模型"></a> TCP/IP四层模型</h4><p>TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示：</p><p><img src="/images/javawz/image-20220131174756807.png" alt="image-20220131174756807"></p><p>一般在应用开发过程中，讨论最多的是TCP/IP模型。</p><h3 id="通信过程"><a class="markdownIt-Anchor" href="#通信过程"></a> 通信过程</h3><p>两台计算机通过TCP/IP协议通讯的过程如下所示：</p><p><img src="/images/javawz/image-20220131175741703.png" alt="image-20220131175741703"></p><p>上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示：</p><p><img src="/images/javawz/image-20220131180004435.png" alt="image-20220131180004435"></p><p>链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、<strong>数据差错校验</strong>等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。</p><p>网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter-net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。</p><p>网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。</p><p>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。</p><p>UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</p><p>目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：</p><p><img src="/images/javawz/image-20220131180029314.png" alt="image-20220131180029314"></p><p>以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。</p><p>虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。</p><h3 id="协议格式"><a class="markdownIt-Anchor" href="#协议格式"></a> 协议格式</h3><h4 id="数据包封装"><a class="markdownIt-Anchor" href="#数据包封装"></a> 数据包封装</h4><p>传输层及其以下的机制由内核提供，应用层由用户进程提供（后面将介绍如何使用socket API编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示：</p><p><img src="/images/javawz/image-20220131180149068.png" alt="image-20220131180149068"></p><p>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p><h4 id="以太网帧格式"><a class="markdownIt-Anchor" href="#以太网帧格式"></a> 以太网帧格式</h4><p>以太网的帧格式如下所示：</p><p><img src="/images/javawz/image-20220131180221986-1644317422126.png" alt="image-20220131180221986"></p><p>其中的<strong>源地址和目的地址</strong>是指网卡的<strong>硬件地址</strong>（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，“HWaddr 00:15:F2:14:9E:3F”部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。</p><p>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。<strong>最大值1500称为以太网的最大传输单元（MTU）</strong>，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。</p><h4 id="arp数据报格式"><a class="markdownIt-Anchor" href="#arp数据报格式"></a> ARP数据报格式</h4><p>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。</p><p>每台主机都维护一个ARP缓存表，可以用<code>arp -a</code>命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。想一想，为什么表项要有过期时间而不是一直有效？</p><p>ARP数据报的格式如下所示：</p><p><img src="/images/javawz/image-20220131192510328.png" alt="image-20220131192510328"></p><p>源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为1表示ARP请求，op字段为2表示ARP应答。</p><p><img src="/images/javawz/image-20220131230905439.png" alt="image-20220131230905439"></p><p><img src="/images/javawz/image-20220131231031294.png" alt="image-20220131231031294"></p><p>路由器会把arp数据报发给所有的机器，然后每个机器拿到后会检查接收端的ip是不是自己的ip，如果不是则扔掉</p><p>ARP数据报：获取下一条的mac地址</p><p><img src="/images/javawz/image-20220131232110833.png" alt="image-20220131232110833"></p><p>TTL:表示当前还可以进行多少跳，每次到达自己这里TTL都会减一</p><p>数据包到达路由器后会进行解封装,先解数据帧首尾,然后解网络层，然后再封装自己的ip和自己的mac地址，和目标mac地址，最后发出去，每次结果路由器都会重复上面步骤，直到到达目的pc</p><h4 id="ip段格式"><a class="markdownIt-Anchor" href="#ip段格式"></a> IP段格式</h4><p><img src="/images/javawz/image-20220201173046589.png" alt="image-20220201173046589"></p><p>IP数据报的首部长度和数据长度都是可变长的，<strong>但总是4字节的整数倍</strong>。对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，<strong>最小值为5</strong>，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说<strong>首部长度最大是60字节</strong>。8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大?吐量、最大可靠性、最小成本），还有一个位总是0。总长度是整个数据报（包括IP首部和IP层payload）的字节数。每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。3位标志和13位片偏移用于分片。TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。</p><p>想一想，前面讲了以太网帧中的最小数据长度为46字节，不足46字节的要用填充字节补上，那么如何界定这46字节里前多少个字节是IP、ARP或RARP数据报而后面是填充字节？</p><h3 id="udp数据报格式"><a class="markdownIt-Anchor" href="#udp数据报格式"></a> UDP数据报格式</h3><p><img src="/images/javawz/image-20220201173320717.png" alt="image-20220201173320717"></p><p>端口号表示指定的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">下面分析一帧基于UDP的TFTP协议帧。</span><br><span class="line">以太网首部</span><br><span class="line">0000: 00 05 5d 67 d0 b1 00 05 5d 61 58 a8 08 00</span><br><span class="line">IP首部</span><br><span class="line">0000: 45 00</span><br><span class="line">0010: 00 53 93 25 00 00 80 11 25 ec c0 a8 00 37 c0 a8</span><br><span class="line">0020: 00 01</span><br><span class="line">UDP首部</span><br><span class="line">0020： 05 d4 00 45 00 3f ac 40</span><br><span class="line">TFTP协议</span><br><span class="line">0020: 00 01 &apos;c&apos;&apos;:&apos;&apos;\&apos;&apos;q&apos;</span><br><span class="line">0030: &apos;w&apos;&apos;e&apos;&apos;r&apos;&apos;q&apos;&apos;.&apos;&apos;q&apos;&apos;w&apos;&apos;e&apos;00 &apos;n&apos;&apos;e&apos;&apos;t&apos;&apos;a&apos;&apos;s&apos;&apos;c&apos;&apos;i&apos;</span><br><span class="line">0040: &apos;i&apos;00 &apos;b&apos;&apos;l&apos;&apos;k&apos;&apos;s&apos;&apos;i&apos;&apos;z&apos;&apos;e&apos;00 &apos;5&apos;&apos;1&apos;&apos;2&apos;00 &apos;t&apos;&apos;i&apos;</span><br><span class="line">0050: &apos;m&apos;&apos;e&apos;&apos;o&apos;&apos;u&apos;&apos;t&apos;00 &apos;1&apos;&apos;0&apos;00 &apos;t&apos;&apos;s&apos;&apos;i&apos;&apos;z&apos;&apos;e&apos;00 &apos;0&apos;</span><br><span class="line">0060: 00以太网首部：源MAC地址是00:05:5d:61:58:a8，目的MAC地址是00:05:5d:67:d0:b1，上层协议类型0x0800表示IP。</span><br><span class="line">IP首部：每一个字节0x45包含4位版本号和4位首部长度，版本号为4，即IPv4，首部长度为5，说明IP首部不带有选项字段。服务类型为0，没有使用服务。16位总长度字段（包括IP首部和IP层payload的长度）为0x0053，即83字节，加上以太网首部14字节可知整个帧长度是97字节。IP报标识是0x9325，标志字段和片偏移字段设置为0x0000，就是DF=0允许分片，MF=0此数据报没有更多分片，没有分片偏移。TTL是0x80，也就是128。上层协议0x11表示UDP协议。IP首部校验和为0x25ec，源主机IP是c0 a8 00 37（192.168.0.55），目的主机IP是c0 a8 00 01（192.168.0.1）。</span><br><span class="line">UDP首部：源端口号0x05d4（1492）是客户端的端口号，目的端口号0x0045（69）是TFTP服务的well-known端口号。UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay-load的长度。UDP首部和UDP层payload的校验和为0xac40。</span><br><span class="line">TFTP是基于文本的协议，各字段之间用字节0分隔，开头的00 01表示请求读取一个文件，接下来的各字段是：</span><br><span class="line">c:\qwerq.qwe</span><br><span class="line">netascii</span><br><span class="line">blksize 512</span><br><span class="line">timeout 10</span><br><span class="line">tsize 0</span><br></pre></td></tr></table></figure><p>一般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器，客户端主动发起请求（上面的例子就是客户端发起的请求帧），而服务器被动地等待、接收和应答请求。客户端的IP地址和端口号唯一标识了该主机上的TFTP客户端进程，服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程，由于客户端是主动发起请求的一方，它必须知道服务器的IP地址和TFTP服务进程的端口号，所以，一些常见的网络协议有默认的服务器端口，例如HTTP服务默认TCP协议的80端口，FTP服务默认TCP协议的21端口，TFTP服务默认UDP协议的69端口（如上例所示）。在使用客户端程序时，必须指定服务器的主机名或IP地址，如果不明确指定端口号则采用默认端口，请读者查阅ftp、tftp等程序的man page了解如何指定端口号。/etc/services中列出了所有well-known的服务端口和对应的传输层协议，这是由IANA（Internet Assigned Numbers Authority）规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务。</p><p>很多服务有well-known的端口号，然而客户端程序的端口号却不必是well-known的，往往是每次运行客户端程序时由系统自动分配一个空闲的端口号，用完就释放掉，称为ephemeral的端口号，想想这是为什么？</p><p>前面提过，UDP协议不面向连接，也不保证传输的可靠性，例如：</p><p>发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。</p><p>接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。</p><p>通常接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。</p><p>因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。例如，基于UDP的TFTP协议一般只用于传送小文件（所以才叫trivial的ftp），而基于TCP的FTP协议适用于各种文件的传输。TCP协议又是如何用面向连接的服务来代替应用程序解决传输的可靠性问题呢。</p><h4 id="tcp数据报格式"><a class="markdownIt-Anchor" href="#tcp数据报格式"></a> TCP数据报格式</h4><p><img src="/images/javawz/image-20220201173716334.png" alt="image-20220201173716334"></p><p>与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。32位序号、32位确认序号、窗口大小稍后详细解释。4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。URG、ACK、PSH、RST、SYN、FIN是六个控制位，本节稍后将解释SYN、ACK、FIN、RST四个位，其它位的解释从略。16位检验和将TCP协议头和数据都计算在内。紧急指针和各种选项的解释从略。</p><h3 id="nat映射"><a class="markdownIt-Anchor" href="#nat映射"></a> NAT映射</h3><p><img src="/images/javawz/image-20220201173928063.png" alt="image-20220201173928063"></p><p>A机器发送数据包给服务器,首先数据包经过路由器,然后路由器会一个端口号和自己的ip再和A机器的ip成为映射关系,服务器收到后回A机器数据包,目的ip的地址是写路由器的ip,端口号写路由器创建出来的那个端口号,路由器收到数据包后会在NAT映射表中查找端口号对应的ip,找到后再发给A机器</p><h3 id="打洞机制"><a class="markdownIt-Anchor" href="#打洞机制"></a> 打洞机制</h3><p><img src="/images/javawz/image-20220201180619648.png" alt="image-20220201180619648"></p><p>两台机器在不同的局域网中进行直接通信,需要进行nat映射和打洞机制.</p><h3 id="socket编程"><a class="markdownIt-Anchor" href="#socket编程"></a> Socket编程</h3><h4 id="套接字概念"><a class="markdownIt-Anchor" href="#套接字概念"></a> 套接字概念</h4><p>Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。</p><p>既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p><p>套接字的内核实现较为复杂，不宜在学习初期深入学习。</p><p>在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p><p>套接字通信原理如下图所示：</p><p><img src="/images/javawz/image-20220201193432501.png" alt="image-20220201193432501"></p><p>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。</p><p>TCP/IP协议最早在BSD UNIX上实现，为TCP/IP协议设计的应用层编程接口称为socket API。本章的主要内容是socket API，主要介绍TCP协议的函数接口，最后介绍UDP协议和UNIX Domain Socket的函数接口。</p><p><img src="/images/javawz/image-20220201193510324.png" alt="image-20220201193510324"></p><p><img src="/images/javawz/image-20220201193808939.png" alt="image-20220201193808939"></p><h3 id="网络字节序"><a class="markdownIt-Anchor" href="#网络字节序"></a> 网络字节序</h3><p><img src="/images/javawz/image-20220201234457225.png" alt="image-20220201234457225"></p><p>我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发 出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。</p><p>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。例如上一节的UDP段格式，地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。</p><p>为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做<strong>网络字节序和主机字节序的转换</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要包含的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);<span class="comment">//ip本地字节序转换到网络字节序</span></span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);<span class="comment">//端口本地字节序转换到网络字节序</span></span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);<span class="comment">//ip网络字节序转换为本地字节序</span></span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);<span class="comment">//端口网络字节序转换为本地字节序</span></span><br></pre></td></tr></table></figure><p>h表示host，n表示network，l表示32位长整数，s表示16位短整数。</p><p>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</p><h4 id="ip地址转换函数"><a class="markdownIt-Anchor" href="#ip地址转换函数"></a> IP地址转换函数</h4><p>早期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int inet_aton(const char *cp, struct in_addr *inp);</span><br><span class="line">in_addr_t inet_addr(const char *cp);</span><br><span class="line">char *inet_ntoa(struct in_addr in);</span><br><span class="line">只能处理IPv4的ip地址</span><br><span class="line">不可重入函数</span><br><span class="line">注意参数是struct in_addr</span><br></pre></td></tr></table></figure><p>现在：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;<span class="comment">//字符串点分十进制ip转换为网络字节序</span></span><br><span class="line">参数<span class="number">1</span>:AF_INET(ipv4)</span><br><span class="line">      AF_INET6 (ipv6)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//网络字节序ip转换成点分十进制ip字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line">参数<span class="number">1</span>:AF_INET(ipv4)</span><br><span class="line">      AF_INET6 (ipv6)</span><br><span class="line">    </span><br><span class="line">    两个函数错误返回<span class="number">-1</span>并设置errno</span><br></pre></td></tr></table></figure><p>支持IPv4和IPv6</p><p>可重入函数</p><p>其中<code>inet_pton</code>和<code>inet_ntop</code>不仅可以转换IPv4的<code>in_addr</code>，还可以转换IPv6的<code>in6_addr</code>。</p><p>因此函数接口是<code>void *addrptr</code>。</p><h4 id="sockaddr数据结构"><a class="markdownIt-Anchor" href="#sockaddr数据结构"></a> sockaddr数据结构</h4><p>strcut sockaddr 很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p><p><img src="/images/javawz/image-20220201225235077.png" alt="image-20220201225235077"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr &#123;</span><br><span class="line">sa_family_t sa_family; /* address family, AF_xxx */</span><br><span class="line">char sa_data[14];/* 14 bytes of protocol address */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 sudo grep -r &quot;struct sockaddr_in &#123;&quot;  /usr 命令可查看到struct sockaddr_in结构体的定义。一般其默认的存储位置：/usr/include/linux/in.h 文件中。</span><br></pre></td></tr></table></figure><br><p>一般使用这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">__kernel_sa_family_t sin_family; /* Address family */  地址结构类型</span><br><span class="line">__be16 sin_port; /* Port number */端口号</span><br><span class="line">struct in_addr sin_addr;/* Internet address */IP地址</span><br><span class="line">/* Pad to size of `struct sockaddr&apos;. */</span><br><span class="line">unsigned char __pad[__SOCK_SIZE__ - sizeof(short int) -</span><br><span class="line">sizeof(unsigned short int) - sizeof(struct in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct in_addr &#123;/* Internet address. */</span><br><span class="line">__be32 s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in6 &#123;</span><br><span class="line">unsigned short int sin6_family; /* AF_INET6 */</span><br><span class="line">__be16 sin6_port; /* Transport layer port # */</span><br><span class="line">__be32 sin6_flowinfo; /* IPv6 flow information */</span><br><span class="line">struct in6_addr sin6_addr;/* IPv6 address */</span><br><span class="line">__u32 sin6_scope_id; /* scope id (new in RFC2553) */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct in6_addr &#123;</span><br><span class="line">union &#123;</span><br><span class="line">__u8 u6_addr8[16];</span><br><span class="line">__be16 u6_addr16[8];</span><br><span class="line">__be32 u6_addr32[4];</span><br><span class="line">&#125; in6_u;</span><br><span class="line">#define s6_addr in6_u.u6_addr8</span><br><span class="line">#define s6_addr16 in6_u.u6_addr16</span><br><span class="line">#define s6_addr32 in6_u.u6_addr32</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define UNIX_PATH_MAX 108</span><br><span class="line">struct sockaddr_un &#123;</span><br><span class="line">__kernel_sa_family_t sun_family; /* AF_UNIX */</span><br><span class="line">char sun_path[UNIX_PATH_MAX]; /* pathname */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Pv4和IPv6的地址格式定义在<code>netinet/in.h</code>中，IPv4地址用<code>sockaddr_in</code>结构体表示，包括16位端口号和32位IP地址，IPv6地址用<code>sockaddr_in6</code>结构体表示，包括16位端口号、128位IP地址和一些控制字段。UNIX Domain Socket的地址格式定义在<code>sys/un.h</code>中，用<code>sock-addr_un</code>结构体表示。各种socket地址结构体的开头都是相同的，前16位表示整个结构体的长度（并不是所有UNIX的实现都有长度字段，如Linux就没有），后16位表示地址类型。IPv4、IPv6和Unix Domain Socket的地址类型分别定义为常数<code>AF_INET、AF_INET6、AF_UNIX</code>。这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如bind、accept、connect等函数，这些函数的参数应该设计成<code>void *</code>类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有<code>void *</code>类型，因此这些函数的参数都用<code>struct sockaddr *</code>类型表示，在传递参数之前要强制类型转换一下，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">bind(listen_fd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));/* initialize servaddr */</span><br></pre></td></tr></table></figure><h3 id="网络套接字函数"><a class="markdownIt-Anchor" href="#网络套接字函数"></a> 网络套接字函数</h3><h4 id="socket模型创建流程图"><a class="markdownIt-Anchor" href="#socket模型创建流程图"></a> socket模型创建流程图</h4><p><img src="/images/javawz/image-20220201225715684.png" alt="image-20220201225715684"></p><h4 id="socket函数"><a class="markdownIt-Anchor" href="#socket函数"></a> socket函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">domain:</span><br><span class="line">AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址</span><br><span class="line">AF_INET6 与上面类似，不过是来用IPv6的地址</span><br><span class="line">AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</span><br><span class="line">type:</span><br><span class="line">SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</span><br><span class="line">SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</span><br><span class="line">SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</span><br><span class="line">SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</span><br><span class="line">SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</span><br><span class="line">protocol:</span><br><span class="line">传0 表示使用默认协议。</span><br><span class="line">返回值：</span><br><span class="line">成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</span><br></pre></td></tr></table></figure><p><code>socket()</code>打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回<code>-1</code>。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为<code>SOCK_STREAM</code>，表示面向流的传输协议。如果是UDP协议，则type参数指定为<code>SOCK_DGRAM</code>，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。</p><h4 id="bind函数"><a class="markdownIt-Anchor" href="#bind函数"></a> bind函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">sockfd：</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">构造出IP地址加端口号</span><br><span class="line">addrlen:</span><br><span class="line">sizeof(addr)长度</span><br><span class="line">返回值：</span><br><span class="line">成功返回0，失败返回-1, 设置errno</span><br></pre></td></tr></table></figure><p>服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。</p><p>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(6666);</span><br></pre></td></tr></table></figure><p>首先将整个结构体清零，然后设置地址类型为AF_INET，<strong>网络地址为INADDR_ANY，这个宏表示本地的任意IP地址</strong>，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为6666。</p><h4 id="listen函数"><a class="markdownIt-Anchor" href="#listen函数"></a> listen函数</h4><p>表示最多同时能有多少客户端连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">sockfd:</span><br><span class="line">socket文件描述符</span><br><span class="line">backlog:</span><br><span class="line">排队建立3次握手队列和刚刚建立3次握手队列的链接数和</span><br></pre></td></tr></table></figure><p>查看系统默认backlog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br></pre></td></tr></table></figure><p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</p><h4 id="accept函数"><a class="markdownIt-Anchor" href="#accept函数"></a> accept函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">sockdf:</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">传出参数，返回链接客户端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小</span><br><span class="line">返回值：</span><br><span class="line">成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno</span><br></pre></td></tr></table></figure><p>三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。</p><p>我们的服务器程序结构是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line">cliaddr_len = sizeof(cliaddr);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">n = read(connfd, buf, MAXLINE);</span><br><span class="line">......</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭<code>listenfd</code>，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1。</p><h3 id="connect函数"><a class="markdownIt-Anchor" href="#connect函数"></a> connect函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">sockdf:</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">传入参数，指定服务器端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">传入参数,传入sizeof(addr)大小</span><br><span class="line">返回值：</span><br><span class="line">成功返回0，失败返回-1，设置errno</span><br></pre></td></tr></table></figure><h4 id="cs模型-tcp"><a class="markdownIt-Anchor" href="#cs模型-tcp"></a> C/S模型-TCP</h4><p>下图是基于TCP协议的客户端/服务器程序的一般流程：</p><p><img src="/images/javawz/image-20220201230423889.png" alt="image-20220201230423889"></p><p>服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口的状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞等待服务器应答，服务器应答一个SYN-ACK段，客户端收到后从connect()返回，同时应答一个ACK段，服务器收到后从accept()返回。</p><p>数据传输的过程：</p><p>建立连接后，TCP协议提供全双工的通信服务，但是一般的客户端/服务器程序的流程是由客户端主动发起请求，服务器被动处理请求，一问一答的方式。因此，服务器从accept()返回后立刻调用read()，读socket就像读管道一样，如果没有数据到达就阻塞等待，这时客户端调用write()发送请求给服务器，服务器收到后从read()返回，对客户端的请求进行处理，在此期间客户端调用read()阻塞等待服务器的应答，服务器调用write()将处理结果发回给客户端，再次调用read()阻塞等待下一条请求，客户端收到后从read()返回，发送下一条请求，如此循环下去。</p><p>如果客户端没有更多的请求了，就调用close()关闭连接，就像写端关闭的管道一样，服务器的read()返回0，这样服务器就知道客户端关闭了连接，也调用close()关闭连接。注意，任何一方调用close()后，连接的两个传输方向都关闭，不能再发送数据了。如果一方调用shutdown()则连接处于半关闭状态，仍可接收对方发来的数据。</p><p>在学习socket API时要注意应用程序和TCP协议层是如何交互的： 应用程序调用某个socket函数时TCP协议层完成什么动作，比如调用connect()会发出SYN段 应用程序如何知道TCP协议层的状态变化，比如从某个阻塞的socket函数返回就表明TCP协议收到了某些段，再比如read()返回0就表明收到了FIN段</p><h3 id="nc命令"><a class="markdownIt-Anchor" href="#nc命令"></a> nc命令</h3><p>简单的客户端程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc ip地址 端口号</span><br><span class="line">nc 127.0.0.1 6666</span><br><span class="line">nc 127.1 6666</span><br></pre></td></tr></table></figure><h4 id="bzero函数"><a class="markdownIt-Anchor" href="#bzero函数"></a> bzero函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//要包含的头文件</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 作用: 把缓冲区逐字节清零</span><br><span class="line">void bzero(void *s, size_t n);</span><br><span class="line">void *s//指定缓冲区</span><br><span class="line">size_t n//指定缓冲取大小</span><br></pre></td></tr></table></figure><h4 id="server实现"><a class="markdownIt-Anchor" href="#server实现"></a> server实现</h4><p>作用是从客户端读字符，然后将每个字符转换为大写并回送给客户端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ],CLIE_IP[BUFZIZ];</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT); </span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">    cfd = accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client IP: %s  port:%d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), </span><br><span class="line">            ntohs(clie_addr.sin_port));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        write(cfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(cfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client客户端实现"><a class="markdownIt-Anchor" href="#client客户端实现"></a> client客户端实现</h3><p>作用:客户端输入英文小写字符串,并发送给服务端,然后服务端回一串对应的大写英文字符串,最后输出到终端</p><p>如果客户端不绑定端口和ip，操作系统会隐式的帮客户端绑定地址和端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man 7 ip //查看struct sockaddr_in 结构体</span><br><span class="line"></span><br><span class="line">gets函数最好不要使用,因为已经过时了,使用fgets来代替gets</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建一个socket 指定IPv4 TCP*/</span></span><br><span class="line">    sfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化一个地址结构:*/</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));                       <span class="comment">//清零</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;                             <span class="comment">//IPv4协议族</span></span><br><span class="line">    inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr);    <span class="comment">//指定IP 字符串类型转换为网络字节序 参3:传出参数</span></span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);                      <span class="comment">//指定端口 本地转网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*根据地址结构链接指定服务器进程*/</span></span><br><span class="line">    connect(sfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*从标准输入获取数据*/</span></span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">/*将数据写给服务器*/</span></span><br><span class="line">        write(sfd, buf, <span class="built_in">strlen</span>(buf));       <span class="comment">//写个服务器</span></span><br><span class="line">        <span class="comment">/*从服务器读回转换后数据*/</span></span><br><span class="line">        len = read(sfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">/*写至标准输出*/</span></span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*关闭链接*/</span></span><br><span class="line">    close(sfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h3 id="客户端服务器程序分析"><a class="markdownIt-Anchor" href="#客户端服务器程序分析"></a> 客户端服务器程序分析</h3><br><p><img src="/images/javawz/image-20220210013817470.png" alt="image-20220210013817470"></p><p>客户端和服务器端的cfd文件描述符各自指向两个缓冲区一个是读缓冲区另一个是写缓冲区</p><p>他们是通过IP地址+端口号进行建立连接的</p><p>一个文件描述符读的同时也可以写,所以是双向全双工的</p><p>客户端输入hello然后通过cfd写入发送缓冲区里，然后发送给服务器端的cfd接收缓冲区，服务器端收到hello后将其转换为HELLO后，将其写入发送缓冲区，然后发送给客户端的接收缓冲区，客户端收到后显示到终端</p><p>如果cfd只有一个缓冲区，就只能接收或发送，如果缓冲区是负责接收的，那么就不能发送，相反同上。所以cfd一定是两个缓冲区进行工作的。</p><p>服务器端或客户端的read如果没有接收到消息，一定是阻塞的，直到缓冲区收到内容才进行工作。</p><h3 id="查看网络程序端口"><a class="markdownIt-Anchor" href="#查看网络程序端口"></a> 查看网络程序端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -apn | grep 端口号</span><br></pre></td></tr></table></figure><h3 id="错误处理函数"><a class="markdownIt-Anchor" href="#错误处理函数"></a> 错误处理函数</h3><p>帮助文档查看函数名的时候是不区分大小写的</p><h4 id="wraph"><a class="markdownIt-Anchor" href="#wraph"></a> wrap.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WRAP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> Read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> Write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="keyword">ssize_t</span> Writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="keyword">ssize_t</span> my_read(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr);</span><br><span class="line"><span class="keyword">ssize_t</span> Readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="wrapc"><a class="markdownIt-Anchor" href="#wrapc"></a> wrap.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(s);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ((n = accept(fd, sa, salenptr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">perr_exit(<span class="string">"accept error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((n = bind(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"bind error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n = connect(fd, sa, salen);</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perr_exit(<span class="string">"connect error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((n = listen(fd, backlog)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"listen error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((n = socket(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"socket error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ( (n = read(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ((n = write(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> ((n = close(fd)) == <span class="number">-1</span>)</span><br><span class="line">perr_exit(<span class="string">"close error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*参三: 应该读取的字节数*/</span>                          <span class="comment">//socket 4096  readn(cfd, buf, 4096)   nleft = 4096-1500</span></span><br><span class="line"><span class="comment">//读n个字节</span></span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span>  nleft;              <span class="comment">//usigned int 剩余未读取的字节数</span></span><br><span class="line"><span class="keyword">ssize_t</span> nread;              <span class="comment">//int 实际读到的字节数</span></span><br><span class="line"><span class="keyword">char</span>   *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;                  <span class="comment">//n 未读取字节数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">nread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">nleft -= nread;   <span class="comment">//nleft = nleft - nread </span></span><br><span class="line">ptr += nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写n个字节</span></span><br><span class="line"><span class="keyword">ssize_t</span> Writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nwritten;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"><span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ( (nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">nwritten = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">nleft -= nwritten;</span><br><span class="line">ptr += nwritten;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次读100个字节</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> read_cnt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *read_ptr;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> read_buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ( (read_cnt = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;   <span class="comment">//"hello\n"</span></span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">read_ptr = read_buf;</span><br><span class="line">&#125;</span><br><span class="line">read_cnt--;</span><br><span class="line">*ptr = *read_ptr++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*readline --- fgets*/</span>    </span><br><span class="line"><span class="comment">//传出参数 vptr</span></span><br><span class="line"><span class="comment">// 作用：读一行</span></span><br><span class="line"><span class="keyword">ssize_t</span> Readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n, rc;</span><br><span class="line"><span class="keyword">char</span>    c, *ptr;</span><br><span class="line">ptr = vptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((rc = my_read(fd, &amp;c)) == <span class="number">1</span>) &#123;   <span class="comment">//ptr[] = hello\n</span></span><br><span class="line">*ptr++ = c;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">*ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">*ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read函数返回值"><a class="markdownIt-Anchor" href="#read函数返回值"></a> read函数返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char buf[1024];</span><br><span class="line"></span><br><span class="line">&gt;0实际读到的字节数,可以等于buf或小于buf</span><br><span class="line">=0对端关闭</span><br><span class="line">=-1异常</span><br><span class="line">1.errno == EINTR 被信号中断可以进行重启或退出处理</span><br><span class="line">2.  errno == EAGAIN (EWOULDBLOCK) 非阻塞方式读，并且没有数据</span><br><span class="line">3.  其他值   出现错误。--perror 打印错误信息 ,exit 退出程序。</span><br></pre></td></tr></table></figure><br><h3 id="tcp三次握手和四次挥手"><a class="markdownIt-Anchor" href="#tcp三次握手和四次挥手"></a> TCP三次握手和四次挥手</h3><p><img src="/images/javawz/image-20220210193456378.png" alt="image-20220210193456378"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TCP三次握手</span><br><span class="line">客户端: 发送SYN包 1(0)括号0代表这个数据包带0字节数据</span><br><span class="line">服务端: 收到后做应答   2000(0) ACK 2ACK是应答客户端发送的SYN包号+1</span><br><span class="line">客户端: 收到服务端的包后做出应答  ACK 2001</span><br><span class="line"></span><br><span class="line">TCP四次挥手</span><br><span class="line">客户端:发送FIN包   2(0)  ACK 2001</span><br><span class="line">服务端;    收到后回一个ACK包   ACK 3</span><br><span class="line">这时候TCP属于半关闭状态</span><br><span class="line">服务端:发送FIN包  FIN 2001(0) ACK 3</span><br><span class="line">客户端:发送ACK包  ACK 2002</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MTU、mss、半关闭</span><br><span class="line"></span><br><span class="line">MTU： 最大传输单元    受协议限制   以太网1500   IP 65535</span><br><span class="line"></span><br><span class="line">mss： 受MTU 标示一个数据包携带数据的上限数。 </span><br><span class="line"></span><br><span class="line">win： 滑动窗口——当前本端 能接收的数据上限值。(单位：字节)</span><br></pre></td></tr></table></figure><br><p>使用TCP建立连接的机器,如果机器A发送数据包给机器B，机器B没有收到的话，机器A会重新发送一次</p><h3 id="协议上限分析"><a class="markdownIt-Anchor" href="#协议上限分析"></a> 协议上限分析</h3><p><img src="/images/javawz/image-20220210200444005.png" alt="image-20220210200444005"></p><h3 id="多进程并发服务器程序实现"><a class="markdownIt-Anchor" href="#多进程并发服务器程序实现"></a> 多进程并发服务器程序实现</h3><p><img src="/images/javawz/image-20220210204704757.png" alt="image-20220210204704757"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sigchild</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>;</span></span><br><span class="line"></span><br><span class="line">    newact.sa_handler = do_sigchild;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGCHLD, &amp;newact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="comment">//子进程工作</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            Close(listenfd);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                n = Read(connfd, buf, MAXLINE);</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">                        inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                        ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                    buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line"></span><br><span class="line">                Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                Write(connfd, buf, n);</span><br><span class="line">            &#125;</span><br><span class="line">            Close(connfd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Close(connfd);</span><br><span class="line">        &#125;  <span class="keyword">else</span></span><br><span class="line">            perr_exit(<span class="string">"fork"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程并发服务器程序实现"><a class="markdownIt-Anchor" href="#多线程并发服务器程序实现"></a> 多线程并发服务器程序实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> &#123;</span>                     <span class="comment">//定义一个结构体, 将地址结构跟cfd捆绑</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_work</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> *<span class="title">ts</span> = (<span class="title">struct</span> <span class="title">s_info</span>*)<span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];      <span class="comment">//#define INET_ADDRSTRLEN 16  可用"[+d"查看</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n = Read(ts-&gt;connfd, buf, MAXLINE);                     <span class="comment">//读客户端</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"the client %d closed...\n"</span>, ts-&gt;connfd);</span><br><span class="line">            <span class="keyword">break</span>;                                              <span class="comment">//跳出循环,关闭cfd</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">                inet_ntop(AF_INET, &amp;(*ts).cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                ntohs((*ts).cliaddr.sin_port));                 <span class="comment">//打印客户端信息(IP/PORT)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);                           <span class="comment">//小写--&gt;大写</span></span><br><span class="line"></span><br><span class="line">        Write(STDOUT_FILENO, buf, n);                           <span class="comment">//写出至屏幕</span></span><br><span class="line">        Write(ts-&gt;connfd, buf, n);                              <span class="comment">//回写给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">    Close(ts-&gt;connfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> <span class="title">ts</span>[256];</span>      <span class="comment">//根据最大线程数创建结构体数组.</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);                     <span class="comment">//创建一个socket, 得到lfd</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));                             <span class="comment">//地址结构清零</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);                   <span class="comment">//指定本地任意IP</span></span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);                           <span class="comment">//指定端口号 8000</span></span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)); <span class="comment">//绑定</span></span><br><span class="line"></span><br><span class="line">    Listen(listenfd, <span class="number">128</span>);      <span class="comment">//设置同一时刻链接服务器上限数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepting client connect ...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);   <span class="comment">//阻塞监听客户端链接请求</span></span><br><span class="line">        ts[i].cliaddr = cliaddr;</span><br><span class="line">        ts[i].connfd = connfd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 达到线程最大数时，pthread_create出错处理, 增加服务器稳定性 */</span></span><br><span class="line">        pthread_create(&amp;tid, <span class="literal">NULL</span>, do_work, (<span class="keyword">void</span>*)&amp;ts[i]);</span><br><span class="line">        pthread_detach(tid);                                                    <span class="comment">//子线程分离,防止僵线程产生.</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tcp状态转换"><a class="markdownIt-Anchor" href="#tcp状态转换"></a> TCP状态转换</h3><p><img src="/images/javawz/image-20220211012542123.png" alt="image-20220211012542123"></p><p>RST标志位表示客户端异常断开,服务端无法接收ACK,所以客户端操作系统会发送一个RST标志,然后让服务端回到LISTEN状态,重新接收连接</p><p>2MSL在linux中是</p><p>TIME_WAIT状态是确保主动关闭端发送的最后一个ACK能顺利到达</p><p>CLOSED：表示初始状态。</p><p>LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</p><p>SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</p><p>SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</p><p>ESTABLISHED：表示连接已经建立。</p><p>FIN_WAIT_1: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：</p><p>FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。</p><p>FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。</p><p>FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。</p><p>TIME_WAIT:表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</p><p>CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</p><p>CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</p><p>LAST_ACK:该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</p><h3 id="2msl"><a class="markdownIt-Anchor" href="#2msl"></a> 2MSL</h3><p>2MSL (Maximum Segment Lifetime)</p><p>RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p><h4 id="程序设计中的问题"><a class="markdownIt-Anchor" href="#程序设计中的问题"></a> 程序设计中的问题</h4><p>做一个测试，首先启动server，然后启动client，用Ctrl-C终止server，马上再运行server，运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">itcast$ ./server</span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure><p>这是因为，虽然server的应用程序终止了，但TCP协议层的连接并没有完全断开，因此不能再次监听同样的server端口。我们用netstat命令查看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">itcast$ netstat -apn |grep 6666</span><br><span class="line">tcp        1      0 192.168.1.11:38103      192.168.1.11:6666       CLOSE_WAIT  3525/client     </span><br><span class="line">tcp        0      0 192.168.1.11:6666       192.168.1.11:38103      FIN_WAIT2   -</span><br></pre></td></tr></table></figure><p>server终止时，socket描述符会自动关闭并发FIN段给client，client收到FIN后处于CLOSE_WAIT状态，但是client并没有终止，也没有关闭socket描述符，因此不会发FIN给server，因此server的TCP连接处于FIN_WAIT2状态。</p><p>现在用Ctrl-C把client也终止掉，再观察现象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">itcast$ netstat -apn |grep 6666</span><br><span class="line">tcp        0      0 192.168.1.11:6666       192.168.1.11:38104      TIME_WAIT   -</span><br><span class="line">itcast$ ./server</span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure><p>client终止时自动关闭socket描述符，server的TCP连接收到client发的FIN段后处于TIME_WAIT状态。TCP协议规定，<strong>主动关闭连接的一方要处于TIME_WAIT状态</strong>，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态，因为我们先Ctrl-C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端口。</p><p>MSL在RFC 1122中规定为两分钟，但是各操作系统的实现不同，在Linux上一般经过半分钟后就可以再次启动server了。至于为什么要规定TIME_WAIT的时间，可参考UNP 2.7节。</p><h3 id="半关闭"><a class="markdownIt-Anchor" href="#半关闭"></a> 半关闭</h3><p>当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。</p><p>从程序的角度，可以使用API来控制实现半连接状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int shutdown(int sockfd, int how);</span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line">how:允许为shutdown操作选择以下几种方式:</span><br><span class="line">SHUT_RD(0)：关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span><br><span class="line">该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(1):关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</span><br><span class="line">SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span><br></pre></td></tr></table></figure><p>使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。</p><p><strong>shutdown不考虑描述符的引用计数，直接关闭描述符</strong>。也可选择中止一个方向的连接，只中止读或只中止写。</p><p>注意:</p><ol><li><p>如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。</p></li><li><p>在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但，如果一个进程close(sfd)将不会影响到其它进程。</p></li></ol><h4 id="端口复用"><a class="markdownIt-Anchor" href="#端口复用"></a> 端口复用</h4><p>在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:6666）没有完全断开，而我们重新监听的是lis-tenfd（0.0.0.0:6666），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。</p><p>在server代码的socket()和bind()调用之间插入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int opt = 1;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));</span><br></pre></td></tr></table></figure><p>有关setsockopt可以设置的其它选项请参考UNP第7章。</p><h2 id="多路io转接服务器"><a class="markdownIt-Anchor" href="#多路io转接服务器"></a> 多路I/O转接服务器</h2><p>多路IO转接服务器也叫做多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件。</p><p>主要使用的方法有三种</p><h3 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h3><ol><li><p>select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数</p></li><li><p>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力</p></li></ol><p><img src="/images/javawz/image-20220214185634906.png" alt="image-20220214185634906"></p><p><img src="/images/javawz/image-20220214190814350.png" alt="image-20220214190814350"></p><p>如果要修改文件描述符上限需要重新编译内核</p><p>如果有两个文件描述符,一个是1号文件描述符另一个是1023号文件描述符触发了读事件,则需要for循环遍历1023次才能找到对应的两个事件,解决办法是创建一个数组来保存文件描述符,防止多余的遍历</p><p>满足监听条件的集合和原有集合都是同一个集合,所有要提前保存好原有集合,防止数据被覆盖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line">/* According to earlier standards */</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">nfds: 监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态</span><br><span class="line">readfds：监控有读数据到达文件描述符集合，传入传出参数</span><br><span class="line">writefds：监控写数据到达文件描述符集合，传入传出参数</span><br><span class="line">exceptfds：监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</span><br><span class="line">timeout：定时阻塞监控时间，3种情况</span><br><span class="line">1.NULL，永远等下去</span><br><span class="line">2.设置timeval，等待固定时间</span><br><span class="line">3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span><br><span class="line">struct timeval &#123;</span><br><span class="line">long tv_sec; /* seconds */</span><br><span class="line">long tv_usec; /* microseconds */</span><br><span class="line">&#125;;</span><br><span class="line">void FD_CLR(int fd, fd_set *set); //把文件描述符集合里fd清0</span><br><span class="line">int FD_ISSET(int fd, fd_set *set); //测试文件描述符集合里fd是否置1</span><br><span class="line">void FD_SET(int fd, fd_set *set); //把文件描述符集合里fd位置1</span><br><span class="line">void FD_ZERO(fd_set *set); //把文件描述符集合里所有位清0</span><br></pre></td></tr></table></figure><h3 id="select实现"><a class="markdownIt-Anchor" href="#select实现"></a> select实现</h3><p><img src="/images/javawz/image-20220214203149162.png" alt="image-20220214203149162"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, n, maxi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nready, client[FD_SETSIZE];                 <span class="comment">/* 自定义数组client, 防止遍历1024个文件描述符  FD_SETSIZE默认为1024 */</span></span><br><span class="line">    <span class="keyword">int</span> maxfd, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ], str[INET_ADDRSTRLEN];         <span class="comment">/* #define INET_ADDRSTRLEN 16 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存放服务器和客户端的ip和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>, <span class="title">serv_addr</span>;</span></span><br><span class="line"><span class="comment">//客户端clie_addr的长度</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    fd_set rset, allset;                            <span class="comment">/* rset 读事件文件描述符集合 allset用来暂存 */</span></span><br><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置端口复用</span></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空serv_addr</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"><span class="comment">//设置服务器端口和ip</span></span><br><span class="line">    serv_addr.sin_family= AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port= htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定端口和ip</span></span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"><span class="comment">//设置监听</span></span><br><span class="line">    Listen(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    maxfd = listenfd;                                           <span class="comment">/* 起初 listenfd 即为最大文件描述符 */</span></span><br><span class="line"></span><br><span class="line">    maxi = <span class="number">-1</span>;                                                  <span class="comment">/* 将来用作client[]的下标, 初始值指向0个元素之前下标位置 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        client[i] = <span class="number">-1</span>;                                         <span class="comment">/* 用-1初始化client[] */</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;allset);</span><br><span class="line">    FD_SET(listenfd, &amp;allset);                                  <span class="comment">/* 构造select监控文件描述符集 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;   </span><br><span class="line">        rset = allset;                                          <span class="comment">/* 每次循环时都从新设置select监控信号集 */</span></span><br><span class="line">        nready = select(maxfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready &lt; <span class="number">0</span>)</span><br><span class="line">            perr_exit(<span class="string">"select error"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123;                        <span class="comment">/* 说明有新的客户端链接请求 */</span></span><br><span class="line"></span><br><span class="line">            clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">            connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);       <span class="comment">/* Accept 不会阻塞 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">                    inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                    ntohs(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">                <span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) &#123;                            <span class="comment">/* 找client[]中没有使用的位置 */</span></span><br><span class="line">                    client[i] = connfd;                         <span class="comment">/* 保存accept返回的文件描述符到client[]里 */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == FD_SETSIZE) &#123;                              <span class="comment">/* 达到select能监控的文件个数上限 1024 */</span></span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">"too many clients\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FD_SET(connfd, &amp;allset);                            <span class="comment">/* 向监控文件描述符集合allset添加新的文件描述符connfd */</span></span><br><span class="line"><span class="comment">//如果connfn大于maxfd则交换</span></span><br><span class="line">            <span class="keyword">if</span> (connfd &gt; maxfd)</span><br><span class="line">                maxfd = connfd;                                 <span class="comment">/* select第一个参数需要 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">                maxi = i;                                       <span class="comment">/* 保证maxi存的总是client[]最后一个元素下标 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) &#123;                               <span class="comment">/* 检测哪个clients 有数据就绪 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((n = Read(sockfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>) &#123;    <span class="comment">/* 当client关闭链接时,服务器端也关闭对应链接 */</span></span><br><span class="line">                    Close(sockfd);</span><br><span class="line">                    FD_CLR(sockfd, &amp;allset);                        <span class="comment">/* 解除select对此文件描述符的监控 */</span></span><br><span class="line">                    client[i] = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                    Write(sockfd, buf, n);</span><br><span class="line">                    Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;                                          <span class="comment">/* 跳出for, 但还在while中 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220214204935192.png" alt="image-20220214204935192"></p><h3 id="poll"><a class="markdownIt-Anchor" href="#poll"></a> poll</h3><p><img src="/images/javawz/image-20220215183748654.png" alt="image-20220215183748654"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line">struct pollfd &#123;</span><br><span class="line">int fd; /* 文件描述符 */</span><br><span class="line">short events; /* 监控的事件 */</span><br><span class="line">short revents; /* 监控事件中满足条件返回的事件 */</span><br><span class="line">&#125;;</span><br><span class="line">POLLIN普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND</span><br><span class="line">POLLRDNORM数据可读</span><br><span class="line">POLLRDBAND优先级带数据可读</span><br><span class="line">POLLPRI 高优先级可读数据</span><br><span class="line">POLLOUT普通或带外数据可写</span><br><span class="line">POLLWRNORM数据可写</span><br><span class="line">POLLWRBAND优先级带数据可写</span><br><span class="line">POLLERR 发生错误</span><br><span class="line">POLLHUP 发生挂起</span><br><span class="line">POLLNVAL 描述字不是一个打开的文件</span><br><span class="line"></span><br><span class="line">nfds 监控数组中有多少文件描述符需要被监控</span><br><span class="line"></span><br><span class="line">timeout 毫秒级等待</span><br><span class="line">-1：阻塞等，#define INFTIM -1 Linux中没有定义此宏</span><br><span class="line">0：立即返回，不阻塞进程</span><br><span class="line">&gt;0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值</span><br></pre></td></tr></table></figure><p>如果不再监控某个文件描述符时，可以把pollfd中，fd设置为-1，poll不再监控此pollfd，下次返回时，把revents设置为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, maxi, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">int</span> nready;                                 <span class="comment">/*接收poll返回值, 记录满足监听事件的fd个数*/</span></span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    Listen(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;                    <span class="comment">/* 要监听的第一个文件描述符 存入client[0]*/</span></span><br><span class="line">    client[<span class="number">0</span>].events = POLLIN;                  <span class="comment">/* listenfd监听普通读事件 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">        client[i].fd = <span class="number">-1</span>;                      <span class="comment">/* 用-1初始化client[]里剩下元素 0也是文件描述符,不能用 */</span></span><br><span class="line"></span><br><span class="line">    maxi = <span class="number">0</span>;                                   <span class="comment">/* client[]数组有效元素中最大元素下标 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        nready = poll(client, maxi+<span class="number">1</span>, <span class="number">-1</span>);      <span class="comment">/* 阻塞监听是否有客户端链接请求 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLIN) &#123;       <span class="comment">/* listenfd有读事件就绪 */</span></span><br><span class="line"></span><br><span class="line">            clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);<span class="comment">/* 接收客户端请求 Accept 不会阻塞 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">                    inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                    ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">                <span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    client[i].fd = connfd;      <span class="comment">/* 找到client[]中空闲的位置,存放accept返回的connfd */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == OPEN_MAX)                  <span class="comment">/* 达到了最大客户端数 */</span></span><br><span class="line">                perr_exit(<span class="string">"too many clients"</span>);</span><br><span class="line"></span><br><span class="line">            client[i].events = POLLIN;          <span class="comment">/* 设置刚刚返回的connfd,监控读事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">                maxi = i;                       <span class="comment">/* 更新client[]中最大元素下标 */</span></span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;                       <span class="comment">/* 没有更多就绪事件时,继续回到poll阻塞 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= maxi; i++) &#123;           <span class="comment">/* 前面的if没满足,说明没有listenfd满足. 检测client[] 看是那个connfd就绪 */</span></span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (client[i].revents &amp; POLLIN) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* connection reset by client */</span></span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) &#123;  <span class="comment">/* 收到RST标志 */</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"client[%d] aborted connection\n"</span>, i);</span><br><span class="line">                        Close(sockfd);</span><br><span class="line">                        client[i].fd = <span class="number">-1</span>;      <span class="comment">/* poll中不监控该文件描述符,直接置为-1即可,不用像select中那样移除 */</span></span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        perr_exit(<span class="string">"read error"</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;            <span class="comment">/* 说明客户端先关闭链接 */</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, i);</span><br><span class="line">                    Close(sockfd);</span><br><span class="line">                    client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                    Writen(sockfd, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h3><p>epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p><p>目前epell是linux大规模并发网络程序中的热门首选模型。</p><p>epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</p><p>可以使用cat命令查看一个进程可以打开的socket描述符上限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure><p>如有需要，可以通过修改配置文件的方式修改该上限值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/security/limits.conf</span><br><span class="line">在文件尾部写入以下配置,soft软限制，hard硬限制。如下图所示。</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 100000</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220215203019930.png" alt="image-20220215203019930"></p><h4 id="基础api"><a class="markdownIt-Anchor" href="#基础api"></a> 基础API</h4><ol><li>创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_create(int size)size：监听数目</span><br></pre></td></tr></table></figure><ol start="2"><li>控制某个epoll监控的文件描述符上的事件：注册、修改、删除。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</span><br><span class="line">epfd：为epoll_creat的句柄</span><br><span class="line">op：表示动作，用3个宏来表示：</span><br><span class="line">EPOLL_CTL_ADD (注册新的fd到epfd)，</span><br><span class="line">EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</span><br><span class="line">EPOLL_CTL_DEL (从epfd删除一个fd)；</span><br><span class="line">event：告诉内核需要监听的事件</span><br><span class="line"></span><br><span class="line">struct epoll_event &#123;</span><br><span class="line">__uint32_t events; /* Epoll events */</span><br><span class="line">epoll_data_t data; /* User data variable */</span><br><span class="line">&#125;;</span><br><span class="line">typedef union epoll_data &#123;</span><br><span class="line">void *ptr;</span><br><span class="line">int fd;</span><br><span class="line">uint32_t u32;</span><br><span class="line">uint64_t u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure><ol start="3"><li>等待所监控文件描述符上有事件的产生，类似于select()调用。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</span><br><span class="line">events：用来存内核得到事件的集合，</span><br><span class="line">maxevents：告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</span><br><span class="line">timeout：是超时时间</span><br><span class="line">-1：阻塞</span><br><span class="line">0：立即返回，非阻塞</span><br><span class="line">&gt;0：指定毫秒</span><br><span class="line">返回值：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220215203335277.png" alt="image-20220215203335277"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 5000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">int</span>  n, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nready, efd, res;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tep</span>, <span class="title">ep</span>[<span class="title">OPEN_MAX</span>];</span>       <span class="comment">//tep: epoll_ctl参数  ep[] : epoll_wait参数</span></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));      <span class="comment">//端口复用</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    efd = epoll_create(OPEN_MAX);               <span class="comment">//创建epoll模型, efd指向红黑树根节点</span></span><br><span class="line">    <span class="keyword">if</span> (efd == <span class="number">-1</span>)</span><br><span class="line">        perr_exit(<span class="string">"epoll_create error"</span>);</span><br><span class="line"></span><br><span class="line">    tep.events = EPOLLIN; tep.data.fd = listenfd;           <span class="comment">//指定lfd的监听时间为"读"</span></span><br><span class="line">    res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep);    <span class="comment">//将lfd及对应的结构体设置到树上,efd可找到该树</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">        perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        <span class="comment">/*epoll为server阻塞监听事件, ep为struct epoll_event类型数组, OPEN_MAX为数组容量, -1表永久阻塞*/</span></span><br><span class="line">        nready = epoll_wait(efd, ep, OPEN_MAX, <span class="number">-1</span>); </span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            perr_exit(<span class="string">"epoll_wait error"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nready; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(ep[i].events &amp; EPOLLIN))      <span class="comment">//如果不是"读"事件, 继续循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ep[i].data.fd == listenfd) &#123;    <span class="comment">//判断满足事件的fd是不是lfd            </span></span><br><span class="line">                clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);    <span class="comment">//接受链接</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>, </span><br><span class="line">                        inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)), </span><br><span class="line">                        ntohs(cliaddr.sin_port));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"cfd %d---client %d\n"</span>, connfd, ++num);</span><br><span class="line"></span><br><span class="line">                tep.events = EPOLLIN; tep.data.fd = connfd;</span><br><span class="line">                res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep);</span><br><span class="line">                <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">                    perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                <span class="comment">//不是lfd, </span></span><br><span class="line">                sockfd = ep[i].data.fd;</span><br><span class="line">                n = Read(sockfd, buf, MAXLINE);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;                       <span class="comment">//读到0,说明客户端关闭链接</span></span><br><span class="line">                    res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);  <span class="comment">//将该文件描述符从红黑树摘除</span></span><br><span class="line">                    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">                        perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line">                    Close(sockfd);                  <span class="comment">//关闭与该客户端的链接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, sockfd);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;                 <span class="comment">//出错</span></span><br><span class="line">                    perror(<span class="string">"read n &lt; 0 error: "</span>);</span><br><span class="line">                    res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line">                    Close(sockfd);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                            <span class="comment">//实际读到了字节数</span></span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);   <span class="comment">//转大写,写回给客户端</span></span><br><span class="line"></span><br><span class="line">                    Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                    Writen(sockfd, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Close(listenfd);</span><br><span class="line">    Close(efd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件模型"><a class="markdownIt-Anchor" href="#事件模型"></a> 事件模型</h3><p>EPOLL事件有两种模型：</p><p>Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。</p><p>Level Triggered (LT) 水平触发只要有数据都会触发。</p><p>思考如下步骤：</p><ol><li><p>假定我们已经把一个用来从管道中读取数据的文件描述符(RFD)添加到epoll描述符。</p></li><li><p>管道的另一端写入了2KB的数据</p></li><li><p>调用epoll_wait，并且它会返回RFD，说明它已经准备好读取操作</p></li><li><p>读取1KB的数据</p></li><li><p>调用epoll_wait……</p></li></ol><p>在这个过程中，有两种工作模式：</p><h4 id="et模式"><a class="markdownIt-Anchor" href="#et模式"></a> ET模式</h4><p>ET模式即Edge Triggered工作模式。</p><p>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。</p><ol><li><p>基于非阻塞文件句柄</p></li><li><p>只有当read或者write返回EAGAIN(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次read时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。</p></li></ol><h4 id="lt模式"><a class="markdownIt-Anchor" href="#lt模式"></a> LT模式</h4><p>LT模式即Level Triggered工作模式。</p><p>与ET模式不同的是，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll，无论后面的数据是否被使用。</p><p>LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。</p><p>ET(edge-triggered)：ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once).</p><p>基于管道epoll ET触发模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> efd, i;</span><br><span class="line">    <span class="keyword">int</span> pfd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], ch = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">    pipe(pfd);</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;             <span class="comment">//子 写</span></span><br><span class="line">        close(pfd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//aaaa\n</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXLINE/<span class="number">2</span>; i++)</span><br><span class="line">                buf[i] = ch;</span><br><span class="line">            buf[i<span class="number">-1</span>] = <span class="string">'\n'</span>;</span><br><span class="line">            ch++;</span><br><span class="line">            <span class="comment">//bbbb\n</span></span><br><span class="line">            <span class="keyword">for</span> (; i &lt; MAXLINE; i++)</span><br><span class="line">                buf[i] = ch;</span><br><span class="line">            buf[i<span class="number">-1</span>] = <span class="string">'\n'</span>;</span><br><span class="line">            ch++;</span><br><span class="line">            <span class="comment">//aaaa\nbbbb\n</span></span><br><span class="line">            write(pfd[<span class="number">1</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pfd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;       <span class="comment">//父 读</span></span><br><span class="line">        struct epoll_event event;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>[10];</span>        <span class="comment">//epoll_wait就绪返回event</span></span><br><span class="line">        <span class="keyword">int</span> res, len;</span><br><span class="line"></span><br><span class="line">        close(pfd[<span class="number">1</span>]);</span><br><span class="line">        efd = epoll_create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        event.events = EPOLLIN | EPOLLET;     <span class="comment">// ET 边沿触发</span></span><br><span class="line">        <span class="comment">//event.events = EPOLLIN;                 // LT 水平触发 (默认)</span></span><br><span class="line">        event.data.fd = pfd[<span class="number">0</span>];</span><br><span class="line">        epoll_ctl(efd, EPOLL_CTL_ADD, pfd[<span class="number">0</span>], &amp;event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            res = epoll_wait(efd, resevent, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"res %d\n"</span>, res);</span><br><span class="line">            <span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == pfd[<span class="number">0</span>]) &#123;</span><br><span class="line">                len = read(pfd[<span class="number">0</span>], buf, MAXLINE/<span class="number">2</span>);</span><br><span class="line">                write(STDOUT_FILENO, buf, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(pfd[<span class="number">0</span>]);</span><br><span class="line">        close(efd);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll阻塞io"><a class="markdownIt-Anchor" href="#epoll阻塞io"></a> epoll阻塞IO</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> efd;</span><br><span class="line"></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>[10];</span></span><br><span class="line">    <span class="keyword">int</span> res, len;</span><br><span class="line"></span><br><span class="line">    efd = epoll_create(<span class="number">10</span>);</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;     <span class="comment">/* ET 边沿触发 */</span></span><br><span class="line">    <span class="comment">//event.events = EPOLLIN;                 /* 默认 LT 水平触发 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line"></span><br><span class="line">    cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    event.data.fd = connfd;</span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        res = epoll_wait(efd, resevent, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"res %d\n"</span>, res);</span><br><span class="line">        <span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == connfd) &#123;</span><br><span class="line">            len = read(connfd, buf, MAXLINE/<span class="number">2</span>);         <span class="comment">//readn(500)   </span></span><br><span class="line">            write(STDOUT_FILENO, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll非阻塞io"><a class="markdownIt-Anchor" href="#epoll非阻塞io"></a> epoll非阻塞IO</h3><p>假设我们在程序中规定数据包前50个字节是对这个数据包的总述，因此我们一次读50个字节然后判断是否要完全读取这个数据包，这时候就要用到边沿性触发机制。</p><p>如果客户端只发送200Byte数据，而服务器端一次读400Byte，这时read函数是阻塞等待剩下的200Byte的，所以要设置非阻塞fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> efd, flag;</span><br><span class="line"></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>[10];</span></span><br><span class="line">    <span class="keyword">int</span> res, len;</span><br><span class="line"></span><br><span class="line">    efd = epoll_create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN | EPOLLET;     <span class="comment">/* ET 边沿触发，默认是水平触发 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//event.events = EPOLLIN;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line">    cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    flag = fcntl(connfd, F_GETFL);          <span class="comment">/* 修改connfd为非阻塞读 */</span></span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    fcntl(connfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">    event.data.fd = connfd;</span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);      <span class="comment">//将connfd加入监听红黑树</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"epoll_wait begin\n"</span>);</span><br><span class="line">        res = epoll_wait(efd, resevent, <span class="number">10</span>, <span class="number">-1</span>);        <span class="comment">//最多10个, 阻塞监听</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"epoll_wait end res %d\n"</span>, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == connfd) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((len = read(connfd, buf, MAXLINE/<span class="number">2</span>)) &gt;<span class="number">0</span> )    <span class="comment">//非阻塞读, 轮询</span></span><br><span class="line">                write(STDOUT_FILENO, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll反应堆模型"><a class="markdownIt-Anchor" href="#epoll反应堆模型"></a> epoll反应堆模型</h3><p>libevent     跨平台</p><p>epoll — 服务器 — 监听 — cfd ---- 可读 ---- epoll返回 ---- read – cfd从树上摘下 — 设置监听cfd写事件， 操作</p><p>— 小写转大写 – 等待epoll_wait 返回 — 回写客户端 – cfd从树上摘下 ----- 设置监听cfd读事件， 操作 – epoll继续监听。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evt[i].events = EPOLLIN, evt[I].data.fd == cfd       *ptr     struct &#123;int fd, void (*func)(void *arg), void *arv&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__func__ //获取当前函数名</span><br><span class="line">__FILE__//获取当前文件名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s\n%s\n&quot;, __func__, __FILE__);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220218003454575.png" alt="image-20220218003454575"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *epoll基于非阻塞I/O事件驱动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS  1024                                    <span class="comment">//监听上限数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT   8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">senddata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述就绪文件描述符相关信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;                                                 <span class="comment">//要监听的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> events;                                             <span class="comment">//对应的监听事件</span></span><br><span class="line">    <span class="keyword">void</span> *arg;                                              <span class="comment">//泛型参数</span></span><br><span class="line">    <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg);       <span class="comment">//回调函数</span></span><br><span class="line">    <span class="keyword">int</span> status;                                             <span class="comment">//是否在监听:1-&gt;在红黑树上(监听), 0-&gt;不在(不监听)</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFLEN];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">long</span> last_active;                                       <span class="comment">//记录每次加入红黑树 g_efd 的时间值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_efd;                                                  <span class="comment">//全局变量, 保存epoll_create返回的文件描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> <span class="title">g_events</span>[<span class="title">MAX_EVENTS</span>+1];</span>                    <span class="comment">//自定义结构体类型数组. +1--&gt;listen fd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将结构体 myevent_s 成员变量 初始化*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventset</span><span class="params">(struct myevent_s *ev, <span class="keyword">int</span> fd, <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;call_back = call_back;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// memset(ev-&gt;buf, 0, sizeof(ev-&gt;buf));</span></span><br><span class="line">    <span class="comment">//ev-&gt;len = 0;</span></span><br><span class="line">    ev-&gt;last_active = time(<span class="literal">NULL</span>);                       <span class="comment">//调用eventset函数的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 epoll监听的红黑树 添加一个 文件描述符 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventadd</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">int</span> events, struct myevent_s *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> = &#123;</span><span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    epv.events = ev-&gt;events = events;       <span class="comment">//EPOLLIN 或 EPOLLOUT</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;status == <span class="number">1</span>) &#123;                                          <span class="comment">//已经在红黑树 g_efd 里</span></span><br><span class="line">        op = EPOLL_CTL_MOD;                                         <span class="comment">//修改其属性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                <span class="comment">//不在红黑树里</span></span><br><span class="line">        op = EPOLL_CTL_ADD;                 <span class="comment">//将其加入红黑树 g_efd, 并将status置1</span></span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(efd, op, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)                       <span class="comment">//实际添加/修改</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"event add failed [fd=%d], events[%d]\n"</span>, ev-&gt;fd, events);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"event add OK [fd=%d], op=%d, events[%0X]\n"</span>, ev-&gt;fd, op, events);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从epoll 监听的 红黑树中删除一个 文件描述符*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventdel</span><span class="params">(<span class="keyword">int</span> efd, struct myevent_s *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> = &#123;</span><span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;status != <span class="number">1</span>)                                        <span class="comment">//不在红黑树上</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;                                             <span class="comment">//修改状态</span></span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv);                <span class="comment">//从红黑树 efd 上将 ev-&gt;fd 摘除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  当有文件描述符就绪, epoll返回, 调用该函数 与客户端建立链接 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptconn</span><span class="params">(<span class="keyword">int</span> lfd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cin</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="built_in">cin</span>);</span><br><span class="line">    <span class="keyword">int</span> cfd, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cfd = accept(lfd, (struct sockaddr *)&amp;<span class="built_in">cin</span>, &amp;len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EINTR) &#123;</span><br><span class="line">            <span class="comment">/* 暂时不做出错处理 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s: accept, %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_EVENTS; i++)                                <span class="comment">//从全局数组g_events中找一个空闲元素</span></span><br><span class="line">            <span class="keyword">if</span> (g_events[i].status == <span class="number">0</span>)                                <span class="comment">//类似于select中找值为-1的元素</span></span><br><span class="line">                <span class="keyword">break</span>;                                                  <span class="comment">//跳出 for</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == MAX_EVENTS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: max connect limit[%d]\n"</span>, __func__, MAX_EVENTS);</span><br><span class="line">            <span class="keyword">break</span>;                                                      <span class="comment">//跳出do while(0) 不执行后续代码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>) &#123;             <span class="comment">//将cfd也设置为非阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: fcntl nonblocking failed, %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 给cfd设置一个 myevent_s 结构体, 回调函数 设置为 recvdata */</span></span><br><span class="line"></span><br><span class="line">        eventset(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);   </span><br><span class="line">        eventadd(g_efd, EPOLLIN, &amp;g_events[i]);                         <span class="comment">//将cfd添加到红黑树g_efd中,监听读事件</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"new connect [%s:%d][time:%ld], pos[%d]\n"</span>, </span><br><span class="line">            inet_ntoa(<span class="built_in">cin</span>.sin_addr), ntohs(<span class="built_in">cin</span>.sin_port), g_events[i].last_active, i);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = recv(fd, ev-&gt;buf, <span class="keyword">sizeof</span>(ev-&gt;buf), <span class="number">0</span>);            <span class="comment">//读文件描述符, 数据存入myevent_s成员buf中</span></span><br><span class="line"></span><br><span class="line">    eventdel(g_efd, ev);        <span class="comment">//将该节点从红黑树上摘除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        ev-&gt;len = len;</span><br><span class="line">        ev-&gt;buf[len] = <span class="string">'\0'</span>;                                <span class="comment">//手动添加字符串结束标记</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"C[%d]:%s\n"</span>, fd, ev-&gt;buf);</span><br><span class="line"></span><br><span class="line">        eventset(ev, fd, senddata, ev);                     <span class="comment">//设置该 fd 对应的回调函数为 senddata</span></span><br><span class="line">        eventadd(g_efd, EPOLLOUT, ev);                      <span class="comment">//将fd加入红黑树g_efd中,监听其写事件</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        close(ev-&gt;fd);</span><br><span class="line">        <span class="comment">/* ev-g_events 地址相减得到偏移元素位置 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[fd=%d] pos[%ld], closed\n"</span>, fd, ev-g_events);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(ev-&gt;fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"recv[fd=%d] error[%d]:%s\n"</span>, fd, errno, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">senddata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = send(fd, ev-&gt;buf, ev-&gt;len, <span class="number">0</span>);                    <span class="comment">//直接将数据 回写给客户端。未作处理</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    printf("fd=%d\tev-&gt;buf=%s\ttev-&gt;len=%d\n", fd, ev-&gt;buf, ev-&gt;len);</span></span><br><span class="line"><span class="comment">    printf("send len = %d\n", len);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"send[fd=%d], [%d]%s\n"</span>, fd, len, ev-&gt;buf);</span><br><span class="line">        eventdel(g_efd, ev);                                <span class="comment">//从红黑树g_efd中移除</span></span><br><span class="line">        eventset(ev, fd, recvdata, ev);                     <span class="comment">//将该fd的 回调函数改为 recvdata</span></span><br><span class="line">        eventadd(g_efd, EPOLLIN, ev);                       <span class="comment">//从新添加到红黑树上， 设为监听读事件</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(ev-&gt;fd);                                      <span class="comment">//关闭链接</span></span><br><span class="line">        eventdel(g_efd, ev);                                <span class="comment">//从红黑树g_efd中移除</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"send[fd=%d] error %s\n"</span>, fd, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建 socket, 初始化lfd */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initlistensocket</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    fcntl(lfd, F_SETFL, O_NONBLOCK);                                            <span class="comment">//将socket设为非阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg);  */</span></span><br><span class="line">    eventset(&amp;g_events[MAX_EVENTS], lfd, acceptconn, &amp;g_events[MAX_EVENTS]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* void eventadd(int efd, int events, struct myevent_s *ev) */</span></span><br><span class="line">    eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                                               <span class="comment">//bzero(&amp;sin, sizeof(sin))</span></span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">bind(lfd, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"></span><br><span class="line">listen(lfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port = SERV_PORT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        port = atoi(argv[<span class="number">1</span>]);                           <span class="comment">//使用用户指定端口.如未指定,用默认端口</span></span><br><span class="line"></span><br><span class="line">    g_efd = epoll_create(MAX_EVENTS+<span class="number">1</span>);                 <span class="comment">//创建红黑树,返回给全局 g_efd </span></span><br><span class="line">    <span class="keyword">if</span> (g_efd &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create efd in %s err %s\n"</span>, __func__, strerror(errno));</span><br><span class="line"></span><br><span class="line">    initlistensocket(g_efd, port);                      <span class="comment">//初始化监听socket</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>+1];</span>            <span class="comment">//保存已经满足就绪事件的文件描述符数组 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"server running:port[%d]\n"</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> checkpos = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 超时验证，每次测试100个链接，不测试listenfd 当客户端60秒内没有和服务器通信，则关闭此客户端链接 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> now = time(<span class="literal">NULL</span>);                          <span class="comment">//当前时间</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++, checkpos++) &#123;         <span class="comment">//一次循环检测100个。 使用checkpos控制检测对象</span></span><br><span class="line">            <span class="keyword">if</span> (checkpos == MAX_EVENTS)</span><br><span class="line">                checkpos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (g_events[checkpos].status != <span class="number">1</span>)         <span class="comment">//不在红黑树 g_efd 上</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> duration = now - g_events[checkpos].last_active;       <span class="comment">//客户端不活跃的世间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (duration &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                close(g_events[checkpos].fd);                           <span class="comment">//关闭与该客户端链接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"[fd=%d] timeout\n"</span>, g_events[checkpos].fd);</span><br><span class="line">                eventdel(g_efd, &amp;g_events[checkpos]);                   <span class="comment">//将该客户端 从红黑树 g_efd移除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*监听红黑树g_efd, 将满足的事件的文件描述符加至events数组中, 1秒没有事件满足, 返回 0*/</span></span><br><span class="line">        <span class="keyword">int</span> nfd = epoll_wait(g_efd, events, MAX_EVENTS+<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"epoll_wait error, exit\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfd; i++) &#123;</span><br><span class="line">            <span class="comment">/*使用自定义结构体myevent_s类型指针, 接收 联合体data的void *ptr成员*/</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">events</span>[<span class="title">i</span>].<span class="title">data</span>.<span class="title">ptr</span>;</span>  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123;           <span class="comment">//读就绪事件</span></span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123;         <span class="comment">//写就绪事件</span></span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 退出前释放所有资源 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="心跳包和乒乓包"><a class="markdownIt-Anchor" href="#心跳包和乒乓包"></a> 心跳包和乒乓包</h3><p>心跳包:</p><p>​在应用层自定义一个协议。例如服务器每隔一段时间发送一个123的数据包，客户端收到后会回一个456的数据包，当服务器收到客户端发送来的456之后就认为客户端还保持连接，如果服务器发送了123之后没有得到客户端的回应，则每隔3秒持续发送123给客户端，持续发送3次之后还没有得到回应，则认为客户端掉线了，服务端则close(cfd)且让客户端重新连接</p><p><img src="/images/javawz/image-20220218181416978.png" alt="image-20220218181416978"></p><p>乒乓包：</p><p>​在判别网络通不通的同时还可以携带一些数据。例如：朋友圈的小圆点，客户端每隔一段时间询问有没有动态更新，服务器马上回应有或没有，如果有则回复有，客户端收到后会让小圆点变红</p><p><img src="/images/javawz/image-20220218182244501.png" alt="image-20220218182244501"></p><h3 id="设置tcp属性"><a class="markdownIt-Anchor" href="#设置tcp属性"></a> 设置TCP属性</h3><p>SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“host unreachable(主机不可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为EHOSTUNREACH。</p><p>根据上面的介绍我们可以知道对端以一种非优雅的方式断开连接的时候，我们可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keepAlive = 1;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive));</span><br></pre></td></tr></table></figure><p>如果我们不能接受如此之长的等待时间，从TCP-Keepalive-HOWTO上可以知道一共有两种方式可以设置，一种是修改内核关于网络方面的 配置参数，另外一种就是SOL_TCP字段的TCP_KEEPIDLE， TCP_KEEPINTVL， TCP_KEEPCNT三个选项。</p><ol><li>The tcp_keepidle parameter specifies the interval of inactivity that causes TCP to generate a KEEPALIVE transmission for an application that requests them. tcp_keepidle defaults to 14400 (two hours).</li></ol><p>/*开始首次KeepAlive探测前的TCP空闭时间 */</p><ol start="2"><li>The tcp_keepintvl parameter specifies the interval between the nine retriesthat are attempted if a KEEPALIVE transmission is not acknowledged. tcp_keep ntvldefaults to 150 (75 seconds).</li></ol><p>/* 两次KeepAlive探测间的时间间隔 */</p><ol start="3"><li>The tcp_keepcnt option specifies the maximum number of keepalive probes tobe sent. The value of TCP_KEEPCNT is an integer value between 1 and n, where n s the value of the systemwide tcp_keepcnt parameter.</li></ol><p>/* 判定断开前的KeepAlive探测次数*/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int keepIdle = 1000;</span><br><span class="line">int keepInterval = 10;</span><br><span class="line">int keepCount = 10;</span><br><span class="line"></span><br><span class="line">Setsockopt(listenfd, SOL_TCP, TCP_KEEPIDLE, (void *)&amp;keepIdle, sizeof(keepIdle));</span><br><span class="line">Setsockopt(listenfd, SOL_TCP,TCP_KEEPINTVL, (void *)&amp;keepInterval, sizeof(keepInterval));</span><br><span class="line">Setsockopt(listenfd,SOL_TCP, TCP_KEEPCNT, (void *)&amp;keepCount, sizeof(keepCount));</span><br></pre></td></tr></table></figure><p>SO_KEEPALIVE设置空闲2小时才发送一个“保持存活探测分节”，不能保证实时检测。对于判断网络断开时间太长，对于需要及时响应的程序不太适应。</p><p>当然也可以修改时间间隔参数，但是会影响到所有打开此选项的套接口！关联了完成端口的socket可能会忽略掉该套接字选项。</p><h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3><p><img src="/images/javawz/image-20220220022756899.png" alt="image-20220220022756899"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __THREADPOOL_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __THREADPOOL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">threadpool_t</span> <span class="title">threadpool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function threadpool_create</span></span><br><span class="line"><span class="comment"> * @descCreates a threadpool_t object.</span></span><br><span class="line"><span class="comment"> * @param thr_num  thread num</span></span><br><span class="line"><span class="comment"> * @param max_thr_num  max thread size</span></span><br><span class="line"><span class="comment"> * @param queue_max_size   size of the queue.</span></span><br><span class="line"><span class="comment"> * @return a newly created thread pool or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">threadpool_t</span> *threadpool_create(<span class="keyword">int</span> min_thr_num, <span class="keyword">int</span> max_thr_num, <span class="keyword">int</span> queue_max_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function threadpool_add</span></span><br><span class="line"><span class="comment"> * @desc add a new task in the queue of a thread pool</span></span><br><span class="line"><span class="comment"> * @param pool     Thread pool to which add the task.</span></span><br><span class="line"><span class="comment"> * @param function Pointer to the function that will perform the task.</span></span><br><span class="line"><span class="comment"> * @param argument Argument to be passed to the function.</span></span><br><span class="line"><span class="comment"> * @return 0 if all goes well,else -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_add</span><span class="params">(<span class="keyword">threadpool_t</span> *pool, <span class="keyword">void</span>*(*function)(<span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function threadpool_destroy</span></span><br><span class="line"><span class="comment"> * @desc Stops and destroys a thread pool.</span></span><br><span class="line"><span class="comment"> * @param pool  Thread pool to destroy.</span></span><br><span class="line"><span class="comment"> * @return 0 if destory success else -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_destroy</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc get the thread num</span></span><br><span class="line"><span class="comment"> * @pool pool threadpool</span></span><br><span class="line"><span class="comment"> * @return # of the thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_all_threadnum</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * desc get the busy thread num</span></span><br><span class="line"><span class="comment"> * @param pool threadpool</span></span><br><span class="line"><span class="comment"> * return # of the busy thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_busy_threadnum</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"threadpool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_TIME 10                 <span class="comment">/*10s检测一次*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_WAIT_TASK_NUM 10            <span class="comment">/*如果queue_size &gt; MIN_WAIT_TASK_NUM 添加新的线程到线程池*/</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_THREAD_VARY 10          <span class="comment">/*每次创建和销毁线程的个数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *(*function)(<span class="keyword">void</span> *);          <span class="comment">/* 函数指针，回调函数 */</span></span><br><span class="line">    <span class="keyword">void</span> *arg;                          <span class="comment">/* 上面函数的参数 */</span></span><br><span class="line">&#125; <span class="keyword">threadpool_task_t</span>;                    <span class="comment">/* 各子线程任务结构体 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述线程池相关信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadpool_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;               <span class="comment">/* 用于锁住本结构体 */</span>    </span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> thread_counter;     <span class="comment">/* 记录忙状态线程个数de琐 -- busy_thr_num */</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> queue_not_full;      <span class="comment">/* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> queue_not_empty;     <span class="comment">/* 任务队列里不为空时，通知等待任务的线程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> *threads;                 <span class="comment">/* 存放线程池中每个线程的tid。数组 */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> adjust_tid;               <span class="comment">/* 存管理线程tid */</span></span><br><span class="line">    <span class="keyword">threadpool_task_t</span> *task_queue;      <span class="comment">/* 任务队列 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min_thr_num;                    <span class="comment">/* 线程池最小线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> max_thr_num;                    <span class="comment">/* 线程池最大线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> live_thr_num;                   <span class="comment">/* 当前存活线程个数 */</span></span><br><span class="line">    <span class="keyword">int</span> busy_thr_num;                   <span class="comment">/* 忙状态线程个数 */</span></span><br><span class="line">    <span class="keyword">int</span> wait_exit_thr_num;              <span class="comment">/* 要销毁的线程个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> queue_front;                    <span class="comment">/* task_queue队头下标 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_rear;                     <span class="comment">/* task_queue队尾下标 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_size;                     <span class="comment">/* task_queue队中实际任务数 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_max_size;                 <span class="comment">/* task_queue队列可容纳任务数上限 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shutdown;                       <span class="comment">/* 标志位，线程池使用状态，true或false */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function void *threadpool_thread(void *threadpool)</span></span><br><span class="line"><span class="comment"> * @desc the worker thread</span></span><br><span class="line"><span class="comment"> * @param threadpool the pool which own the thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadpool_thread</span><span class="params">(<span class="keyword">void</span> *threadpool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function void *adjust_thread(void *threadpool);</span></span><br><span class="line"><span class="comment"> * @desc manager thread</span></span><br><span class="line"><span class="comment"> * @param threadpool the threadpool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">adjust_thread</span><span class="params">(<span class="keyword">void</span> *threadpool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * check a thread is alive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_thread_alive</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_free</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">threadpool_t</span> *threadpool_create(<span class="keyword">int</span> min_thr_num, <span class="keyword">int</span> max_thr_num, <span class="keyword">int</span> queue_max_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">threadpool_t</span> *pool = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((pool = (<span class="keyword">threadpool_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">threadpool_t</span>))) == <span class="literal">NULL</span>) </span><br><span class="line">&#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"malloc threadpool fail"</span>);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">/*跳出do while*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;min_thr_num = min_thr_num;</span><br><span class="line">        pool-&gt;max_thr_num = max_thr_num;</span><br><span class="line">        pool-&gt;busy_thr_num = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;live_thr_num = min_thr_num;               <span class="comment">/* 活着的线程数 初值=最小线程数 */</span></span><br><span class="line">        pool-&gt;queue_size = <span class="number">0</span>;                           <span class="comment">/* 有0个产品 */</span></span><br><span class="line">        pool-&gt;queue_max_size = queue_max_size;</span><br><span class="line">        pool-&gt;queue_front = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queue_rear = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;shutdown = <span class="literal">false</span>;                         <span class="comment">/* 不关闭线程池 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 根据最大线程上限数， 给工作线程数组开辟空间, 并清零 */</span></span><br><span class="line">        pool-&gt;threads = (<span class="keyword">pthread_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>)*max_thr_num); </span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"malloc threads fail"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threads, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>)*max_thr_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 队列开辟空间 */</span></span><br><span class="line">        pool-&gt;task_queue = (<span class="keyword">threadpool_task_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">threadpool_task_t</span>)*queue_max_size);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;task_queue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"malloc task_queue fail"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化互斥琐、条件变量 */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;(pool-&gt;lock), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_mutex_init(&amp;(pool-&gt;thread_counter), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_cond_init(&amp;(pool-&gt;queue_not_empty), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_cond_init(&amp;(pool-&gt;queue_not_full), <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"init the lock or cond fail"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 启动 min_thr_num 个 work thread */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min_thr_num; i++) &#123;</span><br><span class="line">            pthread_create(&amp;(pool-&gt;threads[i]), <span class="literal">NULL</span>, threadpool_thread, (<span class="keyword">void</span> *)pool);<span class="comment">/*pool指向当前线程池*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"start thread 0x%x...\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pool-&gt;threads[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_create(&amp;(pool-&gt;adjust_tid), <span class="literal">NULL</span>, adjust_thread, (<span class="keyword">void</span> *)pool);<span class="comment">/* 启动管理者线程 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    threadpool_free(pool);      <span class="comment">/* 前面代码调用失败时，释放poll存储空间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向线程池中 添加一个任务 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_add</span><span class="params">(<span class="keyword">threadpool_t</span> *pool, <span class="keyword">void</span>*(*function)(<span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ==为真，队列已经满， 调wait阻塞 */</span></span><br><span class="line">    <span class="keyword">while</span> ((pool-&gt;queue_size == pool-&gt;queue_max_size) &amp;&amp; (!pool-&gt;shutdown)) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;(pool-&gt;queue_not_full), &amp;(pool-&gt;lock));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;shutdown) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清空 工作线程 调用的回调函数 的参数arg */</span></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;task_queue[pool-&gt;queue_rear].arg != <span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;task_queue[pool-&gt;queue_rear].arg);</span><br><span class="line">        pool-&gt;task_queue[pool-&gt;queue_rear].arg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*添加任务到任务队列里*/</span></span><br><span class="line">    pool-&gt;task_queue[pool-&gt;queue_rear].function = function;</span><br><span class="line">    pool-&gt;task_queue[pool-&gt;queue_rear].arg = arg;</span><br><span class="line">    pool-&gt;queue_rear = (pool-&gt;queue_rear + <span class="number">1</span>) % pool-&gt;queue_max_size;       <span class="comment">/* 队尾指针移动, 模拟环形 */</span></span><br><span class="line">    pool-&gt;queue_size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*添加完任务后，队列不为空，唤醒线程池中 等待处理任务的线程*/</span></span><br><span class="line">    pthread_cond_signal(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程池中各个工作线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadpool_thread</span><span class="params">(<span class="keyword">void</span> *threadpool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">threadpool_t</span> *pool = (<span class="keyword">threadpool_t</span> *)threadpool;</span><br><span class="line">    <span class="keyword">threadpool_task_t</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/* Lock must be taken to wait on conditional variable */</span></span><br><span class="line">        <span class="comment">/*刚创建出线程，等待任务队列里有任务，否则阻塞等待任务队列里有任务后再唤醒接收任务*/</span></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*queue_size == 0 说明没有任务，调 wait 阻塞在条件变量上, 若有任务，跳过该while*/</span></span><br><span class="line">        <span class="keyword">while</span> ((pool-&gt;queue_size == <span class="number">0</span>) &amp;&amp; (!pool-&gt;shutdown)) &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread 0x%x is waiting\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">            pthread_cond_wait(&amp;(pool-&gt;queue_not_empty), &amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*清除指定数目的空闲线程，如果要结束的线程个数大于0，结束线程*/</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;wait_exit_thr_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pool-&gt;wait_exit_thr_num--;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*如果线程池里线程个数大于最小值时可以结束当前线程*/</span></span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;live_thr_num &gt; pool-&gt;min_thr_num) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"thread 0x%x is exiting\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">                    pool-&gt;live_thr_num--;</span><br><span class="line">                    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">                    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*如果指定了true，要关闭线程池里的每个线程，自行退出处理*/</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;shutdown) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread 0x%x is exiting\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);     <span class="comment">/* 线程自行结束 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*从任务队列里获取任务, 是一个出队操作*/</span></span><br><span class="line">        task.function = pool-&gt;task_queue[pool-&gt;queue_front].function;</span><br><span class="line">        task.arg = pool-&gt;task_queue[pool-&gt;queue_front].arg;</span><br><span class="line"></span><br><span class="line">        pool-&gt;queue_front = (pool-&gt;queue_front + <span class="number">1</span>) % pool-&gt;queue_max_size;       <span class="comment">/* 出队，模拟环形队列 */</span></span><br><span class="line">        pool-&gt;queue_size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*通知可以有新的任务添加进来*/</span></span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queue_not_full));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*任务取出后，立即将 线程池琐 释放*/</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*执行任务*/</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 0x%x start working\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));                            <span class="comment">/*忙状态线程数变量琐*/</span></span><br><span class="line">        pool-&gt;busy_thr_num++;                                                   <span class="comment">/*忙状态线程数+1*/</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        (*(task.function))(task.arg);                                           <span class="comment">/*执行回调函数任务*/</span></span><br><span class="line">        <span class="comment">//task.function(task.arg);                                              /*执行回调函数任务*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*任务结束处理*/</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 0x%x end working\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pool-&gt;busy_thr_num--;                                       <span class="comment">/*处理掉一个任务，忙状态数线程数-1*/</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 管理线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">adjust_thread</span><span class="params">(<span class="keyword">void</span> *threadpool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">threadpool_t</span> *pool = (<span class="keyword">threadpool_t</span> *)threadpool;</span><br><span class="line">    <span class="keyword">while</span> (!pool-&gt;shutdown) &#123;</span><br><span class="line"></span><br><span class="line">        sleep(DEFAULT_TIME);                                    <span class="comment">/*定时 对线程池管理*/</span></span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">        <span class="keyword">int</span> queue_size = pool-&gt;queue_size;                      <span class="comment">/* 关注 任务数 */</span></span><br><span class="line">        <span class="keyword">int</span> live_thr_num = pool-&gt;live_thr_num;                  <span class="comment">/* 存活 线程数 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        <span class="keyword">int</span> busy_thr_num = pool-&gt;busy_thr_num;                  <span class="comment">/* 忙着的线程数 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 创建新线程 算法： 任务数大于最小线程池个数, 且存活的线程数少于最大线程个数时 如：30&gt;=10 &amp;&amp; 40&lt;100*/</span></span><br><span class="line">        <span class="keyword">if</span> (queue_size &gt;= MIN_WAIT_TASK_NUM &amp;&amp; live_thr_num &lt; pool-&gt;max_thr_num) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;(pool-&gt;lock));  </span><br><span class="line">            <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*一次增加 DEFAULT_THREAD 个线程*/</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;max_thr_num &amp;&amp; add &lt; DEFAULT_THREAD_VARY</span><br><span class="line">                    &amp;&amp; pool-&gt;live_thr_num &lt; pool-&gt;max_thr_num; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;threads[i] == <span class="number">0</span> || !is_thread_alive(pool-&gt;threads[i])) &#123;</span><br><span class="line">                    pthread_create(&amp;(pool-&gt;threads[i]), <span class="literal">NULL</span>, threadpool_thread, (<span class="keyword">void</span> *)pool);</span><br><span class="line">                    add++;</span><br><span class="line">                    pool-&gt;live_thr_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 销毁多余的空闲线程 算法：忙线程X2 小于 存活的线程数 且 存活的线程数 大于 最小线程数时*/</span></span><br><span class="line">        <span class="keyword">if</span> ((busy_thr_num * <span class="number">2</span>) &lt; live_thr_num  &amp;&amp;  live_thr_num &gt; pool-&gt;min_thr_num) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 一次销毁DEFAULT_THREAD个线程, 隨機10個即可 */</span></span><br><span class="line">            pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">            pool-&gt;wait_exit_thr_num = DEFAULT_THREAD_VARY;      <span class="comment">/* 要销毁的线程数 设置为10 */</span></span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DEFAULT_THREAD_VARY; i++) &#123;</span><br><span class="line">                <span class="comment">/* 通知处在空闲状态的线程, 他们会自行终止*/</span></span><br><span class="line">                pthread_cond_signal(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_destroy</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pool-&gt;shutdown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*先销毁管理线程*/</span></span><br><span class="line">    pthread_join(pool-&gt;adjust_tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;live_thr_num; i++) &#123;</span><br><span class="line">        <span class="comment">/*通知所有的空闲线程*/</span></span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;live_thr_num; i++) &#123;</span><br><span class="line">        pthread_join(pool-&gt;threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    threadpool_free(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放任务队列和所有的锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_free</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;task_queue) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;task_queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;threads) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threads);</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">        pthread_mutex_destroy(&amp;(pool-&gt;lock));</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pthread_mutex_destroy(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pthread_cond_destroy(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">        pthread_cond_destroy(&amp;(pool-&gt;queue_not_full));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取所有活着的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_all_threadnum</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all_threadnum = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">    all_threadnum = pool-&gt;live_thr_num;</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">    <span class="keyword">return</span> all_threadnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取忙碌的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_busy_threadnum</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> busy_threadnum = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    busy_threadnum = pool-&gt;busy_thr_num;</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    <span class="keyword">return</span> busy_threadnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断线程是否活着</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_thread_alive</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kill_rc = pthread_kill(tid, <span class="number">0</span>);     <span class="comment">//发0号信号，测试线程是否存活</span></span><br><span class="line">    <span class="keyword">if</span> (kill_rc == ESRCH) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试*/</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="comment">/* 线程池中的线程，模拟处理业务 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">process</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 0x%x working on task %d\n "</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self(),*(<span class="keyword">int</span> *)arg);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"task %d is end\n"</span>,*(<span class="keyword">int</span> *)arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">threadpool_t</span> *thp = threadpool_create(<span class="number">3</span>,<span class="number">100</span>,<span class="number">100</span>);<span class="comment">/*创建线程池，池里最小3个线程，最大100，队列最大100*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pool inited"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int *num = (int *)malloc(sizeof(int)*20);</span></span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">20</span>], i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        num[i]=i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add task %d\n"</span>,i);</span><br><span class="line">        threadpool_add(thp, process, (<span class="keyword">void</span>*)&amp;num[i]);     <span class="comment">/* 向线程池中添加任务 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">10</span>);                                          <span class="comment">/* 等子线程完成任务 */</span></span><br><span class="line">    threadpool_destroy(thp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="udp服务器"><a class="markdownIt-Anchor" href="#udp服务器"></a> UDP服务器</h3><p>无连接的不可靠报文传递</p><p>无需创建连接，所以UDP开销较小，数据传输速度快，实时性较强。</p><p>多用于对实时性要求较高的通信场合，如视频会议、电话会议等</p><p>缺点：数据传输不可靠，传输数据的正确率、传输顺序和流量都得不到控制和保证。</p><p>使用UDP协议进行数据传输，为保证数据的正确性，我们需要在应用层添加辅助校验协议来弥补UDP的不足，以达到数据可靠传输的目的。</p><p>UDP也有可能出现缓冲区被填满后，再接收数据时丢包的现象。由于它没有TCP滑动窗口的机制，通常采用如下两种方法解决：</p><ol><li><p>服务器应用层设计流量控制，控制发送数据速度。</p></li><li><p>借助setsockopt函数改变接收缓冲区大小。如：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</span><br><span class="line">int n = 220x1024</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;n, sizeof(n));</span><br></pre></td></tr></table></figure><h4 id="cs模型-udp"><a class="markdownIt-Anchor" href="#cs模型-udp"></a> C/S模型-UDP</h4><p><img src="/images/javawz/image-20220220232755019.png" alt="image-20220220232755019"></p><p>由于UDP不需要维护连接，程序逻辑简单了很多，但是UDP协议是不可靠的，保证通讯可靠性的机制需要在应用层实现。</p><h4 id="sendto"><a class="markdownIt-Anchor" href="#sendto"></a> sendto</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sendto(int s, const void *buf, int len, unsigned int flags, const struct sockaddr *to, int tolen);</span><br></pre></td></tr></table></figure><p>返回值说明：</p><p>成功则返回实际传送出去的字符数，失败返回-1，错误原因会存于errno 中。</p><p>参数说明：</p><p>    s：   socket描述符；<br>　　　　buf： UDP数据报缓存区（包含待发送数据）；<br>　　　　len：  UDP数据报的长度；<br>　　　　flags：调用方式标志位（一般设置为0）；<br>　　　　to：　 指向接收数据的主机地址信息的结构体（sockaddr_in需类型转换）；<br>　　　　tolen：to所指结构体的长度；</p><br><br><h4 id="recvfrom"><a class="markdownIt-Anchor" href="#recvfrom"></a> recvfrom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int recvfrom(int s, void *buf, int len, unsigned int flags,struct sockaddr *from, int *fromlen);</span><br></pre></td></tr></table></figure><p>返回值说明：</p><p>  成功则返回实际接收到的字符数，失败返回-1，错误原因会存于errno 中。</p><p>  参数说明：</p><p>    s：     socket描述符；</p><p>    buf：    UDP数据报缓存区（包含所接收的数据）；<br>    len：    缓冲区长度。<br>    flags：  调用操作方式（一般设置为0）。<br>    from：   指向发送数据的客户端地址信息的结构体（sockaddr_in需类型转换）；<br>    fromlen：指针，指向from结构体长度值。</p><h4 id="serverc"><a class="markdownIt-Anchor" href="#serverc"></a> Server.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ,<span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">                inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                ntohs(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line"></span><br><span class="line">        n = sendto(sockfd, buf, n, <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">"sendto error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="clientc"><a class="markdownIt-Anchor" href="#clientc"></a> Client.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sockfd, n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, BUFSIZ, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        n = sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">"sendto error"</span>);</span><br><span class="line"></span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);         <span class="comment">//NULL:不关心对端信息</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line"></span><br><span class="line">        write(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="udp实现广播"><a class="markdownIt-Anchor" href="#udp实现广播"></a> UDP实现广播</h3><pre><code>IP：192.168.42.255(广播)   IP：192.168.42.1(网关)广播需要设置套接字开启广播功能   int flag = 1;    setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;flag, sizeof(flag));给sockfd开放广播权限。</code></pre><p>客户端需要绑定端口号</p><h4 id="server"><a class="markdownIt-Anchor" href="#server"></a> server</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8000                                    <span class="comment">/* 无关紧要 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1500</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BROADCAST_IP <span class="meta-string">"192.168.42.255"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000                                    <span class="comment">/* 重要 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>, <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造用于UDP通信的套接字 */</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;                        <span class="comment">/* IPv4 */</span></span><br><span class="line">    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);         <span class="comment">/* 本地任意IP INADDR_ANY = 0 */</span></span><br><span class="line">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启广播权限</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造 client 地址 IP+端口  192.168.7.255+9000 */</span></span><br><span class="line">    bzero(&amp;clientaddr, <span class="keyword">sizeof</span>(clientaddr));</span><br><span class="line">    clientaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, BROADCAST_IP, &amp;clientaddr.sin_addr.s_addr);</span><br><span class="line">    clientaddr.sin_port = htons(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"Drink %d glasses of water\n"</span>, i++);</span><br><span class="line">        <span class="comment">//fgets(buf, sizeof(buf), stdin);</span></span><br><span class="line">        sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;clientaddr, <span class="keyword">sizeof</span>(clientaddr));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="client"><a class="markdownIt-Anchor" href="#client"></a> Client</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">localaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> confd;</span><br><span class="line">    <span class="keyword">ssize_t</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建一个socket</span></span><br><span class="line">    confd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化本地端地址</span></span><br><span class="line">    bzero(&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));</span><br><span class="line">    localaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span> , &amp;localaddr.sin_addr.s_addr);</span><br><span class="line">    localaddr.sin_port = htons(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(confd, (struct sockaddr *)&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));  <span class="comment">//显示绑定不能省略</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"...bind ok...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = recvfrom(confd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    close(confd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组播"><a class="markdownIt-Anchor" href="#组播"></a> 组播</h3><p>广播是把数据报发送给所有的机器,容易造成广播风暴，所以推荐使用组播</p><p>组播组可以是永久的也可以是临时的。组播组地址中，有一部分由官方分配的，称为永久组播组。永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">224.0.0.0～224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；</span><br><span class="line">224.0.1.0～224.0.1.255是公用组播地址，可以用于Internet；欲使用需申请。</span><br><span class="line">224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效；</span><br><span class="line">239.0.0.0～239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效。（局域网使用）</span><br></pre></td></tr></table></figure><p>可使用ip ad命令查看网卡编号，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">itcast$ ip ad</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:0a:c4:f4 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet6 fe80::20c:29ff:fe0a:c4f4/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>eth0网卡的编号是2</p><p><code>if_nametoindex</code>函数可以根据网卡名，获取网卡序号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned int if_nametoindex(const char *ifname);//传递网卡名字</span><br></pre></td></tr></table></figure><h3 id="serverc-2"><a class="markdownIt-Anchor" href="#serverc-2"></a> Server.c</h3><p>服务端要开启组播权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define GROUP &quot;239.0.0.2&quot;</span><br><span class="line">struct ip_mreqn group;</span><br><span class="line"></span><br><span class="line">inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);        /* 设置组地址 */</span><br><span class="line">inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;group.imr_address);      /* 本地任意IP */</span><br><span class="line">group.imr_ifindex = if_nametoindex(&quot;eth0&quot;);             /* 给出网卡名,转换为对应编号: eth0 --&gt; 编号  命令:ip ad */</span><br><span class="line">setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, sizeof(group));  /* 组播权限 */</span><br></pre></td></tr></table></figure><h4 id="查看ip_mreqn结构体"><a class="markdownIt-Anchor" href="#查看ip_mreqn结构体"></a> 查看ip_mreqn结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo grep -r &quot;ip_mreqn&quot; /usr/ -n</span><br><span class="line"></span><br><span class="line">struct ip_mreqn &#123;</span><br><span class="line">     struct in_addr  imr_multiaddr;      /* IP multicast address of group 组地址*/ </span><br><span class="line">     struct in_addr  imr_address;        /* local IP address of interface 本地ip*/</span><br><span class="line">     int     imr_ifindex;        /* Interface index 网卡编号*/</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1500</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">"239.0.0.2"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>, <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE] = <span class="string">"itcast\n"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);                <span class="comment">/* 构造用于UDP通信的套接字 */</span></span><br><span class="line">    </span><br><span class="line">    bzero(&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;                        <span class="comment">/* IPv4 */</span></span><br><span class="line">    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);         <span class="comment">/* 本地任意IP INADDR_ANY = 0 */</span></span><br><span class="line">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);        <span class="comment">/* 设置组地址 */</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;group.imr_address);      <span class="comment">/* 本地任意IP */</span></span><br><span class="line">    group.imr_ifindex = if_nametoindex(<span class="string">"eth0"</span>);             <span class="comment">/* 给出网卡名,转换为对应编号: eth0 --&gt; 编号  命令:ip ad */</span></span><br><span class="line"></span><br><span class="line">    setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, <span class="keyword">sizeof</span>(group));  <span class="comment">/* 组播权限 */</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;clientaddr, <span class="keyword">sizeof</span>(clientaddr));                 <span class="comment">/* 构造 client 地址 IP+端口 */</span></span><br><span class="line">    clientaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, GROUP, &amp;clientaddr.sin_addr.s_addr); <span class="comment">/* IPv4  239.0.0.2+9000 */</span></span><br><span class="line">    clientaddr.sin_port = htons(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"itcast %d\n"</span>, i++);</span><br><span class="line">        <span class="comment">//fgets(buf, sizeof(buf), stdin);</span></span><br><span class="line">        sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;clientaddr, <span class="keyword">sizeof</span>(clientaddr));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clientc-2"><a class="markdownIt-Anchor" href="#clientc-2"></a> client.c</h3><p>客户端要加入组播</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define GROUP &quot;239.0.0.2&quot;</span><br><span class="line"></span><br><span class="line">inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);                        /* 设置组地址 */</span><br><span class="line">inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;group.imr_address);                      /* 使用本地任意IP添加到组播组 */</span><br><span class="line">group.imr_ifindex = if_nametoindex(&quot;eth0&quot;);                             /* 通过网卡名--&gt;编号 ip ad */</span><br><span class="line">    </span><br><span class="line">setsockopt(confd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, sizeof(group));/* 设置client 加入多播组 */</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">"239.0.0.2"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">localaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> confd;</span><br><span class="line">    <span class="keyword">ssize_t</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span>                                                  <span class="comment">/* 组播结构体 */</span></span><br><span class="line"></span><br><span class="line">    confd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));                                   <span class="comment">/* 初始化 */</span></span><br><span class="line">    localaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span> , &amp;localaddr.sin_addr.s_addr);</span><br><span class="line">    localaddr.sin_port = htons(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    bind(confd, (struct sockaddr *)&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));</span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);                        <span class="comment">/* 设置组地址 */</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;group.imr_address);                      <span class="comment">/* 使用本地任意IP添加到组播组 */</span></span><br><span class="line">    group.imr_ifindex = if_nametoindex(<span class="string">"eth0"</span>);                             <span class="comment">/* 通过网卡名--&gt;编号 ip ad */</span></span><br><span class="line">    </span><br><span class="line">    setsockopt(confd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, <span class="keyword">sizeof</span>(group));<span class="comment">/* 设置client 加入多播组 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = recvfrom(confd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    close(confd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="socket-ipc本地套接字domain"><a class="markdownIt-Anchor" href="#socket-ipc本地套接字domain"></a> socket IPC（本地套接字domain）</h3><p>使用UNIX Domain Socket的过程和网络socket十分相似，也要先调用socket()创建一个socket文件描述符，address family指定为AF_UNIX，type可以选择SOCK_DGRAM或SOCK_STREAM，protocol参数仍然指定为0即可。</p><p>UNIX Domain Socket与网络socket编程最明显的不同在于地址格式不同，用结构体sockaddr_un表示，网络编程的socket地址是IP地址加端口号，而UNIX Domain Socket的地址是一个socket类型的文件在文件系统中的路径，这个socket文件由bind()调用创建，如果调用bind()时该文件已存在，则bind()错误返回。</p><p>对比网络套接字地址结构和本地套接字地址结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">__kernel_sa_family_t sin_family; /* Address family */  地址结构类型</span><br><span class="line">__be16 sin_port; /* Port number */端口号</span><br><span class="line">struct in_addr sin_addr;/* Internet address */IP地址</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sockaddr_un &#123;</span><br><span class="line">__kernel_sa_family_t sun_family; /* AF_UNIX */地址结构类型</span><br><span class="line">char sun_path[UNIX_PATH_MAX]; /* pathname */socket文件名(含路径)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下程序将UNIX Domain socket绑定到一个地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size = offsetof(struct sockaddr_un, sun_path) + strlen(un.sun_path);</span><br><span class="line">#define offsetof(type, member) ((int)&amp;((type *)0)-&gt;MEMBER)</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220223213103304.png" alt="image-20220223213103304"></p><h4 id="offsetof"><a class="markdownIt-Anchor" href="#offsetof"></a> offsetof</h4><p><img src="/images/javawz/image-20220223213748406.png" alt="image-20220223213748406"></p><h4 id="unlink"><a class="markdownIt-Anchor" href="#unlink"></a> unlink</h4><p>删除pathname指定的硬链接,并由pathname所引用的文件链接计数减1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int unlink(const char *pathname);</span><br></pre></td></tr></table></figure><p><img src="/images/javawz/image-20220223214357895.png" alt="image-20220223214357895"></p><p><img src="/images/javawz/image-20220223214309111.png" alt="image-20220223214309111"></p><h4 id="server-2"><a class="markdownIt-Anchor" href="#server-2"></a> server</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_ADDR  <span class="meta-string">"serv.socket"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd, len, size, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    lfd = Socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path,SERV_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);     <span class="comment">/* servaddr total len */</span></span><br><span class="line"></span><br><span class="line">    unlink(SERV_ADDR);                              <span class="comment">/* 确保bind之前serv.sock文件不存在,bind会创建该文件 */</span></span><br><span class="line">    Bind(lfd, (struct sockaddr *)&amp;servaddr, len);           <span class="comment">/* 参3不能是sizeof(servaddr) */</span></span><br><span class="line"></span><br><span class="line">    Listen(lfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accept ...\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;cliaddr, (<span class="keyword">socklen_t</span> *)&amp;len);</span><br><span class="line"></span><br><span class="line">        len -= offsetof(struct sockaddr_un, sun_path);      <span class="comment">/* 得到文件名的长度 */</span></span><br><span class="line">        cliaddr.sun_path[len] = <span class="string">'\0'</span>;                       <span class="comment">/* 确保打印时,没有乱码出现 */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client bind filename %s\n"</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((size = read(cfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">            write(cfd, buf, size);</span><br><span class="line">        &#125;</span><br><span class="line">        close(cfd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="client-2"><a class="markdownIt-Anchor" href="#client-2"></a> Client</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;         </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_ADDR <span class="meta-string">"serv.socket"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIE_ADDR <span class="meta-string">"clie.socket"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  cfd, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    cfd = Socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    cliaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(cliaddr.sun_path,CLIE_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(cliaddr.sun_path);     <span class="comment">/* 计算客户端地址结构有效长度 */</span></span><br><span class="line"></span><br><span class="line">    unlink(CLIE_ADDR);</span><br><span class="line">    Bind(cfd, (struct sockaddr *)&amp;cliaddr, len);                                 <span class="comment">/* 客户端也需要bind, 不能依赖自动绑定*/</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));                                          <span class="comment">/* 构造server 地址 */</span></span><br><span class="line">    servaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path,SERV_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);   <span class="comment">/* 计算服务器端地址结构有效长度 */</span></span><br><span class="line"></span><br><span class="line">    Connect(cfd, (struct sockaddr *)&amp;servaddr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;协议的概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#协议的概念&quot;&gt;&lt;/a&gt; 协议的概念&lt;/h3&gt;
&lt;h4 id=&quot;什么是协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是协议&quot;&gt;&lt;/a&gt; 什么是
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>线程同步</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/30/linux083%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/30/linux083线程同步/</id>
    <published>2022-01-29T17:35:19.000Z</published>
    <updated>2022-02-20T13:09:49.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-互斥锁"><a class="markdownIt-Anchor" href="#1-互斥锁"></a> 1 互斥锁</h3><h4 id="11互斥锁的使用步骤"><a class="markdownIt-Anchor" href="#11互斥锁的使用步骤"></a> 1.1互斥锁的使用步骤</h4><ul><li><p>第1步：创建一把互斥锁</p><ul><li><code>pthread_mutex_t mutex;</code></li></ul></li><li><p>初始化互斥锁</p><ul><li><code>pthread_mutex_init(&amp;mutex);</code>—相当于mutex=1</li></ul></li><li><p>在代码中寻找共享资源（也称为临界区）</p><ul><li><code>pthread_mutex_lock(&amp;mutex); -- mutex = 0</code></li></ul></li><li><p>临界区代码</p><ul><li><code>pthread_mutex_unlock(&amp;mutex); -- mutex = 1</code></li></ul></li><li><p>释放互斥锁资源</p><ul><li><code>pthread_mutex_destroy(&amp;mutex);</code></li></ul></li></ul><p>注意：必须在所有操作共享资源的线程上都加上锁否则不能起到同步的效果</p><h4 id="12-练习"><a class="markdownIt-Anchor" href="#12-练习"></a> 1.2 练习</h4><ul><li>编写思路：</li></ul><p>1 定义一把互斥锁，应该为一全局变量</p><p><code>pthread_mutex_t mutex;</code></p><p>2 在main函数中对mutex进行初始化</p><p><code>pthread_mutex_init(&amp;mutex, NULL);</code></p><p>3 创建两个线程，在两个线程中加锁和解锁</p><p>4 主线程释放互斥锁资源</p><p><code>pthread_mutex_destroy(&amp;mutex);</code></p><p><img src="/images/javawz/image-20220130014052263.png" alt="image-20220130014052263"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread1</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"world\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread2</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"HELLO "</span>);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WORLD\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1;</span><br><span class="line"><span class="keyword">pthread_t</span> thread2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机数种子</span></span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//互斥锁初始化</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">ret = pthread_create(&amp;thread1, <span class="literal">NULL</span>, mythread1, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = pthread_create(&amp;thread2, <span class="literal">NULL</span>, mythread2, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束</span></span><br><span class="line">pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放互斥锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-死锁"><a class="markdownIt-Anchor" href="#13-死锁"></a> 1.3 死锁</h3><p>死锁并不是linux提供给用户的一种使用方法，而是由于用户使用互斥锁不当引起的一种现象。</p><ul><li>常见的死锁有两种：<ul><li>第一种：自己锁自己，如下图代码片段</li><li>第二种 线程A拥有A锁，请求获得B锁；线程B拥有B锁，请求获得A锁，这样造成线程A和线程B都不释放自己的锁，而且还想得到对方的锁，从而产生死锁，如下图所示：</li></ul></li></ul><p><img src="/images/javawz/image-20220130014154167.png" alt="image-20220130014154167"></p><ul><li>如何解决死锁：<ul><li>让线程按照一定的顺序去访问共享资源</li><li>在访问其他锁的时候，需要先将自己的锁解开</li><li>调用<code>pthread_mutex_trylock</code>，如果加锁不成功会立刻返回</li></ul></li></ul><p>​自己锁自己.<br>​注意点: 线程在异常退出的时候也需要解锁.<br>A线程占用着A锁, 又想去获得B锁; B线程占用着B锁, 又想去获得A锁,<br>​  两个线程都不释放自己的锁, 又想去获得对方的锁, 从而造成了死锁.<br>​  解决方法:<br>​  1 需要先释放自己的锁再去获得其他锁<br>​  2 避免使用嵌套的锁, 让线程按照一定的顺序加锁<br>​  3 可以调用<code>pthread_mutex_trylock</code>函数加锁, 该函数不阻塞, 所以不会产生死锁.</p><h3 id="2-读写锁"><a class="markdownIt-Anchor" href="#2-读写锁"></a> 2 读写锁</h3><ul><li>什么是读写锁<ul><li>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。<strong>写独占、读共享。</strong></li></ul></li><li>读写锁使用场合<ul><li>读写锁非常适合于对数据结构读的次数远大于写的情况。</li></ul></li><li>读写锁特性<ul><li>读写锁是“写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞。</li><li>读写锁是“读模式加锁”时，如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</li><li>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高</li></ul></li><li>读写锁场景练习:<ul><li>线程A加写锁成功, 线程B请求读锁<ul><li>线程B阻塞</li></ul></li><li>线程A持有读锁, 线程B请求写锁<ul><li>线程B阻塞</li></ul></li><li>线程A拥有读锁, 线程B请求读锁<ul><li>线程B加锁成功</li></ul></li><li>线程A持有读锁, 然后线程B请求写锁, 然后线程C请求读锁<ul><li>B阻塞，c阻塞 - 写的优先级高</li><li>A解锁，B线程加写锁成功，C继续阻塞</li><li>B解锁，C加读锁成功</li></ul></li><li>线程A持有写锁, 然后线程B请求读锁, 然后线程C请求写锁<ul><li>BC阻塞</li><li>A解锁，C加写锁成功，B继续阻塞</li><li>C解锁，B加读锁成功</li></ul></li></ul></li><li>读写锁总结</li></ul><p>读并行，写独占，当读写同时等待锁的时候写的优先级高</p><ul><li><p>读写锁主要操作函数</p><ul><li>定义一把读写锁<ul><li><code>pthread_rwlock_t rwlock;</code></li></ul></li><li>初始化读写锁<ul><li><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></li><li>函数参数</li><li>rwlock-读写锁</li><li>attr-读写锁属性，传NULL为默认属性</li></ul></li><li>销毁读写锁<ul><li><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></li></ul></li><li>加读锁<ul><li><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></li></ul></li><li>尝试加读锁<ul><li><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></li></ul></li><li>加写锁<ul><li><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></li></ul></li><li>尝试加写锁<ul><li><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></li></ul></li><li>解锁<ul><li><code>int pthread_rwlock_unlock(&amp;pthread_rwlock_t *rwlock);</code></li></ul></li></ul></li><li><p>练习：3个线程不定时写同一全局资源，5个线程不定时读同一全局资源。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读写锁测试程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把读写锁</span></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写线程回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_write</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加写锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">cur = number;</span><br><span class="line">cur++;</span><br><span class="line">number = cur;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]-W:[%d]\n"</span>, i, cur);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读线程回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_read</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加读锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">cur = number;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]-R:[%d]\n"</span>, i, cur);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">pthread_t</span> thread[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//读写锁初始化</span></span><br><span class="line">pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建3个写子线程</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">pthread_create(&amp;thread[i], <span class="literal">NULL</span>, thread_write, &amp;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建5个读子线程</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">pthread_create(&amp;thread[i], <span class="literal">NULL</span>, thread_read, &amp;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回收子线程</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n; j++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_join(thread[j], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-条件变量"><a class="markdownIt-Anchor" href="#3-条件变量"></a> 3 条件变量</h3><ul><li>条件本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。<ul><li>使用互斥量保护共享数据;</li><li>使用条件变量可以使线程阻塞, 等待某个条件的发生, 当条件满足的时候解除阻塞.</li></ul></li><li>条件变量的两个动作:<ul><li>条件不满足, 阻塞线程</li><li>条件满足, 通知阻塞的线程解除阻塞, 开始工作.</li></ul></li><li>条件变量相关函数<ul><li><code>pthread_cond_t cond;</code><ul><li>定义一个条件变量</li></ul></li></ul></li><li><code>int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);</code><ul><li>函数描述:初始化条件变量</li><li>函数参数:<ul><li>cond: 条件变量</li><li>attr: 条件变量属性, 通常传NULL</li></ul></li><li>函数返回值:成功返回0, 失败返回错误号</li></ul></li><li><code>int pthread_cond_destroy(pthread_cond_t *cond);</code><ul><li>函数描述: 销毁条件变量</li><li>函数参数: 条件变量</li><li>返回值: 成功返回0, 失败返回错误号</li></ul></li><li><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code><ul><li>函数描述: 条件不满足, 引起线程阻塞并解锁;<ul><li>​     条件满足, 解除线程阻塞, 并加锁</li></ul></li><li>函数参数:<ul><li>cond: 条件变量</li><li>mutex: 互斥锁变量</li></ul></li><li>函数返回值: 成功返回0, 失败返回错误号</li></ul></li><li><code>int pthread_cond_signal(pthread_cond_t *cond);</code><ul><li>函数描述: 唤醒至少一个阻塞在该条件变量上的线程</li><li>函数参数: 条件变量</li><li>函数返回值: 成功返回0, 失败返回错误号</li></ul></li><li><code>pthread_cond_broadcas(pthread_cond_t *cond)</code><ul><li>唤醒睡眠的线程，一次唤醒所有睡眠的线程</li><li>函数参数: 条件变量</li></ul></li></ul><p>4 使用条件变量的代码片段</p><p><img src="/images/javawz/image-20220130015559506.png" alt="image-20220130015559506"></p><p>上述代码中，生产者线程调用<code>pthread_cond_signal</code>函数会使消费者线程在<code>pthread_cond_wait</code>处解除阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用条件变量实现生产者和消费者模型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line">NODE *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生产一个节点</span></span><br><span class="line">pNode = (NODE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span>(pNode==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"malloc error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pNode-&gt;data = rand()%<span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"P:[%d]\n"</span>, pNode-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">pNode-&gt;next = head;</span><br><span class="line">head = pNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知消费者线程解除阻塞</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//若条件不满足,需要阻塞等待</span></span><br><span class="line"><span class="comment">//若条件不满足,则阻塞等待并解锁;</span></span><br><span class="line"><span class="comment">//若条件满足(被生成者线程调用pthread_cond_signal函数通知),解除阻塞并加锁 </span></span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C:[%d]\n"</span>, head-&gt;data);</span><br><span class="line">pNode = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pNode);</span><br><span class="line">pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1;</span><br><span class="line"><span class="keyword">pthread_t</span> thread2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化互斥锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量初始化</span></span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建生产者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建消费者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束</span></span><br><span class="line">pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放互斥锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放条件变量</span></span><br><span class="line">pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用条件变量实现生产者和消费者模型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line">NODE *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生产一个节点</span></span><br><span class="line">pNode = (NODE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span>(pNode==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"malloc error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pNode-&gt;data = rand()%<span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"P[%d]:[%d]\n"</span>, n, pNode-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">pNode-&gt;next = head;</span><br><span class="line">head = pNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知消费者线程解除阻塞</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//若条件不满足,需要阻塞等待</span></span><br><span class="line"><span class="comment">//若条件不满足,则阻塞等待并解锁;</span></span><br><span class="line"><span class="comment">//若条件满足(被生成者线程调用pthread_cond_signal函数通知),解除阻塞并加锁 </span></span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C[%d]:[%d]\n"</span>, n, head-&gt;data);</span><br><span class="line">pNode = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pNode);</span><br><span class="line">pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">pthread_t</span> thread2[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化互斥锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量初始化</span></span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i]= i;</span><br><span class="line"><span class="comment">//创建生产者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread1[i], <span class="literal">NULL</span>, producer, &amp;arr[i]);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建消费者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread2[i], <span class="literal">NULL</span>, consumer, &amp;arr[i]);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_join(thread1[i], <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(thread2[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放互斥锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放条件变量</span></span><br><span class="line">pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h3><p>1 信号量介绍</p><p>​信号量相当于多把锁, 可以理解为是加强版的互斥锁</p><p>2 相关函数</p><p>定义信号量 <code>sem_t sem</code>;</p><ul><li><p><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></p><ul><li>函数描述: 初始化信号量</li><li>函数参数:<ul><li>sem: 信号量变量</li><li>pshared: 0表示线程同步, 1表示进程同步</li><li>value: 最多有几个线程操作共享数据</li></ul></li><li>函数返回值:成功返回0, 失败返回-1, 并设置errno值</li></ul></li><li><p><code>int sem_wait(sem_t *sem);</code></p><ul><li>函数描述: 调用该函数一次, 相当于<code>sem--</code>, 当sem为0的时候, 引起阻塞</li><li>函数参数: 信号量变量</li><li>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</li></ul></li><li><p><code>int sem_post(sem_t *sem);</code></p><ul><li>函数描述: 调用一次, 相当于<code>sem++</code></li><li>` 函数参数: 信号量变量</li><li>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</li></ul></li><li><p><code>int sem_trywait(sem_t *sem);</code></p><ul><li>函数描述: 尝试加锁, 若失败直接返回, 不阻塞</li><li>函数参数: 信号量变量</li><li>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</li></ul></li><li><p><code>int sem_destroy(sem_t *sem);</code></p><ul><li>函数描述: 销毁信号量</li><li>函数参数: 信号量变量</li><li>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</li></ul></li></ul><p>3 信号量代码片段:</p><p><img src="/images/javawz/image-20220130020118740.png" alt="image-20220130020118740"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用信号量实现生产者和消费者模型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line">NODE *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> sem_producer;</span><br><span class="line"><span class="keyword">sem_t</span> sem_consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生产一个节点</span></span><br><span class="line">pNode = (NODE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span>(pNode==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"malloc error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pNode-&gt;data = rand()%<span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"P:[%d]\n"</span>, pNode-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">sem_wait(&amp;sem_producer); <span class="comment">//--</span></span><br><span class="line"></span><br><span class="line">pNode-&gt;next = head;</span><br><span class="line">head = pNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">sem_post(&amp;sem_consumer);  <span class="comment">//相当于++</span></span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NODE *pNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">sem_wait(&amp;sem_consumer); <span class="comment">//相当于--</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C:[%d]\n"</span>, head-&gt;data);</span><br><span class="line">pNode = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">sem_post(&amp;sem_producer); <span class="comment">//相当于++</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pNode);</span><br><span class="line">pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">sleep(rand()%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1;</span><br><span class="line"><span class="keyword">pthread_t</span> thread2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化信号量</span></span><br><span class="line">sem_init(&amp;sem_producer, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">sem_init(&amp;sem_consumer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建生产者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建消费者线程</span></span><br><span class="line">ret = pthread_create(&amp;thread2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程结束</span></span><br><span class="line">pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放信号量资源</span></span><br><span class="line">sem_destroy(&amp;sem_producer);</span><br><span class="line">sem_destroy(&amp;sem_consumer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-互斥锁&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-互斥锁&quot;&gt;&lt;/a&gt; 1 互斥锁&lt;/h3&gt;
&lt;h4 id=&quot;11互斥锁的使用步骤&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11互斥锁的使用步骤
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>守护进程和线程</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/24/linux082%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/24/linux082守护进程和线程/</id>
    <published>2022-01-24T12:30:39.000Z</published>
    <updated>2022-01-29T19:12:09.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="守护进程"><a class="markdownIt-Anchor" href="#守护进程"></a> 守护进程</h2><h3 id="11-守护进程介绍"><a class="markdownIt-Anchor" href="#11-守护进程介绍"></a> 1.1 守护进程介绍</h3><p>Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字，如vsftpd</p><p>Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。</p><ul><li>总结守护进程的特点：<ul><li>Linux后台服务进程</li><li>独立于控制终端</li><li>周期性的执行某种任务</li><li>不受用户登陆和注销的影响</li><li>一般采用以d结尾的名字</li></ul></li></ul><h3 id="12-进程组和会话"><a class="markdownIt-Anchor" href="#12-进程组和会话"></a> 1.2 进程组和会话</h3><ul><li><p>进程组</p><ul><li>进程组是一个或者多个进程的集合，每个进程都属于一个进程组，引入进程组是为了简化对进程的管理。当父进程创建子进程的时候，默认子进程与父进程属于同一个进程组。</li><li>进程组ID==第一个进程ID（组长进程）。如父进程创建了多个子进程，父进程和多个子进程同属于一个组，而由于父进程是进程组里的第一个进程，所以父进程就是这个组的组长, 组长ID==父进程ID。</li><li>可以使用kill -SIGKILL -进程组ID(负的)来将整个进程组内的进程全部杀死。</li><li>只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</li><li>进程组生存期：从进程组创建到最后一个进程离开</li></ul></li><li><p>会话</p><ul><li>一个会话是一个或多个进程组的集合。</li><li>创建会话的进程不能是进程组组长</li><li>创建会话的进程成为一个进程组的组长进程，同时也成为会话的会长。</li><li>需要有root权限（ubuntu不需要）</li><li>新创建的会话丢弃原有的控制终端</li><li>建立新会话时，先调用fork, 父进程终止，子进程调用setsid函数</li><li>可以使用<code>ps ajx</code>来查看进程组ID和会话ID</li><li>可以fork出几个子进程，然后查看进程组ID和会话ID</li></ul></li><li><p>进程组和会话的关系图</p><p><img src="/images/javawz/image-20220124220938860.png" alt="image-20220124220938860"></p></li></ul><h3 id="13-创建守护进程的模型"><a class="markdownIt-Anchor" href="#13-创建守护进程的模型"></a> 1.3 创建守护进程的模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t setsid(void);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功后，将返回调用进程的（新）会话ID。一旦出错，</span><br><span class="line">返回（pid_t）-1，并设置errno以指示错误。</span><br></pre></td></tr></table></figure><ul><li><p>第1步：fork子进程，父进程退出</p><ul><li>子进程继承了父进程的进程组ID, 但具有一个新的进程ID,这样就保证了子进程不是一个进程组的组长ID,这对于下面要做的setsid函数的调用是必要的前提条件</li></ul></li><li><p>第2步：子进程调用setsid函数创建新会话</p><ul><li>调用这个函数以后</li><li>该进程成为新会话的首进程，是会话的会长</li><li>成为一个新进程组的组长进程，是进程组组长</li><li>不受控制终端的影响</li></ul></li><li><p>第3步：改变当前工作目录<code>chdir</code></p><ul><li>如：a.out在U盘上，启动这个程序，这个程序的当前的工作目录就是这个u盘，如果u盘拔掉后进程的当前工作目录将消失，a.out将不能正常工作。</li></ul></li><li><p>第4步：重设文件掩码  <code>mode &amp; ~umask</code></p><ul><li>子进程会继承父进程的掩码</li><li>增加子进程程序操作的灵活性</li><li><code>umask(0000);</code>最右边的0代表八进制</li></ul></li><li><p>第5步：关闭文件描述符</p><ul><li>守护进程不受控制终端的影响所以可以关闭，以释放资源</li><li><code>close(STDIN_FILENO);</code></li><li><code>close(STDOUT_FILENO);</code></li><li><code>close(STDERR_FILENO);</code></li></ul></li><li><p>第6步：执行核心工作</p><ul><li>守护进程的核心代码逻辑</li></ul></li></ul><h3 id="14练习"><a class="markdownIt-Anchor" href="#14练习"></a> 1.4练习</h3><p>​编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。</p><p>分析：首先要按照1.3介绍的守护进行的步骤创建一个守护进程</p><p>题目要求每隔2S钟，所以需要一个定时器，2S钟触发一次，需要调用<code>setitimer</code>函数创建一个定时器，并且要捕获SIGALRM信号，然后在SIGALRM信号处理函数里面完成获取系统时间，然后将时间写入文件。</p><ul><li>用到的主要知识点：<ul><li>创建守护进程的模型</li><li>setitimer函数的使用</li><li>sigaction函数</li><li>文件I/O操作</li><li>获取系统时间函数time，将<code>time_t</code>类型转换为字符串ctime函数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建守护进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"mydemon.log"</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0755</span>);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前的系统时间</span></span><br><span class="line"><span class="keyword">time_t</span> t;</span><br><span class="line">time(&amp;t);</span><br><span class="line">    <span class="comment">//将时间转换为字符串形式</span></span><br><span class="line"><span class="keyword">char</span> *p = ctime(&amp;t);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将时间写入文件</span></span><br><span class="line">write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//父进程fork子进程, 然后父进程退出</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span> || pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子进程调用setsid函数创建会话</span></span><br><span class="line">setsid();</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变当前的工作目录</span></span><br><span class="line">chdir(<span class="string">"/home/itcast/log"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变文件掩码</span></span><br><span class="line">umask(<span class="number">0000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭标准输入,输出和错误输出文件描述符</span></span><br><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心操作</span></span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = myfunc;</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置时钟</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tm</span>;</span></span><br><span class="line">tm.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">tm.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">tm.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">tm.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">setitimer(ITIMER_REAL, &amp;tm, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化:<br> 1 不再频繁的打开和关闭文件<br> 2 如何控制log文件大小  test.log</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写守护进程: 每隔2秒获取一次系统时间,并将时间写入文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//获取当前系统时间</span></span><br><span class="line"><span class="keyword">time_t</span> tm;</span><br><span class="line">time(&amp;tm);</span><br><span class="line"><span class="keyword">char</span> *p = ctime(&amp;tm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//新建文件</span></span><br><span class="line">fd = open(<span class="string">"./mydaemon.log"</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写文件</span></span><br><span class="line">write(fd, p, <span class="built_in">strlen</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//fork子进程，父进程退出</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span> || pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子进程调用setsid函数创建新会话</span></span><br><span class="line">setsid();</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变当前工作目录chdir</span></span><br><span class="line">chdir(<span class="string">"/home/itcast"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重设文件掩码</span></span><br><span class="line">umask(<span class="number">0000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭标准输入,标准输出, 标准错误输出这三个文件描述符</span></span><br><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心工作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = sighandler;</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用setitimer函数设置时钟</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tm</span>;</span></span><br><span class="line">tm.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">tm.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">tm.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">tm.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">setitimer(ITIMER_REAL, &amp;tm, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取文件大小</span></span><br><span class="line"><span class="keyword">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">if</span>(size&gt;<span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd);</span><br><span class="line">            <span class="comment">//文件重命名</span></span><br><span class="line">rename(<span class="string">"./mydaemon.log"</span>, <span class="string">"./mydaemon.log.bak"</span>);</span><br><span class="line">flag =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>守护进程的特点:&emsp;1 一个linux后台服务进程&emsp;2 不依赖于控制终端&emsp;3 周期性执行某些任务&emsp;4 不受用户登录和注销的影响&emsp;5 一般以d结尾<p>进程组和会话:<br> 进程组: 一个进程包含多个进程<br> 会话: 多个组组成一个会话.<br> 创建会话的进程不能是组长进程;<br> 一般创建会话是父进程先fork子进程, 然后父进程退出, 让子进程调用setsid函数<br> 创建一个会话, 这个子进程既是会长也是组长;<br> 只要是创建了会话, 这个进程就脱离了控制终端的影响.</p><p>创建守护进程模型:<br>1 父进程fork子进程, 然后父进程退出.<br>目的是: 子进程肯定不是组长进程, 为后续调用setsid函数提供了条件.<br>2 子进程调用setsid函数创建一个新的会话.<br>  1 该子进程成了该会话的会长<br>  2 该子进程成了该组的组长进程.<br>  3 不再受控制终端的影响了<br>3 改变当前的工作目录, chdir  -----不是必须的<br>4 重设文件掩码, umask(0000)  -----不是必须的<br>5 关闭<code>STDIN_FILENO STDOUT_FILENO STDERR_FILENO</code>  —不是必须的<br>6 核心操作</p><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><ul><li><h3 id="21-什么是线程"><a class="markdownIt-Anchor" href="#21-什么是线程"></a> 2.1 什么是线程</h3><ul><li>轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。</li><li>进程：拥有独立的地址空间，拥有PCB，相当于独居。</li><li>线程：有PCB，但没有独立的地址空间，多个线程共享进程空间，相当于合租。</li></ul></li></ul><p><img src="/images/javawz/image-20220124231226369.png" alt="image-20220124231226369"></p><ul><li><p>在Linux操作系统下：</p><ul><li>线程：最小的执行单位</li><li>进程：最小分配资源单位，可看成是只有一个线程的进程。</li></ul></li><li><p>线程的特点</p><ul><li>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</li><li>线程是轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</li><li>从内核里看进程和线程是一样的，都有各自不同的PCB.</li><li>进程可以蜕变成线程</li><li>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</li></ul></li></ul><p><img src="/images/javawz/image-20220124231358842.png" alt="image-20220124231358842"></p><ul><li>查看指定线程的LWP号：<code>ps –Lf pid</code></li><li>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数 clone。</li><li>如果复制对方的地址空间，那么就产出一个“进程”；</li><li>如果共享对方的地址空间，就产生一个“线程”。</li></ul><p>so：<strong>Linux内核是不区分进程和线程的, 只在用户层面上进行区分</strong>。</p><p>所以，线程所有操作函数<code>pthread_*</code> 是库函数，而非系统调用。</p><h3 id="22-线程共享资源"><a class="markdownIt-Anchor" href="#22-线程共享资源"></a> 2.2 线程共享资源</h3><ul><li>文件描述符表</li><li>每种信号的处理方式</li><li>当前工作目录</li><li>用户ID和组ID</li><li>内存地址空间 (<code>.text/.data/.bss/heap/共享库</code>)</li></ul><h3 id="23-线程非共享资源"><a class="markdownIt-Anchor" href="#23-线程非共享资源"></a> 2.3 线程非共享资源</h3><ul><li>线程id</li><li>处理器现场和栈指针(内核栈)</li><li>独立的栈空间(用户空间栈)</li><li>errno变量</li><li>信号屏蔽字</li><li>调度优先级</li></ul><h3 id="24-线程优-缺点"><a class="markdownIt-Anchor" href="#24-线程优-缺点"></a> 2.4  线程优、缺点</h3><ul><li>优点：<ul><li>提高程序并发性</li><li>开销小</li><li>数据通信、共享数据方便</li></ul></li><li>缺点：<ul><li>库函数，不稳定</li><li>gdb调试、编写困难</li><li>对信号支持不好</li></ul></li></ul><p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p><h3 id="25-pthread_create函数"><a class="markdownIt-Anchor" href="#25-pthread_create函数"></a> 2.5  pthread_create函数</h3><ul><li>头文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br></pre></td></tr></table></figure><ul><li>函数作用：</li><li>创建一个新线程</li><li>函数原型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread, </span><br><span class="line"></span><br><span class="line">const pthread_attr_t *attr,</span><br><span class="line"></span><br><span class="line">      void *(*start_routine) (void *),</span><br><span class="line"></span><br><span class="line"> void *arg</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>返回值</p><ul><li>成功，返回0</li><li>失败，返回错误号</li></ul></li><li><p>函数参数：</p><ul><li><code>pthread_t</code>：传出参数，保存系统为我们分配好的线程ID</li><li>当前Linux中可理解为：<code>typedef unsigned long int pthread_t</code>。</li><li>attr：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。</li><li><code>start_routine</code>：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。</li><li>arg：线程主函数执行期间所使用的参数。</li></ul></li><li><p>注意点</p><ul><li>由于<code>pthread_create</code>的错误码不保存在errno中，因此不能直接用<code>perror()</code>打印错误信息，可以先用<code>strerror()</code>把错误码转换成错误信息再打印。<code>strerror要包含头文件#include&lt;string.h&gt;</code></li><li>如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。</li></ul></li><li><p>练习题：</p></li></ul><p>1 编写程序创建一个线程。</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_t pthread_self(void);</span><br><span class="line"></span><br><span class="line">函数作用：获得线程自身的ID。pthread_t的类型为unsigned long int，所以在打印的时候要使用%lu方式，否则显示结果出问题。</span><br><span class="line"></span><br><span class="line">pthread_self() //获取当前线程id</span><br></pre></td></tr></table></figure><br><h4 id="多线程编译是要指定库"><a class="markdownIt-Anchor" href="#多线程编译是要指定库"></a> 多线程编译是要指定库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc xxx.c -l pthread -o xxx</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>2 编写程序创建一个线程，并给线程传递一个<code>int</code>参数</p><p>3 编写程序创建一个线程，并给线程传递一个结构体参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程: 传递参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int n = *(int *)arg;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> *<span class="title">p</span> = (<span class="title">struct</span> <span class="title">Test</span> *)<span class="title">arg</span>;</span></span><br><span class="line"><span class="comment">//struct Test *p = arg;</span></span><br><span class="line"><span class="comment">//printf("n==[%d]\n", n);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d][%s]\n"</span>, p-&gt;data, p-&gt;name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">99</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;t, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(struct Test));</span><br><span class="line">t.data = <span class="number">88</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(t.name, <span class="string">"xiaowen"</span>);</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="comment">//int ret = pthread_create(&amp;thread, NULL, mythread, &amp;n);</span></span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, &amp;t);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 编写程序，主线程循环创建5个子线程，并让子线程判断自己是第几个子线程。</p><p>练习4分析：最后每个子线程打印出来的值并不是想象中的值，比如都是5，分析其原因：</p><p>在创建子线程的时候使用循环因子作为参数传递给子线程，这样主线程和多个子线程就会共享变量i（变量i在main函数中定义，在整个进程都一直有效）所以在子线程看来变量i是合法的栈内存空间。</p><p>那么为什么最后每个子线程打印出来的值都是5呢?</p><p>是由于主线程可能会在一个cpu时间片内连续创建了5个子线程，此时变量i的值变成了5，当主线程失去cpu的时间片后，子线程得到cpu的时间片，子线程访问的是变量i的内存空间的值，所以打印出来值为5.</p><p><img src="/images/javawz/image-20220124232632703.png" alt="image-20220124232632703"></p><p>主线程和子线程共享同一块内存空间</p><p><img src="/images/javawz/image-20220124232651711.png" alt="image-20220124232651711"></p><p>主线程和子线程分时使用cpu资源</p><p>解决办法：不能使多个子线程都共享同一块内存空间，应该使每个子线程访问不同的内存空间，可以在主线程定义一个数组：<code>int arr[5];</code>，然后创建线程的时候分别传递不同的数组元素，这样每个子线程访问的就是互不相同的内存空间，这样就可以打印正确的值。</p><p>如下图：</p><p><img src="/images/javawz/image-20220124232725306.png" alt="image-20220124232725306"></p><p>多个子线程各自访问不同的内存空间</p><ul><li>根据测试程序还可以得出结论：<ul><li>如果主线程早于子线程退出，则子线程可能得不到执行，因为主线程退出，整个进程空间都会被回收，子线程没有了生存空间，所以也就得不到执行。</li><li>线程之间（包含主线程和子线程）可以共享同一变量，包含全局变量或者非全局变量（但是非全局变量必须在其有效的生存期内）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环创建子线程,并且打印是第几个子线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = *(<span class="keyword">int</span> *)arg;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:child thread, pid==[%d], id==[%ld]\n"</span>, i, getpid(), pthread_self());</span><br><span class="line">sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">pthread_t</span> thread[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">ret = pthread_create(&amp;thread[i], <span class="literal">NULL</span>, mythread, &amp;arr[i]);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26pthread_exit函数"><a class="markdownIt-Anchor" href="#26pthread_exit函数"></a> 2.6pthread_exit函数</h3><p>在线程中禁止调用exit函数，否则会导致整个进程退出，取而代之的是调用<code>pthread_exit</code>函数，这个函数是使一个线程退出，如果主线程调用<code>pthread_exit</code>函数也不会使整个进程退出，不影响其他线程的执行。</p><ul><li><p>函数描述</p><ul><li>将单个线程退出</li></ul></li><li><p>函数原型</p><ul><li><code>void pthread_exit(void *retval);</code></li></ul></li><li><p>函数参数</p><ul><li>retval表示线程退出状态，通常传NULL</li></ul></li></ul><p>另注意，<code>pthread_exit</code>或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了，栈空间就会被回收。</p><p>练习：编写程序测试<code>pthread_exit</code>函数使一个线程退出。</p><p>通过程序测试得知，<code>pthread_exit</code>函数只是使一个线程退出，假如子线程里面调用了exit函数，会使整个进程终止；如果主线程调用了<code>pthread_exit</code>函数，并不影响子线程，只是使主线程自己退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程退出函数测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> g_var = <span class="number">9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"><span class="comment">//printf("[%p]\n", &amp;g_var);</span></span><br><span class="line"><span class="comment">//pthread_exit(&amp;g_var);</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;t, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line">t.data = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(t.name, <span class="string">"xiaowen"</span>);</span><br><span class="line">pthread_exit(&amp;t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//回收子线程</span></span><br><span class="line"><span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">pthread_join(thread, &amp;p);</span><br><span class="line"><span class="comment">//int n = *(int *)p;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> *<span class="title">pt</span> = (<span class="title">struct</span> <span class="title">Test</span> *)<span class="title">p</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child exit status:[%d],[%s],[%p]\n"</span>,  pt-&gt;data, pt-&gt;name, p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="27-pthread_join函数"><a class="markdownIt-Anchor" href="#27-pthread_join函数"></a> 2.7 pthread_join函数</h3><ul><li><p>函数描述：阻塞等待线程退出，获取线程退出状态。其作用，对应进程中的waitpid() 函数。</p></li><li><p>函数原型：<code>int pthread_join(pthread_t thread, void **retval);</code></p></li><li><p>函数返回值：</p><ul><li>成功：0；</li><li>失败：错误号</li></ul></li><li><p>函数参数：</p><ul><li>thread：线程ID</li><li>retval：存储线程结束状态，整个指针和<code>pthread_exit</code>的参数是同一块内存地址。</li></ul></li></ul><p>练习：编写程序，使主线程获取子线程的退出状态。</p><p>一般先定义<code>void *ptr; 然后pthread_join(threadid, &amp;ptr);</code></p><h3 id="28-pthread_detach函数"><a class="markdownIt-Anchor" href="#28-pthread_detach函数"></a> 2.8 pthread_detach函数</h3><p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p><p>进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</p><p>也可使用 pthread_create函数参2(线程属性)来设置线程分离。<code>pthread_detach</code>函数是在创建线程之后调用的。</p><ul><li>函数描述<ul><li>实现线程分离</li></ul></li><li>函数原型<ul><li><code>int pthread_detach(pthread_t thread);</code></li></ul></li><li>函数返回值<ul><li>成功：0；</li><li>失败：错误号</li></ul></li></ul><p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用<code>pthread_ join</code>获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。不能对一个已经处于detach状态的线程调用<code>pthread_ join</code>，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了<code>pthread_detach</code>就不能再调用<code>pthread_ join</code>了。</p><p>练习：编写程序，在创建线程之后设置线程的分离状态。</p><p>说明：如果线程已经设置了分离状态，则再调用<code>pthread_ join</code>就会失败，可用这个方法验证是否已成功设置分离状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置子线程为分离属性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置线程为分离属性</span></span><br><span class="line">pthread_detach(thread);</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程设置分离属性,则pthread_join不再阻塞,立刻返回</span></span><br><span class="line">ret = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_join error:[%s]\n"</span>, strerror(ret));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="29-pthread_cancel函数"><a class="markdownIt-Anchor" href="#29-pthread_cancel函数"></a> 2.9 pthread_cancel函数</h3><ul><li><p>函数描述</p></li><li><p>杀死(取消)线程。其作用，对应进程中 kill() 函数。</p></li><li><p>函数原型</p></li><li><p><code>int pthread_cancel(pthread_t thread);</code></p></li><li><p>函数返回值</p></li><li><p>成功：0；</p></li><li><p>失败：错误号</p></li><li><p>【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。</p></li><li><p>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</p></li><li><p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write… 执行命令<code>man 7 pthreads</code>可以查看具备这些取消点的系统调用列表。可粗略认为一个系统调用(进入内核)即为一个取消点。还以通过调用<code>pthread_testcancel</code>函数设置一个取消点。</p><ul><li>函数原型：<code>void pthread_testcancel(void);</code></li></ul></li></ul><p>练习：编写程序，让主线程取消子线程的执行。</p><p>先测试一下没有取消点看看能否使线程取消；然后调用<code>pthread_testcancel</code>设置一个取消点，看看能够使线程取消。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置取消点</span></span><br><span class="line"><span class="comment">//pthread_testcancel();</span></span><br><span class="line"><span class="comment">//printf也有取消点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消子线程</span></span><br><span class="line">pthread_cancel(thread);</span><br><span class="line"></span><br><span class="line">pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="210-pthread_equal函数"><a class="markdownIt-Anchor" href="#210-pthread_equal函数"></a> 2.10 pthread_equal函数</h3><ul><li>函数描述：</li><li>比较两个线程ID是否相等。</li><li>函数原型</li><li><code>int pthread_equal(pthread_t t1, pthread_t t2);</code></li></ul><p>注意：这个函数是为了以能够扩展使用的， 有可能Linux在未来线程ID <code>pthread_t</code>类型被修改为结构体实现。</p><h3 id="211-进程函数和线程函数比较"><a class="markdownIt-Anchor" href="#211-进程函数和线程函数比较"></a> 2.11 进程函数和线程函数比较</h3><table><thead><tr><th>进程</th><th>线程</th></tr></thead><tbody><tr><td><strong>fork</strong></td><td><strong>pthread_create</strong></td></tr><tr><td><strong>exit</strong></td><td><strong>pthread_exit</strong></td></tr><tr><td><strong>wait/waitpid</strong></td><td><strong>pthread_join</strong></td></tr><tr><td><strong>kill</strong></td><td><strong>pthread_cancel</strong></td></tr><tr><td><strong>getpid</strong></td><td><strong>pthread_self</strong></td></tr></tbody></table><p><br><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较线程ID是否相等</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//                      void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较线程ID</span></span><br><span class="line"><span class="comment">//if(pthread_equal(thread, pthread_self())!=0)</span></span><br><span class="line"><span class="keyword">if</span>(pthread_equal(pthread_self(), pthread_self())!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"two thread id is same\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"two thread id is not same\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目的是为了让子线程能够执行起来</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-线程属性"><a class="markdownIt-Anchor" href="#3-线程属性"></a> 3 线程属性</h3><p>linux下线程的属性是可以根据实际项目需要，进行设置，之前讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题，如果对程序的性能提出更高的要求，则需要设置线程属性，本节以设置线程的分离属性为例讲解设置线程属性。</p><ul><li><p>线程的分离状态决定一个线程以什么样的方式来终止自己，有两种状态：</p><ul><li>非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</li><li>分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</li></ul></li><li><p>设置线程属性分为以下步骤</p></li><li><p>第1步：定义线程属性类型类型的变量</p><ul><li><code>pthread_attr_t attr;</code></li></ul></li><li><p>第2步：对线程属性变量进行初始化</p><ul><li><code>int pthread_attr_init (pthread_attr_t* attr);</code></li></ul></li><li><p>第3步：设置线程为分离属性</p></li><li><p><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code></p><ul><li>参数:<ul><li>attr: 线程属性</li><li>detachstate:<ul><li><code>PTHREAD_CREATE_DETACHED</code>(分离)</li><li><code>PTHREAD_CREATE_JOINABLE</code>（非分离)</li></ul></li></ul></li></ul></li></ul><p>注意：这一步完成之后调用<code>pthread_create</code>函数创建线程，</p><p>则创建出来的线程就是分离线程；其实上述三步就是</p><p><code>pthread_create</code>的第二个参数做准备工作。</p><ul><li>第4步：释放线程属性资源<ul><li><code>int pthread_attr_destroy(pthread_attr_t *attr);</code></li><li>参数：线程属性</li></ul></li></ul><p>练习：编写程序，创建一个分离属性的线程。</p><p>验证：设置为分离属性的线程是不能够被<code>pthread_join</code>函数回收的，</p><p>可以通过调用<code>pthread_join</code>函数测试该线程是否已经是分离属性的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在创建子线程的时候设置分离属性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义pthread_attr_t类型的变量</span></span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化attr变量</span></span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置attr为分离属性</span></span><br><span class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread, &amp;attr, mythread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error, [%s]\n"</span>, strerror(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main thread, pid==[%d], id==[%ld]\n"</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放线程属性</span></span><br><span class="line">pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证子线程是否为分离属性</span></span><br><span class="line">ret = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_join error:[%s]\n"</span>, strerror(ret));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-线程同步"><a class="markdownIt-Anchor" href="#4-线程同步"></a> 4 线程同步</h3><h4 id="41-线程同步的概念"><a class="markdownIt-Anchor" href="#41-线程同步的概念"></a> 4.1 线程同步的概念</h4><p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p><h4 id="42-线程同步的例子"><a class="markdownIt-Anchor" href="#42-线程同步的例子"></a> 4.2 线程同步的例子</h4><p>创建两个线程，让两个线程共享一个全局变量<code>int number</code>， 然后让每个线程数5000次数，看最后打印出这个number值是多少？</p><p>线程A代码片段：</p><p><img src="/images/javawz/image-20220128210559848.png" alt="image-20220128210559848"></p><p>线程B代码片段：</p><p><img src="/images/javawz/image-20220128210619983.png" alt="image-20220128210619983"></p><ul><li><p>代码片段说明</p><ul><li>代码中使用调用usleep是为了让两个子线程能够轮流使用CPU，避免一个子线程在一个时间片内完成5000次数数。</li><li>对number执行++操作，使用了中间变量cur是为了尽可能的模拟cpu时间片用完而让出cpu的情况。</li></ul></li><li><p>测试结果</p><ul><li>经过多次测试最后的结果显示，有可能会出现number值少于5000*2=10000的情况。</li></ul></li><li><p>分析原因</p><ul><li>假如子线程A执行完了cur++操作，还没有将cur的值赋值给number失去了cpu的执行权，子线程B得到了cpu执行权，而子线程B最后执行完了number=cur，而后失去了cpu的执行权；此时子线程A又重新得到cpu的执行权，并执行number=cur操作，这样会把线程B刚刚写回number的值被覆盖了，造成number值不符合预期的值。</li></ul><p><img src="/images/javawz/image-20220128210754455.png" alt="image-20220128210754455"></p></li><li><p>数据混乱的原因</p><ul><li>资源共享（独享资源则不会）</li><li>调度随机（线程操作共享资源的先后顺序不确定）</li><li>线程间缺乏必要的同步机制。</li></ul></li></ul><p>以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p><ul><li><p>如何解决问题</p><ul><li>原子操作的概念</li></ul><p>原子操作指的是该操作要么不做，要么就完成。</p><ul><li>使用互斥锁解决同步问题</li></ul><p>使用互斥锁其实是模拟原子操作，互斥锁示意图：</p></li></ul><p>Linux中提供一把互斥锁mutex（也称之为互斥量）。每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p><p>资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</p><p><img src="/images/javawz/image-20220128210816722.png" alt="image-20220128210816722"></p><p>线程1访问共享资源的时候要先判断锁是否锁着，如果锁着就阻塞等待；若锁是解开的就将这把锁加锁，此时可以访问共享资源，访问完成后释放锁，这样其他线程就有机会获得锁。</p><p>应该注意：图中同一时刻，只能有一个线程持有该锁，只要该线程未完成操作就不释放锁。</p><p>​使用互斥锁之后，两个线程由并行操作变成了串行操作，效率降低了，但是数据不一致的问题得到解决了。</p><h4 id="43互斥锁主要相关函数"><a class="markdownIt-Anchor" href="#43互斥锁主要相关函数"></a> 4.3互斥锁主要相关函数</h4><ul><li><p><code>pthread_mutex_t</code>类型</p><ul><li>其本质是一个结构体，为简化理解，应用时可忽略其实现细节，简单当成整数看待。</li><li><code>pthread_mutex_t mutex;</code>变量mutex只有两种取值1、0。</li></ul></li><li><p><code>pthread_mutex_init</code>函数</p><ul><li>函数描述：<ul><li>初始化一个互斥锁(互斥量) —&gt; 初值可看作1</li></ul></li><li>函数原型：<ul><li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></li></ul></li><li>函数参数<ul><li>mutex：传出参数，调用时应传<code>&amp;mutex</code></li><li>attr：互斥锁属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。</li></ul></li></ul></li><li><p><strong>restrict关键字</strong>：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改互斥量mutex的两种初始化方式：</p><ul><li><strong>静态初始化</strong>：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。</li><li><code>pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</code></li><li><strong>动态初始化</strong>：局部变量应采用动态初始化。</li></ul></li></ul><p><code>pthread_mutex_init(&amp;mutex, NULL);</code></p><ul><li><p><code>pthread_mutex_destroy</code>函数</p></li><li><p>函数描述</p><ul><li>销毁一个互斥锁</li></ul></li><li><p>函数原型</p><ul><li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></li></ul></li><li><p>函数参数</p><ul><li>mutex—互斥锁变量</li></ul></li><li><p><code>pthread_mutex_lock</code>函数</p><ul><li>函数描述<ul><li>对互斥所加锁，可理解为将<code>mutex--</code></li></ul></li><li>函数原型<ul><li><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></li></ul></li><li>函数参数<ul><li>mutex—互斥锁变量</li></ul></li></ul></li><li><p><code>pthread_mutex_unlock</code>函数</p><ul><li>函数描述</li><li>对互斥所解锁，可理解为将mutex ++</li><li>函数原型</li><li><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li></ul></li><li><p><code>pthread_mutex_trylock</code>函数</p><ul><li>函数描述<ul><li>尝试加锁</li></ul></li><li>函数原型<ul><li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></li></ul></li><li>函数参数<ul><li>mutex—互斥锁变量</li></ul></li></ul></li></ul><h4 id="44-加锁和解锁"><a class="markdownIt-Anchor" href="#44-加锁和解锁"></a> 4.4 加锁和解锁</h4><ul><li>lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</li><li>unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</li></ul><p>练习：使用互斥锁解决两个线程数数不一致的问题。</p><p>代码片段：在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好。</p><p><img src="/images/javawz/image-20220128211719750.png" alt="image-20220128211719750"></p><p>总结：使用互斥锁之后，两个线程由并行变为了串行，效率降低了，但是可以使两个线程同步操作共享资源，从而解决了数据不一致的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 50000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mythread1</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">n = number;</span><br><span class="line">n++;</span><br><span class="line">number = n;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"A: [%d]\n"</span>,number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mythread2</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NUM;i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">n = number;</span><br><span class="line">n++;</span><br><span class="line">number = n;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"B: [%d]\n"</span>,number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1;</span><br><span class="line"><span class="keyword">pthread_t</span> thread2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret1 = pthread_create(&amp;thread1,<span class="literal">NULL</span>,mythread1,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret1 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error: [%s]\n"</span>,strerror(ret1));</span><br><span class="line"><span class="keyword">return</span> ret1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ret2 = pthread_create(&amp;thread2,<span class="literal">NULL</span>,mythread2,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret2 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_create error: [%s]\n"</span>,strerror(ret2));</span><br><span class="line"><span class="keyword">return</span> ret2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> *retval1;</span><br><span class="line"><span class="keyword">void</span> *retval2;</span><br><span class="line"><span class="keyword">int</span> join_ret = pthread_join(thread1,&amp;retval1);</span><br><span class="line"><span class="keyword">if</span>(join_ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_join error [%s]\n"</span>,strerror(join_ret));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> join_ret2 = pthread_join(thread2,&amp;retval2);</span><br><span class="line"><span class="keyword">if</span>(join_ret2 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pthread_join error [%s]\n"</span>,strerror(join_ret2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"number [%d]"</span>,number);</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥锁: 线程A和线程B共同访问共享资源, 当线程A想访问共享资源的时候,<br>要先获得锁, 如果锁被占用, 则加锁不成功需要阻塞等待对方释放锁;<br>若锁没有被占用, 则获得锁成功–加锁, 然后操作共享资源, 操作完之后,<br>必须解锁, 同理B也是和A一样.<br>也就是说, 同时不能有两个线程访问共享资源, 属于互斥操作.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;守护进程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#守护进程&quot;&gt;&lt;/a&gt; 守护进程&lt;/h2&gt;
&lt;h3 id=&quot;11-守护进程介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-守护进程介绍&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
</feed>
