<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanChen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowuyoucy.github.io/"/>
  <updated>2021-05-27T02:40:43.370Z</updated>
  <id>https://xiaowuyoucy.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Win32程序的执行单元</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/20/win0003-Win32%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/20/win0003-Win32程序的执行单元/</id>
    <published>2021-05-19T16:32:15.000Z</published>
    <updated>2021-05-27T02:40:43.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="win32程序的执行单元"><a class="markdownIt-Anchor" href="#win32程序的执行单元"></a> Win32程序的执行单元</h1><h3 id="线程的创建"><a class="markdownIt-Anchor" href="#线程的创建"></a> 线程的创建</h3><h4 id="线程函数的定义"><a class="markdownIt-Anchor" href="#线程函数的定义"></a> 线程函数的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI ThreadProc(LPVOID lpParam) //线程函数名ThreadProc可以随意的</span><br></pre></td></tr></table></figure><p>WINAPI 是一个宏名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define WINAPI __stdcall;</span><br></pre></td></tr></table></figure><p><code>__stdcall</code>是新标准C/C++函数的调用方法</p><p><code>__stdcall</code>采用自动清栈的方式</p><p><code>__cdecl</code>采用的是手工清栈方式</p><p><code>ThreadProc</code>是一个回调函数</p><p>如果没有显式说明的话，函数的调用方法是<code>__cdecl</code></p><p>lpParam参数由CreateTHread函数的第四个参数指定</p><h4 id="创建新线程的函数是createthread"><a class="markdownIt-Anchor" href="#创建新线程的函数是createthread"></a> 创建新线程的函数是CreateThread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateThread（</span><br><span class="line">LPSECURITY_ATTRIBUTES lpThreadAttributes，//线程的安全属性</span><br><span class="line">DWORD dwStackSize，//指定线程堆栈的大小</span><br><span class="line">LPTHREAD_START_ROUTINE lpStartAddress，//线程函数的起始地址</span><br><span class="line">LPVOID IpParameter，//传递给线程函数的参数</span><br><span class="line">DWORD dwCreationFlags，//指定创线程建后是否立即启动</span><br><span class="line">DWORD* pThreadld//用于取得内核给新生成的线程分配的线程ID号</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>成功：返回新建线程的句柄</p><p>IpThreadAttributes参数:</p><p>如果指定为NULL表示默认安全属性,且不可继承</p><p>如果希望此线程对象句柄可以被继承,则必须设定一个SECURITY_ATTRIBUTES结构,将它的bInheritHandle成员初始化为TRUE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SECURITY ATTRIBUTES sa</span><br><span class="line">sa.nLength =sizeof(sa)；</span><br><span class="line">sa.lpSecurityDescriptor = NULL;</span><br><span class="line">sa.binheritHandle=TRUE;</span><br><span class="line">//使CreateThread返回的句柄可以被继承</span><br><span class="line">//句柄h可以被子进程继承</span><br><span class="line">HANDLE h=：CreateThread(&amp;sa，....);</span><br></pre></td></tr></table></figure><p>dwCreationFlags—创建标志:</p><p>如果是0，表示线程被创建后立即开始运行；如果指定为CREATE_SUSPENDED标志，表示线程被创建以后处于挂起（暂停）状态，直到使用ResumeThread函数</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" I am from a thread, count = %d \n"</span>, i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD dwThreadId;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个线程</span></span><br><span class="line">hThread = ::CreateThread (</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认安全属性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认堆栈大小</span></span><br><span class="line">ThreadProc,<span class="comment">// 线程入口地址（执行线程的函数）</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 传给函数的参数</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">// 指定线程立即运行</span></span><br><span class="line">&amp;dwThreadId);<span class="comment">// 返回线程的ID号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Now another thread has been created. ID = %d \n"</span>, dwThreadId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待新线程运行结束</span></span><br><span class="line">::WaitForSingleObject (hThread, INFINITE);</span><br><span class="line">::CloseHandle (hThread);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>INFINITE表示无限时间等待</p><h4 id="waitforsingleobject函数等待新线程运行结束"><a class="markdownIt-Anchor" href="#waitforsingleobject函数等待新线程运行结束"></a> WaitForSingleObject函数等待新线程运行结束</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//等待新线程运行结束</span><br><span class="line">::WaitForSingleObject（</span><br><span class="line">hThread，//hHandle 要等待的对象的句柄</span><br><span class="line">INFINITE);//dwMilliseconds要等待的时间（以毫秒为单位）</span><br></pre></td></tr></table></figure><p>WaitForSingleObject函数用于等待指定的对象（hHandle）变成受信状态。参数dwMilliseconds给出了以毫秒为单位的要等待的时间，其值指定为INFINITE表示要等待无限长的时间。</p><p>当有下列一种情况发生时函数就会返回：<br>（1）要等待的对象变成受信（signaled）状态。<br>（2）参数dwMilliseconds指定的时间已过去。</p><p>一个可执行对象有两种状态，未受信（nonsignaled）和受信（signaled）状态。</p><p><code>线程对象只有当线程运行结束时才达到受信状态</code>，此时&quot;WaitForSingleObject（hThread，INFINITE）&quot;语句才会返回。</p><hr><h3 id="内核句柄对象"><a class="markdownIt-Anchor" href="#内核句柄对象"></a> 内核句柄对象</h3><p>线程内核对象就是一个包含了线程状态信息的数据结构。每一次对Create Thread函数的成<br>功调用，系统都会在内部为新的线程分配一个内核对象。系统提供的管理线程的函数其实就是<br>依靠访问线程内核对象来实现管理的。</p><p>线程内核对象（Thread Kernel Object）</p><p><img src="/images/javawz/1621938794206.png" alt="1621938794206"></p><h4 id="1线程上下文context"><a class="markdownIt-Anchor" href="#1线程上下文context"></a> 1，线程上下文CONTEXT</h4><p>每个线程都有它自己的一组CPU寄存器，称为<code>线程的上下文</code>。这组寄存器的值保存在一<br>个CONTEXT结构里，反映了该线程上次运行时CPU寄存器的状态。</p><h4 id="2使用计数usage-count"><a class="markdownIt-Anchor" href="#2使用计数usage-count"></a> 2，使用计数Usage Count</h4><p>Usage Count成员记录了线程内核对象的使用计数，这个计数说明了此内核对象被打开的<br>次数。</p><p>当这个值是0的时候，系统就认为已经没有任何进程在引用此内核对象了，于是线程内核对象就要从内存中撤销。<br>只要线程没有结束运行， Usage Count的值就至少为1。</p><p>在创建一个新的线程时，CreateThread函数返回线程内核对象的句柄，相当于打开一次新创建的内核对象，这也会促使Usage Count的值加1，所以创建一个新的线程后，初始状态下Usage Count的值是2。之后，只要有进程打开此内核对象，就会使Usage Count的值加1。比如当有一个进程调用OpenThread<br>函数打开这个线程内核对象后， Usage Count的值会再次加1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenThread(</span><br><span class="line">DWORD dwDesiredAccess， //想要的访问权限，可以为THREAD ALL ACCESS等</span><br><span class="line">BOOL bInheritHandle，//指定此函数返回的句柄是否可以被子进程继承</span><br><span class="line">DWORD dwThreadld//目标线程ID号</span><br><span class="line">);//注意， OpenThread函数是Windows 2000及其以上产品的新特性， Windows 98并不支持它。</span><br></pre></td></tr></table></figure><p>由于对这个函数的调用会使Usage Count的值加1，所以在使用完它们返回的句柄后一定要调用CloseHandle函数进行关闭。关闭内核对象句柄的操作就会使Usage Count的值减1.</p><p>还有一些函数仅仅返回内核对象的<code>伪句柄</code>，并不会创建新的句柄，当然也就不会影响Usage Count的值。如果对这些伪句柄调用CloseHandle函数，那么CloseHandle就会忽略对自己的调用并返回FALSE，对进程和线程来说，这些函数有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HANDLE GetCurrentProcess 0； //返回当前进程句柄</span><br><span class="line">HANDLE GetCurrentThread 0； //返回当前线程句柄</span><br></pre></td></tr></table></figure><p>如果线程结束后Usage Count不为0,会造成内存泄露   当然，线程所在的进程结束后，该进程占用的所有资源都要释放</p><h4 id="暂停次数suspend-count"><a class="markdownIt-Anchor" href="#暂停次数suspend-count"></a> 暂停次数Suspend Count</h4><p>线程内核对象中的Suspend Count用于指明线程的暂停计数。</p><p>当调用CreateProcess （创建进程的主线程）或CreateThread函数时，线程的内核对象就被创建了，它暂停计数被初始化为1 （即处于暂停状态），这可以阻止新创建的线程被调度到CPU中。</p><p>因为线程的初始化需要时间，当线程完全初始化好了之后， CreateProcess或CreateThread检查是否传递了<code>CREATE_SUSPENDED</code>标志。如果传递了这个标志，那么这些函数就返回，同时新线程处于暂停状态。</p><p>如果尚未传递该标志，那么线程的暂停计数将被递减为0。当线程的暂停计数是0的时候，该线程就处于可调度状态。</p><p>暂停次数为1:暂停状态</p><p>暂停次数为0:可调度状态</p><h4 id="resunethread唤醒一个线程"><a class="markdownIt-Anchor" href="#resunethread唤醒一个线程"></a> ResuneThread唤醒一个线程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD ResuneThread (HANDLE hThread);      //唤醒一个挂起的线程</span><br></pre></td></tr></table></figure><p>该函数减少线程的暂停计数，当计数值减到0的时候，线程被恢复运行。如果调用成功ResumeThread函数返回线程的前一个暂停计数，否则返回OxFFFFFFFF （-1）。<br>单个线程可以被暂停若干次。如果一个线程被暂停了3次，它必须被唤醒3次才可以分配给一个CPU</p><h4 id="suspendthread函数挂起一个线程"><a class="markdownIt-Anchor" href="#suspendthread函数挂起一个线程"></a> SuspendThread函数挂起一个线程。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI SuspendThread(</span><br><span class="line">　　_In_HANDLE hThread</span><br><span class="line">　　);</span><br></pre></td></tr></table></figure><p><code>可调度的（没有处于暂停状态）</code></p><p>大约每经20ms， Windows查看一次当前存在的所有线程内核对象。在这些对象中，只有<br>一少部分是可调度的（没有处于暂停状态）， Windows选择其中的一个内核对象，将它的<br>CONTEXT （上下文）装入CPU的寄存器，这一过程称为<code>上下文转换</code>。</p><h3 id="退出代码exit-code"><a class="markdownIt-Anchor" href="#退出代码exit-code"></a> 退出代码Exit Code</h3><p>成员Exit Code指定了线程的退出代码，也可以说是线程函数的返回值。在线程运行期间，线程函数还没有返回， Exit Code的值是STILL_ACTIVE。线程运行结束后，系统自动将Exit Code设为线程函数的返回值。可以用GetExitCodeThread函数得到线程的退出代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwExitCode；</span><br><span class="line">if(GetExitCodeThread(hThread， &amp;dwExitCode))</span><br><span class="line">&#123;</span><br><span class="line">if(dwExitCode == STILL ACTIVE)</span><br><span class="line">&#123;&#125;//目标线程还在运行</span><br><span class="line">else</span><br><span class="line">&#123;&#125;//目标线程已经中止，退出代码为dwExitCode</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">........</span><br></pre></td></tr></table></figure><h4 id="getexitcodethread得到线程的退出代码"><a class="markdownIt-Anchor" href="#getexitcodethread得到线程的退出代码"></a> GetExitCodeThread得到线程的退出代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL GetExitCodeThread( HANDLE hThread, LPDWORD lpExitCode);</span><br></pre></td></tr></table></figure><h3 id="是否受信signaled"><a class="markdownIt-Anchor" href="#是否受信signaled"></a> 是否受信Signaled</h3><p>成员Signaled指示了线程对象是否为“受信”状态。</p><p>线程在运行期间， Signaled的值永远是FALSE，即“<code>未受信</code>”，只有当线程结束以后，系统才把Signaled的值置为TRUE，此时，针对此对象的等待函数就会返回，如上一小节中的WaitForSingleObject函数。</p><p>线程结束后,会变成受信状态</p><h3 id="线程的终止"><a class="markdownIt-Anchor" href="#线程的终止"></a> 线程的终止</h3><p>一当线程正常终止时，会发生下列事件：<br>在线程函数中创建的所有C++对象将通过它们各自的析构函数被正确地销毁。<br>该线程使用的堆栈将被释放。<br>系统将线程内核对象中Exit Code （退出代码）的值由STILL_ ACTIVE设置为线程函数的返回值。<br>系统将递减线程内核对象中Usage Code （使用计数）的值。</p><h4 id="终止线程的执行有4种方法"><a class="markdownIt-Anchor" href="#终止线程的执行有4种方法"></a> 终止线程的执行有4种方法:</h4><p>（1）线程函数自然退出。当函数执行到return语句返回时， Windows将终止线程的执行。<br>建议使用这种方法终止线程的执行。<br>（2）使用ExitThread函数来终止线程，原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void ExitThread（ DWORD dwExiCode ）//线程的退出代码</span><br></pre></td></tr></table></figure><p>ExitThread函数会中止当前线程的运行，促使系统释放掉所有此线程使用的资源。但是，<br>CCt资源却不能得到正确地清除。</p><p>（3）使用TerminateThread函数在一个线程中强制终止另一个线程的执行，原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL TerminateThread(</span><br><span class="line">HANDLE hThread， //目标线程句柄</span><br><span class="line">DWORD dwExitCode //目标线程的退出代码</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>（4）使用ExitProcess函数结束进程，这时系统会自动结束进程中所有线程的运行。用这<br>种方法相当于对每个线程使用TerminateThread函数，所以也应当避免这种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLSPEC_NORETURN VOID ExitProcess(UINT uExitCode);//进程退出代码</span><br></pre></td></tr></table></figure><h4 id="线程的优先级"><a class="markdownIt-Anchor" href="#线程的优先级"></a> 线程的优先级</h4><p>每个线程都要被赋予一个优先级号，取值为0（最低）到31 （最高）。</p><p>调用WaitForSingleObject函数就会导致主线程处于不可调度状态，还有在第4章要讨论的GetMessage函数，也会使线程暂停运行。</p><p>Windows支持6个优先级类： idle， below normal， normal， above normal，high和real-time.</p><p>线程刚被创建时，他的相对优先级总是被设置为normal，若要改变线程的优先级，必须<br>使用下面这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL SetThreadPriority(HANDLE hThread,int nPriority );</span><br></pre></td></tr></table></figure><p>hThread参数是目标线程的句柄, nPriority参数定义了线程的优先级,取值如下所示:</p><p>THREAD_PRIORITY_TIME_CRITICALTime-critical (实时)</p><p>THREAD_PRIORITY_HIGHEST_Highest (最高)</p><p>THREAD_PRIORITY_ABOVE_NORMAL   Above normal (高于正常, Windows 98不支持)</p><p>THREAD_PRIORITY_NORMAL Nornal (正常)</p><p>THREAD_PRIORITY_BELOW_NORMAL   Below normal （低于正常， Windows 98不支持）</p><p>THREAD_PRIORITY_LOWEST   Lowest （最低）</p><p>THREAD_PRIORITY_IDLE   Idle （空闲）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadIdle</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i++&lt;<span class="number">10</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Idle Thread is running \n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadNormal</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i++&lt;<span class="number">10</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Normal Thread is running \n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwThreadID;</span><br><span class="line">HANDLE h[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个优先级为Idle的线程</span></span><br><span class="line">h[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadIdle, <span class="literal">NULL</span>,</span><br><span class="line">CREATE_SUSPENDED, &amp;dwThreadID);</span><br><span class="line">::SetThreadPriority(h[<span class="number">0</span>], THREAD_PRIORITY_IDLE);</span><br><span class="line">::ResumeThread(h[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个优先级为Normal的线程</span></span><br><span class="line">h[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadNormal, <span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两个线程内核对象都变成受信状态</span></span><br><span class="line">::WaitForMultipleObjects(</span><br><span class="line"><span class="number">2</span>,    <span class="comment">// DWORD nCount  要等待的内核对象的数量</span></span><br><span class="line">h,    <span class="comment">// CONST HANDLE *lpHandles 句柄数组</span></span><br><span class="line">TRUE,    <span class="comment">// BOOL bWaitAll指定是否等待所有内核对象变成受信状态</span></span><br><span class="line">INFINITE);  <span class="comment">// DWORD dwMilliseconds 要等待的时间</span></span><br><span class="line">   </span><br><span class="line">::CloseHandle(h[<span class="number">0</span>]);</span><br><span class="line">::CloseHandle(h[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>创建线程时可以给参数指定CREATE_SUSPENDED，让线程挂起</p><p>ResumeThread函数恢复线程运行。</p><h4 id="waitformultipleobjects函数"><a class="markdownIt-Anchor" href="#waitformultipleobjects函数"></a> <code>WaitForMultipleObjects</code>函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForMultipleObjects(</span><br><span class="line">DWORD nCount,//数组个数</span><br><span class="line">const HANDLE* lpHandles,//句柄数组</span><br><span class="line">BOOL bWaitAll,//指定是否等待所有内核对象变成受信状态</span><br><span class="line">DWORD dwMilliseconds//要等待的时间</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>用于等待多个内核对象，前两个参数分别为要等待的内核对象的个数和句柄数组指针。</p><p>如果将第三个参数bWaitAll的值设为TRUE，等待的内核对象全部变成受信状态以后此函数才返回。否则， bWaitAll为0的话，只要等待的内核对象中有一个变成了受信状态， WaitForMultipleObjects就返回，返回值指明了是哪一个内核对象变成了受信状态。</p><p>参数bWaitAll为FALSE的时候， WaitForMultpleObjects函数从索引0开始扫描整个句柄<br>数组，第一个受信的内核对象将终止函数的等待，使函数返回。</p><p>下面的代码说明了函数返回值的作用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h[<span class="number">2</span>];</span><br><span class="line">h[<span class="number">0</span>] = hThread1;</span><br><span class="line">h[<span class="number">1</span>] = hThread2;</span><br><span class="line">DWORD dw = ::WaitForMultipleObjects(<span class="number">2</span>, h, FALSE, <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">switch</span>(dw)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WAIT_FAILED:</span><br><span class="line"><span class="comment">// 调用WaitForMultipleObjects函数失败(句柄无效？)</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_TIMEOUT:</span><br><span class="line"><span class="comment">// 在5秒内没有一个内核对象受信</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0 + <span class="number">0</span>:</span><br><span class="line"><span class="comment">// 句柄h[0]对应的内核对象受信</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0 + <span class="number">1</span>:</span><br><span class="line"><span class="comment">// 句柄h[1]对应的内核对象受信</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cc运行期库"><a class="markdownIt-Anchor" href="#cc运行期库"></a> C/C++运行期库</h4><p><code>#include &lt;process.h&gt;</code></p><p>在实际的开发过程中，一般不直接使用windows系统提供的CreateThread函数创建线程，<br>而是使用C/C++运行期函数_beginthreadex。</p><p>_beginthreadex的参数与CreateThread函数是对应的，只是参数名和类型不完全相同，使用的<br>时候需要强制转化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned long _beginthreadex(</span><br><span class="line">void *security,</span><br><span class="line">unsigned stack_size,</span><br><span class="line">unsigned (__stdcall *start_address) ( void *),</span><br><span class="line">void *arglist,</span><br><span class="line">unsigned initflag,</span><br><span class="line">unsigned *thrdaddr</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>相应地， C/C++运行期库也提供了另一个版本的结束当前线程运行的函数，用于取代<br>ExitThread函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void  _endthreadex（unsigned retval ）； //指定退出代码</span><br></pre></td></tr></table></figure><p>这个函数会释放_beginthreadex为保持线程同步而申请的内存空间，然后再调用ExitThread<br>函数来终止线程。</p><p>使用_beginthreadex来创建一个线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">my</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">132</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">132</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">132</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD threadId;</span><br><span class="line">HANDLE h = (HANDLE) _beginthreadex(<span class="literal">NULL</span>,<span class="literal">NULL</span>,(_beginthreadex_proc_type)my,<span class="literal">NULL</span>,<span class="number">0</span>, (<span class="keyword">unsigned</span>*)&amp;threadId);</span><br><span class="line">WaitForSingleObject(h, INFINITE);</span><br><span class="line">    CloseHandle(h);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h2><h3 id="临界区对象"><a class="markdownIt-Anchor" href="#临界区对象"></a> 临界区对象</h3><p>当多个线程在同一个进程中执行时，可能有不止一个线程同时执行同一段代码，访问同一段内存中的数据。多个线程同时读共享数据没有问题，但如果同时读和写，情况就不同了。</p><h4 id="使用临界区对象"><a class="markdownIt-Anchor" href="#使用临界区对象"></a> 使用临界区对象</h4><p>临界区对象是定义在数据段中的一个CRITICAL_SECTION结构， Windows内部使用这个结构记录一些信息，确保在同一时间只有一个线程访问该数据段中的数据。</p><p>编程的时候，要把临界区对象定义在想保护的数据段中，然后在任何线程使用此临界区对象之前对它进行初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void InitializeCriticalSection（LPCRITICAL_SECTION IpCriticalSection）；</span><br><span class="line">//指向数据段中定义的CRITICAL_SECTION结构</span><br></pre></td></tr></table></figure><p>线程访问临界区中数据的时候，必须首先调用EnterCriticalSection函数，申请进入临界区（文叫关键代码段），在同一时间内， Windows只允许一个线程进入临界区。</p><p>所以在申请的时候，如果有另一个线程在临界区的话， EnterCriticalSection函数会一直等待下去，直到其他线程离开临界区才返回。EnterCriticalSection函数用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void EnterCriticalSection（ LPCRITICAL_SECTION IpCriticalSection）；</span><br></pre></td></tr></table></figure><p>当操作完成的时候，还要将临界区交还给Windows，以便其他线程可以申请使用。这个工作由LeaveCriticalSection函数来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void LeaveCriticalSection（ LPCRITICAL_SECTION IpCriticalSection）;</span><br></pre></td></tr></table></figure><p>当程序不再使用临界区对象的时候，必须使用DeleteCriticalSection函数将它删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void DeleteCriticalSection（ LPCRITICAL_SECTION IpCriticalSection）;</span><br></pre></td></tr></table></figure><p>现在使用临界区对象来改写上面有同步问题的计数程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;process.h&gt;</span><br><span class="line"></span><br><span class="line">BOOL g_bContinue = TRUE;</span><br><span class="line">int g_nCount1 = 0;</span><br><span class="line">int g_nCount2 = 0;</span><br><span class="line">CRITICAL_SECTION g_cs; // 对存在同步问题的代码段使用临界区对象</span><br><span class="line"></span><br><span class="line">UINT __stdcall ThreadFunc(LPVOID);</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">UINT uId;</span><br><span class="line">HANDLE h[2];</span><br><span class="line"></span><br><span class="line">// 初始化临界区对象</span><br><span class="line">::InitializeCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">h[0] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId);</span><br><span class="line">h[1] = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunc, NULL, 0, &amp;uId);</span><br><span class="line"></span><br><span class="line">// 等待1秒后通知两个计数线程结束，关闭句柄</span><br><span class="line">Sleep(1000);</span><br><span class="line">g_bContinue = FALSE;</span><br><span class="line">::WaitForMultipleObjects(2, h, TRUE, INFINITE);</span><br><span class="line">::CloseHandle(h[0]);</span><br><span class="line">::CloseHandle(h[1]);</span><br><span class="line"></span><br><span class="line">// 删除临界区对象</span><br><span class="line">::DeleteCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">printf(&quot;g_nCount1 = %d \n&quot;, g_nCount1);</span><br><span class="line">printf(&quot;g_nCount2 = %d \n&quot;, g_nCount2);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT __stdcall ThreadFunc(LPVOID)</span><br><span class="line">&#123;</span><br><span class="line">while(g_bContinue)</span><br><span class="line">&#123;</span><br><span class="line">::EnterCriticalSection(&amp;g_cs);</span><br><span class="line">g_nCount1++;</span><br><span class="line">g_nCount2++;</span><br><span class="line">::LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="互锁函数"><a class="markdownIt-Anchor" href="#互锁函数"></a> 互锁函数</h4><p>互锁函数为同步访问多线程共享变量提供了一个简单的机制。如果变量在共享内存，不同<br>进程的线程也可以使用此机制。</p><p>用于互锁的函数有InterlockedIncrement. InterlockedDecrement.<br>InterlockedExchangeAdd， InterlockedExchangePointer等.</p><p>InterlockedIncrement函数递增（加1）指定的32位变量。这个函数可以阻止其他线程同<br>时使用此变量，函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LONG InterlockedIncrement（ LONG volatile* Addend）;</span><br><span class="line">//指向要递增的变量</span><br></pre></td></tr></table></figure><p>InterlockedDecrement函数同步递减（减1）指定的32位变量，原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LONG InterlockedDecrement( LONG volatile* Addend);</span><br><span class="line">//指向要递减的变量</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// InterlockDemo.cpp文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_nCount1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> g_nCount2 = <span class="number">0</span>;</span><br><span class="line">BOOL g_bContinue = TRUE;</span><br><span class="line"></span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UINT uId;</span><br><span class="line">HANDLE h[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">h[<span class="number">0</span>] = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId);</span><br><span class="line">h[<span class="number">1</span>] = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待1秒后通知两个计数线程结束，关闭句柄</span></span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">g_bContinue = FALSE;</span><br><span class="line">::WaitForMultipleObjects(<span class="number">2</span>, h, TRUE, INFINITE);</span><br><span class="line">::CloseHandle(h[<span class="number">0</span>]);</span><br><span class="line">::CloseHandle(h[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"g_nCount1 = %d \n"</span>, g_nCount1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"g_nCount2 = %d \n"</span>, g_nCount2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ThreadFunc</span><span class="params">(LPVOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(g_bContinue)</span><br><span class="line">&#123;</span><br><span class="line">::InterlockedIncrement((<span class="keyword">long</span>*)&amp;g_nCount1);</span><br><span class="line">::InterlockedIncrement((<span class="keyword">long</span>*)&amp;g_nCount2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件内核对象"><a class="markdownIt-Anchor" href="#事件内核对象"></a> 事件内核对象</h4><p>多线程程序设计大多会涉及线程间相互通信。</p><p>事件对象（event）是一种抽象的对象，它也有未受信（nonsignaled）和受信（signaled）两种状态，编程人员也可以使用WaitForSingleObject函数等待其变成受信状态。</p><p>事件对象包含3个成员： nUsageCount （使用计数）、bManualReset （是否人工重置）和<br>bSignaled （是否受信）。</p><p>成员nUsagecount记录当前的使用计数，当使用计数为0的时候，Windows就会销毁此内核对象占用的资源；</p><p>成员bManualReset指定在一个事件内核对象上等待的函数返回之后， Windows是否重置这个对象为未受信状态；</p><p>成员bsignaled指定当前事件内核对象是否受信。</p><p>如果想使用事件对象，需要首先用<code>CreateEvent</code>函数去创建它，初始状态下， nUsageCount<br>的值为1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateEvent（</span><br><span class="line">LPSECURITY_ATTRIBUTES IpEventAttributes，//用来定义事件对象的安全属性</span><br><span class="line">BOOL bManualReset,//指定是否需要手动重置事件对象为未受信状态。</span><br><span class="line">BOOL bInitialState，//指定事件对象创建时的初始状态</span><br><span class="line">LPCWSTR IpName）;//事件对象的名称</span><br></pre></td></tr></table></figure><p>参数bManualReset对应着内核对象中的bManualReset成员。</p><p>自动重置（auto-reset）和人工重置（manual-reset）是事件内核对象两种不同的类型。</p><p>当一个人工重置的事件对象受信以后，所有等待在这个事件上的线程都会变为可调度状态(暂停次数为0)；</p><p>可是当一个自动重置的事件对象受信以后， Windows仅允许一个等待在该事件上的线程变成可调度状态，然后就自动重置此事件对象为未受信状态。</p><p>blnitialState参数对应着bSignaled成员。</p><p>将它设为TRUE，则表示事件对象创建时的初始化状态为受信(结束)（bSignaled =TRUE）；设为FALSE时，状态为未受信(未结束)（bSignaled =FALSE）。</p><p>IpName参数用来指定事件对象的名称。为事件对象命名是为了在其他地方（比如，其他<br>进程的线程中）使用OpenEvent或CreateEvent函数获取此内核对象的句柄。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenEvent (</span><br><span class="line">DWORD dwDesiredAccess, //指定想要的访问权限</span><br><span class="line">BOOL blnheritHandle, //指定返回句柄是否可被继承</span><br><span class="line">LPCWSTR IpName); //要打开的事件对象的名称</span><br></pre></td></tr></table></figure><p>系统创建或打开一个事件内核对象后，会返回事件的句柄。当编程人员不使用此内核对象的时候，应该调用CloseHandle函数释放它占用的资源。</p><p>事件对象被建立后，程序可以通过SetEvent和ResetEvent函数来设置它的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BOOL SetEvent(HANDLE hEvent ); //将事件状态设为&quot;受信(sigaled) &quot;;</span><br><span class="line">BOOL ResetEvent(HANDLE hEvent); //将事件状态设为&quot;未受信(nonsigaled) &quot;;</span><br></pre></td></tr></table></figure><p>通常情况下，为一个自动重置类型的事件对象调用ResetEvent函数是不必要的，因为Windows会自动重置此事件对象。</p><p>下面例子中，主线程通过将事件状态设为“受信”来通知子线程开始工作。这是事件内核对<br>象一个很重要的用途，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE g_hEvent;</span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ChildFunc</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hChildThread;</span><br><span class="line">UINT uId;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个自动重置的（auto-reset events），未受信的（nonsignaled）事件内核对象</span></span><br><span class="line">g_hEvent = ::CreateEvent(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">hChildThread = (HANDLE)::_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ChildFunc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;uId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知子线程开始工作</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please input a char to tell the Child Thread to work: \n"</span>);</span><br><span class="line">getchar();</span><br><span class="line">::SetEvent(g_hEvent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待子线程完成工作，释放资源</span></span><br><span class="line">::WaitForSingleObject(hChildThread, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"All the work has been finished. \n"</span>);</span><br><span class="line">::CloseHandle(hChildThread);</span><br><span class="line">::CloseHandle(g_hEvent);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT __<span class="function">stdcall <span class="title">ChildFunc</span><span class="params">(LPVOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">::WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Child thread is working...... \n"</span>);</span><br><span class="line">::Sleep(<span class="number">5</span>*<span class="number">1000</span>); <span class="comment">// 暂停5秒，模拟真正的工作</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量内核对象"><a class="markdownIt-Anchor" href="#信号量内核对象"></a> 信号量内核对象</h3><p>信号量（Semaphore）内核对象对线程的同步方式与前面几种方法不同，它允许多个线程<br>在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</p><p>在用CreateSemaphore函数创建信号量时，即要同时指出允许的最大资源计数和当前可用资源计数。</p><p>一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可<br>用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。</p><p>但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能再允许<br>其他线程的进入，此时的信号量信号将无法发出。</p><p>线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore函数将当前可用资源计数加1，在任何时候当前可用资源计数决不可能大于最大资源计数。</p><p><img src="../../themes/pure/source/images/javawz/1622071965844.png" alt="1622071965844"></p><p>以箭头和白色箭头表示共享资源所允许的最大资源计数和当前可用资源计数。</p><p>黑色箭头表示已经访问的资源个数。当可用资源为0时，其他线程不能进入，直到可用资源大于0时，其他线程才可访问</p><p>信号量也被称作Dikstrait数器。</p><p>使用信号量内核对象进行线程同步主要会用到CreateSemaphore，OpenSemaphore、ReleaseSemaphore、 WaitForSingleObject和WaitForMultipleObjects等函数。</p><h4 id="其中createsemaphore用来创建一个信号量内核对象其函数原型为"><a class="markdownIt-Anchor" href="#其中createsemaphore用来创建一个信号量内核对象其函数原型为"></a> 其中CreateSemaphore用来创建一个信号量内核对象，其函数原型为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateSemaphore(</span><br><span class="line">LPSECURITY_ATTRIBUTES IpSemaphoreAttributes,//安全属性指针</span><br><span class="line">LONG IInitialCount,//初始计数</span><br><span class="line">LONG IMaximumCount,//最大计数</span><br><span class="line">LPCTSTR IpName//对象名指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参数IMaximumCount是一个有符号32位值，定义了允许的最大资源计数，最大取值不能<br>超过4294967295， IpName参数可以为创建的信号量定义一个名字，由于其创建的是一个内核<br>对象，因此在其他进程中可以通过该名字而得到此信号量。</p><h4 id="opensemaphore-函数即可用来根据信号量名打开在其他进程中创建的信号量函数原型如下"><a class="markdownIt-Anchor" href="#opensemaphore-函数即可用来根据信号量名打开在其他进程中创建的信号量函数原型如下"></a> OpenSemaphore （）函数即可用来根据信号量名打开在其他进程中创建的信号量，函数原型如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenSemaphore(</span><br><span class="line">DWORD dwDesiredAccess,//访问标志</span><br><span class="line">BOOL bInheritHandle,//继承标志</span><br><span class="line">LPCTSTR IpName//信号量名</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在线程离开对共享资源的处理时，必须通过ReleaseSemaphore来增加当前可用资源计数。否则，将会出现当前正在处理共享资源的实际线程数并没有达到要限制的数值，而其他线程却因为当前可用资源计数为0而仍无法进入的情况。</p><h4 id="releasesemaphore的函数原型为"><a class="markdownIt-Anchor" href="#releasesemaphore的函数原型为"></a> ReleaseSemaphore的函数原型为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL ReleaseSemaphore(</span><br><span class="line">HANDLE hSemaphore,//信号量句柄</span><br><span class="line">LONG IReleaseCount,//计数递增数量</span><br><span class="line">LPLONG IpPreviousCount//先前计数</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该函数将IReleaseCount中的值添加给信号量的当前资源计数，一般将IReleaseCount设置<br>为1，如果需要也可以设置其他的值。</p><p>WaitForSingleObject和WaitForMultipleObjects主要用在试图进入共享资源的线程函数入口处，主要用来判断信号量的当前可用资源计数是否允许本线程的进入。</p><p>只有在当前可用资源计数值大于0时，被监视的信号量内核对象才会得到通知。</p><p>信号量的使用特点使甚更适用于对Socket （套接字）程序中线程的同步。</p><p>例如，网络上的HTTP服务器要对同一时间内访问同一页面的用户数加以限制，这时可以为没一个用户对服务<br>器的页面请求设置一个线程，而页面则是待保护的共享资源，通过使用信号量对线程的同步作用可以确保在任一时刻无论有多少用户对某一页面进行访问，只有不大于设定的最大用户数目的线程能够进行访问，而其他的访问企图则被挂起，只有在有用户退出对此页面的访问后才有可能进入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;process.h&gt;//使用_beginthreadex创建线程需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量对象句柄</span></span><br><span class="line">HANDLE hSemaphore;</span><br><span class="line"></span><br><span class="line"><span class="function">UINT WINAPI <span class="title">myThread</span><span class="params">(LPVOID pParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//试图进入信号量关口</span></span><br><span class="line">WaitForSingleObject(hSemaphore, INFINITE);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放信号量计数</span></span><br><span class="line">ReleaseSemaphore(hSemaphore,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建信号量对象</span></span><br><span class="line">hSemaphore = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">HANDLE h1 = (HANDLE) _beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE h2 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE h3 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE h4 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(h1, INFINITE);</span><br><span class="line">WaitForSingleObject(h2, INFINITE);</span><br><span class="line">WaitForSingleObject(h3, INFINITE);</span><br><span class="line">WaitForSingleObject(h4, INFINITE);</span><br><span class="line">   </span><br><span class="line">    CloseHandle(h1);</span><br><span class="line">    CloseHandle(h2);</span><br><span class="line">    CloseHandle(h3);</span><br><span class="line">    CloseHandle(h4);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥内核对象"><a class="markdownIt-Anchor" href="#互斥内核对象"></a> 互斥内核对象</h3><p>互斥（Mutex）是一种用途非常广泛的内核对象。</p><p>能够保证多个线程对同一共享资源的互斥访问。</p><p>同临界区有些类似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。</p><p>当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。</p><p>与其他几种内核对象不同，互斥对象在操作系统中拥有特殊代码，并由操作系统来管理，操作系统<br>甚至还允许其进行一些其他内核对象所不能进行的非常规操作。</p><p><img src="../../themes/pure/source/images/javawz/1622074362650.png" alt="1622074362650"></p><p>黑点表示令牌，只有拿到令牌的线程才能进入访问资源，访问结束后要交出令牌，不然其他线程会一直无法访问该资源。</p><p>以互斥内核对象来保持线程同步可能用到的函数主要有CreateMutex、OpenMutex.<br>ReleaseMutex、 WaitForSingleObject和WaitForMultipleObjects等。</p><p>在使用互斥对象前，首先要通过CreateMutex或OpenMutex创建或打开一个互斥对象。</p><h4 id="createmutex函数原型如下"><a class="markdownIt-Anchor" href="#createmutex函数原型如下"></a> CreateMutex函数原型如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateMutex(</span><br><span class="line">LPSECURITY_ATTRIBUTES IpMutexAttributes， //安全属性指针</span><br><span class="line">BOOL bInitialOwner，//初始拥有者</span><br><span class="line">LPCTSTR IpName//互斥对象名</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数blnitialowner主要用来控制互斥对象的初始状态。一般多将其设置为FALSE，以表<br>明互斥对象在创建时并没有为任何线程所占有。</p><p>如果在创建互斥对象时指定了对象名，那么可以在本进程其他地方或是在其他进程通过OpenMutex函数得到此互斥对象的句柄。</p><h4 id="openmutex函数原型为"><a class="markdownIt-Anchor" href="#openmutex函数原型为"></a> OpenMutex函数原型为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenMutex(</span><br><span class="line">DWORD dwDesiredAccess，//访问标志</span><br><span class="line">BOOL bInheritHandle， //继承标志</span><br><span class="line">LPCTSTR IpName//互斥对象名</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当目前对资源具有访问权的线程不再需要访问此资源而要离开时，必须通过ReleaseMutex函数来释放其拥有的互斥对。</p><h4 id="releasemutex函数原型为"><a class="markdownIt-Anchor" href="#releasemutex函数原型为"></a> ReleaseMutex函数原型为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL ReleaseMutex(HANDLE hMutex);</span><br></pre></td></tr></table></figure><p>其惟一的参数hMutex为待释放的互斥对象句柄。</p><p>至于WaitForSingleObject和WaitForMultipleObjects等待函数在互斥对象保持线程同步中所起的作用与在其他内核对象中的作用是基本一致的，也是等待互斥内核对象的通知。</p><p>但是这里需要特别指出的是：在互斥对象通知引起调用等待函数返回时，等待函数的返回值不再是通常的<code>WAIT_OBJECT_0</code> （对于WaitForSingleObject函数）或是在<code>WAIT_OBJECT_0</code>到<code>WAIT_OBJECT_0+nCount-1</code>之间的一个值（对于WaitForMultipleObiects函数）</p><p>而是将返回一个<code>WAIT_ABANDONED_0</code> （对于WaitForSingleObject函数）或是在<code>WAIT_ABANDONED_0</code>到<code>WAIT_ABANDONED_0+nCount-1</code>之间的一个值（对于WaitForMultipleObjects函数） ，以此来表明线程正在等待的互斥对象由另外一个线程所拥有，而此线程却在使用完共享资源前就已经终止。</p><p>除此之外，使用互斥对象的方法在等待线程的可调度性上同使用其他几种内核对象的方法也有所不同，其他内核对象在没有得到通知时，受调用等待函数的作用，线程将会挂起，同时失去可调度性，<code>而使用互斥的方法却可以在等待的同时仍具有可调度性，这也正是互斥对象所能完成的非常规操作之一</code></p><h4 id="关于wait_abandoned或wait_abandoned_0返回值"><a class="markdownIt-Anchor" href="#关于wait_abandoned或wait_abandoned_0返回值"></a> 关于WAIT_ABANDONED或WAIT_ABANDONED_0返回值</h4><p>假设有A、B两个线程和一个互斥量hMutex。如果A线程调用WaitForSingleObject获取到互斥量后，并没有调用ReleaseMutex来释放互斥量就终止了（如调用了ExitThread,TerminateThread）。然后线程B调用WaitForSingleObject就会返回WAIT_ABANDONED，并且线程B获取到互斥量，线程B使用完成后应该调用ReleasMutex释放互斥量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量对象句柄</span></span><br><span class="line">HANDLE hMutex;</span><br><span class="line">HANDLE h1;</span><br><span class="line">HANDLE h2;</span><br><span class="line">HANDLE h3;</span><br><span class="line">HANDLE h4; </span><br><span class="line"></span><br><span class="line"><span class="function">UINT WINAPI <span class="title">myThread</span><span class="params">(LPVOID pParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了"</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ReleaseMutex(hMutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//试图进入信号量关口</span></span><br><span class="line">DWORD dw =  WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line"><span class="keyword">switch</span> (dw)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WAIT_FAILED:</span><br><span class="line"><span class="comment">// 调用WaitForMultipleObjects函数失败(句柄无效？)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="string">"调用WaitForMultipleObjects函数失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_TIMEOUT:</span><br><span class="line"><span class="comment">// 在10毫秒后没有一个内核对象受信</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="string">"等待10ms后Mutex内核对象未受信,所以结束本线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0:</span><br><span class="line"><span class="comment">// hMutex句柄对应的内核对象受信</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="string">" hMutex句柄对应的内核对象受信,本线程会正常工作"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_ABANDONED_0:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"上一个线程在使用完之后,没有使用ReleaseMutex释放"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">":  "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ReleaseMutex(hMutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">":  "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//释放信号量计数</span></span><br><span class="line"><span class="comment">//ReleaseMutex(hMutex);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建信号量对象</span></span><br><span class="line">hMutex = CreateMutex(<span class="literal">NULL</span>,FALSE,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">h1 = (HANDLE) _beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"a"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">h2 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"b"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">h3 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"c"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">h4 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"d"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(h1, INFINITE);</span><br><span class="line">WaitForSingleObject(h2, INFINITE);</span><br><span class="line">WaitForSingleObject(h3, INFINITE);</span><br><span class="line">WaitForSingleObject(h4, INFINITE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写程序时，互斥对象多用在对那些为多个线程所访问的内存块的保护上，可以确保任<br>何线程在处理此内存块时都对其拥有可靠的独占访问权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量对象句柄</span></span><br><span class="line">HANDLE hMutex;</span><br><span class="line">HANDLE h1;</span><br><span class="line">HANDLE h2;</span><br><span class="line">HANDLE h3;</span><br><span class="line">HANDLE h4; </span><br><span class="line"></span><br><span class="line"><span class="function">UINT WINAPI <span class="title">myThread</span><span class="params">(LPVOID pParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了"</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//试图进入信号量关口</span></span><br><span class="line">DWORD dw =  WaitForSingleObject(hMutex, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">switch</span> (dw)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WAIT_FAILED:</span><br><span class="line"><span class="comment">// 调用WaitForMultipleObjects函数失败(句柄无效？)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="string">"调用WaitForMultipleObjects函数失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_TIMEOUT:</span><br><span class="line"><span class="comment">// 在10毫秒后没有一个内核对象受信</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="string">"等待10ms后Mutex内核对象未受信,所以结束本线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0:</span><br><span class="line"><span class="comment">// hMutex句柄对应的内核对象受信</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">"线程"</span> &lt;&lt; <span class="string">" hMutex句柄对应的内核对象受信,本线程会正常工作"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sleep(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span> *)pParam &lt;&lt; <span class="string">":  "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//释放信号量计数</span></span><br><span class="line">ReleaseMutex(hMutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建信号量对象</span></span><br><span class="line">hMutex = CreateMutex(<span class="literal">NULL</span>,FALSE,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">h1 = (HANDLE) _beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"a"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">h2 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"b"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">h3 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"c"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">h4 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (_beginthreadex_proc_type)myThread, <span class="string">"d"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(h1, INFINITE);</span><br><span class="line">WaitForSingleObject(h2, INFINITE);</span><br><span class="line">WaitForSingleObject(h3, INFINITE);</span><br><span class="line">WaitForSingleObject(h4, INFINITE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程局部存储"><a class="markdownIt-Anchor" href="#线程局部存储"></a> 线程局部存储</h3><p>线程局部存储（thread-local storage， TLS）是一个使用很方便的存储线程局部数据的系统。<br>利用TLS机制可以为进程中所有的线程关联若干个数据，各个线程通过由TLS分配的全局索引来访问与自己关联的数据。</p><p>这样，每个线程都可以有线程局部的静态存储数据。<br>用于管理TLS的数据结构是很简单的， Windows仅为系统中的每一个进程维护一个位数组，再为该进程中的每一个线程申请一个同样长度的数组空间。</p><p><img src="../../themes/pure/source/images/javawz/1622081496611.png" alt="1622081496611"></p><p>运行在系统中的每一个进程都有一个位数组。</p><p>位数组的成员是一个标志，每个标志的值被设为FREE或INUSE，指示了此标志对应的数组索引是否在使用中。</p><p>Windodws保证至少有TLS_MINIMUM_AVAILABLE（定义在WinNTh文件中）个标志位可用。</p><h4 id="1主线程调用tisalloc函数为线程局部存储分配索引函数原型为"><a class="markdownIt-Anchor" href="#1主线程调用tisalloc函数为线程局部存储分配索引函数原型为"></a> （1）主线程调用TIsAlloc函数为线程局部存储分配索引，函数原型为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD TIsAlloc(void);//返回一个TLS索引</span><br></pre></td></tr></table></figure><p>系统为每一个进程都维护着一个长度为TLS_MINIMUM_AVAILABLE的位数组， TIsAlloc的返回值就是数组的一个下标（索引）。</p><p>这个位数组的惟一用途就是记忆哪一个下标在使用中。</p><p>初始状态下，此位数组成员的值都是FREE，表示未被使用。</p><p>当调用TIsAlloc的时候，系统会挨个检查这个数组中成员的值，直到找到一个值为FREE的成员。把找到的成<br>员的值由FREE改为INUSE后， TIsAlloc函数返回该成员的索引。</p><p>如果不能找到一个值为FREE的成员， TIsAlloc函数就返回TLS_OUT_OF_INDEXES （在WinBase.h文件中定义为-1），意味着失败。</p><h5 id="当一个线程被创建时-windows就会在进程地址空间中为该线程分配一个长度为tls_minimum_available的数组数组成员的值都被初始化为0"><a class="markdownIt-Anchor" href="#当一个线程被创建时-windows就会在进程地址空间中为该线程分配一个长度为tls_minimum_available的数组数组成员的值都被初始化为0"></a> 当一个线程被创建时， Windows就会在进程地址空间中为该线程分配一个长度为TLS_MINIMUM_AVAILABLE的数组，数组成员的值都被初始化为0。</h5><h5 id="在内部系统将此数组与该线程关联起来保证只能在该线程中访问此数组中的数据"><a class="markdownIt-Anchor" href="#在内部系统将此数组与该线程关联起来保证只能在该线程中访问此数组中的数据"></a> 在内部，系统将此数组与该线程关联起来，保证只能在该线程中访问此数组中的数据。</h5><h5 id="每个线程都有它自己的数组数组成员可以存储任何数据"><a class="markdownIt-Anchor" href="#每个线程都有它自己的数组数组成员可以存储任何数据"></a> 每个线程都有它自己的数组，数组成员可以存储任何数据。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;win32程序的执行单元&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#win32程序的执行单元&quot;&gt;&lt;/a&gt; Win32程序的执行单元&lt;/h1&gt;
&lt;h3 id=&quot;线程的创建&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h
      
    
    </summary>
    
      <category term="windows程序设计" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Win32程序运行原理</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/19/win0002-Win32%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/19/win0002-Win32程序运行原理/</id>
    <published>2021-05-18T18:02:51.000Z</published>
    <updated>2021-05-19T16:27:45.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="win32程序运行原理"><a class="markdownIt-Anchor" href="#win32程序运行原理"></a> Win32程序运行原理</h1><h3 id="cpu的保护模式和windows系统"><a class="markdownIt-Anchor" href="#cpu的保护模式和windows系统"></a> CPU的保护模式和Windows系统</h3><p>80386处理器有三种工作模式：实模式、保护模式和虚拟86模式</p><p>实模式和虚拟模式是为了和8086处理器兼容而设置的</p><p>Windows操作系统运行在保护模式中</p><h4 id="windows的多任务实现"><a class="markdownIt-Anchor" href="#windows的多任务实现"></a> Windows的多任务实现</h4><p>多任务隔离技术：可以使每个任务都有独立的地址空间，就像每个任务独享一个CPU一样</p><p>在Windows中任务被进程取代</p><p>进程就是正在运行的应用程序的实例（执行它的是线程，进程实则就是一块应用程序的空间）</p><p>Windows是多任务操作系统 每个进程内的线程只能访问自己 线程的内存，不能访问其他进程的内存</p><p>例如 有进程A，B</p><p>A进程中的线程只能访问自己进程的内存，不能访问B进程中的地址</p><h3 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h3><p>Windows为每个进程分配4GB的地址空间主要依靠CPU支持</p><p>CPU在保护模式下支持虚拟存储</p><p>虚拟内存：将磁盘空间当做内存空间来使用</p><p>页文件：包含了对所有进程都有效的虚拟内存</p><p>4GB虚拟地址的前半部分留给系统，后半部分留给用户</p><p><img src="/images/javawz/1621362607000.png" alt="1621362607000"></p><p>系统空间：内核代码、设备驱动代码等等。部分空间是共享的</p><h3 id="内核模式和用户模式"><a class="markdownIt-Anchor" href="#内核模式和用户模式"></a> 内核模式和用户模式：</h3><p>80386处理器共定义了4中（0~3）特权级别 称为<code>环</code></p><p><img src="/images/javawz/1621363114545.png" alt="1621363114545"></p><p>0是特权级(最高级)</p><p>3是用户级</p><p>Windows有两种模式:</p><p>内核模式是0级：系统程序（驱动等等）</p><p>用户模式是3级</p><p>当应用程序调用系统函数时，会从用户模式切换到内核模式去执行</p><h3 id="内核对象"><a class="markdownIt-Anchor" href="#内核对象"></a> 内核对象</h3><p>内核对象：系统提供用户模式下代码与内核模式下代码进行交互的基本接口。</p><p><img src="/images/javawz/1621364048617.png" alt="1621364048617"></p><p>对象句柄：</p><p>调用函数创建一个内核对象时会返回一个此对象的句柄</p><p>很多API函数都需要使用此句柄来辨别处理哪个内核对象，该句柄仅对创建该内核对象的进程有效</p><p>也可以多个进程共享一个内核对象，调用<code>DuplicateHandle</code>复制一个进程句柄传给其他进程</p><h3 id="使用计数"><a class="markdownIt-Anchor" href="#使用计数"></a> 使用计数</h3><p>系统为进程分配内核对象资源时,会将内核对象使用计数属性初始化为1</p><p>以后每次打开这个内核对象,系统就会将使用计数加1,关闭则减1</p><p>使用计数为0时,说明这个内核对象所有引用都已经关闭,系统会释放该内核对象资源</p><h3 id="进程的创建"><a class="markdownIt-Anchor" href="#进程的创建"></a> 进程的创建</h3><h4 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程:</h4><p>进程:</p><p>磁盘将可执行文件载入内存之后就变成了进程</p><p>进程是一个正在运行的程序</p><p>拥有自己的虚拟空间地址、代码、数据、其他系统资源</p><p>有一个或多个线程</p><p>一个进程要完成任何事情，必须拥有一个在它地址空间中运行的线程，此线程负责执行该进程地址空间的代码</p><p>线程:</p><p>进程内执行代码的独立实体</p><p>系统创建一个进程后，会创建一个线程来执行进程内的代码，这个线程称为主线程</p><p>主线程运行过程中可以创建其他线程，一般主线程创建的线程称为辅助线程或子线程</p><p>组成Win32进程的两个部分</p><p>1.进程内核对象：操作系统使用此内核对象进行管理该进程</p><p>2.私有的虚拟地址空间：包含了所有可执行的或是DLL模块的代码和数据、程序动态申请内存的地方</p><h3 id="应用程序的启动过程"><a class="markdownIt-Anchor" href="#应用程序的启动过程"></a> 应用程序的启动过程</h3><h5 id="控制台应用程序的启动过程"><a class="markdownIt-Anchor" href="#控制台应用程序的启动过程"></a> 控制台应用程序的启动过程</h5><p>1.操作系统会调用C/C<ins>运行期启动函数（会初始化C/C</ins>运行期库）</p><p>2.C/C++运行期启动函数调用入口main函数</p><h5 id="win32应用程序的启动过程"><a class="markdownIt-Anchor" href="#win32应用程序的启动过程"></a> Win32应用程序的启动过程</h5><p>1.操作系统会调用CreateProcess函数来创建一个新的进程</p><p>当一个线程调用CreateProcess函数的时候,系统会创建一个进程内核对象,初始化使用计数为1</p><p>该进程内核对象是一个系统用来管理这个进程的数据结构</p><p>2.为新的进程创建一个虚拟空间,加载应用程序运行时所需要的代码和数据</p><p>3.为新的进程创建一个主线程</p><p>4.主线程会执行C/C++运行期启动代码</p><p>5.C/C++运行期启动代码会调用main函数</p><p>如果系统成功创建一个进程和一个主线程,CreateProcess会返回TRUE,否者返回FALSE</p><p>创建进程称为父进程,被创建进程称为子进程</p><p>系统在创建新进程的时候会传递一个STARTUPINFO类型的变量,这个结构体包含了父进程传递给子进程的一些信息</p><h4 id="startupinfo结构体定义如下"><a class="markdownIt-Anchor" href="#startupinfo结构体定义如下"></a> STARTUPINFO结构体定义如下</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFO</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">DWORD cb;  <span class="comment">//包含STARTUPINFO结构中的字节数.如果Microsoft将来扩展该结构,它可用作版本控制手段.应用程序必须将cb初始化为sizeof(STARTUPINFO) </span></span><br><span class="line">    PSTR lpReserved; <span class="comment">//保留。必须初始化为NULL</span></span><br><span class="line">    PSTR lpDesktop; <span class="comment">//用于标识启动应用程序所在的桌面的名字。如果该桌面存在，新进程便与指定的桌面相关联。如果桌面不存在，便创建一个带有默认属性的桌面，并使用为新进程指定的名字。如果lpDesktop是NULL（这是最常见的情况 ),那么该进程将与当前桌面相关联 </span></span><br><span class="line">    PSTR lpTitle; <span class="comment">//用于设定控制台窗口的名称。如果lpTitle是NULL，则可执行文件的名字将用作窗口名.This parameter must be NULL for GUI or console processes that do not create a new console window.</span></span><br><span class="line">    DWORD dwX; <span class="comment">//用于设定应用程序窗口相对屏幕左上角位置的x 坐标（以像素为单位）。 </span></span><br><span class="line">    DWORD dwY; <span class="comment">//对于GUI processes用CW_USEDEFAULT作为CreateWindow的x、y参数，创建它的第一个重叠窗口。若是创建控制台窗口的应用程序，这些成员用于指明相对控制台窗口的左上角的位置</span></span><br><span class="line">    DWORD dwXSize; <span class="comment">//用于设定应用程序窗口的宽度（以像素为单位）</span></span><br><span class="line">    DWORD dwYSize; <span class="comment">//子进程将CW_USEDEFAULT 用作CreateWindow 的nWidth、nHeight参数来创建它的第一个重叠窗口。若是创建控制台窗口的应用程序，这些成员将用于指明控制台窗口的宽度 </span></span><br><span class="line">    DWORD dwXCountChars; <span class="comment">//用于设定子应用程序的控制台窗口的宽度（屏幕显示的字节列）和高度（字节行）（以字符为单位） </span></span><br><span class="line">    DWORD dwYCountChars; </span><br><span class="line">    DWORD dwFillAttribute;   <span class="comment">//用于设定子应用程序的控制台窗口使用的文本和背景颜色 </span></span><br><span class="line">    DWORD dwFlags;           <span class="comment">//请参见下一段和表4-7 的说明 </span></span><br><span class="line">    WORD wShowWindow;        <span class="comment">//用于设定如果子应用程序初次调用的ShowWindow 将SW_*作为nCmdShow 参数传递时，该应用程序的第一个重叠窗口应该如何出现。本成员可以是通常用于ShowWindow 函数的任何一个SW_*标识符，除了SW_SHOWDEFAULT. </span></span><br><span class="line">    WORD cbReserved2;        <span class="comment">//保留。必须被初始化为0 </span></span><br><span class="line">    PBYTE lpReserved2;       <span class="comment">//保留。必须被初始化为NULL</span></span><br><span class="line">    HANDLE hStdInput;        <span class="comment">//用于设定供控制台输入和输出用的缓存的句柄。按照默认设置，hStdInput 用于标识键盘缓存，hStdOutput 和hStdError用于标识控制台窗口的缓存 </span></span><br><span class="line">    HANDLE hStdOutput; </span><br><span class="line">    HANDLE hStdError; </span><br><span class="line">&#125; STARTUPINFO, *LPSTARTUPINFO;</span><br></pre></td></tr></table></figure><h4 id="dwflags-使用标志及含义"><a class="markdownIt-Anchor" href="#dwflags-使用标志及含义"></a> dwFlags 使用标志及含义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STARTF_USESIZE <span class="comment">// 使用dwXSize和dwYSize成员</span></span><br><span class="line">STARTF_USESHOWWINDOW <span class="comment">//使用wShowWindow成员</span></span><br><span class="line">STARTF_USEPOSITION <span class="comment">//使用dwX和dwY成员</span></span><br><span class="line">STARTF_USECOUNTCHARS <span class="comment">//使用dwXCountChars和dwYCountChars成员</span></span><br><span class="line">STARTF_USEFILLATTRIBUTE <span class="comment">//使用dwFillAttribute成员</span></span><br><span class="line">STARTF_USESTDHANDLES <span class="comment">//使用hStdInput、hStdOutput和hStdError成员</span></span><br><span class="line">STARTF_RUN_FULLSCREEN <span class="comment">//强制在x 8 6 计算机上运行的控制台应用程序以全屏幕方式启动运行</span></span><br></pre></td></tr></table></figure><h4 id="getstartupinfo函数"><a class="markdownIt-Anchor" href="#getstartupinfo函数"></a> GetStartupInfo函数</h4><p>获取父进程创建自己时使用的STARTUPINFO结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">GetStartupInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">LPSTARTUPINFO lpStartupInfo <span class="comment">// STARTUPINFO指针</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>定义一个STARTUPINFO结构体变量后要初始化cb成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFO si = &#123;<span class="keyword">sizeof</span>(STARTUPINFO)&#125;;</span><br><span class="line">GetStartupInfo(&amp;si);</span><br></pre></td></tr></table></figure><h4 id="createprocess函数"><a class="markdownIt-Anchor" href="#createprocess函数"></a> CreateProcess函数</h4><p>用来创建一个新的进程和它的主线程，这个新进程运行指定的可执行文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">BOOL <span class="title">CreateProcess</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">　LPCTSTR lpApplicationName, <span class="comment">// 应用程序名称  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPTSTR lpCommandLine, <span class="comment">// 命令行字符串  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="comment">// 进程的安全属性  NULL默认安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPSECURITY_ATTRIBUTES lpThreadAttributes, <span class="comment">// 线程的安全属性  NULL默认安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">　BOOL bInheritHandles, <span class="comment">// 是否继承父进程的属性  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　DWORD dwCreationFlags, <span class="comment">// 创建标志  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPVOID lpEnvironment, <span class="comment">// 指向新的环境块的指针  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPCTSTR lpCurrentDirectory, <span class="comment">// 指向当前目录名的指针  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPSTARTUPINFO lpStartupInfo, <span class="comment">// 传递给新进程的信息  </span></span></span></span><br><span class="line"><span class="function"><span class="params">　LPPROCESS_INFORMATION lpProcessInformation <span class="comment">// 新进程返回的信息  </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>lp开头代表是说明变量类型为指针变量</p><p>LPCSTR 是 const char *</p><p>WINDEF.h头文件包含了变量类型对应的宏名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>       DWORD;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span>                 BOOL;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>       BYTE;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>      WORD;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">float</span>               FLOAT;</span><br><span class="line"> <span class="keyword">typedef</span> FLOAT               *PFLOAT;</span><br><span class="line"> <span class="keyword">typedef</span> BOOL near           *PBOOL;</span><br><span class="line"> <span class="keyword">typedef</span> BOOL far            *LPBOOL;</span><br><span class="line"> <span class="keyword">typedef</span> BYTE near           *PBYTE;</span><br><span class="line"> <span class="keyword">typedef</span> BYTE far            *LPBYTE;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> near            *PINT;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> far             *LPINT;</span><br><span class="line"> <span class="keyword">typedef</span> WORD near           *PWORD;</span><br><span class="line"> <span class="keyword">typedef</span> WORD far            *LPWORD;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">long</span> far            *LPLONG;</span><br><span class="line"> <span class="keyword">typedef</span> DWORD near          *PDWORD;</span><br><span class="line"> <span class="keyword">typedef</span> DWORD far           *LPDWORD;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">void</span> far            *LPVOID;</span><br><span class="line"> <span class="keyword">typedef</span> CONST <span class="keyword">void</span> far      *LPCVOID;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span>                 INT;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>        UINT;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>        *PUINT;</span><br></pre></td></tr></table></figure><h4 id="创建一个新的进程打开记事本"><a class="markdownIt-Anchor" href="#创建一个新的进程打开记事本"></a> 创建一个新的进程打开记事本</h4><p><img src="/images/javawz/1621369626292.png" alt="1621369626292"></p><h4 id="process_information结构体"><a class="markdownIt-Anchor" href="#process_information结构体"></a> PROCESS_INFORMATION结构体</h4><p><img src="/images/javawz/1621369983635.png" alt="1621369983635"></p><p>创建了一个进程之后,如果不使用hProcess或hThread时就应该释放它</p><p>父进程必须要有一个CloseHandle函数来关闭CreateProcess函数返回的两个内核对象句柄，否者基本子进程已经终止了,该进程的内核对象和主线程的内核对象仍然没有释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 02CreateProcess.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> szCommandLine[] = <span class="string">"cmd"</span>;</span><br><span class="line">STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">si.dwFlags = STARTF_USESHOWWINDOW;<span class="comment">// 指定wShowWindow成员有效</span></span><br><span class="line">si.wShowWindow = TRUE;<span class="comment">// 此成员设为TRUE的话则显示新建进程的主窗口，</span></span><br><span class="line"><span class="comment">// 为FALSE的话则不显示</span></span><br><span class="line">BOOL bRet = ::CreateProcess (</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 不在此指定可执行文件的文件名</span></span><br><span class="line">szCommandLine,<span class="comment">// 命令行参数</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认进程安全性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认线程安全性</span></span><br><span class="line">FALSE,<span class="comment">// 指定当前进程内的句柄不可以被子进程继承</span></span><br><span class="line">CREATE_NEW_CONSOLE,<span class="comment">// 为新进程创建一个新的控制台窗口</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 使用本进程的环境变量</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 使用本进程的驱动器和目录</span></span><br><span class="line">&amp;si,</span><br><span class="line">&amp;pi);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 既然我们不使用两个句柄，最好是立刻将它们关闭</span></span><br><span class="line">::CloseHandle (pi.hThread);</span><br><span class="line">::CloseHandle (pi.hProcess);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 新进程的进程ID号：%d \n"</span>, pi.dwProcessId);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 新进程的主线程ID号：%d \n"</span>, pi.dwThreadId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>windows是通过dwFlags来查看STARTUPINFO变量中的哪一个成员有效，再去取那个成员的值</p><p>使用wShowWindow成员用STARTF_USESHOWWINDOW</p><p>使用dwXSize和dwXSize用STARTF_USESIZE</p><p>使用dwX，dwY成员用STARTF_USEPOSITION</p><p><code>dwFlags = STARTF_USESHOWWINDOW | STARTF_USESIZE | STARTF_USEPOSITION</code></p><p>则wShowWindow,dwXSize,dwXSize,dwX，dwY成员都有效</p><p>CREATE_NEW_CONSOLE 表示创建一个新的控制台</p><h4 id="closehandle函数"><a class="markdownIt-Anchor" href="#closehandle函数"></a> CloseHandle函数</h4><p>关闭一个内核对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL CloseHandle(</span><br><span class="line"></span><br><span class="line">HANDLE hObject//代表一个已打开对象handle。</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>TRUE：执行成功；</p><p>FALSE：执行失败，可以调用GetLastError()获知失败原因。</p><h3 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h3><h4 id="获取系统进程"><a class="markdownIt-Anchor" href="#获取系统进程"></a> 获取系统进程</h4><hr><h4 id="processentry32-结构"><a class="markdownIt-Anchor" href="#processentry32-结构"></a> PROCESSENTRY32 结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span>  &#123;</span>    </span><br><span class="line">  DWORD   dwSize;   <span class="comment">//   结构大小；    </span></span><br><span class="line">  DWORD   cntUsage;   <span class="comment">//   此进程的引用计数；    </span></span><br><span class="line">  DWORD   th32ProcessID;   <span class="comment">//   进程ID;    </span></span><br><span class="line">  DWORD   th32DefaultHeapID;   <span class="comment">//   进程默认堆ID；    </span></span><br><span class="line">  DWORD   th32ModuleID;   <span class="comment">//   进程模块ID；    </span></span><br><span class="line">  DWORD   cntThreads;   <span class="comment">//   此进程开启的线程计数；    </span></span><br><span class="line">  DWORD   th32ParentProcessID;<span class="comment">//   父进程ID；    </span></span><br><span class="line">  LONG   pcPriClassBase;   <span class="comment">//   线程优先权；    </span></span><br><span class="line">  DWORD   dwFlags;   <span class="comment">//   保留；    </span></span><br><span class="line">  <span class="keyword">char</span>   szExeFile[MAX_PATH];   <span class="comment">//   进程全名；    </span></span><br><span class="line">  &#125;   PROCESSENTRY32;</span><br></pre></td></tr></table></figure><hr><h4 id="createtoolhelp32snapshot"><a class="markdownIt-Anchor" href="#createtoolhelp32snapshot"></a> CreateToolhelp32Snapshot</h4><p>可以通过获取进程信息为指定的进程、进程使用的堆[HEAP]、模块[MODULE]、线程建立一个快照。</p><p>头文件：<code>tlhelp32.h</code></p><p>返回值： 调用成功，返回快照的句柄，调用失败，返回INVALID_HANDLE_VALUE**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**<span class="function">HANDLE WINAPI <span class="title">CreateToolhelp32Snapshot</span><span class="params">(**</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">*DWORD dwFlags,* <span class="comment">//用来指定“快照”中需要返回的对象，可以是TH32CS_SNAPPROCESS等</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">*DWORD th32ProcessID* <span class="comment">//一个进程ID号，用来指定要获取哪一个进程的快照，当获取系统进程列表   //获取 当前进程快照时可以设为0</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>指定快照中包含的系统内容，dwFlags这个参数能够使用下列数值（常量）中的一个或多个。<br><code>TH32CS_INHERIT</code>       声明快照句柄是可继承的。<br><code>TH32CS_SNAPALL</code>        在快照中包含系统中所有的进程和线程。<br><code>TH32CS_SNAPHEAPLIST</code>    在快照中包含在th32ProcessID中指定的进程的所有的堆。<br><code>TH32CS_SNAPMODULE</code>    在快照中包含在th32ProcessID中指定的进程的所有的模块。<br><code>TH32CS_SNAPPROCESS</code>    在快照中包含系统中所有的进程。<br><code>TH32CS_SNAPTHREAD</code>     在快照中包含系统中所有的线程。<br>H32CS_SNAPALL = (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE)</p><hr><h4 id="process32first"><a class="markdownIt-Anchor" href="#process32first"></a> process32First</h4><p>是一个进程获取函数，当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后，我们可以利用process32First函数来获得第一个进程的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">Process32First</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   HANDLE hSnapshot, <span class="comment">//快照句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">   LPPROCESSENTRY32 lppe <span class="comment">//PROCESSENTRY32指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><hr><h4 id="process32next"><a class="markdownIt-Anchor" href="#process32next"></a> Process32Next</h4><p>是一个进程获取函数，当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后,我们可以利用Process32Next函数来获得下一个进程的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">Process32Next</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   HANDLE hSnapshot, <span class="comment">//快照句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">   LPPROCESSENTRY32 lppe <span class="comment">//PROCESSENTRY32指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><br><hr><h4 id="获取系统进程的例子"><a class="markdownIt-Anchor" href="#获取系统进程的例子"></a> 获取系统进程的例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 02ProcessList.cpp文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt; // 声明快照函数的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PROCESSENTRY32 pe32;</span><br><span class="line"><span class="comment">// 在使用这个结构之前，先设置它的大小</span></span><br><span class="line">pe32.dwSize = <span class="keyword">sizeof</span>(pe32); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 给系统内的所有进程拍一个快照</span></span><br><span class="line">HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" CreateToolhelp32Snapshot调用失败！ \n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历进程快照，轮流显示每个进程的信息</span></span><br><span class="line">BOOL bMore = ::Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line"><span class="keyword">while</span>(bMore)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 进程名称：%s \n"</span>, pe32.szExeFile);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 进程ID号：%u \n\n"</span>, pe32.th32ProcessID);</span><br><span class="line"></span><br><span class="line">bMore = ::Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要忘记清除掉snapshot对象</span></span><br><span class="line">::CloseHandle(hProcessSnap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><hr><h4 id="终止当前进程"><a class="markdownIt-Anchor" href="#终止当前进程"></a> 终止当前进程</h4><p>终止进程也就是结束程序的执行，让它从内存中卸载。进程终止的原因可能有4种:</p><p>(1)主线程的入口函数返回。</p><p>(2)进程中一个线程调用了ExitProcess 函数。</p><p>(3)此进程中的所有线程都结束了。</p><p>(4)其他进程中的一一个线程调 用了TerminateProcess 函数。</p><h4 id="exitprocess结束当前进程函数"><a class="markdownIt-Anchor" href="#exitprocess结束当前进程函数"></a> Exitprocess结束当前进程函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Exitprocess(UINT uExitCode);//uExitCode为退出代码</span><br></pre></td></tr></table></figure><hr><h4 id="terminateprocess终止其他进程函数"><a class="markdownIt-Anchor" href="#terminateprocess终止其他进程函数"></a> TerminateProcess终止其他进程函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL TerminateProcess(</span><br><span class="line">HANDLE hprocess,//要结束的进程句柄</span><br><span class="line">UINT uExitCode//指定目标进程的退出代码</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="openprocess-函数用来打开一个已存在的进程对象并返回进程的句柄"><a class="markdownIt-Anchor" href="#openprocess-函数用来打开一个已存在的进程对象并返回进程的句柄"></a> OpenProcess 函数用来打开一个已存在的进程对象，并返回进程的句柄。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenProcess(</span><br><span class="line">DWORD dwDesiredAccess, //渴望得到的访问权限（标志）</span><br><span class="line">BOOL bInheritHandle, // 是否继承句柄</span><br><span class="line">DWORD dwProcessId// 进程id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>**dwDesiredAccess ：**获取的权限，可分为以下几种</p><p>PROCESS_ALL_ACCESS：获取所有权限</p><p>PROCESS_CREATE_PROCESS：创建进程</p><p>PROCESS_CREATE_THREAD：创建线程</p><p>PROCESS_DUP_HANDLE：使用DuplicateHandle()函数复制一个新句柄</p><p>PROCESS_QUERY_INFORMATION：获取进程的令牌、退出码和优先级等信息</p><p>PROCESS_QUERY_LIMITED_INFORMATION：获取进程特定的某个信息</p><p>PROCESS_SET_INFORMATION：设置进程的某种信息</p><p>PROCESS_SET_QUOTA：使用SetProcessWorkingSetSize函数设置内存限制</p><p>PROCESS_SUSPEND_RESUME：暂停或者恢复一个进程</p><p>PROCESS_TERMINATE：使用Terminate函数终止进程</p><p>PROCESS_VM_OPERATION：在进程的地址空间执行操作</p><p>PROCESS_VM_READ：使用ReadProcessMemory函数在进程中读取内存</p><p>PROCESS_VM_WRITE：使用WriteProcessMemory函数在进程中写入内存</p><p>SYNCHRONIZE：使用wait函数等待进程终止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 02TerminateProcess.cpp文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">TerminateProcessFromId</span><span class="params">(DWORD dwId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line"><span class="comment">// 打开目标进程，取得进程句柄</span></span><br><span class="line">HANDLE hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwId);</span><br><span class="line"><span class="keyword">if</span>(hProcess != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 终止进程</span></span><br><span class="line">bRet = ::TerminateProcess(hProcess, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwId;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 请输入您要终止的进程的ID号： \n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%u"</span>, &amp;dwId);</span><br><span class="line"><span class="keyword">if</span>(TerminateProcessFromId(dwId))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 终止进程成功！ \n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 终止进程失败！ \n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getlasterror获取调用线程的最后出错代码"><a class="markdownIt-Anchor" href="#getlasterror获取调用线程的最后出错代码"></a> GetLastError获取调用线程的最后出错代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD GetLastError(VOID);</span><br></pre></td></tr></table></figure><h4 id="getexitcodeprocess-获取一个已中断进程的退出代码"><a class="markdownIt-Anchor" href="#getexitcodeprocess-获取一个已中断进程的退出代码"></a> GetExitCodeProcess 获取一个已中断进程的退出代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL GetExitCodeProcess(</span><br><span class="line">HANDLE hProcess,//想获取退出代码的一个进程的句柄</span><br><span class="line">LPDWORD lpExitCode//用于装载进程退出代码的一个长整数变量。如进程尚未中止，则设为常数STILL_ACTIVE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一旦进程终止， 就会有下列事件发生:</p><p>(1)所有被这个进程创建或打开的对象句柄就会关闭。</p><p>(2)此进程内的所有线程将终止执行。</p><p>(3)进程内核对象变成受信状态，所有等待在此对象上的线程开始运行，即WaitForSingleObject函数返回。</p><p>(4)系统将进程对象中退出代码的值由STILL_ ACTIVE改为指定的退出码。</p><hr><h4 id="readprocessmemory是一个内存操作函数-其作用为根据进程句柄读入该进程的某个内存空间"><a class="markdownIt-Anchor" href="#readprocessmemory是一个内存操作函数-其作用为根据进程句柄读入该进程的某个内存空间"></a> ReadProcessMemory是一个内存操作函数， 其作用为根据进程句柄读入该进程的某个内存空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL ReadProcessMemory(</span><br><span class="line">HANDLE hProcess,//待读进程的句柄</span><br><span class="line">PVOID pvAddressRemote,//目标进程中待读内容的起始位置</span><br><span class="line">PVOID pvBufferLocal, //用来接受读取数据的缓冲区</span><br><span class="line">DWORD dwSize, //要读取的字节数</span><br><span class="line">PDWORD pdwNumBytesRead//用来供函数返回实际读取的字节数</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="writeprocessmemory是计算机语言中的一种函数-此函数能写入某一进程的内存区域直接写入会出access-violation错误故需此函数入口区必须可以访问否则操作将失败"><a class="markdownIt-Anchor" href="#writeprocessmemory是计算机语言中的一种函数-此函数能写入某一进程的内存区域直接写入会出access-violation错误故需此函数入口区必须可以访问否则操作将失败"></a> WriteProcessMemory是计算机语言中的一种函数。此函数能写入某一进程的内存区域（直接写入会出Access Violation错误），故需此函数入口区必须可以访问，否则操作将失败。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL WriteProcessMemory(</span><br><span class="line">HANDLE hProcess,//由OpenProcess返回的进程句柄。</span><br><span class="line">LPVOID lpBaseAddress,//要写的内存首地址</span><br><span class="line">LPVOID lpBuffer,//指向要写的数据的指针。</span><br><span class="line">DWORD nSize,//要写入的字节数。</span><br><span class="line">LPDWORD lpNumberOfBytesWritten//用来供函数返回实际写入的字节数</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>应该在目标进程的整个用户地址空间进行搜索。在进程的整个4GB地址中，Windows 98系列的操作系统为应用程序预留的是4MB到2GB部分，Windows2000系列的操作系统预留的是64KB到2GB部分，所以在搜索前还要先判断操作系统的类型，以决定搜索的范围。</p><h4 id="osversioninfo-操作系统的信息版本结构"><a class="markdownIt-Anchor" href="#osversioninfo-操作系统的信息版本结构"></a> OSVERSIONINFO 操作系统的信息版本结构</h4><p><img src="/images/javawz/1621378080153.png" alt="1621378080153"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _OSVERSIONINFO &#123;</span><br><span class="line"></span><br><span class="line">DWORD dwOSVersionInfoSize; // 本结构的大小，必须在调用之前设置</span><br><span class="line"></span><br><span class="line">DWORD dwMajorVersion;//操作系统的主版本号</span><br><span class="line"></span><br><span class="line">DWORD dwMinorVersion;//操作系统的次版本号</span><br><span class="line"></span><br><span class="line">DWORD dwBuildNumber;//操作系统的编译版本号</span><br><span class="line"></span><br><span class="line">DWORD dwPlatformld;//操作系统平台。可以是VER_PLATFORM_WIN32_NT (2000系列)等</span><br><span class="line"></span><br><span class="line">TCHAR szCSDVersion[128];//指定安装在系统上的最新服务包，例如“Service Pack3&quot;等</span><br><span class="line"></span><br><span class="line">&#125; OSVERSIONINFO;</span><br></pre></td></tr></table></figure><h4 id="getversionex返回当前操作系统的版本号在64位系统上是32位字节长度"><a class="markdownIt-Anchor" href="#getversionex返回当前操作系统的版本号在64位系统上是32位字节长度"></a> GetVersionEX返回当前操作系统的版本号（在64位系统上是32位字节长度）。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL GetVersionEx(</span><br><span class="line">LPOSVERSIONINFO lpVersionInformation // 指向版本信息结构体的指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h4 id="游戏修改器例子"><a class="markdownIt-Anchor" href="#游戏修改器例子"></a> 游戏修改器例子</h4><p>Windows采用了分页机制来管理内存，每页的大小是4KB (在x86处理器上)。也就是说Windows是以4KB为单位来为应用程序分配内存的。所以可以按页来搜索目标内存，以提高搜索效率。下面的CompareAPage函数的功能就是比较目标进程内存中1页大小的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 02MemRepair.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">FindFirst</span><span class="params">(DWORD dwValue)</span></span>;<span class="comment">// 在目标进程空间进行第一次查找</span></span><br><span class="line"><span class="function">BOOL <span class="title">FindNext</span><span class="params">(DWORD dwValue)</span></span>;<span class="comment">// 在目标进程地址空间进行第2、3、4……次查找</span></span><br><span class="line"></span><br><span class="line">DWORD g_arList[<span class="number">1024</span>];<span class="comment">// 地址列表</span></span><br><span class="line"><span class="keyword">int</span> g_nListCnt;<span class="comment">// 有效地址的个数</span></span><br><span class="line">HANDLE g_hProcess;<span class="comment">// 目标进程句柄</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">WriteMemory</span><span class="params">(DWORD dwAddr, DWORD dwValue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 启动02testor进程</span></span><br><span class="line"><span class="keyword">char</span> szFileName[] = <span class="string">"ConsoleApplication1.exe"</span>;</span><br><span class="line">STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line">::CreateProcess(<span class="literal">NULL</span>, szFileName, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, </span><br><span class="line">CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"><span class="comment">// 关闭线程句柄，既然我们不使用它</span></span><br><span class="line">::CloseHandle(pi.hThread);</span><br><span class="line">g_hProcess = pi.hProcess;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入要修改的值</span></span><br><span class="line"><span class="keyword">int</span>iVal;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Input val = "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行第一次查找</span></span><br><span class="line">FindFirst(iVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出搜索的结果</span></span><br><span class="line">ShowList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(g_nListCnt &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Input val = "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行下次搜索</span></span><br><span class="line">FindNext(iVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示搜索结果</span></span><br><span class="line">ShowList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得新值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" New value = "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iVal);     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入新值</span></span><br><span class="line"><span class="keyword">if</span>(WriteMemory(g_arList[<span class="number">0</span>], iVal))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Write data success \n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">::CloseHandle(g_hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CompareAPage</span><span class="params">(DWORD dwBaseAddr, DWORD dwValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 读取1页内存</span></span><br><span class="line">BYTE arBytes[<span class="number">4096</span>];</span><br><span class="line"><span class="keyword">if</span>(!::ReadProcessMemory(g_hProcess, (LPVOID)dwBaseAddr, arBytes, <span class="number">4096</span>, <span class="literal">NULL</span>))</span><br><span class="line"><span class="keyword">return</span> FALSE;<span class="comment">// 此页不可读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这1页内存中查找</span></span><br><span class="line">DWORD* pdw;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(<span class="keyword">int</span>)<span class="number">4</span>*<span class="number">1024</span><span class="number">-3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pdw = (DWORD*)&amp;arBytes[i];</span><br><span class="line"><span class="keyword">if</span>(pdw[<span class="number">0</span>] == dwValue)<span class="comment">// 等于要查找的值？</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(g_nListCnt &gt;= <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">// 添加到全局变量中</span></span><br><span class="line">g_arList[g_nListCnt++] = dwBaseAddr + i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">FindFirst</span><span class="params">(DWORD dwValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> DWORD dwOneGB = <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">// 1GB</span></span><br><span class="line"><span class="keyword">const</span> DWORD dwOnePage = <span class="number">4</span>*<span class="number">1024</span>;<span class="comment">// 4KB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g_hProcess == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看操作系统类型，以决定开始地址</span></span><br><span class="line">DWORD dwBase;</span><br><span class="line">OSVERSIONINFO vi = &#123; <span class="keyword">sizeof</span>(vi) &#125;;</span><br><span class="line">::GetVersionEx(&amp;vi);</span><br><span class="line"><span class="keyword">if</span> (vi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)</span><br><span class="line">dwBase = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">// Windows 98系列，4MB</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dwBase = <span class="number">64</span>*<span class="number">1024</span>;<span class="comment">// Windows NT系列，64KB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在开始地址到2GB的地址空间进行查找</span></span><br><span class="line"><span class="keyword">for</span>(; dwBase &lt;<span class="number">2</span>*dwOneGB; dwBase += dwOnePage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 比较1页大小的内存</span></span><br><span class="line">CompareAPage(dwBase, dwValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">FindNext</span><span class="params">(DWORD dwValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 保存m_arList数组中有效地址的个数，初始化新的m_nListCnt值</span></span><br><span class="line"><span class="keyword">int</span> nOrgCnt = g_nListCnt;</span><br><span class="line">g_nListCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在m_arList数组记录的地址处查找</span></span><br><span class="line">BOOL bRet = FALSE;<span class="comment">// 假设失败</span></span><br><span class="line">DWORD dwReadValue;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nOrgCnt; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(::ReadProcessMemory(g_hProcess, (LPVOID)g_arList[i], &amp;dwReadValue, <span class="keyword">sizeof</span>(DWORD), <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dwReadValue == dwValue)</span><br><span class="line">&#123;</span><br><span class="line">g_arList[g_nListCnt++] = g_arList[i];</span><br><span class="line">bRet = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出搜索到的地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; g_nListCnt; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%08lX \n"</span>, g_arList[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">WriteMemory</span><span class="params">(DWORD dwAddr, DWORD dwValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ::WriteProcessMemory(g_hProcess, (LPVOID)dwAddr, &amp;dwValue, <span class="keyword">sizeof</span>(DWORD), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 02Testor.cpp文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量测试</span></span><br><span class="line"><span class="keyword">int</span> g_nNum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">198</span>;<span class="comment">// 局部变量测试</span></span><br><span class="line">g_nNum = <span class="number">1003</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 输出个变量的值和地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" i = %d, addr = %08lX;   g_nNum = %d, addr = %08lX \n"</span>,</span><br><span class="line">++i, &amp;i, --g_nNum, &amp;g_nNum);</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;win32程序运行原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#win32程序运行原理&quot;&gt;&lt;/a&gt; Win32程序运行原理&lt;/h1&gt;
&lt;h3 id=&quot;cpu的保护模式和windows系统&quot;&gt;&lt;a class=&quot;markdownIt
      
    
    </summary>
    
      <category term="windows程序设计" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>windows程序设计基础</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/19/win0001-windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/19/win0001-windows程序设计基础/</id>
    <published>2021-05-18T17:32:42.000Z</published>
    <updated>2021-05-18T18:05:13.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="windows程序设计基础"><a class="markdownIt-Anchor" href="#windows程序设计基础"></a> windows程序设计基础</h1><h3 id="win32-api-简介"><a class="markdownIt-Anchor" href="#win32-api-简介"></a> Win32 API 简介</h3><p>API(Application Programming Interface)  应用程序编程接口</p><p>提供了各种各样与windows系统服务有关的函数</p><p>SDK编程就是直接调用API函数进行编程</p><p>Win32 API 是指编制32应用程序时使用的一组函数、结构、宏定义。</p><h3 id="应用程序类型"><a class="markdownIt-Anchor" href="#应用程序类型"></a> 应用程序类型</h3><p>windows支持两种类型的应用程序:</p><p>Graphical User Interface（GUI ）图形用户界面</p><p>Console User Interface（CUI ）控制台用户界面</p><h3 id="api函数的调用方法"><a class="markdownIt-Anchor" href="#api函数的调用方法"></a> API函数的调用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">///////////////////////////////////////////////////////////////</span><br><span class="line">// 01FirstApp.cpp文件</span><br><span class="line">#include &lt;windows.h&gt;// 包含MessageBox函数声明的头文件</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">// 调用API函数MessageBox</span><br><span class="line">int nSelect = ::MessageBox(NULL, &quot;Hello, Windows XP&quot;, &quot;Greetings&quot;, MB_OKCANCEL);</span><br><span class="line">if(nSelect == IDOK)</span><br><span class="line">printf(&quot; 用户选择了“确定”按钮 \n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot; 用户选择了“取消”按钮 \n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用windows API  需要包含<code>windows.h</code>头文件</p><p>::MessageBox 在函数前面加上<code>::</code>表示是一个全局函数与c++成员函数区分开</p><h3 id="代码风格"><a class="markdownIt-Anchor" href="#代码风格"></a> 代码风格</h3><h4 id="变量的命名"><a class="markdownIt-Anchor" href="#变量的命名"></a> 变量的命名</h4><p>【限定范围的前缀】 + 【数据类型前缀】+【有意义的单词】</p><p><code>g_szTitle</code></p><p>常量：用全大写字母</p><p>全局变量：<code>g_</code>开头</p><p>sz开头：表示以<code>‘\0’</code>结尾的字符串</p><p>类的成员变量：以<code>m_</code>开头</p><p>局部变量：【数据类型前缀】+【有意义的单词】bResult   b代表BOOL类型</p><p>函数名：每个单词首字母大写 <code>CreateFile</code></p><p>类名：<code>CStudent</code>  C代表class</p><p>结构体：<code>SStudent</code>  S代表struct</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;windows程序设计基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#windows程序设计基础&quot;&gt;&lt;/a&gt; windows程序设计基础&lt;/h1&gt;
&lt;h3 id=&quot;win32-api-简介&quot;&gt;&lt;a class=&quot;markdownIt
      
    
    </summary>
    
      <category term="windows程序设计" scheme="https://xiaowuyoucy.github.io/categories/windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>面向抽象类编程实现计算程序员工资</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/14/cpp0060-%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E8%B5%84/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/14/cpp0060-面向抽象类编程实现计算程序员工资/</id>
    <published>2021-05-14T10:47:25.000Z</published>
    <updated>2021-05-14T10:51:53.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向抽象类编程实现计算程序员工资"><a class="markdownIt-Anchor" href="#面向抽象类编程实现计算程序员工资"></a> 面向抽象类编程实现计算程序员工资</h1><p><img src="/images/javawz/1620989260941.png" alt="1620989260941"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*抽象层*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序员抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//打印程序员工资纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintPaid</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">Programmer() &#123;&#125;;</span><br><span class="line">Programmer(<span class="keyword">double</span> tPaid) :paid(tPaid) &#123;&#125;;</span><br><span class="line"><span class="keyword">virtual</span> ~Programmer() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Programmer()..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="comment">//获取程序员工资</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPaid</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> paid; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> paid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*实现层*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初级程序员类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Junior_programmer</span> :</span> <span class="keyword">public</span> Programmer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Junior_programmer()&#123;&#125;</span><br><span class="line">Junior_programmer(<span class="keyword">double</span> paid):Programmer(paid)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintPaid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Junior_programmer :"</span> &lt;&lt; getPaid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Junior_programmer()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Junior_programmer()..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中级程序员类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid_programmer</span> :</span> <span class="keyword">public</span> Programmer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Mid_programmer()&#123;&#125;</span><br><span class="line">Mid_programmer(<span class="keyword">double</span> paid) :Programmer(paid) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintPaid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Mid_programmer :"</span> &lt;&lt; getPaid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Mid_programmer()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Mid_programmer()..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//高级程序员类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adv_programmer</span> :</span> <span class="keyword">public</span> Programmer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Adv_programmer(<span class="keyword">double</span> paid) :Programmer(paid) &#123;&#125;</span><br><span class="line">Adv_programmer()&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintPaid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Adv_programmer :"</span> &lt;&lt; getPaid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Adv_programmer()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Adv_programmer()..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//架构师类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Architect</span> :</span> <span class="keyword">public</span> Programmer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Architect(<span class="keyword">double</span> paid) :Programmer(paid) &#123;&#125;</span><br><span class="line">Architect()&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintPaid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Architect :"</span> &lt;&lt; getPaid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Architect()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Architect"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">后序拓展只需要</span></span><br><span class="line"><span class="comment">1.创建一个类并继承Programmer</span></span><br><span class="line"><span class="comment">2.重写virtual void PrintPaid()函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class XXX : public Programmer &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">virtual void PrintPaid() &#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "XXX :" &lt;&lt; getPaid() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowProgrammerPaid</span><span class="params">(Programmer * p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p-&gt;PrintPaid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"===================="</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*业务逻辑层*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ShowProgrammerPaid(<span class="keyword">new</span> Junior_programmer(<span class="number">10000</span>));</span><br><span class="line">ShowProgrammerPaid(<span class="keyword">new</span> Mid_programmer(<span class="number">15000</span>));</span><br><span class="line">ShowProgrammerPaid(<span class="keyword">new</span> Adv_programmer(<span class="number">20000</span>));</span><br><span class="line">ShowProgrammerPaid(<span class="keyword">new</span> Architect(<span class="number">30000</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向抽象类编程实现计算程序员工资&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#面向抽象类编程实现计算程序员工资&quot;&gt;&lt;/a&gt; 面向抽象类编程实现计算程序员工资&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/16209
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言函数指针的锦囊妙计</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/14/cpp0059-C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E9%94%A6%E5%9B%8A%E5%A6%99%E8%AE%A1/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/14/cpp0059-C语言函数指针的锦囊妙计/</id>
    <published>2021-05-13T18:17:04.000Z</published>
    <updated>2021-05-13T18:18:24.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c语言函数指针的锦囊妙计"><a class="markdownIt-Anchor" href="#c语言函数指针的锦囊妙计"></a> C语言函数指针的锦囊妙计</h1><p><img src="/images/javawz/1620929868031.png" alt="1620929868031"></p><p><img src="/images/javawz/1620929880137.png" alt="1620929880137"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个锦囊的方法 是一个函数指针，类似于c++的纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(TIPS_FUNC)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个锦囊的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tips</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> from[<span class="number">64</span>]; <span class="comment">//这个锦囊是谁写的</span></span><br><span class="line"><span class="keyword">char</span> to[<span class="number">64</span>]; <span class="comment">//写给谁的</span></span><br><span class="line">TIPS_FUNC *fp; <span class="comment">//具体锦囊的内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个供赵云调用的架构函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_tips</span><span class="params">(struct tips * tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊是由"</span> &lt;&lt; tp-&gt;from &lt;&lt; <span class="string">", 写给"</span> &lt;&lt; tp-&gt;to &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">tp-&gt;fp();<span class="comment">//拆开锦囊，调用具体锦囊的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一个一个的锦囊  //类似于实现一个纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tips_1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"一到东吴就大张旗鼓找乔国老"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tips_2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"骗刘备 操作压境"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tips_3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找孙尚香求救"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tips_4</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"你们就死在东吴把"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tips* <span class="title">create_tips</span><span class="params">(<span class="keyword">char</span> *from, <span class="keyword">char</span> *to, TIPS_FUNC *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tips</span> *<span class="title">tp</span> = (<span class="title">struct</span> <span class="title">tips</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">tips</span>));</span></span><br><span class="line"><span class="keyword">if</span> (tp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(tp-&gt;from, from);</span><br><span class="line"><span class="built_in">strcpy</span>(tp-&gt;to, to);</span><br><span class="line"><span class="comment">//注册回调函数</span></span><br><span class="line">tp-&gt;fp = fp; <span class="comment">//给拥有函数指针的结构体  函数指针变量 赋值 就是 注册回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory_tips</span><span class="params">(struct tips * tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tp != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">free</span>(tp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//诸葛亮去写锦囊</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tips</span> * <span class="title">tp1</span> = <span class="title">create_tips</span>("孔明", "赵云", <span class="title">tips_1</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tips</span> * <span class="title">tp2</span> = <span class="title">create_tips</span>("孔明", "赵云", <span class="title">tips_2</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tips</span> * <span class="title">tp3</span> = <span class="title">create_tips</span>("孔明", "赵云", <span class="title">tips_3</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tips</span> *<span class="title">tp4</span>= <span class="title">create_tips</span>("庞统", "赵云", <span class="title">tips_4</span>);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赵云去拆机囊</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"刚来到 东吴境内 ，打开了第一个锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">open_tips(tp1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"刘备乐不思蜀 ，打开第二个锦囊 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">open_tips(tp2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"孙权追杀刘备, 打开第三个锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">open_tips(tp3);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"赵云发现  抵挡不住 军队，想到了庞统的最后一个锦囊 打开了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">open_tips(tp4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">destory_tips(tp1);</span><br><span class="line">destory_tips(tp2);</span><br><span class="line">destory_tips(tp3);</span><br><span class="line">destory_tips(tp4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c语言函数指针的锦囊妙计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c语言函数指针的锦囊妙计&quot;&gt;&lt;/a&gt; C语言函数指针的锦囊妙计&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620929868031.png
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>函数指针的语法和意义</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/14/cpp0058-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E8%AF%AD%E6%B3%95%E5%92%8C%E6%84%8F%E4%B9%89/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/14/cpp0058-函数指针的语法和意义/</id>
    <published>2021-05-13T17:50:06.000Z</published>
    <updated>2021-05-13T17:52:36.849Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javawz/1620928259433.png" alt="1620928259433"></p><p><img src="/images/javawz/1620928267520.png" alt="1620928267520"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"func 111 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数指针</span></span><br><span class="line"><span class="comment">// C语言中 决定一个函数类型</span></span><br><span class="line"><span class="comment">// 返回值 参数列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(FUNC)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">//定义一个函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*FUNC_POINTER)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">//定义一个函数指针类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何将一个函数指针当成一个函数参数呢？</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_function</span><span class="params">(FUNC *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fp(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_function2</span><span class="params">(FUNC_POINTER fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fp(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//他是一个架构函数。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_function3</span><span class="params">(<span class="keyword">int</span>(*fp)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1999 年写的架构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"固定业务1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">fp(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"固定业务2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2015 实现一个子函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_new_function</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"2015年实现的新业务"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FUNC * p = func;</span><br><span class="line">FUNC_POINTER p2 = func;</span><br><span class="line"><span class="keyword">int</span>(*fp)(<span class="keyword">int</span>, <span class="keyword">int</span>) = func;</span><br><span class="line"></span><br><span class="line">p(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">(*p)(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">//以上两种写法等价</span></span><br><span class="line"></span><br><span class="line">p2(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">(*p2)(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">fp(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" --------  "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2015   实现一个子函数，再调用1999的架构</span></span><br><span class="line">my_function3(my_new_function);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javawz/1620928259433.png&quot; alt=&quot;1620928259433&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620928267520.png&quot; alt=&quot;1620928267520&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>利用抽象类实现电脑组装案例</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0057-%E5%88%A9%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85%E6%A1%88%E4%BE%8B/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0057-利用抽象类实现电脑组装案例/</id>
    <published>2021-05-13T15:44:59.000Z</published>
    <updated>2021-05-13T15:54:19.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用抽象类实现电脑组装案例"><a class="markdownIt-Anchor" href="#利用抽象类实现电脑组装案例"></a> 利用抽象类实现电脑组装案例</h1><p><img src="/images/javawz/1620921234240.png" alt="1620921234240"></p><h3 id="面向抽象类编程"><a class="markdownIt-Anchor" href="#面向抽象类编程"></a> 面向抽象类编程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========start抽象层============*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CPU抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span>  &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">caculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显卡抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内存条抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Computer(CPU *tcpu1, Card * tcard, Memory * tmemory) :cpu1(tcpu1), card(tcard), memory(tmemory) &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cpu1-&gt;caculate();</span><br><span class="line">card-&gt;display();</span><br><span class="line">memory-&gt;storage();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CPU *cpu1;</span><br><span class="line">Card * card;</span><br><span class="line">Memory * memory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========end抽象层============*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========start实现层============*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Intel</span></span><br><span class="line"><span class="comment">//IntelCPU</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelCpu</span> :</span><span class="keyword">public</span> CPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">caculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"IntelCPU"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Intel显卡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelCard</span> :</span> <span class="keyword">public</span> Card &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"IntelCard"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Intel内存条</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelMemory</span> :</span><span class="keyword">public</span> Memory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">storage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"IntelMemory"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//NIVDE显卡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NVIDIACard</span> :</span> <span class="keyword">public</span> Card &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NVIDIACard"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Kingston内存条</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KingstonMemory</span> :</span><span class="keyword">public</span> Memory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">storage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"KingstonMemory"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========end实现层============*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========业务逻辑层============*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//组装一台纯Intel的电脑</span></span><br><span class="line"><span class="function">Computer <span class="title">p1</span><span class="params">(<span class="keyword">new</span> IntelCpu,<span class="keyword">new</span> IntelCard,<span class="keyword">new</span> IntelMemory)</span></span>;</span><br><span class="line">p1.print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//组装一台IntelCpu,NVIDIACard,KingstonMemory的电脑</span></span><br><span class="line"><span class="function">Computer <span class="title">p2</span><span class="params">(<span class="keyword">new</span> IntelCpu, <span class="keyword">new</span> NVIDIACard, <span class="keyword">new</span> KingstonMemory)</span></span>;</span><br><span class="line">p2.print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用抽象类实现电脑组装案例&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#利用抽象类实现电脑组装案例&quot;&gt;&lt;/a&gt; 利用抽象类实现电脑组装案例&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620921234240.
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>纯虚函数和抽象类</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0056-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0056-纯虚函数和抽象类/</id>
    <published>2021-05-12T23:33:38.000Z</published>
    <updated>2021-05-12T23:50:18.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="纯虚函数和抽象类"><a class="markdownIt-Anchor" href="#纯虚函数和抽象类"></a> 纯虚函数和抽象类</h1><p><img src="/images/javawz/1620863272021.png" alt="1620863272021"></p><p><img src="/images/javawz/1620863367789.png" alt="1620863367789"></p><p><img src="/images/javawz/1620863228601.png" alt="1620863228601"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图形类</span></span><br><span class="line"><span class="comment">//拥有纯虚函数的类， 就叫抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//是一个抽象的接口，说明图形是有一个得到面积方法</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span>  <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//代表一个接口，一个求图形面积的接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个个打印面积的接口</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆类</span></span><br><span class="line"><span class="comment">//如果 一个子类继承了抽象类， 那么一定要重写这个纯虚函数。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span><span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Circle(<span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;r = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写父类抽象类的纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14</span> *  r * r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"圆的面积是"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;getArea() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> r;<span class="comment">//半径</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一个正方形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span><span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Rect(<span class="keyword">double</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是一个抽象的接口，说明图形是有一个得到面积方法</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span>  <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶一个打印面积的接口</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"正方形的面积是"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;getArea() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> a;<span class="comment">//边长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tri</span> :</span><span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Tri(<span class="keyword">double</span> a, <span class="keyword">double</span> h)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;h = h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span>  <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> * h * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"三角形的面积是"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;getArea() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> a;<span class="comment">//底</span></span><br><span class="line"><span class="keyword">double</span> h;<span class="comment">//高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个传递抽象类 指针的架构函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArea</span><span class="params">(Shape *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p-&gt;print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务层</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Shape p;//抽象类不能够实例化</span></span><br><span class="line"></span><br><span class="line">Shape *sp = <span class="keyword">new</span> Circle(<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类的指针就可以调用纯虚函数， 接口</span></span><br><span class="line"><span class="comment">//sp-&gt;getArea();//在此处就发生了多态</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; sp-&gt;getArea() &lt;&lt; endl;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//delete sp;</span></span><br><span class="line"></span><br><span class="line">printArea(sp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> sp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个正方形的对象。用抽象类指针（父类指针）指向子类对象</span></span><br><span class="line">sp = <span class="keyword">new</span> Rect(<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">printArea(sp);</span><br><span class="line"><span class="keyword">delete</span> sp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务层 根本就不关心 具体对象怎么实现的， 只用抽象类的指针就可以。</span></span><br><span class="line">Shape *sp2 = <span class="keyword">new</span> Tri(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">sp2-&gt;print();</span><br><span class="line"><span class="keyword">delete</span> sp2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" ------   "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;纯虚函数和抽象类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#纯虚函数和抽象类&quot;&gt;&lt;/a&gt; 纯虚函数和抽象类&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620863272021.png&quot; alt=&quot;16208
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>父类指针和子类指针的步长</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0055-%E7%88%B6%E7%B1%BB%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%90%E7%B1%BB%E6%8C%87%E9%92%88%E7%9A%84%E6%AD%A5%E9%95%BF/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0055-父类指针和子类指针的步长/</id>
    <published>2021-05-12T22:31:49.000Z</published>
    <updated>2021-05-12T22:59:07.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="父类指针和子类指针的步长"><a class="markdownIt-Anchor" href="#父类指针和子类指针的步长"></a> 父类指针和子类指针的步长</h1><p><img src="/images/javawz/1620858785306.png" alt="1620858785306"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Parent(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent::print() "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span><span class="keyword">public</span> Parent&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Child(<span class="keyword">int</span> a) :Parent(a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Child :: Print() "</span> &lt;&lt; a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Child <span class="built_in">array</span>[] = &#123;Child(<span class="number">0</span>), Child(<span class="number">1</span>), Child(<span class="number">2</span>) &#125;;</span><br><span class="line"><span class="comment">//array[0]   array[1] array[2]</span></span><br><span class="line"></span><br><span class="line">Child *cp = &amp;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">Parent *pp = &amp;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cp-&gt;print(); <span class="comment">//Child::</span></span><br><span class="line">pp-&gt;print(); <span class="comment">//Child::发生多态</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">cp++; <span class="comment">//Child::12</span></span><br><span class="line"><span class="comment">//pp++;//8</span></span><br><span class="line">pp = cp;</span><br><span class="line"></span><br><span class="line">cp-&gt;print();</span><br><span class="line">pp-&gt;print();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" -----  "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, cp = &amp;<span class="built_in">array</span>[<span class="number">0</span>], pp = cp; i &lt; <span class="number">3</span>; i++, cp++, pp =cp) &#123;</span><br><span class="line">pp-&gt;print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Fu();</span><br><span class="line">Fu(<span class="keyword">int</span> ta): a(ta) &#123;&#125;;</span><br><span class="line">~Fu();</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Fu a = "</span>&lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> :</span> <span class="keyword">public</span> Fu</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Zi();</span><br><span class="line">Zi(<span class="keyword">int</span> a, <span class="keyword">int</span> tb) :Fu(a) ,b(tb)&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Zi b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">~Zi();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Zi::Zi()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Zi::~Zi()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fu::Fu()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fu::~Fu()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Zi zi[] = &#123; Zi(<span class="number">100</span>,<span class="number">200</span>),Zi(<span class="number">300</span>,<span class="number">400</span>),Zi(<span class="number">500</span>,<span class="number">600</span>) &#125;;</span><br><span class="line"></span><br><span class="line">Fu * pFu = zi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">会崩溃,因为(pFu + i) == (pFu + sizeof Fu) 而不是(pFu + sizeof Zi)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; 3; i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">(pFu + i)-&gt;print();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line">Zi * zi1[] = &#123; <span class="keyword">new</span> Zi(<span class="number">1</span>,<span class="number">2</span>),<span class="keyword">new</span> Zi(<span class="number">3</span>,<span class="number">4</span>), <span class="keyword">new</span> Zi(<span class="number">5</span>,<span class="number">6</span>), <span class="keyword">new</span> Zi(<span class="number">7</span>,<span class="number">8</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(zi1) / <span class="keyword">sizeof</span>(Zi *); i++)</span><br><span class="line">&#123;</span><br><span class="line">pFu = zi1[i];</span><br><span class="line">pFu-&gt;print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;父类指针和子类指针的步长&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#父类指针和子类指针的步长&quot;&gt;&lt;/a&gt; 父类指针和子类指针的步长&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620858785306.png
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>vptr指针的分布初始化</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0054-vptr%E6%8C%87%E9%92%88%E7%9A%84%E5%88%86%E5%B8%83%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0054-vptr指针的分布初始化/</id>
    <published>2021-05-12T22:27:20.000Z</published>
    <updated>2021-05-12T22:31:03.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vptr指针的分布初始化"><a class="markdownIt-Anchor" href="#vptr指针的分布初始化"></a> vptr指针的分布初始化</h1><p><img src="/images/javawz/1620858549708.png" alt="1620858549708"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要在构造函数中去调用成员函数。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Parent(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent(int a)...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">print(); <span class="comment">//这个print打印的是 Parent 还是 Child的？</span></span><br><span class="line">        <span class="comment">//调用的是父类的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent::print():  "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Child(<span class="keyword">int</span> a, <span class="keyword">int</span> b) :Parent(a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//vptr指针就执行的子类的虚函数表</span></span><br><span class="line">print(); <span class="comment">//执行的child ？ 还是 parent?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//再此处之前， 是构造父类的内存空间  此时child还有没构造完毕，vptr指针此时指向的是父类的虚函数表</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Child() ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写了父类的虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Child::print()  "</span>&lt;&lt; <span class="string">" , "</span> &lt;&lt;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Parent *p = <span class="keyword">new</span> Child(<span class="number">10</span>, <span class="number">20</span>);<span class="comment">//在此调用Child 的构造函数</span></span><br><span class="line">p-&gt;print(); <span class="comment">//此时发生了多态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vptr指针的分布初始化&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vptr指针的分布初始化&quot;&gt;&lt;/a&gt; vptr指针的分布初始化&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620858549708.png
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>验证vptr指针的存在</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0053-%E9%AA%8C%E8%AF%81vptr%E6%8C%87%E9%92%88%E7%9A%84%E5%AD%98%E5%9C%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0053-验证vptr指针的存在/</id>
    <published>2021-05-12T22:24:38.000Z</published>
    <updated>2021-05-12T22:27:46.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="验证vptr指针的存在"><a class="markdownIt-Anchor" href="#验证vptr指针的存在"></a> 验证vptr指针的存在</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent func "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent2 func "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Parent p1;</span><br><span class="line">Parent2 p2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(p1)"</span> &lt;&lt; <span class="keyword">sizeof</span>(p1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(p2)"</span> &lt;&lt; <span class="keyword">sizeof</span>(p2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//p2多出来的4个字节就是存放vptr指针的空间大小</span></span><br><span class="line"><span class="comment">//vptr指针我们访问不了，vptr指针指向的是Parent2类的虚函数表</span></span><br><span class="line"><span class="comment">//此表中目前有一个 虚函数 func(inta, intb)的入口地址。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;验证vptr指针的存在&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#验证vptr指针的存在&quot;&gt;&lt;/a&gt; 验证vptr指针的存在&lt;/h1&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>多态的原理</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0052-%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0052-多态的原理/</id>
    <published>2021-05-12T22:15:59.000Z</published>
    <updated>2021-05-12T22:21:59.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态的原理"><a class="markdownIt-Anchor" href="#多态的原理"></a> 多态的原理</h1><p><img src="/images/javawz/1620857806688.png" alt="1620857806688"></p><p><img src="/images/javawz/1620857813598.png" alt="1620857813598"></p><p><img src="/images/javawz/1620857825265.png" alt="1620857825265"></p><p><img src="/images/javawz/1620857858870.png" alt="1620857858870"></p><p><img src="/images/javawz/1620857876671.png" alt="1620857876671"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多态的原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#多态的原理&quot;&gt;&lt;/a&gt; 多态的原理&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620857806688.png&quot; alt=&quot;1620857806688&quot;
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>重载重写重定义</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0051-%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%87%8D%E5%AE%9A%E4%B9%89/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0051-重载重写重定义/</id>
    <published>2021-05-12T19:05:42.000Z</published>
    <updated>2021-05-12T19:06:32.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重载重写重定义"><a class="markdownIt-Anchor" href="#重载重写重定义"></a> 重载重写重定义</h1><p><img src="/images/javawz/1620846366366.png" alt="1620846366366"></p><p><img src="/images/javawz/1620846376910.png" alt="1620846376910"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重载重写重定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重载重写重定义&quot;&gt;&lt;/a&gt; 重载重写重定义&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620846366366.png&quot; alt=&quot;16208463
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>虚析构函数</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0050-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0050-虚析构函数/</id>
    <published>2021-05-12T18:49:15.000Z</published>
    <updated>2021-05-12T18:59:02.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚析构函数"><a class="markdownIt-Anchor" href="#虚析构函数"></a> 虚析构函数</h1><p><img src="/images/javawz/1620845408803.png" alt="1620845408803"></p><h3 id="通过父类指针将所有子类对象析构掉需要用到虚析构函数"><a class="markdownIt-Anchor" href="#通过父类指针将所有子类对象析构掉需要用到虚析构函数"></a> 通过父类指针将所有子类对象析构掉,需要用到虚析构函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"A() ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>]; <span class="comment">//给p开辟了一个空间</span></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"A string "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~A()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *p; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"B()..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"B string"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span>  ~B()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~B()...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"C()..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">"C string"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span>  ~C()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~C()...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A *p)</span><span class="comment">//p = cp;  p = &amp;c //用父类指针指向子类对象。</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">p-&gt;print(); <span class="comment">//在此处发生多态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//delete p; //delete 一个父类指针   如何让delete p不是将p看做父类指针来delete 而是当子类呢</span></span><br><span class="line"><span class="comment">//如果类的析构函数加上了 virtual delete 就会发生多态。 delelte p 会调用C类的析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDelete</span><span class="params">(A*p)</span> <span class="comment">//p-&gt;cp   父类指针指向子类对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">//p-&gt;~()  //如果~（） 不加virtual关键 不会发生多态。</span></span><br><span class="line"><span class="comment">//希望delete p， p-&gt;~() 调用C类的~（）</span></span><br><span class="line"><span class="comment">// 如果给 所有的类的析构函数加上virtual关键字  就会发生多态。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C *cp = new C;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cp-&gt;print();//cp的函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">delete cp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" -----  "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">C * cp1 = <span class="keyword">new</span> C; <span class="comment">//发生3此构造 A() B（） C()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test();</span></span><br><span class="line">func(cp1);</span><br><span class="line">myDelete(cp1); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;虚析构函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#虚析构函数&quot;&gt;&lt;/a&gt; 虚析构函数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620845408803.png&quot; alt=&quot;1620845408803&quot;
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>动态联编和静态联编</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0049-%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0049-动态联编和静态联编/</id>
    <published>2021-05-12T18:27:48.000Z</published>
    <updated>2021-05-12T18:29:58.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态联编和静态联编"><a class="markdownIt-Anchor" href="#动态联编和静态联编"></a> 动态联编和静态联编</h1><p><img src="/images/javawz/1620844095321.png" alt="1620844095321"></p><p><img src="/images/javawz/1620844190008.png" alt="1620844190008"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态联编和静态联编&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动态联编和静态联编&quot;&gt;&lt;/a&gt; 动态联编和静态联编&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620844095321.png&quot; alt=&quot;16
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>多态的定义和多态的三个必要条件</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0048-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%89%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0048-多态的定义和多态的三个必要条件/</id>
    <published>2021-05-12T18:11:02.000Z</published>
    <updated>2021-05-12T18:28:32.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态的定义和多态的三个必要条件"><a class="markdownIt-Anchor" href="#多态的定义和多态的三个必要条件"></a> 多态的定义和多态的三个必要条件</h1><p><img src="/images/javawz/1620843121025.png" alt="1620843121025"></p><p><img src="/images/javawz/1620843156924.png" alt="1620843156924"></p><p><img src="/images/javawz/1620843238613.png" alt="1620843238613"></p><p><img src="/images/javawz/1620843246344.png" alt="1620843246344"></p><p><img src="/images/javawz/1620843281030.png" alt="1620843281030"></p><h3 id="多态发生的三个必要条件"><a class="markdownIt-Anchor" href="#多态发生的三个必要条件"></a> 多态发生的三个必要条件</h3><p>要有继承。<br>要有子类重写父类的虚函数<br>父类指针(或者引用) 指向子类对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//当前Hero的战斗力是10</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getAd</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超级英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperHero</span> :</span><span class="keyword">public</span> Hero</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getAd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BugHero</span> :</span> <span class="keyword">public</span> Hero</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getAd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//怪兽</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//战斗的函数</span></span><br><span class="line"><span class="comment">//先写的 战斗函数， 通过用父类的指针作为参数</span></span><br><span class="line"><span class="comment">//多态具有调用未来的 意义。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlayerFight</span><span class="params">(Hero *hero, Monster *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//多态这种现象较 动态联编 是迟绑定 或是 晚绑定</span></span><br><span class="line"><span class="keyword">if</span> (hero-&gt;getAd() &gt; m-&gt;getAd()) &#123; <span class="comment">//在此hero-&gt;getAd()就发生了多态</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"英雄战胜了 叫兽"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"英雄挂了。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Hero hero1;</span><br><span class="line">Monster mon1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后写的超级英雄</span></span><br><span class="line">SuperHero hero2;</span><br><span class="line"></span><br><span class="line">BugHero hero3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始战斗</span></span><br><span class="line">PlayerFight(&amp;hero1, &amp;mon1);</span><br><span class="line"></span><br><span class="line">PlayerFight(&amp;hero2, &amp;mon1); <span class="comment">//Hero *hero = &amp;hero2;</span></span><br><span class="line"></span><br><span class="line">PlayerFight(&amp;hero3, &amp;mon1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的三个必要条件</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>*p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p = &amp;a;</span><br><span class="line"></span><br><span class="line">*p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态发生的三个必要条件</span></span><br><span class="line"><span class="comment">//1 要有继承。</span></span><br><span class="line"><span class="comment">//2 要有子类重写父类的虚函数</span></span><br><span class="line"><span class="comment">//3  父类指针(或者引用) 指向子类对象。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func(a); //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a 不大于10"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void func(int a);</span></span><br><span class="line"><span class="comment">void func(int a, int b);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多态的定义和多态的三个必要条件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#多态的定义和多态的三个必要条件&quot;&gt;&lt;/a&gt; 多态的定义和多态的三个必要条件&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/16208431
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>多继承与虚继承</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0047-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0047-多继承与虚继承/</id>
    <published>2021-05-12T17:40:38.000Z</published>
    <updated>2021-05-12T17:47:19.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多继承与虚继承"><a class="markdownIt-Anchor" href="#多继承与虚继承"></a> 多继承与虚继承</h1><h3 id="多继承"><a class="markdownIt-Anchor" href="#多继承"></a> 多继承</h3><p>俗话讲的,鱼与熊掌不可兼得,而在计算机就可以实现,生成一种新的对象,<br>叫熊掌鱼,多继承自鱼和熊掌即可。还比如生活中,“兼”。</p><p><img src="/images/javawz/1620841315510.png" alt="1620841315510"></p><h4 id="一个类有多个直接基类的继承关系称为多继承"><a class="markdownIt-Anchor" href="#一个类有多个直接基类的继承关系称为多继承"></a> 一个类有多个直接基类的继承关系称为多继承</h4><p><img src="/images/javawz/1620841334608.png" alt="1620841334608"></p><h4 id="沙发床实现"><a class="markdownIt-Anchor" href="#沙发床实现"></a> 沙发床实现</h4><p><img src="/images/javawz/1620841356908.png" alt="1620841356908"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//家具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Furniture</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m; <span class="comment">//材质  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果子类虚继承本来， 编译器会将父类中的成员， 只拷贝一份。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//床类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bed</span>:</span> <span class="keyword">virtual</span>  <span class="keyword">public</span> Furniture</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"在床上睡觉"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//沙发类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sofa</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Furniture</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"在沙发上睡觉"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//沙发床</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SofaBed</span> :</span><span class="keyword">public</span> Bed, <span class="keyword">public</span> Sofa</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sitAndSleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sit();<span class="comment">//sofa</span></span><br><span class="line">sleep();<span class="comment">//bed</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Bed b;</span><br><span class="line">b.sleep();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"  ---- "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Sofa s; <span class="comment">//m </span></span><br><span class="line">s.m = <span class="number">100</span>;</span><br><span class="line">s.sit();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"------- "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">SofaBed sb;</span><br><span class="line">sb.sitAndSleep();</span><br><span class="line"></span><br><span class="line">sb.m; <span class="comment">//多继承如果 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚继承"><a class="markdownIt-Anchor" href="#虚继承"></a> 虚继承</h3><p>如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，则<br>在对该基类中声明的名字进行访问时，可能产生二义性</p><p><img src="/images/javawz/1620841441584.png" alt="1620841441584"></p><p><img src="/images/javawz/1620841525168.png" alt="1620841525168"></p><p><img src="/images/javawz/1620841541994.png" alt="1620841541994"></p><p><img src="/images/javawz/1620841576400.png" alt="1620841576400"></p><p><img src="/images/javawz/1620841589330.png" alt="1620841589330"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多继承与虚继承&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#多继承与虚继承&quot;&gt;&lt;/a&gt; 多继承与虚继承&lt;/h1&gt;
&lt;h3 id=&quot;多继承&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#多继承&quot;&gt;&lt;/a&gt; 多
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>继承中的static</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0047-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84static/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0047-继承中的static/</id>
    <published>2021-05-12T17:15:14.000Z</published>
    <updated>2021-05-12T18:28:44.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承中的static"><a class="markdownIt-Anchor" href="#继承中的static"></a> 继承中的static</h1><p><img src="/images/javawz/1620839824421.png" alt="1620839824421"></p><p><img src="/images/javawz/1620839885212.png" alt="1620839885212"></p><p><img src="/images/javawz/1620839891459.png" alt="1620839891459"></p><p><img src="/images/javawz/1620840002589.png" alt="1620840002589"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::s = <span class="number">0</span>;<span class="comment">//静态成员变量要在类的外部初始化</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b.s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">b.s = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b.s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; A::s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;继承中的static&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#继承中的static&quot;&gt;&lt;/a&gt; 继承中的static&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620839824421.png&quot; alt=
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>父类和子类出现重名变量</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0046-%E7%88%B6%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB%E5%87%BA%E7%8E%B0%E9%87%8D%E5%90%8D%E5%8F%98%E9%87%8F/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0046-父类和子类出现重名变量/</id>
    <published>2021-05-12T17:04:05.000Z</published>
    <updated>2021-05-12T17:08:32.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="父类和子类出现重名变量"><a class="markdownIt-Anchor" href="#父类和子类出现重名变量"></a> 父类和子类出现重名变量</h1><p><img src="/images/javawz/1620839080609.png" alt="1620839080609"></p><p><img src="/images/javawz/1620839161158.png" alt="1620839161158"></p><p><img src="/images/javawz/1620839167367.png" alt="1620839167367"></p><p><img src="/images/javawz/1620839206345.png" alt="1620839206345"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Parent(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span><span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">Child(<span class="keyword">int</span> a, <span class="keyword">int</span> aa) : Parent(aa)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a; <span class="comment">//让Child 的a  = a， 让父亲的a = aa</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//默认是使用 当前类的重名的变量</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent::a = "</span> &lt;&lt; Parent::a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//如果想访问父类中的重名变量 需要加上父类的作用域</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  a ---&gt; Paretn::a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Child <span class="title">c</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">c.print();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;父类和子类出现重名变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#父类和子类出现重名变量&quot;&gt;&lt;/a&gt; 父类和子类出现重名变量&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620839080609.png&quot; a
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>子类中的构造和析构</title>
    <link href="https://xiaowuyoucy.github.io/2021/05/13/cpp0045-%E5%AD%90%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/"/>
    <id>https://xiaowuyoucy.github.io/2021/05/13/cpp0045-子类中的构造和析构/</id>
    <published>2021-05-12T16:56:24.000Z</published>
    <updated>2021-05-12T16:58:58.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子类中的构造和析构"><a class="markdownIt-Anchor" href="#子类中的构造和析构"></a> 子类中的构造和析构</h1><p><img src="/images/javawz/1620838602286.png" alt="1620838602286"></p><p><img src="/images/javawz/1620838656750.png" alt="1620838656750"></p><p><img src="/images/javawz/1620838667523.png" alt="1620838667523"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//子类在进行初始化成员变量的时候， 如果此成员变量是继承过来的， 那么需要调用父类的构造器来初始化。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Parent(<span class="keyword">int</span> a) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent(int a) ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Parent()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Parent()..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//子类继承于父类， 父类中的成员变量 应该用 父类的构造函数来初始化</span></span><br><span class="line">Son(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : Parent(a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son(int a, int b) ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Parent p = Parent(b);//是一个新的parent对象。</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Son() ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pirntAB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Parent::printA();</span><br><span class="line"><span class="keyword">this</span>-&gt;printB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Parent <span class="title">p</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Son <span class="title">s</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>; <span class="comment">// p + s独有</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.pirntAB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">test1();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;子类中的构造和析构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#子类中的构造和析构&quot;&gt;&lt;/a&gt; 子类中的构造和析构&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/1620838602286.png&quot; alt=&quot;16
      
    
    </summary>
    
      <category term="cpp" scheme="https://xiaowuyoucy.github.io/categories/cpp/"/>
    
    
  </entry>
  
</feed>
