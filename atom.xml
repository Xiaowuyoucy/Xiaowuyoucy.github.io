<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanChen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowuyoucy.github.io/"/>
  <updated>2021-09-28T10:14:17.873Z</updated>
  <id>https://xiaowuyoucy.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>结构体与指针应用_封包构造与解析</title>
    <link href="https://xiaowuyoucy.github.io/2021/09/28/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%8C%87%E9%92%88%E5%BA%94%E7%94%A8-%E5%B0%81%E5%8C%85%E6%9E%84%E9%80%A0%E4%B8%8E%E8%A7%A3%E6%9E%90/"/>
    <id>https://xiaowuyoucy.github.io/2021/09/28/结构体与指针应用-封包构造与解析/</id>
    <published>2021-09-28T09:34:41.000Z</published>
    <updated>2021-09-28T10:14:17.873Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javawz/image-20210928175610434.png" alt="image-20210928175610434"></p><p><img src="/images/javawz/image-20210928180651334.png" alt="image-20210928180651334"></p><p><img src="/images/javawz/image-20210928181047378.png" alt="image-20210928181047378"></p><p><img src="/images/javawz/image-20210928181341416.png" alt="image-20210928181341416"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">byte bType;</span><br><span class="line"><span class="keyword">int</span> ilength;</span><br><span class="line"><span class="keyword">char</span>* cValue;</span><br><span class="line">&#125;TLV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> iCmdID;</span><br><span class="line">byte bCount;</span><br><span class="line"><span class="keyword">int</span> iResolve;</span><br><span class="line">TLV tlv[<span class="number">0</span>];</span><br><span class="line">&#125;COMMAND;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 发送命令函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendCmd</span><span class="params">(<span class="keyword">void</span>* pDate, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParseCmd</span><span class="params">(<span class="keyword">void</span>* pDate, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令类型 110 保留字0填充</span></span><br><span class="line"><span class="comment">// 2个TLV 一个是字符串 hello 一个是字符串agp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line">TLV tl1;</span><br><span class="line">TLV tl2;</span><br><span class="line"><span class="keyword">char</span>* pString1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span>* pString2 = <span class="literal">NULL</span>;</span><br><span class="line">COMMAND* pCmd = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> iCmdLength = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> iTLVCount = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(&amp;tl1, <span class="number">0</span>, <span class="keyword">sizeof</span>(TLV));</span><br><span class="line"><span class="built_in">memset</span>(&amp;tl2, <span class="number">0</span>, <span class="keyword">sizeof</span>(TLV));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造字符串</span></span><br><span class="line">pString1 = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">"hello"</span>));</span><br><span class="line"><span class="built_in">memcpy</span>(pString1, <span class="string">"hello"</span>, <span class="built_in">strlen</span>(<span class="string">"hello"</span>));</span><br><span class="line">pString2 = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">"agp"</span>));</span><br><span class="line"><span class="built_in">memcpy</span>(pString2, <span class="string">"agp"</span>, <span class="built_in">strlen</span>(<span class="string">"agp"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造tlv1</span></span><br><span class="line">tl1.ilength = <span class="built_in">strlen</span>(<span class="string">"hello"</span>);</span><br><span class="line">tl1.bType = <span class="number">1</span>;</span><br><span class="line">tl1.cValue = pString1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造tlv2</span></span><br><span class="line">tl2.ilength = <span class="built_in">strlen</span>(<span class="string">"agp"</span>);</span><br><span class="line">tl2.bType = <span class="number">1</span>;</span><br><span class="line">tl2.cValue = pString2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造发送包</span></span><br><span class="line">iCmdLength = <span class="keyword">sizeof</span>(COMMAND) + tl1.ilength + tl2.ilength + <span class="number">2</span> * <span class="number">5</span>;</span><br><span class="line">pCmd = <span class="built_in">malloc</span>(iCmdLength);</span><br><span class="line">pCmd-&gt;iCmdID = <span class="number">110</span>;</span><br><span class="line">pCmd-&gt;bCount = <span class="number">2</span>;</span><br><span class="line">pCmd-&gt;iResolve = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="keyword">void</span>*)((<span class="keyword">int</span>)pCmd + <span class="keyword">sizeof</span>(COMMAND)), &amp;tl1, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="keyword">void</span>*)((<span class="keyword">int</span>)pCmd + <span class="keyword">sizeof</span>(COMMAND) + <span class="number">5</span>), tl1.cValue, tl1.ilength);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="keyword">void</span>*)((<span class="keyword">int</span>)pCmd + <span class="keyword">sizeof</span>(COMMAND) + <span class="number">5</span> + tl1.ilength), &amp;tl2, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="keyword">void</span>*)((<span class="keyword">int</span>)pCmd + <span class="keyword">sizeof</span>(COMMAND) + <span class="number">5</span> + tl1.ilength + <span class="number">5</span>), tl2.cValue, tl2.ilength);</span><br><span class="line">SendCmd(pCmd,iCmdLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line">ParseCmd(pCmd,iCmdLength);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* g_PDate = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendCmd</span><span class="params">(<span class="keyword">void</span>* pDate, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">g_PDate = <span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">memcpy</span>(g_PDate, pDate, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParseCmd</span><span class="params">(<span class="keyword">void</span>* pDate, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">COMMAND* cmd = (COMMAND*)pDate;</span><br><span class="line">TLV* ptl1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TLV));</span><br><span class="line">TLV* ptl2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TLV));</span><br><span class="line"><span class="keyword">char</span>* pString1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span>* pString2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">memset</span>(ptl1, <span class="number">0</span>, <span class="keyword">sizeof</span>(TLV));</span><br><span class="line"><span class="built_in">memset</span>(ptl2, <span class="number">0</span>, <span class="keyword">sizeof</span>(TLV));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"命令ID:%d\r\n"</span>, cmd-&gt;iCmdID);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"TLV个数:%d\r\n"</span>, cmd-&gt;bCount);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"保留字段:%d\r\n"</span>, cmd-&gt;iResolve);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"TLV数据--------------------\r\n"</span>);</span><br><span class="line">ptl1 = (TLV*)((<span class="keyword">int</span>)pDate + <span class="keyword">sizeof</span>(COMMAND));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"TL1类型:%d\r\n"</span>, ptl1-&gt;bType);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"TL1长度:%d\r\n"</span>, ptl1-&gt;ilength);</span><br><span class="line">pString1 = <span class="built_in">malloc</span>(ptl1-&gt;ilength + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(pString1, (<span class="keyword">void</span>*)((<span class="keyword">int</span>)ptl1 + <span class="keyword">sizeof</span>(TLV) - <span class="number">4</span>), ptl1-&gt;ilength);</span><br><span class="line">pString1[ptl1-&gt;ilength] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"TL1数据:%s\r\n"</span>, pString1);</span><br><span class="line"></span><br><span class="line">ptl2 = (TLV*)((<span class="keyword">int</span>)pDate + <span class="keyword">sizeof</span>(COMMAND) + ptl1-&gt;ilength + <span class="keyword">sizeof</span>(TLV) - <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"TL2类型:%d\r\n"</span>, ptl2-&gt;bType);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"TL2长度:%d\r\n"</span>, ptl2-&gt;ilength);</span><br><span class="line">pString2 = <span class="built_in">malloc</span>(ptl2-&gt;ilength + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(pString2, (<span class="keyword">void</span>*)((<span class="keyword">int</span>)ptl2 + <span class="keyword">sizeof</span>(TLV) - <span class="number">4</span>), ptl2-&gt;ilength);</span><br><span class="line">pString2[ptl2-&gt;ilength] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"TL2数据:%s\r\n"</span>, pString2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javawz/image-20210928175610434.png&quot; alt=&quot;image-20210928175610434&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/image-20210928180651
      
    
    </summary>
    
      <category term="C" scheme="https://xiaowuyoucy.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>函数调用过程与调用约定</title>
    <link href="https://xiaowuyoucy.github.io/2021/09/28/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <id>https://xiaowuyoucy.github.io/2021/09/28/函数调用过程与调用约定/</id>
    <published>2021-09-27T17:39:51.000Z</published>
    <updated>2021-09-27T17:48:34.365Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数调用约定"><a class="markdownIt-Anchor" href="#函数调用约定"></a> 函数调用约定</h3><p><code>__cdecl</code>    缺省调用方式，函数采用从右到左的压栈方式，调用方清理堆栈，注意可变参数<br></p><p><code>__stdcall</code>  函数的参数自右向左通过栈传递，被调用方清理堆栈<br></p><p><code>__fastcall</code> 通过寄存器来传送参数，被调用方清理堆栈<br></p><p><code>__thiscall</code>用于C++成员函数，使用ecx存放this指针<br></p><p>naked call 裸函数，上面几种方式会产生保存一些寄存器的代码，这种不产生。naked call不是类型修饰符，必须和_declspec共同使用<br><code>__declspec(naked)</code> 是告诉编译器 不要对函数进行优化  函数的所有实现包括堆栈的平衡  参数的压栈 ebp的赋值 还原 都要我们来做</p><br><h4 id="决定以下内容"><a class="markdownIt-Anchor" href="#决定以下内容"></a> 决定以下内容：</h4><p>1)函数参数的压栈顺序<br>2)由调用者还是被调用者把参数弹出栈<br>3)以及产生函数修饰名的方法</p><h4 id="修饰名"><a class="markdownIt-Anchor" href="#修饰名"></a> 修饰名</h4><p>1、修饰名(Decoration name)：&quot;C&quot;或者&quot;C++“函数在内部（编译和链接）通过修饰名识别<br>2、C编译时函数名修饰约定规则：<br><br><code>__stdcall</code>调用约定在输出函数名前加上一个下划线前缀，后面加上一个”@&quot;符号和其参数的字节数，格式为_functionname@number,<br>例如 ：function(int a, int b)，其修饰名为：_function@8</p><br><p><code>__cdecl</code>调用约定仅在输出函数名前加上一个下划线前缀，格式为_functionname。</p><p><br><code>__fastcall</code>调用约定在输出函数名前加上一个&quot;@“符号，后面也是一个”@&quot;符号和其参数的字节数，格式为@functionname@number。</p><br><p>注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一般WIN32的函数都是__stdcall</span><br><span class="line"> #define CALLBACK __stdcall</span><br><span class="line"> #define WINAPI　 __stdcall</span><br></pre></td></tr></table></figure><hr><h3 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认是__cdecl</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆栈平衡由函数内部处理</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">stdAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前两个参数使用寄存器存储,堆栈平衡由函数内部处理</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">fastAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆栈平衡由我们自己处理</span></span><br><span class="line"><span class="keyword">int</span> __declspec(naked) nkAdd(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">__asm  </span><br><span class="line">&#123;  </span><br><span class="line">push [esp + <span class="number">0</span>ch]  </span><br><span class="line">push [esp + <span class="number">0</span>ch]  </span><br><span class="line">push [esp + <span class="number">0</span>ch]      </span><br><span class="line">call stdAdd</span><br><span class="line">mov eax,eax</span><br><span class="line">ret</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="comment">// 内联汇编</span></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax,eax</span><br><span class="line">mov eax,eax</span><br><span class="line">mov eax,eax</span><br><span class="line">&#125;</span><br><span class="line">result = cAdd(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line">stdAdd(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line">fastAdd(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line"> nkAdd(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line"><span class="comment">//CreateThread();</span></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数调用约定&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数调用约定&quot;&gt;&lt;/a&gt; 函数调用约定&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;__cdecl&lt;/code&gt;    缺省调用方式，函数采用从右到左的压栈方式，调用方清理堆栈，注意可变参数&lt;
      
    
    </summary>
    
      <category term="C" scheme="https://xiaowuyoucy.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>结构体、共用体、枚举</title>
    <link href="https://xiaowuyoucy.github.io/2021/09/28/%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE/"/>
    <id>https://xiaowuyoucy.github.io/2021/09/28/结构体、共用体、枚举/</id>
    <published>2021-09-27T16:52:48.000Z</published>
    <updated>2021-09-27T17:06:48.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h3><p>不同类型数据的集合<br>定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct 结构名</span><br><span class="line">&#123;结构成员表&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">int no;</span><br><span class="line">char name[10];</span><br><span class="line">int age;</span><br><span class="line">double socre;</span><br><span class="line">char addr[50];</span><br><span class="line">struct date birth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct date</span><br><span class="line">&#123;</span><br><span class="line">int year;</span><br><span class="line">int month;</span><br><span class="line">int day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct student st1;</span><br></pre></td></tr></table></figure><p>初始化，可直接清空</p><h3 id="memset"><a class="markdownIt-Anchor" href="#memset"></a> memset</h3><p>函数原型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memset(void *s, int ch, size_t n);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memset(&amp;st, 0, sizeof(st)); //用0填充st内存</span><br></pre></td></tr></table></figure><h3 id="memcpy"><a class="markdownIt-Anchor" href="#memcpy"></a> memcpy</h3><p>函数原型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *destin, void *source, unsigned n);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy(st.name, &quot;agp&quot;, strlen(&quot;agp&quot;)); //将“agp”复制到st.name内存中</span><br></pre></td></tr></table></figure><h3 id="typedef"><a class="markdownIt-Anchor" href="#typedef"></a> typedef</h3><p>使用typedef创建结构体、共用体、枚举类型别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">typedef struct date</span><br><span class="line">&#123;</span><br><span class="line">int year;</span><br><span class="line">int month;</span><br><span class="line">int day;</span><br><span class="line">&#125;MDATE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef union data</span><br><span class="line">&#123;</span><br><span class="line">char c[10];</span><br><span class="line">int a;</span><br><span class="line">double f;</span><br><span class="line">&#125; MDATA;</span><br><span class="line">MDATA x;</span><br><span class="line"></span><br><span class="line">typedef enum week &#123;</span><br><span class="line">sun, </span><br><span class="line">mon, </span><br><span class="line">tue,</span><br><span class="line">wed,</span><br><span class="line">thu, </span><br><span class="line">fri,</span><br><span class="line">sta</span><br><span class="line">&#125;WEEK;</span><br></pre></td></tr></table></figure><h5 id="结构体指针变量访问成员"><a class="markdownIt-Anchor" href="#结构体指针变量访问成员"></a> 结构体指针变量访问成员</h5><p>访问方法，指针用-&gt; .</p><h5 id="大小-内存对齐-x86-默认4字节对齐"><a class="markdownIt-Anchor" href="#大小-内存对齐-x86-默认4字节对齐"></a> 大小 内存对齐 X86 默认4字节对齐</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(1)  修改内存对齐为1</span><br><span class="line">一般是 网络通信 双机通信~~ 使用</span><br></pre></td></tr></table></figure><p>sizeof(结构名或者变量名)<br>对齐原因：有些平台每次读都是从偶地址开始，如果一个int型（假设为 32位）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要2个读周期，并对两次读出的结果的高低 字节进行拼凑才能得到该int数据。显然在读取效率上下降很多。这也是空间和时间的博弈。<br><a href="http://baike.baidu.com/view/925608.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/925608.htm</a><br>原则：地址可以被整除</p><p>结构数组<br>地址1 结构1<br>地址2 结构2<br>…</p><h3 id="共用体union"><a class="markdownIt-Anchor" href="#共用体union"></a> 共用体union</h3><p>共用一块内存，某个时刻只有一个有效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union data</span><br><span class="line">&#123;</span><br><span class="line">char c[10];</span><br><span class="line">int a;</span><br><span class="line">double f;</span><br><span class="line">&#125;;</span><br><span class="line">union data x;</span><br></pre></td></tr></table></figure><h3 id="枚举enum-提高程序可读性"><a class="markdownIt-Anchor" href="#枚举enum-提高程序可读性"></a> 枚举enum 提高程序可读性</h3><p>有名字的整形常量的集合，该类型变量只能取其中的一个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum week &#123;sun, mon, tue, wed,thu, fri, sta&#125;; 不赋值 默认从0开始</span><br><span class="line">enum week w = sun; //sun == 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;结构体&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#结构体&quot;&gt;&lt;/a&gt; 结构体&lt;/h3&gt;
&lt;p&gt;不同类型数据的集合&lt;br&gt;
定义&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="C" scheme="https://xiaowuyoucy.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>编译过程与预处理</title>
    <link href="https://xiaowuyoucy.github.io/2021/09/27/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>https://xiaowuyoucy.github.io/2021/09/27/编译过程与预处理/</id>
    <published>2021-09-27T15:41:21.000Z</published>
    <updated>2021-09-27T15:55:27.688Z</updated>
    
    <content type="html"><![CDATA[<p>1.编写文本代码，C或Cpp文件<br><br></p><p>2.编译，就是Compile，由C编译程序对你写的代码进行词法和语法分析，发现并报告错误。<br>如若无错，则生成中间代码，扩展名.obj，此时是二进制</p><br><p>3.链接，Link，生成可执行的Exe文件。由于一个程序的源码可由多个文件组成。这些文件在第二步<br>中分别编译，生成各自的目标文件，这一步的作用便是将这些Obj文件，以及程序中需要的其它库文件(Dll除开），统一到一个文件中来，形成单个的Exe 文件。此Exe文件便可以在操作系统下直接运行了。</p><br><h4 id="源文件-预编译处理-编译优化汇编程序-链接程序可执行文件"><a class="markdownIt-Anchor" href="#源文件-预编译处理-编译优化汇编程序-链接程序可执行文件"></a> 源文件－－&gt;预编译处理－－&gt;编译(优化,汇编程序)－－&gt;链接程序–&gt;可执行文件</h4><p>预处理：编译成目标文件前对源程序进行处理</p><br><h3 id="宏处理-define"><a class="markdownIt-Anchor" href="#宏处理-define"></a> 宏处理 #define</h3><p>预处理指令#开头，无逗号，可出现在任意位置，作用域为出现位置到文件结尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define 一改全改</span><br><span class="line">#define PI 3.14</span><br><span class="line">#define MAX(a, b) (a &gt; b ? a : b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define Add(a,b) a+b  </span><br><span class="line">c * Add(a,b) * d == c * a + b * d，导致计算错误，解决方法是在a+b中加上括号(a + b )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#undef 宏名 //取消宏定义</span><br></pre></td></tr></table></figure><p><br><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">多行定义 \</span><br><span class="line"></span><br><span class="line">#define MAX(a, b) (a &gt; b ? \</span><br><span class="line">a : b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define APG_DELETE(p) do&#123; delete p; p = NULL&#125; while(0)</span><br><span class="line"></span><br><span class="line">if(NULL != p) APG_DELETE(p)</span><br><span class="line">else   ...do sth...</span><br><span class="line">if(NULL != p) AGP_DELETE(p);</span><br><span class="line">else   ...do sth...</span><br></pre></td></tr></table></figure><p><br><br></p><h3 id="文件包含-include"><a class="markdownIt-Anchor" href="#文件包含-include"></a> 文件包含 #include</h3><p><code>#include&lt;头文件名称&gt;</code>: 先在系统路径搜索文件（一般是include）<br><code>#include&quot;头文件名称&quot;</code>：先在当前目录搜索</p><p><br><br></p><h3 id="条件编译与program"><a class="markdownIt-Anchor" href="#条件编译与program"></a> 条件编译与#program</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if 0或1  //如果是0则不编译，如果是1则编译</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><br><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 宏名 //如果宏名已定义，执行块1，否则执行块2</span><br><span class="line">块1....</span><br><span class="line">#else</span><br><span class="line">块2.....</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><br><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef 宏名 //如果宏名没有定义，我们就定义一个这样的宏，防止头文件被重复包含</span><br><span class="line">#define 宏名</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><br><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#program once //防止头文件被重复包含，只能在vs中用</span><br></pre></td></tr></table></figure><p><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.编写文本代码，C或Cpp文件&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;2.编译，就是Compile，由C编译程序对你写的代码进行词法和语法分析，发现并报告错误。&lt;br&gt;
如若无错，则生成中间代码，扩展名.obj，此时是二进制&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;3.链接，Link，生成可执行
      
    
    </summary>
    
      <category term="C" scheme="https://xiaowuyoucy.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>STL中常用的集合算法</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/26/cpp0094-STL%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/26/cpp0094-STL中常用的集合算法/</id>
    <published>2021-07-26T15:13:19.000Z</published>
    <updated>2021-07-26T15:18:51.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stl中常用的集合算法"><a class="markdownIt-Anchor" href="#stl中常用的集合算法"></a> STL中常用的集合算法</h1><h4 id="set_unionset_intersectionset_difference"><a class="markdownIt-Anchor" href="#set_unionset_intersectionset_difference"></a> set_union(),set_intersection(),set_difference()</h4><p>set_union: 构造一个有序序列，包含两个有序序列的并集。</p><p>set_intersection: 构造一个有序序列，包含两个有序序列的交集。</p><p>假设有集合A和B，所有属于A且不属于B的元素的集合被称为A与B的差集。</p><p>示例：对于集合A = {a, b, c, d}和集合B = {b, c, w}，则A与B 的差集为{a, d}</p><p>也就是集合A中有的元素,在集合B中没有的这部分元素，就是集合A和集合B中的差集</p><p>set_difference: 构造一个有序序列，该序列保留第一个有序序列中存在而第二个有序序列中不存在的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vecIntA;</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(1);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(5);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(7);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(9);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          vector&lt;int&gt; vecIntB;</span><br><span class="line"></span><br><span class="line">​          vecIntB.push_back(1);</span><br><span class="line"></span><br><span class="line">​          vecIntB.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecIntB.push_back(5);</span><br><span class="line"></span><br><span class="line">​          vecIntB.push_back(6);</span><br><span class="line"></span><br><span class="line">​          vecIntB.push_back(8);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          vector&lt;int&gt; vecIntC;</span><br><span class="line"></span><br><span class="line">​          vecIntC.resize(10);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          //并集</span><br><span class="line"></span><br><span class="line">​          set_union(vecIntA.begin(), vecIntA.end(), vecIntB.begin(), vecIntB.end(), vecIntC.begin());          //vecIntC : &#123;1,3,5,6,7,8,9,0,0,0&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          //交集</span><br><span class="line"></span><br><span class="line">​          fill(vecIntC.begin(),vecIntC.end(),0);</span><br><span class="line"></span><br><span class="line">​          set_intersection(vecIntA.begin(), vecIntA.end(),  </span><br><span class="line">vecIntB.begin(), vecIntB.end(), vecIntC.begin());        //vecIntC: &#123;1,3,5,0,0,0,0,0,0,0&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          //差集</span><br><span class="line"></span><br><span class="line">​          fill(vecIntC.begin(),vecIntC.end(),0);</span><br><span class="line"></span><br><span class="line">​          set_difference(vecIntA.begin(), vecIntA.end(), vecIntB.begin(),   </span><br><span class="line">           vecIntB.end(), vecIntC.begin());          //vecIntC: &#123;7,9,0,0,0,0,0,0,0,0&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printV</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_union</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">3</span>);</span><br><span class="line">v1.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">v2.push_back(<span class="number">2</span>);</span><br><span class="line">v2.push_back(<span class="number">4</span>);</span><br><span class="line">v2.push_back(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">v3.resize(v1.size() + v2.size());</span><br><span class="line"><span class="comment">//v1∪v2,把相同部分去掉,将结果存放到v3容器中</span></span><br><span class="line">set_union(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin());</span><br><span class="line"></span><br><span class="line">for_each(v3.begin(),v3.end(), printV);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_set_intersection</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">3</span>);</span><br><span class="line">v1.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">v2.push_back(<span class="number">1</span>);</span><br><span class="line">v2.push_back(<span class="number">3</span>);</span><br><span class="line">v2.push_back(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">v3.resize(v1.size()+v2.size());</span><br><span class="line"><span class="comment">//v1∩v2,将不相同的部分去掉,把结果存放到v3容器中</span></span><br><span class="line">set_intersection(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin());</span><br><span class="line">for_each(v3.begin(), v3.end(), printV);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_difference</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"></span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">2</span>);</span><br><span class="line">v1.push_back(<span class="number">3</span>);</span><br><span class="line">v1.push_back(<span class="number">4</span>);</span><br><span class="line">v1.push_back(<span class="number">4</span>);</span><br><span class="line">v1.push_back(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"></span><br><span class="line">v2.push_back(<span class="number">1</span>);</span><br><span class="line">v2.push_back(<span class="number">2</span>);</span><br><span class="line">v2.push_back(<span class="number">3</span>);</span><br><span class="line">v2.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">v3.resize(v1.size() + v2.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  set_difference 差集:v1 - v2 将剩余元素存放在v3中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      假设有集合A和B，所有属于A且不属于B的元素的集合被称为A与B的差集。</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      示例：对于集合A = &#123;a, b, c, d&#125;和集合B = &#123;b, c, w&#125;，则A与B 的差集为&#123;a, d&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());</span><br><span class="line">for_each(v3.begin(), v3.end(), printV);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test_union();</span><br><span class="line">test_set_intersection();</span><br><span class="line">test_difference();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stl中常用的集合算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stl中常用的集合算法&quot;&gt;&lt;/a&gt; STL中常用的集合算法&lt;/h1&gt;
&lt;h4 id=&quot;set_unionset_intersectionset_difference&quot;
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>STL中常用的算术和生成算法</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/26/cpp0093-STL%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%9C%AF%E5%92%8C%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/26/cpp0093-STL中常用的算术和生成算法/</id>
    <published>2021-07-26T14:44:33.000Z</published>
    <updated>2021-07-26T14:46:46.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stl中常用的算术和生成算法"><a class="markdownIt-Anchor" href="#stl中常用的算术和生成算法"></a> STL中常用的算术和生成算法</h1><h4 id="accumulate"><a class="markdownIt-Anchor" href="#accumulate"></a> accumulate()</h4><p>accumulate: 对指定范围内的元素求和，然后结果再加上一个由val指定的初始值。</p><p>要加上头文件 <code>#include&lt;numeric&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">​          vector&lt;int&gt; vecIntA;</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(1);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(5);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(7);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(9);</span><br><span class="line"></span><br><span class="line">​          int iSum = accumulate(vecIntA.begin(), vecIntA.end(), 100);     //iSum==125</span><br></pre></td></tr></table></figure><h4 id="fill"><a class="markdownIt-Anchor" href="#fill"></a> fill()</h4><p>fill:  将输入值赋给标志范围内的所有元素。</p><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vecIntA;</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(1);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(5);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(7);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(9);</span><br><span class="line">//将vecintA容器中的所有元素都填充为8</span><br><span class="line">​          fill(vecIntA.begin(), vecIntA.end(), 8);       //8, 8, 8, 8, 8</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_accumulate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">2</span>);</span><br><span class="line">v1.push_back(<span class="number">3</span>);</span><br><span class="line">v1.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//accumulate : 将容器中所有元素相加,然后在加上最后一个参数的值,并返回</span></span><br><span class="line"><span class="keyword">int</span> sum = accumulate(v1.begin(),v1.end(),<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将v1所有元素都填充为100</span></span><br><span class="line">fill(v1.begin(),v1.end(),<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v1.begin(); it != v1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test_accumulate();</span><br><span class="line">test_fill();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stl中常用的算术和生成算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stl中常用的算术和生成算法&quot;&gt;&lt;/a&gt; STL中常用的算术和生成算法&lt;/h1&gt;
&lt;h4 id=&quot;accumulate&quot;&gt;&lt;a class=&quot;markdownI
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>常用的拷贝和替换STL算法</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/26/cpp0092-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2STL%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/26/cpp0092-常用的拷贝和替换STL算法/</id>
    <published>2021-07-26T14:23:54.000Z</published>
    <updated>2021-07-26T14:31:44.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的拷贝和替换stl算法"><a class="markdownIt-Anchor" href="#常用的拷贝和替换stl算法"></a> 常用的拷贝和替换STL算法</h1><h4 id="copy"><a class="markdownIt-Anchor" href="#copy"></a> copy()</h4><p>将容器1中的元素拷贝到容器2中</p><p><code>copy(容器1.begin(),容器1.end(),容器2.begin())</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vecIntA;</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(1);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(5);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(7);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(9);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          vector&lt;int&gt; vecIntB;</span><br><span class="line"></span><br><span class="line">​          vecIntB.resize(5);            //扩大空间</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          copy(vecIntA.begin(), vecIntA.end(), vecIntB.begin()); //vecIntB: &#123;1,3,5,7,9&#125;</span><br></pre></td></tr></table></figure><h4 id="replace"><a class="markdownIt-Anchor" href="#replace"></a> replace()</h4><p><code>replace(beg,end,oldValue,newValue)</code>:</p><p>将指定范围内的所有等于oldValue的元素替换成newValue。</p><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     vector&lt;int&gt; vecIntA;</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(1);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(5);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(9);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          replace(vecIntA.begin(), vecIntA.end(), 3, 8);     //&#123;1,8,5,8,9&#125;</span><br></pre></td></tr></table></figure><h4 id="replace_if"><a class="markdownIt-Anchor" href="#replace_if"></a> replace_if()</h4><p><code>replace_if(begin,end,一元谓词,要替换的数字)</code></p><p>replace_if : 将指定范围内所有操作结果为true的元素用新值替换。</p><p>用法举例：</p><p>replace_if(vecIntA.begin(),vecIntA.end(),GreaterThree,newVal)</p><p>其中 vecIntA是用vector&lt;int&gt;声明的容器</p><p>GreaterThree 函数的原型是 bool GreaterThree(int iNum)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//把大于等于3的元素替换成8</span><br><span class="line"></span><br><span class="line">​          vector&lt;int&gt; vecIntA;</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(1);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(5);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(9);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          replace_if(vecIntA.begin(), vecIntA.end(), GreaterThree, 8);     // GreaterThree的定义在上面。</span><br></pre></td></tr></table></figure><h4 id="swap"><a class="markdownIt-Anchor" href="#swap"></a> swap()</h4><p>swap:  交换两个容器的元素</p><p><code>swap(容器1,容器2)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">       vector&lt;int&gt; vecIntA;</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(1);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecIntA.push_back(5);</span><br><span class="line"></span><br><span class="line">​          </span><br><span class="line"></span><br><span class="line">​          vector&lt;int&gt; vecIntB;</span><br><span class="line"></span><br><span class="line">​          vecIntB.push_back(2);</span><br><span class="line"></span><br><span class="line">​          vecIntB.push_back(4);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          swap(vecIntA, vecIntB); //交换</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printV</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">21</span>);</span><br><span class="line">v1.push_back(<span class="number">31</span>);</span><br><span class="line">v1.push_back(<span class="number">41</span>);</span><br><span class="line">v1.push_back(<span class="number">51</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">v2.resize(v1.size());</span><br><span class="line">copy(v1.begin(), v1.end(),v2.begin());</span><br><span class="line"></span><br><span class="line">for_each(v2.begin(),v2.end(),printV);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_replace</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">21</span>);</span><br><span class="line">v1.push_back(<span class="number">31</span>);</span><br><span class="line">v1.push_back(<span class="number">41</span>);</span><br><span class="line">v1.push_back(<span class="number">51</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将v1的所以元素是1的,都替换成5</span></span><br><span class="line">replace(v1.begin(),v1.end(),<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">for_each(v1.begin(),v1.end(),printV);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MyGreate</span><span class="params">(<span class="keyword">int</span> &amp; i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_replaceif</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">21</span>);</span><br><span class="line">v1.push_back(<span class="number">51</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将v1容器中大于等于1的所有元素都替换成5</span></span><br><span class="line">replace_if(v1.begin(),v1.end(), MyGreate,<span class="number">5</span>);</span><br><span class="line">for_each(v1.begin(),v1.end(),printV);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1, v2;</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">3</span>);</span><br><span class="line">v1.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">v2.push_back(<span class="number">2</span>);</span><br><span class="line">v2.push_back(<span class="number">4</span>);</span><br><span class="line">v2.push_back(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换前</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1: "</span>;</span><br><span class="line">for_each(v1.begin(), v1.end(), printV);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">swap(v1, v2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换后</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1: "</span>;</span><br><span class="line">for_each(v1.begin(),v1.end(),printV);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test_copy();</span><br><span class="line">test_replace();</span><br><span class="line">test_replaceif();</span><br><span class="line">test_swap();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用的拷贝和替换stl算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#常用的拷贝和替换stl算法&quot;&gt;&lt;/a&gt; 常用的拷贝和替换STL算法&lt;/h1&gt;
&lt;h4 id=&quot;copy&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot;
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>常用的排序算法</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/25/cpp0091-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/25/cpp0091-常用的排序算法/</id>
    <published>2021-07-24T19:38:28.000Z</published>
    <updated>2021-07-24T21:17:04.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用的排序算法"><a class="markdownIt-Anchor" href="#常用的排序算法"></a> 常用的排序算法</h3><h4 id="merge"><a class="markdownIt-Anchor" href="#merge"></a> merge()</h4><p>以下是排序和通用算法：提供元素排序策略</p><p>merge:  合并两个有序序列，存放到另一个序列。</p><p>例如：vecIntA,vecIntB,vecIntC是用vector&lt;int&gt;声明的容器，vecIntA已包含1,3,5,7,9元素，vecIntB已包含2,4,6,8元素</p><p>vecIntC.resize(9); //扩大容量</p><p>merge(vecIntA.begin(),vecIntA.end(),vecIntB.begin(),vecIntB.end(),vecIntC.begin());</p><p>此时vecIntC就存放了按顺序的1,2,3,4,5,6,7,8,9九个元素</p><h4 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort()</h4><p>sort: 以默认升序的方式重新排列指定范围内的元素。若要改排序规则，可以输入比较函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//学生类</span><br><span class="line"></span><br><span class="line">Class CStudent:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">​    CStudent(int iID, string strName)</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">m_iID=iID; </span><br><span class="line"></span><br><span class="line">m_strName=strName; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:      </span><br><span class="line"></span><br><span class="line">​     int m_iID;</span><br><span class="line"></span><br><span class="line">​     string m_strName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//学号比较函数</span><br><span class="line"></span><br><span class="line">bool Compare(const CStudent &amp;stuA,const CStudent &amp;stuB)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​          return (stuA.m_iID&lt;strB.m_iID);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    vector&lt;CStudent&gt; vecStu;</span><br><span class="line"></span><br><span class="line">​    vecStu.push_back(CStudent(2,&quot;老二&quot;));</span><br><span class="line"></span><br><span class="line">vecStu.push_back(CStudent(1,&quot;老大&quot;));</span><br><span class="line"></span><br><span class="line">vecStu.push_back(CStudent(3,&quot;老三&quot;));</span><br><span class="line"></span><br><span class="line">vecStu.push_back(CStudent(4,&quot;老四&quot;));</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   sort(vecStu.begin(),vecStu.end(),Compare);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">// 此时，vecStu容器包含了按顺序的&quot;老大对象&quot;,&quot;老二对象&quot;,&quot;老三对象&quot;,&quot;老四对象&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="random_shuffle"><a class="markdownIt-Anchor" href="#random_shuffle"></a> random_shuffle()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> random_shuffle:   对指定范围内的元素随机调整次序。</span><br><span class="line"></span><br><span class="line">​          srand(time(0));              //设置随机种子</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          vector&lt;int&gt; vecInt;</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(1);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(5);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(7);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(9);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          string str(&quot;itcastitcast &quot;);</span><br><span class="line"></span><br><span class="line">​     </span><br><span class="line"></span><br><span class="line">​          random_shuffle(vecInt.begin(), vecInt.end());  //随机排序，结果比如：9,7,1,5,3</span><br><span class="line"></span><br><span class="line">​          random_shuffle(str.begin(), str.end());         //随机排序，结果比如：&quot; itstcasticat &quot;</span><br></pre></td></tr></table></figure><h4 id="reverse"><a class="markdownIt-Anchor" href="#reverse"></a> reverse()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">       vector&lt;int&gt; vecInt;</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(1);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(5);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(7);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(9);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          reverse(vecInt.begin(), vecInt.end());        //&#123;9,7,5,3,1&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end() ; it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"============================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_merge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">v1.push_back(<span class="number">0</span>);</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">5</span>);</span><br><span class="line">v1.push_back(<span class="number">60</span>);</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">sort(v1.begin(),v1.end());</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">v2.push_back(<span class="number">2</span>);</span><br><span class="line">v2.push_back(<span class="number">4</span>);</span><br><span class="line">v2.push_back(<span class="number">6</span>);</span><br><span class="line">v2.push_back(<span class="number">8</span>);</span><br><span class="line">sort(v2.begin(), v2.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">v3.resize(v1.size() + v2.size());</span><br><span class="line"></span><br><span class="line">merge(v1.begin(),v1.end(),v2.begin(),v2.end(),v3.begin());</span><br><span class="line"></span><br><span class="line">printV(v3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Student() &#123;</span><br><span class="line">m_name = <span class="string">""</span>;</span><br><span class="line">m_age = <span class="number">0</span>;</span><br><span class="line">m_id = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Student(<span class="built_in">string</span> name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">m_age = age;</span><br><span class="line">m_id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Student &amp; s1, Student &amp; s2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s1.m_id &lt;= s2.m_id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s1.m_id == s2.m_id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> s1.m_age &gt;= s2.m_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"name: "</span> &lt;&lt; m_name &lt;&lt; <span class="string">"\tid: "</span> &lt;&lt; m_id &lt;&lt; <span class="string">"\tage: "</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span>m_name;</span><br><span class="line"><span class="keyword">int</span>m_id;</span><br><span class="line"><span class="keyword">int</span>m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printV2</span><span class="params">(Student &amp; s)</span> </span>&#123;</span><br><span class="line">s.printAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">v1.push_back(<span class="number">0</span>);</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line">v1.push_back(<span class="number">5</span>);</span><br><span class="line">v1.push_back(<span class="number">60</span>);</span><br><span class="line">v1.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">sort(v1.begin(),v1.end());<span class="comment">//默认升序排序</span></span><br><span class="line">printV(v1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt; v2;</span><br><span class="line">v2.push_back(Student(<span class="string">"老大"</span>,<span class="number">1</span>,<span class="number">22</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老大"</span>,<span class="number">1</span>,<span class="number">23</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老二"</span>, <span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老四"</span>, <span class="number">4</span>, <span class="number">18</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老大"</span>,<span class="number">1</span>,<span class="number">22</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老三"</span>, <span class="number">3</span>, <span class="number">19</span>));</span><br><span class="line"></span><br><span class="line">sort(v2.begin(),v2.end(),Student());</span><br><span class="line">for_each(v2.begin(),v2.end(),printV2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_random_shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt; v2;</span><br><span class="line">v2.push_back(Student(<span class="string">"老大"</span>, <span class="number">1</span>, <span class="number">22</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老大"</span>, <span class="number">1</span>, <span class="number">23</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老二"</span>, <span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老四"</span>, <span class="number">4</span>, <span class="number">18</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老大"</span>, <span class="number">1</span>, <span class="number">22</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老三"</span>, <span class="number">3</span>, <span class="number">19</span>));</span><br><span class="line"></span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">random_shuffle(v2.begin(),v2.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v2.begin(), v2.end(), printV2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"1234567"</span>;</span><br><span class="line">random_shuffle(str.begin(), str.end());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt; v2;</span><br><span class="line">v2.push_back(Student(<span class="string">"老大"</span>, <span class="number">1</span>, <span class="number">22</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老大"</span>, <span class="number">1</span>, <span class="number">23</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老二"</span>, <span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老四"</span>, <span class="number">4</span>, <span class="number">18</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老大"</span>, <span class="number">1</span>, <span class="number">22</span>));</span><br><span class="line">v2.push_back(Student(<span class="string">"老三"</span>, <span class="number">3</span>, <span class="number">19</span>));</span><br><span class="line"></span><br><span class="line">sort(v2.begin(), v2.end(), Student());</span><br><span class="line">reverse(v2.begin(), v2.end());</span><br><span class="line">for_each(v2.begin(),v2.end(),printV2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test_merge();</span><br><span class="line">test_sort();</span><br><span class="line">test_random_shuffle();</span><br><span class="line">test_reverse();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;常用的排序算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#常用的排序算法&quot;&gt;&lt;/a&gt; 常用的排序算法&lt;/h3&gt;
&lt;h4 id=&quot;merge&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#merge&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>常用的查找算法</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/25/cpp0090-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/25/cpp0090-常用的查找算法/</id>
    <published>2021-07-24T18:33:46.000Z</published>
    <updated>2021-07-26T14:36:00.025Z</updated>
    
    <content type="html"><![CDATA[<h4 id="adjacent_find"><a class="markdownIt-Anchor" href="#adjacent_find"></a> adjacent_find()</h4><h4 id="binary_search"><a class="markdownIt-Anchor" href="#binary_search"></a> binary_search()</h4><h4 id="binary_search-2"><a class="markdownIt-Anchor" href="#binary_search-2"></a> binary_search()</h4><h4 id="count"><a class="markdownIt-Anchor" href="#count"></a> count()</h4><h4 id="count_if"><a class="markdownIt-Anchor" href="#count_if"></a> count_if()</h4><h4 id="find"><a class="markdownIt-Anchor" href="#find"></a> find()</h4><h4 id="find_if"><a class="markdownIt-Anchor" href="#find_if"></a> find_if()</h4><h4 id="adjacent_find-2"><a class="markdownIt-Anchor" href="#adjacent_find-2"></a> adjacent_find()</h4><p>在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。否则返回past-the-end。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vecInt;</span><br><span class="line"></span><br><span class="line">​     vecInt.push_back(1);</span><br><span class="line"></span><br><span class="line">​     vecInt.push_back(2);</span><br><span class="line"></span><br><span class="line">​     vecInt.push_back(2);</span><br><span class="line"></span><br><span class="line">​     vecInt.push_back(4);</span><br><span class="line"></span><br><span class="line">​     vecInt.push_back(5);</span><br><span class="line"></span><br><span class="line">vecInt.push_back(5);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​     vector&lt;int&gt;::iterator it = adjacent_find(vecInt.begin(), vecInt.end());       //*it == 2</span><br></pre></td></tr></table></figure><h4 id="binary_search-3"><a class="markdownIt-Anchor" href="#binary_search-3"></a> binary_search</h4><p>在有序序列中查找value,找到则返回true。注意：在无序序列中，不可使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">       set&lt;int&gt; setInt;</span><br><span class="line"></span><br><span class="line">​          setInt.insert(3);</span><br><span class="line"></span><br><span class="line">​          setInt.insert(1);</span><br><span class="line"></span><br><span class="line">​          setInt.insert(7);</span><br><span class="line"></span><br><span class="line">​          setInt.insert(5);</span><br><span class="line"></span><br><span class="line">​          setInt.insert(9);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​          bool bFind = binary_search(setInt.begin(),setInt.end(),5);</span><br></pre></td></tr></table></figure><h4 id="count-2"><a class="markdownIt-Anchor" href="#count-2"></a> count()</h4><p>利用等于操作符，把标志范围内的元素与输入值比较，返回相等的个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vecInt;</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(1);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(2);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(2);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(4);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(2);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(5);</span><br><span class="line"></span><br><span class="line">​          int iCount = count(vecInt.begin(),vecInt.end(),2);  //iCount==3</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure><h4 id="count_if-2"><a class="markdownIt-Anchor" href="#count_if-2"></a> count_if()</h4><p>假设vector&lt;int&gt; vecIntA，vecIntA包含1,3,5,7,9元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//先定义比较函数</span><br><span class="line"></span><br><span class="line">bool GreaterThree(int iNum)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​          if(iNum&gt;=3)</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​              return true;</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​          else</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​              return false;</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int iCount = count_if(vecIntA.begin(), vecIntA.end(), GreaterThree);</span><br><span class="line"></span><br><span class="line">//此时iCount == 4</span><br></pre></td></tr></table></figure><h4 id="find-2"><a class="markdownIt-Anchor" href="#find-2"></a> find()</h4><p>find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的迭代器。</p><p>equal_range:  返回一对iterator，第一个表示lower_bound,第二个表示upper_bound。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vecInt;</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(1);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(3);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(5);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(7);</span><br><span class="line"></span><br><span class="line">​          vecInt.push_back(9);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it = find(vecInt.begin(), vecInt.end(), 5);         //*it == 5</span><br></pre></td></tr></table></figure><h4 id="find_if-2"><a class="markdownIt-Anchor" href="#find_if-2"></a> find_if()</h4><p>find_if:  使用输入的函数代替等于操作符执行find。返回被找到的元素的迭代器。</p><p>假设vector&lt;int&gt; vecIntA，vecIntA包含1,3,5,3,9元素</p><p><code>vector&lt;int&gt;::it = find_if(vecInt.begin(),vecInt.end(),GreaterThree);</code></p><p>此时<code>*it==3, *(it+1)==5, *(it+2)==3, *(it+3)==9</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_adjacent_find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">0</span>);</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在iterator对标识元素范围内，</span></span><br><span class="line"><span class="comment">//查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。否则返回past-the-end。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it =  adjacent_find(v.begin(), v.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*it: "</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//distance 返回迭代器it元素在v容器中的位置(索引)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"distance: "</span> &lt;&lt; distance(v.begin(),it) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_binary_search</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">0</span>);</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要先排序</span></span><br><span class="line"><span class="keyword">if</span> (binary_search(v.begin(), v.end(), <span class="number">5</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">0</span>);</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"count: "</span> &lt;&lt; count(v.begin(), v.end(), <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Com</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_countif</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">0</span>);</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"count_if: "</span> &lt;&lt; count_if(v.begin(), v.end(), Com) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_find</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">0</span>);</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(v.begin(),v.end(),<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*it: "</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"distance: "</span> &lt;&lt; distance(v.begin(),it) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_findif</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">0</span>);</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"find_if: "</span> &lt;&lt; *(find_if(v.begin(), v.end(), ComP())) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *argv[], <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test_adjacent_find();</span><br><span class="line">test_binary_search();</span><br><span class="line">test_count();</span><br><span class="line">test_countif();</span><br><span class="line">test_find();</span><br><span class="line">test_findif();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;adjacent_find&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#adjacent_find&quot;&gt;&lt;/a&gt; adjacent_find()&lt;/h4&gt;
&lt;h4 id=&quot;binary_search&quot;&gt;&lt;a class=&quot;markdow
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>foreach和transform算法</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/24/cpp0089-foreach%E5%92%8Ctransform%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/24/cpp0089-foreach和transform算法/</id>
    <published>2021-07-24T15:28:16.000Z</published>
    <updated>2021-07-26T14:32:09.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="foreach和transform算法"><a class="markdownIt-Anchor" href="#foreach和transform算法"></a> foreach和transform算法</h1><h4 id="for_each"><a class="markdownIt-Anchor" href="#for_each"></a> for_each()</h4><p><code>for_each(迭代器起始位置,迭代器结束位置,函数对象或回调函数)</code></p><p>for_each: 用指定函数依次对指定范围内所有元素进行迭代访问。该函数不得修改序列中的元素。</p><p>for_each()会返回一个新的函数对象</p><p>一般情况下：for_each所使用的函数对象，参数是引用，没有返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void show(const int &amp;iItem)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; iItem;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">int iArray[] = &#123;0,1,2,3,4&#125;;</span><br><span class="line">vector&lt;int&gt; vecInt(iArray,iArray+sizeof(iArray)/sizeof(iArray[0]));</span><br><span class="line">    for_each(vecInt.begin(), vecInt.end(), show);</span><br><span class="line"></span><br><span class="line">//结果打印出0 1 2 3 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transform"><a class="markdownIt-Anchor" href="#transform"></a> transform()</h4><p>transform:  与for_each类似，遍历所有元素，但可对容器的元素进行修改</p><p><code>transform(迭代器起始位置,迭代器结束位置,迭代器x起始位置,函数对象或回调函数)</code></p><p>transform所使用的函数对象，参数一般不使用引用，而是还有返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int increase (int i)  </span><br><span class="line">&#123;  </span><br><span class="line">return i+1;   </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; vecIntA;</span><br><span class="line">vecIntA.push_back(1);</span><br><span class="line">vecIntA.push_back(3);</span><br><span class="line">vecIntA.push_back(5);</span><br><span class="line">vecIntA.push_back(7);</span><br><span class="line">vecIntA.push_back(9);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">transform(vecIntA.begin(),vecIntA.end(),vecIntA.begin(),increase);//vecIntA : &#123;2,4,6,8,10&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &quot;string&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &quot;set&quot;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &quot;functional&quot;</span><br><span class="line">#include &quot;iterator&quot;  //输出流迭代器的头文件</span><br><span class="line"></span><br><span class="line">void printV(vector&lt;int&gt; &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it=v.begin(); it!=v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printList(list&lt;int&gt; &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">for (list&lt;int&gt;::iterator it=v.begin(); it!=v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showElem(int &amp;n)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CMyShow</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CMyShow()</span><br><span class="line">&#123;</span><br><span class="line">num = 0;</span><br><span class="line">&#125;</span><br><span class="line">void operator()(int &amp;n)</span><br><span class="line">&#123;</span><br><span class="line">num ++;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">void printNum()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">private:</span><br><span class="line">int num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main41_foreach()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">v1.push_back(1);</span><br><span class="line">v1.push_back(3);</span><br><span class="line">v1.push_back(5);</span><br><span class="line"></span><br><span class="line">printV(v1);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">template&lt;class _InIt,</span><br><span class="line">class _Fn1&gt; inline</span><br><span class="line">_Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)</span><br><span class="line">&#123;// perform function for each element</span><br><span class="line">_DEBUG_RANGE(_First, _Last);</span><br><span class="line">_DEBUG_POINTER(_Func);</span><br><span class="line">return (_For_each(_Unchecked(_First), _Unchecked(_Last), _Func));</span><br><span class="line">&#125; */</span><br><span class="line"></span><br><span class="line">//函数对象 回调函数入口地址</span><br><span class="line">for_each(v1.begin(), v1.end(), showElem);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for_each(v1.begin(), v1.end(), CMyShow());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"> CMyShow mya;</span><br><span class="line"> CMyShow my1 = for_each(v1.begin(), v1.end(),mya); //给my1初始化</span><br><span class="line"> mya.printNum();  //ma1和my1 是两个不同的对象</span><br><span class="line"> my1.printNum();</span><br><span class="line"></span><br><span class="line"> my1 = for_each(v1.begin(), v1.end(),mya);  //给my1赋值</span><br><span class="line"> my1.printNum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int  increase(int i)</span><br><span class="line">&#123;</span><br><span class="line">return i+100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main42_transform()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">v1.push_back(1);</span><br><span class="line">v1.push_back(3);</span><br><span class="line">v1.push_back(5);</span><br><span class="line"></span><br><span class="line">printV(v1);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//transform 使用回调函数</span><br><span class="line">transform(v1.begin(), v1.end(), v1.begin(),  increase ); </span><br><span class="line">printV(v1);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//transform 使用 预定义的函数对象</span><br><span class="line">transform(v1.begin(), v1.end(), v1.begin(),  negate&lt;int&gt;() ); </span><br><span class="line">printV(v1);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//transform 使用 函数适配器 和函数对象</span><br><span class="line">list&lt;int&gt; mylist;</span><br><span class="line">mylist.resize( v1.size() );</span><br><span class="line"></span><br><span class="line">transform(v1.begin(), v1.end(), mylist.begin(),  bind2nd( multiplies&lt;int&gt;(), 10 ) ); </span><br><span class="line">printList(mylist);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//transform 也可以把运算结果 直接输出到屏幕</span><br><span class="line">transform(v1.begin(), v1.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot; ), negate&lt;int&gt;() );</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//一般情况下：for_each所使用的函数对象，参数是引用，没有返回值</span><br><span class="line">//transform所使用的函数对象，参数一般不使用引用，而是还有返回值</span><br><span class="line">int showElem2(int n)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; &quot; &quot;;</span><br><span class="line">return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main43_transform_pk_foreach()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">v1.push_back(1);</span><br><span class="line">v1.push_back(3);</span><br><span class="line">v1.push_back(5);</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v2 = v1;</span><br><span class="line"></span><br><span class="line">for_each(v1.begin(), v1.end(), showElem);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//transform 对 函数对象的要求</span><br><span class="line">/*</span><br><span class="line">c:\program files\microsoft visual studio 10.0\vc\include\algorithm(1119): </span><br><span class="line">参见对正在编译的函数 模板 实例化</span><br><span class="line">“_OutIt std::_Transform1&lt;int*,_OutIt,</span><br><span class="line">void(__cdecl *)(int &amp;)&gt;(_InIt,_InIt,_OutIt,_Fn1,</span><br><span class="line">std::tr1::true_type)”的引用</span><br><span class="line">1&gt;          with</span><br><span class="line">1&gt;          [</span><br><span class="line">1&gt;              _OutIt=std::_Vector_iterator&lt;std::_Vector_val&lt;int,std::allocator&lt;int&gt;&gt;&gt;,</span><br><span class="line">1&gt;              _InIt=int *,</span><br><span class="line">1&gt;              _Fn1=void (__cdecl *)(int &amp;)</span><br><span class="line">1&gt;          ]</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">template&lt;class _InIt,</span><br><span class="line">class _OutIt,</span><br><span class="line">class _Fn1&gt; inline</span><br><span class="line">_OutIt _Transform(_InIt _First, _InIt _Last,</span><br><span class="line">_OutIt _Dest, _Fn1 _Func)</span><br><span class="line">&#123;// transform [_First, _Last) with _Func</span><br><span class="line">for (; _First != _Last; ++_First, ++_Dest)</span><br><span class="line">*_Dest = _Func(*_First);  //解释了 为什么 要有返回值</span><br><span class="line">return (_Dest);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">transform(v2.begin(), v2.end(), v2.begin(), showElem2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">//main41_foreach();</span><br><span class="line">//main42_transform();</span><br><span class="line">// main43_transform_pk_foreach();</span><br><span class="line">cout&lt;&lt;&quot;hello...&quot;&lt;&lt;endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;foreach和transform算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#foreach和transform算法&quot;&gt;&lt;/a&gt; foreach和transform算法&lt;/h1&gt;
&lt;h4 id=&quot;for_each&quot;&gt;&lt;a cla
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>23-30</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/15/hbnx003-23-30/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/15/hbnx003-23-30/</id>
    <published>2021-07-15T15:33:34.000Z</published>
    <updated>2021-07-26T16:57:37.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 知识点：</h2><p>CALL框架</p><p>EBP寄存器 栈底指针</p><p>ESP寄存器 栈顶指针</p><p><strong>一、EBP栈底指针</strong></p><p>EBP是一个特殊的寄存器，通过EBP+偏移量 可以访问CALL里边的局部变量。它的低16位叫BP。//EAX和AX的关系</p><p><strong>二、ESP栈顶指针</strong></p><p>ESP栈顶指针与EBP构成的一段空间大小，一般就是本CALL局部变量的空间大小总和。ESP指针配合EBP使用。//SP</p><p>三、代码分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void fun1(void)</span><br><span class="line"></span><br><span class="line">&#123;    //0401000 /$ 55      PUSH EBP //保存栈环境或者叫保存EBP指针</span><br><span class="line"></span><br><span class="line">​     //0401001 |. 8BEC     MOV EBP,ESP</span><br><span class="line"></span><br><span class="line">​     //0401003 |. 5D      POP EBP //恢复EBP指针</span><br><span class="line"></span><br><span class="line">​     //0401004 \. C3      RETN</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun2(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​     int a;</span><br><span class="line"></span><br><span class="line">​     int b=5;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun3(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​     fun2();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>1、每个CALL会分配一个独立的栈段空间，供局部变量使用.</p><p>栈段空间大小一般要大于局部变量所需空间大小之和 ebp-esp=栈段空间大小。</p><p>2、CALL栈平衡。进CALL前与出CALL后 EBP和ESP的值不变。</p><h2 id="知识点-2"><a class="markdownIt-Anchor" href="#知识点-2"></a> 知识点：</h2><p><strong>PUSH</strong></p><p><strong>POP</strong></p><p><strong>CALL堆栈平衡</strong></p><p>RETN指令</p><p><strong>一、PUSH入栈指令  (压栈指令):</strong></p><p>格式: <code>PUSH 操作数</code></p><p>//sub esp,4 ;mov [esp],EBP</p><p>操作数可以是寄存器，存储器，或者立即数</p><p><strong>二、POP出栈指令 （弹栈指令)</strong></p><p>格式：<code>POP 操作数</code></p><p>//mov EBP,[esp] ;add esp,4</p><p>操作数是寄存器，或者存储器，不能是立即数</p><p><strong>三、代码分析</strong></p><p>1、测试PUSH和POP 与ESP栈顶指针的关系</p><p>2、CALL与ESP的关系</p><p>3、总结栈的特点(后进先出)</p><p><strong>[EBP-??] //</strong> <strong>局部变量</strong></p><p><strong>[ EBP+??] //上一个CALL 局部变量，上一个CALL传入参数</strong></p><p><strong>CALL  PUSH EIP</strong></p><p><strong>RETN  POP  EIP</strong></p><h2 id="知识点-3"><a class="markdownIt-Anchor" href="#知识点-3"></a> 知识点：</h2><p><strong>cdecl</strong> <strong>函数调用约定</strong></p><p><strong>stdcall</strong> <strong>函数调用约定</strong></p><p><strong>CALL堆栈平衡</strong></p><p><strong>配置属性–&gt; c/c++ --&gt;高级–&gt;调用约定</strong></p><p><strong>一、cdecl调用约定</strong></p><p><code>VC++默认约定__cdecl</code></p><p>1、源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl add1(int a,int b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​     return a+b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、生成汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00401000 /$ 55      PUSH EBP</span><br><span class="line"></span><br><span class="line">00401001 |. 8BEC      MOV EBP,ESP</span><br><span class="line"></span><br><span class="line">00401003 |. 8B45 08    MOV EAX,DWORD PTR SS:[EBP+8]</span><br><span class="line"></span><br><span class="line">00401006 |. 0345 0C    ADD EAX,DWORD PTR SS:[EBP+C]</span><br><span class="line"></span><br><span class="line">00401009 |. 5D      POP EBP</span><br><span class="line"></span><br><span class="line">0040100A \. C3      RETN                   ; POP EIP</span><br></pre></td></tr></table></figure><p>3、调用代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">push b</span><br><span class="line"></span><br><span class="line">push a</span><br><span class="line"></span><br><span class="line">call add1</span><br><span class="line"></span><br><span class="line">add esp,8</span><br><span class="line"></span><br><span class="line">00401031 |. 6A 02     PUSH 2                  ; 0012FF7C</span><br><span class="line"></span><br><span class="line">00401033 |. 6A 01     PUSH 1</span><br><span class="line"></span><br><span class="line">00401035 |. E8 C6FFFFFF  CALL stdcall_.00401000          ; __cdecl add1</span><br><span class="line"></span><br><span class="line">0040103A |. 83C4 08    ADD ESP,8                ; RETN 8</span><br></pre></td></tr></table></figure><p><strong>二、stdcall调用约定</strong></p><p><code>API函数约定 __stdcall</code></p><p>1、源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> int __stdcall add2(int a,int b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​     return a+b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、生成汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00401010 /$ 55      PUSH EBP</span><br><span class="line"></span><br><span class="line">00401011 |. 8BEC     MOV EBP,ESP</span><br><span class="line"></span><br><span class="line">00401013 |. 8B45 08    MOV EAX,DWORD PTR SS:[EBP+8]</span><br><span class="line"></span><br><span class="line">00401016 |. 0345 0C    ADD EAX,DWORD PTR SS:[EBP+C]</span><br><span class="line"></span><br><span class="line">00401019 |. 5D      POP EBP</span><br><span class="line"></span><br><span class="line">0040101A \. C2 0800    RETN 8                  ; RETN 8  //ADD ESP,8</span><br></pre></td></tr></table></figure><p>3、调用代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">push b</span><br><span class="line"></span><br><span class="line">push a</span><br><span class="line"></span><br><span class="line">call add2</span><br><span class="line"></span><br><span class="line">0040103D |. 6A 04     PUSH 4                  ; 0012FF7C</span><br><span class="line"></span><br><span class="line">0040103F |. 6A 03     PUSH 3</span><br><span class="line"></span><br><span class="line">00401041 |. E8 CAFFFFFF  CALL stdcall_.00401010          ; __stdcall add2 PUSH 下一个EIP</span><br></pre></td></tr></table></figure><h2 id="知识点-4"><a class="markdownIt-Anchor" href="#知识点-4"></a> 知识点：</h2><p><strong>fastcall</strong> <strong>函数调用约定</strong></p><p><strong>CALL堆栈平衡</strong></p><p><strong>三、__fastcall</strong> <strong>函数调用约定</strong></p><p>直接用寄存器传递参数，由于寄存器相对于栈(存储器)速度要快上许多，所以这类的调用约定叫fastcall</p><p>1、源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> int __fastcall add2(int a,int b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​     return a+b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">00401020 /$ 55      PUSH EBP</span><br><span class="line"></span><br><span class="line">00401021 |. 8BEC     MOV EBP,ESP</span><br><span class="line"></span><br><span class="line">00401023 |. 83EC 08    SUB ESP,8                  ; int a,b;</span><br><span class="line"></span><br><span class="line">00401026 |. 8955 F8    MOV DWORD PTR SS:[EBP-8],EDX       ; b=edx</span><br><span class="line"></span><br><span class="line">00401029 |. 894D FC    MOV DWORD PTR SS:[EBP-4],ECX       ; a=ecx</span><br><span class="line"></span><br><span class="line">0040102C |. 8B45 FC    MOV EAX,DWORD PTR SS:[EBP-4]</span><br><span class="line"></span><br><span class="line">0040102F |. 0345 F8    ADD EAX,DWORD PTR SS:[EBP-8]</span><br><span class="line"></span><br><span class="line">00401032 |. 8BE5     MOV ESP,EBP                ; add esp,8</span><br><span class="line"></span><br><span class="line">00401034 |. 5D      POP EBP</span><br><span class="line"></span><br><span class="line">00401035 \. C3      RETN</span><br></pre></td></tr></table></figure><p>3、调用代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401096 |. BA 02000000  MOV EDX,2</span><br><span class="line"></span><br><span class="line">0040109B |. B9 01000000  MOV ECX,1</span><br><span class="line"></span><br><span class="line">004010A0 |. E8 7BFFFFFF  CALL fastcall.00401020          ; 3</span><br></pre></td></tr></table></figure><p>一般超过两个参数,就会使用栈来存储其他参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall add4(int a, int b,int c,int d,int e) &#123;</span><br><span class="line"></span><br><span class="line">return a + b + c + d + e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00F4112B   .  6A 05         push 0x5                                 ;  002FF838</span><br><span class="line">00F4112D   .  6A 04         push 0x4</span><br><span class="line">00F4112F   .  6A 03         push 0x3</span><br><span class="line">00F41131   .  BA 02000000   mov edx,0x2</span><br><span class="line">00F41136      B9            db B9</span><br><span class="line">00F41137      01            db 01</span><br><span class="line">00F41138      00            db 00</span><br><span class="line">00F41139      00            db 00</span><br><span class="line">00F4113A &gt;    00            db 00                                    ;  002FF838</span><br><span class="line">00F4113B   .  E8 80FFFFFF   call ConsoleA.00F410C0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00F410C0  /$  55            push ebp</span><br><span class="line">00F410C1  |.  8BEC          mov ebp,esp</span><br><span class="line">00F410C3  |.  83EC 08       sub esp,0x8</span><br><span class="line">00F410C6  |.  8955 F8       mov [local.2],edx</span><br><span class="line">00F410C9  |.  894D FC       mov [local.1],ecx</span><br><span class="line">00F410CC  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00F410CF  |.  0345 F8       add eax,[local.2]</span><br><span class="line">00F410D2  |.  0345 08       add eax,[arg.1]</span><br><span class="line">00F410D5  |.  0345 0C       add eax,[arg.2]</span><br><span class="line">00F410D8  |.  0345 10       add eax,[arg.3]</span><br><span class="line">00F410DB  |.  8BE5          mov esp,ebp</span><br><span class="line">00F410DD  |.  5D            pop ebp</span><br><span class="line">00F410DE  \.  C2 0C00       retn 0xC</span><br></pre></td></tr></table></figure><h2 id="知识点-5"><a class="markdownIt-Anchor" href="#知识点-5"></a> 知识点：</h2><p><strong>if else</strong></p><p><strong>逆向还原代码</strong></p><p><strong>一、了解if else结构</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sub esp,8</span><br><span class="line"></span><br><span class="line">00401029 |. 8B45 FC    MOV EAX,DWORD PTR SS:[EBP-4]</span><br><span class="line"></span><br><span class="line">0040102C |. 3B45 F8    CMP EAX,DWORD PTR SS:[EBP-8]</span><br><span class="line"></span><br><span class="line">0040102F |. 7E 10     JLE SHORT ifelse01.00401041 //表示 else部分的开始</span><br><span class="line"></span><br><span class="line">00401031 |. 68 FC204000  PUSH ifelse01.004020FC          ; /format = &quot;a&gt;b&quot;</span><br><span class="line"></span><br><span class="line">00401036 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]  ; \printf</span><br><span class="line"></span><br><span class="line">0040103C |. 83C4 04    ADD ESP,4</span><br><span class="line"></span><br><span class="line">0040103F |. EB 0E    JMP SHORT ifelse01.0040104F //结合前边的 jle 401041 判断是否有else部分</span><br><span class="line"></span><br><span class="line">00401041 |&gt; 68 00214000  PUSH ifelse01.00402100          ; /format = &quot;b&gt;=a&quot;</span><br><span class="line"></span><br><span class="line">00401046 |. FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]  ; \printf</span><br><span class="line"></span><br><span class="line">0040104C |. 83C4 04    ADD ESP,4</span><br></pre></td></tr></table></figure><p><strong>二、逆向还原代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> int a,b,c;</span><br><span class="line">//00401006  |.  68 F4204000   PUSH ifelse01.004020F4                   ; /format = &quot;begin&quot;</span><br><span class="line">//0040100B  |.  FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]    ; \printf</span><br><span class="line">//00401011  |.  83C4 04       ADD ESP,4</span><br><span class="line"> printf(&quot;begin&quot;);</span><br><span class="line">//00401014  |.  C745 FC 01000&gt;MOV DWORD PTR SS:[EBP-4],1</span><br><span class="line">//0040101B  |.  C745 F8 02000&gt;MOV DWORD PTR SS:[EBP-8],2</span><br><span class="line">//00401022  |.  C745 F4 03000&gt;MOV DWORD PTR SS:[EBP-C],3 a=1,b=2,c=3;</span><br><span class="line">//00401029  |.  8B45 FC       MOV EAX,DWORD PTR SS:[EBP-4]</span><br><span class="line">//0040102C  |.  3B45 F8       CMP EAX,DWORD PTR SS:[EBP-8]</span><br><span class="line">//0040102F  |.  7E 10         JLE SHORT ifelse01.00401041</span><br><span class="line">if (a&gt;b)</span><br><span class="line">&#123;//00401031  |.  68 FC204000   PUSH ifelse01.004020FC                   ; /format = &quot;a&gt;b&quot;</span><br><span class="line">//00401036  |.  FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]    ; \printf</span><br><span class="line">//0040103C  |.  83C4 04       ADD ESP,4</span><br><span class="line">//0040103F  |.  EB 0E         JMP SHORT ifelse01.0040104F</span><br><span class="line">printf(&quot;a&gt;b&quot;);</span><br><span class="line">&#125;else</span><br><span class="line">&#123;//00401041  |&gt;  68 00214000   PUSH ifelse01.00402100                   ; /format = &quot;b&gt;=a&quot;</span><br><span class="line">//00401046  |.  FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]    ; \printf</span><br><span class="line">//0040104C  |.  83C4 04       ADD ESP,4</span><br><span class="line">   printf(&quot;b&gt;=a&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//0040104F  |&gt; \8B4D F4       MOV ECX,DWORD PTR SS:[EBP-C]             ;  c</span><br><span class="line">//00401052  |.  3B4D F8       CMP ECX,DWORD PTR SS:[EBP-8]             ;  b</span><br><span class="line">//00401055  |.  7E 46         JLE SHORT ifelse01.0040109D              ;  if (c&gt;b)</span><br><span class="line">if (c&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">//00401057  |.  8B55 F4       MOV EDX,DWORD PTR SS:[EBP-C] c</span><br><span class="line">//0040105A  |.  3B55 FC       CMP EDX,DWORD PTR SS:[EBP-4] a</span><br><span class="line">//0040105D  |.  7E 20         JLE SHORT ifelse01.0040107F</span><br><span class="line">if (c&gt;a)</span><br><span class="line">&#123;</span><br><span class="line">//0040105F  |.  8B45 FC       MOV EAX,DWORD PTR SS:[EBP-4]</span><br><span class="line">//00401062  |.  50            PUSH EAX                                 ; /&lt;%d&gt;</span><br><span class="line">//00401063  |.  8B4D F4       MOV ECX,DWORD PTR SS:[EBP-C]             ; |</span><br><span class="line">//00401066  |.  51            PUSH ECX                                 ; |&lt;%d&gt;</span><br><span class="line">//00401067  |.  8B55 F8       MOV EDX,DWORD PTR SS:[EBP-8]             ; |</span><br><span class="line">//0040106A  |.  52            PUSH EDX                                 ; |&lt;%d&gt;</span><br><span class="line">//0040106B  |.  8B45 F4       MOV EAX,DWORD PTR SS:[EBP-C]             ; |</span><br><span class="line">//0040106E  |.  50            PUSH EAX                                 ; |&lt;%d&gt;</span><br><span class="line">//0040106F  |.  68 08214000   PUSH ifelse01.00402108                   ; |format = &quot;%d&gt;%d,%d&gt;%d&quot;</span><br><span class="line">//00401074  |.  FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]    ; \printf</span><br><span class="line">//0040107A  |.  83C4 14       ADD ESP,14</span><br><span class="line">printf(&quot;%d&gt;%d,%d&gt;%d&quot;,c,b,c,a);</span><br><span class="line">//0040107D  |.  EB 1E         JMP SHORT ifelse01.0040109D</span><br><span class="line">&#125;else</span><br><span class="line">&#123;</span><br><span class="line">//0040107F  |&gt;  8B4D FC       MOV ECX,DWORD PTR SS:[EBP-4]</span><br><span class="line">//00401082  |.  51            PUSH ECX                                 ; /&lt;%d&gt;</span><br><span class="line">//00401083  |.  8B55 F4       MOV EDX,DWORD PTR SS:[EBP-C]             ; |</span><br><span class="line">//00401086  |.  52            PUSH EDX                                 ; |&lt;%d&gt;</span><br><span class="line">//00401087  |.  8B45 F8       MOV EAX,DWORD PTR SS:[EBP-8]             ; |</span><br><span class="line">//0040108A  |.  50            PUSH EAX                                 ; |&lt;%d&gt;</span><br><span class="line">//0040108B  |.  8B4D F4       MOV ECX,DWORD PTR SS:[EBP-C]             ; |</span><br><span class="line">//0040108E  |.  51            PUSH ECX                                 ; |&lt;%d&gt;</span><br><span class="line">//0040108F  |.  68 14214000   PUSH ifelse01.00402114                   ; |format = &quot;%d&gt;%d,%d&lt;=%d&quot;</span><br><span class="line">//00401094  |.  FF15 A0204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]    ; \printf</span><br><span class="line">//0040109A  |.  83C4 14       ADD ESP,14</span><br><span class="line">printf(&quot;%d&gt;%d,%d&lt;=%d&quot;,c,b,c,a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//0040109D  |&gt;  33C0          XOR EAX,EAX</span><br></pre></td></tr></table></figure><h2 id="知识点-6"><a class="markdownIt-Anchor" href="#知识点-6"></a> 知识点：</h2><p><strong>switch case生成的汇编框架</strong></p><p><strong>逆向汇编代码还原成C++代码</strong></p><p><strong>一、了解switch case结构</strong></p><p><strong>1、普通情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">00401011 |. 83C4 04    ADD ESP,4</span><br><span class="line"></span><br><span class="line">00401014 |. C745 FC 20000&gt;MOV DWORD PTR SS:[EBP-4],20       ; a=20;</span><br><span class="line"></span><br><span class="line">0040101B |. 8B45 FC    MOV EAX,DWORD PTR SS:[EBP-4]</span><br><span class="line"></span><br><span class="line">0040101E |. 8945 F8    MOV DWORD PTR SS:[EBP-8],EAX       ; switch (a)</span><br><span class="line"></span><br><span class="line">00401021 |. 837D F8 03  CMP DWORD PTR SS:[EBP-8],3        ; case 3:</span><br><span class="line"></span><br><span class="line">00401025 |. 74 0E     JE SHORT switchCa.00401035</span><br><span class="line"></span><br><span class="line">00401027 |. 837D F8 04  CMP DWORD PTR SS:[EBP-8],4        ; case 4:</span><br><span class="line"></span><br><span class="line">0040102B |. 74 28     JE SHORT switchCa.00401055</span><br><span class="line"></span><br><span class="line">0040102D |. 837D F8 05  CMP DWORD PTR SS:[EBP-8],5        ; case 5:</span><br><span class="line"></span><br><span class="line">00401031 |. 74 12     JE SHORT switchCa.00401045</span><br><span class="line"></span><br><span class="line">00401033 |. EB 30     JMP SHORT switchCa.00401065       ; default:</span><br></pre></td></tr></table></figure><p><strong>2、跳转表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">00401014 |. C745 FC 20000&gt;MOV DWORD PTR SS:[EBP-4],20       ; a=20;</span><br><span class="line"></span><br><span class="line">0040101B |. 8B45 FC    MOV EAX,DWORD PTR SS:[EBP-4]</span><br><span class="line"></span><br><span class="line">0040101E |. 8945 F8    MOV DWORD PTR SS:[EBP-8],EAX       ; b=a</span><br><span class="line"></span><br><span class="line">00401021 |. 8B4D F8    MOV ECX,DWORD PTR SS:[EBP-8]       ; b==1</span><br><span class="line"></span><br><span class="line">00401024 |. 83E9 03    SUB ECX,3                ; a-0x3=跳转表数组大小  ecx = a - 最小case值</span><br><span class="line"></span><br><span class="line">00401027 |. 894D F8    MOV DWORD PTR SS:[EBP-8],ECX</span><br><span class="line"></span><br><span class="line">0040102A |. 837D F8 0E  CMP DWORD PTR SS:[EBP-8],0E       ; 0E=case最大常量-case最小常量</span><br><span class="line"></span><br><span class="line">0040102E |. 77 61     JA SHORT switchCa.00401091        ; default:</span><br><span class="line"></span><br><span class="line">00401030 |. 8B55 F8    MOV EDX,DWORD PTR SS:[EBP-8]   ;edx == local.1 == ecx ==  a - case最小值</span><br><span class="line"></span><br><span class="line">00401033 |. 0FB682 CC1040&gt;MOVZX EAX,BYTE PTR DS:[EDX+4010CC]    ; 跳转表的索引数组</span><br><span class="line"></span><br><span class="line">0040103A |&gt; FF2485 B41040&gt;JMP DWORD PTR DS:[EAX*4+4010B4]     ; /跳转表</span><br></pre></td></tr></table></figure><p><strong>二、逆向还原代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">//00401003 |. 83EC 08    SUB ESP,8                ; int a,b</span><br><span class="line"></span><br><span class="line">//00401006 |. 68 F4204000  PUSH switchCa.004020F4          ; /format = &quot;begin\n&quot;</span><br><span class="line"></span><br><span class="line">//0040100B |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]  ; \printf</span><br><span class="line"></span><br><span class="line">//00401011 |. 83C4 04    ADD ESP,4                ; a=20</span><br><span class="line"></span><br><span class="line">//00401014 |. C745 FC 20000&gt;MOV DWORD PTR SS:[EBP-4],20       ; switch (a)</span><br><span class="line"></span><br><span class="line">//0040101B |. 8B45 FC    MOV EAX,DWORD PTR SS:[EBP-4]</span><br><span class="line"></span><br><span class="line">//0040101E |. 8945 F8    MOV DWORD PTR SS:[EBP-8],EAX</span><br><span class="line"></span><br><span class="line">//00401021 |. 8B4D F8    MOV ECX,DWORD PTR SS:[EBP-8]</span><br><span class="line"></span><br><span class="line">//00401024 |. 83E9 09    SUB ECX,9                ; 23</span><br><span class="line"></span><br><span class="line">//00401027 |. 894D F8    MOV DWORD PTR SS:[EBP-8],ECX</span><br><span class="line"></span><br><span class="line">//0040102A |. 837D F8 08  CMP DWORD PTR SS:[EBP-8],8        ; 9..17</span><br><span class="line"></span><br><span class="line">//0040102E |. 77 4A     JA SHORT switchCa.0040107A        ; 9,11,15,16,17</span><br><span class="line"></span><br><span class="line">//00401030 |. 8B55 F8    MOV EDX,DWORD PTR SS:[EBP-8]</span><br><span class="line"></span><br><span class="line">//00401033 |. FF2495 9C1040&gt;JMP DWORD PTR DS:[EDX*4+40109C]     ; 跳转表</span><br><span class="line"></span><br><span class="line">//0040103A |&gt; 68 FC204000  PUSH switchCa.004020FC          ; /format = &quot;aaa&quot;</span><br><span class="line"></span><br><span class="line">//0040103F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]  ; \printf</span><br><span class="line"></span><br><span class="line">//00401045 |. 83C4 04    ADD ESP,4</span><br><span class="line"></span><br><span class="line">//00401048 |. EB 3E     JMP SHORT switchCa.00401088</span><br><span class="line"></span><br><span class="line">//0040104A |&gt; 68 00214000  PUSH switchCa.00402100          ; /format = &quot;aaaa&quot;</span><br><span class="line"></span><br><span class="line">//0040104F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]  ; \printf</span><br><span class="line"></span><br><span class="line">//00401055 |. 83C4 04    ADD ESP,4</span><br><span class="line"></span><br><span class="line">//00401058 |. EB 2E     JMP SHORT switchCa.00401088</span><br><span class="line"></span><br><span class="line">//0040105A |&gt; 68 08214000  PUSH switchCa.00402108          ; /format = &quot;bbbb&quot;</span><br><span class="line"></span><br><span class="line">//0040105F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]  ; \printf</span><br><span class="line"></span><br><span class="line">//00401065 |. 83C4 04    ADD ESP,4</span><br><span class="line"></span><br><span class="line">//00401068 |. EB 1E     JMP SHORT switchCa.00401088</span><br><span class="line"></span><br><span class="line">//0040106A |&gt; 68 10214000  PUSH switchCa.00402110          ; /format = &quot;xxxx&quot;</span><br><span class="line"></span><br><span class="line">//0040106F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]  ; \printf</span><br><span class="line"></span><br><span class="line">//00401075 |. 83C4 04    ADD ESP,4</span><br><span class="line"></span><br><span class="line">//00401078 |. EB 0E     JMP SHORT switchCa.00401088</span><br><span class="line"></span><br><span class="line">//0040107A |&gt; 68 18214000  PUSH switchCa.00402118          ; /format = &quot;3333&quot;</span><br><span class="line"></span><br><span class="line">//0040107F |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]  ; \printf //Default</span><br><span class="line"></span><br><span class="line">//00401085 |. 83C4 04    ADD ESP,4</span><br><span class="line"></span><br><span class="line">//00401088 |&gt; 68 20214000  PUSH switchCa.00402120          ; /command = &quot;pause&quot;</span><br><span class="line"></span><br><span class="line">//0040108D |. FF15 9C204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.system&gt;]  ; \system</span><br><span class="line"></span><br><span class="line">//00401093 |. 83C4 04    ADD ESP,4</span><br><span class="line"></span><br><span class="line">​     printf(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">​     int a=0x20;</span><br><span class="line"></span><br><span class="line">​     switch(a)</span><br><span class="line"></span><br><span class="line">​     &#123;    </span><br><span class="line"></span><br><span class="line">​     case 11:</span><br><span class="line"></span><br><span class="line">​          printf(&quot;aaa&quot;);</span><br><span class="line"></span><br><span class="line">​          break;</span><br><span class="line"></span><br><span class="line">​     case 15:</span><br><span class="line"></span><br><span class="line">​          printf(&quot;aaaa&quot;);</span><br><span class="line"></span><br><span class="line">​          break;</span><br><span class="line"></span><br><span class="line">​     case 17:</span><br><span class="line"></span><br><span class="line">​          printf(&quot;bbbb&quot;);</span><br><span class="line"></span><br><span class="line">​          break;</span><br><span class="line"></span><br><span class="line">​     case 9:</span><br><span class="line"></span><br><span class="line">​          printf(&quot;xxxx&quot;);</span><br><span class="line"></span><br><span class="line">​          break;          </span><br><span class="line"></span><br><span class="line">​     default:</span><br><span class="line"></span><br><span class="line">​          printf(&quot;3333&quot;);</span><br><span class="line"></span><br><span class="line">​          break;</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br></pre></td></tr></table></figure><hr>## 知识点：<p><strong>入口函数main的定位</strong></p><p><strong>逆向汇编代码还原成C++代码</strong></p><p><strong>索引表数组</strong></p><p><strong>跳转表</strong></p><h3 id="设置程序的入口基址"><a class="markdownIt-Anchor" href="#设置程序的入口基址"></a> 设置程序的入口基址</h3><p>最少要大于等于<code>0x10000</code></p><p><img src="/images/javawz/1627315281528.png" alt="1627315281528"></p><h3 id="找入口main函数"><a class="markdownIt-Anchor" href="#找入口main函数"></a> 找入口main函数</h3><p><img src="/images/javawz/1627318463657.png" alt="1627318463657"></p><p><img src="/images/javawz/1627318492662.png" alt="1627318492662"></p><p>双击进入就是main函数的入口位置了</p><p><strong>一、索引表及跳转表分析</strong></p><p>1、确定case常量</p><p>18,20,28,32</p><p>2、确定case常量顺序 (可以根据 跳转表 调整也可以)</p><p><strong>000210AC 00021063  30.00021063 18</strong></p><p><strong>000210B0 00021053 30.00021053  20</strong></p><p><strong>000210B4 00021048 30.00021048  28</strong></p><p><strong>000210B8 00021089 30.00021089 32</strong></p><p>**// 调整后实际上就是按地址大小排序 **</p><p><strong>000210B4 00021048 30.00021048  28</strong></p><p><strong>000210B0 00021053 30.00021053  20</strong></p><p><strong>000210AC 00021063  30.00021063 18</strong></p><p><strong>000210B8 00021089 30.00021089  32</strong></p><p><strong>二、还原代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">​     int a,b; a=0x16;     b=3;</span><br><span class="line"></span><br><span class="line">​     switch(a)</span><br><span class="line"></span><br><span class="line">​     &#123;</span><br><span class="line"></span><br><span class="line">​     case 28:</span><br><span class="line"></span><br><span class="line">​          b=b+a;</span><br><span class="line"></span><br><span class="line">​          break;</span><br><span class="line"></span><br><span class="line">​     case 20:</span><br><span class="line"></span><br><span class="line">​          printf(&quot;123&quot;);</span><br><span class="line"></span><br><span class="line">​          break;</span><br><span class="line"></span><br><span class="line">​          //18,20,28,32</span><br><span class="line"></span><br><span class="line">​     case 18:</span><br><span class="line"></span><br><span class="line">​          if (b&gt;9)</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​               printf(&quot;3333&quot;);</span><br><span class="line"></span><br><span class="line">​          &#125;else</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​               printf(&quot;2222&quot;);</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​          break;     </span><br><span class="line"></span><br><span class="line">​     case 32:</span><br><span class="line"></span><br><span class="line">​          printf(&quot;321&quot;);</span><br><span class="line"></span><br><span class="line">​          //break;</span><br><span class="line"></span><br><span class="line">​     default:</span><br><span class="line"></span><br><span class="line">​          printf(&quot;00end&quot;);</span><br><span class="line"></span><br><span class="line">​          break;</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">​     //end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;知识点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#知识点&quot;&gt;&lt;/a&gt; 知识点：&lt;/h2&gt;
&lt;p&gt;CALL框架&lt;/p&gt;
&lt;p&gt;EBP寄存器 栈底指针&lt;/p&gt;
&lt;p&gt;ESP寄存器 栈顶指针&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、EBP栈底指
      
    
    </summary>
    
      <category term="汇编逆向" scheme="https://xiaowuyoucy.github.io/categories/%E6%B1%87%E7%BC%96%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>13-22</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/14/hbnx002-13-22/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/14/hbnx002-13-22/</id>
    <published>2021-07-14T14:57:46.000Z</published>
    <updated>2021-07-16T19:38:51.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 知识点：</h2><p><strong>条件转移指令JNE/JNZ</strong></p><p><strong>ZF（零标志）</strong></p><p><strong>不等于转移指令 JNE/JNZ (等于JE/JZ)</strong></p><p>1、 <strong>JNE/JNZ功能</strong></p><p>条件转移指令JNE/JNZ //不等于转移</p><p><code>格式: JNE/JNZ 标号</code></p><p>功能: ZF＝0,转至标号地址处执行</p><p>2、代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> printf(&quot;begin\n&quot;);</span><br><span class="line"></span><br><span class="line">​     int a=4;</span><br><span class="line"></span><br><span class="line">​     //if (a==3) //ZF=0</span><br><span class="line"></span><br><span class="line">​     //&#123;</span><br><span class="line"></span><br><span class="line">​     //    printf(&quot;未跳转ZF==1\n&quot;);</span><br><span class="line"></span><br><span class="line">​     //&#125;</span><br><span class="line"></span><br><span class="line">​     //printf(&quot;ZF==0跳转\n&quot;);</span><br><span class="line"></span><br><span class="line">​     __asm</span><br><span class="line"></span><br><span class="line">​     &#123;   mov eax,3</span><br><span class="line"></span><br><span class="line">​      sub eax,a //3-4</span><br><span class="line"></span><br><span class="line">​      jz end; //ZF=1</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">​     printf(&quot;未跳转\n&quot;);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line"></span><br><span class="line">​     printf(&quot;跳转\n&quot;);</span><br><span class="line"></span><br><span class="line">​     printf(&quot;end\n&quot;);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line"></span><br><span class="line">00401004 |. 68 F4204000  PUSH JNE_JNZ.004020F4          ; /format = &quot;begin\n&quot;</span><br><span class="line"></span><br><span class="line">00401009 |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]  ; \printf</span><br><span class="line"></span><br><span class="line">0040100F |. 83C4 04    ADD ESP,4</span><br><span class="line"></span><br><span class="line">00401012 |. C745 FC 04000&gt;MOV DWORD PTR SS:[EBP-4],4        ; a=4</span><br><span class="line"></span><br><span class="line">00401019 |. B8 03000000  MOV EAX,3                ; eax=3</span><br><span class="line"></span><br><span class="line">0040101E |. 2B45 FC    SUB EAX,DWORD PTR SS:[EBP-4]       ; 3-4 cmp eax,[ebp-4]</span><br><span class="line"></span><br><span class="line">00401021 |. 74 0E     JE SHORT JNE_JNZ.00401031</span><br><span class="line"></span><br><span class="line">00401023 |. 68 FC204000  PUSH JNE_JNZ.004020FC          ; /format = &quot;未跳转&quot;</span><br><span class="line"></span><br><span class="line">00401028 |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]  ; \printf</span><br><span class="line"></span><br><span class="line">0040102E |. 83C4 04    ADD ESP,4</span><br><span class="line"></span><br><span class="line">00401031 |&gt; 68 04214000  PUSH JNE_JNZ.00402104          ; /format = &quot;跳转&quot;</span><br><span class="line"></span><br><span class="line">00401036 |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]  ; \printf</span><br><span class="line"></span><br><span class="line">0040103C |. 83C4 04    ADD ESP,4</span><br><span class="line"></span><br><span class="line">0040103F |. 68 0C214000  PUSH JNE_JNZ.0040210C          ; /format = &quot;end\n&quot;</span><br><span class="line"></span><br><span class="line">00401044 |. FF15 A4204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.printf&gt;]  ; \printf</span><br><span class="line"></span><br><span class="line">0040104A |. 83C4 04    ADD ESP,4</span><br><span class="line"></span><br><span class="line">0040104D |. FF15 9C204000 CALL DWORD PTR DS:[&lt;&amp;MSVCR90.getchar&gt;]  ; MSVCR90.getchar</span><br></pre></td></tr></table></figure><h2 id="知识点-2"><a class="markdownIt-Anchor" href="#知识点-2"></a> 知识点：</h2><p><strong>无条件跳转指令jmp</strong></p><p><strong>goto指令</strong></p><p><strong>优化后的指令</strong></p><p><strong>一、GOTO与JMP</strong></p><p><strong>无条件跳转指令</strong></p><p><code>格式: JMP A</code></p><ol><li>其中A为转移的目的地址。程序转移到目的地址所指向的指令继续往下执行。</li></ol><p>// JZ/JE JNZ/JNE 都需要一个条件，条件成立才跳转，而jmp不需要。</p><ol start="2"><li>本组指令对标志位无影响.</li></ol><p>3、代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//goto jmp</span><br><span class="line"></span><br><span class="line">​     printf(&quot;begin\n&quot;);</span><br><span class="line"></span><br><span class="line">​     goto end;</span><br><span class="line"></span><br><span class="line">  printf(&quot;do this&quot;);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line"></span><br><span class="line">​     printf(&quot;end\n&quot;);</span><br><span class="line"></span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure><p><strong>二、优化后的指令</strong></p><p>/0d 禁用优化</p><p>/01 最小化大小</p><p>/02 最大化速度</p><p>/0x 完全优化</p><p>优化功能对嵌入汇编代码的程序无效</p><h5 id="撤销对汇编指令更改"><a class="markdownIt-Anchor" href="#撤销对汇编指令更改"></a> 撤销对汇编指令更改</h5><p>ALT+BACKSPACE键</p><p><img src="/images/javawz/1626276948460.png" alt="1626276948460"></p><h2 id="知识点-3"><a class="markdownIt-Anchor" href="#知识点-3"></a> 知识点：</h2><p><strong>条件转移指令 JNGE</strong></p><p><strong>条件转移指令 JL</strong></p><p><strong>一、指令格式</strong></p><p>条件转移指令 <strong>JL/JNGE</strong></p><p><code>格式: JL/JNGE 标号地址</code></p><p>功能: 小于/不大于等于时转移 标号地址</p><p>JNGE 有符号 不大于等于 则跳转 //Jump if Not Greater or Equal</p><p>JL  有符号 小于    则跳转　//Jump if Less</p><p><code>SF=1; 符号标志位为1 则跳转到标号地址执行</code></p><p><strong>二、代码测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">     printf(&quot;begin\n&quot;);</span><br><span class="line"></span><br><span class="line">​     //&gt;=</span><br><span class="line"></span><br><span class="line">​     int a=0xA;</span><br><span class="line"></span><br><span class="line">​     int b=0x20;</span><br><span class="line"></span><br><span class="line">​     //if (a&gt;=b) //jl</span><br><span class="line"></span><br><span class="line">​     //&#123;</span><br><span class="line"></span><br><span class="line">​     //    printf(&quot;do this&quot;);</span><br><span class="line"></span><br><span class="line">​     //&#125;</span><br><span class="line"></span><br><span class="line">​     __asm </span><br><span class="line"></span><br><span class="line">​     &#123;</span><br><span class="line"></span><br><span class="line">​          mov ebx,b</span><br><span class="line"></span><br><span class="line">​          sub a,ebx</span><br><span class="line"></span><br><span class="line">​          jnge end</span><br><span class="line"></span><br><span class="line">​          mov ebx,ebx</span><br><span class="line"></span><br><span class="line">​          jl end</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">​     //&lt;</span><br><span class="line"></span><br><span class="line">  end:</span><br><span class="line"></span><br><span class="line">​     printf(&quot;end\n&quot;);</span><br></pre></td></tr></table></figure><h2 id="知识点-4"><a class="markdownIt-Anchor" href="#知识点-4"></a> 知识点：</h2><p><strong>条件转移指令 JLE</strong></p><p><strong>条件转移指令 JNG</strong></p><p><strong>一、指令格式</strong></p><p>条件转移指令 <strong>JLE/JNG</strong></p><p><code>格式: JLE/JNG 标号地址</code></p><p>功能: 小于等于/不大于  时转到标号地址</p><p>JNG  有符号 不大于     则跳转  //Jump if Not Greater</p><p>JLE  有符号 小于等于    则跳转  　//Jump if Less or Equal</p><h5 id="sf1zf1of1-其中一个或者多个为1-则跳转"><a class="markdownIt-Anchor" href="#sf1zf1of1-其中一个或者多个为1-则跳转"></a> SF=1,ZF=1,OF=1 //其中一个或者多个为1 则跳转</h5><p><strong>二、代码测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​     printf(&quot;begin\n&quot;);</span><br><span class="line"></span><br><span class="line">​     int a=3;</span><br><span class="line"></span><br><span class="line">​     int b=5;</span><br><span class="line"></span><br><span class="line">​     if (a&gt;b) //JLE/JNG 小于等于/不大于时转移</span><br><span class="line"></span><br><span class="line">​     &#123;</span><br><span class="line"></span><br><span class="line">​          printf(&quot;do this&quot;);</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">   //JNG 不大于</span><br><span class="line"></span><br><span class="line">​     printf(&quot;end;\n&quot;);</span><br><span class="line"></span><br><span class="line">​     return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OD ctrl+* 设置下一条要执行指令的地址 简单的说就是设置EIP</code></p><h5 id="jnc-指令jump-not-carry-没进位时跳转-cf0"><a class="markdownIt-Anchor" href="#jnc-指令jump-not-carry-没进位时跳转-cf0"></a> JNC 指令：Jump Not  Carry 没进位时跳转 //CF=0</h5><h5 id="jc-进位则跳转-cf1"><a class="markdownIt-Anchor" href="#jc-进位则跳转-cf1"></a> JC   ;进位则跳转 CF=1</h5><h2 id="知识点-5"><a class="markdownIt-Anchor" href="#知识点-5"></a> 知识点：</h2><p><strong>条件转移指令</strong> JG（&gt; 时转移)</p><p><strong>条件转移指令</strong> JNLE(&lt;=时不转移)</p><p><strong>条件转移指令</strong> JGE(&gt;=时转移)</p><p><strong>条件转移指令</strong>JNL(&lt;时不转移)</p><p><strong>一、指令格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JG/JNLE 标号地址     不&lt;= //大于   &gt;  // ZF=0 &amp;&amp; SF=0 &amp;&amp; OF=0</span><br><span class="line"></span><br><span class="line">JGE/JNL 标号地址     不&lt;  //大于等于 &gt;=  </span><br><span class="line">ZF=1 || SF=0 || OF=0时跳转</span><br></pre></td></tr></table></figure><p>JG : Jump if Greater      //  &gt; 跳</p><p>JNLE:Jump if Not Less or Equal  //不&lt;= 跳</p><p>JGE :Jump if Greater or Equal // &gt;= 跳</p><p>JNL: Jump if Not Less    //不&lt; 跳</p><p><strong>二、代码测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  printf(&quot;begin\n&quot;);</span><br><span class="line"></span><br><span class="line">​     int a=4;</span><br><span class="line"></span><br><span class="line">​     //if (a&lt;=3)</span><br><span class="line"></span><br><span class="line">​     //if (!(a&gt;3))</span><br><span class="line"></span><br><span class="line">​     // </span><br><span class="line"></span><br><span class="line">​     //&#123;</span><br><span class="line"></span><br><span class="line">​     //    printf(&quot;小于等于&quot;);</span><br><span class="line"></span><br><span class="line">​     //&#125;//大于时跳转//不小于等于跳转</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​     __asm</span><br><span class="line"></span><br><span class="line">​     &#123;</span><br><span class="line"></span><br><span class="line">​          cmp a,3</span><br><span class="line"></span><br><span class="line">​          JNLE end //JG end</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">​     printf(&quot;do this\n&quot;);</span><br><span class="line"></span><br><span class="line">​     printf(&quot;小于等于&quot;);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line"></span><br><span class="line">​     printf(&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">​     return 0;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JMP                        //014</span><br><span class="line">JE/JZ     //=                //012 Jump if Equl </span><br><span class="line">JNE/JNZ  //不=              //013</span><br><span class="line"></span><br><span class="line">//带符号数条件转移指令</span><br><span class="line">JL /JNGE  //不&gt;=  //小于  &lt;   //015</span><br><span class="line">JLE/JNG  //不&gt;   //小于等于&lt;=  //016</span><br><span class="line">JG/JNLE  //不&lt;=  //大于     &gt;//017</span><br><span class="line">JGE/JNL  //不&lt;   //大于等于&gt;=  //017</span><br><span class="line"></span><br><span class="line">Jump     跳转/转移</span><br><span class="line">Not      不</span><br><span class="line">Equal    相等</span><br><span class="line">Zero    零</span><br><span class="line">Less    小于</span><br><span class="line">Greater 大于</span><br></pre></td></tr></table></figure><h2 id="知识点-6"><a class="markdownIt-Anchor" href="#知识点-6"></a> 知识点：</h2><p><img src="/images/javawz/1626339401129.png" alt="1626339401129"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">二、代码测试</span><br><span class="line"> </span><br><span class="line">JE/JZ              ！= 不跳转</span><br><span class="line">JNZ/JNE            == 不跳转</span><br><span class="line">JG/JNLE           &lt;= 不跳转</span><br><span class="line">JGE/JNL            &lt;  不跳转</span><br><span class="line">JL/JNGE           &gt;= 不跳转</span><br><span class="line">JLE/JNG            &gt; 不跳转 </span><br><span class="line">printf(&quot;begin\n&quot;);</span><br><span class="line">//unsigned </span><br><span class="line">int a=3,b=5;</span><br><span class="line">if (a!=b) //je</span><br><span class="line">if (a==b) //jnz</span><br><span class="line">if (a&lt;=b) //jg</span><br><span class="line">if (a&lt;b) //jge</span><br><span class="line">if (a&gt;=b) //jl</span><br><span class="line">if (a&gt;b)//jle</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;do if&quot;);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;end&quot;);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><h2 id="知识点-7"><a class="markdownIt-Anchor" href="#知识点-7"></a> 知识点：</h2><p>JA （&gt; 时转移)</p><p>JNBE(&lt;=时不转移)</p><p>JA与JG的区别</p><p><img src="/images/javawz/1626348252959.png" alt="1626345077615"></p><p><strong>Above</strong> <strong>高于</strong></p><p><strong>Below低于</strong></p><p><strong>一、无符号大于转移指令JA/JNBE</strong></p><p><strong>JA  :</strong> 高于    时跳转 // &gt;时跳转</p><p><strong>JNBE:</strong> 不低于等于 时跳转 //&lt;=时不跳转</p><p>​         <strong>CF(进位标志位)</strong>：当执行一个加法（减法）运算时，最高位产生进位（或借位）时，CF为1，否则为0。</p><p>​         <strong>ZF零标志位</strong>：若当前的运算结果为零，则ZF为1，否则为0。</p><p>JA与JG区别：</p><p>JG是带符号数比较 &gt;</p><p>JA是无符号数比较 &gt;</p><p>二、代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">      //**CF(进位标志位)**</span><br><span class="line"></span><br><span class="line">​      printf(&quot;begin\n&quot;);</span><br><span class="line"></span><br><span class="line">​      int a=3,b=-5;</span><br><span class="line"></span><br><span class="line">​      unsigned int a2=a,b2=b;   </span><br><span class="line"></span><br><span class="line">​      if (a2&lt;=b2)//无符号的生成JA    不够减 借位</span><br><span class="line"></span><br><span class="line">​      if (a&lt;=b) ///&lt;=时不跳转&gt;时跳转带符号的生成JG指令</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​           printf(&quot;do if\n&quot;);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br></pre></td></tr></table></figure><h2 id="知识点-8"><a class="markdownIt-Anchor" href="#知识点-8"></a> 知识点：</h2><p><strong>JNB</strong> （不小于)</p><p><strong>JAE  (高于等于)</strong></p><p><strong>JNC</strong>  <strong>（CF！=1）</strong></p><p><img src="/images/javawz/1626348252959.png" alt="1626345077615"></p><p><strong>JNB与JGE的区别</strong></p><p><strong>一、无符号大于转移指令JA/JNBE</strong></p><p><strong>JNB</strong> <strong>:</strong> 低于    时不跳转 //&gt;=时跳转 //OD</p><p><strong>JAE:</strong>  高于等于  时跳转  //&gt;=时跳转</p><p><strong>JNC</strong> ：Jump Not Carry 没进位时跳转 //CF=0</p><p>JA与JG区别：</p><p>JNB 是带符号数比较 &gt;=</p><p>JGE 是无符号数比较 &gt;=</p><p>二、代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line"></span><br><span class="line">//CF(进位标志位)</span><br><span class="line"></span><br><span class="line">​     printf(&quot;begin\n&quot;);</span><br><span class="line"></span><br><span class="line">​     int a=3,b=-5;</span><br><span class="line"></span><br><span class="line">​     unsigned int a2=a,b2=b;    </span><br><span class="line"></span><br><span class="line">​     if (a2&lt;b2)//无符号的生成JAE JNB     不够减借位</span><br><span class="line"></span><br><span class="line">​          if (a&lt;b) ///&lt;时不跳转&gt;时跳转带符号的生成JGE JNL指令</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​               printf(&quot;do if\n&quot;);</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br></pre></td></tr></table></figure><h2 id="知识点-9"><a class="markdownIt-Anchor" href="#知识点-9"></a> 知识点：</h2><p><strong>JB/JNAE/JC &lt;指令</strong></p><p><strong>与JL/JNGE区别</strong></p><p><strong>一、无符号大于转移指令JB/JNAE/JC</strong></p><p><strong>JB   低于     时跳转  //&lt; 时跳转 //OD</strong></p><p><strong>JNAE:</strong>  高于等于  时不跳转 //**&gt;=**时不跳转</p><p><strong>JC</strong> ：Jump Carry 进位时跳转 //CF=1</p><p>JB与JL区别：</p><p>JB 是带符号数比较 &gt;=</p><p>JL 是无符号数比较 &gt;=</p><p>二、代码测试</p><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//CF(进位标志位)</span><br><span class="line"></span><br><span class="line">​     printf(&quot;begin\n&quot;);</span><br><span class="line"></span><br><span class="line">​     int a=3,b=-5;</span><br><span class="line"></span><br><span class="line">​     unsigned int a2=a,b2=b;    </span><br><span class="line"></span><br><span class="line">​     if (a2**&gt;=** b2)//无符号的生成JAE JNB   不够减借位</span><br><span class="line"></span><br><span class="line">​          if (a**&gt;=** b) ///&lt;时不跳转&gt;时跳转带符号的生成JGE JNL指令</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​               printf(&quot;do if\n&quot;);</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br></pre></td></tr></table></figure><h2 id="知识点-10"><a class="markdownIt-Anchor" href="#知识点-10"></a> 知识点：</h2><p><strong>JBE/JNA &lt;=指令</strong></p><p><strong>与JLE/JNG区别</strong></p><p><img src="/images/javawz/1626348252959.png" alt="1626348252959"></p><p><strong>一、无符号大于转移指令JBE/JNA</strong></p><p><strong>JBE:  低于等于  时跳转    // &lt;=时跳转 //OD</strong></p><p>**JNA:   高于    时不跳转   //&gt; 不跳转 **</p><p>JBE与JLE区别：</p><p>JLE 是带符号数比较 &gt;=</p><p>JBE 是无符号数比较 &gt;=</p><p>二、代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line"></span><br><span class="line">//CF(进位标志位)</span><br><span class="line"></span><br><span class="line">​     printf(&quot;begin\n&quot;);</span><br><span class="line"></span><br><span class="line">​     int a=3,b=-5;</span><br><span class="line"></span><br><span class="line">​     unsigned int a2=a,b2=b;    </span><br><span class="line"></span><br><span class="line">​     if (a2&gt;=b2)//无符号的生成JAE JNB   不够减借位</span><br><span class="line"></span><br><span class="line">​          if (a&gt;= b) ///&lt;时不跳转&gt;时跳转带符号的生成JGE JNL指令</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​               printf(&quot;do if\n&quot;);</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;知识点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#知识点&quot;&gt;&lt;/a&gt; 知识点：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;条件转移指令JNE/JNZ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ZF（零标志）&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="汇编逆向" scheme="https://xiaowuyoucy.github.io/categories/%E6%B1%87%E7%BC%96%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1-12</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/12/hbnx001-1-12/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/12/hbnx001-1-12/</id>
    <published>2021-07-12T15:22:37.000Z</published>
    <updated>2021-07-24T18:43:27.211Z</updated>
    
    <content type="html"><![CDATA[<p>OD 按下F2断点/关闭断点</p><h3 id="跳到被调用的地方的下一条语句"><a class="markdownIt-Anchor" href="#跳到被调用的地方的下一条语句"></a> 跳到被调用的地方的下一条语句</h3><p><img src="/images/javawz/1626103662895.png" alt="1626103662895"></p><p>按下回车会鼠标右键选择反汇编窗口中跟随</p><h3 id="定位到指定api函数的地方"><a class="markdownIt-Anchor" href="#定位到指定api函数的地方"></a> 定位到指定API函数的地方</h3><p><img src="/images/javawz/1626103810500.png" alt="1626103810500"></p><p><img src="/images/javawz/1626103833021.png" alt="1626103833021"></p><p>按下Ctrl + G 或 鼠标右键选择转到-&gt;表达式</p><p>或者输入命令 <code>bp api函数名</code></p><p><img src="/images/javawz/1626103933703.png" alt="1626103933703"></p><h3 id="查看所有断点"><a class="markdownIt-Anchor" href="#查看所有断点"></a> 查看所有断点</h3><p><img src="/images/javawz/1626103996834.png" alt="1626103996834"></p><p><img src="/images/javawz/1626104011540.png" alt="1626104011540"></p><p>按下 ALT + B 或 鼠标点击菜单栏 查看-&gt;断点</p><h3 id="将od添加到鼠标右键菜单栏"><a class="markdownIt-Anchor" href="#将od添加到鼠标右键菜单栏"></a> 将OD添加到鼠标右键菜单栏</h3><p><img src="/images/javawz/1626104111657.png" alt="1626104111657"></p><p><img src="/images/javawz/1626104133252.png" alt="1626104133252"></p><h3 id="od断点历史记录文件夹"><a class="markdownIt-Anchor" href="#od断点历史记录文件夹"></a> OD断点历史记录文件夹</h3><p><img src="/images/javawz/1626104363289.png" alt="1626104363289"></p><h3 id="c或c内联汇编"><a class="markdownIt-Anchor" href="#c或c内联汇编"></a> c或c++内联汇编</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 001_MOV.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> aaa = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, TCHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MessageBoxW(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, MB_OK);</span><br><span class="line">aaa = <span class="number">0x889977</span>;<span class="comment">//MOV DWORD PTR DS:[0x403018],0x889977</span></span><br><span class="line">__asm &#123;</span><br><span class="line">mov aaa, <span class="number">0x889977</span></span><br><span class="line">&#125;</span><br><span class="line">__asm mov aaa, <span class="number">0x889977</span>;</span><br><span class="line">MessageBoxW(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mov指令"><a class="markdownIt-Anchor" href="#mov指令"></a> MOV指令</h3><p>aaa=0x889977;</p><p>MOV DWORD PTR DS:[0x403018],0x889977</p><p>dword 双字 就是四个字节 ptr pointer缩写 即指针 []里的数据是一个地址值</p><h3 id="dd指令"><a class="markdownIt-Anchor" href="#dd指令"></a> dd指令</h3><p>查看数据的指令</p><p><code>dd 地址</code></p><p>dd 0x403018 == dd 403018</p><hr><hr><h3 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 知识点：</h3><p>函数与CALL</p><p>关闭C/C++优化</p><p>单步步过</p><p>单步步入</p><p><strong>一、函数与CALL</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int add(int a,int b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> return a+b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">00401030 |. 8105 18304000&gt;ADD DWORD PTR DS:[403018],88       ; add 加法指令</span><br><span class="line"></span><br><span class="line">未被优化</span><br><span class="line"></span><br><span class="line">00401040 |. 68 88000000  PUSH 88</span><br><span class="line"></span><br><span class="line">00401045 |. A1 18304000  MOV EAX,DWORD PTR DS:[403018]</span><br><span class="line"></span><br><span class="line">0040104A |. 50      PUSH EAX</span><br><span class="line"></span><br><span class="line">0040104B |. E8 B0FFFFFF  CALL 001_MOV.00401000          ; add函数</span><br><span class="line"></span><br><span class="line">00401050 |. 83C4 08    ADD ESP,8</span><br><span class="line"></span><br><span class="line">00401053 |. A3 18304000  MOV DWORD PTR DS:[403018],EAX</span><br></pre></td></tr></table></figure><p><strong>二、关闭C/C++优化</strong></p><p>项目配置属性—&gt; C/C++ —&gt;优化—&gt;禁用/Od</p><p><strong>三、单步步入：(进CALL)</strong></p><p>F9(运行): 如果断下后，要继续让程序运行起来，可以用快捷键</p><p><em><strong>F7(单步步入):按下后执行下一条指令。如果有CALL则进入。</strong></em></p><p><strong>四、单步步过：(不进CALL)</strong></p><p>F8(单步步过):按下后执行下一条指令。不会进入子函数CALL里边，子函数CALL也被当成一条指令。</p><p>这两个单步执行操作的主要区别在于：如果当前的命令是一个子函数，按，将会进入子函数，并停在子函数的第一条命令上；而按，将会一次运行完这个子函数。如果您单步步过的子函数中含有断点或其他调试事件，执行将会被暂停</p><hr><hr><h3 id="知识点-2"><a class="markdownIt-Anchor" href="#知识点-2"></a> 知识点：</h3><p>立即寻址</p><p>寄存器寻址</p><p>寄存器间接寻址</p><p>直接寻址方式</p><p>直接寻址方式</p><p>寄存器相对寻址</p><h4 id="一-了解指令常用寻址方式"><a class="markdownIt-Anchor" href="#一-了解指令常用寻址方式"></a> 一、了解指令常用寻址方式</h4><p>寻址方式就是寻找操作数或操作数地址的方式。</p><p>寄存器是中央处理器内的组成部分。寄存器是一组容量有限的高速存贮部件，它们可用来暂存指令、数据和位址。（DWORD）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MOV   EAX，0x1234     //立即寻址         </span><br><span class="line"></span><br><span class="line">MOV   EAX，EBX     //寄存器寻址  数据寄存器,一般称之为通用寄存器组 通用寄存器有4个 EAX,EBX,ECX,EDX       </span><br><span class="line"></span><br><span class="line">MOV   EAX，[EBX]     //寄存器间接寻址         </span><br><span class="line"></span><br><span class="line">MOV   EAX，v       //v是一个变量名  </span><br><span class="line"></span><br><span class="line">MOV   EAX，[1234]     //直接寻址方式         </span><br><span class="line"></span><br><span class="line">MOV   EAX，[EBX+1234]   //寄存器相对寻址</span><br></pre></td></tr></table></figure><h4 id="二-理解寻址"><a class="markdownIt-Anchor" href="#二-理解寻址"></a> 二、理解寻址</h4><p>上边的名字看起来很多，总结起来也就2种方式：</p><p>带[]与不带[]</p><p><code>1、不带括号的 有立即数与寄存器</code></p><p><code>2、带括号的就是指针，从地址里边取值出来。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MOV   EAX，0x1234     //立即寻址     eax=0x1234;      </span><br><span class="line"></span><br><span class="line">MOV   EAX，EBX     //寄存器寻址    eax=ebx        </span><br><span class="line"></span><br><span class="line">MOV   EAX，[EBX]     //寄存器间接寻址  eax=*(int*)ebx;        </span><br><span class="line"></span><br><span class="line">MOV   EAX，v       //v是一个变量名   eax=v; //被编译后 一般会呈后边两种形式</span><br><span class="line"></span><br><span class="line">MOV   EAX，[1234]     //直接寻址方式   eax=*(int*)(0x1234)</span><br><span class="line"></span><br><span class="line">MOV   EAX，[EBX+1234]   // 寄存器相对寻址  eax=*(int*)((int)ebx+1234); //这里的1234称为偏移，EBX是基址</span><br></pre></td></tr></table></figure><h4 id="三-对调位置"><a class="markdownIt-Anchor" href="#三-对调位置"></a> 三、对调位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MOV   EAX，0x1234     //立即数不能出现在MOV指令左边。如：   MOV 0x1234,EAX 这是错的写法   </span><br><span class="line"></span><br><span class="line">后边的都可以对换位置    </span><br><span class="line"></span><br><span class="line">MOV   EAX，EBX     //寄存器寻址    eax=ebx         mov ebx,eax     </span><br><span class="line"></span><br><span class="line">MOV   EAX，[EBX]     //寄存器间接寻址  eax=*(int*)ebx;       mov [ebx],eax    </span><br><span class="line"></span><br><span class="line">MOV   EAX，v       //v是一个变量名   eax=v;          mov v,eax</span><br><span class="line"></span><br><span class="line">MOV   EAX，[1234]     //直接寻址方式   eax=*(int*)(0x1234)     mov [1234],eax</span><br><span class="line"></span><br><span class="line">MOV   EAX，[EBX+1234]   // 寄存器相对寻址  eax=*(int*)((int)ebx+1234)  mov [ebx+1234],eax</span><br></pre></td></tr></table></figure><h4 id="四-代码测试"><a class="markdownIt-Anchor" href="#四-代码测试"></a> 四、代码测试</h4><p><code>int *da=a;//int a[0x10]={0,1,2,3,4,5,6,7,8,9,0xA,0xB,0xC,0xd,0xe};</code></p><p>//提示 在命令栏中用 dd 地址表达式 可以以DWORD 4字节格式显示指定地址的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">mov eax,0x1111</span><br><span class="line"></span><br><span class="line">   mov ebx,eax</span><br><span class="line"></span><br><span class="line">mov ebx,bbb //全局变量bbb</span><br><span class="line"></span><br><span class="line">mov ebx,da //取数组基址</span><br><span class="line"></span><br><span class="line"> mov eax,[da+4]</span><br><span class="line"></span><br><span class="line"> mov eax,[ebx+4]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//下边指令，前边是寄存器相对寻址，后边是立即寻址</span><br><span class="line"></span><br><span class="line">0040105A |. C745 FC 20304&gt;MOV DWORD PTR SS:[EBP-4],001_MOV.00403020   ; int *da=a //a是数组的地址 </span><br><span class="line"></span><br><span class="line">00401061 |. B8 11110000  MOV EAX,1111                 ; eax=0x1111 立即寻址</span><br><span class="line"></span><br><span class="line">00401066 |. 8BD8     MOV EBX,EAX                  ; mov ebx,0x1111--&gt;ebx=0x1111 //寄存器寻址</span><br><span class="line"></span><br><span class="line">00401068 |. 8B1D 18304000 MOV EBX,DWORD PTR DS:[403018]         ; mov ebx,008899FF--&gt;ebx=009988FF 直接寻址</span><br><span class="line"></span><br><span class="line">0040106E |. 8B5D FC    MOV EBX,DWORD PTR SS:[EBP-4]         ; mov ebx,da 寄存器 相对寻址</span><br><span class="line"></span><br><span class="line">00401071 |. 8B45 00    MOV EAX,DWORD PTR SS:[EBP]            //寄存器间接寻址</span><br><span class="line"></span><br><span class="line">00401074 |. 8B43 04    MOV EAX,DWORD PTR DS:[EBX+4]         ; eax=da[1]=1 寄存器 相对寻址</span><br></pre></td></tr></table></figure><h3 id="dd命令"><a class="markdownIt-Anchor" href="#dd命令"></a> dd命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dd eax + 2 * 8</span><br><span class="line"></span><br><span class="line">dd eax</span><br><span class="line"></span><br><span class="line">dd 0x11111</span><br></pre></td></tr></table></figure><h3 id="定位到指定地址"><a class="markdownIt-Anchor" href="#定位到指定地址"></a> 定位到指定地址</h3><p><img src="/images/javawz/1626164450409.png" alt></p><p><img src="/images/javawz/1626164503122.png" alt="1626164503122"></p><hr><hr><h3 id="知识点-3"><a class="markdownIt-Anchor" href="#知识点-3"></a> 知识点：</h3><p>加法汇编指令ADD</p><p><strong>一、加法指令 ADD(Addition)</strong> <strong>格式</strong></p><p>格式: ADD A,B  //A=A+B;</p><p>功能: 两数相加</p><ol><li>OPRD1为任一通用寄存器或存储器操作数,可以是任意一个通用寄存器,而且还可以是任意一个存储器操作数.</li></ol><p>OPRD2为立即数,也可以是任意一个通用寄存器操作数.立即数只能用于源操作数B.</p><ol start="2"><li>A和B均为寄存器是允许的,一个为寄存器而另一个为存储器也是允许的, 但不允许两个都是存储器操作数.</li></ol><p>//也就是说A与B不能同时是指针 如: <code>add [eax],[ebx] 这类情况是错的</code></p><p>例子：</p><p>第三课中的add函数里 有如下2句代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401003 |. 8B45 08    MOV EAX,DWORD PTR SS:[EBP+8]       ; a</span><br><span class="line"></span><br><span class="line">00401006 |. 0345 0C    ADD EAX,DWORD PTR SS:[EBP+C]       ; b //eax=a+b</span><br></pre></td></tr></table></figure><p><strong>二、ADD指令测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     int i=0;</span><br><span class="line"></span><br><span class="line">     printf(&quot;&quot;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  i=i+0x100;</span><br><span class="line"></span><br><span class="line">    i=i+0x111;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     int *p=&amp;i;</span><br><span class="line"></span><br><span class="line">     __asm </span><br><span class="line"></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">          mov eax,0x222</span><br><span class="line"></span><br><span class="line">          mov ebx,0x100</span><br><span class="line"></span><br><span class="line">          add ebx,eax //ebx322</span><br><span class="line"></span><br><span class="line">          //</span><br><span class="line"></span><br><span class="line">          mov ebx,p</span><br><span class="line"></span><br><span class="line">          add [ebx],0x111</span><br><span class="line">//00401048 |. 8003 11    ADD BYTE PTR DS:[EBX],11         ; i=i+11</span><br><span class="line"></span><br><span class="line">          add i,0x111   //DWORD WORD</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line"></span><br><span class="line">     0040101C |. 8B45 F8    MOV EAX,DWORD PTR SS:[EBP-8]       ; eax=i=0</span><br><span class="line"></span><br><span class="line">     0040101F |. 05 00010000  ADD EAX,100               ; eax=eax+100=0+100=100</span><br><span class="line"></span><br><span class="line">     00401024 |. 8945 F8    MOV DWORD PTR SS:[EBP-8],EAX       ; i=eax=100</span><br><span class="line"></span><br><span class="line">     00401027 |. 8B4D F8    MOV ECX,DWORD PTR SS:[EBP-8]       ; ecx=i=100</span><br><span class="line"></span><br><span class="line">     0040102A |. 81C1 11010000 ADD ECX,111               ; ecx=ecx+111=100+111=0x211</span><br><span class="line"></span><br><span class="line">     00401030 |. 894D F8    MOV DWORD PTR SS:[EBP-8],ECX       ; i=ecx=0x211</span><br><span class="line"></span><br><span class="line">     00401033 |. 8D55 F8    LEA EDX,DWORD PTR SS:[EBP-8]       ; edx=&amp;i=ebp-8;</span><br><span class="line"></span><br><span class="line">     00401036 |. 8955 FC    MOV DWORD PTR SS:[EBP-4],EDX       ; p=&amp;i</span><br><span class="line"></span><br><span class="line">     00401039 |. B8 22020000  MOV EAX,222</span><br><span class="line"></span><br><span class="line">     0040103E |. BB 00010000  MOV EBX,100</span><br><span class="line"></span><br><span class="line">     00401043 |. 03D8     ADD EBX,EAX               ; ebx=ebx+eax=100+222=322</span><br><span class="line"></span><br><span class="line">     00401045 |. 8B5D FC    MOV EBX,DWORD PTR SS:[EBP-4]       ; ebx=i=edx=ebp-8</span><br><span class="line"></span><br><span class="line">     00401048 |. 8003 11    ADD BYTE PTR DS:[EBX],11         ; i=i+11</span><br><span class="line"></span><br><span class="line">     0040104B |. 8145 F8 11010&gt;ADD DWORD PTR SS:[EBP-8],111       ; i=i+111</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     */ </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     printf(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OD按下<code>-</code>号可以返回上一步</p><hr><hr><h3 id="知识点-4"><a class="markdownIt-Anchor" href="#知识点-4"></a> 知识点：</h3><p><strong>十六进制</strong></p><p><strong>字节，字，双字</strong></p><p><strong>汇编中的内存单元长度修饰</strong></p><p><strong>add [ebx],0x111 //00401048 |.  8003 11  ADD BYTE PTR DS:[EBX],11   ; i=i+11</strong></p><p><strong>一、十六进制</strong></p><p><strong>十六进制</strong>同我们日常中的十进制表示法不一样。它由0-9,A-F,组成。与10进制的对应关系是：0-9对应0-9;A-F对应10-15;</p><p>十进制元素(0,1,2,3,4,5,6,7,8,9)</p><p>十六进制元素(0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F)</p><p>9+1=10; //十进制 A</p><p>F+1=10; //十六进制</p><p>99+1=100;//十进制 0x64</p><p>FF+1=100;//十六进制 1<em>16</em>16=256 //0xBDA=11<em>16</em>16+13*16+10</p><p>十六进制一般会加上前缀0x 汇编中也可以加上h后缀</p><p>//想一想 十六进制中</p><p>0x0F+2=0x11  0xF9+1=0xFA  0x10+1=0x11  0x18+8=0x20 8+9=0x11</p><p><strong>二、字节，字，双字</strong></p><p>字节 (1字节):BYTE类型 ( unsigned char)  0-255    表示成16进制0–0xFF</p><p>字  (2字节):WORD类型 (unsigned short)  0-65535，  表示成16进制0–0xFFFF</p><p>双字 (4字节):DWORD类型(unsigned long)  0-4294967295 表示成16进制0–0xFFFFFFFF</p><p>四字(8字节) QWORD 类型 (unsigned long long )  64 位整数，Q 代表四（字）</p><p><strong>三、汇编中的内存单元长度修饰</strong></p><p><strong>1、自动加上修饰前缀规律</strong></p><p>后面是寄存器会自动加上前缀修饰符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> int pb=3;</span><br><span class="line"></span><br><span class="line"> mov [eax],ebx</span><br><span class="line"></span><br><span class="line"> mov edx,[ecx]</span><br><span class="line"></span><br><span class="line"> mov ebx,pb</span><br><span class="line"></span><br><span class="line">BYTE c=3;</span><br><span class="line"></span><br><span class="line">WORD w=4;</span><br><span class="line"></span><br><span class="line">DWORD dw=5;</span><br><span class="line"></span><br><span class="line">mov c,0x87654321</span><br><span class="line"></span><br><span class="line">mov w,0x87654321</span><br><span class="line"></span><br><span class="line">mov dw,0x87654321</span><br></pre></td></tr></table></figure><p><strong>2、必须手动添加内存单元长度修饰的情况</strong></p><p><strong>前边是存储器，后边是常量的情况，需要手动添加长度修饰</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">add [ebx],0x111 //特殊... 因为编译器不知道具体长度，会默认为 字节长度</span><br><span class="line"></span><br><span class="line">mov byte ptr [ebx],0x87654321</span><br><span class="line"></span><br><span class="line">mov word ptr [ebx],0x87654321</span><br><span class="line"></span><br><span class="line">mov dword ptr [ebx],0x87654321</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   BYTE c=3;</span><br><span class="line"></span><br><span class="line">     WORD w=4;</span><br><span class="line"></span><br><span class="line">     DWORD dw=5;</span><br><span class="line"></span><br><span class="line">     __asm</span><br><span class="line"></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">            add c,0x87654321 // mov [ebp-??],0x21</span><br><span class="line"></span><br><span class="line">              add w,0x87654321</span><br><span class="line"></span><br><span class="line">               add dw,0x87654321</span><br><span class="line"></span><br><span class="line">               /* 自动添加的长度修饰符</span><br><span class="line"></span><br><span class="line">               00401071 |. 8045 EF 21  ADD BYTE PTR SS:[EBP-11],21       ; c=21</span><br><span class="line"></span><br><span class="line">              00401075 |.  66:8145 FC 21&gt;ADD WORD PTR SS:[EBP-4],4321       ; w=4321</span><br><span class="line"></span><br><span class="line">               0040107B |. 8145 F0 21436&gt;ADD DWORD PTR SS:[EBP-10],87654321    ; dw=87654321</span><br><span class="line"></span><br><span class="line">               */</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><hr><h3 id="知识点-5"><a class="markdownIt-Anchor" href="#知识点-5"></a> 知识点：</h3><p>寄存器EAX</p><p>寄存器AX</p><p>寄存器AH</p><p>寄存器AL</p><p>一、EAX与AX,AH,AL关系图</p><p>EAX，EBX，ECX，EDX都有低16位和低8位，高8位寄存器</p><p>ESP，EBP，ESI，EDI只有低16位寄存器例如 SP,BP,SI,DI，而没有低8位和高8位</p><h4 id="数据查看命令"><a class="markdownIt-Anchor" href="#数据查看命令"></a> 数据查看命令</h4><p>dd  查看DWORD内存</p><p>dw 查看WORD内存</p><p>db 查看BYTE内存</p><p><img src="/images/javawz/1626179488871.png" alt="1626179488871"></p><p>一格表示一字节</p><p><img src="/images/javawz/1626178921052.png" alt="1626178921052"></p><p>二、代码测试</p><h5 id="1-od命令栏-号指令-用计显示表达式的值"><a class="markdownIt-Anchor" href="#1-od命令栏-号指令-用计显示表达式的值"></a> 1、OD命令栏 ？号指令 （用计显示表达式的值)</h5><p><code>? ax</code> 查看ax的值</p><p><code>? eax</code> 查看eax的值</p><p><code>? al</code> 查看al的值</p><p><code>? ah</code>查看ah的值</p><p><img src="/images/javawz/1626179249330.png" alt="1626179249330"></p><p><img src="/images/javawz/1626178885198.png" alt="1626178885198"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">printf(&quot;&quot;);</span><br><span class="line">int i_AX,i_AH,i_AL;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax,0x87654321  ;</span><br><span class="line">mov word ptr [i_AX],ax</span><br><span class="line">mov byte ptr [i_AH],ah</span><br><span class="line">mov byte ptr [i_AL],al</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">DWORD iEax;</span><br><span class="line">WORD  iAx;</span><br><span class="line">BYTE  iAh,iAl;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax,0x87654321</span><br><span class="line">mov iEax,eax</span><br><span class="line">mov iAx,ax</span><br><span class="line">mov iAh,ah</span><br><span class="line">mov iAl,al</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;EAX=%x,AX=%x,AH=%x,AL=%x \n&quot;,iEax,iAx,iAh,iAl);</span><br><span class="line">getchar();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h3 id="知识点-6"><a class="markdownIt-Anchor" href="#知识点-6"></a> 知识点：</h3><p>MOVSX符号扩展传送</p><p>MOVZX零扩展传送</p><p>一、MOVSX与MOVZX格式</p><p>MOVSX 操作数A ，操作数B</p><p>MOVZX 操作数A ，操作数B</p><p>相同点：操作数B 空间必须小于 操作数A</p><p>1、格式与MOV基本相同</p><p>2、能完成小存储单元向大存储单元的数据传送 比如 movsx eax,bx movzx ebx,ax   movsx eax,bx</p><p>正确语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOVSX EAX,AX</span><br><span class="line">MOVSX EBX,BL</span><br><span class="line">MOVZX EDX,DX</span><br><span class="line">MOVZX EDX,DL</span><br></pre></td></tr></table></figure><p>错误写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVSX EAX,EAX //第二个操作数内存等于第一个操作数</span><br><span class="line">MOVSX AX,EAX  //第二个操作数内存大于第一个操作数</span><br></pre></td></tr></table></figure><p><strong>MOVSX，MOVZX 与MOV指令区别：</strong></p><p>1、MOVSX，MOVZX的操作数B所占空间必须小于操作数A.</p><p>2、MOV指令是原值传送，不会改动。而MOVSX与MOVZX有可能会改动</p><p><strong>MOVSX与MOVZX的区别：</strong></p><p>1、MOVSX将用操作数B的符号位扩展填充操作数A的余下空间，如果是负数则符号位为1，如果是正数则和MOVZX功能相同</p><p>2、MOVZX将用0来扩展填充操作数A的余下空间。</p><p>操作数A</p><p><img src="/images/javawz/1626181356116.png" alt="1626181356116"></p><p>操作数B</p><p><img src="/images/javawz/1626181370217.png" alt="1626181370217"></p><p>二、代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> int i=0x888;</span><br><span class="line"></span><br><span class="line">     char ci=-100;</span><br><span class="line"></span><br><span class="line">     printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">     i=ci; //111111111111111111111111 11001101</span><br><span class="line"></span><br><span class="line">     i=(unsigned char)ci; //       11001101</span><br><span class="line"></span><br><span class="line">printf(&quot;&quot;);</span><br></pre></td></tr></table></figure><p>判断有符号十六进制是正数还是负数</p><p>char 0-FF //FF/2</p><p>DWORD 0-0xFFF 8F8F</p><p>最高为大于等于8的是负数,1至7是正数</p><h5 id="od按下f4键可以运行到鼠标指定的指令前提是程序必须会经过这条指令"><a class="markdownIt-Anchor" href="#od按下f4键可以运行到鼠标指定的指令前提是程序必须会经过这条指令"></a> <code>OD按下F4键可以运行到鼠标指定的指令,前提是程序必须会经过这条指令</code></h5><hr><hr><h3 id="知识点-7"><a class="markdownIt-Anchor" href="#知识点-7"></a> 知识点：</h3><p><strong>LEA指令</strong></p><p>&amp;与LEA</p><p>OD里修改汇编代码  在指定的指令位置按下空格键或</p><p><strong>一、LEA指令格式</strong></p><p><strong>有效地址传送指令</strong> LEA</p><p>格式: LEA 操作数A, 操作数B</p><p>功能: 将操作数B的有效地址传送到指定的的某个寄存器，操作数A必须是寄存器。(32位系统上就是32位寄存器)</p><p><code>不能两个操作数都是内存操作的</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误写法</span><br><span class="line">LEA DWORD PTR DS:[EBX],DWORD PTR DS:[0X123456]</span><br></pre></td></tr></table></figure><p><strong>二、C++代码测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line"></span><br><span class="line">int *p=&amp;i;</span><br></pre></td></tr></table></figure><p><strong>三、OD里修改汇编代码</strong></p><p>按下空格后 直接输入汇编代码</p><p><img src="/images/javawz/1626186522912.png" alt="1626186522912"></p><p><strong>四、汇编代码测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int i=0:</span><br><span class="line"></span><br><span class="line">char a[4]=&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">__asm</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> lea ebx,i  // ebx=&amp;i</span><br><span class="line"></span><br><span class="line"> mov dword ptr [ebx],0x113388</span><br><span class="line"></span><br><span class="line"> mov i,0x776628</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><hr><hr><h3 id="知识点-8"><a class="markdownIt-Anchor" href="#知识点-8"></a> 知识点：</h3><p><strong>OD调试</strong></p><p><strong>命令栏指令</strong></p><p><strong>一、OD调试</strong></p><p><strong>重新开始：Ctrl+F2</strong></p><p>转到地址：CTRL+G</p><p><strong>断点切换: F2</strong></p><p>断点窗口: Alt+B</p><p>运行  : F9</p><p>暂停  : F12</p><p>单步步过: F8 //遇到CALL跳过</p><p>单步步入: F7 //遇到CALL进入</p><p>运行到选定位置  :F4  <strong>//这个主菜单上没有，右键菜单-断点-F4</strong></p><p>反汇编窗口中跟随 :回车键enter</p><p>跟随: 回车键enter //进入某个地址</p><p>执行到返回 CTRL + F9</p><h5 id="右键菜单转到"><a class="markdownIt-Anchor" href="#右键菜单转到"></a> 右键菜单–转到</h5><p>+号：转到下一步 //Plus</p><p>-号：转到上一步 //Minus</p><p><code>*号</code>：转到当前指令地址 //EIP</p><p>寄存器窗口:</p><p><strong>二、命令栏指令</strong></p><p>bp 下断点</p><p>bc 清除断点</p><p>dd 以双字方式显示数据</p><p>dw 以字方式显示数据</p><p>db 以字节方式显示数据</p><p>？ 计算表达式的值</p><hr><hr><h3 id="知识点-9"><a class="markdownIt-Anchor" href="#知识点-9"></a> 知识点：</h3><p><strong>汇编减法指令sub</strong></p><p><strong>初识标志位</strong></p><p><strong>标志寄存器PSW</strong></p><p><strong>ZF（零标志）</strong></p><p><strong>一、标志寄存器PSW</strong></p><p>标志寄存器PSW(程序状态字寄存器PSW)</p><p>标志寄存器PSW是一个16为的寄存器。它反映了CPU运算的状态特征并且存放某些控制标志。8086使用了16位中的9位，包括6个状态标志位和3个控制标志位。</p><p><img src="/images/javawz/1626190827047.png" alt="1626190827047"></p><p><strong>CF(进位标志位)</strong>：当执行一个加法（减法）运算时，最高位产生进位（或借位）时，CF为1，否则为0。</p><p><strong>ZF零标志位</strong>：若当前的运算结果为零，则ZF为1，否则为0。</p><p><strong>SF符号标志位</strong>：该标志位与运算结果的最高位相同。即运算结果为负，则SF为1，否则为0。</p><p><strong>OF溢出标志位</strong>：若运算结果超出机器能够表示的范围称为溢出，此时OF为1，否则为0。判断是否溢出的方法是：进行二进制运算时，最高位的进位值与次高位的进位值进行异或运算，若运算结果为1则表示溢出OF=1，否则OF=0</p><p><strong>PF奇偶标志</strong>：当运算结果的最低16位中含1的个数为偶数则PF=1否则PF=0</p><p><strong>AF辅助进位标志</strong>：一个加法（减法）运算结果的低4位向高4位有进位（或借位）时则AF=1否则AF=0</p><p>另外还有三个控制标志位用来控制CPU的操作，可以由程序进行置位和复位。</p><p><strong>TF跟踪标志</strong>：该标志位为方面程序调试而设置。若TF=1，8086/8088CPU处于单步工作方式，即在每条指令执行结束后，产生中断。</p><p><strong>IF中断标志位</strong>：该标志位用来控制CPU是否响应可屏蔽中断。若IF=1则允许中断，否则禁止中断。</p><p><strong>DF方向标志</strong>：该标志位用来控制串处理指令的处理方向。若DF=1则串处理过程中地址自动递减，否则自动递增。</p><p><strong>OD里能查看到除IF标志外的 8个标志位</strong></p><p><img src="/images/javawz/1626190975291.png" alt="1626190975291"></p><p><strong>二、SUB指令</strong></p><p><strong>减法指令SUB (SUBtract)</strong></p><p>格式: SUB A,B //A=A-B;</p><p>功能: 两个操作数的相减,即从A中减去B,其结果放在A中.</p><p>SUB指令会影响标志位</p><p><code>如果SUB EAX,EBX 等于0的话,ZF标志位会置为1,说明两数相等</code></p><hr><hr><h3 id="知识点-10"><a class="markdownIt-Anchor" href="#知识点-10"></a> 知识点：</h3><p><strong>比较指令CMP</strong></p><p><strong>条件跳转指令JZ</strong></p><p><strong>ZF（零标志）</strong></p><p><strong>CMP</strong> <strong>和JZ</strong> <strong>指令</strong></p><p><strong>比较指令CMP</strong></p><p>格式: <strong>CMP</strong> A,B // A-B;</p><p>功能: 两个操作数的相减,即从A中减去B，其结果会影响标志位， 对标志位的影响与SUB指令相同。本条指令主要是用于配合条件转移指令使用。如JZ ZF=0时，跳转</p><p><strong>条件转移指令 JE/JZ</strong></p><p><code>格式: JE/JZ标号 //等于跳转</code></p><p><code>功能: ZF＝1,转到指定地址执行</code></p><p>说明:</p><ol><li><p>指令JE与JZ等价,它们是根据标志位ZF进行转移的指令</p></li><li><p>JE,JZ均为一条指令的两种助记符表示方法</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   printf(&quot;begin\n&quot;);</span><br><span class="line"></span><br><span class="line">     int a=3;</span><br><span class="line"></span><br><span class="line">    if (a!=3)</span><br><span class="line"></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">          printf(&quot;do code\n&quot;);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;end&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OD 按下F2断点/关闭断点&lt;/p&gt;
&lt;h3 id=&quot;跳到被调用的地方的下一条语句&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#跳到被调用的地方的下一条语句&quot;&gt;&lt;/a&gt; 跳到被调用的地方的下一条语句&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/ima
      
    
    </summary>
    
      <category term="汇编逆向" scheme="https://xiaowuyoucy.github.io/categories/%E6%B1%87%E7%BC%96%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0088-%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0088-算法/</id>
    <published>2021-07-05T10:16:24.000Z</published>
    <updated>2021-07-24T22:08:35.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h1><h3 id="算法基础"><a class="markdownIt-Anchor" href="#算法基础"></a> 算法基础</h3><h4 id="算法概述"><a class="markdownIt-Anchor" href="#算法概述"></a> 算法概述</h4><p>算法部分主要由头文件&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;组成。</p><p>&lt;algorithm&gt;是所有STL头文件中最大的一个，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、反转、排序、合并等等。</p><p>&lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。</p><p>&lt;functional&gt;中则定义了一些模板类，用以声明函数对象。</p><p>STL提供了大量实现算法的模版函数，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能，从而大大地提升效率。</p><p>#include &lt;algorithm&gt;</p><p>#include &lt;numeric&gt;</p><p>#include &lt;functional&gt;</p><h4 id="stl中算法分类"><a class="markdownIt-Anchor" href="#stl中算法分类"></a> STL中算法分类</h4><ul><li><p>操作对象</p></li><li><ul><li>直接改变容器的内容</li><li>将原容器的内容复制一份,修改其副本,然后传回该副本</li></ul></li><li><p>功能:</p></li><li><ul><li><p>非可变序列算法 指不直接修改其所操作的容器内容的算法</p></li><li><ul><li>计数算法     count、count_if</li><li>搜索算法     search、find、find_if、find_first_of、…</li><li>比较算法     equal、mismatch、lexicographical_compare</li></ul></li><li><p>可变序列算法 指可以修改它们所操作的容器内容的算法</p></li><li><ul><li>删除算法     remove、remove_if、remove_copy、…</li><li>修改算法     for_each、transform</li><li>排序算法     sort、stable_sort、partial_sort、</li></ul></li><li><p>排序算法 包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作</p></li><li><p>数值算法 对容器内容进行数值计算</p></li></ul></li></ul><h4 id="常用算法汇总"><a class="markdownIt-Anchor" href="#常用算法汇总"></a> 常用算法汇总</h4><p>常用的查找算法：</p><p>adjacent_find()（ adjacent 是邻近的意思）,binary_search(),count(),</p><p>count_if(),equal_range(),find(),find_if()。</p><p>常用的排序算法：</p><p>merge(),sort(),random_shuffle()（shuffle是洗牌的意思） ,reverse()。</p><p>常用的拷贝和替换算法：</p><p>copy(), replace(),</p><p>replace_if(),swap()</p><p>常用的算术和生成算法：</p><p>accumulate()（ accumulate 是求和的意思）,fill(),。</p><p>常用的集合算法：</p><p>set_union(),set_intersection(),</p><p>set_difference()。</p><p>常用的遍历算法：</p><p>for_each(), transform()（ transform 是变换的意思）</p><h3 id="算法中函数对象和谓词"><a class="markdownIt-Anchor" href="#算法中函数对象和谓词"></a> 算法中函数对象和谓词</h3><h4 id="函数对象和谓词定义"><a class="markdownIt-Anchor" href="#函数对象和谓词定义"></a> 函数对象和谓词定义</h4><p><strong>函数对象：</strong></p><p>重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象。一个类对象，表现出一个函数的特征，就是通过“对象名+(参数列表)”的方式使用一个类对象，如果没有上下文，完全可以把它看作一个函数对待。</p><p>这是通过重载类的operator()来实现的。</p><p>“在标准库中，函数对象被广泛地使用以获得弹性”，标准库中的很多算法都可以使用函数对象或者函数来作为自定的回调行为；</p><p><strong>谓词：</strong></p><p>一元函数对象：函数参数1个；</p><p>二元函数对象：函数参数2个；</p><p>一元谓词 函数参数1个，函数返回值是bool类型，可以作为一个判断式</p><p>​              谓词可以使一个仿函数，也可以是一个回调函数。</p><p>二元谓词 函数参数2个，函数返回值是bool类型</p><p>一元谓词函数举例如下</p><p>1，判断给出的string对象的长度是否小于6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool GT6(const string &amp;s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return s.size() &gt;= 6;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2,判断给出的int是否在3到8之间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool Compare( int i )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return ( i &gt;= 3 &amp;&amp; i &lt;= 8 );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二元谓词举例如下</p><p>1，比较两个string对象，返回一个bool值，指出第一个string是否比第二个短</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool isShorter(const string &amp;s1, const string &amp;s2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return s1.size() &lt; s2.size();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一元函数对象案例"><a class="markdownIt-Anchor" href="#一元函数对象案例"></a> 一元函数对象案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//1普通类 重载 函数调用操作符</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void FuncShowElemt(T &amp;t)  //普通函数 不能像 仿函数那样记录状态</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void showChar(char &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数模板 重载 函数调用操作符</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class ShowElemt</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ShowElemt()</span><br><span class="line">&#123;</span><br><span class="line">n = 0;</span><br><span class="line">&#125;</span><br><span class="line">void operator()(T &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">void printCount()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//1 函数对象 基本使用</span><br><span class="line">void main11()</span><br><span class="line">&#123;</span><br><span class="line">int a = 100;</span><br><span class="line">FuncShowElemt&lt;int&gt;(a); //普通的函数调用</span><br><span class="line"></span><br><span class="line">ShowElemt&lt;int&gt; showElemt; //函数对象 </span><br><span class="line">showElemt(a); //函数对象调用 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一元谓词案例"><a class="markdownIt-Anchor" href="#一元谓词案例"></a> 一元谓词案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//1元谓词 例子</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Isdiv</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Isdiv(const T &amp;divisor) //</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;divisor = divisor;</span><br><span class="line">&#125;</span><br><span class="line">bool operator()(T &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">return (t%divisor == 0);</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">private:</span><br><span class="line">T divisor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main13()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v2;</span><br><span class="line">for (int i=10; i&lt;33; i++)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">int a = 4;</span><br><span class="line">Isdiv&lt;int&gt; mydiv(a);</span><br><span class="line">// _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)   //返回的是迭代器</span><br><span class="line">it = find_if(v2.begin(), v2.end(), Isdiv&lt;int&gt;(4));</span><br><span class="line">if (it != v2.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;第一个被4整除的数是：&quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二元函数对象案例"><a class="markdownIt-Anchor" href="#二元函数对象案例"></a> 二元函数对象案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">struct SumAdd</span><br><span class="line">&#123;</span><br><span class="line">T operator()(T &amp;t1, T &amp;t2)</span><br><span class="line">&#123;</span><br><span class="line">return t1 + t2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void printE(T &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = t.begin(); it!=t.end(); it++ )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt; &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it!=v.end(); it++ )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  main14()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1, v2 ;</span><br><span class="line">vector&lt;int&gt; v3;</span><br><span class="line">v1.push_back(1);</span><br><span class="line">v1.push_back(2);</span><br><span class="line">v1.push_back(3);</span><br><span class="line"></span><br><span class="line">v2.push_back(4);</span><br><span class="line">v2.push_back(5);</span><br><span class="line">v2.push_back(6);</span><br><span class="line"></span><br><span class="line">v3.resize(10);</span><br><span class="line"></span><br><span class="line">//transform(v1.begin(), v1.end(), v2.begin(),v3.begin(), SumAdd&lt;int&gt;());</span><br><span class="line">/*</span><br><span class="line">template&lt;class _InIt1,</span><br><span class="line">class _InIt2,</span><br><span class="line">class _OutIt,</span><br><span class="line">class _Fn2&gt; inline</span><br><span class="line">_OutIt transform(_InIt1 _First1, _InIt1 _Last1,</span><br><span class="line">_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)</span><br><span class="line">*/</span><br><span class="line">vector&lt;int&gt;::iterator it = transform(v1.begin(), v1.end(), v2.begin(),v3.begin(), SumAdd&lt;int&gt;());</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">printE(v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二元谓词案例"><a class="markdownIt-Anchor" href="#二元谓词案例"></a> 二元谓词案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void current(int &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MyCompare(const int &amp;a, const int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">return a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line">void main15()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v(10);</span><br><span class="line"></span><br><span class="line">for (int i=0; i&lt;10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v[i] = rand() % 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), current);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">sort(v.begin(), v.end(), MyCompare );</span><br><span class="line"></span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">for (int i=0; i&lt;10; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, v[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="预定义函数对象和函数适配器"><a class="markdownIt-Anchor" href="#预定义函数对象和函数适配器"></a> 预定义函数对象和函数适配器</h4><p>预定义函数对象基本概念：标准模板库STL提前定义了很多预定义函数对象，#include &lt;functional&gt; 必须包含。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//1使用预定义函数对象：</span><br><span class="line">//类模板plus&lt;&gt; 的实现了： 不同类型的数据进行加法运算</span><br><span class="line">void main41()</span><br><span class="line">&#123;</span><br><span class="line">plus&lt;int&gt; intAdd;</span><br><span class="line">int x = 10;</span><br><span class="line">int y = 20;</span><br><span class="line">int z = intAdd(x, y); //等价于 x + y </span><br><span class="line">cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">plus&lt;string&gt; stringAdd;</span><br><span class="line">string myc = stringAdd(&quot;aaa&quot;, &quot;bbb&quot;);</span><br><span class="line">cout &lt;&lt; myc &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; v1;</span><br><span class="line">v1.push_back(&quot;bbb&quot;);</span><br><span class="line">v1.push_back(&quot;aaa&quot;);</span><br><span class="line">v1.push_back(&quot;ccc&quot;);</span><br><span class="line">v1.push_back(&quot;zzzz&quot;);</span><br><span class="line"></span><br><span class="line">//缺省情况下，sort()用底层元素类型的小于操作符以升序排列容器的元素。</span><br><span class="line">//为了降序，可以传递预定义的类模板greater,它调用底层元素类型的大于操作符：</span><br><span class="line">cout &lt;&lt; &quot;sort()函数排序&quot; &lt;&lt; endl;;</span><br><span class="line">sort(v1.begin(), v1.end(), greater&lt;string&gt;() ); //从大到小</span><br><span class="line">for (vector&lt;string&gt;::iterator it=v1.begin(); it!=v1.end(); it++ )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算术函数对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">预定义的函数对象支持加、减、乘、除、求余和取反。调用的操作符是与type相关联的实例</span><br><span class="line">加法：plus&lt;Types&gt;</span><br><span class="line">plus&lt;string&gt; stringAdd;</span><br><span class="line">sres = stringAdd(sva1,sva2);</span><br><span class="line">减法：minus&lt;Types&gt;</span><br><span class="line">乘法：multiplies&lt;Types&gt;</span><br><span class="line">除法divides&lt;Tpye&gt;</span><br><span class="line">求余：modulus&lt;Tpye&gt;</span><br><span class="line">取反：negate&lt;Type&gt;</span><br><span class="line">negate&lt;int&gt; intNegate;</span><br><span class="line">ires = intNegate(ires);</span><br><span class="line">Ires= UnaryFunc(negate&lt;int&gt;(),Ival1);</span><br></pre></td></tr></table></figure><p><strong>关系函数对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">等于equal_to&lt;Tpye&gt;</span><br><span class="line">equal_to&lt;string&gt; stringEqual;</span><br><span class="line">sres = stringEqual(sval1,sval2);</span><br><span class="line">不等于not_equal_to&lt;Type&gt;</span><br><span class="line">大于 greater&lt;Type&gt;</span><br><span class="line">大于等于greater_equal&lt;Type&gt;</span><br><span class="line">小于 less&lt;Type&gt;</span><br><span class="line">小于等于less_equal&lt;Type&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main42()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;string&gt; v1;</span><br><span class="line">v1.push_back(&quot;bbb&quot;);</span><br><span class="line">v1.push_back(&quot;aaa&quot;);</span><br><span class="line">v1.push_back(&quot;ccc&quot;);</span><br><span class="line">v1.push_back(&quot;zzzz&quot;);</span><br><span class="line">v1.push_back(&quot;ccc&quot;);</span><br><span class="line">string s1 = &quot;ccc&quot;;</span><br><span class="line">//int num = count_if(v1.begin(),v1.end(), equal_to&lt;string&gt;(),s1);</span><br><span class="line">int num = count_if(v1.begin(),v1.end(),bind2nd(equal_to&lt;string&gt;(), s1));</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>逻辑函数对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">逻辑与 logical_and&lt;Type&gt;</span><br><span class="line">logical_and&lt;int&gt; indAnd;</span><br><span class="line">ires = intAnd(ival1,ival2);</span><br><span class="line">dres=BinaryFunc( logical_and&lt;double&gt;(),dval1,dval2);</span><br><span class="line">逻辑或logical_or&lt;Type&gt;</span><br><span class="line">逻辑非logical_not&lt;Type&gt;</span><br><span class="line">logical_not&lt;int&gt; IntNot;</span><br><span class="line">Ires = IntNot(ival1);</span><br><span class="line">Dres=UnaryFunc( logical_not&lt;double&gt;,dval1);</span><br></pre></td></tr></table></figure><h4 id="函数适配器"><a class="markdownIt-Anchor" href="#函数适配器"></a> 函数适配器</h4><p>​        <strong>函数适配器的理论知识</strong></p><p><img src="/images/javawz/1625480849621.png" alt="1625480849621"></p><p><img src="/images/javawz/1625480873142.png" alt="1625480873142"></p><p><img src="/images/javawz/1625480877479.png" alt="1625480877479"></p><p><img src="/images/javawz/1625480882053.png" alt="1625480882053"></p><p><strong>常用函数函数适配器</strong></p><p>标准库提供一组函数适配器，用来特殊化或者扩展一元和二元函数对象。常用适配器是：</p><p>1绑定器（binder）: binder通过把二元函数对象的一个实参绑定到一个特殊的值上，将其转换成一元函数对象。C＋＋标准库提供两种预定义的binder适配器：bind1st和bind2nd，前者把值绑定到二元函数对象的第一个实参上，后者绑定在第二个实参上。</p><p>2取反器(negator) : negator是一个将函数对象的值翻转的函数适配器。标准库提供两个预定义的ngeator适配器：not1翻转一元预定义函数对象的真值,而not2翻转二元谓词函数的真值。</p><p>常用函数适配器列表如下：</p><p>bind1st(op, value)</p><p>bind2nd(op, value)</p><p>not1(op)</p><p>not2(op)</p><p>mem_fun_ref(op)</p><p>mem_fun(op)</p><p>ptr_fun(op)</p><p><strong>3）常用函数适配器案例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class IsGreat</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">IsGreat(int i)</span><br><span class="line">&#123;</span><br><span class="line">m_num = i;</span><br><span class="line">&#125;</span><br><span class="line">bool operator()(int &amp;num)</span><br><span class="line">&#123;</span><br><span class="line">if (num &gt; m_num)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">private:</span><br><span class="line">int m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main43()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;  v1;</span><br><span class="line">for (int i=0; i&lt;5; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator it = v1.begin(); it!=v1.end(); it ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot; ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int num1 = count(v1.begin(), v1.end(), 3);</span><br><span class="line">cout &lt;&lt; &quot;num1:&quot; &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//通过谓词求大于2的个数</span><br><span class="line">int num2 = count_if(v1.begin(), v1.end(), IsGreat(2)); </span><br><span class="line">cout &lt;&lt; &quot;num2:&quot; &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//通过预定义函数对象求大于2的个数   greater&lt;int&gt;() 有2个参数 </span><br><span class="line">//param &gt; 2</span><br><span class="line">int num3 = count_if(v1.begin(), v1.end(), bind2nd(greater&lt;int&gt;(), 2 ) );</span><br><span class="line">cout &lt;&lt; &quot;num3:&quot; &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//取模 能被2整除的数 求奇数</span><br><span class="line">int num4 = count_if(v1.begin(), v1.end(), bind2nd(modulus &lt;int&gt;(), 2 ) ); </span><br><span class="line">cout &lt;&lt; &quot;奇数num4:&quot; &lt;&lt; num4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int num5 = count_if(v1.begin(), v1.end(), not1( bind2nd(modulus &lt;int&gt;(), 2 ) ) ); </span><br><span class="line">cout &lt;&lt; &quot;偶数num5:&quot; &lt;&lt; num5 &lt;&lt; endl;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line"></span><br><span class="line">class MyPrint:public binary_function&lt;int,int,void&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void operator()(int v, int start) const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v=&quot; &lt;&lt; v &lt;&lt; &quot;start=&quot; &lt;&lt; start &lt;&lt; &quot;v+start=&quot; &lt;&lt; v + start &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++) </span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;请输入一个起始值：&quot; &lt;&lt; endl;</span><br><span class="line">int num;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">//for_each(v.begin(), v.end(), bind2nd (MyPrint(),num));</span><br><span class="line">for_each(v.begin(), v.end(), bind1st(MyPrint(), num));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//第一步，绑定数据 bind2nd</span><br><span class="line">//第二步，继承类 binary_function&lt;参数类型1，参数类型2，返回值类型&gt;</span><br><span class="line">//第三步，加const修饰operator()</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取反适配器"><a class="markdownIt-Anchor" href="#取反适配器"></a> 取反适配器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class MyPrint:public binary_function&lt;int,int,void&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void operator()(int v, int start) const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v=&quot; &lt;&lt; v &lt;&lt; &quot;start=&quot; &lt;&lt; start &lt;&lt; &quot;v+start=&quot; &lt;&lt; v + start &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">   //取反适配器</span><br><span class="line">class CreateThenFive:public unary_function&lt;int,bool&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int v)const</span><br><span class="line">&#123;</span><br><span class="line">return v &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    void test02()</span><br><span class="line">    &#123;</span><br><span class="line">    //一元取反</span><br><span class="line">    vector&lt;int&gt;v;</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//查找大于5的数字</span><br><span class="line">//需求改为找小于5的数字</span><br><span class="line">//vector&lt;int&gt;::iterator pos=find_if(v.begin(), v.end(),not1 (CreateThenFive()));</span><br><span class="line">vector&lt;int&gt;::iterator pos=find_if(v.begin(), v.end(),not1(bind2nd(greater&lt;int&gt;(),5)));</span><br><span class="line"></span><br><span class="line">if (pos != v.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到大于5的数字为：&quot; &lt;&lt;*pos&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//一元取反适配器 not1</span><br><span class="line">//继承unary_fuction&lt;类型1，返回值类型&gt;</span><br><span class="line">//const</span><br></pre></td></tr></table></figure><h4 id="10328-stl的容器算法迭代器的设计理念"><a class="markdownIt-Anchor" href="#10328-stl的容器算法迭代器的设计理念"></a> 10.3.2.8 STL的容器算法迭代器的设计理念</h4><p><img src="/images/javawz/clip_image002.jpg" alt="img"></p><p>1） STL的容器通过<strong>类模板</strong>技术，实现数据类型和容器模型的分离。</p><p>2） STL的迭代器技术实现了遍历容器的统一方法；也为STL的算法提供了统一性</p><p>3） STL的函数对象实现了自定义数据类型的算法运算。（算法和）</p><p>4） 具体例子：transform算法的输入，通过迭代器first和last指向的元算作为输入；通过result作为输出；通过函数对象来做自定义数据类型的运算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#算法&quot;&gt;&lt;/a&gt; 算法&lt;/h1&gt;
&lt;h3 id=&quot;算法基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#算法基础&quot;&gt;&lt;/a&gt; 算法基础&lt;/h3&gt;
&lt;h4 
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>容器共性机制研究</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0087-%E5%AE%B9%E5%99%A8%E5%85%B1%E6%80%A7%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0087-容器共性机制研究/</id>
    <published>2021-07-05T06:41:46.000Z</published>
    <updated>2021-07-05T06:51:15.814Z</updated>
    
    <content type="html"><![CDATA[<h4 id="容器的共通能力"><a class="markdownIt-Anchor" href="#容器的共通能力"></a> 容器的共通能力</h4><p>C++模板是容器的概念。</p><p><img src="/images/javawz/1625467342426.png" alt="1625467342426"></p><p><b>理论提高：</b>所有容器提供的都是值（value）语意，而非引用（reference）语意。<strong>容器执行插入元素的操作时，内部实施拷贝动作。<strong>所以STL容器内存储的元素必须</strong>能够被拷贝</strong>（必须提供拷贝构造函数）。</p><p>除了queue与stack外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。</p><p>通常STL不会丢出异常。要求使用者确保传入正确的参数。</p><p>每个容器都提供了一个默认构造函数跟一个默认拷贝构造函数。</p><p>如已有容器vecIntA。</p><p>vector&lt;int&gt; vecIntB(vecIntA); //调用拷贝构造函数，复制vecIntA到vecIntB中。</p><p>与大小相关的操作方法(c代表容器)：</p><p>c.size();  //返回容器中元素的个数</p><p>c.empty();  //判断容器是否为空</p><p>比较操作(c1,c2代表容器)：</p><p>c1 == c2   判断c1是否等于c2</p><p>c1 != c2   判断c1是否不等于c2</p><p>c1 = c2    把c2的所有元素指派给c1</p><h4 id="各个容器的使用时机"><a class="markdownIt-Anchor" href="#各个容器的使用时机"></a> 各个容器的使用时机</h4><p><img src="/images/javawz/1625467543529.png" alt="1625467543529"></p><p><b> deque的使用场景：</b>比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</p><h5 id="vector与deque的比较"><a class="markdownIt-Anchor" href="#vector与deque的比较"></a> vector与deque的比较：</h5><p>一：<a href="http://vector.at" target="_blank" rel="noopener">vector.at</a>()<a href="http://xn--deque-gu8k.at" target="_blank" rel="noopener">比deque.at</a>()效率高，<a href="http://xn--vector-hh4kj42j.at" target="_blank" rel="noopener">比如vector.at</a>(0)是固定的，deque的开始位置却是不固定的。</p><p>二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</p><p>三：deque支持头部的快速插入与快速移除，这是deque的优点。</p><p><b> list的使用场景：</b>比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p><p><b>set的使用场景：</b>比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。</p><p><b> map的使用场景：</b>比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;容器的共通能力&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#容器的共通能力&quot;&gt;&lt;/a&gt; 容器的共通能力&lt;/h4&gt;
&lt;p&gt;C++模板是容器的概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/162546734242
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>Map和multimap容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0086-Map%E5%92%8Cmultimap%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0086-Map和multimap容器/</id>
    <published>2021-07-05T06:30:26.000Z</published>
    <updated>2021-07-05T06:41:11.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="map和multimap容器"><a class="markdownIt-Anchor" href="#map和multimap容器"></a> Map和multimap容器</h1><p>map是标准的<strong>关联式</strong>容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。</p><p>map中<strong>key值是唯一的</strong>。集合中的元素按一定的<strong>顺序</strong>排列。元素插入过程是按排序规则插入，所以不能指定插入位置。</p><p>map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入操作和删除操作上比vector快。</p><p>map可以直接存取key所对应的value，支持[]操作符，如map[key]=value。</p><p>multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。</p><p>#include &lt;map&gt;</p><p><img src="/images/javawz/1625466752833.png" alt="1625466752833"></p><h4 id="mapmultimap对象的默认构造"><a class="markdownIt-Anchor" href="#mapmultimap对象的默认构造"></a> map/multimap对象的默认构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map/multimap采用模板类实现，对象的默认构造形式：</span><br><span class="line">map&lt;T1,T2&gt; mapTT; </span><br><span class="line">multimap&lt;T1,T2&gt;  multimapTT;  </span><br><span class="line">如：</span><br><span class="line">map&lt;int, char&gt; mapA;</span><br><span class="line">map&lt;string,float&gt; mapB;</span><br><span class="line">//其中T1,T2还可以用各种指针类型或自定义类型</span><br></pre></td></tr></table></figure><h4 id="map的插入与迭代器"><a class="markdownIt-Anchor" href="#map的插入与迭代器"></a> map的插入与迭代器</h4><p>map.insert(…);  //往容器插入元素，返回pair&lt;iterator,bool&gt;</p><p>在map中插入元素的三种方式：</p><p>假设 map&lt;int, string&gt; mapStu;</p><h5 id="一-通过pair的方式插入对象"><a class="markdownIt-Anchor" href="#一-通过pair的方式插入对象"></a> 一、通过pair的方式插入对象</h5><p>mapStu.insert( pair&lt;int,string&gt;(3,“小张”) );</p><h5 id="二-通过pair的方式插入对象"><a class="markdownIt-Anchor" href="#二-通过pair的方式插入对象"></a> 二、通过pair的方式插入对象</h5><p>mapStu.inset(make_pair(-1, “校长-1”));</p><h5 id="三-通过value_type的方式插入对象"><a class="markdownIt-Anchor" href="#三-通过value_type的方式插入对象"></a> 三、通过value_type的方式插入对象</h5><p>mapStu.insert( map&lt;int,string&gt;::value_type(1,“小李”) );</p><h5 id="四-通过数组的方式插入值"><a class="markdownIt-Anchor" href="#四-通过数组的方式插入值"></a> 四、通过数组的方式插入值</h5><p>mapStu[3] = “小刘&quot;;</p><p>mapStu[5] = “小王&quot;；</p><p>​</p><p>前三种方法，采用的是insert()方法，该方法<strong>返回值为pair</strong></p><p>第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值<strong>修改</strong>成“小刘”。若发现已存在3这个键，则修改这个键对应的value。</p><p>string strName = mapStu[2];  //取操作或插入操作</p><p>只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，键为2，值为初始化值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">假设  map&lt;int, string&gt; mapA;</span><br><span class="line">pair&lt; map&lt;int,string&gt;::iterator, bool &gt; pairResult = mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;));//插入方式一</span><br><span class="line"></span><br><span class="line">int iFirstFirst = (pairResult.first)-&gt;first;//iFirst == 3;</span><br><span class="line">string strFirstSecond = (pairResult.first)-&gt;second;//strFirstSecond为&quot;小张&quot;</span><br><span class="line">bool bSecond = pairResult.second;//bSecond == true;</span><br><span class="line"></span><br><span class="line">mapA.insert(map&lt;int,string&gt;::value_type(1,&quot;小李&quot;));//插入方式二</span><br><span class="line"></span><br><span class="line">mapA[3] = &quot;小刘&quot;;//修改value</span><br><span class="line">mapA[5] = &quot;小王&quot;;//插入方式三</span><br><span class="line"></span><br><span class="line">string str1 = mapA[2];//执行插入 string() 操作，返回的str1的字符串内容为空。</span><br><span class="line">string str2 = mapA[3];//取得value，str2为&quot;小刘&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//迭代器遍历</span><br><span class="line">for (map&lt;int,string&gt;::iterator it=mapA.begin(); it!=mapA.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;int, string&gt; pr = *it;</span><br><span class="line">int iKey = pr.first;</span><br><span class="line">string strValue = pr.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;T1,T2,less&lt;T1&gt; &gt;  mapA;  //该容器是按键的升序方式排列元素。未指定函数对象，默认采用less&lt;T1&gt;函数对象。</span><br><span class="line">map&lt;T1,T2,greater&lt;T1&gt;&gt; mapB;   //该容器是按键的降序方式排列元素。</span><br><span class="line">less&lt;T1&gt;与greater&lt;T1&gt;  可以替换成其它的函数对象functor。</span><br><span class="line">可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。</span><br><span class="line">map.begin();  //返回容器中第一个数据的迭代器。</span><br><span class="line">map.end();  //返回容器中最后一个数据之后的迭代器。</span><br><span class="line">map.rbegin();  //返回容器中倒数第一个元素的迭代器。</span><br><span class="line">map.rend();   //返回容器中倒数最后一个元素的后面的迭代器。</span><br></pre></td></tr></table></figure><h4 id="map对象的拷贝构造与赋值"><a class="markdownIt-Anchor" href="#map对象的拷贝构造与赋值"></a> map对象的拷贝构造与赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map(const map &amp;mp);     //拷贝构造函数</span><br><span class="line">map&amp; operator=(const map &amp;mp);//重载等号操作符</span><br><span class="line">map.swap(mp);//交换两个集合容器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line">map&lt;int, string&gt; mapA;</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;));</span><br><span class="line"></span><br><span class="line">map&lt;int ,string&gt; mapB(mapA);//拷贝构造</span><br><span class="line"></span><br><span class="line">map&lt;int, string&gt; mapC;</span><br><span class="line">mapC = mapA;//赋值</span><br><span class="line"></span><br><span class="line">mapC[3] = &quot;老张&quot;;</span><br><span class="line">mapC.swap(mapA);//交换</span><br></pre></td></tr></table></figure><h4 id="map的大小"><a class="markdownIt-Anchor" href="#map的大小"></a> map的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.size();//返回容器中元素的数目</span><br><span class="line">map.empty();//判断容器是否为空</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int, string&gt; mapA;</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;));</span><br><span class="line"></span><br><span class="line">if (mapA.empty())</span><br><span class="line">&#123;</span><br><span class="line">int iSize = mapA.size();//iSize == 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map的删除"><a class="markdownIt-Anchor" href="#map的删除"></a> map的删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.clear();//删除所有元素</span><br><span class="line">map.erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">map.erase(beg,end);    //删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</span><br><span class="line">map.erase(keyElem);     //删除容器中key为keyElem的对组。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int, string&gt; mapA;</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;));</span><br><span class="line"></span><br><span class="line">//删除区间内的元素</span><br><span class="line">map&lt;int,string&gt;::iterator itBegin=mapA.begin();</span><br><span class="line">++ itBegin;</span><br><span class="line">++ itBegin;</span><br><span class="line">map&lt;int,string&gt;::iterator itEnd=mapA.end();</span><br><span class="line">mapA.erase(itBegin,itEnd);//此时容器mapA包含按顺序的&#123;1,&quot;小杨&quot;&#125;&#123;3,&quot;小张&quot;&#125;两个元素。</span><br><span class="line"></span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;));</span><br><span class="line">mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;));</span><br><span class="line"></span><br><span class="line">//删除容器中第一个元素</span><br><span class="line">mapA.erase(mapA.begin());//此时容器mapA包含了按顺序的&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;三个元素</span><br><span class="line"></span><br><span class="line">//删除容器中key为5的元素</span><br><span class="line">mapA.erase(5);    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//删除mapA的所有元素</span><br><span class="line">mapA.clear();//容器为空</span><br></pre></td></tr></table></figure><h4 id="map的查找"><a class="markdownIt-Anchor" href="#map的查找"></a> map的查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.find(key);   查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();</span><br><span class="line">map.count(keyElem);   //返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,string&gt;::iterator it=mapStu.find(3);</span><br><span class="line">if(it == mapStu.end())</span><br><span class="line">&#123;</span><br><span class="line">//没找到</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    //找到了</span><br><span class="line">        pair&lt;int, string&gt; pairStu = *it;</span><br><span class="line">  int iID = pairStu.first;//或   int  iID = it-&gt;first;</span><br><span class="line">        string strName = pairStu.second;//或   string strName = it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map.lower_bound(keyElem);  //返回第一个key&gt;=keyElem元素的迭代器。</span><br><span class="line">map.upper_bound(keyElem);   //  返回第一个key&gt;keyElem元素的迭代器。</span><br><span class="line">例如：  mapStu是用map&lt;int,string&gt;声明的容器，已包含&#123;1,&quot;小李&quot;&#125;&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;&#123;9,&quot;小陈&quot;&#125;元素。map&lt;int,string&gt;::iterator it;</span><br><span class="line">it = mapStu.lower_bound(5);  //it-&gt;first==5    it-&gt;second==&quot;小王&quot;</span><br><span class="line">it = mapStu.upper_bound(5);   //it-&gt;first==7   it-&gt;second==&quot;小赵&quot;</span><br><span class="line">it = mapStu.lower_bound(6);  //it-&gt;first==7    it-&gt;second==&quot;小赵&quot;</span><br><span class="line">it = mapStu.upper_bound(6);    //it-&gt;first==7   it-&gt;second==&quot;小赵&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。</span><br><span class="line"> </span><br><span class="line">以上函数返回两个迭代器，而这两个迭代器被封装在pair中。</span><br><span class="line"></span><br><span class="line">例如 map&lt;int,string&gt; mapStu;</span><br><span class="line">...  //往mapStu容器插入元素&#123;1,&quot;小李&quot;&#125;&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;&#123;9,&quot;小陈&quot;&#125;</span><br><span class="line">pair&lt; map&lt;int,string&gt;::iterator , map&lt;int,string&gt;::iterator &gt; pairIt = mapStu.equal_range(5);</span><br><span class="line">map&lt;int, string&gt;::iterator itBeg = pairIt.first;</span><br><span class="line">map&lt;int, string&gt;::iterator itEnd = pairIt.second;</span><br><span class="line">//此时 itBeg-&gt;first==5  ,  itEnd-&gt;first == 7,</span><br><span class="line">itBeg-&gt;second==&quot;小王&quot;, itEnd-&gt;second==&quot;小赵&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;map和multimap容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#map和multimap容器&quot;&gt;&lt;/a&gt; Map和multimap容器&lt;/h1&gt;
&lt;p&gt;map是标准的&lt;strong&gt;关联式&lt;/strong&gt;容器，一个map是
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>Set和multiset容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0085-Set%E5%92%8Cmultiset%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0085-Set和multiset容器/</id>
    <published>2021-07-05T06:17:49.000Z</published>
    <updated>2021-07-05T06:29:05.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="set和multiset容器"><a class="markdownIt-Anchor" href="#set和multiset容器"></a> Set和multiset容器</h1><p>set是一个<strong>集合</strong>容器，其中所包含的元素是<strong>唯一</strong>的，<strong>集合中的元素按一定的顺序排列</strong>。<strong>元素插入过程是按排序规则插入</strong>，所以不能指定插入位置。</p><p>set采用<strong>红黑树</strong>变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。</p><p>set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。</p><p>multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中<strong>同一值可以出现多次</strong>。</p><p>不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。</p><p>#include &lt;set&gt;</p><h4 id="setmultiset对象的默认构造"><a class="markdownIt-Anchor" href="#setmultiset对象的默认构造"></a> set/multiset对象的默认构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; setInt;            //一个存放int的set容器。</span><br><span class="line">set&lt;float&gt; setFloat;     //一个存放float的set容器。</span><br><span class="line">set&lt;string&gt; setString;     //一个存放string的set容器。</span><br><span class="line">multiset&lt;int&gt; mulsetInt;            //一个存放int的multi set容器。</span><br><span class="line">multi set&lt;float&gt; multisetFloat;     //一个存放float的multi set容器。</span><br><span class="line">multi set&lt;string&gt; multisetString;     //一个存放string的multi set容器。</span><br></pre></td></tr></table></figure><h4 id="set的插入与迭代器"><a class="markdownIt-Anchor" href="#set的插入与迭代器"></a> set的插入与迭代器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set.insert(elem);     //在容器中插入元素。</span><br><span class="line">set.begin();  //返回容器中第一个数据的迭代器。</span><br><span class="line">set.end();  //返回容器中最后一个数据之后的迭代器。</span><br><span class="line">set.rbegin();  //返回容器中倒数第一个元素的迭代器。</span><br><span class="line">set.rend();   //返回容器中倒数最后一个元素的后面的迭代器。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; setInt;</span><br><span class="line">setInt.insert(3); setInt.insert(1);setInt.insert(5);setInt.insert(2);</span><br><span class="line">for(set&lt;int&gt;::iterator it=setInt.begin(); it!=setInt.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">      int iItem = *it;</span><br><span class="line">      cout &lt;&lt; iItem;    //或直接使用cout &lt;&lt; *it</span><br><span class="line">&#125;</span><br><span class="line">//这样子便顺序输出  1 2 3 5。</span><br><span class="line"></span><br><span class="line">set.rbegin()与set.rend()</span><br></pre></td></tr></table></figure><h4 id="set集合的元素排序"><a class="markdownIt-Anchor" href="#set集合的元素排序"></a> Set集合的元素排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int,less&lt;int&gt; &gt;  setIntA;  //该容器是按升序方式排列元素。</span><br><span class="line">set&lt;int,greater&lt;int&gt;&gt; setIntB;   //该容器是按降序方式排列元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set&lt;int&gt; 相当于 set&lt;int,less&lt;int&gt;&gt;。</span><br><span class="line">less&lt;int&gt;与greater&lt;int&gt;中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。</span><br><span class="line">//疑问1：less&lt;&gt;与greater&lt;&gt;是什么？</span><br><span class="line"></span><br><span class="line">疑问2：如果set&lt;&gt;不包含int类型，而是包含自定义类型，set容器如何排序？</span><br><span class="line">要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫functor。</span><br><span class="line">下面将讲解什么是functor，functor的用法。</span><br><span class="line">使用stl提供的函数对象</span><br><span class="line">set&lt;int,greater&lt;int&gt;&gt; setIntB;   </span><br><span class="line">setIntB.insert(3);</span><br><span class="line">setIntB.insert(1);</span><br><span class="line">setIntB.insert(5);</span><br><span class="line">setIntB.insert(2);</span><br><span class="line">此时容器setIntB就包含了按顺序的5,3,2,1元素</span><br></pre></td></tr></table></figure><h4 id="函数对象functor的用法"><a class="markdownIt-Anchor" href="#函数对象functor的用法"></a> 函数对象functor的用法</h4><p>尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。</p><p>functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。</p><p>greater&lt;&gt;与less&lt;&gt;就是函数对象。</p><p>下面举出greater&lt;int&gt;的简易实现原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">struct greater</span><br><span class="line">&#123;</span><br><span class="line">bool operator() (const int&amp; iLeft, const int&amp; iRight)</span><br><span class="line">&#123;</span><br><span class="line">       return (iLeft&gt;iRight);    //如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">容器就是调用函数对象的operator()方法去比较两个值的大小。</span><br><span class="line"></span><br><span class="line">题目：学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。</span><br><span class="line"></span><br><span class="line">解：</span><br><span class="line">//学生类</span><br><span class="line">class CStudent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CStudent(int iID, string strName)</span><br><span class="line">&#123;</span><br><span class="line">m_iID = iID;</span><br><span class="line">m_strName = strName;</span><br><span class="line">&#125;</span><br><span class="line">     int m_iID;//学号</span><br><span class="line">     string m_strName; //姓名</span><br><span class="line">&#125;</span><br><span class="line">//为保持主题鲜明，本类不写拷贝构造函数，本类也不需要写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。</span><br><span class="line"></span><br><span class="line">//函数对象</span><br><span class="line">struct StuFunctor</span><br><span class="line">&#123;</span><br><span class="line">bool operator()  (const CStudent &amp;stu1, const CStudent &amp;stu2)</span><br><span class="line">&#123;</span><br><span class="line">return (stu1.m_iID&lt;stu2.m_iID);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//main函数</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;CStudent, StuFunctor&gt; setStu;</span><br><span class="line">setStu.insert(CStudent(3,&quot;小张&quot;));</span><br><span class="line">setStu.insert(CStudent(1,&quot;小李&quot;));</span><br><span class="line">setStu.insert(CStudent(5,&quot;小王&quot;));</span><br><span class="line">setStu.insert(CStudent(2,&quot;小刘&quot;));</span><br><span class="line">//此时容器setStu包含了四个学生对象，分别是按姓名顺序的“小李”，“小刘”，“小张”，“小王” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set对象的拷贝构造与赋值"><a class="markdownIt-Anchor" href="#set对象的拷贝构造与赋值"></a> set对象的拷贝构造与赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(const set &amp;st);     //拷贝构造函数</span><br><span class="line">set&amp; operator=(const set &amp;st);//重载等号操作符</span><br><span class="line">set.swap(st);//交换两个集合容器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; setIntA;</span><br><span class="line">setIntA.insert(3);</span><br><span class="line">setIntA.insert(1);</span><br><span class="line">setIntA.insert(7);</span><br><span class="line">setIntA.insert(5);</span><br><span class="line">setIntA.insert(9);</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; setIntB(setIntA);  //1 3 5 7 9</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; setIntC;</span><br><span class="line">setIntC = setIntA;//1 3 5 7 9</span><br><span class="line"></span><br><span class="line">setIntC.insert(6);</span><br><span class="line">setIntC.swap(setIntA);  //交换</span><br></pre></td></tr></table></figure><h4 id="set的大小"><a class="markdownIt-Anchor" href="#set的大小"></a> set的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set.size();//返回容器中元素的数目</span><br><span class="line">set.empty();//判断容器是否为空</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; setIntA;</span><br><span class="line">setIntA.insert(3);</span><br><span class="line">setIntA.insert(1);</span><br><span class="line">setIntA.insert(7);</span><br><span class="line">setIntA.insert(5);</span><br><span class="line">setIntA.insert(9);</span><br><span class="line"></span><br><span class="line">if (!setIntA.empty())</span><br><span class="line">&#123;</span><br><span class="line">int iSize = setIntA.size();//5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set的删除"><a class="markdownIt-Anchor" href="#set的删除"></a> set的删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set.clear();//清除所有元素</span><br><span class="line">set.erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">set.erase(beg,end);    //删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</span><br><span class="line">set.erase(elem);     //删除容器中值为elem的元素。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">删除区间内的元素</span><br><span class="line">setInt是用set&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9,11元素。</span><br><span class="line">set&lt;int&gt;::iterator itBegin=setInt.begin();</span><br><span class="line">++ itBegin;</span><br><span class="line">set&lt;int&gt;::iterator itEnd=setInt.begin();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">setInt.erase(itBegin,itEnd);</span><br><span class="line">//此时容器setInt包含按顺序的1,6,9,11四个元素。</span><br><span class="line"></span><br><span class="line">删除容器中第一个元素</span><br><span class="line">setInt.erase(setInt.begin());//6,9,11</span><br><span class="line"></span><br><span class="line">删除容器中值为9的元素</span><br><span class="line">set.erase(9);    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除setInt的所有元素</span><br><span class="line">setInt.clear();//容器为空</span><br></pre></td></tr></table></figure><h4 id="set的查找"><a class="markdownIt-Anchor" href="#set的查找"></a> set的查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set.find(elem);   //查找elem元素，返回指向elem元素的迭代器。</span><br><span class="line"></span><br><span class="line">set.count(elem);   //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。</span><br><span class="line"></span><br><span class="line">set.lower_bound(elem);  //返回第一个&gt;=elem元素的迭代器。</span><br><span class="line">set.upper_bound(elem);   //  返回第一个&gt;elem元素的迭代器。</span><br><span class="line">set.equal_range(elem);//返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。</span><br><span class="line"> </span><br><span class="line">以上函数返回两个迭代器，而这两个迭代器被封装在pair中。</span><br><span class="line">以下讲解pair的含义与使用方法。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; setInt;</span><br><span class="line">setInt.insert(3);</span><br><span class="line">setInt.insert(1);</span><br><span class="line">setInt.insert(7);</span><br><span class="line">setInt.insert(5);</span><br><span class="line">setInt.insert(9);</span><br><span class="line"></span><br><span class="line">set&lt;int&gt;::iterator itA = setInt.find(5);</span><br><span class="line">int iA = *itA;//iA == 5</span><br><span class="line">int iCount = setInt.count(5);//iCount == 1</span><br><span class="line"></span><br><span class="line">set&lt;int&gt;::iterator itB = setInt.lower_bound(5);</span><br><span class="line">set&lt;int&gt;::iterator itC = setInt.upper_bound(5);</span><br><span class="line">int iB = *itB;//iB == 5</span><br><span class="line">int iC = *itC; //iC == 7</span><br><span class="line"></span><br><span class="line">pair&lt; set&lt;int&gt;::iterator, set&lt;int&gt;::iterator &gt; pairIt = setInt.equal_range(5);  //pair是什么？</span><br></pre></td></tr></table></figure><h4 id="pair的使用"><a class="markdownIt-Anchor" href="#pair的使用"></a> pair的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair译为对组，可以将两个值视为一个单元。</span><br><span class="line">pair&lt;T1,T2&gt;存放的两个值的类型，可以不一样，如T1为int，T2为float。T1,T2也可以是自定义类型。</span><br><span class="line">pair.first是pair里面的第一个值，是T1类型。</span><br><span class="line">pair.second是pair里面的第二个值，是T2类型。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; setInt;</span><br><span class="line">...  //往setInt容器插入元素1,3,5,7,9</span><br><span class="line">pair&lt; set&lt;int&gt;::iterator , set&lt;int&gt;::iterator &gt; pairIt = setInt.equal_range(5);</span><br><span class="line">set&lt;int&gt;::iterator itBeg = pairIt.first;</span><br><span class="line">set&lt;int&gt;::iterator itEnd = pairIt.second;</span><br><span class="line">//此时 *itBeg==5  而  *itEnd == 7</span><br></pre></td></tr></table></figure><h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4><p>一、容器set/multiset的使用方法；</p><p>​              红黑树的变体，查找效率高，插入不能指定位置，插入时自动排序。</p><p>二、functor的使用方法；</p><p>类似于函数的功能，可用来自定义一些规则，如元素比较规则。</p><p>三、pair的使用方法。</p><p>​     对组，一个整体的单元，存放两个类型(T1,T2，T1可与T2一样)的两个元素。</p><p>案例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int x;</span><br><span class="line">   scanf(&quot;%ld&quot;,&amp;x);</span><br><span class="line">   multiset&lt;int&gt; h;//建立一个multiset类型，变量名是h，h序列里面存的是int类型,初始h为空</span><br><span class="line">   while(x!=0)&#123;</span><br><span class="line">       h.insert(x);//将x插入h中</span><br><span class="line">       scanf(&quot;%ld&quot;,&amp;x);</span><br><span class="line">   &#125;    </span><br><span class="line"></span><br><span class="line">pair&lt; multiset&lt;int&gt;::iterator , multiset&lt;int&gt;::iterator &gt; pairIt = h.equal_range(22);</span><br><span class="line">multiset&lt;int&gt;::iterator itBeg = pairIt.first;</span><br><span class="line">multiset&lt;int&gt;::iterator itEnd = pairIt.second;</span><br><span class="line"></span><br><span class="line">int nBeg = *itBeg;</span><br><span class="line">int nEnd = *itEnd;</span><br><span class="line"></span><br><span class="line">   while(!h.empty())&#123;// 序列非空h.empty()==true时表示h已经空了</span><br><span class="line">multiset&lt;int&gt;::iterator c = h.begin();//c指向h序列中第一个元素的地址，第一个元素是最小的元素</span><br><span class="line">       printf(&quot;%ld &quot;,*c);//将地址c存的数据输出</span><br><span class="line">       h.erase(c);//从h序列中将c指向的元素删除</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;set和multiset容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#set和multiset容器&quot;&gt;&lt;/a&gt; Set和multiset容器&lt;/h1&gt;
&lt;p&gt;set是一个&lt;strong&gt;集合&lt;/strong&gt;容器，其中所包含的元素
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>优先级队列priority_queue</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0084-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97priority-queue/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0084-优先级队列priority-queue/</id>
    <published>2021-07-05T06:02:34.000Z</published>
    <updated>2021-07-05T06:09:00.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先级队列priority_queue"><a class="markdownIt-Anchor" href="#优先级队列priority_queue"></a> 优先级队列priority_queue</h1><p>最大值优先级队列、最小值优先级队列</p><p>优先级队列适配器 STL priority_queue</p><p>用来开发一些特殊的应用,请对stl的类库,多做扩展性学习</p><p>默认是从大到小插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;int, deque&lt;int&gt;&gt; pq;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;&gt; pq;</span><br><span class="line">pq.empty()</span><br><span class="line">pq.size()</span><br><span class="line">pq.top()</span><br><span class="line">pq.pop()</span><br><span class="line">pq.push(item)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;queue&quot; </span><br><span class="line">void main81()</span><br><span class="line">&#123;</span><br><span class="line">priority_queue&lt;int&gt; p1; //默认是 最大值优先级队列 </span><br><span class="line">//priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; p1; //相当于这样写</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; p2; //最小值优先级队列</span><br><span class="line"></span><br><span class="line">p1.push(33);</span><br><span class="line">p1.push(11);</span><br><span class="line">p1.push(55);</span><br><span class="line">p1.push(22);</span><br><span class="line">cout &lt;&lt;&quot;队列大小&quot; &lt;&lt; p1.size() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt;&quot;队头&quot; &lt;&lt; p1.top() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">while (p1.size() &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p1.top() &lt;&lt; &quot; &quot;;</span><br><span class="line">p1.pop();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;测试 最小值优先级队列&quot; &lt;&lt; endl;</span><br><span class="line">p2.push(33);</span><br><span class="line">p2.push(11);</span><br><span class="line">p2.push(55);</span><br><span class="line">p2.push(22);</span><br><span class="line">while (p2.size() &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p2.top() &lt;&lt; &quot; &quot;;</span><br><span class="line">p2.pop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;优先级队列priority_queue&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#优先级队列priority_queue&quot;&gt;&lt;/a&gt; 优先级队列priority_queue&lt;/h1&gt;
&lt;p&gt;最大值优先级队列、最小值优先级队列&lt;/p&gt;
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>List容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0083-List%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0083-List容器/</id>
    <published>2021-07-05T05:52:34.000Z</published>
    <updated>2021-07-05T08:33:47.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="list容器"><a class="markdownIt-Anchor" href="#list容器"></a> List容器</h1><p>list是一个<strong>双向链表容器</strong>，可高效地进行插入删除元素。</p><p>list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok) it+5(err)</p><p>#include&lt;list&gt;</p><h4 id="list对象的默认构造"><a class="markdownIt-Anchor" href="#list对象的默认构造"></a> list对象的默认构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list采用采用模板类实现,对象的默认构造形式：list&lt;T&gt; lstT;  如：</span><br><span class="line">list&lt;int&gt; lstInt;            //定义一个存放int的list容器。</span><br><span class="line">list&lt;float&gt; lstFloat;     //定义一个存放float的list容器。</span><br><span class="line">list&lt;string&gt; lstString;     //定义一个存放string的list容器。</span><br><span class="line">...    </span><br><span class="line">//尖括号内还可以设置指针类型或自定义类型。</span><br></pre></td></tr></table></figure><h4 id="list头尾的添加移除操作"><a class="markdownIt-Anchor" href="#list头尾的添加移除操作"></a> list头尾的添加移除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.push_back(elem);   //在容器尾部加入一个元素</span><br><span class="line">list.pop_back();              //删除容器中最后一个元素</span><br><span class="line">list.push_front(elem);     //在容器开头插入一个元素</span><br><span class="line">list.pop_front();              //从容器开头移除第一个元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstInt;</span><br><span class="line">lstInt.push_back(1);</span><br><span class="line">lstInt.push_back(3);</span><br><span class="line">lstInt.push_back(5);</span><br><span class="line">lstInt.push_back(7);</span><br><span class="line">lstInt.push_back(9);</span><br><span class="line">lstInt.pop_front();</span><br><span class="line">lstInt.pop_front();</span><br><span class="line">lstInt.push_front(11);</span><br><span class="line">lstInt.push_front(13);</span><br><span class="line">lstInt.pop_back();</span><br><span class="line">lstInt.pop_back();</span><br><span class="line">// lstInt    &#123;13,11,5&#125;</span><br></pre></td></tr></table></figure><h4 id="list的数据存取"><a class="markdownIt-Anchor" href="#list的数据存取"></a> list的数据存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.front();   //返回第一个元素。</span><br><span class="line">list.back();  //返回最后一个元素。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstInt;</span><br><span class="line">lstInt.push_back(1);</span><br><span class="line">lstInt.push_back(3);</span><br><span class="line">lstInt.push_back(5);</span><br><span class="line">lstInt.push_back(7);</span><br><span class="line">lstInt.push_back(9);</span><br><span class="line"></span><br><span class="line">int iFront = lstInt.front();//1</span><br><span class="line">int iBack = lstInt.back();//9</span><br><span class="line">lstInt.front() = 11;//11</span><br><span class="line">lstInt.back() = 19;//19</span><br></pre></td></tr></table></figure><h4 id="list与迭代器"><a class="markdownIt-Anchor" href="#list与迭代器"></a> list与迭代器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.begin();                     //返回容器中第一个元素的迭代器。</span><br><span class="line">list.end();                       //返回容器中最后一个元素之后的迭代器。</span><br><span class="line">list.rbegin();         //返回容器中倒数第一个元素的迭代器。</span><br><span class="line">list.rend();         //返回容器中倒数最后一个元素的后面的迭代器。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstInt;</span><br><span class="line">lstInt.push_back(1);</span><br><span class="line">lstInt.push_back(3);</span><br><span class="line">lstInt.push_back(5);</span><br><span class="line">lstInt.push_back(7);</span><br><span class="line">lstInt.push_back(9);</span><br><span class="line"></span><br><span class="line">for (list&lt;int&gt;::iterator it=lstInt.begin(); it!=lstInt.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it;</span><br><span class="line">cout &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (list&lt;int&gt;::reverse_iterator rit=lstInt.rbegin(); rit!=lstInt.rend(); ++rit)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *rit;</span><br><span class="line">cout &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list对象的带参数构造"><a class="markdownIt-Anchor" href="#list对象的带参数构造"></a> list对象的带参数构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list(beg,end);    //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</span><br><span class="line">list(n,elem);   //构造函数将n个elem拷贝给本身。</span><br><span class="line">list(const list &amp;lst);  //拷贝构造函数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstIntA;</span><br><span class="line">lstIntA.push_back(1);</span><br><span class="line">lstIntA.push_back(3);</span><br><span class="line">lstIntA.push_back(5);</span><br><span class="line">lstIntA.push_back(7);</span><br><span class="line">lstIntA.push_back(9);</span><br><span class="line"></span><br><span class="line">list&lt;int&gt; lstIntB(lstIntA.begin(),lstIntA.end());//1 3 5 7 9</span><br><span class="line">list&lt;int&gt; lstIntC(5,8);//8 8 8 8 8 </span><br><span class="line">list&lt;int&gt; lstIntD(lstIntA);//1 3 5 7 9</span><br></pre></td></tr></table></figure><h4 id="list的赋值"><a class="markdownIt-Anchor" href="#list的赋值"></a> list的赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.assign(beg,end);    //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</span><br><span class="line">list.assign(n,elem);  //将n个elem拷贝赋值给本身。</span><br><span class="line">list&amp; operator=(const list &amp;lst);//重载等号操作符</span><br><span class="line">list.swap(lst);  // 将lst与本身的元素互换。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstIntA,lstIntB,lstIntC,lstIntD;</span><br><span class="line">lstIntA.push_back(1);</span><br><span class="line">lstIntA.push_back(3);</span><br><span class="line">lstIntA.push_back(5);</span><br><span class="line">lstIntA.push_back(7);</span><br><span class="line">lstIntA.push_back(9);</span><br><span class="line"></span><br><span class="line">lstIntB.assign(lstIntA.begin(),lstIntA.end());//1 3 5 7 9</span><br><span class="line">lstIntC.assign(5,8);//8 8 8 8 8</span><br><span class="line">lstIntD = lstIntA;//1 3 5 7 9</span><br><span class="line">lstIntC.swap(lstIntD);//互换</span><br></pre></td></tr></table></figure><h4 id="list的大小"><a class="markdownIt-Anchor" href="#list的大小"></a> list的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.size();   //返回容器中元素的个数</span><br><span class="line">list.empty();   //判断容器是否为空</span><br><span class="line">list.resize(num);   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">list.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstIntA;</span><br><span class="line">lstIntA.push_back(1);</span><br><span class="line">lstIntA.push_back(3);</span><br><span class="line">lstIntA.push_back(5);</span><br><span class="line"></span><br><span class="line">if (!lstIntA.empty())</span><br><span class="line">&#123;</span><br><span class="line">int iSize = lstIntA.size();//3</span><br><span class="line">lstIntA.resize(5);//1 3 5 0 0</span><br><span class="line">lstIntA.resize(7,1);//1 3 5 0 0 1 1</span><br><span class="line">lstIntA.resize(2);//1 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list的插入"><a class="markdownIt-Anchor" href="#list的插入"></a> list的插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.insert(pos,elem);   //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br><span class="line">list.insert(pos,n,elem);   //在pos位置插入n个elem数据，无返回值。</span><br><span class="line">list.insert(pos,beg,end);   //在pos位置插入[beg,end)区间的数据，无返回值。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstA;</span><br><span class="line">list&lt;int&gt; lstB;</span><br><span class="line"></span><br><span class="line">lstA.push_back(1);</span><br><span class="line">lstA.push_back(3);</span><br><span class="line">lstA.push_back(5);</span><br><span class="line">lstA.push_back(7);</span><br><span class="line">lstA.push_back(9);</span><br><span class="line"></span><br><span class="line">lstB.push_back(2);</span><br><span class="line">lstB.push_back(4);</span><br><span class="line">lstB.push_back(6);</span><br><span class="line">lstB.push_back(8);</span><br><span class="line"></span><br><span class="line">lstA.insert(lstA.begin(), 11);//&#123;11, 1, 3, 5, 7, 9&#125;</span><br><span class="line">lstA.insert(++lstA.begin(),2,33);//&#123;11,33,33,1,3,5,7,9&#125;</span><br><span class="line">lstA.insert(lstA.begin() , lstB.begin() , lstB.end() );//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span><br></pre></td></tr></table></figure><h4 id="list的删除"><a class="markdownIt-Anchor" href="#list的删除"></a> list的删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.clear();//移除容器的所有数据</span><br><span class="line">list.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">list.erase(pos);    //删除pos位置的数据，返回下一个数据的位置。</span><br><span class="line">list.remove(elem);   //删除容器中所有与elem值匹配的元素。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//删除区间内的元素</span><br><span class="line">lstInt是用list&lt;int&gt; //声明的容器，现已包含按顺序的1,3,5,6,9元素。</span><br><span class="line">list&lt;int&gt;::iterator itBegin=lstInt.begin();</span><br><span class="line">++ itBegin;</span><br><span class="line">list&lt;int&gt;::iterator itEnd=lstInt.begin();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">lstInt.erase(itBegin,itEnd);</span><br><span class="line">//此时容器lstInt包含按顺序的1,6,9三个元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//假设 lstInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素的方法一</span><br><span class="line">for(list&lt;int&gt;::iterator it=lstInt.being(); it!=lstInt.end(); )    //小括号里不需写  ++it</span><br><span class="line">&#123;</span><br><span class="line">   if(*it == 3)</span><br><span class="line">   &#123;</span><br><span class="line">        it  =  lstInt.erase(it);       //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span><br><span class="line">         //此时，不执行  ++it；  </span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">       ++it;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除容器中等于3的元素的方法二</span><br><span class="line">lstInt.remove(3);</span><br><span class="line"></span><br><span class="line">//删除lstInt的所有元素</span><br><span class="line">lstInt.clear();//容器为空</span><br></pre></td></tr></table></figure><h4 id="list的反序排列"><a class="markdownIt-Anchor" href="#list的反序排列"></a> list的反序排列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.reverse();     //反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lstA;</span><br><span class="line"></span><br><span class="line">lstA.push_back(1);</span><br><span class="line">lstA.push_back(3);</span><br><span class="line">lstA.push_back(5);</span><br><span class="line">lstA.push_back(7);</span><br><span class="line">lstA.push_back(9);</span><br><span class="line"></span><br><span class="line">lstA.reverse();//9 7 5 3 1</span><br></pre></td></tr></table></figure><h4 id="list排序"><a class="markdownIt-Anchor" href="#list排序"></a> list排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list.sort();//默认从小到大</span><br><span class="line">改变规则需要提供回调函数</span><br><span class="line">例如比较两个int类型的回调函数</span><br><span class="line"></span><br><span class="line">bool Compare(const int&amp; x,const int&amp; y) &#123;</span><br><span class="line">return x &gt; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool Compare(const int&amp; x,const int&amp; y) &#123;</span><br><span class="line">return x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line">list&lt;int&gt; li;</span><br><span class="line">li.push_back(10);</span><br><span class="line">li.push_back(20);</span><br><span class="line">li.push_back(40);</span><br><span class="line">li.push_back(1);</span><br><span class="line">li.push_back(2);</span><br><span class="line"></span><br><span class="line">li.sort(Compare);</span><br><span class="line"></span><br><span class="line">for (list&lt;int&gt;::iterator it = li.begin(); it != li.end();it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一、容器deque的使用方法</p><p>​     适合     在头尾添加移除元素。使用方法与vector类似。</p><p>二、容器queue,stack的使用方法</p><p>​     适合队列，堆栈的操作方式。</p><p>三、容器list的使用方法</p><p>​     适合在任意位置快速插入移除元素</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;list容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#list容器&quot;&gt;&lt;/a&gt; List容器&lt;/h1&gt;
&lt;p&gt;list是一个&lt;strong&gt;双向链表容器&lt;/strong&gt;，可高效地进行插入删除元素。&lt;/p&gt;
&lt;p&gt;list不可以随
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>Queue容器</title>
    <link href="https://xiaowuyoucy.github.io/2021/07/05/cpp0082-Queue%E5%AE%B9%E5%99%A8/"/>
    <id>https://xiaowuyoucy.github.io/2021/07/05/cpp0082-Queue容器/</id>
    <published>2021-07-05T05:48:08.000Z</published>
    <updated>2021-07-05T05:52:08.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="queue容器"><a class="markdownIt-Anchor" href="#queue容器"></a> Queue容器</h1><p>queue是队列容器，是一种“先进先出”的容器。</p><p>queue是简单地装饰deque容器而成为另外的一种容器。</p><p>#include &lt;queue&gt;</p><h4 id="queue对象的默认构造"><a class="markdownIt-Anchor" href="#queue对象的默认构造"></a> queue对象的默认构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue采用模板类实现，queue对象的默认构造形式：queue&lt;T&gt; queT;  如：</span><br><span class="line">queue&lt;int&gt; queInt;            //一个存放int的queue容器。</span><br><span class="line">queue&lt;float&gt; queFloat;     //一个存放float的queue容器。</span><br><span class="line">queue&lt;string&gt; queString;     //一个存放string的queue容器。</span><br><span class="line">...    </span><br><span class="line">//尖括号内还可以设置指针类型或自定义类型。</span><br></pre></td></tr></table></figure><h4 id="queue的push与pop方法"><a class="markdownIt-Anchor" href="#queue的push与pop方法"></a> queue的push()与pop()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.push(elem);   //往队尾添加元素</span><br><span class="line">queue.pop();   //从队头移除第一个元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;int&gt; queInt;</span><br><span class="line">queInt.push(1);queInt.push(3);</span><br><span class="line">queInt.push(5);queInt.push(7);</span><br><span class="line">queInt.push(9);queInt.pop();</span><br><span class="line">queInt.pop();</span><br><span class="line">此时queInt存放的元素是5,7,9</span><br></pre></td></tr></table></figure><h4 id="queue对象的拷贝构造与赋值"><a class="markdownIt-Anchor" href="#queue对象的拷贝构造与赋值"></a> queue对象的拷贝构造与赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue(const queue &amp;que);     //拷贝构造函数</span><br><span class="line">queue&amp; operator=(const queue &amp;que);//重载等号操作符</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;int&gt; queIntA;</span><br><span class="line">queIntA.push(1);</span><br><span class="line">queIntA.push(3);</span><br><span class="line">queIntA.push(5);</span><br><span class="line">queIntA.push(7);</span><br><span class="line">queIntA.push(9);</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; queIntB(queIntA);//拷贝构造</span><br><span class="line">queue&lt;int&gt; queIntC;</span><br><span class="line">queIntC = queIntA;//赋值</span><br></pre></td></tr></table></figure><h4 id="queue的数据存取"><a class="markdownIt-Anchor" href="#queue的数据存取"></a> queue的数据存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.back();   //返回最后一个元素</span><br><span class="line">queue.front();   //返回第一个元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;int&gt; queIntA;</span><br><span class="line">queIntA.push(1);</span><br><span class="line">queIntA.push(3);</span><br><span class="line">queIntA.push(5);</span><br><span class="line">queIntA.push(7);</span><br><span class="line">queIntA.push(9);</span><br><span class="line"></span><br><span class="line">int iFront = queIntA.front();//1</span><br><span class="line">int iBack = queIntA.back();//9</span><br><span class="line"></span><br><span class="line">queIntA.front() = 11;//11</span><br><span class="line">queIntA.back() = 19;//19</span><br></pre></td></tr></table></figure><h4 id="queue的大小"><a class="markdownIt-Anchor" href="#queue的大小"></a> queue的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.empty();   //判断队列是否为空</span><br><span class="line">queue.size();      //返回队列的大小</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;int&gt; queIntA; </span><br><span class="line">queIntA.push(1);   </span><br><span class="line">queIntA.push(3);  </span><br><span class="line">queIntA.push(5);</span><br><span class="line">queIntA.push(7);</span><br><span class="line">queIntA.push(9);</span><br><span class="line"></span><br><span class="line">if (!queIntA.empty())</span><br><span class="line">&#123;</span><br><span class="line">int iSize = queIntA.size();//5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;queue容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#queue容器&quot;&gt;&lt;/a&gt; Queue容器&lt;/h1&gt;
&lt;p&gt;queue是队列容器，是一种“先进先出”的容器。&lt;/p&gt;
&lt;p&gt;queue是简单地装饰deque容器而成为另外的一
      
    
    </summary>
    
      <category term="c++" scheme="https://xiaowuyoucy.github.io/categories/c/"/>
    
    
  </entry>
  
</feed>
