<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanChen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowuyoucy.github.io/"/>
  <updated>2022-05-13T21:24:27.912Z</updated>
  <id>https://xiaowuyoucy.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MYSQL基础知识</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/14/MYSQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/14/MYSQL基础知识/</id>
    <published>2022-05-13T21:24:27.000Z</published>
    <updated>2022-05-13T21:24:27.912Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker拉取oracle 11g镜像配置的详细教程</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/13/Docker%E6%8B%89%E5%8F%96oracle11g%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/13/Docker拉取oracle11g镜像配置的详细教程/</id>
    <published>2022-05-12T22:22:30.000Z</published>
    <updated>2022-05-12T22:40:13.437Z</updated>
    
    <content type="html"><![CDATA[<h4 id="docker拉取oracle数据库镜像"><a class="markdownIt-Anchor" href="#docker拉取oracle数据库镜像"></a> docker拉取oracle数据库镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search oracle</span><br></pre></td></tr></table></figure><p>查看可以使用docker拉取的oracle镜像；我是选择的Oracle12c这一款，truevoly/oracle-12c是复制之前的sath89/oracle-12c image镜像。</p><p><img src="../../themes/pure/source/images/javawz/5a025e6dda1a45f79592f8b8575a17c7.png" alt="在这里插入图片描述"></p><h3 id="开始拉取镜像-执行命令"><a class="markdownIt-Anchor" href="#开始拉取镜像-执行命令"></a> 开始拉取镜像-执行命令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</span><br></pre></td></tr></table></figure><p>下载完成后 查看镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="../../themes/pure/source/images/javawz/2021091810223023.png" alt="img"></p><h3 id="创建容器"><a class="markdownIt-Anchor" href="#创建容器"></a> 创建容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 1521:1521 --name oracle11g registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</span><br></pre></td></tr></table></figure><p><em><strong>参数 -d 后台运行容器，并返回容器ID ; -p 指定端口 , -v 指定数据卷位置</strong></em></p><p><em><strong>数据卷的特点：<br>1、可以供多个容器访问，直接共享或者重用<br>2、独立于容器周期，不会在删除容器时删除其挂载的数据卷<br>3、数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含的数据这些数据会复制到新的容器中<br>4、可以直接对数据卷里的内容进行修改</strong></em></p><p>这里说一下，命令后面的地址一定要是你下载的镜像地址也就是你拉取镜像名字，否则会出现名字已存在等问题！</p><p>​    如果创建成功能会返回容器id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ee92e88fea086c05af307d0274e1555ab04bfe747bb7b5b5e2198074bc40cdde</span><br></pre></td></tr></table></figure><h3 id="启动容器"><a class="markdownIt-Anchor" href="#启动容器"></a> 启动容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start oracle11g</span><br></pre></td></tr></table></figure><p><img src="../../themes/pure/source/images/javawz/2021091810223024.png" alt="img"></p><h3 id="进入镜像进行配置"><a class="markdownIt-Anchor" href="#进入镜像进行配置"></a> 进入镜像进行配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it oracle11g bash</span><br></pre></td></tr></table></figure><h3 id="创建软连接"><a class="markdownIt-Anchor" href="#创建软连接"></a> 创建软连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s $ORACLE_HOME/bin/sqlplus /usr/bin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//ctrl + p + q 退出容器（注意，不要exit退出，防止容器直接关闭了）</span><br></pre></td></tr></table></figure><h3 id="查看容器运行状态"><a class="markdownIt-Anchor" href="#查看容器运行状态"></a> 查看容器运行状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE                 COMMAND             CREATED         STATUS         PORTS                                                                                                                         NAMES</span><br><span class="line">ee92e88fea08   truevoly/oracle-12c   &quot;/entrypoint.sh &quot;   6 minutes ago   Up 6 minutes   0.0.0.0:1521-&gt;1521/tcp, :::1521-&gt;1521/tcp, 0.0.0.0:2122-&gt;22/tcp, :::2122-&gt;22/tcp, 0.0.0.0:9090-&gt;8080/tcp, :::9090-&gt;8080/tcp   oracle12c</span><br><span class="line">//进入容器内部</span><br><span class="line">[root@localhost ~]# docker exec -it ee92e88fea08 /bin/bash</span><br><span class="line">//切换成oracle用户</span><br><span class="line">root@ee92e88fea08:/# su oracle</span><br><span class="line">//进入sqlplus</span><br><span class="line">oracle@ee92e88fea08:/$ $ORACLE_HOME/bin/sqlplus / as sysdba</span><br><span class="line"></span><br><span class="line">SQL*Plus: Release 12.1.0.2.0 Production on Sun Aug 1 03:15:37 2021</span><br><span class="line"></span><br><span class="line">Copyright (c) 1982, 2014, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Connected to:</span><br><span class="line">Oracle Database 12c Standard Edition Release 12.1.0.2.0 - 64bit Production</span><br><span class="line">//设置密码有效期为无限制</span><br><span class="line">SQL&gt; ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;</span><br><span class="line"></span><br><span class="line">Profile altered.</span><br><span class="line">//解锁system用户</span><br><span class="line">SQL&gt; alter user SYSTEM account unlock;</span><br><span class="line"></span><br><span class="line">User altered.</span><br><span class="line">//创建一个账号为test_lx的用户密码设置为test_lx</span><br><span class="line">SQL&gt; create user test_lx identified by test_lx;     </span><br><span class="line"></span><br><span class="line">User created.</span><br><span class="line">//为这个用户赋予管理员的权限</span><br><span class="line">SQL&gt; grant dba to test_lx;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br><span class="line"></span><br><span class="line">SQL&gt; read escape sequence</span><br><span class="line"></span><br><span class="line">//ctrl + p + q 退出容器（注意，不要exit退出，防止容器直接关闭了）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;docker拉取oracle数据库镜像&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker拉取oracle数据库镜像&quot;&gt;&lt;/a&gt; docker拉取oracle数据库镜像&lt;/h4&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>同义词</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/13/%E5%90%8C%E4%B9%89%E8%AF%8D/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/13/同义词/</id>
    <published>2022-05-12T22:14:01.000Z</published>
    <updated>2022-05-12T22:20:21.890Z</updated>
    
    <content type="html"><![CDATA[<p>同义词:<br>1 什么是同义词:<br>同义词就是别名.</p><p>2 同义词使用的场合.</p><p>xiaohong想访问scott用户的emp表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 需要scott用户给xiaohong赋访问emp表的权限:</span><br><span class="line">grant select on emp to xiaohong;</span><br><span class="line">然后使用xiaohong用户登录oracle:</span><br><span class="line">sqlplus xiaohong/xiaohong@oracle;</span><br><span class="line">SQL&gt; select * from scott.emp;</span><br><span class="line">为了在访问scott.emp表的时候不用再使用scott.emp,可以给scott.emp创建同义词;</span><br></pre></td></tr></table></figure><p>3 如何创建同义词:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create synonym 同义词名 for 用户名.表名;</span><br><span class="line">create synonym emp for scott.emp;</span><br></pre></td></tr></table></figure><p>如何创建一个新的oracle用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用sys用户创建新的用户和给这个新用户添加权限:</span><br><span class="line">create user 用户名 identified by 密码;</span><br><span class="line">grant connect, resource to 用户名;  --给用户添加连接权限,如果一个新用户没有连接权限的话,是无法连接到这个用户的</span><br><span class="line">grant create synonym to 用户名;     --给用户添加创建同义词的权限</span><br><span class="line"></span><br><span class="line">create user xiaohei identified by xiaohei;</span><br><span class="line">grant connect, resource to xiaohei;</span><br><span class="line">grant create synonym to xiaohei;</span><br></pre></td></tr></table></figure><p>4 删除同义词:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop synonym 同义词名;</span><br><span class="line">drop synonym emp;</span><br></pre></td></tr></table></figure><p>5 查询同义词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select synonym_name from user_synonyms;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;同义词:&lt;br&gt;
1 什么是同义词:&lt;br&gt;
同义词就是别名.&lt;/p&gt;
&lt;p&gt;2 同义词使用的场合.&lt;/p&gt;
&lt;p&gt;xiaohong想访问scott用户的emp表:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>序列</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/13/%E5%BA%8F%E5%88%97/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/13/序列/</id>
    <published>2022-05-12T21:56:38.000Z</published>
    <updated>2022-05-12T23:51:22.509Z</updated>
    
    <content type="html"><![CDATA[<p>可以理解成数组：默认，从[1]开始，长度[20][1, 2, 3, 4, 5, 6, …, 20]在内存中。</p><p>由于序列是被保存在内存中，访问内存的速率要高于访问硬盘的速率。所以序列可以提高效率。</p><p>序列:<br>1 序列的用处:<br>由于表的主键要求是非空且唯一的, 为了保证主键是非空和唯一的, 可以使用序列.</p><p>​2 创建序列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create sequence 序列名;</span><br><span class="line">create sequence seq_mytest;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- Create sequence </span><br><span class="line">create sequence 序列名</span><br><span class="line">minvalue 最小值</span><br><span class="line">maxvalue 最大值</span><br><span class="line">start with 1  --开始值</span><br><span class="line">increment by 1  --步长</span><br><span class="line">cache 20;--容器大小</span><br><span class="line"></span><br><span class="line">-- Create sequence </span><br><span class="line">create sequence MYSEQ</span><br><span class="line">minvalue 1</span><br><span class="line">maxvalue 9999999999999999999999999999</span><br><span class="line">start with 1</span><br><span class="line">increment by 1</span><br><span class="line">cache 20;</span><br></pre></td></tr></table></figure><p>3 序列的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">currval 和 nextval, 但是第一次使用的时候先要取nextval的值.</span><br><span class="line"></span><br><span class="line">序列名.currval  //获取当前序列</span><br><span class="line">序列名.nextval  //获取下一个序列</span><br><span class="line"></span><br><span class="line">查看序列</span><br><span class="line">select 序列名.currval from dual;--duan是伪表</span><br><span class="line">select 序列名.nextval from dual;</span><br></pre></td></tr></table></figure><p>4 删除序列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop sequence 序列名;</span><br><span class="line">drop sequence seq_mytest;</span><br></pre></td></tr></table></figure><p>查看序列代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit 序列名</span><br></pre></td></tr></table></figure><p>查看序列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sequence_name from user_sequences;</span><br></pre></td></tr></table></figure><p>查询序列的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user_sequences;   --user_sequences为数据字典视图。</span><br></pre></td></tr></table></figure><p>查看序列属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit 序列名</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可以理解成数组：默认，从[1]开始，长度[20]		[1, 2, 3, 4, 5, 6, …, 20]		在内存中。&lt;/p&gt;
&lt;p&gt;由于序列是被保存在内存中，访问内存的速率要高于访问硬盘的速率。所以序列可以提高效率。&lt;/p&gt;
&lt;p&gt;序列:&lt;br&gt;
1 序列的用处:&lt;br&gt;

      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>索引</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/13/%E7%B4%A2%E5%BC%95/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/13/索引/</id>
    <published>2022-05-12T21:50:24.000Z</published>
    <updated>2022-05-12T21:56:09.862Z</updated>
    
    <content type="html"><![CDATA[<p>索引:使用是索引的目的是提高查询的效率.</p><p>索引，相当于书的目录，提高数据检索速度。提高效率（视图不可以提高效率）</p><ul><li>一种独立于表的模式对象, 可以存储在与表不同的磁盘或表空间中</li><li>索引被删除或损坏, 不会对表产生影响, 其影响的只是查询的速度</li><li>索引一旦建立, Oracle 管理系统会对其进行自动维护, 而且由 Oracle 管理系统决定何时使用索引. 用户不用在查询语句中指定使用哪个索引</li><li>在删除一个表时, 所有基于该表的索引会自动被删除</li><li>通过指针加速 Oracle 服务器的查询速度</li><li>通过快速定位数据的方法，减少磁盘 I/O</li></ul><p>1 创建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create index 索引名 on 表名(列名);</span><br><span class="line"></span><br><span class="line">create index idx_emp on emp(empno);</span><br><span class="line"></span><br><span class="line">--emp(empno)  表名(列名)  一般列名使用主键列</span><br></pre></td></tr></table></figure><p>2 删除索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop index 索引名;</span><br><span class="line">drop index idx_emp_bak;</span><br></pre></td></tr></table></figure><p>3 查询创建的索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select index_name from user_indexes;</span><br><span class="line">select xxxx_name from user_xxxxs;</span><br></pre></td></tr></table></figure><p>4 索引的原理?<br>在查询的时候, where条件后面要使用创建索引的时候的列, oracle先查询索引表,<br>从索引表中找到该列的值对应的rowid, 找到rowid再从表中根据rowid找到那一行记录.<br>5 注意点:<br>创建索引的列最后是值的分布很广泛且重复的概率很低.</p><p>​</p><p>下列情况不要创建索引:</p><ul><li>表很小</li><li>列不经常作为连接条件或出现在WHERE子句中</li><li>查询的数据大于2%到4%</li><li>表经常更新</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;索引:使用是索引的目的是提高查询的效率.&lt;/p&gt;
&lt;p&gt;索引，相当于书的目录，提高数据检索速度。提高效率（视图不可以提高效率）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种独立于表的模式对象, 可以存储在与表不同的磁盘或表空间中&lt;/li&gt;
&lt;li&gt;索引被删除或损坏, 不会对表产生影响, 
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>视图</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/13/%E8%A7%86%E5%9B%BE/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/13/视图/</id>
    <published>2022-05-12T21:42:28.000Z</published>
    <updated>2022-05-12T21:49:28.654Z</updated>
    
    <content type="html"><![CDATA[<p>视图:<br>1 什么是视图:<br>视图本身没有数据, 数据存储在表中</p><p>​2 如何创建视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create view vm_emp as select * from emp;</span><br><span class="line"></span><br><span class="line">create or replace view vm_emp as select * from emp;</span><br><span class="line">create or replace view vm_emp as select deptno, empno, ename from emp where deptno=10;</span><br><span class="line">--  or replace代表如果视图存在,就替换</span><br><span class="line">--查看视图</span><br><span class="line">select view_name from user_views;</span><br></pre></td></tr></table></figure><p>​添加创建视图权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">添加步骤：</span><br><span class="line">1.使用管理员登陆：sqlplus / as sysdba </span><br><span class="line">2.给scott用户增加权限：SQL&gt;  grant create view to scott;  </span><br><span class="line">3.执行“/”可成功创建视图empincomeview。 </span><br><span class="line">4.视图的操作和表的操作完全一样。SQL&gt;  select * from empincomeview;</span><br></pre></td></tr></table></figure><p>3 如何删除视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop view 视图名;</span><br><span class="line">drop view vm_emp;</span><br></pre></td></tr></table></figure><p>4 使用视图的优点:</p><p>可以限制用户对某些数据的访问;<br>可以简化查询;</p><p>5 使用视图注意点:</p><p>不要通过视图去修改表的数据.<br>可以将视图设置为只读属性:with read only</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create or replace view vm_emp as select * from emp with read only;</span><br></pre></td></tr></table></figure><p>查看视图代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit 视图名</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;视图:&lt;br&gt;
1 什么是视图:&lt;br&gt;
视图本身没有数据, 数据存储在表中&lt;/p&gt;
&lt;p&gt;​	2 如何创建视图&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>表的创建和管理</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/13/%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/13/表的创建和管理/</id>
    <published>2022-05-12T19:16:25.000Z</published>
    <updated>2022-05-12T20:10:52.563Z</updated>
    
    <content type="html"><![CDATA[<p>创建前提条件：表空间的使用权限和create table的权限</p><p>基本的数据存储集合，由行和列组成。表名和列名遵循如下命名规则：</p><ul><li>必须<strong>以字母开头</strong></li><li>必须在 <strong>1–30</strong> 个字符之间</li><li>必须只能包含 <strong>A–Z, a–z, 0–9, _, $,</strong> 和 <strong>#</strong></li><li>必须不能和用户定义的其他对象重名</li><li>必须不能是Oracle 的保留字</li><li><strong>Oracle</strong>默认存储是都存为大写</li><li>数据库名只能是1~8位，datalink可以是128位，和其他一些特殊字符</li></ul><h4 id="创建表的数据类型"><a class="markdownIt-Anchor" href="#创建表的数据类型"></a> 创建表的数据类型</h4><p><img src="../../themes/pure/source/images/javawz/wps37AF.tmp.jpg" alt="img"></p><p>rowid：行地址 ——伪列</p><h4 id="查看行地址"><a class="markdownIt-Anchor" href="#查看行地址"></a> 查看行地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rowid, empno, deptno from emp</span><br></pre></td></tr></table></figure><h4 id="创建表的语句"><a class="markdownIt-Anchor" href="#创建表的语句"></a> 创建表的语句:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(列名 类型, ...,列名 类型);</span><br><span class="line"></span><br><span class="line">create table tbl(id number, name varchar2(20));</span><br><span class="line">insert into tbl values(01, &apos;xiaoliu&apos;);</span><br></pre></td></tr></table></figure><h4 id="在创建表的时候为某一列设置默认值"><a class="markdownIt-Anchor" href="#在创建表的时候为某一列设置默认值"></a> 在创建表的时候为某一列设置默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table tbl(id number, name varchar2(20), hiredate date default sysdate);</span><br><span class="line">//hiredate date default sysdate 如果hiredate为空,默认使用系统日期值</span><br><span class="line"></span><br><span class="line">insert into tbl(id, name) values(02, &apos;xiaohong&apos;);  ---若没有插入hiredate的值, 则使用默认值</span><br></pre></td></tr></table></figure><h4 id="通过已有的表创建一个表-相当于表结构的复制"><a class="markdownIt-Anchor" href="#通过已有的表创建一个表-相当于表结构的复制"></a> 通过已有的表创建一个表, 相当于表结构的复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table tbl_bak as select * from tbl where 1=2;</span><br></pre></td></tr></table></figure><h3 id="修改表"><a class="markdownIt-Anchor" href="#修改表"></a> 修改表</h3><h4 id="增加一个列"><a class="markdownIt-Anchor" href="#增加一个列"></a> 增加一个列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 列名 类型;</span><br><span class="line"></span><br><span class="line">alter table tbl add email varchar2(30);</span><br></pre></td></tr></table></figure><h4 id="修改列属性"><a class="markdownIt-Anchor" href="#修改列属性"></a> 修改列属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 modify 列名 要修改的类型;</span><br><span class="line">alter table tbl modify email varchar2(40);</span><br></pre></td></tr></table></figure><h4 id="重命名列"><a class="markdownIt-Anchor" href="#重命名列"></a> 重命名列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 rename column 旧列名 to 新列名;</span><br><span class="line">alter table tbl rename column email to address;</span><br></pre></td></tr></table></figure><h4 id="删除列"><a class="markdownIt-Anchor" href="#删除列"></a> 删除列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop column 列名;</span><br><span class="line">alter table tbl drop column address;</span><br></pre></td></tr></table></figure><h4 id="表名的重命名"><a class="markdownIt-Anchor" href="#表名的重命名"></a> 表名的重命名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename 旧表名 to 新表名;</span><br><span class="line">rename t1 to t2;</span><br></pre></td></tr></table></figure><h4 id="删除表"><a class="markdownIt-Anchor" href="#删除表"></a> 删除表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;       --删除的表可以闪回</span><br><span class="line">drop table 表名 purge; --purge的作用删除不经过回收站, 删除的表不可以闪回</span><br><span class="line"></span><br><span class="line">drop table tbl;       --删除的表可以闪回</span><br><span class="line">drop table tbl purge; --purge的作用删除不经过回收站, 删除的表不可以闪回</span><br></pre></td></tr></table></figure><h4 id="表的闪回删除的表恢复回来"><a class="markdownIt-Anchor" href="#表的闪回删除的表恢复回来"></a> 表的闪回:删除的表恢复回来</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实现过程: </span><br><span class="line">1 create table tbl(id number, name varchar2(20));</span><br><span class="line">2 drop table tbl;</span><br><span class="line">3 select * from tab;    ---看tname那一列</span><br><span class="line">4 show recyclebin;      ----看ORIGINAL NAME那一列</span><br><span class="line">5 flashback table tbl to before drop;</span><br><span class="line"></span><br><span class="line">假如: drop table tbl purge; 则不能闪回了</span><br><span class="line">   1 drop table tbl purge;</span><br><span class="line">   2 select * from tab;</span><br><span class="line">   3 show recyclebin;</span><br><span class="line">   4 flashback table tbl to before drop;</span><br></pre></td></tr></table></figure><h3 id="表的约束"><a class="markdownIt-Anchor" href="#表的约束"></a> 表的约束:</h3><p>表的约束（5种）：<br>○ 检查 (值是否符合预设的规则)<br>○ 非空 (not null)<br>○ 唯一 (不能重复)<br>○ 主键（非空+唯一）<br>○ 外键 (取值必须在另外一个表中存在)</p><p>如不给约束指定起名，那么oracle会自动给约束起名</p><p>为测试方便, 新建一个表, 与dept一样, 并添加主键(做就要是为了测试外键)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table dept_bak as select * from dept;</span><br><span class="line">alter table dept_bak add constraint pk_dept_bak primary key (DEPTNO);</span><br></pre></td></tr></table></figure><p>使用约束的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table student(</span><br><span class="line">id number constraint pk_student primary key,   ---主键(非空唯一)</span><br><span class="line">name varchar2(30)  not null,                   --非空</span><br><span class="line">email varchar2(30) unique,                     --唯一</span><br><span class="line">sex varchar2(10) check(sex in (&apos;男&apos;,&apos;女&apos;)),    --check约束</span><br><span class="line">sal number check(sal&gt;10000),                   --check约束</span><br><span class="line">deptno number(2) references dept_bak(deptno) on delete set null  --当dept_bak表的数据被删除以后, 该列设置为null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">REFERENCES: 标示在父表中的列</span><br><span class="line">ON DELETE CASCADE(级联删除): 当父表中的列被删除时，子表中相对应的列也被删除</span><br><span class="line">ON DELETE SET NULL(级联置空): 子表中相应的列置空</span><br></pre></td></tr></table></figure><p>给hiredate设置默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student add hiredate date default sysdate;</span><br></pre></td></tr></table></figure><p>1 验证主键: 分两方面验证, 非空和唯一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先正常插入一条记录: </span><br><span class="line">insert into student(id, name, email, sex, sal, deptno) values(1000, &apos;xiaohong&apos;, &apos;helloworld@163.com&apos;, &apos;女&apos;, &apos;10001&apos;, 10);</span><br><span class="line"></span><br><span class="line">验证主键唯一性: </span><br><span class="line">insert into student(id, name, email, sex, sal, deptno) values(1000, &apos;xiaohong&apos;, &apos;helloworld@163.com&apos;, &apos;女&apos;, &apos;10001&apos;, 10);--报错, 1000与刚刚插入成功的重复了</span><br></pre></td></tr></table></figure><p>验证主键非空:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into student(id, name, email, sex, sal, deptno) values(null, &apos;xiaohong&apos;, &apos;helloworld@163.com&apos;, &apos;女&apos;, &apos;10001&apos;, 10);</span><br></pre></td></tr></table></figure><p>2 验证非空: 使用name来进行验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into student(id, name, email, sex, sal, deptno) values(1001, null, &apos;hello@163.com&apos;, &apos;女&apos;, &apos;10001&apos;, 10);</span><br></pre></td></tr></table></figure><p>3 验证唯一性: 通过email进行验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into student(id, name, email, sex, sal, deptno) values(1001, &apos;xiaoliu&apos;, &apos;helloworld@163.com&apos;, &apos;女&apos;, &apos;10001&apos;, 10);</span><br></pre></td></tr></table></figure><p>4 验证check约束: 使用sex和sal进行验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into student(id, name, email, sex, sal, deptno) values(1001, &apos;xiaoliu&apos;, &apos;xiaofang@163.com&apos;, &apos;无&apos;, &apos;10001&apos;, 10);   </span><br><span class="line">--sex违反check条件,sex只能取&apos;男&apos;,&apos;女&apos;</span><br><span class="line"></span><br><span class="line">insert into student(id, name, email, sex, sal, deptno) values(1001, &apos;xiaoliu&apos;, &apos;xiaoyuan@163.com&apos;, &apos;女&apos;, 9000, 10);    </span><br><span class="line">--sal违反check条件,sal&gt;10000</span><br></pre></td></tr></table></figure><p>5 验证外键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into student(id, name, email, sex, sal, deptno) values(1002, &apos;xiaoliu&apos;, &apos;xiaohua@163.com&apos;, &apos;女&apos;, &apos;10001&apos;, 11);   </span><br><span class="line">---dept表中不存在deptno为11的部门编号</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a--cascade 级联删除, 主表记录删除的时候, 子表数据跟着删除</span><br><span class="line">b--drop table dept_bak cascade constraints;</span><br><span class="line">c--set null  设置为null, 主表删除的时候，子表该字段设为null</span><br><span class="line">d--默认方式, 主表删除的时候, 如果子表引用了该字段的数据, 不能删除, 先删子表, 后删主表</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建前提条件：表空间的使用权限和create table的权限&lt;/p&gt;
&lt;p&gt;基本的数据存储集合，由行和列组成。表名和列名遵循如下命名规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须&lt;strong&gt;以字母开头&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;必须在 &lt;strong&gt;1–30&lt;/s
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/12/%E4%BA%8B%E5%8A%A1/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/12/事务/</id>
    <published>2022-05-11T22:06:16.000Z</published>
    <updated>2022-05-11T22:19:23.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-事务"><a class="markdownIt-Anchor" href="#11-事务"></a> <strong>1.1</strong> 事务</h2><p>数据库事务，是由有限的数据库操作序列组成的逻辑执行单元，这一系列操作要么全部执行，要么全部放弃执行。</p><p>数据库事务由以下的部分组成:</p><p>一个或多个DML语句</p><p>一个 DDL(Data Definition Language – 数据定义语言) 语句</p><p>一个 DCL(Data Control Language – 数据控制语言) 语句</p><p>事务的特点：要么都成功，要么都失败。</p><h3 id="事务的特性"><a class="markdownIt-Anchor" href="#事务的特性"></a> 事务的特性</h3><p>事务4大特性(ACID) ：原子性、一致性、隔离性、持久性。</p><p>​原子性 (Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。</p><p>​一致性 (Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。</p><p>​隔离性 (Isolation)：事务的执行不受其他事务的干扰，当数据库被多个客户端并发访问时，隔离它们的操作，防止出现：脏读、幻读、不可重复读。</p><p>​持久性 (Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。</p><p>事务的起始标志：Oracle中自动开启事务，以DML语句为开启标志。</p><p>​执行一个增删改查语句，只要没有提交commit和回滚rollback，操作都在一个事务中。</p><p>事务的结束标志：提交、回滚都是事务的结束标志。</p><p>​提交：显示提交：commit</p><p>​隐式提交：1. 有DDL语句，如：create table除了创建表之外还会隐式提交Create之前所有没有提交的DML语句。 2. 正常退出(exit / quit)</p><p>​回滚：显示回滚：rollback</p><p>​隐式回滚：掉电、宕机、非正常退出。</p><h3 id="控制事务"><a class="markdownIt-Anchor" href="#控制事务"></a> 控制事务</h3><p>savepoint</p><p>​保存点（savepoint）可以防止错误操作影响整个事务，方便进行事务控制。</p><p><img src="/images/javawz/wpsE205.tmp.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【示例】：1. SQL&gt; create table testsp ( tid number, tname varchar2(20));  DDL语句会隐式commit之前操作</span><br><span class="line"> 2. set feedback on      打开回显</span><br><span class="line"> 3. insert into testsp values(1, &apos;Tom&apos;)      </span><br><span class="line"> 4. insert into testsp values(2, &apos;Mary&apos;)      </span><br><span class="line"> 5. savepoint aaa    </span><br><span class="line"> 6. insert into testsp values(3, &apos;Moke&apos;) 故意将“Mike”错写成“Moke”。</span><br><span class="line"> 7. select * from testsp 三条数据都显示出来。</span><br><span class="line"> 8. rollback to savepoint aaa 回滚到保存点aaa</span><br><span class="line"> 9. select * from testsp 发现表中的数据保存到第二条操作结束的位置</span><br><span class="line">需要注意，前两次的操作仍然没有提交。如操作完成应该显示的执行 commit 提交。</span><br><span class="line"></span><br><span class="line">savepoint主要用于在事务上下文中声明一个中间标记，将一个长事务分隔为多个较小的部分，和我们编写文档时，习惯性保存一下一样，都是为了防止出错和丢失。如果保存点设置名称重复，则会删除之前的那个保存点。一旦commit之后，savepoint将失效。</span><br></pre></td></tr></table></figure><p>事物的隔离级别: 了解oracle是读已提交数据, mysql是可重复读.</p><p>保存点:使用保存点的目的是把一个大的事物分成几段进行保存,<br>类似于编写word文档的时候使用ctrl+s分段保存.</p><h4 id="以实验的方式说明保存点的作用"><a class="markdownIt-Anchor" href="#以实验的方式说明保存点的作用"></a> 以实验的方式说明保存点的作用:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">create table testsp (tid number, tname varchar2(20)); </span><br><span class="line">   insert into testsp values(1, &apos;Tom&apos;);</span><br><span class="line">insert into testsp values(2, &apos;Mary&apos;);</span><br><span class="line">savepoint aaa;</span><br><span class="line">insert into testsp values(3, &apos;Moke&apos;);</span><br><span class="line">savepoint bbb;</span><br><span class="line">update testsp set tname=&apos;tomson&apos; where tid=1;</span><br><span class="line">delete from testsp where tid=1;</span><br><span class="line">rollback to savepoint bbb;</span><br><span class="line">SQL&gt; select * from testsp;</span><br><span class="line"></span><br><span class="line">       TID TNAME</span><br><span class="line">---------- --------------------</span><br><span class="line">         1 Tom</span><br><span class="line">         2 Mary</span><br><span class="line">         3 Moke</span><br><span class="line">rollback to savepoint aaa;--此时不能再回退到bbb</span><br><span class="line"></span><br><span class="line">rollback ;--事务结束</span><br><span class="line">select * from testsp;</span><br><span class="line">**说明: 当执行commit或者rollback后保存点就会全部无效了.</span><br></pre></td></tr></table></figure><h3 id="隔离级别"><a class="markdownIt-Anchor" href="#隔离级别"></a> 隔离级别</h3><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><p><strong>•</strong> <strong>脏读</strong>: 对于两个事物 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的.</p><p><strong>•</strong> <strong>不可重复读</strong>: 对于两个事物 T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段. 之后, T1再次读取同一个字段, 值就不同了.</p><p><strong>•</strong> <strong>幻读</strong>: 对于两个事物 T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行.</p><p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.</p><p>一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱</p><p>​</p><p>SQL99定义4中隔离级别：</p><p>​1. Read Uncommitted读未提交数据。(人家还没有提交你就查到了,一般不允许这样的)</p><ol start="2"><li><p>Read Commited读已提交数据。（Oracle默认）</p><pre><code> 3.Repeatable Read可重复读。（MySQL默认） 4.Serializable序列化、串行化。 （查询也要等前一个事务结束）</code></pre></li></ol><p>这4种MySQL都支持</p><p>Oracle支持的隔离级别： Read Commited（默认）和 Serializable，以及Oracle自定义的Read Only三种。</p><p>Read Only：由于大多数情况下，在事务操作的过程中，不希望别人也来操作，但是如果将别人的隔离级别设置为Serializable（串行），但是单线程会导致数据库的性能太差。是应该允许别人来进行read操作的。</p><h4 id="这是两个事务"><a class="markdownIt-Anchor" href="#这是两个事务"></a> 这是两个事务</h4><p><img src="/images/javawz/image-20220512061906975.png" alt="image-20220512061906975"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-事务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-事务&quot;&gt;&lt;/a&gt; &lt;strong&gt;1.1&lt;/strong&gt; 事务&lt;/h2&gt;
&lt;p&gt;数据库事务，是由有限的数据库操作序列组成的逻辑执行单元，这一系列操作要么全部执行，要么全部
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>数据处理</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/12/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/12/数据处理/</id>
    <published>2022-05-11T20:41:56.000Z</published>
    <updated>2022-05-11T21:41:33.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sql语言的类型"><a class="markdownIt-Anchor" href="#sql语言的类型"></a> sql语言的类型</h3><p>​  DML data manipulation language  数据操作语言，对应增删改查<br>​  DDL  data definition language  数据定义语言 create, drop, truncate<br>​  DCL  data control language 数据控制语言 grant, revoke, commit, rollback</p><ol><li>数据库中，称呼增删改查，为DML语句。(Data Manipulation Language 数据操纵语言)，就是指代：</li></ol><p>​insert、update、delete、select这四个操作。</p><ol start="2"><li>DDL语句。(Data Definition Language 数据定义语言)。如：truncate table(截断/清空 一张表)</li></ol><p>​create table(表)、create view(视图)、create index(索引)、create sequence(序列)、</p><p>​create synonym(同义词)、alter table、drop table。</p><ol start="3"><li>DCL语句。DCL（Data Control Language数据控制语言）如：</li></ol><p>​commit(提交)、rollback(回滚)</p><h3 id="dml语句"><a class="markdownIt-Anchor" href="#dml语句"></a> DML语句:</h3><h4 id="插入和拷贝"><a class="markdownIt-Anchor" href="#插入和拷贝"></a> 插入和拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1 insert语句: </span><br><span class="line">insert into tablename[col1,…] values(val1,…);</span><br><span class="line"></span><br><span class="line">   --插入全部列</span><br><span class="line">  insert into dept values(51,&apos;51name&apos;,&apos;51loc&apos;);</span><br><span class="line">  插入所有的数据时,列名可以不写</span><br><span class="line"></span><br><span class="line">--插入部分列</span><br><span class="line">insert into dept(deptno, dname) values(55, &apos;55name&apos;);</span><br><span class="line">  </span><br><span class="line">--隐式插入null</span><br><span class="line">insert into dept(deptno,dname) values(52,&apos;52name&apos;);</span><br><span class="line"></span><br><span class="line">--显示插入null</span><br><span class="line">insert into dept(deptno,dname,loc) values(53,&apos;53name&apos;,null);</span><br><span class="line">    </span><br><span class="line">    --&amp;符号的使用:</span><br><span class="line">      insert into dept(deptno, dname, loc) values(&amp;t1, &amp;t2, &amp;t3);</span><br><span class="line">      </span><br><span class="line">    拷贝表结构:</span><br><span class="line">       create table tname_YYYY_MM_DD as select * from tname_xxxxx where 1=2;   ---where条件为假, 之拷贝表结构</span><br><span class="line">    </span><br><span class="line">    批量插入:</span><br><span class="line">      insert into tname_bak select * from tname where .....;</span><br></pre></td></tr></table></figure><h4 id="修改"><a class="markdownIt-Anchor" href="#修改"></a> 修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2 update语句: update tablename set col1=val1, col2=val where  cond;</span><br><span class="line">      --修改emp表的员工名字为TOM_CAT的员工的薪水为原有薪水加100</span><br><span class="line">        update emp set sal=sal+100 where ename=&apos;TOM_CAT&apos;;</span><br><span class="line">      </span><br><span class="line">      --修改emp表的员工名字为TOM_CAT的员工的薪水为原有薪水加空</span><br><span class="line">        update emp set sal=null where ename=&apos;TOM_CAT&apos;;</span><br><span class="line">      **注意: 在update的时候, null可以使用等号</span><br><span class="line">      **注意: 在update的时候, 一定要使用where条件, 否则会修改表中所有的记录</span><br></pre></td></tr></table></figure><h4 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  3 delete语句: delete from tablename where cond;</span><br><span class="line">     delete from emp where ename=&apos;TOM_CAT&apos;;</span><br><span class="line">     delete from dept where ename = &amp;dpt;</span><br><span class="line">     **注意: 在使用delete删除的时候一定要有where条件, 否则会删除整个表的记录</span><br><span class="line">     </span><br><span class="line">  truncate table 表名;  删除表中所有数据,不可恢复</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> --delete和truncate的区别: </span><br><span class="line">   1. delete逐条删除表&quot;内容&quot;, truncate先摧毁表再重建。</span><br><span class="line">(由于delete使用频繁，Oracle对delete优化后delete快于truncate)</span><br><span class="line"></span><br><span class="line">2. delete 是DML语句, truncate是DDL语句</span><br><span class="line">DML语句可以闪回(flashback), DDL语句不可以闪回</span><br><span class="line">   （闪回:做错了一个操作并且commit了, 对应的撤销行为）</span><br><span class="line"></span><br><span class="line">3. 由于delete是逐条操作数据，所以delete会产生碎片，truncate不会产生碎片。</span><br><span class="line">（同样是由于Oracle对delete进行了优化, 让delete不产生碎片）。</span><br><span class="line">两个数据之间的数据被删除, 删除的数据——碎片, 整理碎片, 数据连续, 行移动</span><br><span class="line"></span><br><span class="line">4. delete不会释放空间, truncate会释放空间</span><br><span class="line">用delete删除一张10M的表, 空间不会释放。而truncate会。所以当确定表不再使用，应truncate</span><br><span class="line"></span><br><span class="line">5. delete可以回滚rollback, truncate不可以回滚rollback</span><br><span class="line"></span><br><span class="line">实验验证一些delete和truncate</span><br><span class="line">通过实验比较, truncate删除的效率比delete快.</span><br><span class="line">打开时间回显: SQL&gt; set timing on;</span><br><span class="line">关闭时间回显: SQL&gt; set timing off;</span><br></pre></td></tr></table></figure><h4 id="批量插入"><a class="markdownIt-Anchor" href="#批量插入"></a> 批量插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start 脚本名.sql</span><br><span class="line">或</span><br><span class="line">@ 脚本名.sql</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;sql语言的类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sql语言的类型&quot;&gt;&lt;/a&gt; sql语言的类型&lt;/h3&gt;
&lt;p&gt;​		  DML data manipulation language  数据操作语言，对应增删改查&lt;br&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>集合运算</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/12/%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/12/集合运算/</id>
    <published>2022-05-11T19:54:37.000Z</published>
    <updated>2022-05-11T20:04:20.147Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javawz/wps20B9.tmp.jpg" alt="img"></p><p>​union 两个集合相同的部分保留一份<br>​union all 两个集合相同的部分都保留<br>​intersect 两个集合交集只保留相同的部分<br>​minus  集合A-集合B，减去A和B都有的部分, 保留A中与B不同的部分<br>​</p><pre><code>select * from emp where deptno = 10 union select * from emp where deptno=20;select * from emp where deptno = 10 union select * from emp where deptno in(20,10);select * from emp where deptno = 10 union all select * from emp where deptno in(20,10);select * from emp where deptno = 10 intersect select * from emp where deptno in(20,10);select * from emp where deptno in(10,30) minus  select * from emp where deptno in(20,10);总结: 使用集合运算要保证列数一样多, 前后的列的类型要一致</code></pre><h2 id="11-集合运算需要注意的问题"><a class="markdownIt-Anchor" href="#11-集合运算需要注意的问题"></a> <strong>1.1</strong> 集合运算需要注意的问题：</h2><ol><li><p>参与运算的各个集合必须列数相同，且类型一致。</p></li><li><p>采用第一个集合的表头作为最终使用的表头。(别名也只能在第一个集合上起)</p></li><li><p>可以使用括号()先执行后面的语句。</p></li></ol><p>问题：按照部门统计各部门不同工种的工资情况，要求按如下格式输出：</p><p><img src="../../themes/pure/source/images/javawz/wps9A70.tmp.jpg" alt="img"></p><p>分析SQL执行结果。</p><p>​第一部分数据是按照deptno和job进行分组；select 查询deptno、job、sum(sal)</p><p>​第二部分数据是直接按照deptno分组即可，与job无关；select 只需要查询deptno，sum(sal)</p><p>​第三部分数据不按照任何条件分组，即group by null；select 查询sum(sal)</p><p>所以，整体查询结果应该=  group by deptno，job  +  group by deptno  +  group by null</p><p>​按照集合的要求,必须列数相同,类型一致,所以写法如下,使用null强行占位!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select deptno,job,sum(sal) from emp group by deptno,job</span><br><span class="line">union</span><br><span class="line">select deptno,to_char(null),sum(sal) from emp group by deptno</span><br><span class="line">union</span><br><span class="line">select to_number(null),to_char(null),sum(sal) from emp;</span><br></pre></td></tr></table></figure><p>需要注意:集合运算的性能一般较差.</p><h3 id="sql的执行时间"><a class="markdownIt-Anchor" href="#sql的执行时间"></a> SQL的执行时间：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set timing on/off默认是off</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/javawz/wps20B9.tmp.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	union 两个集合相同的部分保留一份&lt;br&gt;
​	union all 两个集合相同的部分都保留&lt;br&gt;
​	intersect 两个集合交集只保留相
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>笛卡尔积的概念</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/12/%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/12/笛卡尔积的概念/</id>
    <published>2022-05-11T19:10:45.000Z</published>
    <updated>2022-05-11T19:55:20.425Z</updated>
    
    <content type="html"><![CDATA[<p>​笛卡尔集的行数 = table1的行数 x table2的行数</p><p>​笛卡尔集的列数 = table1的列数 + table2的列数</p><p><img src="/images/javawz/wps32C0.tmp.jpg" alt="img"></p><p>在操作笛卡尔集的时候，应该避免使用“笛卡尔全集”，因为里面含有大量错误信息。</p><p><img src="/images/javawz/wps69EE.tmp.png" alt="img"></p><p>多表查询就是按照给定条件(连接条件)，从笛卡尔全集中选出正确的结果。</p><p>笛卡尔积的数据集合中有一些是无效的数据, 需要进行过滤,</p><p>对于有2个表的的笛卡尔积, 需要一个条件, 对于n个表需要n-1个条件.</p><p>对于多表查询, 首先会生成笛卡尔积, 笛卡尔积里面会有无效的数据, 此时需要过滤筛选.</p><h3 id="等值连接结合笛卡尔积讲解"><a class="markdownIt-Anchor" href="#等值连接结合笛卡尔积讲解"></a> 等值连接(结合笛卡尔积讲解)</h3><h4 id="查询员工信息员工号-姓名-月薪emp和部门名称dept"><a class="markdownIt-Anchor" href="#查询员工信息员工号-姓名-月薪emp和部门名称dept"></a> 查询员工信息：员工号 姓名 月薪(emp)和部门名称(dept)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分析: </span><br><span class="line">员工号 姓名 月薪 这三个字段在emp表中, 部门名称在dept表中</span><br><span class="line">select e.empno, e.ename, e.sal, d.dname from emp e, dept d where e.deptno=d.deptno;</span><br></pre></td></tr></table></figure><h3 id="不等值连接结合笛卡尔积讲解"><a class="markdownIt-Anchor" href="#不等值连接结合笛卡尔积讲解"></a> 不等值连接(结合笛卡尔积讲解)</h3><p>查询员工信息：员工号 姓名 月薪(emp) 和 薪水级别(salgrade表)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.empno, e.ename, e.sal, s.grade from emp e, salgrade s where e.sal between s.losal and s.hisal;</span><br></pre></td></tr></table></figure><p>按部门统计员工人数, 显示如下信息： 部门号 部门名称 人数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select d.deptno, d.dname, count(e.empno) from emp e, dept d where e.deptno=d.deptno group by d.deptno, d.dname;</span><br><span class="line">部门表中40号部门没有被统计上, 如何将40号部门也统计上呢???</span><br></pre></td></tr></table></figure><h4 id="右外连接"><a class="markdownIt-Anchor" href="#右外连接"></a> 右外连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select d.deptno, d.dname, count(e.empno) from emp e, dept d where e.deptno(+)=d.deptno group by d.deptno, d.dname;</span><br></pre></td></tr></table></figure><h4 id="解释一下count和counteempno的区别"><a class="markdownIt-Anchor" href="#解释一下count和counteempno的区别"></a> 解释一下count(*)和count(e.empno)的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count(*): 只要一行中有一个字段不为空就被统计上</span><br><span class="line">count(e.empno): 只有e.empno不为空才会被统计上</span><br></pre></td></tr></table></figure><h4 id="左外连接"><a class="markdownIt-Anchor" href="#左外连接"></a> 左外连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select d.deptno, d.dname, count(e.empno) from emp e, dept d where d.deptno=e.deptno(+) group by d.deptno, d.dname;</span><br></pre></td></tr></table></figure><h3 id="自连接"><a class="markdownIt-Anchor" href="#自连接"></a> 自连接</h3><p>查询员工信息：xxx的老板是 yyy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分析: emp表中的mgr列表示员工的老板的员工编号, 可以将emp表分别看做员工表和老板表, 员工表的老板是老板表的员工:</span><br><span class="line"></span><br><span class="line">select e.ename || &apos; 的老板是 &apos; ||  nvl(b.ename, &apos; HIS WIFE&apos;) from emp e, emp b where e.mgr=b.empno(+);</span><br></pre></td></tr></table></figure><h3 id="子查询sql嵌套sql"><a class="markdownIt-Anchor" href="#子查询sql嵌套sql"></a> 子查询(sql嵌套sql)</h3><h4 id="查询比scott工资高的员工信息"><a class="markdownIt-Anchor" href="#查询比scott工资高的员工信息"></a> 查询比SCOTT工资高的员工信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">分析: 可以分两部查找,</span><br><span class="line">   第一步: 查找SCOTT的工资</span><br><span class="line">   select sal from emp where ename = &apos;SCOTT&apos;;  ---3000.00</span><br><span class="line"></span><br><span class="line">   第二步: 将上一步得到的结果作为第二部查询的条件</span><br><span class="line">select * from emp where sal&gt;3000;</span><br><span class="line">   </span><br><span class="line">   可以使用子查询方法将两步合成一步: </span><br><span class="line">select * from emp where sal&gt;(select sal from emp where ename = &apos;SCOTT&apos;);</span><br></pre></td></tr></table></figure><h4 id="关于子查询的10点注意事项"><a class="markdownIt-Anchor" href="#关于子查询的10点注意事项"></a> 关于子查询的10点注意事项:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1  合理的书写风格 (如上例，当写一个较复杂的子查询的时候，要合理的添加换行、缩进), 可以借助PL/SQL Developer工具</span><br><span class="line">2  使用小括号</span><br><span class="line">3  主查询和子查询可以是不同表，只要子查询返回的结果主查询可以使用即可</span><br><span class="line">   --查询部门名称是&quot;SALES&quot;的员工信息:</span><br><span class="line">     分析: 部门名称在dept表中, dept表与emp表是通过deptno联系在一起的.</span><br><span class="line">     --使用子查询</span><br><span class="line">    select * from emp where deptno=(select deptno from dept where dname=&apos;SALES&apos;);</span><br><span class="line">    --使用多表查询</span><br><span class="line">       select e.* from emp e, dept d where e.deptno=d.deptno and d.dname=&apos;SALES&apos;;</span><br><span class="line">       </span><br><span class="line">4 可以在主查询的where、select、having、from后都可以放置子查询</span><br><span class="line">     a 在select后使用子查询的情况: </span><br><span class="line">       查询10号部门员工号, 员工姓名, 部门编号, 部门名称</span><br><span class="line">       select e.empno, e.ename, e.deptno,(select dname from dept where deptno=10) from emp e where e.deptno=10;</span><br><span class="line">   注意点: 在select后面使用子查询必须保证子查询结果只返回一条记录.</span><br><span class="line">     </span><br><span class="line">     b 在having后面使用子查询的情况:</span><br><span class="line">       查询部门平均工资高于30号部门平均工资的部门和平均工资</span><br><span class="line">       1 先查询30号部门的平均工资</span><br><span class="line">        select avg(sal) from emp where deptno=30;</span><br><span class="line">       2 查询每个部门的平均工资</span><br><span class="line">         select deptno, avg(sal) from emp group by deptno;</span><br><span class="line">       3  </span><br><span class="line">        select deptno, avg(sal)</span><br><span class="line">  from emp</span><br><span class="line"> group by deptno</span><br><span class="line">having avg(sal) &gt; (select avg(sal) from emp where deptno = 30);</span><br><span class="line"></span><br><span class="line">5 不可以在主查询的group by后面放置子查询 (SQL语句的语法规范)</span><br><span class="line"></span><br><span class="line">6 强调：在from后面放置的子查询(***), from后面放置是一个集合(表、查询结果)</span><br><span class="line"></span><br><span class="line">7 单行子查询只能使用单行操作符, 多行子查询只能使用多行操作符(前面的&gt; &lt; = 都是单行操作符, 接下来说的是多行操作符)</span><br><span class="line">  多行操作符有 IN  ANY(任意一个)  ALL （所有）</span><br><span class="line">  </span><br><span class="line">  --查询部门名称为SALES和ACCOUNTING的员工信息</span><br><span class="line">select * from emp where deptno in (select deptno from dept where dname in (&apos;SALES&apos;, &apos;ACCOUNTING&apos;));</span><br><span class="line"></span><br><span class="line">    --查询薪水比30号部门任意一个(某一个 ANY )员工高的员工信息</span><br><span class="line">select * from emp where sal &gt;(select min(sal) from emp where deptno=30);</span><br><span class="line">select * from emp where sal &gt;(select sal from emp where deptno=30); --错误</span><br><span class="line">    select * from emp where sal &gt;any(select sal from emp where deptno=30);</span><br><span class="line">    </span><br><span class="line">    --查询比30号部门所有人工资高的员工信息</span><br><span class="line">    select * from emp where sal&gt;(select max(sal) from emp where deptno=30);</span><br><span class="line">select * from emp where sal&gt;all(select sal from emp where deptno=30);</span><br><span class="line">  </span><br><span class="line">  8 一般不在子查询中使用order by, 但在Top-N分析问题中，必须使用order by  </span><br><span class="line">  </span><br><span class="line">  9 一般先执行子查询(内查询)，再执行主查询(外查询)；但是相关子查询除外</span><br><span class="line">  </span><br><span class="line">  10 子查询中的null值</span><br><span class="line">    --查询不是老板的员工信息</span><br><span class="line">      分析: 可以先查询谁是老板</span><br><span class="line">      select distinct mgr from emp;</span><br><span class="line">      select * from emp where empno not in (select distinct mgr from emp);</span><br><span class="line">      </span><br><span class="line">      select * from emp where empno not in (select distinct mgr from emp where mgr is not null);</span><br><span class="line"></span><br><span class="line">      总结: not in 后面集合中不能出现null</span><br><span class="line">      empno not in(a, b, null)---&gt; empno!=a and empno!=b and empno!=null;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">思考题?</span><br><span class="line">        查询员工的姓名、薪水和年薪?  select * from ____________;</span><br><span class="line">        select * from (select ename, sal, sal*12 from emp);</span><br><span class="line">        总结: 可以将查询的结果集当成一张表来使用.</span><br><span class="line">               也就是说, from后面既可以是表名, 也可以是select查询的结果集.</span><br><span class="line">   </span><br><span class="line">            </span><br><span class="line">     c 在where后使用子查询的情况:</span><br><span class="line">       --查询比平均工资高的员工的信息?</span><br><span class="line">       1 查询平均工资</span><br><span class="line">       select avg(sal) from emp;</span><br><span class="line">       2 select * from emp where sal&gt;2073;</span><br><span class="line">       合成一步:</span><br><span class="line">       select * from emp where sal&gt;(select avg(sal) from emp);</span><br><span class="line">       </span><br><span class="line">         </span><br><span class="line">        d 在having后使用子查询的情况:</span><br><span class="line">          --查询最低薪水高于30号部门最低薪水的部门及其最低薪水</span><br><span class="line">            1 先得到30部门的最低薪水</span><br><span class="line">               select min(sal) from emp where deptno=30;  --950</span><br><span class="line">            2 得到各个部门的最低薪水</span><br><span class="line">            select deptno, min(sal) from emp group by deptno;</span><br><span class="line">            3 使用条件进行过滤</span><br><span class="line">      select deptno, min(sal)</span><br><span class="line">  from emp</span><br><span class="line"> group by deptno</span><br><span class="line">having min(sal) &gt; 950;</span><br><span class="line">             </span><br><span class="line">            将三步合并写成: </span><br><span class="line">                select deptno, min(sal)</span><br><span class="line">  from emp</span><br><span class="line"> group by deptno</span><br><span class="line">having min(sal) &gt; (select min(sal) from emp where deptno = 30);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​	笛卡尔集的行数 = table1的行数 x table2的行数&lt;/p&gt;
&lt;p&gt;​	笛卡尔集的列数 = table1的列数 + table2的列数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/wps32C0.tmp.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>分组函数和分组数据</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/12/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0%E5%92%8C%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/12/分组函数和分组数据/</id>
    <published>2022-05-11T17:23:56.000Z</published>
    <updated>2022-05-11T18:02:21.851Z</updated>
    
    <content type="html"><![CDATA[<p>分组函数:也称之为组函数或者聚合函数, oracle提供的常用的分组函数有:sum, avg, count, max, min</p><h4 id="1-统计员工总数"><a class="markdownIt-Anchor" href="#1-统计员工总数"></a> 1 统计员工总数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(empno) from emp;</span><br></pre></td></tr></table></figure><h4 id="2-统计工种总数"><a class="markdownIt-Anchor" href="#2-统计工种总数"></a> 2 统计工种总数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(job) from emp;</span><br><span class="line">select count(distinct job) from emp;</span><br></pre></td></tr></table></figure><h4 id="3-求员工的平均工资"><a class="markdownIt-Anchor" href="#3-求员工的平均工资"></a> 3 求员工的平均工资</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(sal) from emp;</span><br></pre></td></tr></table></figure><h4 id="4-求员工的平均奖金"><a class="markdownIt-Anchor" href="#4-求员工的平均奖金"></a> 4 求员工的平均奖金</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(comm), sum(comm)/count(comm), sum(comm)/count(empno) from emp;</span><br></pre></td></tr></table></figure><h4 id="5-求员工表中最高工资和最低工资"><a class="markdownIt-Anchor" href="#5-求员工表中最高工资和最低工资"></a> 5 求员工表中最高工资和最低工资</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(sal), min(sal) from emp;</span><br></pre></td></tr></table></figure><h4 id="6-如何去掉分组函数的滤空功能呢-提示-nvl函数"><a class="markdownIt-Anchor" href="#6-如何去掉分组函数的滤空功能呢-提示-nvl函数"></a> 6 如何去掉分组函数的滤空功能呢??  --提示: nvl函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(nvl(empno)) from emp;</span><br></pre></td></tr></table></figure><h4 id="结论-分组函数具有滤空功能"><a class="markdownIt-Anchor" href="#结论-分组函数具有滤空功能"></a> 结论: 分组函数具有滤空功能.</h4><br><p>​<br></p><br><h2 id="分组数据-借助execl理解分组功能"><a class="markdownIt-Anchor" href="#分组数据-借助execl理解分组功能"></a> 分组数据: 借助execl理解分组功能.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本格式 : select ..., count() from emp where ... group by .. </span><br><span class="line">说明: 按照group by 后给定的表达式，将from后面的table进行分组, 针对每一组, 使用组函数。</span><br></pre></td></tr></table></figure><h4 id="1-统计各个部门的平均工资"><a class="markdownIt-Anchor" href="#1-统计各个部门的平均工资"></a> 1 统计各个部门的平均工资？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno, avg(sal) from emp group by deptno;</span><br></pre></td></tr></table></figure><h4 id="2-统计各个部门不同工种的平均工资"><a class="markdownIt-Anchor" href="#2-统计各个部门不同工种的平均工资"></a> 2 统计各个部门不同工种的平均工资?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select deptno, job, avg(sal) from emp group by deptno, job;</span><br><span class="line"></span><br><span class="line">结论: 请思考通过案例1和案例2得出什么样的结论??  select后面的列和group后面的列有什么关系?</span><br><span class="line">  select a, b, c.., count(f) from table group by a, b, c</span><br><span class="line">     select后面没有出现在分组函数中的列名, 一定要出现在group by子句中.</span><br><span class="line">     在group by子句中出现的列, 不要求一定出现在select后面的列中</span><br></pre></td></tr></table></figure><h4 id="3-统计各个部门平均工资高于2000"><a class="markdownIt-Anchor" href="#3-统计各个部门平均工资高于2000"></a> 3 统计各个部门平均工资高于2000?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select deptno, avg(sal) from emp group by deptno having avg(sal)&gt;2000;</span><br><span class="line"></span><br><span class="line">结论:对分组数据进行过滤, 不能够使用where, 应该使用having</span><br></pre></td></tr></table></figure><h4 id="4-求10号部门员工的平均薪水"><a class="markdownIt-Anchor" href="#4-求10号部门员工的平均薪水"></a> 4 求10号部门员工的平均薪水</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">方法1: select deptno,avg(sal) from emp where deptno=10 group by deptno;</span><br><span class="line"></span><br><span class="line">方法2: select deptno,avg(sal) from emp group by deptno having deptno=10;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">结论:比较两种方法, 应该优先使用那种方法??</span><br><span class="line"> 第一种方法比第二种方法效率高,原因是第一种是先过滤然后再分组</span><br><span class="line"> 第二种方法是先处理大量的数据,然后再过滤</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">使用分组函数统计分组数据不当的情况:</span><br><span class="line">select deptno job avg(sal) from emp group by deptno    //出错</span><br><span class="line">select deptno avg(sal) from emp group by deptno,job    //没有意义</span><br></pre></td></tr></table></figure><h3 id="where和having"><a class="markdownIt-Anchor" href="#where和having"></a> where和having</h3><p>1 where用于对数据第一次过滤 ,having只能用于分组后的数据过滤</p><p>2 如果where和having同时出现,则where应该出现在having前面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分组函数:也称之为组函数或者聚合函数, oracle提供的常用的分组函数有:sum, avg, count, max, min&lt;/p&gt;
&lt;h4 id=&quot;1-统计员工总数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-统计员工总数&quot;&gt;&lt;/a&gt; 
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>条件表达式</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/12/%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/12/条件表达式/</id>
    <published>2022-05-11T16:19:03.000Z</published>
    <updated>2022-05-11T17:13:41.651Z</updated>
    
    <content type="html"><![CDATA[<p>例子：老板打算给员工涨工资, 要求：</p><p>​总裁(PRESIDENT)涨1000，经理(MANAGER)涨800，其他人涨400. 请将涨前，涨后的薪水列出。</p><p>select ename, job, sal 涨前薪水, 涨后薪水 from emp涨后的薪水是根据job来判断的</p><p>思路：if 是总裁(‘PRESIDENT’) then +1000</p><p>​else if 是经理(‘MANAGER’) then +800</p><p>​else +400</p><p>但是在SQL中无法实现if else 逻辑。当有这种需求的时候，可以使用case 或者 decode</p><p>case：是一个表达式，其语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE expr  WHEN comparison_expr1 THEN return_expr1</span><br><span class="line">            [WHEN comparison_expr2 THEN return_expr2</span><br><span class="line">            WHEN comparison_exprn THEN return_exprn</span><br><span class="line">            ELSE else_expr]</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>案例: 老板打算给涨工资，总裁1000，经理800，普通员工400，将涨前、涨后薪水列出</p><p>介绍case when 的用法和decode的用法:</p><h3 id="使用case-when"><a class="markdownIt-Anchor" href="#使用case-when"></a> 使用case when</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select empno,</span><br><span class="line">       ename,</span><br><span class="line">       job,</span><br><span class="line">       sal &quot;涨前薪水&quot;,</span><br><span class="line">       case job</span><br><span class="line">         when &apos;PRESIDENT&apos; then</span><br><span class="line">          sal + 1000</span><br><span class="line">         when &apos;MANAGER&apos; then</span><br><span class="line">          sal + 800</span><br><span class="line">         else</span><br><span class="line">          sal + 400</span><br><span class="line">       end &quot;涨后薪水&quot;</span><br><span class="line">  from emp;</span><br></pre></td></tr></table></figure><h3 id="使用decode函数"><a class="markdownIt-Anchor" href="#使用decode函数"></a> 使用decode函数:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select empno,</span><br><span class="line">       ename,</span><br><span class="line">       job,</span><br><span class="line">       sal &quot;涨前薪水&quot;,</span><br><span class="line">       decode(job,</span><br><span class="line">              &apos;PRESIDENT&apos;,</span><br><span class="line">              sal + 1000,</span><br><span class="line">              &apos;MANAGER&apos;,</span><br><span class="line">              sal + 800,</span><br><span class="line">              sal + 400) &quot;涨后薪水&quot;</span><br><span class="line">  from emp;</span><br></pre></td></tr></table></figure><h3 id="代码优化"><a class="markdownIt-Anchor" href="#代码优化"></a> 代码优化</h3><p><img src="/images/javawz/image-20220512011329665.png" alt="image-20220512011329665"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;例子：老板打算给员工涨工资, 要求：&lt;/p&gt;
&lt;p&gt;​		总裁(PRESIDENT)涨1000，经理(MANAGER)涨800，其他人涨400. 请将涨前，涨后的薪水列出。&lt;/p&gt;
&lt;p&gt;select ename, job, sal 涨前薪水, 涨后薪水 from emp	
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/11/%E6%8E%92%E5%BA%8F/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/11/排序/</id>
    <published>2022-05-11T14:35:18.000Z</published>
    <updated>2022-05-11T14:40:00.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用order-by关键字-基本格式"><a class="markdownIt-Anchor" href="#使用order-by关键字-基本格式"></a> 使用order by关键字, 基本格式:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select  ... from ... where condition order by colname|alias|expr|number(序号)</span><br><span class="line">order by有两种排序方法; 一种是升序, 一种是降序: 默认是升序的(asc), 降序为desc</span><br></pre></td></tr></table></figure><h3 id="a-使用列名进行排序"><a class="markdownIt-Anchor" href="#a-使用列名进行排序"></a> a 使用列名进行排序:</h3><h4 id="1-员工信息按入职日期先后排序"><a class="markdownIt-Anchor" href="#1-员工信息按入职日期先后排序"></a> 1 员工信息按入职日期先后排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from emp order by hiredate asc;</span><br><span class="line">select * from emp order by hiredate;  --asc可以省略不写</span><br></pre></td></tr></table></figure><h4 id="2-员工薪水按从大到小排序"><a class="markdownIt-Anchor" href="#2-员工薪水按从大到小排序"></a> 2 员工薪水按从大到小排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp order by sal desc;</span><br></pre></td></tr></table></figure><h4 id="3-查询员工信息按奖金逆序"><a class="markdownIt-Anchor" href="#3-查询员工信息按奖金逆序"></a> 3 查询员工信息按奖金逆序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from emp order by comm desc;</span><br><span class="line">select * from emp order by comm desc nulls last;</span><br><span class="line">    </span><br><span class="line">注意: null值表现为无穷大, 可以使用nulls last来使null放在最后</span><br></pre></td></tr></table></figure><h4 id="4-员工信息按部门升序-薪水降序排列"><a class="markdownIt-Anchor" href="#4-员工信息按部门升序-薪水降序排列"></a> 4 员工信息按部门升序、薪水降序排列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from emp order by deptno, sal desc ;</span><br><span class="line">根据排序结果得出结论:</span><br><span class="line">    asc和desc作用于最近的前面的一列</span><br><span class="line">    按照多个列进行排序的时候, 先按照第一列进行排序, 若第一列相同,则按照第二列排序</span><br></pre></td></tr></table></figure><h3 id="b-使用序号进行排序并说明什么序号"><a class="markdownIt-Anchor" href="#b-使用序号进行排序并说明什么序号"></a> b 使用序号进行排序:(并说明什么序号)</h3><h4 id="1-查询员工编号-员工姓名和工资-按照序号工资进行排序"><a class="markdownIt-Anchor" href="#1-查询员工编号-员工姓名和工资-按照序号工资进行排序"></a> 1 查询员工编号, 员工姓名和工资, 按照序号(工资)进行排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> select empno, ename, sal from emp order by 3; </span><br><span class="line">      </span><br><span class="line">序号: select后面出现的列的次序, 次序从1开始.</span><br></pre></td></tr></table></figure><h3 id="c-使用别名进行排序"><a class="markdownIt-Anchor" href="#c-使用别名进行排序"></a> c 使用别名进行排序</h3><h4 id="1-按员工的年收入进行排序"><a class="markdownIt-Anchor" href="#1-按员工的年收入进行排序"></a> 1 按员工的年收入进行排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select empno, ename, sal, sal*12+nvl(comm, 0) yearcomm from emp order by yearcomm;</span><br></pre></td></tr></table></figure><h3 id><a class="markdownIt-Anchor" href="#"></a> </h3><h3 id="d-使用表达式进行排序"><a class="markdownIt-Anchor" href="#d-使用表达式进行排序"></a> d 使用表达式进行排序</h3><h4 id="1-按照员工的年薪进行排序"><a class="markdownIt-Anchor" href="#1-按照员工的年薪进行排序"></a> 1 按照员工的年薪进行排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select empno, ename, sal, sal*12  from emp order by sal*12;</span><br></pre></td></tr></table></figure><h3 id="关于排序的几点说明"><a class="markdownIt-Anchor" href="#关于排序的几点说明"></a> 关于排序的几点说明:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 要了解排序可以使用哪几种方式</span><br><span class="line">    列名   序号   别名   表达式</span><br><span class="line">2 如果有多列进行排序, 应该如何排序, 可以结合案例理解.</span><br><span class="line">         若有多列进行排序, 优先按第1列进行排序, 如果第1列相同,再按照第2列进行排序.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用order-by关键字-基本格式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用order-by关键字-基本格式&quot;&gt;&lt;/a&gt; 使用order by关键字, 基本格式:&lt;/h3&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>单行函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/11/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/11/单行函数/</id>
    <published>2022-05-11T14:25:41.000Z</published>
    <updated>2022-05-11T14:49:17.466Z</updated>
    
    <content type="html"><![CDATA[<p>单行函数:只对针对一行进行, 返回一行记录</p><h3 id="字符串相关函数"><a class="markdownIt-Anchor" href="#字符串相关函数"></a> 字符串相关函数:</h3><h4 id="1-lower-小写-upper-大写-initcap单词的首字母大写"><a class="markdownIt-Anchor" href="#1-lower-小写-upper-大写-initcap单词的首字母大写"></a> 1 lower 小写, upper 大写, initcap单词的首字母大写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select lower(&apos;HELLO WORLD&apos;) &quot;小写&quot;, upper(&apos;Hello world&apos;) &quot;大写&quot;, initcap(&apos;hello world&apos;) &quot;首字母大写&quot; from dual;</span><br></pre></td></tr></table></figure><h4 id="2-concat连接符"><a class="markdownIt-Anchor" href="#2-concat连接符"></a> 2 concat(连接符||)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select concat(&apos;hello &apos;,&apos;world&apos;) from dual;</span><br><span class="line">  **注意: concat函数只能连接两个字符串, 若想连接三个的话只能嵌套调用:</span><br><span class="line">  select concat(concat(&apos;hello &apos;,&apos;world&apos;), &apos; nihao&apos;) from dual;</span><br><span class="line">     select &apos;hello &apos; || &apos;world &apos; || &apos;nihao&apos; from dual;</span><br><span class="line">     **注意: || 可以连接多个字符串, 建议使用||来连接字符串.</span><br><span class="line">   </span><br><span class="line">     **总结: concat只能用于两个字符串的连接, ||可以用于多个字符串的连接, 在使用的使用建议尽量的使用||.</span><br></pre></td></tr></table></figure><h4 id="3-substrstrposlen截取字符串"><a class="markdownIt-Anchor" href="#3-substrstrposlen截取字符串"></a> 3 substr(str,pos,len)截取字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select substr(&apos;helloworld&apos;,1,3), substr(&apos;helloworld&apos;,1), substr(&apos;helloworld&apos;,-3) from dual;</span><br><span class="line"> **总结:pos是从1开始的, 若len为0表示从pos开始, 截取到最后, 若pos为负数, 表示从末尾倒数开始截取,</span><br></pre></td></tr></table></figure><h4 id="4-instrstr-substr判断substr是否在str中存在-若存在返回第一次出现的位置-若不存在则返回0"><a class="markdownIt-Anchor" href="#4-instrstr-substr判断substr是否在str中存在-若存在返回第一次出现的位置-若不存在则返回0"></a> 4 instr(str, substr):判断substr是否在str中存在, 若存在返回第一次出现的位置, 若不存在则返回0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select instr(&apos;hello llo&apos;, &apos;llo&apos;),  instr(&apos;hello llo&apos;, &apos;ow&apos;)from dual;</span><br></pre></td></tr></table></figure><h4 id="5-lpad和rpadlpadstr-len-ch返回len长度的字符串-如果str不够len的话-在左右填充ch这个字符"><a class="markdownIt-Anchor" href="#5-lpad和rpadlpadstr-len-ch返回len长度的字符串-如果str不够len的话-在左右填充ch这个字符"></a> 5 lpad和rpad–l®pad(str, len, ch):返回len长度的字符串, 如果str不够len的话, 在左(右)填充ch这个字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select lpad(&apos;aaaa&apos;, 10, &apos;$&apos;), rpad(&apos;aaaa&apos;, 10, &apos;#&apos;) from dual;</span><br></pre></td></tr></table></figure><h4 id="6-trim去掉首部和尾部的空格中间的空格不去掉"><a class="markdownIt-Anchor" href="#6-trim去掉首部和尾部的空格中间的空格不去掉"></a> 6 trim:去掉首部和尾部的空格,中间的空格不去掉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select &apos;aaa&apos;||trim(&apos;  hello world  &apos;)||&apos;bbb&apos; from dual;  </span><br><span class="line">     trim(c from str):去掉str中的c字符</span><br><span class="line">     select trim(&apos;x&apos; from &apos;xxxxxhello worldxxxxx&apos;) from dual;</span><br></pre></td></tr></table></figure><h4 id="7-replacestr-old-new将str字符串中的old字符串替换成new字符串"><a class="markdownIt-Anchor" href="#7-replacestr-old-new将str字符串中的old字符串替换成new字符串"></a> 7 replace(str, old, new):将str字符串中的old字符串替换成new字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select replace(&apos;hello world&apos;,&apos;llo&apos;,&apos;yy&apos;) from dual;</span><br></pre></td></tr></table></figure><h4 id="8-length和lengthb"><a class="markdownIt-Anchor" href="#8-length和lengthb"></a> 8  length和lengthb</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select length(&apos;hello world&apos;) 字符数, lengthb(&apos;hello world&apos;) 字节数 from dual;</span><br><span class="line">select length(&apos;哈喽我的&apos;) 字符数, lengthb(&apos;哈喽我的&apos;) 字节数 from dual; </span><br><span class="line">  注意:对于length函数一个汉字是一个字符, 对于lengthb函数,一个汉字占两个,</span><br><span class="line">     这两个函数对于普通字符串没有什么区别.</span><br></pre></td></tr></table></figure><h3 id="数值函数"><a class="markdownIt-Anchor" href="#数值函数"></a> 数值函数</h3><h4 id="1-round-四舍五入"><a class="markdownIt-Anchor" href="#1-round-四舍五入"></a> 1 round: 四舍五入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select round(45.926, 2) 一, round(45.926, 1) 二, round(45.926, 0) 三,  round(45.926, -1) 四, round(45.926, -2) 五 from dual;</span><br></pre></td></tr></table></figure><h4 id="trunc-截取"><a class="markdownIt-Anchor" href="#trunc-截取"></a> trunc: 截取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select trunc(45.926, 2) 一, trunc(45.926, 1) 二, trunc(45.926, 0) 三,  trunc(45.926, -1) 四, trunc(45.926, -2) 五 from dual;</span><br></pre></td></tr></table></figure><h4 id="2-mod"><a class="markdownIt-Anchor" href="#2-mod"></a> 2 mod</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select mod(1600, 300) from dual;</span><br></pre></td></tr></table></figure><h4 id="3-ceil向上取整-floor向下取整"><a class="markdownIt-Anchor" href="#3-ceil向上取整-floor向下取整"></a> 3 ceil:向上取整  floor:向下取整</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ceil(121/30), floor(121/30) from dual;</span><br></pre></td></tr></table></figure><h3 id="转换函数"><a class="markdownIt-Anchor" href="#转换函数"></a> 转换函数:</h3><h4 id="1-to_char和to_number"><a class="markdownIt-Anchor" href="#1-to_char和to_number"></a> 1 to_char和to_number</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--把薪水转换为本地货币字符型</span><br><span class="line">select empno,sal,to_char(sal,&apos;L9,999&apos;) from emp;</span><br><span class="line">--把上述某个结果转回数值型</span><br><span class="line">select to_number(&apos;￥2,975&apos;,&apos;L9,999&apos;) from dual;</span><br></pre></td></tr></table></figure><h4 id="2-to_char-与-to_date"><a class="markdownIt-Anchor" href="#2-to_char-与-to_date"></a> 2 to_char 与 to_date</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--显示 &quot;yyyy-mm-dd hh24:mi:ss 今天是 星期几&quot;</span><br><span class="line">select to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss &quot;今天是&quot; day&apos;) from dual;</span><br><span class="line">--将上述输出字符串反转回日期</span><br><span class="line">select to_date(&apos;2017-12-04 01:12:48 今天是 星期一&apos;, &apos;yyyy-mm-dd hh24:mi:ss &quot;今天是&quot; day&apos;) from dual;</span><br></pre></td></tr></table></figure><h4 id="查询1981-11-17日入职的员工信息"><a class="markdownIt-Anchor" href="#查询1981-11-17日入职的员工信息"></a> 查询1981-11-17日入职的员工信息:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where to_char(hiredate, &apos;YYYY-MM-DD&apos;)=&apos;1981-11-17&apos;;</span><br><span class="line">select * from emp where hiredate = to_date(&apos;1981-11-17&apos;, &apos;YYYY-MM-DD&apos;);</span><br></pre></td></tr></table></figure><h4 id="oracle的隐式转换和显示转换"><a class="markdownIt-Anchor" href="#oracle的隐式转换和显示转换"></a> oracle的隐式转换和显示转换:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select 11+&apos;22&apos; from dual;</span><br><span class="line">select 11+to_number(&apos;22&apos;) from dual;</span><br><span class="line">对于select 11+&apos;22&apos; from dual; 会做隐式转换, 将&apos;22&apos;转换成22</span><br><span class="line"></span><br><span class="line">select &apos;11&apos; || 22 from dual;</span><br><span class="line">select &apos;11&apos; || to_char(22) from dual;</span><br><span class="line">对于select 11+&apos;22&apos; from dual; 会做隐式转换, 将22转换成&apos;22&apos;</span><br><span class="line"></span><br><span class="line">select 11+&apos;1a&apos; from dual;  --报错, 1a不是数字, 所以不能转</span><br><span class="line"></span><br><span class="line">**总结: 当没有明确转换函数的时候, 如果类型不一致, 会进行隐式转换, 隐式有一个前提, 它必须能转换, 但应尽量避免隐式转换。</span><br></pre></td></tr></table></figure><h3 id="时间和日期函数"><a class="markdownIt-Anchor" href="#时间和日期函数"></a> 时间和日期函数:</h3><h4 id="显示当前的系统日期"><a class="markdownIt-Anchor" href="#显示当前的系统日期"></a> 显示当前的系统日期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sysdate from dual;</span><br></pre></td></tr></table></figure><h4 id="显示当前的系统日期显示到秒"><a class="markdownIt-Anchor" href="#显示当前的系统日期显示到秒"></a> 显示当前的系统日期显示到秒</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select to_char(sysdate, &apos;yyyy-mm-dd hh24:mi:ss&apos;) from dual;</span><br></pre></td></tr></table></figure><h4 id="显示当前日期星期几"><a class="markdownIt-Anchor" href="#显示当前日期星期几"></a> 显示当前日期星期几</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select to_char(sysdate, &apos;day&apos;) from dual;</span><br></pre></td></tr></table></figure><h4 id="显示昨天今天明天oracle日期型1代表加一天"><a class="markdownIt-Anchor" href="#显示昨天今天明天oracle日期型1代表加一天"></a> 显示昨天，今天，明天–oracle日期型+1代表加一天</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sysdate-1 昨天,sysdate 今天,sysdate+1 明天 from dual;</span><br></pre></td></tr></table></figure><h4 id="计算员工工龄-可以按日周月年-日期差减方法"><a class="markdownIt-Anchor" href="#计算员工工龄-可以按日周月年-日期差减方法"></a> 计算员工工龄 可以按日，周，月，年 日期差减方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select empno,ename,sysdate-hiredate 日,(sysdate-hiredate)/7 周,(sysdate-hiredate)/30 月,(sysdate-hiredate)/365 年 from emp;</span><br></pre></td></tr></table></figure><h4 id="日期函数-months_between-add_months-last_day-next_day"><a class="markdownIt-Anchor" href="#日期函数-months_between-add_months-last_day-next_day"></a> 日期函数 months_between  add_months  last_day  next_day</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select empno, ename, months_between(sysdate,hiredate), (sysdate-hiredate)/30 月 from emp;</span><br></pre></td></tr></table></figure><h4 id="add_months增加月份"><a class="markdownIt-Anchor" href="#add_months增加月份"></a> add_months:增加月份</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select add_months(sysdate, 2) from dual;</span><br></pre></td></tr></table></figure><h4 id="求明年的今天"><a class="markdownIt-Anchor" href="#求明年的今天"></a> 求明年的今天</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select add_months(sysdate,12) from dual;</span><br></pre></td></tr></table></figure><h4 id="last_day最后一天指定日期所在月份的最后一天"><a class="markdownIt-Anchor" href="#last_day最后一天指定日期所在月份的最后一天"></a> last_day:最后一天–指定日期所在月份的最后一天</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select last_day(sysdate) from dual;</span><br></pre></td></tr></table></figure><h4 id="next_day求指定日期的下一个星期几"><a class="markdownIt-Anchor" href="#next_day求指定日期的下一个星期几"></a> next_day:求指定日期的下一个星期几</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select next_day(sysdate, &apos;星期一&apos;) from dual;</span><br></pre></td></tr></table></figure><h4 id="round-trunc-对日期型数据进行四舍五入和截断"><a class="markdownIt-Anchor" href="#round-trunc-对日期型数据进行四舍五入和截断"></a> round、trunc 对日期型数据进行四舍五入和截断</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select round(sysdate, &apos;month&apos;), round(sysdate, &apos;year&apos;) from dual;</span><br><span class="line">select trunc (sysdate, &apos;month&apos;), trunc(sysdate, &apos;year&apos;) from dual;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单行函数:只对针对一行进行, 返回一行记录&lt;/p&gt;
&lt;h3 id=&quot;字符串相关函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#字符串相关函数&quot;&gt;&lt;/a&gt; 字符串相关函数:&lt;/h3&gt;
&lt;h4 id=&quot;1-lower-小写-upper-大写-in
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>in和like</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/11/in%E5%92%8Clike/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/11/in和like/</id>
    <published>2022-05-11T13:16:07.000Z</published>
    <updated>2022-05-11T13:19:43.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-在where条件中使用inin后面是一个集合"><a class="markdownIt-Anchor" href="#3-在where条件中使用inin后面是一个集合"></a> 3 在where条件中使用in–in后面是一个集合</h2><h3 id="1-查询部门号是10或者20的员工信息"><a class="markdownIt-Anchor" href="#1-查询部门号是10或者20的员工信息"></a> 1 查询部门号是10或者20的员工信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where deptno=10 or deptno=20;</span><br><span class="line">select * from emp where deptno in(10,20);</span><br><span class="line"></span><br><span class="line">思考: 可以在in的集合中使用null吗?</span><br><span class="line">select * from emp where deptno in(10,20,null);</span><br><span class="line">select * from emp where deptno=10 or deptno=20 or deptno=null;</span><br></pre></td></tr></table></figure><h3 id="2-查询不是10和20号部门的员工信息"><a class="markdownIt-Anchor" href="#2-查询不是10和20号部门的员工信息"></a> 2 查询不是10和20号部门的员工信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where deptno!=10 and deptno!=20;</span><br><span class="line">select * from emp where deptno not in(10,20);</span><br><span class="line">  </span><br><span class="line">思考: 若not in的集合中有null会怎么样呢?</span><br><span class="line">select * from emp where deptno not in(10,20,null);</span><br><span class="line">select * from emp where deptno!=10 and deptno!=20 and deptno!=null;</span><br><span class="line">  </span><br><span class="line">not in后面不能出现null</span><br></pre></td></tr></table></figure><h2 id="在where条件中使用like模糊查找-其中-匹配任意多个字符-_匹配一个字符"><a class="markdownIt-Anchor" href="#在where条件中使用like模糊查找-其中-匹配任意多个字符-_匹配一个字符"></a> 在where条件中使用like–模糊查找, 其中: '%‘匹配任意多个字符。’_'匹配一个字符</h2><h4 id="1-查询员工首字母是s的员工信息"><a class="markdownIt-Anchor" href="#1-查询员工首字母是s的员工信息"></a> 1 查询员工首字母是S的员工信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where ename like &apos;S%&apos;;</span><br></pre></td></tr></table></figure><h4 id="2-查询员工编号为79开头的员工信息"><a class="markdownIt-Anchor" href="#2-查询员工编号为79开头的员工信息"></a> 2 查询员工编号为79开头的员工信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where empno like &apos;79%&apos;;</span><br></pre></td></tr></table></figure><h4 id="3-查询名字为四个字母长度的员工信息"><a class="markdownIt-Anchor" href="#3-查询名字为四个字母长度的员工信息"></a> 3 查询名字为四个字母长度的员工信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where ename like &apos;____&apos;;</span><br></pre></td></tr></table></figure><h4 id="4-查询员工姓名带_的员工信息"><a class="markdownIt-Anchor" href="#4-查询员工姓名带_的员工信息"></a> 4 查询员工姓名带_的员工信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">插入一条记录, 用于测试转义字符</span><br><span class="line">insert into emp (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)</span><br><span class="line">values (1000, &apos;TOM_CAT&apos;, &apos;CLERK&apos;, 9999, to_date(&apos;23-01-1982&apos;, &apos;dd-mm-yyyy&apos;), 1200.00, null, 10);   </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">select * from emp where ename like &apos;%\_%&apos; escape &apos;\&apos;;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;3-在where条件中使用inin后面是一个集合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#3-在where条件中使用inin后面是一个集合&quot;&gt;&lt;/a&gt; 3 在where条件中使用in–in后面是一个集合&lt;/h2&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>where逻辑表达式</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/11/where%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/11/where逻辑表达式/</id>
    <published>2022-05-11T12:57:34.000Z</published>
    <updated>2022-05-11T13:01:28.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在where条件中使用逻辑运算符-or-and-not"><a class="markdownIt-Anchor" href="#在where条件中使用逻辑运算符-or-and-not"></a> 在where条件中使用逻辑运算符: or and not</h2><h4 id="1-查询10号部门或者20部门的员工信息"><a class="markdownIt-Anchor" href="#1-查询10号部门或者20部门的员工信息"></a> 1 查询10号部门或者20部门的员工信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where deptno=10 or deptno=20;</span><br></pre></td></tr></table></figure><h4 id="2-查询10号部门员工工资为1300的员工信息"><a class="markdownIt-Anchor" href="#2-查询10号部门员工工资为1300的员工信息"></a> 2 查询10号部门员工工资为1300的员工信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where deptno=10 and sal=1300;</span><br></pre></td></tr></table></figure><h4 id="3-查询81年2月含2月至82年2月不含2月入职的员工信息大于等于81年2月1日小于等于82年1月31日"><a class="markdownIt-Anchor" href="#3-查询81年2月含2月至82年2月不含2月入职的员工信息大于等于81年2月1日小于等于82年1月31日"></a> 3 查询81年2月(含2月)至82年2月(不含2月)入职的员工信息(大于等于81年2月1日，小于等于82年1月31日)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">说明: 注意日期格式问题,注意月份单月不要在前面加0,否则会报错</span><br><span class="line">  select * from emp where hiredate&gt;=&apos;1-2月-81&apos; and hiredate&lt;=&apos;31-1月-82&apos;;</span><br><span class="line">  select * from emp where hiredate between &apos;1-2月-81&apos; and &apos;31-1月-82&apos;;</span><br></pre></td></tr></table></figure><h4 id="结论-关于and-or-操作符的sql优化问题"><a class="markdownIt-Anchor" href="#结论-关于and-or-操作符的sql优化问题"></a> 结论: 关于and or 操作符的sql优化问题?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">where条件在进行逻辑表达式计算的时候,是从右往左进行的, 所以对于and来说, 要把容易出现假的放在</span><br><span class="line">最右边, 对于or来说, 要把容易出现真的表达式放在最右边.</span><br><span class="line">where a and b and c and d;</span><br><span class="line">where a or b or c or d;</span><br></pre></td></tr></table></figure><h4 id="4-查询奖金为空的员工信息-null"><a class="markdownIt-Anchor" href="#4-查询奖金为空的员工信息-null"></a> 4 查询奖金为空的员工信息-null</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where comm=null; --不正确的写法</span><br><span class="line"></span><br><span class="line">select * from emp where comm is null;</span><br></pre></td></tr></table></figure><h4 id="5-查询奖金不为空的员工信息"><a class="markdownIt-Anchor" href="#5-查询奖金不为空的员工信息"></a> 5 查询奖金不为空的员工信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where comm!=null;</span><br><span class="line">select * from emp where comm is not null;</span><br><span class="line"></span><br><span class="line">结论: 关于null的在where条件中使用的结论?</span><br><span class="line">where条件后面为空应该用is null</span><br><span class="line">where条件后面不为空使用is not null</span><br></pre></td></tr></table></figure><h4 id="分析下面的sql语句"><a class="markdownIt-Anchor" href="#分析下面的sql语句"></a> 分析下面的sql语句:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where deptno=10 or deptno=30 and sal=1250;</span><br><span class="line">      </span><br><span class="line">**注意: 在有or和and的where条件中, and的优先级比or高, 所以若表示10部门或者20部门, 且sal为1250的, 应该</span><br><span class="line">   select * from emp where (deptno=10 or deptno=30) and sal=1250;</span><br><span class="line"> **结论: 在where条件表达式中有or的时候, 应该使用()括起来</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在where条件中使用逻辑运算符-or-and-not&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#在where条件中使用逻辑运算符-or-and-not&quot;&gt;&lt;/a&gt; 在where条件中使用逻辑运算符: or and not&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>select查询-比较运算符</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/11/select%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/11/select查询和比较运算符/</id>
    <published>2022-05-11T12:38:00.000Z</published>
    <updated>2022-05-11T13:01:45.285Z</updated>
    
    <content type="html"><![CDATA[<h3 id="若在编写sql语句的时候-书写错误-则可以进行修改"><a class="markdownIt-Anchor" href="#若在编写sql语句的时候-书写错误-则可以进行修改"></a> 若在编写sql语句的时候, 书写错误, 则可以进行修改:</h3><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如 SQL&gt; select * ffom</span><br><span class="line">SQL&gt; emp;</span><br><span class="line">先输入: 错误发生的那一行, 然后输入c /ffom/from,最后输入/执行sql语句.</span><br><span class="line">SQL&gt; 2</span><br><span class="line">SQL&gt; c/ffom/from</span><br><span class="line">SQL&gt; /</span><br></pre></td></tr></table></figure><p>​</p><h3 id="若编写的sql语句比较长-可以使用edit打开一个记事本-在记事本上编写"><a class="markdownIt-Anchor" href="#若编写的sql语句比较长-可以使用edit打开一个记事本-在记事本上编写"></a> 若编写的sql语句比较长, 可以使用edit打开一个记事本, 在记事本上编写:</h3><p><img src="/images/javawz/image-20220511204054544.png" alt="image-20220511204054544"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如: SQL&gt;edit , 然后按/执行sql语句</span><br><span class="line">语句末尾不需要加分号</span><br><span class="line">最后以/结束</span><br></pre></td></tr></table></figure><h3 id="保存查询结果"><a class="markdownIt-Anchor" href="#保存查询结果"></a> 保存查询结果:</h3><pre><code>spool名的使用: spool d:\resultsselect * from emp;spool off这样会将查询结果保存到文件中.</code></pre><h2 id="where"><a class="markdownIt-Anchor" href="#where"></a> where</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本结构: select .... from  table  where 条件;</span><br></pre></td></tr></table></figure><h3 id="使用比较运算符-between-and"><a class="markdownIt-Anchor" href="#使用比较运算符-between-and"></a> 使用比较运算符: &gt; &gt;= &lt; &lt;= != (&lt;&gt;) between and</h3><h4 id="1-查询10号部门的员工信息"><a class="markdownIt-Anchor" href="#1-查询10号部门的员工信息"></a> 1 查询10号部门的员工信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where deptno=10;</span><br></pre></td></tr></table></figure><h4 id="2-查询员工名字为king的员工信息"><a class="markdownIt-Anchor" href="#2-查询员工名字为king的员工信息"></a> 2 查询员工名字为king的员工信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where ename = &apos;KING&apos;;</span><br><span class="line">       </span><br><span class="line">结论: 表中的列的值是区分大小写的; 但是关键字不区分大小写</span><br></pre></td></tr></table></figure><h4 id="3-查找薪水不等于1250员工的信息"><a class="markdownIt-Anchor" href="#3-查找薪水不等于1250员工的信息"></a> 3 查找薪水不等于1250员工的信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where sal!=1250;</span><br><span class="line">select * from emp where sal&lt;&gt;1250;</span><br></pre></td></tr></table></figure><h4 id="4-查询入职日期为1981年11月17日的员工信息"><a class="markdownIt-Anchor" href="#4-查询入职日期为1981年11月17日的员工信息"></a> 4 查询入职日期为1981年11月17日的员工信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where hiredate=&apos;1981-11-17&apos;; --查询错误</span><br><span class="line">select * from emp where hiredate=&apos;17-11月-81&apos;;</span><br></pre></td></tr></table></figure><h4 id="查询当前使用的日期格式"><a class="markdownIt-Anchor" href="#查询当前使用的日期格式"></a> 查询当前使用的日期格式:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from v$nls_parameters;</span><br></pre></td></tr></table></figure><h4 id="修改日期格式"><a class="markdownIt-Anchor" href="#修改日期格式"></a> 修改日期格式:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter session set NLS_DATE_FORMAT=&apos;yyyy-mm-dd&apos;;</span><br></pre></td></tr></table></figure><h4 id="修改成原有的格式"><a class="markdownIt-Anchor" href="#修改成原有的格式"></a> 修改成原有的格式:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter session set NLS_DATE_FORMAT=&apos;DD-MON-RR&apos;;</span><br><span class="line">说明: 需要注意日期格式, 默认是DD-MON-RR</span><br></pre></td></tr></table></figure><h4 id="5-查找工资介于1000-2000之间的员工信息"><a class="markdownIt-Anchor" href="#5-查找工资介于1000-2000之间的员工信息"></a> 5 查找工资介于1000-2000之间的员工信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where sal&gt;=1000 and sal&lt;=2000;</span><br><span class="line"></span><br><span class="line">select * from emp where sal between 1000 and 2000;</span><br><span class="line">结论: between and是闭区间</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;若在编写sql语句的时候-书写错误-则可以进行修改&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#若在编写sql语句的时候-书写错误-则可以进行修改&quot;&gt;&lt;/a&gt; 若在编写sql语句的时候, 书写错误, 则可以进行修改:&lt;/h3&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL和sqlplus区别</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/11/SQL%E5%92%8Csqlplus%E5%8C%BA%E5%88%AB/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/11/SQL和sqlplus区别/</id>
    <published>2022-05-11T11:58:46.000Z</published>
    <updated>2022-05-11T12:37:35.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sql和sqlplus"><a class="markdownIt-Anchor" href="#sql和sqlplus"></a> SQL和sqlplus</h2><p>我们已经学习使用了select，应该知道还有update、delete、insert、create…</p><p>同时，我们学习了ed、c、set、col、desc….</p><p>SQL → 语言，关键字不能缩写。</p><p>sqlplus → Oracle提供的工具，可在里面执行SQL语句，它配有自己的命令(ed、c、set、col) 特点是缩写关键字。</p><h3 id="sql"><a class="markdownIt-Anchor" href="#sql"></a> SQL</h3><p>• 一种语言</p><p>• ANSI 标准</p><p>• 关键字不能缩写</p><p>• 使用语句控制数据库中的表的定义信息和表中的数据</p><h3 id="sqlplus"><a class="markdownIt-Anchor" href="#sqlplus"></a> SQL*Plus</h3><p>• 一种环境</p><p>• Oracle 的特性之一</p><p>• 关键字可以缩写</p><p>• 命令不能改变数据库中的数据的值</p><p>• 集中运行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sql和sqlplus&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sql和sqlplus&quot;&gt;&lt;/a&gt; SQL和sqlplus&lt;/h2&gt;
&lt;p&gt;我们已经学习使用了select，应该知道还有update、delete、insert、cr
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>基本的SELECT语句</title>
    <link href="https://xiaowuyoucy.github.io/2022/05/11/%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/"/>
    <id>https://xiaowuyoucy.github.io/2022/05/11/基本的SELECT语句/</id>
    <published>2022-05-11T11:47:23.000Z</published>
    <updated>2022-05-11T11:52:14.880Z</updated>
    
    <content type="html"><![CDATA[<p>SQL语句不区分大小写</p><h3 id="基本的select语句"><a class="markdownIt-Anchor" href="#基本的select语句"></a> 基本的SELECT语句</h3><p>​   <code>其语法格式为：SELECT *|{[DISTINCT] column|expression [alias],...} FROMtable;</code></p><h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例:</h3><h4 id="1-查询所有员工的所有记录"><a class="markdownIt-Anchor" href="#1-查询所有员工的所有记录"></a> 1 查询所有员工的所有记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp;</span><br></pre></td></tr></table></figure><h4 id="2-查询员工号姓名月薪奖金年薪"><a class="markdownIt-Anchor" href="#2-查询员工号姓名月薪奖金年薪"></a> 2 查询员工号，姓名，月薪，奖金，年薪</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select empno, ename, sal, comm, sal*12 from emp;</span><br><span class="line">  </span><br><span class="line">使用select * 和 select 列名的区别: 使用select *会先查有哪些列, 影响效率</span><br></pre></td></tr></table></figure><h4 id="3-对案例2使用别名"><a class="markdownIt-Anchor" href="#3-对案例2使用别名"></a> 3 对案例2使用别名:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select empno, ename, sal as 工资, comm 奖金, sal*12 &quot;年 薪&quot; from emp;</span><br><span class="line"></span><br><span class="line">关于别名的结论: </span><br><span class="line">    as可以省略</span><br><span class="line">    如果别名中间有空格, 需要使用&quot;&quot;引起来</span><br></pre></td></tr></table></figure><h4 id="4-查询员工号姓名月薪奖金年薪年收入"><a class="markdownIt-Anchor" href="#4-查询员工号姓名月薪奖金年薪年收入"></a> 4 查询员工号，姓名，月薪，奖金，年薪，年收入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select empno, ename, sal, comm, sal*12 年薪, sal*12+nvl(comm, 0) 年收入 from emp;</span><br><span class="line"></span><br><span class="line">结论: </span><br><span class="line">  1 包含有null的表达式都为空</span><br><span class="line">  2 nvl的用法: nvl(a, b): 如果a为空, 则取b的值.</span><br></pre></td></tr></table></figure><h4 id="5-查看员工表不同的部门编号"><a class="markdownIt-Anchor" href="#5-查看员工表不同的部门编号"></a> 5 查看员工表不同的部门编号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct deptno from emp;</span><br></pre></td></tr></table></figure><h4 id="6-查看不同部门的不同工种"><a class="markdownIt-Anchor" href="#6-查看不同部门的不同工种"></a> 6 查看不同部门的不同工种</h4><pre><code>select distinct detpno, job from emp;   结论:distinct的作用范围??distinct作用于后面出现的所有的列.</code></pre><h4 id="7-输出计算表达式-3205显示当前日期-sysdate"><a class="markdownIt-Anchor" href="#7-输出计算表达式-3205显示当前日期-sysdate"></a> 7 输出计算表达式 3+20*5，显示当前日期  sysdate</h4><pre><code>select 3+20*5, sysdate from dual;注意: dual表是一个伪表, 主要是为了满足sql的语法规定</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SQL语句不区分大小写&lt;/p&gt;
&lt;h3 id=&quot;基本的select语句&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本的select语句&quot;&gt;&lt;/a&gt; 基本的SELECT语句&lt;/h3&gt;
&lt;p&gt;​	   &lt;code&gt;其语法格式为：SELECT *
      
    
    </summary>
    
      <category term="数据库" scheme="https://xiaowuyoucy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
</feed>
