<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanChen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaowuyoucy.github.io/"/>
  <updated>2022-01-23T12:33:05.975Z</updated>
  <id>https://xiaowuyoucy.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用信号完成两个进程交替数数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/23/linux081%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%88%90%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%95%B0%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/23/linux081使用信号完成两个进程交替数数/</id>
    <published>2022-01-23T12:30:23.000Z</published>
    <updated>2022-01-23T12:33:05.975Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用SIGUSR1和SIGUSR2在父子进程间交替数数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"F:[%d]\n"</span>, num);</span><br><span class="line">num += <span class="number">2</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C:[%d]\n"</span>, num);</span><br><span class="line">num += <span class="number">2</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num=<span class="number">0</span>;</span><br><span class="line">flag  = <span class="number">1</span>;</span><br><span class="line">signal(SIGUSR1, func1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">kill(pid, SIGUSR2);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num=<span class="number">1</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">signal(SIGUSR2, func2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">kill(getppid(), SIGUSR1);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>SIGCHLD</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/23/linux080SIGCHLD/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/23/linux080SIGCHLD/</id>
    <published>2022-01-23T11:15:47.000Z</published>
    <updated>2022-01-23T12:29:57.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="产生sigchld信号的条件"><a class="markdownIt-Anchor" href="#产生sigchld信号的条件"></a> 产生SIGCHLD信号的条件</h3><ul><li><p>子进程结束的时候</p></li><li><p>子进程收到SIGSTOP信号</p></li><li><p>当子进程停止时，收到SIGCONT信号</p></li></ul><h3 id="sigchld信号的作用"><a class="markdownIt-Anchor" href="#sigchld信号的作用"></a> SIGCHLD信号的作用</h3><p>​子进程退出后，内核会给它的父进程发送SIGCHLD信号，父进程收到这个信号后可以对子进程进行回收。</p><p>​使用SIGCHLD信号完成对子进程的回收可以避免父进程阻塞等待而不能执行其他操作，只有当父进程收到SIGCHLD信号之后才去调用信号捕捉函数完成对子进程的回收，未收到SIGCHLD信号之前可以处理其他操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对SIGCHLD信号测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child [%d]\n"</span>,pid);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">signal(SIGCHLD,sighandler);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fater [%d]\n"</span>,pid);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -19 子进程id号 //对子进程发送SIGSTOP信号,然后产生SIGCHLD信号</span><br><span class="line">kill -18 子进程id号 //对子进程发送SIGCONT信号,然后产生SIGCHLD信号</span><br></pre></td></tr></table></figure><h3 id="使用sigchld信号完成对子进程的回收"><a class="markdownIt-Anchor" href="#使用sigchld信号完成对子进程的回收"></a> 使用SIGCHLD信号完成对子进程的回收</h3><ul><li><p>练习：父进程创建三个子进程，然后让父进程捕获SIGCHLD信号完成对子进程的回收。</p></li><li><p>注意点：</p></li><li><p>有可能还未完成信号处理函数的注册三个子进程都退出了。</p></li><li><p>解决办法：可以在fork之前先将SIGCHLD信号阻塞，当完成信号处理函数的注册后在解除阻塞。</p></li><li><p>当SIGCHLD信号函数处理期间, SIGCHLD信号若再次产生是被阻塞的,而且若产生了多次, 则该信号只会被处理一次, 这样可能会产生僵尸进程。</p></li><li><p>解决办法: 可以在信号处理函数里面使用while(1)循环回收, 这样就有可能出现捕获一次SIGCHLD信号但是回收了多个子进程的情况，从而可以避免产生僵尸进程。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父进程使用SICCHLD信号完成对子进程的回收</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitchild</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> wpid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回收子进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line"><span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child is quit, wpid==[%d]\n"</span>, wpid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child is living, wpid==[%d]\n"</span>, wpid);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"no child is living, wpid==[%d]\n"</span>, wpid);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将SIGCHLD信号阻塞</span></span><br><span class="line"><span class="keyword">sigset_t</span> mask;</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line">sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//fork子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) <span class="comment">//fork失败的情况</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>) <span class="comment">//父进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: fpid==[%d], cpid==[%d]\n"</span>, getpid(), pid);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: fpid==[%d], cpid==[%d]\n"</span>, getppid(), getpid());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:father: fpid==[%d]\n"</span>, i, getpid());</span><br><span class="line"><span class="comment">//signal(SIGCHLD, waitchild);</span></span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = waitchild;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除对SIGCHLD信号的阻塞</span></span><br><span class="line">sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第1个子进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:child: cpid==[%d]\n"</span>, i, getpid());</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第2个子进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:child: cpid==[%d]\n"</span>, i, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第3个子进程</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]:child: cpid==[%d]\n"</span>, i, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;产生sigchld信号的条件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#产生sigchld信号的条件&quot;&gt;&lt;/a&gt; 产生SIGCHLD信号的条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;子进程结束的时候&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>sigaction函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/22/linux079sigaction/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/22/linux079sigaction/</id>
    <published>2022-01-22T13:10:27.000Z</published>
    <updated>2022-01-23T08:35:04.927Z</updated>
    
    <content type="html"><![CDATA[<ul><li>sigaction函数</li><li>函数说明：注册一个信号处理函数</li><li>函数原型：</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</span><br></pre></td></tr></table></figure><ul><li>函数参数：</li><li>signum：捕捉的信号</li><li>act：  传入参数，新的处理方式。</li><li>oldact： 传出参数，旧的处理方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction &#123;</span><br><span class="line"></span><br><span class="line">void  (*sa_handler)(int);// 信号处理函数</span><br><span class="line"></span><br><span class="line">void  (*sa_sigaction)(int, siginfo_t *, void *); //信号处理函数</span><br><span class="line"></span><br><span class="line">sigset_t  sa_mask; //信号处理函数执行期间需要阻塞的信号</span><br><span class="line"></span><br><span class="line">int    sa_flags; //通常为0，表示使用默认标识</span><br><span class="line"></span><br><span class="line">void   (*sa_restorer)(void);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>总结：</p><ul><li>sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作</li><li>sa_mask: 用来指定在信号处理函数执行期间需要被屏蔽的信号，特别是当某个信号被处理时，它自身会被自动放入进程的信号掩码，因此在信号处理函数执行期间这个信号不会再度发生。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</li><li>sa_flags：通常设置为0，使用默认属性。</li><li>sa_restorer：已不再使用</li></ul></li><li><p>练习：编写程序，使用sigaction函数注册信号捕捉函数，并使用这个程序验证信号是否支持排队。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sigaction函数测试---注册信号处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">sleep(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = sighandler;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);  <span class="comment">//在信号处理函数执行期间, 不阻塞任何信号</span></span><br><span class="line">sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signal(SIGQUIT, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>知识点: 信号处理不支持排队:</p></li><li><p>在XXX信号处理函数执行期间, XXX信号是被阻塞的, 如果该信号产生了多次, 在XXX信号处理函数结束之后,  该XXX信号只被处理一次.</p></li><li><p>在XXX信号处理函数执行期间,如果阻塞了YYY信号, 若YYY信号产生了多次, 当XXX信号处理函数结束后, YYY信号只会被处理一次.</p></li><li><p>内核实现信号捕捉的过程</p></li></ul><p>如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这称为捕捉信号。由于信号处理函数的代码是在用户空间的，处理过程比较复杂，举例如下：</p><p>用户程序注册了SIGQUIT信号的处理函数sighandler。</p><p>当前正在执行main函数，这时发生中断或异常切换到内核态。</p><p>在中断处理完毕后要返回用户态的main函数之前检查到有信号SIGQUIT递达。</p><p>内核决定返回用户态后不是恢复main函数的上下文继续执行，而是执行sighandler函数，sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系，是两个独立的控制流程。</p><p>sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态。</p><p>如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行了。</p><p><img src="/images/javawz/wps7CFB.tmp.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;sigaction函数&lt;/li&gt;
&lt;li&gt;函数说明：注册一个信号处理函数&lt;/li&gt;
&lt;li&gt;函数原型：&lt;/li&gt;
&lt;/ul&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>信号集相关函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/22/linux078%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/22/linux078信号集相关函数/</id>
    <published>2022-01-22T06:35:35.000Z</published>
    <updated>2022-01-22T13:07:07.163Z</updated>
    
    <content type="html"><![CDATA[<p>由于信号集属于内核的一块区域，用户不能直接操作内核空间，为此，内核提供了一些信号集相关的接口函数，使用这些函数用户就可以完成对信号集的相关操作。</p><p>信号集是一个能表示多个信号的数据类型，<code>sigset_t set</code>，set即一个信号集。既然是一个集合，就需要对集进行添加、删除等操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sigset_t类型的定义在signal.h文件中的第49行处:</span><br><span class="line">typedef __sigset_t sigset_t;</span><br><span class="line">__sigset_t的定义在sigset.h文件中的26，27行处: </span><br><span class="line"># define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span><br><span class="line"></span><br><span class="line">  typedef struct</span><br><span class="line">  &#123;</span><br><span class="line">    unsigned long int __val[_SIGSET_NWORDS];</span><br><span class="line">  &#125; __sigset_t;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">上述变量类型的定义的查找有个小窍门： 可以执行gcc的预处理命令：</span><br><span class="line">gcc -E test.c -o test.i 这样头文件就会展开，可以直接到test.i文件中看到相关变量类型的定义。</span><br></pre></td></tr></table></figure><p>信号集相关函数</p><ul><li><code>int sigemptyset(sigset_t *set);</code></li></ul><p>函数说明：将某个信号集清0</p><p>函数返回值：成功：0；失败：-1，设置errno</p><ul><li><code>int sigfillset(sigset_t *set);</code></li></ul><p>函数说明：将某个信号集置1</p><p>函数返回值：成功：0；失败：-1，设置errno</p><ul><li><code>int sigaddset(sigset_t *set, int signum);</code></li></ul><p>函数说明：将某个信号加入信号集合中</p><p>函数返回值：成功：0；失败：-1，设置errno</p><ul><li><code>int sigdelset(sigset_t *set, int signum);</code></li></ul><p>函数说明：将某信号从信号清出信号集</p><p>函数返回值：成功：0；失败：-1，设置errno</p><ul><li><code>int sigismember(const sigset_t *set, int signum);</code></li></ul><p>函数说明：判断某个信号是否在信号集中</p><p>函数返回值：在：1；不在：0；出错：-1，设置errno</p><ul><li>sigprocmask函数</li></ul><p>函数说明：用来屏蔽信号、解除屏蔽也使用该函数。其本质，读</p><p>取或修改进程控制块中的信号屏蔽字（阻塞信号集）。</p><p>特别注意，屏蔽信号只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢弃处理。</p><p>函数原型：<code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code></p><p>函数返回值：成功：0；失败：-1，设置errno</p><p>函数参数：</p><p>how参数取值：假设当前的信号屏蔽字为mask</p><p><code>SIG_BLOCK</code>: 当how设置为此值，set表示需要屏蔽的信号。<strong>相当于</strong> mask = mask | set</p><p><code>SIG_UNBLOCK</code>: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~set</p><p><code>SIG_SETMASK</code>: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于mask = set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</p><p>set：传入参数，是一个自定义信号集合。由参数how来指示如何修改当前信号屏蔽字。</p><p>oldset：传出参数，保存旧的信号屏蔽字。</p><ul><li>sigpending函数</li></ul><p>函数原型：<code>int sigpending(sigset_t *set);</code></p><p>函数说明：读取当前进程的未决信号集</p><p>函数参数：set传出参数</p><p>函数返回值：成功：0；失败：-1，设置errno</p><p>练习：编写程序，设置阻塞信号集并把所有常规信号的未决状态打印至屏幕。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号集相关函数测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册SIGINT和SIGQUIT的信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line">signal(SIGQUIT, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义sigset_t类型的变量</span></span><br><span class="line"><span class="keyword">sigset_t</span> pending, mask, oldmask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">sigemptyset(&amp;pending);</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line">sigemptyset(&amp;oldmask);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将SIGINT和SIGQUIT加入到阻塞信号集中</span></span><br><span class="line">sigaddset(&amp;mask, SIGINT);</span><br><span class="line">sigaddset(&amp;mask, SIGQUIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将mask中的SIGINT和SIGQUIT信号加入到阻塞信号集中</span></span><br><span class="line"><span class="comment">//sigprocmask(SIG_BLOCK, &amp;mask, NULL);</span></span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;oldmask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取未决信号集</span></span><br><span class="line">sigpending(&amp;pending);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">32</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断某个信号是否在集合中</span></span><br><span class="line"><span class="keyword">if</span>(sigismember(&amp;pending, i)==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k++%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从阻塞信号集中解除对SIGINT和SIGQUIT的阻塞</span></span><br><span class="line"><span class="comment">//sigprocmask(SIG_UNBLOCK, &amp;mask, NULL);</span></span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于信号集属于内核的一块区域，用户不能直接操作内核空间，为此，内核提供了一些信号集相关的接口函数，使用这些函数用户就可以完成对信号集的相关操作。&lt;/p&gt;
&lt;p&gt;信号集是一个能表示多个信号的数据类型，&lt;code&gt;sigset_t set&lt;/code&gt;，set即一个信号集。既然
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>未决信号集和阻塞信号集的关系</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/22/linux077%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/22/linux077未决信号集和阻塞信号集的关系/</id>
    <published>2022-01-22T05:56:34.000Z</published>
    <updated>2022-01-22T07:37:44.866Z</updated>
    
    <content type="html"><![CDATA[<p>未决信号集和阻塞信号集的关系</p><p>阻塞信号集是当前进程要阻塞的信号的集合，未决信号集是当前进程中还处于未决状态的信号的集合，这两个集合存储在内核的PCB中。</p><ul><li>下面以SIGINT为例说明信号未决信号集和阻塞信号集的关系：</li><li>编号从1开始</li><li>当进程收到一个SIGINT信号（信号编号为2），首先这个信号会保存在未决信号集合中，此时对应的2号编号的这个位置上置为1，表示处于未决状态；在这个信号需要被处理之前首先要在阻塞信号集中的编号为2的位置上去检查该值是否为1：</li><li>如果为1，表示SIGNIT信号被当前进程阻塞了，这个信号暂时不被处理，所以未决信号集上该位置上的值保持为1，表示该信号处于未决状态；</li><li>如果为0，表示SIGINT信号没有被当前进程阻塞，这个信号需要被处理，内核会对SIGINT信号进行处理（执行默认动作，忽略或者执行用户自定义的信号处理函数），并将未决信号集中编号为2的位置上将1变为0，表示该信号已经处理了，这个时间非常短暂，用户感知不到。</li></ul><p>当SIGINT信号从阻塞信号集中解除阻塞之后，该信号就会被处理。</p><p><img src="/images/javawz/wpsB642.tmp.jpg" alt="img"></p><p>未决信号集和阻塞信号集的数据类型都是<code>sigset_t</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;未决信号集和阻塞信号集的关系&lt;/p&gt;
&lt;p&gt;阻塞信号集是当前进程要阻塞的信号的集合，未决信号集是当前进程中还处于未决状态的信号的集合，这两个集合存储在内核的PCB中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下面以SIGINT为例说明信号未决信号集和阻塞信号集的关系：&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>setitimer函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/22/linux076setitimer%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/22/linux076setitimer函数/</id>
    <published>2022-01-21T16:27:46.000Z</published>
    <updated>2022-01-22T05:19:25.228Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>函数原型</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);</span><br></pre></td></tr></table></figure><ul><li><strong>函数描述</strong></li></ul><p>设置定时器(闹钟)，可代替alarm函数，精度微秒us，可以实现周期定时。</p><ul><li><p><strong>函数返回值</strong></p><ul><li>成功：0；</li><li>失败：-1，设置errno值</li></ul></li><li><p><strong>函数参数：</strong></p></li><li><p>which：指定定时方式</p></li><li><p>自然定时：<code>ITIMER_REAL</code> → <strong>14）SIGALRM</strong>计算自然时间</p></li><li><p>虚拟空间计时(用户空间)：<code>ITIMER_VIRTUAL</code>→ <strong>26）SIGVTALRM</strong> 只计算进程占用cpu的时间</p></li><li><p>运行时计时(用户+内核)：<code>ITIMER_PROF</code> → <strong>27）SIGPROF</strong>计算占用cpu及执行系统调用的时间</p></li><li><p>new_value：<code>struct itimerval</code>, 负责设定timeout时间。</p><ul><li><code>itimerval.it_value</code>: 设定第一次执行function所延迟的秒数</li><li><code>itimerval.it_interval</code>: 设定以后每几秒执行function</li></ul></li><li><p>old_value： 存放旧的timeout值，一般指定为NULL</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct itimerval &#123; </span><br><span class="line"></span><br><span class="line">  struct timerval it_interval; // 闹钟触发周期</span><br><span class="line"></span><br><span class="line">  struct timerval it_value; // 闹钟触发时间</span><br><span class="line"></span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"> struct timeval &#123; </span><br><span class="line"></span><br><span class="line">  long tv_sec; // 秒</span><br><span class="line"></span><br><span class="line">  long tv_usec; // 微秒</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>练习: 使用setitimer实现每隔一秒打印一次hello, world。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo [%d]\n"</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册捕获SIGALRM信号处理函数</span></span><br><span class="line">signal(SIGALRM,sighandler);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tm</span>;</span></span><br><span class="line"><span class="comment">//周期性时间赋值</span></span><br><span class="line">tm.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">tm.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//第一次触发的时间,3秒后每隔1秒发送一次SIGALRM信号</span></span><br><span class="line">tm.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">tm.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setitimer(ITIMER_REAL,&amp;tm,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>alarm函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/21/linux075alarm%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/21/linux075alarm函数/</id>
    <published>2022-01-21T12:20:15.000Z</published>
    <updated>2022-01-21T12:34:18.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="alarm函数"><a class="markdownIt-Anchor" href="#alarm函数"></a> alarm函数</h3><ul><li><p>函数原型：<code>unsigned int alarm(unsigned int seconds);</code></p></li><li><p>函数描述：设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。</p></li><li><p>函数返回值：返回0或剩余的秒数，无失败。例如：</p></li></ul><p><img src="/images/javawz/wps5652.tmp.jpg" alt="img"></p><ul><li>常用操作：取消定时器alarm(0)，返回旧闹钟余下秒数。</li></ul><p>alarm使用的是自然定时法，与进程状态无关，就绪、运行、挂起(阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm都计时。</p><br><p>=============================================================================</p><br><p>练习题1：编写一个程序测试alarm函数</p><p>练习题2：编写程序，测试你的电脑1秒种能数多个数字。</p><ul><li><p>使用time命令查看程序执行的时间。程序运行的瓶颈在于IO，优化程序，首选优化IO。</p></li><li><p>实际执行时间 = 系统时间 + 用户时间 + 损耗时间</p></li></ul><p>损耗的时间主要来来自文件IO操作，IO操作会有用户区到内核区的切换，切换的次数越多越耗时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal函数测试---注册信号处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line">signal(SIGALRM, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = alarm(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"first: n==[%d]\n"</span>, n);</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">n = alarm(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//n = alarm(0); //取消时钟</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"second: n==[%d]\n"</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试1秒钟可以数多少数字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//一秒钟后发送信号</span></span><br><span class="line">alarm(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d]"</span>, i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="time命令"><a class="markdownIt-Anchor" href="#time命令"></a> time命令</h3><p>查看程序使用的时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time 程序名</span><br><span class="line"></span><br><span class="line">real   实际执行时间</span><br><span class="line">user    用户时间</span><br><span class="line">sys     系统时间(内核时间)</span><br></pre></td></tr></table></figure><p>实际执行时间 = 系统时间 + 用户时间 + 损耗时间<br>损耗时间= 实际执行时间-(系统时间 + 用户时间 )<br>每一个数字都直接打印:<code>printf(&quot;[%d]\n&quot;, i++);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">real    0m1.217s</span><br><span class="line">user    0m0.120s</span><br><span class="line">sys     0m0.252s</span><br><span class="line">15734次</span><br></pre></td></tr></table></figure><p><code>损耗时间= 1.217-(0.120+0.252)=0.845</code><br>文件重定向之后:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time ./alarm_uncle  &gt; test.log</span><br><span class="line">real    0m1.003s</span><br><span class="line">user    0m0.520s</span><br><span class="line">sys     0m0.428s</span><br><span class="line">2191879次</span><br></pre></td></tr></table></figure><p><code>损耗时间=1.003-(0.520+0.428)=0.055</code><br>原因是: 调用<code>printf</code>函数打印数字遇到<code>\n</code>才会打印, 打印过程涉及到从<br>用户区到内核区的切换, 切换次数越多消耗的时间越长, 效率越低;<br>而使用文件重定向, 由于文件操作是带缓冲的, 所以涉及到用户区到内核区的<br>切换次数大大减少,从而使损耗降低.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;alarm函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#alarm函数&quot;&gt;&lt;/a&gt; alarm函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数原型：&lt;code&gt;unsigned int alarm(unsigned int seco
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>abort函数和raise函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/20/linux074abort%E5%87%BD%E6%95%B0%E5%92%8Craise%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/20/linux074abort函数和raise函数/</id>
    <published>2022-01-20T12:16:22.000Z</published>
    <updated>2022-01-20T13:51:22.352Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>raise函数</p><ul><li><p>函说描述：给当前进程发送指定信号(自己给自己发)</p></li><li><p>函数原型：</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int raise(int sig);</span><br></pre></td></tr></table></figure><ul><li><p>函数返回值：成功：0，失败非0值</p></li><li><p>函数拓展:</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise(signo) == kill(getpid(), signo);</span><br></pre></td></tr></table></figure><ul><li><p>abort函数</p></li><li><p>函数描述：给自己发送异常终止信号 <strong>6) SIGABRT</strong>，并产生core文件</p></li><li><p>函数原型：<code>void abort(void);</code></p></li><li><p>设置core文件大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited//无限制大小</span><br><span class="line">ulimit -x//x代表的是 下面带-的参数,比如-c</span><br><span class="line">yxc19980620c@yc:~/my/demo05$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 15434</span><br><span class="line">max locked memory       (kbytes, -l) 65536</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 15434</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure></li><li><p>函数拓展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abort() == kill(getpid(), SIGABRT);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//raise和abort函数测-</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给当前进程发送SIGINT信号</span></span><br><span class="line">raise(SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给当前进程发送SIGABRT</span></span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;raise函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函说描述：给当前进程发送指定信号(自己给自己发)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>信号相关函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/20/linux073%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/20/linux073信号相关函数/</id>
    <published>2022-01-20T10:38:02.000Z</published>
    <updated>2022-01-20T10:45:23.684Z</updated>
    
    <content type="html"><![CDATA[<h3 id="signal函数"><a class="markdownIt-Anchor" href="#signal函数"></a> signal函数</h3><ul><li><p>函数作用：注册信号捕捉函数</p></li><li><p>函数原型</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line"></span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br></pre></td></tr></table></figure><ul><li><p>函数参数</p><ul><li>signum：信号编号</li><li>handler：信号处理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal函数测试---注册信号处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//while(1)</span></span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="kill函数命令"><a class="markdownIt-Anchor" href="#kill函数命令"></a> kill函数/命令</h3><ul><li><p>描述：给指定进程发送指定信号</p></li><li><p>kill命令：kill -SIGKILL 进程PID</p></li><li><p>kill函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int kill(pid_t pid, int sig);</span><br></pre></td></tr></table></figure></li><li><p>函数返回值：</p><ul><li>成功：0；</li><li>失败：-1，设置errno</li></ul></li><li><p>函数参数：</p><ul><li>sig信号参数：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</li><li>pid参数：</li><li>pid &gt; 0: 发送信号给指定的进程。</li><li>pid = 0: 发送信号给与调用kill函数进程属于同一进程组的所有进程。</li><li>pid &lt; -1:  取|pid|发给对应进程组。</li><li>pid = -1：发送给进程有权限发送的系统中所有进程。</li></ul></li></ul><p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal函数测试---注册信号处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signo==[%d]\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册信号处理函数</span></span><br><span class="line">signal(SIGINT, sighandler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">kill(getpid(), SIGINT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;signal函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#signal函数&quot;&gt;&lt;/a&gt; signal函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数作用：注册信号捕捉函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数原型&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>信号的基本概念</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/20/linux072%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/20/linux072信号的基本概念/</id>
    <published>2022-01-20T08:51:19.000Z</published>
    <updated>2022-01-22T16:21:43.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号介绍"><a class="markdownIt-Anchor" href="#信号介绍"></a> 信号介绍</h2><ul><li>信号的概念</li></ul><p>信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</p><ul><li><p>信号在我们的生活中随处可见，例如：</p><ul><li><p>古代战争中摔杯为号；</p></li><li><p>现代战争中的信号弹;</p></li><li><p>体育比赛中使用的信号枪…</p></li></ul></li><li><p>信号的特点</p><ul><li>简单</li><li>不能携带大量信息</li><li>满足某个特点条件才会产生</li></ul></li></ul><h2 id="2-信号的机制"><a class="markdownIt-Anchor" href="#2-信号的机制"></a> 2 信号的机制</h2><p>进程A给进程B发送信号，进程B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕后再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</p><p><code>每个进程收到的所有信号，都是由内核负责发送的。</code></p><p>进程A给进程B发送信号示意图：</p><p><img src="/images/javawz/wps6534.tmp.jpg" alt="img"></p><p><img src="/images/javawz/image-20220120172232030.png" alt="image-20220120172232030"></p><h3 id="21信号的状态"><a class="markdownIt-Anchor" href="#21信号的状态"></a> 2.1信号的状态</h3><p>信号有三种状态：产生、未决和递达。</p><ul><li><p>信号的产生</p><ul><li>按键产生，如：Ctrl+c(终止进程SIGINT)、Ctrl+z(挂起进程SIGTSTP)、Ctrl+\(退出进程SIGQUIT)</li><li>系统调用产生，如：kill、raise、abort</li><li>软件条件产生，如：定时器alarm</li><li>硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</li><li>命令产生，如：kill命令</li></ul></li><li><p>未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。</p></li><li><p>递达：递送并且到达进程。</p></li></ul><h3 id="22-信号的处理方式"><a class="markdownIt-Anchor" href="#22-信号的处理方式"></a> 2.2 信号的处理方式</h3><ul><li><p>执行默认动作</p></li><li><p>忽略信号(丢弃不处理)</p></li><li><p>捕捉信号(调用用户的自定义的处理函数)</p></li></ul><h3 id="23-信号的特质"><a class="markdownIt-Anchor" href="#23-信号的特质"></a> 2.3 信号的特质</h3><p>信号的实现手段导致信号<code>有很强的延时性</code>，但对于用户来说，时间非常短，不易察觉。</p><p>Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集</strong>。</p><p>注:表示PCB的task_struct结构体定义在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/src/linux-headers-4.4.0-97/include/linux/sched.h:1390</span><br></pre></td></tr></table></figure><h3 id="24-阻塞信号集和未决信号集"><a class="markdownIt-Anchor" href="#24-阻塞信号集和未决信号集"></a> 2.4 阻塞信号集和未决信号集</h3><p>Linux内核的进程控制块PCB是一个结构体，这个结构体里面包含了信号相关的信息，主要有阻塞信号集和未决信号集。</p><ul><li><p>阻塞信号集中保存的都是被当前进程阻塞的信号。若当前进程收到的是阻塞信号集中的某些信号，这些信号需要暂时被阻塞，不予处理。</p></li><li><p>信号产生后由于某些原因(主要是阻塞)不能抵达，这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态；若是信号从阻塞信号集中解除阻塞，则该信号会被处理，并从未决信号集中去除。</p></li></ul><h3 id="25信号的四要素"><a class="markdownIt-Anchor" href="#25信号的四要素"></a> 2.5信号的四要素</h3><ul><li>通过<code>man 7 signal</code>可以查看信号相关信息</li><li>信号编号</li><li>信号的名字</li><li>信号的默认处理(默认终止进程)</li><li>信号如何产生</li></ul><h4 id="1-信号的编号"><a class="markdownIt-Anchor" href="#1-信号的编号"></a> 1 信号的编号</h4><p>使用kill -l命令可以查看当前系统有哪些信号，不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。</p><h4 id="2-信号的名称"><a class="markdownIt-Anchor" href="#2-信号的名称"></a> 2 信号的名称</h4><h4 id="3-产生信号的事件"><a class="markdownIt-Anchor" href="#3-产生信号的事件"></a> 3 产生信号的事件</h4><h4 id="4信号的默认处理动作"><a class="markdownIt-Anchor" href="#4信号的默认处理动作"></a> 4信号的默认处理动作</h4><p><strong>Term</strong>：终止进程</p><p><strong>Ign</strong>：忽略信号 (默认即时对该种信号忽略操作)</p><p><strong>Core</strong>：终止进程，生成Core文件。(查验死亡原因，用于gdb调试)</p><p><strong>Stop</strong>：停止（暂停）进程</p><p><strong>Cont</strong>：继续运行进程</p><ul><li><p>特别需要注意的是：The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.(无法捕获、阻止或忽略信号SIGKILL和SIGSTOP。)</p></li><li><p>几个常用到的信号</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">SIGINT、SIGQUIT、SIGKILL、SIGSEGV、SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM、SIGTERM、SIGCHLD、SIGSTOP、SIGCONT</span><br><span class="line"></span><br><span class="line">SIGHUP        1       A     在控制终端上是挂起信号, 或者控制进程结束</span><br><span class="line">SIGINT        2       A     从键盘输入的中断</span><br><span class="line">SIGQUIT       3       C     从键盘输入的退出</span><br><span class="line">SIGILL        4       C     无效硬件指令</span><br><span class="line">SIGABRT       6       C     非正常终止, 可能来自 abort(3)</span><br><span class="line">SIGFPE        8       C     浮点运算例外</span><br><span class="line">SIGKILL       9      AEF    杀死进程信号</span><br><span class="line">SIGSEGV      11       C     无效的内存引用</span><br><span class="line">SIGPIPE      13       A     管道中止: 写入已经关闭读取的管道</span><br><span class="line">SIGALRM      14       A     来自 alarm(2) 的超时信号</span><br><span class="line">SIGTERM      15       A     终止信号</span><br><span class="line">SIGUSR1   30,10,16    A     用户定义的信号 1</span><br><span class="line">SIGUSR2   31,12,17    A     用户定义的信号 2</span><br><span class="line">SIGCHLD   20,17,18    B     子进程结束或停止</span><br><span class="line">SIGCONT   19,18,25          继续停止的进程</span><br><span class="line">SIGSTOP   17,19,23   DEF    停止进程</span><br><span class="line">SIGTSTP   18,20,24    D     终端上发出的停止信号</span><br><span class="line">SIGTERM      15       A     终止信号</span><br><span class="line">SIGUSR1   30,10,16    A     用户定义的信号 1</span><br><span class="line">SIGUSR2   31,12,17    A     用户定义的信号 2</span><br><span class="line">SIGCHLD   20,17,18    B     子进程结束或停止</span><br><span class="line">SIGFPE        8       C     浮点运算例外</span><br><span class="line">SIGABRT       6       C     非正常终止, 可能来自 abort(3)</span><br><span class="line">SIGQUIT       3       C     从键盘输入的退出</span><br><span class="line">SIGILL        4       C     无效硬件指令</span><br><span class="line">SIGABRT       6       C     非正常终止, 可能来自 abort(3)</span><br><span class="line">SIGFPE        8       C     浮点运算例外</span><br><span class="line">SIGKILL       9      AEF    杀死进程信号</span><br><span class="line">SIGSEGV      11       C     无效的内存引用</span><br><span class="line">SIGPIPE      13       A     管道中止: 写入无人读取的管道</span><br><span class="line">SIGALRM      14       A     来自 alarm(2) 的超时信号</span><br><span class="line">SIGTERM      15       A     终止信号</span><br><span class="line">SIGUSR1   30,10,16    A     用户定义的信号 1</span><br><span class="line">SIGUSR2   31,12,17    A     用户定义的信号 2</span><br><span class="line">SIGCHLD   20,17,18    B     子进程结束或停止</span><br><span class="line">SIGCONT   19,18,25          继续停止的进程</span><br><span class="line">SIGSTOP   17,19,23   DEF    停止进程</span><br><span class="line">SIGTSTP   18,20,24    D     终端上发出的停止信号</span><br><span class="line">SIGTTIN   21,21,26    D     后台进程试图从控制终端(tty)输入</span><br><span class="line">SIGTTOU   22,22,27    D     后台进程试图在控制终端(tty)输出</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;信号介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#信号介绍&quot;&gt;&lt;/a&gt; 信号介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;信号的概念&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>第二章物理层</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/20/第二章物理层/</id>
    <published>2022-01-19T17:14:47.000Z</published>
    <updated>2022-01-19T17:19:57.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="物理层定义的标准"><a class="markdownIt-Anchor" href="#物理层定义的标准"></a> 物理层定义的标准</h3><p>1.物理层解决如何在连接各种计算机的传输媒体上传输数据比特流 （0101…）。<br>物理层的主要任务：确定传输媒体的接口的一些特性：<br>1）机械特性：接口形状，大小，引线数目。<br>2）电气特性：规定电压范围（-5V到5V）。<br>3）功能特性：例如规定-5V是0，+5V是1.<br>4)过程特性：（规程特性）规定建立连接时各个相关部件的工作步骤(比如一个大可乐瓶和一个小可乐瓶,他们的瓶盖都是通用的,说明接口一样大小)。</p><h3 id="数据通信基础知识"><a class="markdownIt-Anchor" href="#数据通信基础知识"></a> 数据通信基础知识</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;物理层定义的标准&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#物理层定义的标准&quot;&gt;&lt;/a&gt; 物理层定义的标准&lt;/h3&gt;
&lt;p&gt;1.物理层解决如何在连接各种计算机的传输媒体上传输数据比特流 （0101…）。&lt;br&gt;
物理层的主要任务：确
      
    
    </summary>
    
      <category term="计算机网络原理" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>内存映射区</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/19/linux071%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/19/linux071内存映射区/</id>
    <published>2022-01-19T11:37:10.000Z</published>
    <updated>2022-01-19T16:36:41.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="存储映射区介绍"><a class="markdownIt-Anchor" href="#存储映射区介绍"></a> 存储映射区介绍</h3><p>​存储映射<code>I/O (Memory-mapped I/O)</code>使一个磁盘文件与存储空间中的一个缓冲区相映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样，就可在不使用read和write函数的情况下，使用地址（指针）完成I/O操作。</p><p>使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。</p><img src="/images/javawz/image-20220119222706887.png" height="140%" width="35%"><h3 id="mmap函数"><a class="markdownIt-Anchor" href="#mmap函数"></a> mmap函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br></pre></td></tr></table></figure><h4 id="函数作用"><a class="markdownIt-Anchor" href="#函数作用"></a> 函数作用:</h4><p>建立存储映射区</p><h4 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> 函数原型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br></pre></td></tr></table></figure><h4 id="函数返回值"><a class="markdownIt-Anchor" href="#函数返回值"></a> 函数返回值：</h4><p>成功：返回创建的映射区首地址；</p><p>失败：<code>MAP_FAILED</code>宏 并设置errno</p><h4 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数：</h4><p>addr: 指定映射的起始地址, 通常设为NULL, 由系统指定</p><p>length：映射到内存的文件长度</p><p>prot：映射区的保护方式, 最常用的:</p><p>读：<code>PROT_READ</code></p><p>写：<code>PROT_WRITE</code></p><p>读写：<code>PROT_READ | PROT_WRITE</code></p><p>flags：映射区的特性, 可以是</p><p><code>MAP_SHARED</code>: 写入映射区的数据会写回文件, 且允许其他映射该文件的进程共享。</p><p><code>MAP_PRIVATE</code>: 对映射区的写入操作会产生一个映射区的复制(copy-on-write), 对此区域所做的修改不会写回原文件。</p><p>fd：由open返回的文件描述符, 代表要映射的文件。</p><p>offset：以文件开始处的偏移量, <strong>必须是4k的整数倍</strong>, 通常为0, 表示从文件头开始映射。</p><h3 id="munmap函数"><a class="markdownIt-Anchor" href="#munmap函数"></a> munmap函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br></pre></td></tr></table></figure><h4 id="函数作用-2"><a class="markdownIt-Anchor" href="#函数作用-2"></a> 函数作用:</h4><p>释放由mmap函数建立的存储映射区</p><h4 id="函数原型-2"><a class="markdownIt-Anchor" href="#函数原型-2"></a> 函数原型:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int munmap(void *addr, size_t length);</span><br></pre></td></tr></table></figure><h4 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值：</h4><p>成功：返回0</p><p>失败：返回-1，设置errno值</p><h4 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数:</h4><p>addr：调用mmap函数成功返回的映射区首地址</p><p>length：映射区大小（mmap函数的第二个参数）</p><h4 id="mmap注意事项"><a class="markdownIt-Anchor" href="#mmap注意事项"></a> mmap注意事项</h4><p>创建映射区的过程中，隐含着一次对映射文件的读操作，将文件内容读取到映射区</p><p>当MAP_SHARED时，要求：映射区的权限应 &lt;=文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</p><p>映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭。</p><p>特别注意，当映射文件大小为0时，不能创建映射区。所以，用于映射的文件必须要有实际大小；mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。</p><p>munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。</p><p>文件偏移量必须为0或者4K的整数倍</p><p>mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</p><h4 id="有关mmap函数的使用总结"><a class="markdownIt-Anchor" href="#有关mmap函数的使用总结"></a> 有关mmap函数的使用总结</h4><p>第一个参数写成NULL</p><p>第二个参数要映射的文件大小 &gt; 0</p><p>第三个参数：PROT_READ 、PROT_WRITE</p><p>第四个参数：MAP_SHARED 或者 MAP_PRIVATE</p><p>第五个参数：打开的文件对应的文件描述符</p><p>第六个参数：4k的整数倍</p><h4 id="mmap函数相关思考题"><a class="markdownIt-Anchor" href="#mmap函数相关思考题"></a> mmap函数相关思考题</h4><p>可以open的时候O_CREAT一个新文件来创建映射区吗?</p><p>答:不可以,因为刚刚创建出来的文件大小是0</p><p>如果open时O_RDONLY, mmap时PROT参数指定<code>PROT_READ|PROT_WRITE</code>会怎样？</p><p>答:open的权限应该大于等于mmap</p><p>mmap映射完成之后, 文件描述符关闭，对mmap映射有没有影响？</p><p>答:没有影响</p><p>如果文件偏移量为1000会怎样？</p><p>答:必须为4K的整倍数</p><p>对mem越界操作会怎样？</p><p>答:出错</p><p>如果<code>mem++</code>，munmap可否成功？</p><p>答:出错</p><p>mmap什么情况下会调用失败？</p><p>答:指定错误参数或内存不足的时候</p><p>如果不检测mmap的返回值，会怎样？</p><p>答:如果mmap返回的是-1,而又不检测,从而会使用错误的指针</p><h4 id="mmap应用练习"><a class="markdownIt-Anchor" href="#mmap应用练习"></a> mmap应用练习</h4><p>练习1：使用mmap完成对文件的读写操作</p><p>练习:2：使用mmap完成父子进程间通信</p><p>图解说明</p><p><img src="/images/javawz/wps1FD2.tmp.jpg" alt="img"></p><p>思路</p><p>调用mmap函数创建存储映射区，返回映射区首地址ptr</p><p>调用fork函数创建子进程，子进程也拥有了映射区首地址</p><p>父子进程可以通过映射区首地址指针ptr完成通信</p><p>调用munmap函数释放存储映射区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用mmap函数完成父子进程间通信</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line"><span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./test.log"</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//void * addr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);</span></span><br><span class="line"><span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(addr, <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%s]"</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习3：使用mmap完成没有血缘关系的进程间通</p><p>思路：两个进程都打开相同的文件，然后调用mmap函数建立存储映射区，这样两个进程共享同一个存储映射区。</p><h4 id="mmap_read"><a class="markdownIt-Anchor" href="#mmap_read"></a> mmap_read</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用mmap函数完成两个不相干进程间通信</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line"><span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./test.log"</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立共享映射区</span></span><br><span class="line"><span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">memcpy</span>(buf, addr, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf=[%s]\n"</span>, buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mmap_write"><a class="markdownIt-Anchor" href="#mmap_write"></a> mmap_write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用mmap函数完成两个不相干进程间通信</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line"><span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./test.log"</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立共享映射区</span></span><br><span class="line"><span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(addr, <span class="string">"0123456789"</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用mmap函数建立匿名映射"><a class="markdownIt-Anchor" href="#使用mmap函数建立匿名映射"></a> 使用mmap函数建立匿名映射：</h4><p>必须是有血缘关系之间的进程使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br></pre></td></tr></table></figure><p><code>MAP_ANONYMOUS</code>必须和<code>MAP_SHARED</code>一起使用，而且fd指定为-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用mmap匿名映射完成父子进程间通信</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line"><span class="comment">//void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line">    <span class="comment">//              int fd, off_t offset);</span></span><br><span class="line"><span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(addr, <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%s]"</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;存储映射区介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#存储映射区介绍&quot;&gt;&lt;/a&gt; 存储映射区介绍&lt;/h3&gt;
&lt;p&gt;​	存储映射&lt;code&gt;I/O (Memory-mapped I/O)&lt;/code&gt;使一个磁盘文件与存储空间中的一
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>fifo函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/17/linux070fifo%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/17/linux070fifo函数/</id>
    <published>2022-01-17T10:59:33.000Z</published>
    <updated>2022-01-17T17:01:09.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fifo介绍"><a class="markdownIt-Anchor" href="#fifo介绍"></a> FIFO介绍</h3><p><strong>FIFO常被称为命名管道</strong>，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间通信。<strong>但通过FIFO，不相关的进程也能交换数据。</strong></p><p>​FIFO是Linux基础文件类型中的一种（文件类型为p，可通过ls -l查看文件类型）。但FIFO文件在磁盘上没有数据块，文件大小为0，仅仅用来标识内核中一条通道。进程可以打开这个文件进行read/write，实际上是在读写内核缓冲区，这样就实现了进程间通信。</p><h3 id="创建管道"><a class="markdownIt-Anchor" href="#创建管道"></a> 创建管道</h3><h4 id="方式1-使用命令-mkfifo"><a class="markdownIt-Anchor" href="#方式1-使用命令-mkfifo"></a> 方式1-使用命令 mkfifo</h4><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo 管道名</span><br></pre></td></tr></table></figure><p>例如：mkfifo myfifo</p><h4 id="方式2-使用函数"><a class="markdownIt-Anchor" href="#方式2-使用函数"></a> 方式2-使用函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">参数一是文件名</span><br><span class="line">参数2是文件权限</span><br><span class="line">成功返回0</span><br><span class="line">失败返回-1并设置errno</span><br></pre></td></tr></table></figure><p>参数说明和返回值可以查看man 3 mkfifo</p><p>当创建了一个FIFO，就可以使用open函数打开它，常见的文件I/O函数都可用于FIFO。如：close、read、write、unlink等。</p><p>FIFO严格遵循先进先出（first in first out），对FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。<strong>它们不支持诸如lseek()等文件定位操作。</strong></p><h3 id="access函数"><a class="markdownIt-Anchor" href="#access函数"></a> access函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br></pre></td></tr></table></figure><p>函数声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int access(const char* pathname, int mode);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F_OK 值为0，判断文件是否存在</span><br><span class="line"> </span><br><span class="line">X_OK 值为1，判断对文件是可执行权限</span><br><span class="line"> </span><br><span class="line">W_OK 值为2，判断对文件是否有写权限</span><br><span class="line"> </span><br><span class="line">R_OK 值为4，判断对文件是否有读权限</span><br><span class="line"> </span><br><span class="line">注：后三种可以使用或“|”的方式，一起使用，如W_OK|R_OK</span><br></pre></td></tr></table></figure><p>返回值：成功0，失败-1</p><h3 id="使用fifo完成两个进程通信"><a class="markdownIt-Anchor" href="#使用fifo完成两个进程通信"></a> 使用FIFO完成两个进程通信</h3><p>使用FIFO完成两个进程通信的示意图</p><p><img src="/images/javawz/wps1DAE.tmp.jpg" alt="img"></p><h3 id="fifo_writec"><a class="markdownIt-Anchor" href="#fifo_writec"></a> fifo_write.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = access(<span class="string">"./myfifo"</span>,F_OK);<span class="comment">//判断文件是否存在</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//创建管道文件</span></span><br><span class="line">ret = mkfifo(<span class="string">"myfifo"</span>,<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"mkfifo error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开管道文件</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./myfifo"</span>,O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建缓冲区并且初始化为0</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">"%d hello\n"</span>,++i);</span><br><span class="line">        <span class="comment">//写数据到管道文件</span></span><br><span class="line">write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fifo_readc"><a class="markdownIt-Anchor" href="#fifo_readc"></a> fifo_read.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//打开管道文件</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./myfifo"</span>,O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//读管道文件</span></span><br><span class="line">len = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"len[%d]  %s"</span>,len,buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;fifo介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fifo介绍&quot;&gt;&lt;/a&gt; FIFO介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;FIFO常被称为命名管道&lt;/strong&gt;，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>如何查看管道缓冲区大小</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/17/linux069%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/17/linux069如何查看管道缓冲区大小/</id>
    <published>2022-01-17T10:58:01.000Z</published>
    <updated>2022-01-17T11:03:34.143Z</updated>
    
    <content type="html"><![CDATA[<h3 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long fpathconf(int fd, int name);</span><br><span class="line"></span><br><span class="line">printf(&quot;pipe size==[%ld]\n&quot;, fpathconf(fd[0], _PC_PIPE_BUF));</span><br><span class="line"></span><br><span class="line">printf(&quot;pipe size==[%ld]\n&quot;, fpathconf(fd[1], _PC_PIPE_BUF));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"pipe error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//获取管道缓冲区大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe size [%ld]\n"</span>,fpathconf(fd[<span class="number">0</span>],_PC_PIPE_BUF));</span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">write(fd[<span class="number">1</span>],<span class="string">"hello pipe!"</span>,<span class="keyword">sizeof</span>(<span class="string">"hello pipe!"</span>));</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">read(fd[<span class="number">0</span>],buf,<span class="number">1024</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;命令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#命令&quot;&gt;&lt;/a&gt; 命令&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>设置管道为非阻塞方式</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/17/linux068%E8%AE%BE%E7%BD%AE%E7%AE%A1%E9%81%93%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/17/linux068设置管道为非阻塞方式/</id>
    <published>2022-01-16T18:27:23.000Z</published>
    <updated>2022-01-16T18:29:52.837Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，管道的读写两端都是阻塞的，若要设置读或者写端为非阻塞，则可参</p><p>考下列三个步骤进行：</p><p>第1步：<code>int flags = fcntl(fd[0], F_GETFL, 0);</code></p><p>第2步： <code>flag |= O_NONBLOCK;</code></p><p>第3步： <code>fcntl(fd[0], F_SETFL, flags);</code></p><h3 id="若是读端设置为非阻塞"><a class="markdownIt-Anchor" href="#若是读端设置为非阻塞"></a> 若是读端设置为非阻塞：</h3><ul><li>写端没有关闭，管道中没有数据可读，则read返回-1；</li><li>写端没有关闭，管道中有数据可读，则read返回实际读到的字节数</li><li>写端已经关闭，管道中有数据可读，则read返回实际读到的字节数</li><li>写端已经关闭，管道中没有数据可读，则read返回0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建管道</span></span><br><span class="line"><span class="comment">//int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"pipe error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe size==[%ld]\n"</span>, fpathconf(fd[<span class="number">0</span>], _PC_PIPE_BUF));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe size==[%ld]\n"</span>, fpathconf(fd[<span class="number">1</span>], _PC_PIPE_BUF));</span><br><span class="line"></span><br><span class="line"><span class="comment">//close(fd[0]);</span></span><br><span class="line"><span class="comment">//write(fd[1], "hello world", strlen("hello world"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭写端</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置管道的读端为非阻塞</span></span><br><span class="line"><span class="keyword">int</span> flag = fcntl(fd[<span class="number">0</span>], F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">int</span> n = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read over, n==[%d], buf==[%s]\n"</span>, n, buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;默认情况下，管道的读写两端都是阻塞的，若要设置读或者写端为非阻塞，则可参&lt;/p&gt;
&lt;p&gt;考下列三个步骤进行：&lt;/p&gt;
&lt;p&gt;第1步：&lt;code&gt;int flags = fcntl(fd[0], F_GETFL, 0);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第2步： &lt;code&gt;fl
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>管道的读写行为</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/17/linux067%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E8%A1%8C%E4%B8%BA/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/17/linux067管道的读写行为/</id>
    <published>2022-01-16T17:54:45.000Z</published>
    <updated>2022-01-16T18:26:56.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="读操作"><a class="markdownIt-Anchor" href="#读操作"></a> 读操作</h3><h4 id="有数据"><a class="markdownIt-Anchor" href="#有数据"></a> 有数据</h4><p>read正常读，返回读出的字节数</p><h4 id="无数据"><a class="markdownIt-Anchor" href="#无数据"></a> 无数据</h4><p>1.写端全部关闭</p><p>read解除阻塞，返回0, 相当于读文件读到了尾部</p><p>2.没有全部关闭</p><p>read阻塞</p><h3 id="写操作"><a class="markdownIt-Anchor" href="#写操作"></a> 写操作</h3><h4 id="读端全部关闭"><a class="markdownIt-Anchor" href="#读端全部关闭"></a> 读端全部关闭</h4><p>管道破裂，进程终止, 内核给当前进程发SIGPIPE信号</p><h4 id="读端没全部关闭"><a class="markdownIt-Anchor" href="#读端没全部关闭"></a> 读端没全部关闭</h4><p>1.缓冲区写满了</p><p>write阻塞</p><p>2.缓冲区没有满</p><p>继续write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建管道</span></span><br><span class="line"><span class="comment">//int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"pipe error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe size==[%ld]\n"</span>, fpathconf(fd[<span class="number">0</span>], _PC_PIPE_BUF));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe size==[%ld]\n"</span>, fpathconf(fd[<span class="number">1</span>], _PC_PIPE_BUF));</span><br><span class="line"></span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(fd[<span class="number">1</span>], <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭写端</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">int</span> n = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read over, n==[%d], buf==[%s]\n"</span>, n, buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;读操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#读操作&quot;&gt;&lt;/a&gt; 读操作&lt;/h3&gt;
&lt;h4 id=&quot;有数据&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#有数据&quot;&gt;&lt;/a&gt; 有数据&lt;/h4&gt;
&lt;p&gt;r
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>父子进程执行ps_aux_grep_bash思路分析和实现</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/17/linux066%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8Cps-aux-grep-bash%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/17/linux066父子进程执行ps-aux-grep-bash思路分析和实现/</id>
    <published>2022-01-16T16:35:18.000Z</published>
    <updated>2022-01-16T17:52:12.339Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../themes/pure/source/images/javawz/image-20220117003549233.png" alt="image-20220117003549233"></p><p>输入<code>grep bash</code> 回车之后默认情况下是等待终端输入数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用pipe完成ps aux | grep bash操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建管道</span></span><br><span class="line"><span class="comment">//int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"pipe error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//关闭读端</span></span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将标准输出重定向到管道的写端</span></span><br><span class="line">dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line"></span><br><span class="line">execlp(<span class="string">"ps"</span>, <span class="string">"ps"</span>, <span class="string">"aux"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">perror(<span class="string">"execlp error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//关闭写端</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将标准输入重定向到管道的读端</span></span><br><span class="line">dup2(fd[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line"></span><br><span class="line">execlp(<span class="string">"grep"</span>, <span class="string">"grep"</span>, <span class="string">"--color=auto"</span>, <span class="string">"bash"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">perror(<span class="string">"execlp error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../../themes/pure/source/images/javawz/image-20220117003549233.png&quot; alt=&quot;image-20220117003549233&quot;&gt;&lt;/p&gt;
&lt;p&gt;输入&lt;code&gt;grep bash&lt;/co
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>pipe函数</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/15/linux065pipe%E5%87%BD%E6%95%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/15/linux065pipe函数/</id>
    <published>2022-01-15T05:49:44.000Z</published>
    <updated>2022-01-15T09:47:53.212Z</updated>
    
    <content type="html"><![CDATA[<h3 id="管道的概念"><a class="markdownIt-Anchor" href="#管道的概念"></a> 管道的概念</h3><p>管道是一种最基本的IPC机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用pipe函数即可创建一个管道。</p><p><img src="/images/javawz/wps6AFD.tmp.jpg" alt="img"></p><p>有如下特质：</p><p>管道的本质是一块内核缓冲区</p><p>由两个文件描述符引用，一个表示读端，一个表示写端。</p><p>规定数据从管道的写端流入管道，从读端流出。</p><p>当两个进程都终结的时候，管道也自动消失。</p><p>管道的读端和写端默认都是阻塞的。</p><h3 id="管道的原理"><a class="markdownIt-Anchor" href="#管道的原理"></a> 管道的原理</h3><p>管道的实质是内核缓冲区，内部使用环形队列实现。</p><p>默认缓冲区大小为4K，可以使用ulimit -a命令获取大小。</p><p>实际操作过程中缓冲区会根据数据压力做适当调整。</p><h3 id="管道的局限性"><a class="markdownIt-Anchor" href="#管道的局限性"></a> 管道的局限性</h3><p>数据一旦被读走，便不在管道中存在，不可反复读取。</p><p>数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道</p><p>只能在有血缘关系的进程间使用管道。</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结:</h4><p>1.管道的本质是一块内核缓冲区,内部的实现是环形队列</p><p>2.管道有读写两端,读写两端是两个文件描述符</p><p>3.数据的流向是从管道的写端流到管道的读端(数据的流向是单向的)</p><p>4.数据被读走之后,在管道中就消失</p><p>5.pipe只能用于有血缘关系的进程间通信</p><p>6.管道的读写两端是阻塞的(写满数据阻塞，没读到数据阻塞)</p><p>7.管道的大小默认是4K,但是会根据实际情况做适当调整</p><h3 id="创建管道pipe函数"><a class="markdownIt-Anchor" href="#创建管道pipe函数"></a> 创建管道pipe函数</h3><p>函数作用:</p><p>创建一个管道</p><p>头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure><p>函数原型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int fd[2]);</span><br></pre></td></tr></table></figure><p>函数参数:</p><p>若函数调用成功，fd[0]存放管道的读端，fd[1]存放管道的写端</p><p>返回值:</p><p>成功返回0；</p><p>失败返回-1，并设置errno值。</p><p>​函数调用成功返回读端和写端的文件描述符，其中<strong>fd[0]是读端， fd[1]是写端</strong>，<strong>向管道读写数据是通过使用这两个文件描述符进行的，读写管道的实质是操作内核缓冲区。</strong></p><p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？</p><h3 id="父子进程使用管道通信"><a class="markdownIt-Anchor" href="#父子进程使用管道通信"></a> 父子进程使用管道通信</h3><p>一个进程在由pipe()创建管道后，一般再fork一个子进程，然后通过管道实现父子进程间的通信（因此也不难推出，只要两个进程中存在血缘关系，这里的血缘关系指的是具有共同的祖先，都可以采用管道方式来进行通信）。<strong>父子进程间具有相同的文件描述符，且指向同一个管道pipe</strong>，其他没有关系的进程不能获得pipe（）产生的两个文件描述符，也就不能利用同一个管道进行通信。</p><p><strong>第一步：父进程创建管道</strong></p><p><img src="/images/javawz/wps6AFE.tmp.jpg" alt="img"></p><p><strong>第二步：父进程fork出子进程</strong></p><p><img src="/images/javawz/wps6AFF.tmp.jpg" alt="img"></p><p><strong>第三步：父进程关闭fd[0]，子进程关闭fd[1]</strong></p><p><img src="/images/javawz/wps6B00.tmp.jpg" alt="img"></p><h4 id="创建步骤总结"><a class="markdownIt-Anchor" href="#创建步骤总结"></a> 创建步骤总结：</h4><p>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]和fd[1]，分别指向管道的读端和写端。</p><p>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管。</p><p>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出，这样就实现了父子进程间通信。</p><p>pipe用于父子进程间通信:</p><p>1.父进程创建pipe</p><p>2.父进程调用fork函数创建子进程</p><p>3.父进程关闭一端</p><p>4.子进程关闭一端</p><p>5.父进程和子进程分别执行read或者write操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建管道</span></span><br><span class="line"><span class="comment">//int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret = pipe(fd); </span><br><span class="line">    <span class="comment">/*子进程会复制一份fd,然后内核计数读和写fd各变成2*/</span></span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"pipe error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//关闭读端</span></span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">write(fd[<span class="number">1</span>], <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line"></span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//关闭写端</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">int</span> n = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read over, n==[%d], buf==[%s]\n"</span>, n, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;管道的概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#管道的概念&quot;&gt;&lt;/a&gt; 管道的概念&lt;/h3&gt;
&lt;p&gt;管道是一种最基本的IPC机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用pipe函数即可创建一个管道。&lt;/p
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>进程间通信的基本概念</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/15/linux064%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/15/linux064进程间通信的基本概念/</id>
    <published>2022-01-15T05:43:20.000Z</published>
    <updated>2022-01-15T08:57:08.028Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是进程间通信"><a class="markdownIt-Anchor" href="#什么是进程间通信"></a> 什么是进程间通信</h3><p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。</p><p><img src="/images/javawz/wps9CE.tmp.jpg" alt="img"></p><h3 id="进程间通信的方式"><a class="markdownIt-Anchor" href="#进程间通信的方式"></a> 进程间通信的方式</h3><p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。<strong>现今常用的进程间通信方式有：</strong></p><p><strong>管道 (使用最简单)</strong></p><p><strong>信号 (开销最小)</strong></p><p><strong>共享映射区 (无血缘关系)</strong></p><p><strong>本地套接字 (最稳定)</strong></p><p>父子进程可以共享文件</p><p>两个进程要想完成数据交换,必须通过内核；</p><p>一个进程将数据写到内核，然后另一个进程从内核中读走数据</p><p>IPC：进程间通信（interprocess communication）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是进程间通信&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是进程间通信&quot;&gt;&lt;/a&gt; 什么是进程间通信&lt;/h3&gt;
&lt;p&gt;Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程
      
    
    </summary>
    
      <category term="linux" scheme="https://xiaowuyoucy.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>第一章计算机网络概述</title>
    <link href="https://xiaowuyoucy.github.io/2022/01/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>https://xiaowuyoucy.github.io/2022/01/14/计算机网络概述/</id>
    <published>2022-01-13T16:56:27.000Z</published>
    <updated>2022-01-16T14:22:09.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="局域网"><a class="markdownIt-Anchor" href="#局域网"></a> 局域网</h3><p><img src="/images/javawz/image-20220114011444766.png" alt="image-20220114011444766"></p><p>每一间课室的电脑都连接到同一台交换机上,楼道上会形成很多网线,不雅观</p><p><img src="/images/javawz/image-20220114012723065.png" alt="image-20220114012723065"></p><p>电脑到交换机距离的网线不超过100米，交换机到交换机的网线也不超过一百米</p><p><img src="/images/javawz/image-20220114013131827.png" alt="image-20220114013131827"></p><p>接入层交换机的接口比较多，汇聚层的接口比较少，但要求输入和输出的带宽高</p><p><img src="/images/javawz/image-20220114013417969.png" alt="image-20220114013417969"></p><p>中间的网线承担了两个课室的流量，不规范</p><p>总结：局域网覆盖范围小，自己花钱买设备带宽固定，自己维护</p><h3 id="intenet和广域网"><a class="markdownIt-Anchor" href="#intenet和广域网"></a> Intenet和广域网</h3><p><img src="/images/javawz/image-20220114014449047.png" alt="image-20220114014449047"></p><p>Intenet有很多 IPS运营商组成，他们都有自己的机房，对网民提供访问Internet连接（可以是ADSL或光纤）</p><p>广域网：距离远（可以超过100米） 花钱租带宽</p><p>我们买的带宽是指从我们这里到运营商那一段的带宽，比如我们拉了100兆的网线，意思就是从我们这里到运营商接口那里是100兆的</p><p>公网地址是全球唯一的，不会重复</p><h3 id="规划ip地址介绍mac地址"><a class="markdownIt-Anchor" href="#规划ip地址介绍mac地址"></a> 规划IP地址介绍MAC地址</h3><p><img src="/images/javawz/image-20220114020833334.png" alt="image-20220114020833334"></p><p>一般路由器地址是自己网段的第一个地址</p><p>例如自己网段是13.0.0.0 路由器地址就是13.0.0.1</p><p>MAC地址：网卡生产时的物理地址，48位二进制表示，也是全球唯一，不重复的</p><p>网关: 数据到其他网段需要给的机器(一般是路由器)</p><p>DNS：解析域名的服务器，比如我们打开<code>www.baidu.com</code>，电脑会先请求DNS服务器，然后DNS服务器会返回一个域名对应的ip地址回来</p><h3 id="数据包和数据帧"><a class="markdownIt-Anchor" href="#数据包和数据帧"></a> 数据包和数据帧</h3><p><img src="/images/javawz/image-20220114022359765.png" alt="image-20220114022359765"></p><p><img src="/images/javawz/image-20220114022439593.png" alt="image-20220114022439593"></p><p>IP地址决定最后给谁</p><p>MAC地址决定下一跳给谁</p><p>数据包最大1500字节,如果数据超过1500个字节会切片,然后给每个数据包编号</p><h3 id="访问网站数据传输过程"><a class="markdownIt-Anchor" href="#访问网站数据传输过程"></a> 访问网站数据传输过程</h3><p><img src="/images/javawz/image-20220114023846946.png" alt="image-20220114023846946"></p><p>网站服务器收到请求之后会将网页打包成很多数据包，每个数据包都有编号，然后再一个个放到网卡缓存里，每个数据包都有源ip地址，目标ip地址，源mac地址和目标mac地址。</p><p>数据包发送到客户机网卡的缓存之后，客户机会发送接收下一个数据包的请求，然后服务器收到之后会将上一个发送的数据包删除掉，再发下一个数据包。</p><p>客户机会一边接收数据包，一边将数据包排好序一个个的显示出来，最终形成一个网页</p><h3 id="osi参考模型"><a class="markdownIt-Anchor" href="#osi参考模型"></a> OSI参考模型</h3><p>应用层:所有能产生网络流量的程序</p><p>表示层:在传输之前是否进行加密或压缩处理,是二进制数据还是ASCII数据</p><p>会话层: 查木马<code>netstat -n</code>,一般连接网络的软件都会建立会话</p><p>传输层:可靠传输 、流量控制、不可控传输</p><p>网络层：负责选择最佳路径 规划IP地址</p><p>数据链路层：帧的开始和结束、透明传输、差错校验</p><p>物理层：接口标准、电器标准、如何在物理链路上传输更快的速度</p><h3 id="理解osi参考模型分层思想"><a class="markdownIt-Anchor" href="#理解osi参考模型分层思想"></a> 理解OSI参考模型分层思想</h3><p>网络七层模型之间有相对独立性，每一层的变化一般不会对其他层有影响。一个计算机可以加多ip地址</p><h3 id="osi参考模型和网络排错"><a class="markdownIt-Anchor" href="#osi参考模型和网络排错"></a> OSI参考模型和网络排错</h3><p>网络出现问题,应该从物理层开始往上排查</p><p>物理层故障：网线断了是物理层故障,发送有包，接收没包，需要检查一下网线水晶头（接触不良）</p><p>数据链路层故障：MAC地址冲突、ADSL欠费、接口网速协商不一致（强制性）、计算机连接到错的VLAN</p><p>网络层故障：没有配网关、配置错误的IP地址，子网掩码，路由器没有配置到达目标网络的路由</p><p>应用层故障：应用程序配置错误（代理配置错误等）</p><h3 id="osi参考模型和网络安全"><a class="markdownIt-Anchor" href="#osi参考模型和网络安全"></a> OSI参考模型和网络安全</h3><p>网络安全-OSI模型各层的安全<br>1.物理层：把用不到的口关掉。<br>2.数据链路层：ADSL拨号的账号密码；无线网络要输数据密码；划分VLAN，在交换机上创建虚拟局域网；交换机端口绑定MAC地址。<br>3.网络层：在路由器上使用ACL控制数据包流量（路由器可以控制哪个网段可以访问哪个网络）。Windows防火墙设置；<br>4.应用层：开发的应用程序没有漏洞，SQL注入漏洞等。</p><h3 id="osi参考模型和tcpip协议"><a class="markdownIt-Anchor" href="#osi参考模型和tcpip协议"></a> OSI参考模型和TCP/IP协议</h3><p><img src="/images/javawz/image-20220116133849928.png" alt="image-20220116133849928"></p><p>TCP/IP协议栈一共五层:应用层、传输层、网络层、数据链路层、物理层。<br>ARP协议为IP协议提供服务，IP协议为ICMP和IGMP协议提供服务。<br>应用层：准备要发送的数据<br>传输层：将数据分段编号<br>网络层：为要发送的数据加上IP地址或去掉接收到的数据中的IP地址。<br>数据链路层：添加或去掉MAC地址和校验值</p><p>FCS：差错校验</p><p><img src="/images/javawz/image-20220116135844590.png" alt="image-20220116135844590"></p><p><img src="/images/javawz/image-20220116135938908.png" alt="image-20220116135938908"></p><p><img src="/images/javawz/image-20220116140018729.png" alt="image-20220116140018729"></p><p><img src="/images/javawz/image-20220116140044730.png" alt="image-20220116140044730"></p><h3 id="计算机网络性能指标"><a class="markdownIt-Anchor" href="#计算机网络性能指标"></a> 计算机网络性能指标</h3><p>1.速率（比特率）：连接在计算机网络上的主机在数字信道上传达数据位数的速率。b/s，kb/s,Mb/s,Gb/s。（一般看到的是byte/s，需要bit/s除以8）<br>网络100M指的是100Mbit<br>速率是指一个发送端一个接收端每秒中传输的bit<br>2.带宽：网络设备支持的最高速度，单位是b/s  Kb/s Mb/s  Gb/s<br>3.吞吐量：单位时间内通过某个网络的数据量。b/s,Mb/s…。<br>一般指的是各个信道速率之和</p><p>4.时延：发送时延=数据块长度（bit）/信道带宽(bit/s)；传播时延；处理时延；接收时延。光纤的支持更高的发送速度，但传播速度没有比铜线快，光纤每秒传输20.5万公里，铜线每秒传输23.1万公里。<br>从网络的一端传输到另一端所需要的时间<br>给网络设备增加带宽可以减少发送时延，但不可以无限增加，发送时延越小，数据长度越窄</p><p>5.时延带宽积=传播时延*带宽。（传输线路上的数据量）</p><p><img src="/images/javawz/image-20220116222042898.png" alt="image-20220116222042898"></p><br><p>6.往返时间（round-trip time）：从发送方发送数据开始，到发送方收到接收方确认。ping 命令可以查看。</p><p><img src="/images/javawz/image-20220116221159756.png" alt="image-20220116221159756"></p><br><p>7.网络利用率：1）信道利用率=有数据通过时间/（有+无）数据通过时间。2）网络利用率：信道利用率加权平均值。3）网络当前时延=网络空闲时的时延/（1-信道利用率）。</p><p><img src="/images/javawz/image-20220116222012493.png" alt="image-20220116222012493"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;局域网&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#局域网&quot;&gt;&lt;/a&gt; 局域网&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/images/javawz/image-20220114011444766.png&quot; alt=&quot;image-2022
      
    
    </summary>
    
      <category term="计算机网络原理" scheme="https://xiaowuyoucy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
</feed>
