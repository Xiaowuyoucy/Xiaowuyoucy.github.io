---
title: 单目和双目运算符重载
date: 2021-05-11 19:26:00
tags:
categories: cpp
doc:
---

# 单目和双目运算符重载

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>


using namespace std;

class A
{
public:
	A();
	A(int ta, int tb);
	//A  operator+(const A & another);
	//A & operator+=(const A & another);
	friend A operator+(A & a1, A & a2);
	friend A& operator+=(A & a1, A & a2);
	void print();
	~A();

private:
	int a;
	int b;
};

void A::print() {
	cout << a << endl;
	cout << b << endl;
	cout << "=========================" << endl;
}

//
////重载双目操作符
//A & A::operator+=(const A & another)
//{
//	a += another.a;
//	b += another.b;
//	return *this;
//}
//A  A::operator+(const A & another)
//{
//	return A(a + another.a,b + another.b);
//}
A::A(int ta, int tb)
{
	a = ta;
	b = tb;
}

A::A()
{
	a = 0;
	b = 0;
}

A::~A()
{
}

//全局重载运算符函数
A operator+(A & a1,A & a2) {
	return A(a1.a + a2.a ,a1.b + a2.b);
}
A & operator+=(A & a1, A & a2) {

	a1.a += a2.a;
	a1.b += a2.b;

	return a1;
}

int main(char *argv[], int argc)
{
	A a1(1, 1), a2(2, 2);

	A a3 = a1 + a2;

	a3.print();

	a3 += a1;
	a3.print();
	return 0;
}

```

### 前++和后++重载

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>


using namespace std;

class A
{
public:
	A();
	A(int ta, int tb);
	//A  operator+(const A & another);
	//A & operator+=(const A & another);

	//前++
	A & operator++();
	//后++
	const A operator++(int);

	friend A operator+(A & a1, A & a2);
	friend A& operator+=(A & a1, A & a2);

	////前++
	//friend A& operator++(A &a1);
	////后++
	//friend const A operator++(A &a1, int);

	void print()const;
	~A();

private:
	int a;
	int b;
};

//全局友元重载++函数
//后++
//const A operator++(A & a1, int)
//{
//	A temp(a1.a, a1.b);
//	a1.a++;
//	a1.b++;
//	return a1;
//}
////前++
//A & operator++(A & a1)
//{
//	++a1.a;
//	++a1.b;
//	return a1;
//}




//成员重载++运算符函数
//前++
A & A::operator++()
{
	++a;
	++b;
	return *this;
}

//后++
const A A::operator++(int)
{
	A temp(a, b);
	a++;
	b++;
	return temp;
}

void A::print()const {
	cout << a << endl;
	cout << b << endl;
	cout << "=========================" << endl;
}

//
////重载双目操作符
//A & A::operator+=(const A & another)
//{
//	a += another.a;
//	b += another.b;
//	return *this;
//}
//A  A::operator+(const A & another)
//{
//	return A(a + another.a,b + another.b);
//}
A::A(int ta, int tb)
{
	a = ta;
	b = tb;
}

A::A()
{
	a = 0;
	b = 0;
}

A::~A()
{
}

//全局重载运算符函数
A operator+(A & a1,A & a2) {
	return A(a1.a + a2.a ,a1.b + a2.b);
}
A & operator+=(A & a1, A & a2) {

	a1.a += a2.a;
	a1.b += a2.b;

	return a1;
}


void test1() {
	A a1(1, 1), a2(2, 2);

	A a3 = a1 + a2;

	a3.print();

	a3 += a1;
	a3.print();
}

void test2() {
	A a1(1, 1), a2(2, 2);

	++++a1;
	a1.print();

	(a1++).print();

	a1.print();
}

int main(char *argv[], int argc)
{
	//test1();
	test2();
	return 0;
}

```

### 友元重载前++和后++函数的区别

```cpp
//前++
friend A& operator++(A &a1);
//后++
friend const A operator++(A &a1, int);




//后++
const A operator++(A & a1, int)
{
	A temp(a1.a, a1.b);
	a1.a++;
	a1.b++;
	return a1;
}
//前++
A & operator++(A & a1)
{
	++a1.a;
	++a1.b;
	return a1;
}

```



### 类成员函数重载前++和后++函数的区别

```cpp
前++
A & operator++();
后++
const A operator++(int);



//成员重载++运算符函数
//前++
A & A::operator++()
{
	++a;
	++b;
	return *this;
}

//后++
const A A::operator++(int)
{
	A temp(a, b);
	a++;
	b++;
	return temp;
}
```

### 后++是不能连用的,所以返回的是一个常对象