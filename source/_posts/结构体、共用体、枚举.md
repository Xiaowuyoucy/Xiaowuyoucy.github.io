---
title: 结构体、共用体、枚举
date: 2021-09-28 00:52:48
tags:
categories: C
doc:
---

### 结构体

不同类型数据的集合
定义

```
struct 结构名
{结构成员表};
```

```
struct student
{
int no;
char name[10];
int age;
double socre;
char addr[50];
struct date birth;
};

struct date
{
int year;
int month;
int day;
};

struct student st1;
```

初始化，可直接清空

### memset

函数原型:

```
void *memset(void *s, int ch, size_t n);
```



```
memset(&st, 0, sizeof(st)); //用0填充st内存
```

### memcpy

函数原型:

```
void *memcpy(void *destin, void *source, unsigned n);
```

```
memcpy(st.name, "agp", strlen("agp")); //将“agp”复制到st.name内存中
```



### typedef

使用typedef创建结构体、共用体、枚举类型别名

```
typedef struct date
{
	int year;
	int month;
	int day;
}MDATE;


typedef union data
{
	char c[10];
	int a;
	double f;
} MDATA;
MDATA x;

typedef enum week {
	sun, 
	mon, 
	tue,
	wed,
	thu, 
	fri,
	sta
}WEEK; 
```



##### 结构体指针变量访问成员

访问方法，指针用-> .



##### 大小 内存对齐 X86 默认4字节对齐

```
#pragma pack(1)  修改内存对齐为1
一般是 网络通信 双机通信~~ 使用
```

sizeof(结构名或者变量名)
对齐原因：有些平台每次读都是从偶地址开始，如果一个int型（假设为 32位）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要2个读周期，并对两次读出的结果的高低 字节进行拼凑才能得到该int数据。显然在读取效率上下降很多。这也是空间和时间的博弈。
http://baike.baidu.com/view/925608.htm
原则：地址可以被整除

结构数组
地址1 结构1
地址2 结构2
...

### 共用体union

共用一块内存，某个时刻只有一个有效

```
union data
{
char c[10];
int a;
double f;
};
union data x;
```



### 枚举enum 提高程序可读性

有名字的整形常量的集合，该类型变量只能取其中的一个值

```
enum week {sun, mon, tue, wed,thu, fri, sta}; 不赋值 默认从0开始
enum week w = sun; //sun == 0
```

