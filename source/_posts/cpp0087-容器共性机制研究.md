---
title: 容器共性机制研究
date: 2021-07-05 14:41:46
tags:
categories: c++
doc:
---

#### 容器的共通能力   

C++模板是容器的概念。

![1625467342426](/images/javawz/1625467342426.png)

<b>理论提高：</b>所有容器提供的都是值（value）语意，而非引用（reference）语意。**容器执行插入元素的操作时，内部实施拷贝动作。**所以STL容器内存储的元素必须**能够被拷贝**（必须提供拷贝构造函数）。

 除了queue与stack外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。

 通常STL不会丢出异常。要求使用者确保传入正确的参数。

 每个容器都提供了一个默认构造函数跟一个默认拷贝构造函数。

 如已有容器vecIntA。 

 vector\<int> vecIntB(vecIntA); //调用拷贝构造函数，复制vecIntA到vecIntB中。

 与大小相关的操作方法(c代表容器)：

c.size();  //返回容器中元素的个数

c.empty();  //判断容器是否为空

 比较操作(c1,c2代表容器)：

c1 == c2   判断c1是否等于c2

c1 != c2   判断c1是否不等于c2

c1 = c2    把c2的所有元素指派给c1

#### 各个容器的使用时机

![1625467543529](/images/javawz/1625467543529.png)

 <b> deque的使用场景：</b>比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。

#####  vector与deque的比较：

 一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置却是不固定的。

 二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。

 三：deque支持头部的快速插入与快速移除，这是deque的优点。

<b> list的使用场景：</b>比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。

 <b>set的使用场景：</b>比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 

<b> map的使用场景：</b>比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。