---
title: 类型转换
date: 2021-06-20 05:52:15
tags:
categories: cpp
doc:
---

# 类型转换

C++提供了4种类型转换，分别处理不同的场合应用

### static_cast 静态类型转换。

可以转换基本数据类型和具有继承关系的对象指针或引用

`static_cast<目标类型> (标识符)`

![1624139983807](/images/javawz/1624139983807.png)

### reinterpret_cast重新解释类型转换。



仅仅重新解释类型，但没有进行二进制的转换：

　　1. 转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。

　　2. 在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。但不能将非32bit的实例转成指针。

　　3. 最普通的用途就是在函数指针类型之间进行转换。

　　4. 很难保证移植性。

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>


using namespace std;

typedef void(*VFun)(int, int);
typedef double(*DFun)(int, int);
int main(char *argv[], int argc)
{
	VFun vf = NULL;
	DFun df = reinterpret_cast<DFun>(vf);


	return 0;
}

```



### dynamic_cast 子类和父类之间的多态类型转换。

`dynamic_cast<目标类型> (标识符)`

只能转换具有继承关系的指针或引用,会做类型安全检查

只能从子类转父类,因为一般子类内存空间是大于等于父类的,如果子类内存空间大于父类，把父类指针转换成子类指针,会越界处理，所以不安全。

如果转换失败返回NULL

![1624140927217](/images/javawz/1624140927217.png)

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>


using namespace std;


class Base {
private:
	char * mName;
};

class Son : public Base {
private:
	int age;
};


class Animal {
	char * mName;
};



int main(char *argv[], int argc)
{
	Base * pBase = NULL;

	Son * pSon = NULL;

	Animal * pAnimal = NULL;


	//pSon = dynamic_cast<Son *>(pBase); 父类指针不能装子类指针
	//pSon = dynamic_cast<Son *>(pAnimal); 不具有继承关系的不能转换
	pBase = dynamic_cast<Son *>(pSon); //子类转父类可以
	


	return 0;
}

```



### const_cast 去掉const属性转换。

`const_cast<目标类型>(标识符) `

目标类类型只能是指针或引用。



```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>


using namespace std;


class Base {
private:
	char * mName;
};

class Son : public Base {
private:
	int age;
};


class Animal {
	char * mName;
};


void test() {
	//基本数据类型
	int a = 10;
	const int & b = a;
	int &c = const_cast<int &>(b);

	c = 20;

	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

}

void test02() {
	
	Base * a = NULL;
	const Base *b = a;
	Base * c = const_cast<Base *>(b);
	c = new(Base);

	cout << "===========================" << endl;
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;

	delete c;
	c = NULL;
}

int main(char *argv[], int argc)
{
	//基础数据类型
	test();

	//对象数据类型
	test02();

	return 0;
}

```

