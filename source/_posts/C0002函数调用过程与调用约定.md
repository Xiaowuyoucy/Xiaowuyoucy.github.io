---
title: 函数调用过程与调用约定
date: 2021-09-28 01:39:51
tags:
categories: c
doc:
---



### 函数调用约定

`__cdecl`    缺省调用方式，函数采用从右到左的压栈方式，调用方清理堆栈，注意可变参数<br />

`__stdcall`  函数的参数自右向左通过栈传递，被调用方清理堆栈<br />

`__fastcall` 通过寄存器来传送参数，被调用方清理堆栈<br />

`__thiscall`用于C++成员函数，使用ecx存放this指针<br />

naked call 裸函数，上面几种方式会产生保存一些寄存器的代码，这种不产生。naked call不是类型修饰符，必须和_declspec共同使用
`__declspec(naked)` 是告诉编译器 不要对函数进行优化  函数的所有实现包括堆栈的平衡  参数的压栈 ebp的赋值 还原 都要我们来做

<br />

#### 决定以下内容：

1)函数参数的压栈顺序
2)由调用者还是被调用者把参数弹出栈
3)以及产生函数修饰名的方法

#### 修饰名

1、修饰名(Decoration name)："C"或者"C++"函数在内部（编译和链接）通过修饰名识别
2、C编译时函数名修饰约定规则：<br />
`__stdcall`调用约定在输出函数名前加上一个下划线前缀，后面加上一个"@"符号和其参数的字节数，格式为_functionname@number,
例如 ：function(int a, int b)，其修饰名为：_function@8

<br />

`__cdecl`调用约定仅在输出函数名前加上一个下划线前缀，格式为_functionname。

<br />`__fastcall`调用约定在输出函数名前加上一个"@"符号，后面也是一个"@"符号和其参数的字节数，格式为@functionname@number。

<br />

注：

```
一般WIN32的函数都是__stdcall
 #define CALLBACK __stdcall
 #define WINAPI　 __stdcall
```

<hr />

### 例子

```c
#include <stdio.h>
#include <Windows.h>

// 默认是__cdecl
int cAdd(int a, int b, int c)
{
	return a + b + c;
}

//堆栈平衡由函数内部处理
int __stdcall stdAdd(int a, int b, int c)
{
	return a + b + c;
}

//前两个参数使用寄存器存储,堆栈平衡由函数内部处理
int __fastcall fastAdd(int a, int b, int c)
{
	return a + b + c;
}

//堆栈平衡由我们自己处理
int __declspec(naked) nkAdd(int a, int b, int c)
{
	__asm  
	{  
		push [esp + 0ch]  
		push [esp + 0ch]  
		push [esp + 0ch]      
		call stdAdd
		mov eax,eax
		ret
	}  
}

int main(void)
{	
	int result;
	// 内联汇编
	__asm
	{
		mov eax,eax
		mov eax,eax
		mov eax,eax
	}
	result = cAdd(1,2,3);
	printf("%d",result);
	stdAdd(1,2,3);
	printf("%d",result);
	fastAdd(1,2,3);
	printf("%d",result);
 	nkAdd(1,2,3);
	printf("%d",result);
	//CreateThread();
	system("pause");
	return 0;
}

```

