---
title: 类模板派生普通类与类模板派生类模板
date: 2021-06-18 23:47:47
tags:
categories: c++
doc:
---



### 类模板派生普通类

```
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>


using namespace std;

template<class T>
class A {
public:
	T mA;

	A(){}
	A(T a):mA(a){}
};

//模板类派生普通类
//结论：子类从模板类继承的时候，需要让编译器知道父类的数据类型具体是什么（数据类型的本
质：固定大小内存块的别名）A<int>
class B : public A<int> {

public:
	void show() {
		cout << mA << endl;
	}
	B(int a):A(a){}
};

void test01() {
	B b(100);
	b.show();
}

int main(char *argv[], int argc)
{
	test01();

	return 0;
}

```

### 类模板派生类模板

```cpp

#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<string>

using namespace std;

template<class T>
class A {
public:
	T mA;

	A(){}
	A(T a){
		mA = a;
	}
};

template<class T>
class B : public A<T>
{
public:
	B():A<T>(){}
	B(T a):A<T>(a){}
	void show() {

		//要显示的指明要调用哪个类实例的mA
		cout << A<T>::mA << endl;
	}

};

void test01() {
	B<string> b("wwww");

	cout << b.mA << endl;
}
int main(char *argv[], int argc)
{
	test01();

	return 0;
}

```

