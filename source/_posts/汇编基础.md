---
title: 汇编基础
date: 2023-12-14 17:58:53
tags:
categories: 逆向工程
doc:
---

### 位运算

#### 与运算

![image-20231226032344544](/images/javawz/image-20231226032344544.png)



#### 或运算

![image-20231226032439239](/images/javawz/image-20231226032439239.png)





#### 异或

![image-20231226032458930](/images/javawz/image-20231226032458930.png)



#### 非运算

![image-20231226032523375](/images/javawz/image-20231226032523375.png)



#### 左移

![image-20231226032848211](/images/javawz/image-20231226032848211.png)





#### 右移

各二进位全部右移若干位，低位丢弃，高位补0或者补符号位

shr是无符号的，高位用0补

sar是有符号的，高位用符号位补

在c语言中>>是包含了shr和sar的,怎么区分有符号和无符号要看类型,比如 unsigned int就是无符号的,右移会使用shr



![image-20231226033015280](/images/javawz/image-20231226033015280.png)





### 计算机做加法的过程

4 + 5 = ？

1、4和5，先异或  4xor5

2、4和5进行与运算，得出来的结果判断是否有进位，如果是0就是没有进位，如果是非0就是有进位。最后左移1位

（4 and 5 ）<< 1

3、将步骤1和步骤2的结果异或

4、将步骤1和步骤2的结果相与，判断还有没有进位，如果有则继续重复上述步骤

```
	4------ 0000 0100
	
	5------ 0000 0101
加---------------------------
			0000 1001
			
			
第一步 异或
 		0000 0100

		0000 0101
异或---------------------------
		0000 0001
		
		
第二步 与，判断是否有进位

 		0000 0100

		0000 0101
与---------------------------
		0000 0100

第三步，如果第二步与的结果非0表示有进位，需要左移1位

0000 0100 << 1 = 0000 1000

第四步 继续异或

 		0000 0001

		0000 1000
异或---------------------------
		0000 1001
		

第五步 将第一步和第三步的结果进行与运算判断是否还有进位

 		0000 0001

		0000 1000
与---------------------------
		0000 0000

发现是0 表示没有进位,运算结束

```



4-5=?

4-5 = 4 + (-5)



```
4 + (-5)

4         0000 0100

-5		  1111 1011


1) 异或

		0000 0100
		
		1111 1011
异或---------------------------
		1111 1111
		

2) 判断是否有进位

		0000 0100
		
		1111 1011
与---------------------------
		0000 0000
		
结果是0,没有进位。1111 1111 就是最终结果


```



X / Y 表示 X 可以减去多少次Y



### DTDebug



配置DTDebug

![image-20231226045552087](/images/javawz/image-20231226045552087.png)

![image-20231226045613640](/images/javawz/image-20231226045613640.png)



UDD path和Plugin path 写自己安装目录下的



### 通用寄存器



![image-20231226045728248](/images/javawz/image-20231226045728248.png)

```
MOV 目标操作数，源操作数

mov eax,12
mov eax,ecx

mov ax,12
mov ax,cx

mov ah,ch
mov ah,12

mov al,cl
mov al,2

mov指令 左右两边的操作数必须是等宽的
例如 
ax 和 cx是等宽的
al 和 cl是等宽的
ah 和 cl是等宽的
eax 和 ax不是等宽的,因为eax是32位的,ax是16位的

```



### 内存

![image-20231226050932498](/images/javawz/image-20231226050932498.png)



每个进程都有4G的虚拟内存,当某一块虚拟内存需要用到的时候,会将这块虚拟内存映射到物理内存中,最后物理内存会将这块内存映射到内存条中



```
BYTE　字节　＝　8(BIT)		
WORD  字    =   16(BIT)		
DWORD 双字  =   32(BIT)		
		
1KB = 1024 BYTE		
1MB = 1024 KB 		
1GB = 1024 MB		

```



mov指令使用内存

```
mov 类型 ptr ds:[内存编号],值

mov byte ptr ds:[00A90280],22
mov word ptr ds:[00A90280],22
mov dword ptr ds:[00A90280],22


```



从指定内存中写入/读取数据	

```
		mov dword ptr ds:[0x0012FF34],0x12345678				
						
		mov eax,dword ptr ds:[0x0012FF34]				
						
		dword ：要读/写多少  此时是4字节   byte == 1字节  word == 2字节				
						
		ptr: Point 代表后面是一个指针 (指针的意思就是里面存的不是普通的值，而是个地址)				
						
		ds：段寄存器 先不用管 记住就行				
						
		0x0012FF34:内存编号，必须是32位的  前面0可以省略				
						
		注意：地址编号不要随便写，因为内存是有保护的，并不是所有的内存都可以直接读写(需要特别处理)				
						
		建议地址编号写成esp的值		

```



寻址公式

```
LEA 指令
作用: 取当前内存的地址编号

lea 寄存器,内存地址

LEA EAX,DWORD PTR DS:[0X13FFC4] 内存地址的编号存放到EAX中
将DS:[0X13FFC4] 内存地址的编号存放到EAX中

```



```
	寻址公式一：[立即数]	
		
		
		读取内存的值：
		
		MOV EAX,DWORD PTR DS:[0x13FFC4]
		MOV EAX,DWORD PTR DS:[0x13FFC8]
		
		向内存中写入数据：
		
		MOV DWORD PTR DS:[0x13FFC4],eax
		MOV DWORD PTR DS:[0x13FFC8],ebx
		
		获取内存编号：
		
		LEA EAX,DWORD PTR DS:[0X13FFC4]
		LEA EAX,DWORD PTR DS:[ESP+8]
		
		
	寻址公式二：[reg]  reg代表寄存器 可以是8个通用寄存器中的任意一个	
		
		
		读取内存的值：
		
		MOV ECX,0x13FFD0
		MOV EAX,DWORD PTR DS:[ECX]
		
		向内存中写入数据：
		
		MOV EDX,0x13FFD8
		MOV DWORD PTR DS:[EDX],0x87654321
		
		获取内存编号：
		
		LEA  EAX,DWORD PTR DS:[EDX]
		MOV EAX,DWORD PTR DS:[EDX]
		
		
	寻址公式三：[reg+立即数] 	
		
		读取内存的值：
		
		MOV ECX,0x13FFD0
		MOV EAX,DWORD PTR DS:[ECX+4]
		
		向内存中写入数据：
		
		MOV EDX,0x13FFD8
		MOV DWORD PTR DS:[EDX+0xC],0x87654321
		
		获取内存编号：
		
		LEA  EAX,DWORD PTR DS:[EDX+4]
		MOV EAX,DWORD PTR DS:[EDX+4]
		
		
	寻址公式四：[reg+reg*{1,2,4,8}] 	
		
		
		读取内存的值：
		MOV EAX,13FFC4
		MOV ECX,2
		MOV EDX,DWORD PTR DS:[EAX+ECX*4]
		
		向内存中写入数据：
		MOV EAX,13FFC4
		MOV ECX,2
		MOV DWORD PTR DS:[EAX+ECX*4],87654321
		
		获取内存编号：
		LEA EAX,DWORD PTR DS:[EAX+ECX*4]
		
		
	寻址公式五：[reg+reg*{1,2,4,8}+立即数] 	
		
		
		读取内存的值：
		MOV EAX,13FFC4
		MOV ECX,2
		MOV EDX,DWORD PTR DS:[EAX+ECX*4+4]
		
		向内存中写入数据：
		MOV EAX,13FFC4
		MOV ECX,2
		MOV DWORD PTR DS:[EAX+ECX*4+4],87654321
		
		获取内存编号：
		LEA EAX,DWORD PTR DS:[EAX+ECX*4+2]

```





### 存储模式

大端模式：数据高位在低位，数据低位在高位

小端模式：数据低位在低位，数据高位在高位



| 大端0x12345678 | 小端0x12345678 |    地址    |
| :------------: | :------------: | :--------: |
|       12       |       78       | 0x00000000 |
|       34       |       56       | 0x00000001 |
|       56       |       34       | 0x00000002 |
|       78       |       12       | 0x00000003 |



### DTDEBUG内存窗口的使用

分别以字节/字/双字形式来查看内存（db dw dd）

![image-20231228045203084](/images/javawz/image-20231228045203084.png)





### 基本汇编指令

#### MOV指令

```
MOV 的语法：					
					
1、MOV r/m8,r8 				r 通用寄存器	
					
2、MOV r/m16,r16				m 代表内存	
					
3、MOV r/m32,r32				imm 代表立即数	
					
4、MOV r8,r/m8				r8 代表8位通用寄存器	
					
5、MOV r16,r/m16				m8 代表8位内存	
					
6、MOV r32,r/m32				imm8 代表8位立即数	
					
7、MOV r8, imm8					
					
8、MOV r16, imm16					
					
9、MOV r32, imm32					

```



#### ADD指令

```
ADD AL, imm8 

ADD AX, imm16

ADD EAX, imm32

ADD r/m8, imm8

ADD r/m16,imm16

ADD r/m32,imm32

ADD r/m16, imm8

ADD r/m32, imm8

ADD r/m8, r8

ADD r/m16, r16

ADD r/m32, r32

ADD r8, r/m8

ADD r16, r/m16

ADD r32, r/m32

```





#### SUB指令

减法指令

```
SUB AL, imm8 

SUB AX, imm16

SUB EAX, imm32

SUB r/m8, imm8

SUB r/m16,imm16

SUB r/m32,imm32

SUB r/m16, imm8

SUB r/m32, imm8

SUB r/m8, r8

SUB r/m16, r16

SUB r/m32, r32

SUB r8, r/m8

SUB r16, r/m16

SUB r32, r/m32

```



#### AND 指令

与指令,两个是1才是1,否则是0

```
AND AL, imm8

AND AX, imm16

AND EAX, imm32

AND r/m8, imm8

AND r/m16,imm16

AND r/m32,imm32

AND r/m16, imm8

AND r/m32, imm8

AND r/m8, r8

AND r/m16, r16

AND r/m32, r32

AND r8, r/m8

AND r16, r/m16

AND r32, r/m32

```



#### OR指令

或指令,有一个是1就是1,两个是0就是0

```
OR AL, imm8

OR AX, imm16

OR EAX, imm32

OR r/m8, imm8

OR r/m16,imm16

OR r/m32,imm32

OR r/m16, imm8

OR r/m32, imm8

OR r/m8, r8

OR r/m16, r16

OR r/m32, r32

OR r8, r/m8

OR r16, r/m16

OR r32, r/m32

```



#### XOR指令

异或指令, 两个不一样才是1,否则是0

```
XOR AL, imm8

XOR AX, imm16

XOR EAX, imm32

XOR r/m8, imm8

XOR r/m16,imm16

XOR r/m32,imm32

XOR r/m16, imm8

XOR r/m32, imm8

XOR r/m8, r8

XOR r/m16, r16

XOR r/m32, r32

XOR r8, r/m8

XOR r16, r/m16

XOR r32, r/m32

```



#### NOT 指令

非指令,0变1,1变0

```
NOT r/m8

NOT r/m16

NOT r/m32

```



MOVS指令：移动数据  内存-内存	

移动内存[ESI]]的数据到内存[EDI]中

每复制一次,ESI和EDI都会+1（具体加几或减几要看你一次移动多少个字节）或-1，具体是加还是减要看标志寄存器中DF的值，DF是0就+1，D是1就-1

```
BYTE/WORD/DWORD						
						
MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]					简写为：MOVSB	
						
MOVS WORD PTR ES:[EDI],BYTE PTR DS:[ESI]					简写为：MOVSW	
						
MOVS DWORD PTR ES:[EDI],BYTE PTR DS:[ESI]					简写为：MOVSD	
		

```

![image-20231228060752810](/images/javawz/image-20231228060752810.png)



#### STOS指令：

##### 将Al/AX/EAX的值存储到[EDI]指定的内存单元

```
STOS BYTE PTR ES:[EDI]			简写为STOSB	
				
STOS WORD PTR ES:[EDI]			简写为STOSW	
				
STOS DWORD PTR ES:[EDI]			简写为STOSD	
				
```



![image-20231228062418429](/images/javawz/image-20231228062418429.png)





#### REP指令：

按计数寄存器 (ECX) 中指定的次数重复执行字符串指令	

```
MOV ECX,10	
	
REP MOVSD	
	
REP STOSD	

将内存[esi]中的数据重复ecx次复制到内存[edi]中,每次重复esi和edi都加4
REP MOVS DWORD PTR ES:[EDI],DWORD PTR ES:[ESI]

将EAX中的值重复ECX次复制到内存[EDI]中,每重复一次,edi都加4
REP STOS DWORD PTR ES:[EDI]
```







## 堆栈

查看堆栈的大小

![image-20231228072101553](/images/javawz/image-20231228072101553.png)

![image-20231228072209382](/images/javawz/image-20231228072209382.png)

![image-20231228072142171](/images/javawz/image-20231228072142171.png)



ESP寄存器用来存放当前堆栈使用到哪里的地址





### PUSH指令:

入栈指令

```
1、PUSH r32

2、PUSH r16

3、PUSH m16

4、PUSH m32

5、PUSH imm8/imm16/imm32

```



### POP指令

出栈指令

```
1、POP r32

2、POP r16

3、POP m16

4、POP m32

```



### 通过其他指令实现堆栈的存取

![image-20231228073758951](/images/javawz/image-20231228073758951.png)



```
步骤一：压入数据			
			
			
MOV EBX,13FFDC			BASE
MOV EDX,13FFDC			TOP
			
方式一：			
			
MOV DWORD PTR DS:[EDX-4],0xAAAAAAAA			
SUB EDX,4			
			
方式二：			
			
SUB EDX,4			
MOV DWORD PTR DS:[EDX],0xBBBBBBBB			
			
方式三：			
			
MOV DWORD PTR DS:[EDX-4],0xDDDDDDDD			
LEA EDX,DWORD PTR DS:[EDX-4]			
			
方式四：			
			
LEA EDX,DWORD PTR DS:[EDX-4]			
MOV DWORD PTR DS:[EDX],0xEEEEEEEE			
			
			
			
步骤二：读取第N个数			
			
1、方式一：通过Base加偏移来读取			
			
读第一个压入的数据：			
			
MOV ESI,DWORD PTR DS:[EBX-4]			
			
读第四个压入的数据：			
			
MOV ESI,DWORD PTR DS:[EBX-0x10]			
			
			
2、方式二：通过Top加偏移来读取			
			
读第二个压入的数据：			
			
MOV EDI,DWORD PTR DS:[EDX+4]			
			
读第三个压入的数据：			
			
MOV EDI,DWORD PTR DS:[EDX+8]			
			
步骤三：弹出数据			
			
MOV ECX,DWORD PTR DS:[EDX]			
LEA EDX,DWORD PTR DS:[EDX+4]			
			
MOV ESI,DWORD PTR DS:[EDX]			
ADD EDX,4			
			
LEA EDX,DWORD PTR DS:[EDX+4]			
MOV EDI,DWORD PTR DS:[EDX-4]			
```

