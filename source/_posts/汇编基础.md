---
title: 汇编基础
date: 2023-12-14 17:58:53
tags:
categories: 逆向工程
doc:
---

### 位运算

#### 与运算

![image-20231226032344544](/images/javawz/image-20231226032344544.png)



#### 或运算

![image-20231226032439239](/images/javawz/image-20231226032439239.png)





#### 异或

![image-20231226032458930](/images/javawz/image-20231226032458930.png)



#### 非运算

![image-20231226032523375](/images/javawz/image-20231226032523375.png)



#### 左移

![image-20231226032848211](/images/javawz/image-20231226032848211.png)





#### 右移

各二进位全部右移若干位，低位丢弃，高位补0或者补符号位

shr是无符号的，高位用0补

sar是有符号的，高位用符号位补

在c语言中>>是包含了shr和sar的,怎么区分有符号和无符号要看类型,比如 unsigned int就是无符号的,右移会使用shr



![image-20231226033015280](/images/javawz/image-20231226033015280.png)





### 计算机做加法的过程

4 + 5 = ？

1、4和5，先异或  4xor5

2、4和5进行与运算，得出来的结果判断是否有进位，如果是0就是没有进位，如果是非0就是有进位。最后左移1位

（4 and 5 ）<< 1

3、将步骤1和步骤2的结果异或

4、将步骤1和步骤2的结果相与，判断还有没有进位，如果有则继续重复上述步骤

```
	4------ 0000 0100
	
	5------ 0000 0101
加---------------------------
			0000 1001
			
			
第一步 异或
 		0000 0100

		0000 0101
异或---------------------------
		0000 0001
		
		
第二步 与，判断是否有进位

 		0000 0100

		0000 0101
与---------------------------
		0000 0100

第三步，如果第二步与的结果非0表示有进位，需要左移1位

0000 0100 << 1 = 0000 1000

第四步 继续异或

 		0000 0001

		0000 1000
异或---------------------------
		0000 1001
		

第五步 将第一步和第三步的结果进行与运算判断是否还有进位

 		0000 0001

		0000 1000
与---------------------------
		0000 0000

发现是0 表示没有进位,运算结束

```



4-5=?

4-5 = 4 + (-5)



```
4 + (-5)

4         0000 0100

-5		  1111 1011


1) 异或

		0000 0100
		
		1111 1011
异或---------------------------
		1111 1111
		

2) 判断是否有进位

		0000 0100
		
		1111 1011
与---------------------------
		0000 0000
		
结果是0,没有进位。1111 1111 就是最终结果


```



X / Y 表示 X 可以减去多少次Y



### DTDebug



配置DTDebug

![image-20231226045552087](/images/javawz/image-20231226045552087.png)

![image-20231226045613640](/images/javawz/image-20231226045613640.png)



UDD path和Plugin path 写自己安装目录下的



### 通用寄存器



![image-20231226045728248](/images/javawz/image-20231226045728248.png)

```
MOV 目标操作数，源操作数

mov eax,12
mov eax,ecx

mov ax,12
mov ax,cx

mov ah,ch
mov ah,12

mov al,cl
mov al,2

mov指令 左右两边的操作数必须是等宽的
例如 
ax 和 cx是等宽的
al 和 cl是等宽的
ah 和 cl是等宽的
eax 和 ax不是等宽的,因为eax是32位的,ax是16位的

```



### 内存

![image-20231226050932498](/images/javawz/image-20231226050932498.png)



每个进程都有4G的虚拟内存,当某一块虚拟内存需要用到的时候,会将这块虚拟内存映射到物理内存中,最后物理内存会将这块内存映射到内存条中



```
BYTE　字节　＝　8(BIT)		
WORD  字    =   16(BIT)		
DWORD 双字  =   32(BIT)		
		
1KB = 1024 BYTE		
1MB = 1024 KB 		
1GB = 1024 MB		

```



mov指令使用内存

```
mov 类型 ptr ds:[内存编号],值

mov byte ptr ds:[00A90280],22
mov word ptr ds:[00A90280],22
mov dword ptr ds:[00A90280],22


```



从指定内存中写入/读取数据	

```
		mov dword ptr ds:[0x0012FF34],0x12345678				
						
		mov eax,dword ptr ds:[0x0012FF34]				
						
		dword ：要读/写多少  此时是4字节   byte == 1字节  word == 2字节				
						
		ptr: Point 代表后面是一个指针 (指针的意思就是里面存的不是普通的值，而是个地址)				
						
		ds：段寄存器 先不用管 记住就行				
						
		0x0012FF34:内存编号，必须是32位的  前面0可以省略				
						
		注意：地址编号不要随便写，因为内存是有保护的，并不是所有的内存都可以直接读写(需要特别处理)				
						
		建议地址编号写成esp的值		

```



寻址公式

```
LEA 指令
作用: 取当前内存的地址编号

lea 寄存器,内存地址

LEA EAX,DWORD PTR DS:[0X13FFC4] 内存地址的编号存放到EAX中
将DS:[0X13FFC4] 内存地址的编号存放到EAX中

```



```
	寻址公式一：[立即数]	
		
		
		读取内存的值：
		
		MOV EAX,DWORD PTR DS:[0x13FFC4]
		MOV EAX,DWORD PTR DS:[0x13FFC8]
		
		向内存中写入数据：
		
		MOV DWORD PTR DS:[0x13FFC4],eax
		MOV DWORD PTR DS:[0x13FFC8],ebx
		
		获取内存编号：
		
		LEA EAX,DWORD PTR DS:[0X13FFC4]
		LEA EAX,DWORD PTR DS:[ESP+8]
		
		
	寻址公式二：[reg]  reg代表寄存器 可以是8个通用寄存器中的任意一个	
		
		
		读取内存的值：
		
		MOV ECX,0x13FFD0
		MOV EAX,DWORD PTR DS:[ECX]
		
		向内存中写入数据：
		
		MOV EDX,0x13FFD8
		MOV DWORD PTR DS:[EDX],0x87654321
		
		获取内存编号：
		
		LEA  EAX,DWORD PTR DS:[EDX]
		MOV EAX,DWORD PTR DS:[EDX]
		
		
	寻址公式三：[reg+立即数] 	
		
		读取内存的值：
		
		MOV ECX,0x13FFD0
		MOV EAX,DWORD PTR DS:[ECX+4]
		
		向内存中写入数据：
		
		MOV EDX,0x13FFD8
		MOV DWORD PTR DS:[EDX+0xC],0x87654321
		
		获取内存编号：
		
		LEA  EAX,DWORD PTR DS:[EDX+4]
		MOV EAX,DWORD PTR DS:[EDX+4]
		
		
	寻址公式四：[reg+reg*{1,2,4,8}] 	
		
		
		读取内存的值：
		MOV EAX,13FFC4
		MOV ECX,2
		MOV EDX,DWORD PTR DS:[EAX+ECX*4]
		
		向内存中写入数据：
		MOV EAX,13FFC4
		MOV ECX,2
		MOV DWORD PTR DS:[EAX+ECX*4],87654321
		
		获取内存编号：
		LEA EAX,DWORD PTR DS:[EAX+ECX*4]
		
		
	寻址公式五：[reg+reg*{1,2,4,8}+立即数] 	
		
		
		读取内存的值：
		MOV EAX,13FFC4
		MOV ECX,2
		MOV EDX,DWORD PTR DS:[EAX+ECX*4+4]
		
		向内存中写入数据：
		MOV EAX,13FFC4
		MOV ECX,2
		MOV DWORD PTR DS:[EAX+ECX*4+4],87654321
		
		获取内存编号：
		LEA EAX,DWORD PTR DS:[EAX+ECX*4+2]

```

