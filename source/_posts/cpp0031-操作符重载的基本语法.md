---
title: 操作符重载的基本语法
date: 2021-05-11 00:24:14
tags:
categories: c++
doc:
---

# 操作符重载的基本语法

所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋
予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的
函数，也就是”一名多用”。<br/>

运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重
载。例如，大家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行
加法运算，如5+8，5.8+3.67等，其实计算机对整数、单精度数和双精度数的
加法操作过程是很不相同的，但由于C++已经对运算符”+”进行了重载，所以就能适用于int,float,
double类型的运算。

<br/>又如”<<“是C++的位运算中的位移运算符（左移），但在输出操作中又是与流对象cout配合使用的流插入运算符，”>>“也是位移运算符(右移），但在输入操作中又是与流对象cin配合使用的流提取运算符。这就是运算符重载(operator overloading)。C++系统对”<<“和”>>“进行了重载，用户在不同的场合下
使用它们时，作用是不同的。对”<<“和”>>“的重载处理是放在头文件stream中的。因此，如果要在程序中用”<<“和”>>”作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。
现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用.

`运算符重载的本质是函数重载。`

### 重载函数的一般格式如下:

![1620664783011](/images/javawz/1620664783011.png)

operator 运算符名称 在一起构成了新的函数名。比如

![1620664830303](/images/javawz/1620664830303.png)

我们会说,operator+ 重载了运算符+。

### 友元重载

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>


using namespace std;

class A
{
public:
	A();
	A(int ta,int tb);
	~A();
	void print();
	//友元重载(全局重载函数)
	friend const A & operator+(const A &ta1, const A &ta2);
	int getA() {
		return a;
	}
	int getB() {
		return b;
	}
private:
	int a;
	int b;
};

void A::print() {
	cout << a << endl;
	cout << b << endl;
}
A::A(int ta,int tb) {
	a = ta;
	b = tb;
}
A::A()
{
}

A::~A()
{
}
//友元重载(全局重载函数)
const A & operator+(const A &ta1,const A &ta2) {

	return A(ta1.a + ta2.a,ta1.b + ta2.b);
}
int main(char *argv[], int argc)
{
	A a1(1,2);
	A a2(3, 4);
	A a3 = a1 + a2;
    //operator+(a1,a2);
	a3.print();
	return 0;
}

```

### 成员重载

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>


using namespace std;

class A
{
public:
	A();
	A(int ta, int tb);
	~A();
	void print();
	//成员操作符重载函数
	const A operator+(const A & anotherA);
	int getA() {
		return a;
	}
	int getB() {
		return b;
	}
private:
	int a;
	int b;
};

//成员操作符重载函数
const A A::operator+(const A & anotherA)
{
	return A(this->a + anotherA.a, this->b + anotherA.b);
}
void A::print() {
	cout << a << endl;
	cout << b << endl;
}
A::A(int ta, int tb) {
	a = ta;
	b = tb;
}
A::A()
{
}

A::~A()
{
}

int main(char *argv[], int argc)
{
	A a1(1, 2);
	A a2(3, 4);
	A a3 = a1 + a2;
	//a3 = a1.operator+(a2);
	a3.print();
	return 0;
}

```

![1620666124186](/images/javawz/1620666124186.png)