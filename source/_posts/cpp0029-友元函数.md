---
title: 友元函数
date: 2021-05-10 23:10:16
tags:
categories: c++
doc:
---

# 友元函数

采用类的机制后实现了数据的隐藏与封装,类的数据成员一般定义为私有成
员,成员函 数一般定义为公有的,依此提供类与外界间的通信接口。但是,有时需
要定义一些函数,这 些函数不是类的一部分,但又需要频繁地访问类的数据成员,
这时可以将这些函数定义为该 函数的友元函数。除了友元函数外,还有友元类,
两者统称为友元。友元的作用是提高了程 序的运行效率(即减少了类型检查和
安全性检查等都需要时间开销),但它破坏了类的封装 性和隐藏性,使得非成员函
数可以访问类的私有成员。
友元可以是一个函数,该函数被称为友元函数;友元也可以是一个类,该类被
称为友元 类。



![1620659557510](/images/javawz/1620659557510.png)



友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外
的普通函 数,它不属于任何类,但需要在类的定义中加以声明,声明时只需在友元
的名称前加上 关键字 friend,其格式如下:

![1620659630409](/images/javawz/1620659630409.png)

##### 一个函数可以是多个类的友元函数,只需要在各个类中分别声明。

### 全局函数作友元函数

```cpp

#include<iostream>


using namespace std;

class Test
{
public:
	Test();
	~Test();
	friend int getA(Test & t1);
	friend int getB(Test & t1);
private:
	int a;
	int b;
};

Test::Test()
{
	a = 10;
	b = 20;
}

Test::~Test()
{
}

//通过友元函数访问对象私有成员
int getA(Test & t1) {
	return t1.a;
}
//通过友元函数访问对象私有成员
int getB(Test & t1) {

	return t1.b;
}

int main(char *argv[], int argc)
{
	Test t1;
	cout << getA(t1) << endl;
	cout << getB(t1) << endl;

	return 0;
}

```

### 类成员函数作友元函数



```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>


using namespace std;
//前向声明,是一种不完全型声明,即只需提供类名(无需提供类实现)即可。仅可⽤于声明指针和引用。
class Student;
class Teacher
{
public:
	Teacher();
	~Teacher();
	void print(Student & s)const;
private:

};

class Student
{
public:
	Student();
	~Student();
	//用Teacher类的成员函数做友元
	friend void Teacher::print(Student & s)const;
private:
	char name[50];
	int xueHao;
};


void Teacher::print(Student & s) const
{
	cout << s.name << endl;
	cout << s.xueHao << endl;
}
Teacher::Teacher()
{
}

Teacher::~Teacher()
{
}

Student::Student()
{
	strcpy(name,"XiaoMing");
	xueHao = 10001;
}

Student::~Student()
{
}



int main(char *argv[], int argc)
{
	Student s;
	Teacher t;
	t.print(s);

	return 0;
}

```

