---
title: 树和二叉树
date: 2022-04-04 22:07:32
tags:
categories: cpp
doc:
---

## 树基本概念

![image-20220405195856497](/images/javawz/image-20220405195856497.png)

树的定义：

由一个或多个(n≥0)结点组成的有限集合T，有且仅有一个结点称为根（root），当n>1时，其余的结点分为**m(m≥0)个互不相交的有限集合**T1,T2，…，Tm。每个集合本身又是棵树，被称作这个根的子树 。

- 树的结构特点
  -  非线性结构，有一个直接前驱，但可能有多个直接后继（1:n）
  -  树的定义具有递归性，树中还有树。
  -  树可以为空，即节点个数为0。

- 若干术语
  - 根 -> 即根结点(没有前驱)
  - 叶子 -> 即终端结点(没有后继)
  - 森林 -> 指m棵不相交的树的集合(例如删除A后的子树个数)
  - 有序树 -> 结点各子树从左至右有序，不能互换（左为第一）
  - 无序树 -> 结点各子树可互换位置。
  - 双亲 -> 即上层的那个结点(直接前驱) parent
  - 孩子 -> 即下层结点的子树 (直接后继) child
  - 兄弟 -> 同一双亲下的同层结点（孩子之间互称兄弟）sibling
  - 堂兄弟 -> 即双亲位于同一层的结点（但并非同一双亲）cousin
  - 祖先 -> 即从根到该结点所经分支的所有结点
  - 子孙 -> 即该结点下层子树中的任一结点

  ![image-20220405200058191](/images/javawz/image-20220405200058191.png)
  - 结点 -> 即树的数据元素                        
  - 结点的度 -> 结点挂接的子树数（有几个直接后继就是几度）
  - 结点的层次 -> 从根到该结点的层数（根结点算第一层）  
  - 终端结点 -> 即度为0的结点，即叶子       
  - 分支结点 -> 除树根以外的结点（也称为内部结点）
  - 树的度 -> 所有结点度中的最大值（Max{各结点的度}）     
  - 树的深度(或高度) -> 指所有结点中最大的层数（Max{各结点的层次}）
  - 上图中的结点数＝ 13，树的度＝ 3，树的深度＝ 4

## 树的表示法

### 图形表示法

**事物之间的逻辑关系**可以通过数的形式很直观的表示出来，如下图：

![image-20220405200248743](/images/javawz/image-20220405200248743.png)

### 广义表表示法

![image-20220405200307911](/images/javawz/image-20220405200307911.png)

用广义表表示法表示上图：

中国（河北（保定，石家庄），广东（广州，东莞），山东（青岛，济南））

**根作为由子树森林组成的表的名字写在表的左边**

### 左孩子右兄弟表示法

![image-20220405200422721](/images/javawz/image-20220405200422721.png)

左孩子右兄弟表示法可以将一颗多叉树转化为一颗二叉树：

![image-20220405200439643](/images/javawz/image-20220405200439643.png)



## 二叉树概念

### 基本概念

- 定义

n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成 。

- 逻辑结构

一对二（1：2） 

- 基本特征:
  - 每个结点最多只有两棵子树（**不存在度大于2的结点**）；
  - 左子树和右子树次序不能颠倒（**有序树**）。

- 基本形态：

![image-20220405200902582](/images/javawz/image-20220405200902582.png)

- 二叉树性质
  -  性质1: 在二叉树的第i层上至多有2<sup>i</sup>>-1个结点（i>0）
  -  性质2: 深度为k的二叉树至多有2<sup>k</sup>-1个结点（k>0）
  - 性质3: 对于任何一棵二叉树，若2度的结点数有n2个，则叶子数（n0）必定为n2＋1 （即n0=n2+1）

![img](/images/javawz/wps41A8.tmp.png)概念解释：

-  **满二叉树**
  - 一棵深度为k 且有2<sup>k</sup> -1个结点的二叉树。

​     **特点：每层都“充满”了结点**

![image-20220405201353966](/images/javawz/image-20220405201353966.png)

**完全二叉树**

深度为k 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k 的满二叉树中编号从1至n的结点一一对应。

![image-20220405201428010](/images/javawz/image-20220405201428010.png)

**理解：k-1层与满二叉树完全相同，第k层结点尽力靠左**

- 性质4: 具有n个结点的完全二叉树的深度必为[log<sub>2</sub>n] + 1

- **性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）**

![image-20220405201708193](/images/javawz/image-20220405201708193.png)

使用此性质可以使用完全二叉树实现树的顺序存储。

如果不是完全二叉树咋整???

------ 将其转换成完全二叉树即可



### 二叉树的表示

- 二叉链表示法
  - 存储结构

![image-20220405201828550](/images/javawz/image-20220405201828550.png)

结点数据类型定义：

```
typedef struct BiTNode
{
	int		data;
	struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```

#### 三叉链表表示法

- 存储结构

  ![image-20220405202021310](/images/javawz/image-20220405202021310.png)

每个节点有三个指针域，其中两个分别指向子节点（左孩子，右孩子），还有一共指针指向该节点的父节点。

- 节点数据类型定义

```
//三叉链表
typedef struct TriTNode 
{
	int data;
	//左右孩子指针
	struct TriTNode *lchild, *rchild;
	struct TriTNode *parent;
}TriTNode, *TriTree;
```

### 二叉树的遍历

- 遍历定义

指按某条搜索路线**遍访每个结点且不重复**（又称周游）。

-  遍历用途

它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。  

- 遍历方法

牢记一种约定，**对每个结点的查看都是“先左后右”** 。

限定先左后右，树的遍历有三种实现方案：

   **D**LR         L**D**R         LR**D**

**先** (**根**)序遍历    **中** (**根**)序遍历     **后**(**根**)序遍历 

 **DLR** **— 先序遍历，即先根再左再右**

 **LDR** **— 中序遍历，即先左再根再右**

 **LRD** **— 后序遍历，即先左再右再根**

**注：“先、中、后”的意思是指访问的结点D是先于子树出现还是后于子树出现。**

### 树的遍历，代码实现：

#### 先序遍历

```
PreOrder(NODE *root )
{  
    if (root) //非空二叉树
    {
		printf(“%d”,root->data); //访问D
		PreOrder(root->lchild); //递归遍历左子树
		PreOrder(root->rchild); //递归遍历右子树
    }
}
```

#### 中序遍历

```
InOrder(NODE *root)
{ 
	if(root !=NULL)
 	 {  
		InOrder(root->lchild);
      	printf(“%d”,root->data);
      	InOrder(root->rchild); 
 	 } 
}
```

### 后序遍历

```
PostOrder(NODE *root)
{
	if(root !=NULL) 
   {
		PostOrder(root->lchild);
        PostOrder(root->rchild);
        printf(“%d”,root->data); 
   } 
}
```

树的遍历，本质剖析：

从前面的三种遍历算法可以知道：如果将printf语句抹去，

```
//除去printf的遍历算法：
XXX (NODE *root)
{  
	if(root) 
   {
		XXX(root->lchild);
        XXX(root->rchild);
   }
}
```

**从递归的角度看，这三种算法是完全相同的，或者说这三种遍历**

**算法的访问路径是相同的，只是访问结点的时机不同。**

![image-20220405202919416](/images/javawz/image-20220405202919416.png)

从虚线的出发点到终点的路径上，每个结点经过3次。

​	从虚线的出发点到终点的路径上，每个结点经过3次。

- **第1次经过时访问＝先序遍历**
- **第2次经过时访问＝中序遍历**
- **第3次经过时访问＝后序遍历**



```c
typedef struct BITREENODE {
	char data;
	BITREENODE * lTreeNode;
	BITREENODE * rTreeNode;
}Bitreenode;

typedef struct STACKNODE {
	Bitreenode * node;
	int flag;
}Stacknode;
```



### 计算二叉树中叶子结点的数目

```c
void GetTreeNumNode(Bitreenode * root,int * num)
{
	if (root == NULL)
	{
		return;
	}

	if (root->lTreeNode == NULL && root->rTreeNode == NULL)
	{
		(*num)++;
	}
	GetTreeNumNode(root->lTreeNode, num);
	GetTreeNumNode(root->rTreeNode, num);
}
```

### 求二叉树的深度

```c
int GetBitreeHeigth(Bitreenode * root) {

	int lHeight, rHeight;

	if (root == NULL)
	{
		return 0;
	}
	lHeight = GetBitreeHeigth(root->lTreeNode);
	rHeight = GetBitreeHeigth(root->rTreeNode);

	return lHeight > rHeight ? lHeight + 1 : rHeight + 1;
}
```

### Copy二叉树 

```c
Bitreenode * CopyBiTree(Bitreenode * root) {
	if (root == NULL)
	{
		return NULL;
	}

	Bitreenode * newNode = (Bitreenode *)malloc(sizeof(Bitreenode));
	newNode->data = root->data;
	newNode->lTreeNode = CopyBiTree(root->lTreeNode);
	newNode->rTreeNode = CopyBiTree(root->rTreeNode);

	return newNode;
}
```

### 树的非递归遍历

第一步:先将根节点和标识打包在一起组成一个新结点

![image-20220405204352868](/images/javawz/image-20220405204352868.png)

第二步:把刚刚打包的新结点压入栈



第三步:循环,如果栈元素大于0则继续循环

第四步: 取出栈顶元素

第五步:判断栈顶元素中的树节点是否为NULL,如果是则跳出本次循环

第六步: 判断标识是否为MYTRUE,如果是则打印当前结点信息,否则如果标识是MYFALSE则将标识改为MYTRUE,然后将本结点的左右两个结点压入栈,最后把自己压入栈中

#### 入栈顺序

![image-20220405210112413](/images/javawz/image-20220405210112413.png)



```
typedef struct STACKNODE {
	Bitreenode * node;
	int flag;
}Stacknode;


Stacknode * NewStackNode(Bitreenode * node,int flag) {

	Stacknode * newNode = (Stacknode *)malloc(sizeof(Stacknode));
	newNode->node = node;
	newNode->flag = MYFLASE;

	return newNode;
}


void FeiDiGuiBianLi(Bitreenode * root) {
	if (root == NULL)
	{
		return;
	}

	stack<Stacknode *> my_stack;
	my_stack.push(NewStackNode(root,MYFLASE));

	while (my_stack.size() > 0)
	{
		Stacknode * node = my_stack.top();
		my_stack.pop();
		if (node->node == NULL)
		{
			continue;
		}
		if (node->flag == MYTRUE)
		{
			cout << node->node->data << " ";
		}
		else {
			node->flag = MYTRUE;
			my_stack.push(node);
			my_stack.push(NewStackNode(node->node->rTreeNode,MYFLASE));
			my_stack.push(NewStackNode(node->node->lTreeNode, MYFLASE));
			
		}

	}
}
```





###  二叉树的创建

如何才能确定一棵树？

结论：	

**通过中序遍历和先序遍历可以确定一个树**

通过中序遍历和后续遍历可以确定一个树

通过先序遍历和后序遍历确定不了一个树。

**单独先序遍历：能求解根，但不能求解左子树什么时候结束、右子树什么时候开始。**





### #号法创建树

1、什么是#号法创建树

\#创建树，让树的每一个节点都变成度数为2的树

先序遍历结果: 124###3##

![image-20220405210423895](/images/javawz/image-20220405210423895.png)

\#号法编程实践

```
Bitreenode * CreateBiTree2()
{
	Bitreenode * T;
	char ch;
	char a;
	scanf("%c",&ch);
	while (( a = getchar()) != '\n');
	if (ch =='#') {
		T = NULL;
	}
	else
	{
		T = (Bitreenode *)malloc(sizeof(Bitreenode));
		T->data = ch;
		T->lTreeNode = CreateBiTree2();
		T->rTreeNode = CreateBiTree2();
	}
	return T;
}
```



### 释放树

```
void FreeBiTree(Bitreenode * root)
{
	if (root == NULL)
	{
		return;
	}
	
	FreeBiTree(root->lTreeNode);
	FreeBiTree(root->rTreeNode);
	free(root);


}
```

