---
title: 类的赋值兼容原则
date: 2021-05-13 00:44:09
tags:
categories: cpp
doc:
---

# 类的赋值兼容原则

### 类型兼容性原则

类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类
的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之
外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能
解决的问题，公有派生类都可以解决。

#### 类型兼容规则中所指的替代包括以下情况：

![1620837955527](/images/javawz/1620837955527.png)

![1620837966956](/images/javawz/1620837966956.png)

在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继
承的成员。

```cpp
#define  _CRT_SECURE_NO_WARNINGS 
#include <iostream>

using namespace std;

/*
子类对象可以当作父类对象使用
子类对象可以直接赋值给父类对象
子类对象可以直接初始化父类对象
父类指针可以直接指向子类对象
父类引用可以直接引用子类对象
*/

class Parent
{
public:
	void printP()
	{
		cout << "Parent::printP()..." << endl;
	}
	int a;
};

class Child :public Parent
{
public:
	void printC()
	{
		cout << "Child:: printC()...." << endl;
	}
	int b;
};

void print(Parent *p)
{
	p->printP();
}

int main(void)
{
	Child c;//子类对象
	c.printP(); //子类对象可以当作父类对象使用

	Parent p = c; // 由于子类拥有全部父类的内存空间，子类能够保障父类初始化完整。
						 //子类对象可以直接初始化父类对象 因为子类内存空间包容的父类的，能够保证
						// 完全赋值。
	//Child c2 = p;

	
	//父类指针可以直接指向子类对象
	//子类对象能够完全满足父类指针的需求，所以可以  父类指针可以直接指向子类对象
	Parent *pp = &c;  //pp->printP   (x ) pp->printC
	//pp->printC();
	pp->a;

	//不能用子类指针指向父类对象。
	//父类对象满足不了子类指针的所有需求， 所以不能够 子类指针指向父类对象。
	//Child *cp = &p; // cp-> printP,  cp->printC
	//cp->b; //p中没有b的内存。 //此时访问b就越界了。
	//cp->printP();
	//cp->printC();

	//父类引用可以引用子类对象
	Parent &pr = c;

	//子类引用不可以引用父类的对象。
	//Child &cr = p;

	print(&p); //Parent* p = &p;

	print(&c); //Parent *p = &c;

	//父类指针可以指向子类对象。 

	return 0;
}
```

