---
title: 常用的查找算法
date: 2021-07-25 02:33:46
tags:
categories: c++
doc:
---

#### adjacent_find()

#### binary_search()

#### binary_search()

#### count()

#### count_if()

#### find()

#### find_if()



#### adjacent_find()

在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。否则返回past-the-end。

```
vector<int> vecInt;

​     vecInt.push_back(1);

​     vecInt.push_back(2);

​     vecInt.push_back(2);

​     vecInt.push_back(4);

​     vecInt.push_back(5);

vecInt.push_back(5);

 

​     vector<int>::iterator it = adjacent_find(vecInt.begin(), vecInt.end());       //*it == 2
```



#### binary_search

在有序序列中查找value,找到则返回true。注意：在无序序列中，不可使用。

 

   

```
       set<int> setInt;

​          setInt.insert(3);

​          setInt.insert(1);

​          setInt.insert(7);

​          setInt.insert(5);

​          setInt.insert(9);

 

​          bool bFind = binary_search(setInt.begin(),setInt.end(),5);
```



#### count()

利用等于操作符，把标志范围内的元素与输入值比较，返回相等的个数。

```
vector<int> vecInt;

​          vecInt.push_back(1);

​          vecInt.push_back(2);

​          vecInt.push_back(2);

​          vecInt.push_back(4);

​          vecInt.push_back(2);

​          vecInt.push_back(5);

​          int iCount = count(vecInt.begin(),vecInt.end(),2);  //iCount==3

​     
```



#### count_if() 

假设vector\<int> vecIntA，vecIntA包含1,3,5,7,9元素

 

```
//先定义比较函数

bool GreaterThree(int iNum)

{

​          if(iNum>=3)

​          {

​              return true;

​          }

​          else

​          {

​              return false;

​          }

}

 

int iCount = count_if(vecIntA.begin(), vecIntA.end(), GreaterThree);

//此时iCount == 4
```



#### find() 

find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的迭代器。

equal_range:  返回一对iterator，第一个表示lower_bound,第二个表示upper_bound。

 

```
vector<int> vecInt;

​          vecInt.push_back(1);

​          vecInt.push_back(3);

​          vecInt.push_back(5);

​          vecInt.push_back(7);

​          vecInt.push_back(9);

 

vector<int>::iterator it = find(vecInt.begin(), vecInt.end(), 5);         //*it == 5
```



#### find_if()

find_if:  使用输入的函数代替等于操作符执行find。返回被找到的元素的迭代器。

假设vector\<int> vecIntA，vecIntA包含1,3,5,3,9元素 

`vector<int>::it = find_if(vecInt.begin(),vecInt.end(),GreaterThree);`

此时` *it==3, *(it+1)==5, *(it+2)==3, *(it+3)==9`

 



```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

void test_adjacent_find()
{
	vector<int> v;
	v.push_back(0);
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	v.push_back(3);
	v.push_back(5);
	//在iterator对标识元素范围内，
	//查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。否则返回past-the-end。
	vector<int>::iterator it =  adjacent_find(v.begin(), v.end());
	cout << "*it: " << *it << endl;
	cout << "distance: " << distance(v.begin(),it) << endl;
}

void test_binary_search() {
	vector<int> v;
	v.push_back(0);
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	v.push_back(3);
	v.push_back(5);
	v.push_back(-1);

	//需要先排序
	if (binary_search(v.begin(), v.end(), 5))
	{
		cout << "yes" << endl;
	}
	else
	{
		cout << "no" << endl;
	}
	
}

void test_count() {

	vector<int> v;
	v.push_back(0);
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	v.push_back(3);
	v.push_back(5);
	v.push_back(-1);

	cout << "count: " << count(v.begin(), v.end(), 3) << endl;
}

bool Com(int x) {
	if (x > 3) {
		return true;
	}
	return false;
}

void test_countif() {
	vector<int> v;
	v.push_back(0);
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	v.push_back(3);
	v.push_back(5);
	v.push_back(-1);

	cout << "count_if: " << count_if(v.begin(), v.end(), Com) << endl;

}

void test_find() {
	vector<int> v;
	v.push_back(0);
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	v.push_back(3);
	v.push_back(5);
	v.push_back(-1);

	vector<int>::iterator it = find(v.begin(),v.end(),-1);

	cout << "*it: " << *it << endl;
	cout << "distance: " << distance(v.begin(),it) << endl;

}
class ComP {
public:

	bool operator()(int x) {
		if (x > 3)
		{
			return true;
		}
		return false;
	}
private:

};

void test_findif() {
	vector<int> v;
	v.push_back(0);
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	v.push_back(3);
	v.push_back(5);
	v.push_back(-1);

	cout << "find_if: " << *(find_if(v.begin(), v.end(), ComP())) << endl;

}
int main(char *argv[], int argc)
{
	test_adjacent_find();
	test_binary_search();
	test_count();
	test_countif();
	test_find();
	test_findif();
	return 0;
}

```

